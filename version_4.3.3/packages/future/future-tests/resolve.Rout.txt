
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:33:57.246] plan(): Setting new future strategy stack:
[10:33:57.246] List of future strategies:
[10:33:57.246] 1. sequential:
[10:33:57.246]    - args: function (..., envir = parent.frame())
[10:33:57.246]    - tweaked: FALSE
[10:33:57.246]    - call: future::plan("sequential")
[10:33:57.259] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> strategies <- supportedStrategies()
> 
> message("*** resolve() ...")
*** resolve() ...
> 
> message("*** resolve() for default ...")
*** resolve() for default ...
> 
> x <- 1
> y <- resolve(x)
> stopifnot(identical(y, x))
> 
> message("*** resolve() for default ... DONE")
*** resolve() for default ... DONE
> 
> 
> for (strategy in strategies) {
+   message(sprintf("- plan('%s') ...", strategy))
+   plan(strategy)
+ 
+   if (strategy == "multisession" && availableCores() >= 2) {
+     message("*** resolve() for Future objects ...")
+     
+     for (result in c(FALSE, TRUE)) {
+       for (recursive in list(FALSE, TRUE, -1, 0, 1, 2, Inf)) {
+         message(sprintf("- result = %s, recursive = %s ...", result, recursive))
+       
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         })
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         }, lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message("- w/ exception ...")
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")))
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")), lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message(sprintf("- result = %s, recursive = %s ... DONE", result, recursive))
+       } ## for (resolve ...)
+     } ## for (result ...)
+     
+     message("*** resolve() for Future objects ... DONE")
+   } ## if (strategy == "multisession" && availableCores() >= 2)
+   
+   message("*** resolve() for lists ...")
+ 
+   x <- list()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2, lazy = TRUE)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future({Sys.sleep(0.5); 2})
+   x[[4]] <- 4
+   dim(x) <- c(2, 2)
+   y <- resolve(x, idxs = 1)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[1]]))
+   y <- resolve(x, idxs = 2)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[2]]))
+   y <- resolve(x, idxs = 3)
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = seq_along(x))
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = names(x))
+   stopifnot(identical(y, x))
+ 
+   y <- resolve(x, idxs = matrix(c(1, 2), ncol = 2L), result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk })
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk }, lazy = TRUE)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+ 
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   x <- list(1, 2)
+   res <- tryCatch(x <- resolve(x, idxs = "a"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for lists ... DONE")
+ 
+ 
+   message("*** resolve() for environments ...")
+ 
+   x <- new.env()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- new.env()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+ 
+   x <- new.env()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x$b))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a <- future({ 1 })
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "c")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for environments ... DONE")
+ 
+ 
+   message("*** resolve() for list environments ...")
+ 
+   x <- listenv()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- 1
+   x$b <- 2
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   names <- names(x)
+   dim(x) <- c(1, 3)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$a, mustExist = FALSE)))
+   #stopifnot(is.na(futureOf(x$b, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a <- future({ 1 })
+   x$b %<-% { Sys.sleep(0.5); 2 }
+   x$c %<-% { 3 }
+   x$d <- 4
+   names <- names(x)
+   dim(x) <- c(2, 2)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(identical(futureOf(x$a, mustExist = FALSE), x$a))
+   stopifnot(resolved(x$a))
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   idxs <- matrix(c(1, 2), ncol = 2L)
+   y <- resolve(x, idxs = idxs)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$c, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = 4L)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x[[4L]], mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for list environments ... DONE")
+ 
+   message(sprintf("- plan('%s') ...", strategy))
+ } ## for (strategy ...)
- plan('sequential') ...
[10:33:57.443] plan(): Setting new future strategy stack:
[10:33:57.443] List of future strategies:
[10:33:57.443] 1. sequential:
[10:33:57.443]    - args: function (..., envir = parent.frame())
[10:33:57.443]    - tweaked: FALSE
[10:33:57.443]    - call: plan(strategy)
[10:33:57.454] plan(): nbrOfWorkers() = 1
*** resolve() for lists ...
[10:33:57.455] resolve() on list ...
[10:33:57.455]  recursive: 0
[10:33:57.455]  length: 2
[10:33:57.455]  elements: ‘a’, ‘b’
[10:33:57.455]  length: 1 (resolved future 1)
[10:33:57.455]  length: 0 (resolved future 2)
[10:33:57.455] resolve() on list ... DONE
[10:33:57.456] getGlobalsAndPackages() ...
[10:33:57.456] Searching for globals...
[10:33:57.459] 
[10:33:57.459] Searching for globals ... DONE
[10:33:57.459] - globals: [0] <none>
[10:33:57.459] getGlobalsAndPackages() ... DONE
[10:33:57.460] run() for ‘Future’ ...
[10:33:57.460] - state: ‘created’
[10:33:57.460] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:57.460] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:57.460] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:57.460]   - Field: ‘label’
[10:33:57.460]   - Field: ‘local’
[10:33:57.461]   - Field: ‘owner’
[10:33:57.461]   - Field: ‘envir’
[10:33:57.461]   - Field: ‘packages’
[10:33:57.461]   - Field: ‘gc’
[10:33:57.461]   - Field: ‘conditions’
[10:33:57.461]   - Field: ‘expr’
[10:33:57.461]   - Field: ‘uuid’
[10:33:57.461]   - Field: ‘seed’
[10:33:57.461]   - Field: ‘version’
[10:33:57.461]   - Field: ‘result’
[10:33:57.461]   - Field: ‘asynchronous’
[10:33:57.462]   - Field: ‘calls’
[10:33:57.462]   - Field: ‘globals’
[10:33:57.462]   - Field: ‘stdout’
[10:33:57.462]   - Field: ‘earlySignal’
[10:33:57.462]   - Field: ‘lazy’
[10:33:57.462]   - Field: ‘state’
[10:33:57.462] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:57.462] - Launch lazy future ...
[10:33:57.463] Packages needed by the future expression (n = 0): <none>
[10:33:57.463] Packages needed by future strategies (n = 0): <none>
[10:33:57.464] {
[10:33:57.464]     {
[10:33:57.464]         {
[10:33:57.464]             ...future.startTime <- base::Sys.time()
[10:33:57.464]             {
[10:33:57.464]                 {
[10:33:57.464]                   {
[10:33:57.464]                     base::local({
[10:33:57.464]                       has_future <- base::requireNamespace("future", 
[10:33:57.464]                         quietly = TRUE)
[10:33:57.464]                       if (has_future) {
[10:33:57.464]                         ns <- base::getNamespace("future")
[10:33:57.464]                         version <- ns[[".package"]][["version"]]
[10:33:57.464]                         if (is.null(version)) 
[10:33:57.464]                           version <- utils::packageVersion("future")
[10:33:57.464]                       }
[10:33:57.464]                       else {
[10:33:57.464]                         version <- NULL
[10:33:57.464]                       }
[10:33:57.464]                       if (!has_future || version < "1.8.0") {
[10:33:57.464]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:57.464]                           "", base::R.version$version.string), 
[10:33:57.464]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:57.464]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:57.464]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:57.464]                             "release", "version")], collapse = " "), 
[10:33:57.464]                           hostname = base::Sys.info()[["nodename"]])
[10:33:57.464]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:57.464]                           info)
[10:33:57.464]                         info <- base::paste(info, collapse = "; ")
[10:33:57.464]                         if (!has_future) {
[10:33:57.464]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:57.464]                             info)
[10:33:57.464]                         }
[10:33:57.464]                         else {
[10:33:57.464]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:57.464]                             info, version)
[10:33:57.464]                         }
[10:33:57.464]                         base::stop(msg)
[10:33:57.464]                       }
[10:33:57.464]                     })
[10:33:57.464]                   }
[10:33:57.464]                   ...future.strategy.old <- future::plan("list")
[10:33:57.464]                   options(future.plan = NULL)
[10:33:57.464]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:57.464]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:57.464]                 }
[10:33:57.464]                 ...future.workdir <- getwd()
[10:33:57.464]             }
[10:33:57.464]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:57.464]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:57.464]         }
[10:33:57.464]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:57.464]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:57.464]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:57.464]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:57.464]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:57.464]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:57.464]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:57.464]             base::names(...future.oldOptions))
[10:33:57.464]     }
[10:33:57.464]     if (FALSE) {
[10:33:57.464]     }
[10:33:57.464]     else {
[10:33:57.464]         if (TRUE) {
[10:33:57.464]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:57.464]                 open = "w")
[10:33:57.464]         }
[10:33:57.464]         else {
[10:33:57.464]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:57.464]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:57.464]         }
[10:33:57.464]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:57.464]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:57.464]             base::sink(type = "output", split = FALSE)
[10:33:57.464]             base::close(...future.stdout)
[10:33:57.464]         }, add = TRUE)
[10:33:57.464]     }
[10:33:57.464]     ...future.frame <- base::sys.nframe()
[10:33:57.464]     ...future.conditions <- base::list()
[10:33:57.464]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:57.464]     if (FALSE) {
[10:33:57.464]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:57.464]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:57.464]     }
[10:33:57.464]     ...future.result <- base::tryCatch({
[10:33:57.464]         base::withCallingHandlers({
[10:33:57.464]             ...future.value <- base::withVisible(base::local(1))
[10:33:57.464]             future::FutureResult(value = ...future.value$value, 
[10:33:57.464]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:57.464]                   ...future.rng), globalenv = if (FALSE) 
[10:33:57.464]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:57.464]                     ...future.globalenv.names))
[10:33:57.464]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:57.464]         }, condition = base::local({
[10:33:57.464]             c <- base::c
[10:33:57.464]             inherits <- base::inherits
[10:33:57.464]             invokeRestart <- base::invokeRestart
[10:33:57.464]             length <- base::length
[10:33:57.464]             list <- base::list
[10:33:57.464]             seq.int <- base::seq.int
[10:33:57.464]             signalCondition <- base::signalCondition
[10:33:57.464]             sys.calls <- base::sys.calls
[10:33:57.464]             `[[` <- base::`[[`
[10:33:57.464]             `+` <- base::`+`
[10:33:57.464]             `<<-` <- base::`<<-`
[10:33:57.464]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:57.464]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:57.464]                   3L)]
[10:33:57.464]             }
[10:33:57.464]             function(cond) {
[10:33:57.464]                 is_error <- inherits(cond, "error")
[10:33:57.464]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:57.464]                   NULL)
[10:33:57.464]                 if (is_error) {
[10:33:57.464]                   sessionInformation <- function() {
[10:33:57.464]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:57.464]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:57.464]                       search = base::search(), system = base::Sys.info())
[10:33:57.464]                   }
[10:33:57.464]                   ...future.conditions[[length(...future.conditions) + 
[10:33:57.464]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:57.464]                     cond$call), session = sessionInformation(), 
[10:33:57.464]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:57.464]                   signalCondition(cond)
[10:33:57.464]                 }
[10:33:57.464]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:57.464]                 "immediateCondition"))) {
[10:33:57.464]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:57.464]                   ...future.conditions[[length(...future.conditions) + 
[10:33:57.464]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:57.464]                   if (TRUE && !signal) {
[10:33:57.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:57.464]                     {
[10:33:57.464]                       inherits <- base::inherits
[10:33:57.464]                       invokeRestart <- base::invokeRestart
[10:33:57.464]                       is.null <- base::is.null
[10:33:57.464]                       muffled <- FALSE
[10:33:57.464]                       if (inherits(cond, "message")) {
[10:33:57.464]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:57.464]                         if (muffled) 
[10:33:57.464]                           invokeRestart("muffleMessage")
[10:33:57.464]                       }
[10:33:57.464]                       else if (inherits(cond, "warning")) {
[10:33:57.464]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:57.464]                         if (muffled) 
[10:33:57.464]                           invokeRestart("muffleWarning")
[10:33:57.464]                       }
[10:33:57.464]                       else if (inherits(cond, "condition")) {
[10:33:57.464]                         if (!is.null(pattern)) {
[10:33:57.464]                           computeRestarts <- base::computeRestarts
[10:33:57.464]                           grepl <- base::grepl
[10:33:57.464]                           restarts <- computeRestarts(cond)
[10:33:57.464]                           for (restart in restarts) {
[10:33:57.464]                             name <- restart$name
[10:33:57.464]                             if (is.null(name)) 
[10:33:57.464]                               next
[10:33:57.464]                             if (!grepl(pattern, name)) 
[10:33:57.464]                               next
[10:33:57.464]                             invokeRestart(restart)
[10:33:57.464]                             muffled <- TRUE
[10:33:57.464]                             break
[10:33:57.464]                           }
[10:33:57.464]                         }
[10:33:57.464]                       }
[10:33:57.464]                       invisible(muffled)
[10:33:57.464]                     }
[10:33:57.464]                     muffleCondition(cond, pattern = "^muffle")
[10:33:57.464]                   }
[10:33:57.464]                 }
[10:33:57.464]                 else {
[10:33:57.464]                   if (TRUE) {
[10:33:57.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:57.464]                     {
[10:33:57.464]                       inherits <- base::inherits
[10:33:57.464]                       invokeRestart <- base::invokeRestart
[10:33:57.464]                       is.null <- base::is.null
[10:33:57.464]                       muffled <- FALSE
[10:33:57.464]                       if (inherits(cond, "message")) {
[10:33:57.464]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:57.464]                         if (muffled) 
[10:33:57.464]                           invokeRestart("muffleMessage")
[10:33:57.464]                       }
[10:33:57.464]                       else if (inherits(cond, "warning")) {
[10:33:57.464]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:57.464]                         if (muffled) 
[10:33:57.464]                           invokeRestart("muffleWarning")
[10:33:57.464]                       }
[10:33:57.464]                       else if (inherits(cond, "condition")) {
[10:33:57.464]                         if (!is.null(pattern)) {
[10:33:57.464]                           computeRestarts <- base::computeRestarts
[10:33:57.464]                           grepl <- base::grepl
[10:33:57.464]                           restarts <- computeRestarts(cond)
[10:33:57.464]                           for (restart in restarts) {
[10:33:57.464]                             name <- restart$name
[10:33:57.464]                             if (is.null(name)) 
[10:33:57.464]                               next
[10:33:57.464]                             if (!grepl(pattern, name)) 
[10:33:57.464]                               next
[10:33:57.464]                             invokeRestart(restart)
[10:33:57.464]                             muffled <- TRUE
[10:33:57.464]                             break
[10:33:57.464]                           }
[10:33:57.464]                         }
[10:33:57.464]                       }
[10:33:57.464]                       invisible(muffled)
[10:33:57.464]                     }
[10:33:57.464]                     muffleCondition(cond, pattern = "^muffle")
[10:33:57.464]                   }
[10:33:57.464]                 }
[10:33:57.464]             }
[10:33:57.464]         }))
[10:33:57.464]     }, error = function(ex) {
[10:33:57.464]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:57.464]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:57.464]                 ...future.rng), started = ...future.startTime, 
[10:33:57.464]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:57.464]             version = "1.8"), class = "FutureResult")
[10:33:57.464]     }, finally = {
[10:33:57.464]         if (!identical(...future.workdir, getwd())) 
[10:33:57.464]             setwd(...future.workdir)
[10:33:57.464]         {
[10:33:57.464]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:57.464]                 ...future.oldOptions$nwarnings <- NULL
[10:33:57.464]             }
[10:33:57.464]             base::options(...future.oldOptions)
[10:33:57.464]             if (.Platform$OS.type == "windows") {
[10:33:57.464]                 old_names <- names(...future.oldEnvVars)
[10:33:57.464]                 envs <- base::Sys.getenv()
[10:33:57.464]                 names <- names(envs)
[10:33:57.464]                 common <- intersect(names, old_names)
[10:33:57.464]                 added <- setdiff(names, old_names)
[10:33:57.464]                 removed <- setdiff(old_names, names)
[10:33:57.464]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:57.464]                   envs[common]]
[10:33:57.464]                 NAMES <- toupper(changed)
[10:33:57.464]                 args <- list()
[10:33:57.464]                 for (kk in seq_along(NAMES)) {
[10:33:57.464]                   name <- changed[[kk]]
[10:33:57.464]                   NAME <- NAMES[[kk]]
[10:33:57.464]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:57.464]                     next
[10:33:57.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:57.464]                 }
[10:33:57.464]                 NAMES <- toupper(added)
[10:33:57.464]                 for (kk in seq_along(NAMES)) {
[10:33:57.464]                   name <- added[[kk]]
[10:33:57.464]                   NAME <- NAMES[[kk]]
[10:33:57.464]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:57.464]                     next
[10:33:57.464]                   args[[name]] <- ""
[10:33:57.464]                 }
[10:33:57.464]                 NAMES <- toupper(removed)
[10:33:57.464]                 for (kk in seq_along(NAMES)) {
[10:33:57.464]                   name <- removed[[kk]]
[10:33:57.464]                   NAME <- NAMES[[kk]]
[10:33:57.464]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:57.464]                     next
[10:33:57.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:57.464]                 }
[10:33:57.464]                 if (length(args) > 0) 
[10:33:57.464]                   base::do.call(base::Sys.setenv, args = args)
[10:33:57.464]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:57.464]             }
[10:33:57.464]             else {
[10:33:57.464]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:57.464]             }
[10:33:57.464]             {
[10:33:57.464]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:57.464]                   0L) {
[10:33:57.464]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:57.464]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:57.464]                   base::options(opts)
[10:33:57.464]                 }
[10:33:57.464]                 {
[10:33:57.464]                   {
[10:33:57.464]                     NULL
[10:33:57.464]                     RNGkind("Mersenne-Twister")
[10:33:57.464]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:57.464]                       inherits = FALSE)
[10:33:57.464]                   }
[10:33:57.464]                   options(future.plan = NULL)
[10:33:57.464]                   if (is.na(NA_character_)) 
[10:33:57.464]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:57.464]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:57.464]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:57.464]                     .init = FALSE)
[10:33:57.464]                 }
[10:33:57.464]             }
[10:33:57.464]         }
[10:33:57.464]     })
[10:33:57.464]     if (TRUE) {
[10:33:57.464]         base::sink(type = "output", split = FALSE)
[10:33:57.464]         if (TRUE) {
[10:33:57.464]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:57.464]         }
[10:33:57.464]         else {
[10:33:57.464]             ...future.result["stdout"] <- base::list(NULL)
[10:33:57.464]         }
[10:33:57.464]         base::close(...future.stdout)
[10:33:57.464]         ...future.stdout <- NULL
[10:33:57.464]     }
[10:33:57.464]     ...future.result$conditions <- ...future.conditions
[10:33:57.464]     ...future.result$finished <- base::Sys.time()
[10:33:57.464]     ...future.result
[10:33:57.464] }
[10:33:57.466] plan(): Setting new future strategy stack:
[10:33:57.466] List of future strategies:
[10:33:57.466] 1. sequential:
[10:33:57.466]    - args: function (..., envir = parent.frame())
[10:33:57.466]    - tweaked: FALSE
[10:33:57.466]    - call: NULL
[10:33:57.466] plan(): nbrOfWorkers() = 1
[10:33:57.467] plan(): Setting new future strategy stack:
[10:33:57.467] List of future strategies:
[10:33:57.467] 1. sequential:
[10:33:57.467]    - args: function (..., envir = parent.frame())
[10:33:57.467]    - tweaked: FALSE
[10:33:57.467]    - call: plan(strategy)
[10:33:57.468] plan(): nbrOfWorkers() = 1
[10:33:57.468] SequentialFuture started (and completed)
[10:33:57.468] - Launch lazy future ... done
[10:33:57.468] run() for ‘SequentialFuture’ ... done
[10:33:57.469] getGlobalsAndPackages() ...
[10:33:57.469] Searching for globals...
[10:33:57.469] 
[10:33:57.469] Searching for globals ... DONE
[10:33:57.469] - globals: [0] <none>
[10:33:57.469] getGlobalsAndPackages() ... DONE
[10:33:57.469] run() for ‘Future’ ...
[10:33:57.470] - state: ‘created’
[10:33:57.470] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:57.470] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:57.470] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:57.470]   - Field: ‘label’
[10:33:57.470]   - Field: ‘local’
[10:33:57.470]   - Field: ‘owner’
[10:33:57.470]   - Field: ‘envir’
[10:33:57.470]   - Field: ‘packages’
[10:33:57.471]   - Field: ‘gc’
[10:33:57.471]   - Field: ‘conditions’
[10:33:57.471]   - Field: ‘expr’
[10:33:57.471]   - Field: ‘uuid’
[10:33:57.471]   - Field: ‘seed’
[10:33:57.471]   - Field: ‘version’
[10:33:57.471]   - Field: ‘result’
[10:33:57.471]   - Field: ‘asynchronous’
[10:33:57.471]   - Field: ‘calls’
[10:33:57.471]   - Field: ‘globals’
[10:33:57.471]   - Field: ‘stdout’
[10:33:57.471]   - Field: ‘earlySignal’
[10:33:57.472]   - Field: ‘lazy’
[10:33:57.472]   - Field: ‘state’
[10:33:57.472] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:57.472] - Launch lazy future ...
[10:33:57.472] Packages needed by the future expression (n = 0): <none>
[10:33:57.472] Packages needed by future strategies (n = 0): <none>
[10:33:57.472] {
[10:33:57.472]     {
[10:33:57.472]         {
[10:33:57.472]             ...future.startTime <- base::Sys.time()
[10:33:57.472]             {
[10:33:57.472]                 {
[10:33:57.472]                   {
[10:33:57.472]                     base::local({
[10:33:57.472]                       has_future <- base::requireNamespace("future", 
[10:33:57.472]                         quietly = TRUE)
[10:33:57.472]                       if (has_future) {
[10:33:57.472]                         ns <- base::getNamespace("future")
[10:33:57.472]                         version <- ns[[".package"]][["version"]]
[10:33:57.472]                         if (is.null(version)) 
[10:33:57.472]                           version <- utils::packageVersion("future")
[10:33:57.472]                       }
[10:33:57.472]                       else {
[10:33:57.472]                         version <- NULL
[10:33:57.472]                       }
[10:33:57.472]                       if (!has_future || version < "1.8.0") {
[10:33:57.472]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:57.472]                           "", base::R.version$version.string), 
[10:33:57.472]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:57.472]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:57.472]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:57.472]                             "release", "version")], collapse = " "), 
[10:33:57.472]                           hostname = base::Sys.info()[["nodename"]])
[10:33:57.472]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:57.472]                           info)
[10:33:57.472]                         info <- base::paste(info, collapse = "; ")
[10:33:57.472]                         if (!has_future) {
[10:33:57.472]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:57.472]                             info)
[10:33:57.472]                         }
[10:33:57.472]                         else {
[10:33:57.472]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:57.472]                             info, version)
[10:33:57.472]                         }
[10:33:57.472]                         base::stop(msg)
[10:33:57.472]                       }
[10:33:57.472]                     })
[10:33:57.472]                   }
[10:33:57.472]                   ...future.strategy.old <- future::plan("list")
[10:33:57.472]                   options(future.plan = NULL)
[10:33:57.472]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:57.472]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:57.472]                 }
[10:33:57.472]                 ...future.workdir <- getwd()
[10:33:57.472]             }
[10:33:57.472]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:57.472]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:57.472]         }
[10:33:57.472]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:57.472]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:57.472]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:57.472]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:57.472]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:57.472]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:57.472]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:57.472]             base::names(...future.oldOptions))
[10:33:57.472]     }
[10:33:57.472]     if (FALSE) {
[10:33:57.472]     }
[10:33:57.472]     else {
[10:33:57.472]         if (TRUE) {
[10:33:57.472]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:57.472]                 open = "w")
[10:33:57.472]         }
[10:33:57.472]         else {
[10:33:57.472]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:57.472]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:57.472]         }
[10:33:57.472]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:57.472]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:57.472]             base::sink(type = "output", split = FALSE)
[10:33:57.472]             base::close(...future.stdout)
[10:33:57.472]         }, add = TRUE)
[10:33:57.472]     }
[10:33:57.472]     ...future.frame <- base::sys.nframe()
[10:33:57.472]     ...future.conditions <- base::list()
[10:33:57.472]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:57.472]     if (FALSE) {
[10:33:57.472]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:57.472]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:57.472]     }
[10:33:57.472]     ...future.result <- base::tryCatch({
[10:33:57.472]         base::withCallingHandlers({
[10:33:57.472]             ...future.value <- base::withVisible(base::local(2))
[10:33:57.472]             future::FutureResult(value = ...future.value$value, 
[10:33:57.472]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:57.472]                   ...future.rng), globalenv = if (FALSE) 
[10:33:57.472]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:57.472]                     ...future.globalenv.names))
[10:33:57.472]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:57.472]         }, condition = base::local({
[10:33:57.472]             c <- base::c
[10:33:57.472]             inherits <- base::inherits
[10:33:57.472]             invokeRestart <- base::invokeRestart
[10:33:57.472]             length <- base::length
[10:33:57.472]             list <- base::list
[10:33:57.472]             seq.int <- base::seq.int
[10:33:57.472]             signalCondition <- base::signalCondition
[10:33:57.472]             sys.calls <- base::sys.calls
[10:33:57.472]             `[[` <- base::`[[`
[10:33:57.472]             `+` <- base::`+`
[10:33:57.472]             `<<-` <- base::`<<-`
[10:33:57.472]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:57.472]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:57.472]                   3L)]
[10:33:57.472]             }
[10:33:57.472]             function(cond) {
[10:33:57.472]                 is_error <- inherits(cond, "error")
[10:33:57.472]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:57.472]                   NULL)
[10:33:57.472]                 if (is_error) {
[10:33:57.472]                   sessionInformation <- function() {
[10:33:57.472]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:57.472]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:57.472]                       search = base::search(), system = base::Sys.info())
[10:33:57.472]                   }
[10:33:57.472]                   ...future.conditions[[length(...future.conditions) + 
[10:33:57.472]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:57.472]                     cond$call), session = sessionInformation(), 
[10:33:57.472]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:57.472]                   signalCondition(cond)
[10:33:57.472]                 }
[10:33:57.472]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:57.472]                 "immediateCondition"))) {
[10:33:57.472]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:57.472]                   ...future.conditions[[length(...future.conditions) + 
[10:33:57.472]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:57.472]                   if (TRUE && !signal) {
[10:33:57.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:57.472]                     {
[10:33:57.472]                       inherits <- base::inherits
[10:33:57.472]                       invokeRestart <- base::invokeRestart
[10:33:57.472]                       is.null <- base::is.null
[10:33:57.472]                       muffled <- FALSE
[10:33:57.472]                       if (inherits(cond, "message")) {
[10:33:57.472]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:57.472]                         if (muffled) 
[10:33:57.472]                           invokeRestart("muffleMessage")
[10:33:57.472]                       }
[10:33:57.472]                       else if (inherits(cond, "warning")) {
[10:33:57.472]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:57.472]                         if (muffled) 
[10:33:57.472]                           invokeRestart("muffleWarning")
[10:33:57.472]                       }
[10:33:57.472]                       else if (inherits(cond, "condition")) {
[10:33:57.472]                         if (!is.null(pattern)) {
[10:33:57.472]                           computeRestarts <- base::computeRestarts
[10:33:57.472]                           grepl <- base::grepl
[10:33:57.472]                           restarts <- computeRestarts(cond)
[10:33:57.472]                           for (restart in restarts) {
[10:33:57.472]                             name <- restart$name
[10:33:57.472]                             if (is.null(name)) 
[10:33:57.472]                               next
[10:33:57.472]                             if (!grepl(pattern, name)) 
[10:33:57.472]                               next
[10:33:57.472]                             invokeRestart(restart)
[10:33:57.472]                             muffled <- TRUE
[10:33:57.472]                             break
[10:33:57.472]                           }
[10:33:57.472]                         }
[10:33:57.472]                       }
[10:33:57.472]                       invisible(muffled)
[10:33:57.472]                     }
[10:33:57.472]                     muffleCondition(cond, pattern = "^muffle")
[10:33:57.472]                   }
[10:33:57.472]                 }
[10:33:57.472]                 else {
[10:33:57.472]                   if (TRUE) {
[10:33:57.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:57.472]                     {
[10:33:57.472]                       inherits <- base::inherits
[10:33:57.472]                       invokeRestart <- base::invokeRestart
[10:33:57.472]                       is.null <- base::is.null
[10:33:57.472]                       muffled <- FALSE
[10:33:57.472]                       if (inherits(cond, "message")) {
[10:33:57.472]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:57.472]                         if (muffled) 
[10:33:57.472]                           invokeRestart("muffleMessage")
[10:33:57.472]                       }
[10:33:57.472]                       else if (inherits(cond, "warning")) {
[10:33:57.472]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:57.472]                         if (muffled) 
[10:33:57.472]                           invokeRestart("muffleWarning")
[10:33:57.472]                       }
[10:33:57.472]                       else if (inherits(cond, "condition")) {
[10:33:57.472]                         if (!is.null(pattern)) {
[10:33:57.472]                           computeRestarts <- base::computeRestarts
[10:33:57.472]                           grepl <- base::grepl
[10:33:57.472]                           restarts <- computeRestarts(cond)
[10:33:57.472]                           for (restart in restarts) {
[10:33:57.472]                             name <- restart$name
[10:33:57.472]                             if (is.null(name)) 
[10:33:57.472]                               next
[10:33:57.472]                             if (!grepl(pattern, name)) 
[10:33:57.472]                               next
[10:33:57.472]                             invokeRestart(restart)
[10:33:57.472]                             muffled <- TRUE
[10:33:57.472]                             break
[10:33:57.472]                           }
[10:33:57.472]                         }
[10:33:57.472]                       }
[10:33:57.472]                       invisible(muffled)
[10:33:57.472]                     }
[10:33:57.472]                     muffleCondition(cond, pattern = "^muffle")
[10:33:57.472]                   }
[10:33:57.472]                 }
[10:33:57.472]             }
[10:33:57.472]         }))
[10:33:57.472]     }, error = function(ex) {
[10:33:57.472]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:57.472]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:57.472]                 ...future.rng), started = ...future.startTime, 
[10:33:57.472]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:57.472]             version = "1.8"), class = "FutureResult")
[10:33:57.472]     }, finally = {
[10:33:57.472]         if (!identical(...future.workdir, getwd())) 
[10:33:57.472]             setwd(...future.workdir)
[10:33:57.472]         {
[10:33:57.472]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:57.472]                 ...future.oldOptions$nwarnings <- NULL
[10:33:57.472]             }
[10:33:57.472]             base::options(...future.oldOptions)
[10:33:57.472]             if (.Platform$OS.type == "windows") {
[10:33:57.472]                 old_names <- names(...future.oldEnvVars)
[10:33:57.472]                 envs <- base::Sys.getenv()
[10:33:57.472]                 names <- names(envs)
[10:33:57.472]                 common <- intersect(names, old_names)
[10:33:57.472]                 added <- setdiff(names, old_names)
[10:33:57.472]                 removed <- setdiff(old_names, names)
[10:33:57.472]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:57.472]                   envs[common]]
[10:33:57.472]                 NAMES <- toupper(changed)
[10:33:57.472]                 args <- list()
[10:33:57.472]                 for (kk in seq_along(NAMES)) {
[10:33:57.472]                   name <- changed[[kk]]
[10:33:57.472]                   NAME <- NAMES[[kk]]
[10:33:57.472]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:57.472]                     next
[10:33:57.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:57.472]                 }
[10:33:57.472]                 NAMES <- toupper(added)
[10:33:57.472]                 for (kk in seq_along(NAMES)) {
[10:33:57.472]                   name <- added[[kk]]
[10:33:57.472]                   NAME <- NAMES[[kk]]
[10:33:57.472]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:57.472]                     next
[10:33:57.472]                   args[[name]] <- ""
[10:33:57.472]                 }
[10:33:57.472]                 NAMES <- toupper(removed)
[10:33:57.472]                 for (kk in seq_along(NAMES)) {
[10:33:57.472]                   name <- removed[[kk]]
[10:33:57.472]                   NAME <- NAMES[[kk]]
[10:33:57.472]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:57.472]                     next
[10:33:57.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:57.472]                 }
[10:33:57.472]                 if (length(args) > 0) 
[10:33:57.472]                   base::do.call(base::Sys.setenv, args = args)
[10:33:57.472]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:57.472]             }
[10:33:57.472]             else {
[10:33:57.472]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:57.472]             }
[10:33:57.472]             {
[10:33:57.472]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:57.472]                   0L) {
[10:33:57.472]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:57.472]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:57.472]                   base::options(opts)
[10:33:57.472]                 }
[10:33:57.472]                 {
[10:33:57.472]                   {
[10:33:57.472]                     NULL
[10:33:57.472]                     RNGkind("Mersenne-Twister")
[10:33:57.472]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:57.472]                       inherits = FALSE)
[10:33:57.472]                   }
[10:33:57.472]                   options(future.plan = NULL)
[10:33:57.472]                   if (is.na(NA_character_)) 
[10:33:57.472]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:57.472]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:57.472]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:57.472]                     .init = FALSE)
[10:33:57.472]                 }
[10:33:57.472]             }
[10:33:57.472]         }
[10:33:57.472]     })
[10:33:57.472]     if (TRUE) {
[10:33:57.472]         base::sink(type = "output", split = FALSE)
[10:33:57.472]         if (TRUE) {
[10:33:57.472]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:57.472]         }
[10:33:57.472]         else {
[10:33:57.472]             ...future.result["stdout"] <- base::list(NULL)
[10:33:57.472]         }
[10:33:57.472]         base::close(...future.stdout)
[10:33:57.472]         ...future.stdout <- NULL
[10:33:57.472]     }
[10:33:57.472]     ...future.result$conditions <- ...future.conditions
[10:33:57.472]     ...future.result$finished <- base::Sys.time()
[10:33:57.472]     ...future.result
[10:33:57.472] }
[10:33:57.474] plan(): Setting new future strategy stack:
[10:33:57.474] List of future strategies:
[10:33:57.474] 1. sequential:
[10:33:57.474]    - args: function (..., envir = parent.frame())
[10:33:57.474]    - tweaked: FALSE
[10:33:57.474]    - call: NULL
[10:33:57.475] plan(): nbrOfWorkers() = 1
[10:33:57.475] plan(): Setting new future strategy stack:
[10:33:57.475] List of future strategies:
[10:33:57.475] 1. sequential:
[10:33:57.475]    - args: function (..., envir = parent.frame())
[10:33:57.475]    - tweaked: FALSE
[10:33:57.475]    - call: plan(strategy)
[10:33:57.476] plan(): nbrOfWorkers() = 1
[10:33:57.476] SequentialFuture started (and completed)
[10:33:57.476] - Launch lazy future ... done
[10:33:57.476] run() for ‘SequentialFuture’ ... done
[10:33:57.476] resolve() on list ...
[10:33:57.476]  recursive: 0
[10:33:57.476]  length: 3
[10:33:57.476]  elements: ‘a’, ‘b’, ‘’
[10:33:57.477] resolved() for ‘SequentialFuture’ ...
[10:33:57.477] - state: ‘finished’
[10:33:57.477] - run: TRUE
[10:33:57.477] - result: ‘FutureResult’
[10:33:57.477] resolved() for ‘SequentialFuture’ ... done
[10:33:57.477] Future #1
[10:33:57.477]  length: 2 (resolved future 1)
[10:33:57.477] resolved() for ‘SequentialFuture’ ...
[10:33:57.478] - state: ‘finished’
[10:33:57.478] - run: TRUE
[10:33:57.478] - result: ‘FutureResult’
[10:33:57.478] resolved() for ‘SequentialFuture’ ... done
[10:33:57.478] Future #2
[10:33:57.478]  length: 1 (resolved future 2)
[10:33:57.478]  length: 0 (resolved future 3)
[10:33:57.478] resolve() on list ... DONE
[10:33:57.478] resolved() for ‘SequentialFuture’ ...
[10:33:57.478] - state: ‘finished’
[10:33:57.478] - run: TRUE
[10:33:57.479] - result: ‘FutureResult’
[10:33:57.479] resolved() for ‘SequentialFuture’ ... done
[10:33:57.479] resolved() for ‘SequentialFuture’ ...
[10:33:57.479] - state: ‘finished’
[10:33:57.479] - run: TRUE
[10:33:57.479] - result: ‘FutureResult’
[10:33:57.479] resolved() for ‘SequentialFuture’ ... done
[10:33:57.479] getGlobalsAndPackages() ...
[10:33:57.481] Searching for globals...
[10:33:57.481] 
[10:33:57.481] Searching for globals ... DONE
[10:33:57.481] - globals: [0] <none>
[10:33:57.481] getGlobalsAndPackages() ... DONE
[10:33:57.481] getGlobalsAndPackages() ...
[10:33:57.482] Searching for globals...
[10:33:57.482] 
[10:33:57.482] Searching for globals ... DONE
[10:33:57.482] - globals: [0] <none>
[10:33:57.482] getGlobalsAndPackages() ... DONE
[10:33:57.482] run() for ‘Future’ ...
[10:33:57.483] - state: ‘created’
[10:33:57.483] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:57.483] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:57.483] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:57.483]   - Field: ‘label’
[10:33:57.483]   - Field: ‘local’
[10:33:57.483]   - Field: ‘owner’
[10:33:57.483]   - Field: ‘envir’
[10:33:57.483]   - Field: ‘packages’
[10:33:57.484]   - Field: ‘gc’
[10:33:57.484]   - Field: ‘conditions’
[10:33:57.484]   - Field: ‘expr’
[10:33:57.484]   - Field: ‘uuid’
[10:33:57.484]   - Field: ‘seed’
[10:33:57.484]   - Field: ‘version’
[10:33:57.484]   - Field: ‘result’
[10:33:57.484]   - Field: ‘asynchronous’
[10:33:57.484]   - Field: ‘calls’
[10:33:57.484]   - Field: ‘globals’
[10:33:57.484]   - Field: ‘stdout’
[10:33:57.485]   - Field: ‘earlySignal’
[10:33:57.485]   - Field: ‘lazy’
[10:33:57.485]   - Field: ‘state’
[10:33:57.485] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:57.485] - Launch lazy future ...
[10:33:57.485] Packages needed by the future expression (n = 0): <none>
[10:33:57.485] Packages needed by future strategies (n = 0): <none>
[10:33:57.486] {
[10:33:57.486]     {
[10:33:57.486]         {
[10:33:57.486]             ...future.startTime <- base::Sys.time()
[10:33:57.486]             {
[10:33:57.486]                 {
[10:33:57.486]                   {
[10:33:57.486]                     base::local({
[10:33:57.486]                       has_future <- base::requireNamespace("future", 
[10:33:57.486]                         quietly = TRUE)
[10:33:57.486]                       if (has_future) {
[10:33:57.486]                         ns <- base::getNamespace("future")
[10:33:57.486]                         version <- ns[[".package"]][["version"]]
[10:33:57.486]                         if (is.null(version)) 
[10:33:57.486]                           version <- utils::packageVersion("future")
[10:33:57.486]                       }
[10:33:57.486]                       else {
[10:33:57.486]                         version <- NULL
[10:33:57.486]                       }
[10:33:57.486]                       if (!has_future || version < "1.8.0") {
[10:33:57.486]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:57.486]                           "", base::R.version$version.string), 
[10:33:57.486]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:57.486]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:57.486]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:57.486]                             "release", "version")], collapse = " "), 
[10:33:57.486]                           hostname = base::Sys.info()[["nodename"]])
[10:33:57.486]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:57.486]                           info)
[10:33:57.486]                         info <- base::paste(info, collapse = "; ")
[10:33:57.486]                         if (!has_future) {
[10:33:57.486]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:57.486]                             info)
[10:33:57.486]                         }
[10:33:57.486]                         else {
[10:33:57.486]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:57.486]                             info, version)
[10:33:57.486]                         }
[10:33:57.486]                         base::stop(msg)
[10:33:57.486]                       }
[10:33:57.486]                     })
[10:33:57.486]                   }
[10:33:57.486]                   ...future.strategy.old <- future::plan("list")
[10:33:57.486]                   options(future.plan = NULL)
[10:33:57.486]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:57.486]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:57.486]                 }
[10:33:57.486]                 ...future.workdir <- getwd()
[10:33:57.486]             }
[10:33:57.486]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:57.486]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:57.486]         }
[10:33:57.486]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:57.486]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:57.486]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:57.486]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:57.486]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:57.486]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:57.486]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:57.486]             base::names(...future.oldOptions))
[10:33:57.486]     }
[10:33:57.486]     if (FALSE) {
[10:33:57.486]     }
[10:33:57.486]     else {
[10:33:57.486]         if (TRUE) {
[10:33:57.486]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:57.486]                 open = "w")
[10:33:57.486]         }
[10:33:57.486]         else {
[10:33:57.486]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:57.486]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:57.486]         }
[10:33:57.486]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:57.486]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:57.486]             base::sink(type = "output", split = FALSE)
[10:33:57.486]             base::close(...future.stdout)
[10:33:57.486]         }, add = TRUE)
[10:33:57.486]     }
[10:33:57.486]     ...future.frame <- base::sys.nframe()
[10:33:57.486]     ...future.conditions <- base::list()
[10:33:57.486]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:57.486]     if (FALSE) {
[10:33:57.486]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:57.486]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:57.486]     }
[10:33:57.486]     ...future.result <- base::tryCatch({
[10:33:57.486]         base::withCallingHandlers({
[10:33:57.486]             ...future.value <- base::withVisible(base::local(2))
[10:33:57.486]             future::FutureResult(value = ...future.value$value, 
[10:33:57.486]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:57.486]                   ...future.rng), globalenv = if (FALSE) 
[10:33:57.486]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:57.486]                     ...future.globalenv.names))
[10:33:57.486]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:57.486]         }, condition = base::local({
[10:33:57.486]             c <- base::c
[10:33:57.486]             inherits <- base::inherits
[10:33:57.486]             invokeRestart <- base::invokeRestart
[10:33:57.486]             length <- base::length
[10:33:57.486]             list <- base::list
[10:33:57.486]             seq.int <- base::seq.int
[10:33:57.486]             signalCondition <- base::signalCondition
[10:33:57.486]             sys.calls <- base::sys.calls
[10:33:57.486]             `[[` <- base::`[[`
[10:33:57.486]             `+` <- base::`+`
[10:33:57.486]             `<<-` <- base::`<<-`
[10:33:57.486]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:57.486]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:57.486]                   3L)]
[10:33:57.486]             }
[10:33:57.486]             function(cond) {
[10:33:57.486]                 is_error <- inherits(cond, "error")
[10:33:57.486]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:57.486]                   NULL)
[10:33:57.486]                 if (is_error) {
[10:33:57.486]                   sessionInformation <- function() {
[10:33:57.486]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:57.486]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:57.486]                       search = base::search(), system = base::Sys.info())
[10:33:57.486]                   }
[10:33:57.486]                   ...future.conditions[[length(...future.conditions) + 
[10:33:57.486]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:57.486]                     cond$call), session = sessionInformation(), 
[10:33:57.486]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:57.486]                   signalCondition(cond)
[10:33:57.486]                 }
[10:33:57.486]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:57.486]                 "immediateCondition"))) {
[10:33:57.486]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:57.486]                   ...future.conditions[[length(...future.conditions) + 
[10:33:57.486]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:57.486]                   if (TRUE && !signal) {
[10:33:57.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:57.486]                     {
[10:33:57.486]                       inherits <- base::inherits
[10:33:57.486]                       invokeRestart <- base::invokeRestart
[10:33:57.486]                       is.null <- base::is.null
[10:33:57.486]                       muffled <- FALSE
[10:33:57.486]                       if (inherits(cond, "message")) {
[10:33:57.486]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:57.486]                         if (muffled) 
[10:33:57.486]                           invokeRestart("muffleMessage")
[10:33:57.486]                       }
[10:33:57.486]                       else if (inherits(cond, "warning")) {
[10:33:57.486]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:57.486]                         if (muffled) 
[10:33:57.486]                           invokeRestart("muffleWarning")
[10:33:57.486]                       }
[10:33:57.486]                       else if (inherits(cond, "condition")) {
[10:33:57.486]                         if (!is.null(pattern)) {
[10:33:57.486]                           computeRestarts <- base::computeRestarts
[10:33:57.486]                           grepl <- base::grepl
[10:33:57.486]                           restarts <- computeRestarts(cond)
[10:33:57.486]                           for (restart in restarts) {
[10:33:57.486]                             name <- restart$name
[10:33:57.486]                             if (is.null(name)) 
[10:33:57.486]                               next
[10:33:57.486]                             if (!grepl(pattern, name)) 
[10:33:57.486]                               next
[10:33:57.486]                             invokeRestart(restart)
[10:33:57.486]                             muffled <- TRUE
[10:33:57.486]                             break
[10:33:57.486]                           }
[10:33:57.486]                         }
[10:33:57.486]                       }
[10:33:57.486]                       invisible(muffled)
[10:33:57.486]                     }
[10:33:57.486]                     muffleCondition(cond, pattern = "^muffle")
[10:33:57.486]                   }
[10:33:57.486]                 }
[10:33:57.486]                 else {
[10:33:57.486]                   if (TRUE) {
[10:33:57.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:57.486]                     {
[10:33:57.486]                       inherits <- base::inherits
[10:33:57.486]                       invokeRestart <- base::invokeRestart
[10:33:57.486]                       is.null <- base::is.null
[10:33:57.486]                       muffled <- FALSE
[10:33:57.486]                       if (inherits(cond, "message")) {
[10:33:57.486]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:57.486]                         if (muffled) 
[10:33:57.486]                           invokeRestart("muffleMessage")
[10:33:57.486]                       }
[10:33:57.486]                       else if (inherits(cond, "warning")) {
[10:33:57.486]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:57.486]                         if (muffled) 
[10:33:57.486]                           invokeRestart("muffleWarning")
[10:33:57.486]                       }
[10:33:57.486]                       else if (inherits(cond, "condition")) {
[10:33:57.486]                         if (!is.null(pattern)) {
[10:33:57.486]                           computeRestarts <- base::computeRestarts
[10:33:57.486]                           grepl <- base::grepl
[10:33:57.486]                           restarts <- computeRestarts(cond)
[10:33:57.486]                           for (restart in restarts) {
[10:33:57.486]                             name <- restart$name
[10:33:57.486]                             if (is.null(name)) 
[10:33:57.486]                               next
[10:33:57.486]                             if (!grepl(pattern, name)) 
[10:33:57.486]                               next
[10:33:57.486]                             invokeRestart(restart)
[10:33:57.486]                             muffled <- TRUE
[10:33:57.486]                             break
[10:33:57.486]                           }
[10:33:57.486]                         }
[10:33:57.486]                       }
[10:33:57.486]                       invisible(muffled)
[10:33:57.486]                     }
[10:33:57.486]                     muffleCondition(cond, pattern = "^muffle")
[10:33:57.486]                   }
[10:33:57.486]                 }
[10:33:57.486]             }
[10:33:57.486]         }))
[10:33:57.486]     }, error = function(ex) {
[10:33:57.486]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:57.486]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:57.486]                 ...future.rng), started = ...future.startTime, 
[10:33:57.486]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:57.486]             version = "1.8"), class = "FutureResult")
[10:33:57.486]     }, finally = {
[10:33:57.486]         if (!identical(...future.workdir, getwd())) 
[10:33:57.486]             setwd(...future.workdir)
[10:33:57.486]         {
[10:33:57.486]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:57.486]                 ...future.oldOptions$nwarnings <- NULL
[10:33:57.486]             }
[10:33:57.486]             base::options(...future.oldOptions)
[10:33:57.486]             if (.Platform$OS.type == "windows") {
[10:33:57.486]                 old_names <- names(...future.oldEnvVars)
[10:33:57.486]                 envs <- base::Sys.getenv()
[10:33:57.486]                 names <- names(envs)
[10:33:57.486]                 common <- intersect(names, old_names)
[10:33:57.486]                 added <- setdiff(names, old_names)
[10:33:57.486]                 removed <- setdiff(old_names, names)
[10:33:57.486]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:57.486]                   envs[common]]
[10:33:57.486]                 NAMES <- toupper(changed)
[10:33:57.486]                 args <- list()
[10:33:57.486]                 for (kk in seq_along(NAMES)) {
[10:33:57.486]                   name <- changed[[kk]]
[10:33:57.486]                   NAME <- NAMES[[kk]]
[10:33:57.486]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:57.486]                     next
[10:33:57.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:57.486]                 }
[10:33:57.486]                 NAMES <- toupper(added)
[10:33:57.486]                 for (kk in seq_along(NAMES)) {
[10:33:57.486]                   name <- added[[kk]]
[10:33:57.486]                   NAME <- NAMES[[kk]]
[10:33:57.486]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:57.486]                     next
[10:33:57.486]                   args[[name]] <- ""
[10:33:57.486]                 }
[10:33:57.486]                 NAMES <- toupper(removed)
[10:33:57.486]                 for (kk in seq_along(NAMES)) {
[10:33:57.486]                   name <- removed[[kk]]
[10:33:57.486]                   NAME <- NAMES[[kk]]
[10:33:57.486]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:57.486]                     next
[10:33:57.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:57.486]                 }
[10:33:57.486]                 if (length(args) > 0) 
[10:33:57.486]                   base::do.call(base::Sys.setenv, args = args)
[10:33:57.486]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:57.486]             }
[10:33:57.486]             else {
[10:33:57.486]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:57.486]             }
[10:33:57.486]             {
[10:33:57.486]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:57.486]                   0L) {
[10:33:57.486]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:57.486]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:57.486]                   base::options(opts)
[10:33:57.486]                 }
[10:33:57.486]                 {
[10:33:57.486]                   {
[10:33:57.486]                     NULL
[10:33:57.486]                     RNGkind("Mersenne-Twister")
[10:33:57.486]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:57.486]                       inherits = FALSE)
[10:33:57.486]                   }
[10:33:57.486]                   options(future.plan = NULL)
[10:33:57.486]                   if (is.na(NA_character_)) 
[10:33:57.486]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:57.486]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:57.486]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:57.486]                     .init = FALSE)
[10:33:57.486]                 }
[10:33:57.486]             }
[10:33:57.486]         }
[10:33:57.486]     })
[10:33:57.486]     if (TRUE) {
[10:33:57.486]         base::sink(type = "output", split = FALSE)
[10:33:57.486]         if (TRUE) {
[10:33:57.486]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:57.486]         }
[10:33:57.486]         else {
[10:33:57.486]             ...future.result["stdout"] <- base::list(NULL)
[10:33:57.486]         }
[10:33:57.486]         base::close(...future.stdout)
[10:33:57.486]         ...future.stdout <- NULL
[10:33:57.486]     }
[10:33:57.486]     ...future.result$conditions <- ...future.conditions
[10:33:57.486]     ...future.result$finished <- base::Sys.time()
[10:33:57.486]     ...future.result
[10:33:57.486] }
[10:33:57.487] plan(): Setting new future strategy stack:
[10:33:57.487] List of future strategies:
[10:33:57.487] 1. sequential:
[10:33:57.487]    - args: function (..., envir = parent.frame())
[10:33:57.487]    - tweaked: FALSE
[10:33:57.487]    - call: NULL
[10:33:57.488] plan(): nbrOfWorkers() = 1
[10:33:57.489] plan(): Setting new future strategy stack:
[10:33:57.489] List of future strategies:
[10:33:57.489] 1. sequential:
[10:33:57.489]    - args: function (..., envir = parent.frame())
[10:33:57.489]    - tweaked: FALSE
[10:33:57.489]    - call: plan(strategy)
[10:33:57.489] plan(): nbrOfWorkers() = 1
[10:33:57.489] SequentialFuture started (and completed)
[10:33:57.489] - Launch lazy future ... done
[10:33:57.489] run() for ‘SequentialFuture’ ... done
[10:33:57.490] resolve() on list ...
[10:33:57.490]  recursive: 0
[10:33:57.490]  length: 3
[10:33:57.490]  elements: ‘a’, ‘b’, ‘’
[10:33:57.490] run() for ‘Future’ ...
[10:33:57.490] - state: ‘created’
[10:33:57.490] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:57.490] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:57.490] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:57.491]   - Field: ‘label’
[10:33:57.491]   - Field: ‘local’
[10:33:57.491]   - Field: ‘owner’
[10:33:57.491]   - Field: ‘envir’
[10:33:57.491]   - Field: ‘packages’
[10:33:57.491]   - Field: ‘gc’
[10:33:57.491]   - Field: ‘conditions’
[10:33:57.491]   - Field: ‘expr’
[10:33:57.491]   - Field: ‘uuid’
[10:33:57.491]   - Field: ‘seed’
[10:33:57.491]   - Field: ‘version’
[10:33:57.492]   - Field: ‘result’
[10:33:57.492]   - Field: ‘asynchronous’
[10:33:57.492]   - Field: ‘calls’
[10:33:57.492]   - Field: ‘globals’
[10:33:57.492]   - Field: ‘stdout’
[10:33:57.492]   - Field: ‘earlySignal’
[10:33:57.492]   - Field: ‘lazy’
[10:33:57.492]   - Field: ‘state’
[10:33:57.492] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:57.492] - Launch lazy future ...
[10:33:57.493] Packages needed by the future expression (n = 0): <none>
[10:33:57.493] Packages needed by future strategies (n = 0): <none>
[10:33:57.493] {
[10:33:57.493]     {
[10:33:57.493]         {
[10:33:57.493]             ...future.startTime <- base::Sys.time()
[10:33:57.493]             {
[10:33:57.493]                 {
[10:33:57.493]                   {
[10:33:57.493]                     base::local({
[10:33:57.493]                       has_future <- base::requireNamespace("future", 
[10:33:57.493]                         quietly = TRUE)
[10:33:57.493]                       if (has_future) {
[10:33:57.493]                         ns <- base::getNamespace("future")
[10:33:57.493]                         version <- ns[[".package"]][["version"]]
[10:33:57.493]                         if (is.null(version)) 
[10:33:57.493]                           version <- utils::packageVersion("future")
[10:33:57.493]                       }
[10:33:57.493]                       else {
[10:33:57.493]                         version <- NULL
[10:33:57.493]                       }
[10:33:57.493]                       if (!has_future || version < "1.8.0") {
[10:33:57.493]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:57.493]                           "", base::R.version$version.string), 
[10:33:57.493]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:57.493]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:57.493]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:57.493]                             "release", "version")], collapse = " "), 
[10:33:57.493]                           hostname = base::Sys.info()[["nodename"]])
[10:33:57.493]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:57.493]                           info)
[10:33:57.493]                         info <- base::paste(info, collapse = "; ")
[10:33:57.493]                         if (!has_future) {
[10:33:57.493]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:57.493]                             info)
[10:33:57.493]                         }
[10:33:57.493]                         else {
[10:33:57.493]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:57.493]                             info, version)
[10:33:57.493]                         }
[10:33:57.493]                         base::stop(msg)
[10:33:57.493]                       }
[10:33:57.493]                     })
[10:33:57.493]                   }
[10:33:57.493]                   ...future.strategy.old <- future::plan("list")
[10:33:57.493]                   options(future.plan = NULL)
[10:33:57.493]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:57.493]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:57.493]                 }
[10:33:57.493]                 ...future.workdir <- getwd()
[10:33:57.493]             }
[10:33:57.493]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:57.493]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:57.493]         }
[10:33:57.493]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:57.493]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:57.493]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:57.493]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:57.493]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:57.493]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:57.493]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:57.493]             base::names(...future.oldOptions))
[10:33:57.493]     }
[10:33:57.493]     if (FALSE) {
[10:33:57.493]     }
[10:33:57.493]     else {
[10:33:57.493]         if (TRUE) {
[10:33:57.493]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:57.493]                 open = "w")
[10:33:57.493]         }
[10:33:57.493]         else {
[10:33:57.493]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:57.493]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:57.493]         }
[10:33:57.493]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:57.493]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:57.493]             base::sink(type = "output", split = FALSE)
[10:33:57.493]             base::close(...future.stdout)
[10:33:57.493]         }, add = TRUE)
[10:33:57.493]     }
[10:33:57.493]     ...future.frame <- base::sys.nframe()
[10:33:57.493]     ...future.conditions <- base::list()
[10:33:57.493]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:57.493]     if (FALSE) {
[10:33:57.493]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:57.493]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:57.493]     }
[10:33:57.493]     ...future.result <- base::tryCatch({
[10:33:57.493]         base::withCallingHandlers({
[10:33:57.493]             ...future.value <- base::withVisible(base::local(1))
[10:33:57.493]             future::FutureResult(value = ...future.value$value, 
[10:33:57.493]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:57.493]                   ...future.rng), globalenv = if (FALSE) 
[10:33:57.493]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:57.493]                     ...future.globalenv.names))
[10:33:57.493]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:57.493]         }, condition = base::local({
[10:33:57.493]             c <- base::c
[10:33:57.493]             inherits <- base::inherits
[10:33:57.493]             invokeRestart <- base::invokeRestart
[10:33:57.493]             length <- base::length
[10:33:57.493]             list <- base::list
[10:33:57.493]             seq.int <- base::seq.int
[10:33:57.493]             signalCondition <- base::signalCondition
[10:33:57.493]             sys.calls <- base::sys.calls
[10:33:57.493]             `[[` <- base::`[[`
[10:33:57.493]             `+` <- base::`+`
[10:33:57.493]             `<<-` <- base::`<<-`
[10:33:57.493]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:57.493]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:57.493]                   3L)]
[10:33:57.493]             }
[10:33:57.493]             function(cond) {
[10:33:57.493]                 is_error <- inherits(cond, "error")
[10:33:57.493]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:57.493]                   NULL)
[10:33:57.493]                 if (is_error) {
[10:33:57.493]                   sessionInformation <- function() {
[10:33:57.493]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:57.493]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:57.493]                       search = base::search(), system = base::Sys.info())
[10:33:57.493]                   }
[10:33:57.493]                   ...future.conditions[[length(...future.conditions) + 
[10:33:57.493]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:57.493]                     cond$call), session = sessionInformation(), 
[10:33:57.493]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:57.493]                   signalCondition(cond)
[10:33:57.493]                 }
[10:33:57.493]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:57.493]                 "immediateCondition"))) {
[10:33:57.493]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:57.493]                   ...future.conditions[[length(...future.conditions) + 
[10:33:57.493]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:57.493]                   if (TRUE && !signal) {
[10:33:57.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:57.493]                     {
[10:33:57.493]                       inherits <- base::inherits
[10:33:57.493]                       invokeRestart <- base::invokeRestart
[10:33:57.493]                       is.null <- base::is.null
[10:33:57.493]                       muffled <- FALSE
[10:33:57.493]                       if (inherits(cond, "message")) {
[10:33:57.493]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:57.493]                         if (muffled) 
[10:33:57.493]                           invokeRestart("muffleMessage")
[10:33:57.493]                       }
[10:33:57.493]                       else if (inherits(cond, "warning")) {
[10:33:57.493]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:57.493]                         if (muffled) 
[10:33:57.493]                           invokeRestart("muffleWarning")
[10:33:57.493]                       }
[10:33:57.493]                       else if (inherits(cond, "condition")) {
[10:33:57.493]                         if (!is.null(pattern)) {
[10:33:57.493]                           computeRestarts <- base::computeRestarts
[10:33:57.493]                           grepl <- base::grepl
[10:33:57.493]                           restarts <- computeRestarts(cond)
[10:33:57.493]                           for (restart in restarts) {
[10:33:57.493]                             name <- restart$name
[10:33:57.493]                             if (is.null(name)) 
[10:33:57.493]                               next
[10:33:57.493]                             if (!grepl(pattern, name)) 
[10:33:57.493]                               next
[10:33:57.493]                             invokeRestart(restart)
[10:33:57.493]                             muffled <- TRUE
[10:33:57.493]                             break
[10:33:57.493]                           }
[10:33:57.493]                         }
[10:33:57.493]                       }
[10:33:57.493]                       invisible(muffled)
[10:33:57.493]                     }
[10:33:57.493]                     muffleCondition(cond, pattern = "^muffle")
[10:33:57.493]                   }
[10:33:57.493]                 }
[10:33:57.493]                 else {
[10:33:57.493]                   if (TRUE) {
[10:33:57.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:57.493]                     {
[10:33:57.493]                       inherits <- base::inherits
[10:33:57.493]                       invokeRestart <- base::invokeRestart
[10:33:57.493]                       is.null <- base::is.null
[10:33:57.493]                       muffled <- FALSE
[10:33:57.493]                       if (inherits(cond, "message")) {
[10:33:57.493]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:57.493]                         if (muffled) 
[10:33:57.493]                           invokeRestart("muffleMessage")
[10:33:57.493]                       }
[10:33:57.493]                       else if (inherits(cond, "warning")) {
[10:33:57.493]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:57.493]                         if (muffled) 
[10:33:57.493]                           invokeRestart("muffleWarning")
[10:33:57.493]                       }
[10:33:57.493]                       else if (inherits(cond, "condition")) {
[10:33:57.493]                         if (!is.null(pattern)) {
[10:33:57.493]                           computeRestarts <- base::computeRestarts
[10:33:57.493]                           grepl <- base::grepl
[10:33:57.493]                           restarts <- computeRestarts(cond)
[10:33:57.493]                           for (restart in restarts) {
[10:33:57.493]                             name <- restart$name
[10:33:57.493]                             if (is.null(name)) 
[10:33:57.493]                               next
[10:33:57.493]                             if (!grepl(pattern, name)) 
[10:33:57.493]                               next
[10:33:57.493]                             invokeRestart(restart)
[10:33:57.493]                             muffled <- TRUE
[10:33:57.493]                             break
[10:33:57.493]                           }
[10:33:57.493]                         }
[10:33:57.493]                       }
[10:33:57.493]                       invisible(muffled)
[10:33:57.493]                     }
[10:33:57.493]                     muffleCondition(cond, pattern = "^muffle")
[10:33:57.493]                   }
[10:33:57.493]                 }
[10:33:57.493]             }
[10:33:57.493]         }))
[10:33:57.493]     }, error = function(ex) {
[10:33:57.493]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:57.493]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:57.493]                 ...future.rng), started = ...future.startTime, 
[10:33:57.493]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:57.493]             version = "1.8"), class = "FutureResult")
[10:33:57.493]     }, finally = {
[10:33:57.493]         if (!identical(...future.workdir, getwd())) 
[10:33:57.493]             setwd(...future.workdir)
[10:33:57.493]         {
[10:33:57.493]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:57.493]                 ...future.oldOptions$nwarnings <- NULL
[10:33:57.493]             }
[10:33:57.493]             base::options(...future.oldOptions)
[10:33:57.493]             if (.Platform$OS.type == "windows") {
[10:33:57.493]                 old_names <- names(...future.oldEnvVars)
[10:33:57.493]                 envs <- base::Sys.getenv()
[10:33:57.493]                 names <- names(envs)
[10:33:57.493]                 common <- intersect(names, old_names)
[10:33:57.493]                 added <- setdiff(names, old_names)
[10:33:57.493]                 removed <- setdiff(old_names, names)
[10:33:57.493]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:57.493]                   envs[common]]
[10:33:57.493]                 NAMES <- toupper(changed)
[10:33:57.493]                 args <- list()
[10:33:57.493]                 for (kk in seq_along(NAMES)) {
[10:33:57.493]                   name <- changed[[kk]]
[10:33:57.493]                   NAME <- NAMES[[kk]]
[10:33:57.493]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:57.493]                     next
[10:33:57.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:57.493]                 }
[10:33:57.493]                 NAMES <- toupper(added)
[10:33:57.493]                 for (kk in seq_along(NAMES)) {
[10:33:57.493]                   name <- added[[kk]]
[10:33:57.493]                   NAME <- NAMES[[kk]]
[10:33:57.493]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:57.493]                     next
[10:33:57.493]                   args[[name]] <- ""
[10:33:57.493]                 }
[10:33:57.493]                 NAMES <- toupper(removed)
[10:33:57.493]                 for (kk in seq_along(NAMES)) {
[10:33:57.493]                   name <- removed[[kk]]
[10:33:57.493]                   NAME <- NAMES[[kk]]
[10:33:57.493]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:57.493]                     next
[10:33:57.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:57.493]                 }
[10:33:57.493]                 if (length(args) > 0) 
[10:33:57.493]                   base::do.call(base::Sys.setenv, args = args)
[10:33:57.493]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:57.493]             }
[10:33:57.493]             else {
[10:33:57.493]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:57.493]             }
[10:33:57.493]             {
[10:33:57.493]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:57.493]                   0L) {
[10:33:57.493]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:57.493]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:57.493]                   base::options(opts)
[10:33:57.493]                 }
[10:33:57.493]                 {
[10:33:57.493]                   {
[10:33:57.493]                     NULL
[10:33:57.493]                     RNGkind("Mersenne-Twister")
[10:33:57.493]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:57.493]                       inherits = FALSE)
[10:33:57.493]                   }
[10:33:57.493]                   options(future.plan = NULL)
[10:33:57.493]                   if (is.na(NA_character_)) 
[10:33:57.493]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:57.493]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:57.493]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:57.493]                     .init = FALSE)
[10:33:57.493]                 }
[10:33:57.493]             }
[10:33:57.493]         }
[10:33:57.493]     })
[10:33:57.493]     if (TRUE) {
[10:33:57.493]         base::sink(type = "output", split = FALSE)
[10:33:57.493]         if (TRUE) {
[10:33:57.493]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:57.493]         }
[10:33:57.493]         else {
[10:33:57.493]             ...future.result["stdout"] <- base::list(NULL)
[10:33:57.493]         }
[10:33:57.493]         base::close(...future.stdout)
[10:33:57.493]         ...future.stdout <- NULL
[10:33:57.493]     }
[10:33:57.493]     ...future.result$conditions <- ...future.conditions
[10:33:57.493]     ...future.result$finished <- base::Sys.time()
[10:33:57.493]     ...future.result
[10:33:57.493] }
[10:33:57.495] plan(): Setting new future strategy stack:
[10:33:57.495] List of future strategies:
[10:33:57.495] 1. sequential:
[10:33:57.495]    - args: function (..., envir = parent.frame())
[10:33:57.495]    - tweaked: FALSE
[10:33:57.495]    - call: NULL
[10:33:57.495] plan(): nbrOfWorkers() = 1
[10:33:57.496] plan(): Setting new future strategy stack:
[10:33:57.496] List of future strategies:
[10:33:57.496] 1. sequential:
[10:33:57.496]    - args: function (..., envir = parent.frame())
[10:33:57.496]    - tweaked: FALSE
[10:33:57.496]    - call: plan(strategy)
[10:33:57.496] plan(): nbrOfWorkers() = 1
[10:33:57.496] SequentialFuture started (and completed)
[10:33:57.496] - Launch lazy future ... done
[10:33:57.497] run() for ‘SequentialFuture’ ... done
[10:33:57.497] resolved() for ‘SequentialFuture’ ...
[10:33:57.497] - state: ‘finished’
[10:33:57.497] - run: TRUE
[10:33:57.497] - result: ‘FutureResult’
[10:33:57.497] resolved() for ‘SequentialFuture’ ... done
[10:33:57.497] Future #1
[10:33:57.497]  length: 2 (resolved future 1)
[10:33:57.497] resolved() for ‘SequentialFuture’ ...
[10:33:57.497] - state: ‘finished’
[10:33:57.498] - run: TRUE
[10:33:57.498] - result: ‘FutureResult’
[10:33:57.498] resolved() for ‘SequentialFuture’ ... done
[10:33:57.498] Future #2
[10:33:57.498]  length: 1 (resolved future 2)
[10:33:57.498]  length: 0 (resolved future 3)
[10:33:57.498] resolve() on list ... DONE
[10:33:57.498] resolved() for ‘SequentialFuture’ ...
[10:33:57.498] - state: ‘finished’
[10:33:57.498] - run: TRUE
[10:33:57.498] - result: ‘FutureResult’
[10:33:57.498] resolved() for ‘SequentialFuture’ ... done
[10:33:57.499] resolved() for ‘SequentialFuture’ ...
[10:33:57.499] - state: ‘finished’
[10:33:57.499] - run: TRUE
[10:33:57.499] - result: ‘FutureResult’
[10:33:57.499] resolved() for ‘SequentialFuture’ ... done
[10:33:57.499] getGlobalsAndPackages() ...
[10:33:57.499] Searching for globals...
[10:33:57.499] 
[10:33:57.499] Searching for globals ... DONE
[10:33:57.500] - globals: [0] <none>
[10:33:57.500] getGlobalsAndPackages() ... DONE
[10:33:57.500] getGlobalsAndPackages() ...
[10:33:57.500] Searching for globals...
[10:33:57.500] 
[10:33:57.500] Searching for globals ... DONE
[10:33:57.500] - globals: [0] <none>
[10:33:57.500] getGlobalsAndPackages() ... DONE
[10:33:57.501] resolve() on list ...
[10:33:57.501]  recursive: 0
[10:33:57.501]  length: 3
[10:33:57.501]  elements: ‘a’, ‘b’, ‘’
[10:33:57.501] run() for ‘Future’ ...
[10:33:57.501] - state: ‘created’
[10:33:57.501] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:57.501] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:57.502] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:57.502]   - Field: ‘label’
[10:33:57.502]   - Field: ‘local’
[10:33:57.502]   - Field: ‘owner’
[10:33:57.502]   - Field: ‘envir’
[10:33:57.502]   - Field: ‘packages’
[10:33:57.502]   - Field: ‘gc’
[10:33:57.502]   - Field: ‘conditions’
[10:33:57.502]   - Field: ‘expr’
[10:33:57.502]   - Field: ‘uuid’
[10:33:57.502]   - Field: ‘seed’
[10:33:57.503]   - Field: ‘version’
[10:33:57.503]   - Field: ‘result’
[10:33:57.503]   - Field: ‘asynchronous’
[10:33:57.503]   - Field: ‘calls’
[10:33:57.503]   - Field: ‘globals’
[10:33:57.503]   - Field: ‘stdout’
[10:33:57.503]   - Field: ‘earlySignal’
[10:33:57.503]   - Field: ‘lazy’
[10:33:57.503]   - Field: ‘state’
[10:33:57.503] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:57.503] - Launch lazy future ...
[10:33:57.504] Packages needed by the future expression (n = 0): <none>
[10:33:57.504] Packages needed by future strategies (n = 0): <none>
[10:33:57.504] {
[10:33:57.504]     {
[10:33:57.504]         {
[10:33:57.504]             ...future.startTime <- base::Sys.time()
[10:33:57.504]             {
[10:33:57.504]                 {
[10:33:57.504]                   {
[10:33:57.504]                     base::local({
[10:33:57.504]                       has_future <- base::requireNamespace("future", 
[10:33:57.504]                         quietly = TRUE)
[10:33:57.504]                       if (has_future) {
[10:33:57.504]                         ns <- base::getNamespace("future")
[10:33:57.504]                         version <- ns[[".package"]][["version"]]
[10:33:57.504]                         if (is.null(version)) 
[10:33:57.504]                           version <- utils::packageVersion("future")
[10:33:57.504]                       }
[10:33:57.504]                       else {
[10:33:57.504]                         version <- NULL
[10:33:57.504]                       }
[10:33:57.504]                       if (!has_future || version < "1.8.0") {
[10:33:57.504]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:57.504]                           "", base::R.version$version.string), 
[10:33:57.504]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:57.504]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:57.504]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:57.504]                             "release", "version")], collapse = " "), 
[10:33:57.504]                           hostname = base::Sys.info()[["nodename"]])
[10:33:57.504]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:57.504]                           info)
[10:33:57.504]                         info <- base::paste(info, collapse = "; ")
[10:33:57.504]                         if (!has_future) {
[10:33:57.504]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:57.504]                             info)
[10:33:57.504]                         }
[10:33:57.504]                         else {
[10:33:57.504]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:57.504]                             info, version)
[10:33:57.504]                         }
[10:33:57.504]                         base::stop(msg)
[10:33:57.504]                       }
[10:33:57.504]                     })
[10:33:57.504]                   }
[10:33:57.504]                   ...future.strategy.old <- future::plan("list")
[10:33:57.504]                   options(future.plan = NULL)
[10:33:57.504]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:57.504]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:57.504]                 }
[10:33:57.504]                 ...future.workdir <- getwd()
[10:33:57.504]             }
[10:33:57.504]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:57.504]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:57.504]         }
[10:33:57.504]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:57.504]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:57.504]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:57.504]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:57.504]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:57.504]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:57.504]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:57.504]             base::names(...future.oldOptions))
[10:33:57.504]     }
[10:33:57.504]     if (FALSE) {
[10:33:57.504]     }
[10:33:57.504]     else {
[10:33:57.504]         if (TRUE) {
[10:33:57.504]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:57.504]                 open = "w")
[10:33:57.504]         }
[10:33:57.504]         else {
[10:33:57.504]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:57.504]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:57.504]         }
[10:33:57.504]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:57.504]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:57.504]             base::sink(type = "output", split = FALSE)
[10:33:57.504]             base::close(...future.stdout)
[10:33:57.504]         }, add = TRUE)
[10:33:57.504]     }
[10:33:57.504]     ...future.frame <- base::sys.nframe()
[10:33:57.504]     ...future.conditions <- base::list()
[10:33:57.504]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:57.504]     if (FALSE) {
[10:33:57.504]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:57.504]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:57.504]     }
[10:33:57.504]     ...future.result <- base::tryCatch({
[10:33:57.504]         base::withCallingHandlers({
[10:33:57.504]             ...future.value <- base::withVisible(base::local(1))
[10:33:57.504]             future::FutureResult(value = ...future.value$value, 
[10:33:57.504]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:57.504]                   ...future.rng), globalenv = if (FALSE) 
[10:33:57.504]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:57.504]                     ...future.globalenv.names))
[10:33:57.504]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:57.504]         }, condition = base::local({
[10:33:57.504]             c <- base::c
[10:33:57.504]             inherits <- base::inherits
[10:33:57.504]             invokeRestart <- base::invokeRestart
[10:33:57.504]             length <- base::length
[10:33:57.504]             list <- base::list
[10:33:57.504]             seq.int <- base::seq.int
[10:33:57.504]             signalCondition <- base::signalCondition
[10:33:57.504]             sys.calls <- base::sys.calls
[10:33:57.504]             `[[` <- base::`[[`
[10:33:57.504]             `+` <- base::`+`
[10:33:57.504]             `<<-` <- base::`<<-`
[10:33:57.504]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:57.504]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:57.504]                   3L)]
[10:33:57.504]             }
[10:33:57.504]             function(cond) {
[10:33:57.504]                 is_error <- inherits(cond, "error")
[10:33:57.504]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:57.504]                   NULL)
[10:33:57.504]                 if (is_error) {
[10:33:57.504]                   sessionInformation <- function() {
[10:33:57.504]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:57.504]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:57.504]                       search = base::search(), system = base::Sys.info())
[10:33:57.504]                   }
[10:33:57.504]                   ...future.conditions[[length(...future.conditions) + 
[10:33:57.504]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:57.504]                     cond$call), session = sessionInformation(), 
[10:33:57.504]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:57.504]                   signalCondition(cond)
[10:33:57.504]                 }
[10:33:57.504]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:57.504]                 "immediateCondition"))) {
[10:33:57.504]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:57.504]                   ...future.conditions[[length(...future.conditions) + 
[10:33:57.504]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:57.504]                   if (TRUE && !signal) {
[10:33:57.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:57.504]                     {
[10:33:57.504]                       inherits <- base::inherits
[10:33:57.504]                       invokeRestart <- base::invokeRestart
[10:33:57.504]                       is.null <- base::is.null
[10:33:57.504]                       muffled <- FALSE
[10:33:57.504]                       if (inherits(cond, "message")) {
[10:33:57.504]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:57.504]                         if (muffled) 
[10:33:57.504]                           invokeRestart("muffleMessage")
[10:33:57.504]                       }
[10:33:57.504]                       else if (inherits(cond, "warning")) {
[10:33:57.504]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:57.504]                         if (muffled) 
[10:33:57.504]                           invokeRestart("muffleWarning")
[10:33:57.504]                       }
[10:33:57.504]                       else if (inherits(cond, "condition")) {
[10:33:57.504]                         if (!is.null(pattern)) {
[10:33:57.504]                           computeRestarts <- base::computeRestarts
[10:33:57.504]                           grepl <- base::grepl
[10:33:57.504]                           restarts <- computeRestarts(cond)
[10:33:57.504]                           for (restart in restarts) {
[10:33:57.504]                             name <- restart$name
[10:33:57.504]                             if (is.null(name)) 
[10:33:57.504]                               next
[10:33:57.504]                             if (!grepl(pattern, name)) 
[10:33:57.504]                               next
[10:33:57.504]                             invokeRestart(restart)
[10:33:57.504]                             muffled <- TRUE
[10:33:57.504]                             break
[10:33:57.504]                           }
[10:33:57.504]                         }
[10:33:57.504]                       }
[10:33:57.504]                       invisible(muffled)
[10:33:57.504]                     }
[10:33:57.504]                     muffleCondition(cond, pattern = "^muffle")
[10:33:57.504]                   }
[10:33:57.504]                 }
[10:33:57.504]                 else {
[10:33:57.504]                   if (TRUE) {
[10:33:57.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:57.504]                     {
[10:33:57.504]                       inherits <- base::inherits
[10:33:57.504]                       invokeRestart <- base::invokeRestart
[10:33:57.504]                       is.null <- base::is.null
[10:33:57.504]                       muffled <- FALSE
[10:33:57.504]                       if (inherits(cond, "message")) {
[10:33:57.504]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:57.504]                         if (muffled) 
[10:33:57.504]                           invokeRestart("muffleMessage")
[10:33:57.504]                       }
[10:33:57.504]                       else if (inherits(cond, "warning")) {
[10:33:57.504]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:57.504]                         if (muffled) 
[10:33:57.504]                           invokeRestart("muffleWarning")
[10:33:57.504]                       }
[10:33:57.504]                       else if (inherits(cond, "condition")) {
[10:33:57.504]                         if (!is.null(pattern)) {
[10:33:57.504]                           computeRestarts <- base::computeRestarts
[10:33:57.504]                           grepl <- base::grepl
[10:33:57.504]                           restarts <- computeRestarts(cond)
[10:33:57.504]                           for (restart in restarts) {
[10:33:57.504]                             name <- restart$name
[10:33:57.504]                             if (is.null(name)) 
[10:33:57.504]                               next
[10:33:57.504]                             if (!grepl(pattern, name)) 
[10:33:57.504]                               next
[10:33:57.504]                             invokeRestart(restart)
[10:33:57.504]                             muffled <- TRUE
[10:33:57.504]                             break
[10:33:57.504]                           }
[10:33:57.504]                         }
[10:33:57.504]                       }
[10:33:57.504]                       invisible(muffled)
[10:33:57.504]                     }
[10:33:57.504]                     muffleCondition(cond, pattern = "^muffle")
[10:33:57.504]                   }
[10:33:57.504]                 }
[10:33:57.504]             }
[10:33:57.504]         }))
[10:33:57.504]     }, error = function(ex) {
[10:33:57.504]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:57.504]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:57.504]                 ...future.rng), started = ...future.startTime, 
[10:33:57.504]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:57.504]             version = "1.8"), class = "FutureResult")
[10:33:57.504]     }, finally = {
[10:33:57.504]         if (!identical(...future.workdir, getwd())) 
[10:33:57.504]             setwd(...future.workdir)
[10:33:57.504]         {
[10:33:57.504]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:57.504]                 ...future.oldOptions$nwarnings <- NULL
[10:33:57.504]             }
[10:33:57.504]             base::options(...future.oldOptions)
[10:33:57.504]             if (.Platform$OS.type == "windows") {
[10:33:57.504]                 old_names <- names(...future.oldEnvVars)
[10:33:57.504]                 envs <- base::Sys.getenv()
[10:33:57.504]                 names <- names(envs)
[10:33:57.504]                 common <- intersect(names, old_names)
[10:33:57.504]                 added <- setdiff(names, old_names)
[10:33:57.504]                 removed <- setdiff(old_names, names)
[10:33:57.504]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:57.504]                   envs[common]]
[10:33:57.504]                 NAMES <- toupper(changed)
[10:33:57.504]                 args <- list()
[10:33:57.504]                 for (kk in seq_along(NAMES)) {
[10:33:57.504]                   name <- changed[[kk]]
[10:33:57.504]                   NAME <- NAMES[[kk]]
[10:33:57.504]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:57.504]                     next
[10:33:57.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:57.504]                 }
[10:33:57.504]                 NAMES <- toupper(added)
[10:33:57.504]                 for (kk in seq_along(NAMES)) {
[10:33:57.504]                   name <- added[[kk]]
[10:33:57.504]                   NAME <- NAMES[[kk]]
[10:33:57.504]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:57.504]                     next
[10:33:57.504]                   args[[name]] <- ""
[10:33:57.504]                 }
[10:33:57.504]                 NAMES <- toupper(removed)
[10:33:57.504]                 for (kk in seq_along(NAMES)) {
[10:33:57.504]                   name <- removed[[kk]]
[10:33:57.504]                   NAME <- NAMES[[kk]]
[10:33:57.504]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:57.504]                     next
[10:33:57.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:57.504]                 }
[10:33:57.504]                 if (length(args) > 0) 
[10:33:57.504]                   base::do.call(base::Sys.setenv, args = args)
[10:33:57.504]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:57.504]             }
[10:33:57.504]             else {
[10:33:57.504]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:57.504]             }
[10:33:57.504]             {
[10:33:57.504]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:57.504]                   0L) {
[10:33:57.504]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:57.504]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:57.504]                   base::options(opts)
[10:33:57.504]                 }
[10:33:57.504]                 {
[10:33:57.504]                   {
[10:33:57.504]                     NULL
[10:33:57.504]                     RNGkind("Mersenne-Twister")
[10:33:57.504]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:57.504]                       inherits = FALSE)
[10:33:57.504]                   }
[10:33:57.504]                   options(future.plan = NULL)
[10:33:57.504]                   if (is.na(NA_character_)) 
[10:33:57.504]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:57.504]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:57.504]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:57.504]                     .init = FALSE)
[10:33:57.504]                 }
[10:33:57.504]             }
[10:33:57.504]         }
[10:33:57.504]     })
[10:33:57.504]     if (TRUE) {
[10:33:57.504]         base::sink(type = "output", split = FALSE)
[10:33:57.504]         if (TRUE) {
[10:33:57.504]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:57.504]         }
[10:33:57.504]         else {
[10:33:57.504]             ...future.result["stdout"] <- base::list(NULL)
[10:33:57.504]         }
[10:33:57.504]         base::close(...future.stdout)
[10:33:57.504]         ...future.stdout <- NULL
[10:33:57.504]     }
[10:33:57.504]     ...future.result$conditions <- ...future.conditions
[10:33:57.504]     ...future.result$finished <- base::Sys.time()
[10:33:57.504]     ...future.result
[10:33:57.504] }
[10:33:57.506] plan(): Setting new future strategy stack:
[10:33:57.506] List of future strategies:
[10:33:57.506] 1. sequential:
[10:33:57.506]    - args: function (..., envir = parent.frame())
[10:33:57.506]    - tweaked: FALSE
[10:33:57.506]    - call: NULL
[10:33:57.506] plan(): nbrOfWorkers() = 1
[10:33:57.507] plan(): Setting new future strategy stack:
[10:33:57.507] List of future strategies:
[10:33:57.507] 1. sequential:
[10:33:57.507]    - args: function (..., envir = parent.frame())
[10:33:57.507]    - tweaked: FALSE
[10:33:57.507]    - call: plan(strategy)
[10:33:57.507] plan(): nbrOfWorkers() = 1
[10:33:57.507] SequentialFuture started (and completed)
[10:33:57.508] - Launch lazy future ... done
[10:33:57.508] run() for ‘SequentialFuture’ ... done
[10:33:57.508] resolved() for ‘SequentialFuture’ ...
[10:33:57.508] - state: ‘finished’
[10:33:57.508] - run: TRUE
[10:33:57.508] - result: ‘FutureResult’
[10:33:57.508] resolved() for ‘SequentialFuture’ ... done
[10:33:57.508] Future #1
[10:33:57.508]  length: 2 (resolved future 1)
[10:33:57.508] run() for ‘Future’ ...
[10:33:57.508] - state: ‘created’
[10:33:57.509] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:57.509] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:57.509] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:57.509]   - Field: ‘label’
[10:33:57.509]   - Field: ‘local’
[10:33:57.509]   - Field: ‘owner’
[10:33:57.509]   - Field: ‘envir’
[10:33:57.509]   - Field: ‘packages’
[10:33:57.510]   - Field: ‘gc’
[10:33:57.510]   - Field: ‘conditions’
[10:33:57.510]   - Field: ‘expr’
[10:33:57.510]   - Field: ‘uuid’
[10:33:57.510]   - Field: ‘seed’
[10:33:57.510]   - Field: ‘version’
[10:33:57.510]   - Field: ‘result’
[10:33:57.510]   - Field: ‘asynchronous’
[10:33:57.510]   - Field: ‘calls’
[10:33:57.510]   - Field: ‘globals’
[10:33:57.510]   - Field: ‘stdout’
[10:33:57.510]   - Field: ‘earlySignal’
[10:33:57.511]   - Field: ‘lazy’
[10:33:57.511]   - Field: ‘state’
[10:33:57.511] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:57.511] - Launch lazy future ...
[10:33:57.511] Packages needed by the future expression (n = 0): <none>
[10:33:57.511] Packages needed by future strategies (n = 0): <none>
[10:33:57.513] {
[10:33:57.513]     {
[10:33:57.513]         {
[10:33:57.513]             ...future.startTime <- base::Sys.time()
[10:33:57.513]             {
[10:33:57.513]                 {
[10:33:57.513]                   {
[10:33:57.513]                     base::local({
[10:33:57.513]                       has_future <- base::requireNamespace("future", 
[10:33:57.513]                         quietly = TRUE)
[10:33:57.513]                       if (has_future) {
[10:33:57.513]                         ns <- base::getNamespace("future")
[10:33:57.513]                         version <- ns[[".package"]][["version"]]
[10:33:57.513]                         if (is.null(version)) 
[10:33:57.513]                           version <- utils::packageVersion("future")
[10:33:57.513]                       }
[10:33:57.513]                       else {
[10:33:57.513]                         version <- NULL
[10:33:57.513]                       }
[10:33:57.513]                       if (!has_future || version < "1.8.0") {
[10:33:57.513]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:57.513]                           "", base::R.version$version.string), 
[10:33:57.513]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:57.513]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:57.513]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:57.513]                             "release", "version")], collapse = " "), 
[10:33:57.513]                           hostname = base::Sys.info()[["nodename"]])
[10:33:57.513]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:57.513]                           info)
[10:33:57.513]                         info <- base::paste(info, collapse = "; ")
[10:33:57.513]                         if (!has_future) {
[10:33:57.513]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:57.513]                             info)
[10:33:57.513]                         }
[10:33:57.513]                         else {
[10:33:57.513]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:57.513]                             info, version)
[10:33:57.513]                         }
[10:33:57.513]                         base::stop(msg)
[10:33:57.513]                       }
[10:33:57.513]                     })
[10:33:57.513]                   }
[10:33:57.513]                   ...future.strategy.old <- future::plan("list")
[10:33:57.513]                   options(future.plan = NULL)
[10:33:57.513]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:57.513]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:57.513]                 }
[10:33:57.513]                 ...future.workdir <- getwd()
[10:33:57.513]             }
[10:33:57.513]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:57.513]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:57.513]         }
[10:33:57.513]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:57.513]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:57.513]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:57.513]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:57.513]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:57.513]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:57.513]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:57.513]             base::names(...future.oldOptions))
[10:33:57.513]     }
[10:33:57.513]     if (FALSE) {
[10:33:57.513]     }
[10:33:57.513]     else {
[10:33:57.513]         if (TRUE) {
[10:33:57.513]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:57.513]                 open = "w")
[10:33:57.513]         }
[10:33:57.513]         else {
[10:33:57.513]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:57.513]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:57.513]         }
[10:33:57.513]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:57.513]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:57.513]             base::sink(type = "output", split = FALSE)
[10:33:57.513]             base::close(...future.stdout)
[10:33:57.513]         }, add = TRUE)
[10:33:57.513]     }
[10:33:57.513]     ...future.frame <- base::sys.nframe()
[10:33:57.513]     ...future.conditions <- base::list()
[10:33:57.513]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:57.513]     if (FALSE) {
[10:33:57.513]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:57.513]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:57.513]     }
[10:33:57.513]     ...future.result <- base::tryCatch({
[10:33:57.513]         base::withCallingHandlers({
[10:33:57.513]             ...future.value <- base::withVisible(base::local(2))
[10:33:57.513]             future::FutureResult(value = ...future.value$value, 
[10:33:57.513]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:57.513]                   ...future.rng), globalenv = if (FALSE) 
[10:33:57.513]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:57.513]                     ...future.globalenv.names))
[10:33:57.513]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:57.513]         }, condition = base::local({
[10:33:57.513]             c <- base::c
[10:33:57.513]             inherits <- base::inherits
[10:33:57.513]             invokeRestart <- base::invokeRestart
[10:33:57.513]             length <- base::length
[10:33:57.513]             list <- base::list
[10:33:57.513]             seq.int <- base::seq.int
[10:33:57.513]             signalCondition <- base::signalCondition
[10:33:57.513]             sys.calls <- base::sys.calls
[10:33:57.513]             `[[` <- base::`[[`
[10:33:57.513]             `+` <- base::`+`
[10:33:57.513]             `<<-` <- base::`<<-`
[10:33:57.513]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:57.513]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:57.513]                   3L)]
[10:33:57.513]             }
[10:33:57.513]             function(cond) {
[10:33:57.513]                 is_error <- inherits(cond, "error")
[10:33:57.513]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:57.513]                   NULL)
[10:33:57.513]                 if (is_error) {
[10:33:57.513]                   sessionInformation <- function() {
[10:33:57.513]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:57.513]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:57.513]                       search = base::search(), system = base::Sys.info())
[10:33:57.513]                   }
[10:33:57.513]                   ...future.conditions[[length(...future.conditions) + 
[10:33:57.513]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:57.513]                     cond$call), session = sessionInformation(), 
[10:33:57.513]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:57.513]                   signalCondition(cond)
[10:33:57.513]                 }
[10:33:57.513]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:57.513]                 "immediateCondition"))) {
[10:33:57.513]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:57.513]                   ...future.conditions[[length(...future.conditions) + 
[10:33:57.513]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:57.513]                   if (TRUE && !signal) {
[10:33:57.513]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:57.513]                     {
[10:33:57.513]                       inherits <- base::inherits
[10:33:57.513]                       invokeRestart <- base::invokeRestart
[10:33:57.513]                       is.null <- base::is.null
[10:33:57.513]                       muffled <- FALSE
[10:33:57.513]                       if (inherits(cond, "message")) {
[10:33:57.513]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:57.513]                         if (muffled) 
[10:33:57.513]                           invokeRestart("muffleMessage")
[10:33:57.513]                       }
[10:33:57.513]                       else if (inherits(cond, "warning")) {
[10:33:57.513]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:57.513]                         if (muffled) 
[10:33:57.513]                           invokeRestart("muffleWarning")
[10:33:57.513]                       }
[10:33:57.513]                       else if (inherits(cond, "condition")) {
[10:33:57.513]                         if (!is.null(pattern)) {
[10:33:57.513]                           computeRestarts <- base::computeRestarts
[10:33:57.513]                           grepl <- base::grepl
[10:33:57.513]                           restarts <- computeRestarts(cond)
[10:33:57.513]                           for (restart in restarts) {
[10:33:57.513]                             name <- restart$name
[10:33:57.513]                             if (is.null(name)) 
[10:33:57.513]                               next
[10:33:57.513]                             if (!grepl(pattern, name)) 
[10:33:57.513]                               next
[10:33:57.513]                             invokeRestart(restart)
[10:33:57.513]                             muffled <- TRUE
[10:33:57.513]                             break
[10:33:57.513]                           }
[10:33:57.513]                         }
[10:33:57.513]                       }
[10:33:57.513]                       invisible(muffled)
[10:33:57.513]                     }
[10:33:57.513]                     muffleCondition(cond, pattern = "^muffle")
[10:33:57.513]                   }
[10:33:57.513]                 }
[10:33:57.513]                 else {
[10:33:57.513]                   if (TRUE) {
[10:33:57.513]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:57.513]                     {
[10:33:57.513]                       inherits <- base::inherits
[10:33:57.513]                       invokeRestart <- base::invokeRestart
[10:33:57.513]                       is.null <- base::is.null
[10:33:57.513]                       muffled <- FALSE
[10:33:57.513]                       if (inherits(cond, "message")) {
[10:33:57.513]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:57.513]                         if (muffled) 
[10:33:57.513]                           invokeRestart("muffleMessage")
[10:33:57.513]                       }
[10:33:57.513]                       else if (inherits(cond, "warning")) {
[10:33:57.513]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:57.513]                         if (muffled) 
[10:33:57.513]                           invokeRestart("muffleWarning")
[10:33:57.513]                       }
[10:33:57.513]                       else if (inherits(cond, "condition")) {
[10:33:57.513]                         if (!is.null(pattern)) {
[10:33:57.513]                           computeRestarts <- base::computeRestarts
[10:33:57.513]                           grepl <- base::grepl
[10:33:57.513]                           restarts <- computeRestarts(cond)
[10:33:57.513]                           for (restart in restarts) {
[10:33:57.513]                             name <- restart$name
[10:33:57.513]                             if (is.null(name)) 
[10:33:57.513]                               next
[10:33:57.513]                             if (!grepl(pattern, name)) 
[10:33:57.513]                               next
[10:33:57.513]                             invokeRestart(restart)
[10:33:57.513]                             muffled <- TRUE
[10:33:57.513]                             break
[10:33:57.513]                           }
[10:33:57.513]                         }
[10:33:57.513]                       }
[10:33:57.513]                       invisible(muffled)
[10:33:57.513]                     }
[10:33:57.513]                     muffleCondition(cond, pattern = "^muffle")
[10:33:57.513]                   }
[10:33:57.513]                 }
[10:33:57.513]             }
[10:33:57.513]         }))
[10:33:57.513]     }, error = function(ex) {
[10:33:57.513]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:57.513]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:57.513]                 ...future.rng), started = ...future.startTime, 
[10:33:57.513]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:57.513]             version = "1.8"), class = "FutureResult")
[10:33:57.513]     }, finally = {
[10:33:57.513]         if (!identical(...future.workdir, getwd())) 
[10:33:57.513]             setwd(...future.workdir)
[10:33:57.513]         {
[10:33:57.513]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:57.513]                 ...future.oldOptions$nwarnings <- NULL
[10:33:57.513]             }
[10:33:57.513]             base::options(...future.oldOptions)
[10:33:57.513]             if (.Platform$OS.type == "windows") {
[10:33:57.513]                 old_names <- names(...future.oldEnvVars)
[10:33:57.513]                 envs <- base::Sys.getenv()
[10:33:57.513]                 names <- names(envs)
[10:33:57.513]                 common <- intersect(names, old_names)
[10:33:57.513]                 added <- setdiff(names, old_names)
[10:33:57.513]                 removed <- setdiff(old_names, names)
[10:33:57.513]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:57.513]                   envs[common]]
[10:33:57.513]                 NAMES <- toupper(changed)
[10:33:57.513]                 args <- list()
[10:33:57.513]                 for (kk in seq_along(NAMES)) {
[10:33:57.513]                   name <- changed[[kk]]
[10:33:57.513]                   NAME <- NAMES[[kk]]
[10:33:57.513]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:57.513]                     next
[10:33:57.513]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:57.513]                 }
[10:33:57.513]                 NAMES <- toupper(added)
[10:33:57.513]                 for (kk in seq_along(NAMES)) {
[10:33:57.513]                   name <- added[[kk]]
[10:33:57.513]                   NAME <- NAMES[[kk]]
[10:33:57.513]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:57.513]                     next
[10:33:57.513]                   args[[name]] <- ""
[10:33:57.513]                 }
[10:33:57.513]                 NAMES <- toupper(removed)
[10:33:57.513]                 for (kk in seq_along(NAMES)) {
[10:33:57.513]                   name <- removed[[kk]]
[10:33:57.513]                   NAME <- NAMES[[kk]]
[10:33:57.513]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:57.513]                     next
[10:33:57.513]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:57.513]                 }
[10:33:57.513]                 if (length(args) > 0) 
[10:33:57.513]                   base::do.call(base::Sys.setenv, args = args)
[10:33:57.513]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:57.513]             }
[10:33:57.513]             else {
[10:33:57.513]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:57.513]             }
[10:33:57.513]             {
[10:33:57.513]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:57.513]                   0L) {
[10:33:57.513]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:57.513]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:57.513]                   base::options(opts)
[10:33:57.513]                 }
[10:33:57.513]                 {
[10:33:57.513]                   {
[10:33:57.513]                     NULL
[10:33:57.513]                     RNGkind("Mersenne-Twister")
[10:33:57.513]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:57.513]                       inherits = FALSE)
[10:33:57.513]                   }
[10:33:57.513]                   options(future.plan = NULL)
[10:33:57.513]                   if (is.na(NA_character_)) 
[10:33:57.513]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:57.513]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:57.513]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:57.513]                     .init = FALSE)
[10:33:57.513]                 }
[10:33:57.513]             }
[10:33:57.513]         }
[10:33:57.513]     })
[10:33:57.513]     if (TRUE) {
[10:33:57.513]         base::sink(type = "output", split = FALSE)
[10:33:57.513]         if (TRUE) {
[10:33:57.513]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:57.513]         }
[10:33:57.513]         else {
[10:33:57.513]             ...future.result["stdout"] <- base::list(NULL)
[10:33:57.513]         }
[10:33:57.513]         base::close(...future.stdout)
[10:33:57.513]         ...future.stdout <- NULL
[10:33:57.513]     }
[10:33:57.513]     ...future.result$conditions <- ...future.conditions
[10:33:57.513]     ...future.result$finished <- base::Sys.time()
[10:33:57.513]     ...future.result
[10:33:57.513] }
[10:33:57.515] plan(): Setting new future strategy stack:
[10:33:57.515] List of future strategies:
[10:33:57.515] 1. sequential:
[10:33:57.515]    - args: function (..., envir = parent.frame())
[10:33:57.515]    - tweaked: FALSE
[10:33:57.515]    - call: NULL
[10:33:57.515] plan(): nbrOfWorkers() = 1
[10:33:57.516] plan(): Setting new future strategy stack:
[10:33:57.516] List of future strategies:
[10:33:57.516] 1. sequential:
[10:33:57.516]    - args: function (..., envir = parent.frame())
[10:33:57.516]    - tweaked: FALSE
[10:33:57.516]    - call: plan(strategy)
[10:33:57.516] plan(): nbrOfWorkers() = 1
[10:33:57.516] SequentialFuture started (and completed)
[10:33:57.516] - Launch lazy future ... done
[10:33:57.516] run() for ‘SequentialFuture’ ... done
[10:33:57.517] resolved() for ‘SequentialFuture’ ...
[10:33:57.517] - state: ‘finished’
[10:33:57.517] - run: TRUE
[10:33:57.517] - result: ‘FutureResult’
[10:33:57.517] resolved() for ‘SequentialFuture’ ... done
[10:33:57.517] Future #2
[10:33:57.517]  length: 1 (resolved future 2)
[10:33:57.517]  length: 0 (resolved future 3)
[10:33:57.517] resolve() on list ... DONE
[10:33:57.517] resolved() for ‘SequentialFuture’ ...
[10:33:57.518] - state: ‘finished’
[10:33:57.518] - run: TRUE
[10:33:57.518] - result: ‘FutureResult’
[10:33:57.518] resolved() for ‘SequentialFuture’ ... done
[10:33:57.518] resolved() for ‘SequentialFuture’ ...
[10:33:57.518] - state: ‘finished’
[10:33:57.518] - run: TRUE
[10:33:57.518] - result: ‘FutureResult’
[10:33:57.518] resolved() for ‘SequentialFuture’ ... done
[10:33:57.518] getGlobalsAndPackages() ...
[10:33:57.518] Searching for globals...
[10:33:57.519] 
[10:33:57.519] Searching for globals ... DONE
[10:33:57.519] - globals: [0] <none>
[10:33:57.519] getGlobalsAndPackages() ... DONE
[10:33:57.519] run() for ‘Future’ ...
[10:33:57.519] - state: ‘created’
[10:33:57.519] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:57.520] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:57.520] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:57.520]   - Field: ‘label’
[10:33:57.520]   - Field: ‘local’
[10:33:57.520]   - Field: ‘owner’
[10:33:57.520]   - Field: ‘envir’
[10:33:57.520]   - Field: ‘packages’
[10:33:57.520]   - Field: ‘gc’
[10:33:57.520]   - Field: ‘conditions’
[10:33:57.521]   - Field: ‘expr’
[10:33:57.521]   - Field: ‘uuid’
[10:33:57.521]   - Field: ‘seed’
[10:33:57.521]   - Field: ‘version’
[10:33:57.521]   - Field: ‘result’
[10:33:57.521]   - Field: ‘asynchronous’
[10:33:57.521]   - Field: ‘calls’
[10:33:57.521]   - Field: ‘globals’
[10:33:57.521]   - Field: ‘stdout’
[10:33:57.521]   - Field: ‘earlySignal’
[10:33:57.522]   - Field: ‘lazy’
[10:33:57.522]   - Field: ‘state’
[10:33:57.522] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:57.522] - Launch lazy future ...
[10:33:57.522] Packages needed by the future expression (n = 0): <none>
[10:33:57.522] Packages needed by future strategies (n = 0): <none>
[10:33:57.522] {
[10:33:57.522]     {
[10:33:57.522]         {
[10:33:57.522]             ...future.startTime <- base::Sys.time()
[10:33:57.522]             {
[10:33:57.522]                 {
[10:33:57.522]                   {
[10:33:57.522]                     base::local({
[10:33:57.522]                       has_future <- base::requireNamespace("future", 
[10:33:57.522]                         quietly = TRUE)
[10:33:57.522]                       if (has_future) {
[10:33:57.522]                         ns <- base::getNamespace("future")
[10:33:57.522]                         version <- ns[[".package"]][["version"]]
[10:33:57.522]                         if (is.null(version)) 
[10:33:57.522]                           version <- utils::packageVersion("future")
[10:33:57.522]                       }
[10:33:57.522]                       else {
[10:33:57.522]                         version <- NULL
[10:33:57.522]                       }
[10:33:57.522]                       if (!has_future || version < "1.8.0") {
[10:33:57.522]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:57.522]                           "", base::R.version$version.string), 
[10:33:57.522]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:57.522]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:57.522]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:57.522]                             "release", "version")], collapse = " "), 
[10:33:57.522]                           hostname = base::Sys.info()[["nodename"]])
[10:33:57.522]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:57.522]                           info)
[10:33:57.522]                         info <- base::paste(info, collapse = "; ")
[10:33:57.522]                         if (!has_future) {
[10:33:57.522]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:57.522]                             info)
[10:33:57.522]                         }
[10:33:57.522]                         else {
[10:33:57.522]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:57.522]                             info, version)
[10:33:57.522]                         }
[10:33:57.522]                         base::stop(msg)
[10:33:57.522]                       }
[10:33:57.522]                     })
[10:33:57.522]                   }
[10:33:57.522]                   ...future.strategy.old <- future::plan("list")
[10:33:57.522]                   options(future.plan = NULL)
[10:33:57.522]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:57.522]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:57.522]                 }
[10:33:57.522]                 ...future.workdir <- getwd()
[10:33:57.522]             }
[10:33:57.522]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:57.522]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:57.522]         }
[10:33:57.522]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:57.522]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:57.522]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:57.522]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:57.522]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:57.522]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:57.522]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:57.522]             base::names(...future.oldOptions))
[10:33:57.522]     }
[10:33:57.522]     if (FALSE) {
[10:33:57.522]     }
[10:33:57.522]     else {
[10:33:57.522]         if (TRUE) {
[10:33:57.522]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:57.522]                 open = "w")
[10:33:57.522]         }
[10:33:57.522]         else {
[10:33:57.522]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:57.522]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:57.522]         }
[10:33:57.522]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:57.522]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:57.522]             base::sink(type = "output", split = FALSE)
[10:33:57.522]             base::close(...future.stdout)
[10:33:57.522]         }, add = TRUE)
[10:33:57.522]     }
[10:33:57.522]     ...future.frame <- base::sys.nframe()
[10:33:57.522]     ...future.conditions <- base::list()
[10:33:57.522]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:57.522]     if (FALSE) {
[10:33:57.522]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:57.522]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:57.522]     }
[10:33:57.522]     ...future.result <- base::tryCatch({
[10:33:57.522]         base::withCallingHandlers({
[10:33:57.522]             ...future.value <- base::withVisible(base::local(1))
[10:33:57.522]             future::FutureResult(value = ...future.value$value, 
[10:33:57.522]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:57.522]                   ...future.rng), globalenv = if (FALSE) 
[10:33:57.522]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:57.522]                     ...future.globalenv.names))
[10:33:57.522]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:57.522]         }, condition = base::local({
[10:33:57.522]             c <- base::c
[10:33:57.522]             inherits <- base::inherits
[10:33:57.522]             invokeRestart <- base::invokeRestart
[10:33:57.522]             length <- base::length
[10:33:57.522]             list <- base::list
[10:33:57.522]             seq.int <- base::seq.int
[10:33:57.522]             signalCondition <- base::signalCondition
[10:33:57.522]             sys.calls <- base::sys.calls
[10:33:57.522]             `[[` <- base::`[[`
[10:33:57.522]             `+` <- base::`+`
[10:33:57.522]             `<<-` <- base::`<<-`
[10:33:57.522]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:57.522]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:57.522]                   3L)]
[10:33:57.522]             }
[10:33:57.522]             function(cond) {
[10:33:57.522]                 is_error <- inherits(cond, "error")
[10:33:57.522]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:57.522]                   NULL)
[10:33:57.522]                 if (is_error) {
[10:33:57.522]                   sessionInformation <- function() {
[10:33:57.522]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:57.522]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:57.522]                       search = base::search(), system = base::Sys.info())
[10:33:57.522]                   }
[10:33:57.522]                   ...future.conditions[[length(...future.conditions) + 
[10:33:57.522]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:57.522]                     cond$call), session = sessionInformation(), 
[10:33:57.522]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:57.522]                   signalCondition(cond)
[10:33:57.522]                 }
[10:33:57.522]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:57.522]                 "immediateCondition"))) {
[10:33:57.522]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:57.522]                   ...future.conditions[[length(...future.conditions) + 
[10:33:57.522]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:57.522]                   if (TRUE && !signal) {
[10:33:57.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:57.522]                     {
[10:33:57.522]                       inherits <- base::inherits
[10:33:57.522]                       invokeRestart <- base::invokeRestart
[10:33:57.522]                       is.null <- base::is.null
[10:33:57.522]                       muffled <- FALSE
[10:33:57.522]                       if (inherits(cond, "message")) {
[10:33:57.522]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:57.522]                         if (muffled) 
[10:33:57.522]                           invokeRestart("muffleMessage")
[10:33:57.522]                       }
[10:33:57.522]                       else if (inherits(cond, "warning")) {
[10:33:57.522]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:57.522]                         if (muffled) 
[10:33:57.522]                           invokeRestart("muffleWarning")
[10:33:57.522]                       }
[10:33:57.522]                       else if (inherits(cond, "condition")) {
[10:33:57.522]                         if (!is.null(pattern)) {
[10:33:57.522]                           computeRestarts <- base::computeRestarts
[10:33:57.522]                           grepl <- base::grepl
[10:33:57.522]                           restarts <- computeRestarts(cond)
[10:33:57.522]                           for (restart in restarts) {
[10:33:57.522]                             name <- restart$name
[10:33:57.522]                             if (is.null(name)) 
[10:33:57.522]                               next
[10:33:57.522]                             if (!grepl(pattern, name)) 
[10:33:57.522]                               next
[10:33:57.522]                             invokeRestart(restart)
[10:33:57.522]                             muffled <- TRUE
[10:33:57.522]                             break
[10:33:57.522]                           }
[10:33:57.522]                         }
[10:33:57.522]                       }
[10:33:57.522]                       invisible(muffled)
[10:33:57.522]                     }
[10:33:57.522]                     muffleCondition(cond, pattern = "^muffle")
[10:33:57.522]                   }
[10:33:57.522]                 }
[10:33:57.522]                 else {
[10:33:57.522]                   if (TRUE) {
[10:33:57.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:57.522]                     {
[10:33:57.522]                       inherits <- base::inherits
[10:33:57.522]                       invokeRestart <- base::invokeRestart
[10:33:57.522]                       is.null <- base::is.null
[10:33:57.522]                       muffled <- FALSE
[10:33:57.522]                       if (inherits(cond, "message")) {
[10:33:57.522]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:57.522]                         if (muffled) 
[10:33:57.522]                           invokeRestart("muffleMessage")
[10:33:57.522]                       }
[10:33:57.522]                       else if (inherits(cond, "warning")) {
[10:33:57.522]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:57.522]                         if (muffled) 
[10:33:57.522]                           invokeRestart("muffleWarning")
[10:33:57.522]                       }
[10:33:57.522]                       else if (inherits(cond, "condition")) {
[10:33:57.522]                         if (!is.null(pattern)) {
[10:33:57.522]                           computeRestarts <- base::computeRestarts
[10:33:57.522]                           grepl <- base::grepl
[10:33:57.522]                           restarts <- computeRestarts(cond)
[10:33:57.522]                           for (restart in restarts) {
[10:33:57.522]                             name <- restart$name
[10:33:57.522]                             if (is.null(name)) 
[10:33:57.522]                               next
[10:33:57.522]                             if (!grepl(pattern, name)) 
[10:33:57.522]                               next
[10:33:57.522]                             invokeRestart(restart)
[10:33:57.522]                             muffled <- TRUE
[10:33:57.522]                             break
[10:33:57.522]                           }
[10:33:57.522]                         }
[10:33:57.522]                       }
[10:33:57.522]                       invisible(muffled)
[10:33:57.522]                     }
[10:33:57.522]                     muffleCondition(cond, pattern = "^muffle")
[10:33:57.522]                   }
[10:33:57.522]                 }
[10:33:57.522]             }
[10:33:57.522]         }))
[10:33:57.522]     }, error = function(ex) {
[10:33:57.522]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:57.522]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:57.522]                 ...future.rng), started = ...future.startTime, 
[10:33:57.522]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:57.522]             version = "1.8"), class = "FutureResult")
[10:33:57.522]     }, finally = {
[10:33:57.522]         if (!identical(...future.workdir, getwd())) 
[10:33:57.522]             setwd(...future.workdir)
[10:33:57.522]         {
[10:33:57.522]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:57.522]                 ...future.oldOptions$nwarnings <- NULL
[10:33:57.522]             }
[10:33:57.522]             base::options(...future.oldOptions)
[10:33:57.522]             if (.Platform$OS.type == "windows") {
[10:33:57.522]                 old_names <- names(...future.oldEnvVars)
[10:33:57.522]                 envs <- base::Sys.getenv()
[10:33:57.522]                 names <- names(envs)
[10:33:57.522]                 common <- intersect(names, old_names)
[10:33:57.522]                 added <- setdiff(names, old_names)
[10:33:57.522]                 removed <- setdiff(old_names, names)
[10:33:57.522]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:57.522]                   envs[common]]
[10:33:57.522]                 NAMES <- toupper(changed)
[10:33:57.522]                 args <- list()
[10:33:57.522]                 for (kk in seq_along(NAMES)) {
[10:33:57.522]                   name <- changed[[kk]]
[10:33:57.522]                   NAME <- NAMES[[kk]]
[10:33:57.522]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:57.522]                     next
[10:33:57.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:57.522]                 }
[10:33:57.522]                 NAMES <- toupper(added)
[10:33:57.522]                 for (kk in seq_along(NAMES)) {
[10:33:57.522]                   name <- added[[kk]]
[10:33:57.522]                   NAME <- NAMES[[kk]]
[10:33:57.522]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:57.522]                     next
[10:33:57.522]                   args[[name]] <- ""
[10:33:57.522]                 }
[10:33:57.522]                 NAMES <- toupper(removed)
[10:33:57.522]                 for (kk in seq_along(NAMES)) {
[10:33:57.522]                   name <- removed[[kk]]
[10:33:57.522]                   NAME <- NAMES[[kk]]
[10:33:57.522]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:57.522]                     next
[10:33:57.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:57.522]                 }
[10:33:57.522]                 if (length(args) > 0) 
[10:33:57.522]                   base::do.call(base::Sys.setenv, args = args)
[10:33:57.522]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:57.522]             }
[10:33:57.522]             else {
[10:33:57.522]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:57.522]             }
[10:33:57.522]             {
[10:33:57.522]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:57.522]                   0L) {
[10:33:57.522]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:57.522]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:57.522]                   base::options(opts)
[10:33:57.522]                 }
[10:33:57.522]                 {
[10:33:57.522]                   {
[10:33:57.522]                     NULL
[10:33:57.522]                     RNGkind("Mersenne-Twister")
[10:33:57.522]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:57.522]                       inherits = FALSE)
[10:33:57.522]                   }
[10:33:57.522]                   options(future.plan = NULL)
[10:33:57.522]                   if (is.na(NA_character_)) 
[10:33:57.522]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:57.522]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:57.522]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:57.522]                     .init = FALSE)
[10:33:57.522]                 }
[10:33:57.522]             }
[10:33:57.522]         }
[10:33:57.522]     })
[10:33:57.522]     if (TRUE) {
[10:33:57.522]         base::sink(type = "output", split = FALSE)
[10:33:57.522]         if (TRUE) {
[10:33:57.522]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:57.522]         }
[10:33:57.522]         else {
[10:33:57.522]             ...future.result["stdout"] <- base::list(NULL)
[10:33:57.522]         }
[10:33:57.522]         base::close(...future.stdout)
[10:33:57.522]         ...future.stdout <- NULL
[10:33:57.522]     }
[10:33:57.522]     ...future.result$conditions <- ...future.conditions
[10:33:57.522]     ...future.result$finished <- base::Sys.time()
[10:33:57.522]     ...future.result
[10:33:57.522] }
[10:33:57.524] plan(): Setting new future strategy stack:
[10:33:57.524] List of future strategies:
[10:33:57.524] 1. sequential:
[10:33:57.524]    - args: function (..., envir = parent.frame())
[10:33:57.524]    - tweaked: FALSE
[10:33:57.524]    - call: NULL
[10:33:57.525] plan(): nbrOfWorkers() = 1
[10:33:57.525] plan(): Setting new future strategy stack:
[10:33:57.525] List of future strategies:
[10:33:57.525] 1. sequential:
[10:33:57.525]    - args: function (..., envir = parent.frame())
[10:33:57.525]    - tweaked: FALSE
[10:33:57.525]    - call: plan(strategy)
[10:33:57.526] plan(): nbrOfWorkers() = 1
[10:33:57.526] SequentialFuture started (and completed)
[10:33:57.526] - Launch lazy future ... done
[10:33:57.526] run() for ‘SequentialFuture’ ... done
[10:33:57.526] getGlobalsAndPackages() ...
[10:33:57.526] Searching for globals...
[10:33:57.531] - globals found: [2] ‘{’, ‘Sys.sleep’
[10:33:57.531] Searching for globals ... DONE
[10:33:57.531] Resolving globals: FALSE
[10:33:57.532] 
[10:33:57.532] 
[10:33:57.532] getGlobalsAndPackages() ... DONE
[10:33:57.532] run() for ‘Future’ ...
[10:33:57.532] - state: ‘created’
[10:33:57.532] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:57.532] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:57.533] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:57.533]   - Field: ‘label’
[10:33:57.533]   - Field: ‘local’
[10:33:57.533]   - Field: ‘owner’
[10:33:57.533]   - Field: ‘envir’
[10:33:57.533]   - Field: ‘packages’
[10:33:57.533]   - Field: ‘gc’
[10:33:57.533]   - Field: ‘conditions’
[10:33:57.533]   - Field: ‘expr’
[10:33:57.533]   - Field: ‘uuid’
[10:33:57.534]   - Field: ‘seed’
[10:33:57.534]   - Field: ‘version’
[10:33:57.534]   - Field: ‘result’
[10:33:57.534]   - Field: ‘asynchronous’
[10:33:57.534]   - Field: ‘calls’
[10:33:57.534]   - Field: ‘globals’
[10:33:57.534]   - Field: ‘stdout’
[10:33:57.534]   - Field: ‘earlySignal’
[10:33:57.534]   - Field: ‘lazy’
[10:33:57.534]   - Field: ‘state’
[10:33:57.534] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:57.534] - Launch lazy future ...
[10:33:57.535] Packages needed by the future expression (n = 0): <none>
[10:33:57.535] Packages needed by future strategies (n = 0): <none>
[10:33:57.535] {
[10:33:57.535]     {
[10:33:57.535]         {
[10:33:57.535]             ...future.startTime <- base::Sys.time()
[10:33:57.535]             {
[10:33:57.535]                 {
[10:33:57.535]                   {
[10:33:57.535]                     base::local({
[10:33:57.535]                       has_future <- base::requireNamespace("future", 
[10:33:57.535]                         quietly = TRUE)
[10:33:57.535]                       if (has_future) {
[10:33:57.535]                         ns <- base::getNamespace("future")
[10:33:57.535]                         version <- ns[[".package"]][["version"]]
[10:33:57.535]                         if (is.null(version)) 
[10:33:57.535]                           version <- utils::packageVersion("future")
[10:33:57.535]                       }
[10:33:57.535]                       else {
[10:33:57.535]                         version <- NULL
[10:33:57.535]                       }
[10:33:57.535]                       if (!has_future || version < "1.8.0") {
[10:33:57.535]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:57.535]                           "", base::R.version$version.string), 
[10:33:57.535]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:57.535]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:57.535]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:57.535]                             "release", "version")], collapse = " "), 
[10:33:57.535]                           hostname = base::Sys.info()[["nodename"]])
[10:33:57.535]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:57.535]                           info)
[10:33:57.535]                         info <- base::paste(info, collapse = "; ")
[10:33:57.535]                         if (!has_future) {
[10:33:57.535]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:57.535]                             info)
[10:33:57.535]                         }
[10:33:57.535]                         else {
[10:33:57.535]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:57.535]                             info, version)
[10:33:57.535]                         }
[10:33:57.535]                         base::stop(msg)
[10:33:57.535]                       }
[10:33:57.535]                     })
[10:33:57.535]                   }
[10:33:57.535]                   ...future.strategy.old <- future::plan("list")
[10:33:57.535]                   options(future.plan = NULL)
[10:33:57.535]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:57.535]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:57.535]                 }
[10:33:57.535]                 ...future.workdir <- getwd()
[10:33:57.535]             }
[10:33:57.535]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:57.535]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:57.535]         }
[10:33:57.535]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:57.535]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:57.535]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:57.535]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:57.535]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:57.535]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:57.535]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:57.535]             base::names(...future.oldOptions))
[10:33:57.535]     }
[10:33:57.535]     if (FALSE) {
[10:33:57.535]     }
[10:33:57.535]     else {
[10:33:57.535]         if (TRUE) {
[10:33:57.535]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:57.535]                 open = "w")
[10:33:57.535]         }
[10:33:57.535]         else {
[10:33:57.535]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:57.535]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:57.535]         }
[10:33:57.535]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:57.535]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:57.535]             base::sink(type = "output", split = FALSE)
[10:33:57.535]             base::close(...future.stdout)
[10:33:57.535]         }, add = TRUE)
[10:33:57.535]     }
[10:33:57.535]     ...future.frame <- base::sys.nframe()
[10:33:57.535]     ...future.conditions <- base::list()
[10:33:57.535]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:57.535]     if (FALSE) {
[10:33:57.535]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:57.535]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:57.535]     }
[10:33:57.535]     ...future.result <- base::tryCatch({
[10:33:57.535]         base::withCallingHandlers({
[10:33:57.535]             ...future.value <- base::withVisible(base::local({
[10:33:57.535]                 Sys.sleep(0.5)
[10:33:57.535]                 2
[10:33:57.535]             }))
[10:33:57.535]             future::FutureResult(value = ...future.value$value, 
[10:33:57.535]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:57.535]                   ...future.rng), globalenv = if (FALSE) 
[10:33:57.535]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:57.535]                     ...future.globalenv.names))
[10:33:57.535]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:57.535]         }, condition = base::local({
[10:33:57.535]             c <- base::c
[10:33:57.535]             inherits <- base::inherits
[10:33:57.535]             invokeRestart <- base::invokeRestart
[10:33:57.535]             length <- base::length
[10:33:57.535]             list <- base::list
[10:33:57.535]             seq.int <- base::seq.int
[10:33:57.535]             signalCondition <- base::signalCondition
[10:33:57.535]             sys.calls <- base::sys.calls
[10:33:57.535]             `[[` <- base::`[[`
[10:33:57.535]             `+` <- base::`+`
[10:33:57.535]             `<<-` <- base::`<<-`
[10:33:57.535]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:57.535]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:57.535]                   3L)]
[10:33:57.535]             }
[10:33:57.535]             function(cond) {
[10:33:57.535]                 is_error <- inherits(cond, "error")
[10:33:57.535]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:57.535]                   NULL)
[10:33:57.535]                 if (is_error) {
[10:33:57.535]                   sessionInformation <- function() {
[10:33:57.535]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:57.535]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:57.535]                       search = base::search(), system = base::Sys.info())
[10:33:57.535]                   }
[10:33:57.535]                   ...future.conditions[[length(...future.conditions) + 
[10:33:57.535]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:57.535]                     cond$call), session = sessionInformation(), 
[10:33:57.535]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:57.535]                   signalCondition(cond)
[10:33:57.535]                 }
[10:33:57.535]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:57.535]                 "immediateCondition"))) {
[10:33:57.535]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:57.535]                   ...future.conditions[[length(...future.conditions) + 
[10:33:57.535]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:57.535]                   if (TRUE && !signal) {
[10:33:57.535]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:57.535]                     {
[10:33:57.535]                       inherits <- base::inherits
[10:33:57.535]                       invokeRestart <- base::invokeRestart
[10:33:57.535]                       is.null <- base::is.null
[10:33:57.535]                       muffled <- FALSE
[10:33:57.535]                       if (inherits(cond, "message")) {
[10:33:57.535]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:57.535]                         if (muffled) 
[10:33:57.535]                           invokeRestart("muffleMessage")
[10:33:57.535]                       }
[10:33:57.535]                       else if (inherits(cond, "warning")) {
[10:33:57.535]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:57.535]                         if (muffled) 
[10:33:57.535]                           invokeRestart("muffleWarning")
[10:33:57.535]                       }
[10:33:57.535]                       else if (inherits(cond, "condition")) {
[10:33:57.535]                         if (!is.null(pattern)) {
[10:33:57.535]                           computeRestarts <- base::computeRestarts
[10:33:57.535]                           grepl <- base::grepl
[10:33:57.535]                           restarts <- computeRestarts(cond)
[10:33:57.535]                           for (restart in restarts) {
[10:33:57.535]                             name <- restart$name
[10:33:57.535]                             if (is.null(name)) 
[10:33:57.535]                               next
[10:33:57.535]                             if (!grepl(pattern, name)) 
[10:33:57.535]                               next
[10:33:57.535]                             invokeRestart(restart)
[10:33:57.535]                             muffled <- TRUE
[10:33:57.535]                             break
[10:33:57.535]                           }
[10:33:57.535]                         }
[10:33:57.535]                       }
[10:33:57.535]                       invisible(muffled)
[10:33:57.535]                     }
[10:33:57.535]                     muffleCondition(cond, pattern = "^muffle")
[10:33:57.535]                   }
[10:33:57.535]                 }
[10:33:57.535]                 else {
[10:33:57.535]                   if (TRUE) {
[10:33:57.535]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:57.535]                     {
[10:33:57.535]                       inherits <- base::inherits
[10:33:57.535]                       invokeRestart <- base::invokeRestart
[10:33:57.535]                       is.null <- base::is.null
[10:33:57.535]                       muffled <- FALSE
[10:33:57.535]                       if (inherits(cond, "message")) {
[10:33:57.535]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:57.535]                         if (muffled) 
[10:33:57.535]                           invokeRestart("muffleMessage")
[10:33:57.535]                       }
[10:33:57.535]                       else if (inherits(cond, "warning")) {
[10:33:57.535]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:57.535]                         if (muffled) 
[10:33:57.535]                           invokeRestart("muffleWarning")
[10:33:57.535]                       }
[10:33:57.535]                       else if (inherits(cond, "condition")) {
[10:33:57.535]                         if (!is.null(pattern)) {
[10:33:57.535]                           computeRestarts <- base::computeRestarts
[10:33:57.535]                           grepl <- base::grepl
[10:33:57.535]                           restarts <- computeRestarts(cond)
[10:33:57.535]                           for (restart in restarts) {
[10:33:57.535]                             name <- restart$name
[10:33:57.535]                             if (is.null(name)) 
[10:33:57.535]                               next
[10:33:57.535]                             if (!grepl(pattern, name)) 
[10:33:57.535]                               next
[10:33:57.535]                             invokeRestart(restart)
[10:33:57.535]                             muffled <- TRUE
[10:33:57.535]                             break
[10:33:57.535]                           }
[10:33:57.535]                         }
[10:33:57.535]                       }
[10:33:57.535]                       invisible(muffled)
[10:33:57.535]                     }
[10:33:57.535]                     muffleCondition(cond, pattern = "^muffle")
[10:33:57.535]                   }
[10:33:57.535]                 }
[10:33:57.535]             }
[10:33:57.535]         }))
[10:33:57.535]     }, error = function(ex) {
[10:33:57.535]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:57.535]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:57.535]                 ...future.rng), started = ...future.startTime, 
[10:33:57.535]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:57.535]             version = "1.8"), class = "FutureResult")
[10:33:57.535]     }, finally = {
[10:33:57.535]         if (!identical(...future.workdir, getwd())) 
[10:33:57.535]             setwd(...future.workdir)
[10:33:57.535]         {
[10:33:57.535]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:57.535]                 ...future.oldOptions$nwarnings <- NULL
[10:33:57.535]             }
[10:33:57.535]             base::options(...future.oldOptions)
[10:33:57.535]             if (.Platform$OS.type == "windows") {
[10:33:57.535]                 old_names <- names(...future.oldEnvVars)
[10:33:57.535]                 envs <- base::Sys.getenv()
[10:33:57.535]                 names <- names(envs)
[10:33:57.535]                 common <- intersect(names, old_names)
[10:33:57.535]                 added <- setdiff(names, old_names)
[10:33:57.535]                 removed <- setdiff(old_names, names)
[10:33:57.535]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:57.535]                   envs[common]]
[10:33:57.535]                 NAMES <- toupper(changed)
[10:33:57.535]                 args <- list()
[10:33:57.535]                 for (kk in seq_along(NAMES)) {
[10:33:57.535]                   name <- changed[[kk]]
[10:33:57.535]                   NAME <- NAMES[[kk]]
[10:33:57.535]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:57.535]                     next
[10:33:57.535]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:57.535]                 }
[10:33:57.535]                 NAMES <- toupper(added)
[10:33:57.535]                 for (kk in seq_along(NAMES)) {
[10:33:57.535]                   name <- added[[kk]]
[10:33:57.535]                   NAME <- NAMES[[kk]]
[10:33:57.535]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:57.535]                     next
[10:33:57.535]                   args[[name]] <- ""
[10:33:57.535]                 }
[10:33:57.535]                 NAMES <- toupper(removed)
[10:33:57.535]                 for (kk in seq_along(NAMES)) {
[10:33:57.535]                   name <- removed[[kk]]
[10:33:57.535]                   NAME <- NAMES[[kk]]
[10:33:57.535]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:57.535]                     next
[10:33:57.535]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:57.535]                 }
[10:33:57.535]                 if (length(args) > 0) 
[10:33:57.535]                   base::do.call(base::Sys.setenv, args = args)
[10:33:57.535]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:57.535]             }
[10:33:57.535]             else {
[10:33:57.535]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:57.535]             }
[10:33:57.535]             {
[10:33:57.535]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:57.535]                   0L) {
[10:33:57.535]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:57.535]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:57.535]                   base::options(opts)
[10:33:57.535]                 }
[10:33:57.535]                 {
[10:33:57.535]                   {
[10:33:57.535]                     NULL
[10:33:57.535]                     RNGkind("Mersenne-Twister")
[10:33:57.535]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:57.535]                       inherits = FALSE)
[10:33:57.535]                   }
[10:33:57.535]                   options(future.plan = NULL)
[10:33:57.535]                   if (is.na(NA_character_)) 
[10:33:57.535]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:57.535]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:57.535]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:57.535]                     .init = FALSE)
[10:33:57.535]                 }
[10:33:57.535]             }
[10:33:57.535]         }
[10:33:57.535]     })
[10:33:57.535]     if (TRUE) {
[10:33:57.535]         base::sink(type = "output", split = FALSE)
[10:33:57.535]         if (TRUE) {
[10:33:57.535]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:57.535]         }
[10:33:57.535]         else {
[10:33:57.535]             ...future.result["stdout"] <- base::list(NULL)
[10:33:57.535]         }
[10:33:57.535]         base::close(...future.stdout)
[10:33:57.535]         ...future.stdout <- NULL
[10:33:57.535]     }
[10:33:57.535]     ...future.result$conditions <- ...future.conditions
[10:33:57.535]     ...future.result$finished <- base::Sys.time()
[10:33:57.535]     ...future.result
[10:33:57.535] }
[10:33:57.537] plan(): Setting new future strategy stack:
[10:33:57.537] List of future strategies:
[10:33:57.537] 1. sequential:
[10:33:57.537]    - args: function (..., envir = parent.frame())
[10:33:57.537]    - tweaked: FALSE
[10:33:57.537]    - call: NULL
[10:33:57.537] plan(): nbrOfWorkers() = 1
[10:33:58.039] plan(): Setting new future strategy stack:
[10:33:58.039] List of future strategies:
[10:33:58.039] 1. sequential:
[10:33:58.039]    - args: function (..., envir = parent.frame())
[10:33:58.039]    - tweaked: FALSE
[10:33:58.039]    - call: plan(strategy)
[10:33:58.040] plan(): nbrOfWorkers() = 1
[10:33:58.040] SequentialFuture started (and completed)
[10:33:58.040] - Launch lazy future ... done
[10:33:58.040] run() for ‘SequentialFuture’ ... done
[10:33:58.041] resolve() on list ...
[10:33:58.041]  recursive: 0
[10:33:58.041]  length: 1
[10:33:58.041] 
[10:33:58.041] resolved() for ‘SequentialFuture’ ...
[10:33:58.041] - state: ‘finished’
[10:33:58.041] - run: TRUE
[10:33:58.041] - result: ‘FutureResult’
[10:33:58.041] resolved() for ‘SequentialFuture’ ... done
[10:33:58.041] Future #1
[10:33:58.042]  length: 0 (resolved future 1)
[10:33:58.042] resolve() on list ... DONE
[10:33:58.042] resolved() for ‘SequentialFuture’ ...
[10:33:58.042] - state: ‘finished’
[10:33:58.042] - run: TRUE
[10:33:58.042] - result: ‘FutureResult’
[10:33:58.042] resolved() for ‘SequentialFuture’ ... done
[10:33:58.042] resolve() on list ...
[10:33:58.042]  recursive: 0
[10:33:58.042]  length: 1
[10:33:58.043] 
[10:33:58.043] resolved() for ‘SequentialFuture’ ...
[10:33:58.043] - state: ‘finished’
[10:33:58.043] - run: TRUE
[10:33:58.043] - result: ‘FutureResult’
[10:33:58.043] resolved() for ‘SequentialFuture’ ... done
[10:33:58.043] Future #1
[10:33:58.043]  length: 0 (resolved future 1)
[10:33:58.043] resolve() on list ... DONE
[10:33:58.043] resolved() for ‘SequentialFuture’ ...
[10:33:58.043] - state: ‘finished’
[10:33:58.044] - run: TRUE
[10:33:58.044] - result: ‘FutureResult’
[10:33:58.044] resolved() for ‘SequentialFuture’ ... done
[10:33:58.044] resolve() on list ...
[10:33:58.044]  recursive: 0
[10:33:58.044]  length: 1
[10:33:58.044] 
[10:33:58.044]  length: 0 (resolved future 1)
[10:33:58.044] resolve() on list ... DONE
[10:33:58.044] resolve() on list ...
[10:33:58.045]  recursive: 0
[10:33:58.045]  length: 4
[10:33:58.045] 
[10:33:58.045] resolved() for ‘SequentialFuture’ ...
[10:33:58.047] - state: ‘finished’
[10:33:58.047] - run: TRUE
[10:33:58.047] - result: ‘FutureResult’
[10:33:58.047] resolved() for ‘SequentialFuture’ ... done
[10:33:58.047] Future #1
[10:33:58.047]  length: 3 (resolved future 1)
[10:33:58.047] resolved() for ‘SequentialFuture’ ...
[10:33:58.048] - state: ‘finished’
[10:33:58.048] - run: TRUE
[10:33:58.048] - result: ‘FutureResult’
[10:33:58.048] resolved() for ‘SequentialFuture’ ... done
[10:33:58.048] Future #2
[10:33:58.048]  length: 2 (resolved future 2)
[10:33:58.048]  length: 1 (resolved future 3)
[10:33:58.048]  length: 0 (resolved future 4)
[10:33:58.048] resolve() on list ... DONE
[10:33:58.049] resolve() on list ...
[10:33:58.049]  recursive: 0
[10:33:58.049]  length: 4
[10:33:58.049] 
[10:33:58.049] resolved() for ‘SequentialFuture’ ...
[10:33:58.049] - state: ‘finished’
[10:33:58.049] - run: TRUE
[10:33:58.049] - result: ‘FutureResult’
[10:33:58.049] resolved() for ‘SequentialFuture’ ... done
[10:33:58.049] Future #1
[10:33:58.049]  length: 3 (resolved future 1)
[10:33:58.050] resolved() for ‘SequentialFuture’ ...
[10:33:58.050] - state: ‘finished’
[10:33:58.050] - run: TRUE
[10:33:58.050] - result: ‘FutureResult’
[10:33:58.050] resolved() for ‘SequentialFuture’ ... done
[10:33:58.050] Future #2
[10:33:58.050]  length: 2 (resolved future 2)
[10:33:58.050]  length: 1 (resolved future 3)
[10:33:58.050]  length: 0 (resolved future 4)
[10:33:58.050] resolve() on list ... DONE
[10:33:58.051] resolve() on list ...
[10:33:58.051]  recursive: 0
[10:33:58.051]  length: 1
[10:33:58.051] 
[10:33:58.051]  length: 0 (resolved future 1)
[10:33:58.051] resolve() on list ... DONE
[10:33:58.051] getGlobalsAndPackages() ...
[10:33:58.051] Searching for globals...
[10:33:58.052] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:33:58.052] Searching for globals ... DONE
[10:33:58.053] Resolving globals: FALSE
[10:33:58.053] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:58.054] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:33:58.054] - globals: [1] ‘kk’
[10:33:58.054] 
[10:33:58.054] getGlobalsAndPackages() ... DONE
[10:33:58.054] run() for ‘Future’ ...
[10:33:58.054] - state: ‘created’
[10:33:58.055] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:58.055] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:58.055] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:58.055]   - Field: ‘label’
[10:33:58.055]   - Field: ‘local’
[10:33:58.055]   - Field: ‘owner’
[10:33:58.055]   - Field: ‘envir’
[10:33:58.055]   - Field: ‘packages’
[10:33:58.056]   - Field: ‘gc’
[10:33:58.056]   - Field: ‘conditions’
[10:33:58.056]   - Field: ‘expr’
[10:33:58.056]   - Field: ‘uuid’
[10:33:58.056]   - Field: ‘seed’
[10:33:58.056]   - Field: ‘version’
[10:33:58.056]   - Field: ‘result’
[10:33:58.056]   - Field: ‘asynchronous’
[10:33:58.056]   - Field: ‘calls’
[10:33:58.056]   - Field: ‘globals’
[10:33:58.056]   - Field: ‘stdout’
[10:33:58.057]   - Field: ‘earlySignal’
[10:33:58.057]   - Field: ‘lazy’
[10:33:58.057]   - Field: ‘state’
[10:33:58.057] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:58.057] - Launch lazy future ...
[10:33:58.057] Packages needed by the future expression (n = 0): <none>
[10:33:58.057] Packages needed by future strategies (n = 0): <none>
[10:33:58.058] {
[10:33:58.058]     {
[10:33:58.058]         {
[10:33:58.058]             ...future.startTime <- base::Sys.time()
[10:33:58.058]             {
[10:33:58.058]                 {
[10:33:58.058]                   {
[10:33:58.058]                     base::local({
[10:33:58.058]                       has_future <- base::requireNamespace("future", 
[10:33:58.058]                         quietly = TRUE)
[10:33:58.058]                       if (has_future) {
[10:33:58.058]                         ns <- base::getNamespace("future")
[10:33:58.058]                         version <- ns[[".package"]][["version"]]
[10:33:58.058]                         if (is.null(version)) 
[10:33:58.058]                           version <- utils::packageVersion("future")
[10:33:58.058]                       }
[10:33:58.058]                       else {
[10:33:58.058]                         version <- NULL
[10:33:58.058]                       }
[10:33:58.058]                       if (!has_future || version < "1.8.0") {
[10:33:58.058]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:58.058]                           "", base::R.version$version.string), 
[10:33:58.058]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:58.058]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:58.058]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:58.058]                             "release", "version")], collapse = " "), 
[10:33:58.058]                           hostname = base::Sys.info()[["nodename"]])
[10:33:58.058]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:58.058]                           info)
[10:33:58.058]                         info <- base::paste(info, collapse = "; ")
[10:33:58.058]                         if (!has_future) {
[10:33:58.058]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:58.058]                             info)
[10:33:58.058]                         }
[10:33:58.058]                         else {
[10:33:58.058]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:58.058]                             info, version)
[10:33:58.058]                         }
[10:33:58.058]                         base::stop(msg)
[10:33:58.058]                       }
[10:33:58.058]                     })
[10:33:58.058]                   }
[10:33:58.058]                   ...future.strategy.old <- future::plan("list")
[10:33:58.058]                   options(future.plan = NULL)
[10:33:58.058]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.058]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:58.058]                 }
[10:33:58.058]                 ...future.workdir <- getwd()
[10:33:58.058]             }
[10:33:58.058]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:58.058]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:58.058]         }
[10:33:58.058]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:58.058]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:58.058]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:58.058]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:58.058]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:58.058]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:58.058]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:58.058]             base::names(...future.oldOptions))
[10:33:58.058]     }
[10:33:58.058]     if (FALSE) {
[10:33:58.058]     }
[10:33:58.058]     else {
[10:33:58.058]         if (TRUE) {
[10:33:58.058]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:58.058]                 open = "w")
[10:33:58.058]         }
[10:33:58.058]         else {
[10:33:58.058]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:58.058]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:58.058]         }
[10:33:58.058]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:58.058]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:58.058]             base::sink(type = "output", split = FALSE)
[10:33:58.058]             base::close(...future.stdout)
[10:33:58.058]         }, add = TRUE)
[10:33:58.058]     }
[10:33:58.058]     ...future.frame <- base::sys.nframe()
[10:33:58.058]     ...future.conditions <- base::list()
[10:33:58.058]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:58.058]     if (FALSE) {
[10:33:58.058]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:58.058]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:58.058]     }
[10:33:58.058]     ...future.result <- base::tryCatch({
[10:33:58.058]         base::withCallingHandlers({
[10:33:58.058]             ...future.value <- base::withVisible(base::local({
[10:33:58.058]                 Sys.sleep(0.1)
[10:33:58.058]                 kk
[10:33:58.058]             }))
[10:33:58.058]             future::FutureResult(value = ...future.value$value, 
[10:33:58.058]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.058]                   ...future.rng), globalenv = if (FALSE) 
[10:33:58.058]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:58.058]                     ...future.globalenv.names))
[10:33:58.058]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:58.058]         }, condition = base::local({
[10:33:58.058]             c <- base::c
[10:33:58.058]             inherits <- base::inherits
[10:33:58.058]             invokeRestart <- base::invokeRestart
[10:33:58.058]             length <- base::length
[10:33:58.058]             list <- base::list
[10:33:58.058]             seq.int <- base::seq.int
[10:33:58.058]             signalCondition <- base::signalCondition
[10:33:58.058]             sys.calls <- base::sys.calls
[10:33:58.058]             `[[` <- base::`[[`
[10:33:58.058]             `+` <- base::`+`
[10:33:58.058]             `<<-` <- base::`<<-`
[10:33:58.058]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:58.058]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:58.058]                   3L)]
[10:33:58.058]             }
[10:33:58.058]             function(cond) {
[10:33:58.058]                 is_error <- inherits(cond, "error")
[10:33:58.058]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:58.058]                   NULL)
[10:33:58.058]                 if (is_error) {
[10:33:58.058]                   sessionInformation <- function() {
[10:33:58.058]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:58.058]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:58.058]                       search = base::search(), system = base::Sys.info())
[10:33:58.058]                   }
[10:33:58.058]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.058]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:58.058]                     cond$call), session = sessionInformation(), 
[10:33:58.058]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:58.058]                   signalCondition(cond)
[10:33:58.058]                 }
[10:33:58.058]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:58.058]                 "immediateCondition"))) {
[10:33:58.058]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:58.058]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.058]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:58.058]                   if (TRUE && !signal) {
[10:33:58.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.058]                     {
[10:33:58.058]                       inherits <- base::inherits
[10:33:58.058]                       invokeRestart <- base::invokeRestart
[10:33:58.058]                       is.null <- base::is.null
[10:33:58.058]                       muffled <- FALSE
[10:33:58.058]                       if (inherits(cond, "message")) {
[10:33:58.058]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.058]                         if (muffled) 
[10:33:58.058]                           invokeRestart("muffleMessage")
[10:33:58.058]                       }
[10:33:58.058]                       else if (inherits(cond, "warning")) {
[10:33:58.058]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.058]                         if (muffled) 
[10:33:58.058]                           invokeRestart("muffleWarning")
[10:33:58.058]                       }
[10:33:58.058]                       else if (inherits(cond, "condition")) {
[10:33:58.058]                         if (!is.null(pattern)) {
[10:33:58.058]                           computeRestarts <- base::computeRestarts
[10:33:58.058]                           grepl <- base::grepl
[10:33:58.058]                           restarts <- computeRestarts(cond)
[10:33:58.058]                           for (restart in restarts) {
[10:33:58.058]                             name <- restart$name
[10:33:58.058]                             if (is.null(name)) 
[10:33:58.058]                               next
[10:33:58.058]                             if (!grepl(pattern, name)) 
[10:33:58.058]                               next
[10:33:58.058]                             invokeRestart(restart)
[10:33:58.058]                             muffled <- TRUE
[10:33:58.058]                             break
[10:33:58.058]                           }
[10:33:58.058]                         }
[10:33:58.058]                       }
[10:33:58.058]                       invisible(muffled)
[10:33:58.058]                     }
[10:33:58.058]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.058]                   }
[10:33:58.058]                 }
[10:33:58.058]                 else {
[10:33:58.058]                   if (TRUE) {
[10:33:58.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.058]                     {
[10:33:58.058]                       inherits <- base::inherits
[10:33:58.058]                       invokeRestart <- base::invokeRestart
[10:33:58.058]                       is.null <- base::is.null
[10:33:58.058]                       muffled <- FALSE
[10:33:58.058]                       if (inherits(cond, "message")) {
[10:33:58.058]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.058]                         if (muffled) 
[10:33:58.058]                           invokeRestart("muffleMessage")
[10:33:58.058]                       }
[10:33:58.058]                       else if (inherits(cond, "warning")) {
[10:33:58.058]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.058]                         if (muffled) 
[10:33:58.058]                           invokeRestart("muffleWarning")
[10:33:58.058]                       }
[10:33:58.058]                       else if (inherits(cond, "condition")) {
[10:33:58.058]                         if (!is.null(pattern)) {
[10:33:58.058]                           computeRestarts <- base::computeRestarts
[10:33:58.058]                           grepl <- base::grepl
[10:33:58.058]                           restarts <- computeRestarts(cond)
[10:33:58.058]                           for (restart in restarts) {
[10:33:58.058]                             name <- restart$name
[10:33:58.058]                             if (is.null(name)) 
[10:33:58.058]                               next
[10:33:58.058]                             if (!grepl(pattern, name)) 
[10:33:58.058]                               next
[10:33:58.058]                             invokeRestart(restart)
[10:33:58.058]                             muffled <- TRUE
[10:33:58.058]                             break
[10:33:58.058]                           }
[10:33:58.058]                         }
[10:33:58.058]                       }
[10:33:58.058]                       invisible(muffled)
[10:33:58.058]                     }
[10:33:58.058]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.058]                   }
[10:33:58.058]                 }
[10:33:58.058]             }
[10:33:58.058]         }))
[10:33:58.058]     }, error = function(ex) {
[10:33:58.058]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:58.058]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.058]                 ...future.rng), started = ...future.startTime, 
[10:33:58.058]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:58.058]             version = "1.8"), class = "FutureResult")
[10:33:58.058]     }, finally = {
[10:33:58.058]         if (!identical(...future.workdir, getwd())) 
[10:33:58.058]             setwd(...future.workdir)
[10:33:58.058]         {
[10:33:58.058]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:58.058]                 ...future.oldOptions$nwarnings <- NULL
[10:33:58.058]             }
[10:33:58.058]             base::options(...future.oldOptions)
[10:33:58.058]             if (.Platform$OS.type == "windows") {
[10:33:58.058]                 old_names <- names(...future.oldEnvVars)
[10:33:58.058]                 envs <- base::Sys.getenv()
[10:33:58.058]                 names <- names(envs)
[10:33:58.058]                 common <- intersect(names, old_names)
[10:33:58.058]                 added <- setdiff(names, old_names)
[10:33:58.058]                 removed <- setdiff(old_names, names)
[10:33:58.058]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:58.058]                   envs[common]]
[10:33:58.058]                 NAMES <- toupper(changed)
[10:33:58.058]                 args <- list()
[10:33:58.058]                 for (kk in seq_along(NAMES)) {
[10:33:58.058]                   name <- changed[[kk]]
[10:33:58.058]                   NAME <- NAMES[[kk]]
[10:33:58.058]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.058]                     next
[10:33:58.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.058]                 }
[10:33:58.058]                 NAMES <- toupper(added)
[10:33:58.058]                 for (kk in seq_along(NAMES)) {
[10:33:58.058]                   name <- added[[kk]]
[10:33:58.058]                   NAME <- NAMES[[kk]]
[10:33:58.058]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.058]                     next
[10:33:58.058]                   args[[name]] <- ""
[10:33:58.058]                 }
[10:33:58.058]                 NAMES <- toupper(removed)
[10:33:58.058]                 for (kk in seq_along(NAMES)) {
[10:33:58.058]                   name <- removed[[kk]]
[10:33:58.058]                   NAME <- NAMES[[kk]]
[10:33:58.058]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.058]                     next
[10:33:58.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.058]                 }
[10:33:58.058]                 if (length(args) > 0) 
[10:33:58.058]                   base::do.call(base::Sys.setenv, args = args)
[10:33:58.058]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:58.058]             }
[10:33:58.058]             else {
[10:33:58.058]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:58.058]             }
[10:33:58.058]             {
[10:33:58.058]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:58.058]                   0L) {
[10:33:58.058]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:58.058]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:58.058]                   base::options(opts)
[10:33:58.058]                 }
[10:33:58.058]                 {
[10:33:58.058]                   {
[10:33:58.058]                     NULL
[10:33:58.058]                     RNGkind("Mersenne-Twister")
[10:33:58.058]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:58.058]                       inherits = FALSE)
[10:33:58.058]                   }
[10:33:58.058]                   options(future.plan = NULL)
[10:33:58.058]                   if (is.na(NA_character_)) 
[10:33:58.058]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.058]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:58.058]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:58.058]                     .init = FALSE)
[10:33:58.058]                 }
[10:33:58.058]             }
[10:33:58.058]         }
[10:33:58.058]     })
[10:33:58.058]     if (TRUE) {
[10:33:58.058]         base::sink(type = "output", split = FALSE)
[10:33:58.058]         if (TRUE) {
[10:33:58.058]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:58.058]         }
[10:33:58.058]         else {
[10:33:58.058]             ...future.result["stdout"] <- base::list(NULL)
[10:33:58.058]         }
[10:33:58.058]         base::close(...future.stdout)
[10:33:58.058]         ...future.stdout <- NULL
[10:33:58.058]     }
[10:33:58.058]     ...future.result$conditions <- ...future.conditions
[10:33:58.058]     ...future.result$finished <- base::Sys.time()
[10:33:58.058]     ...future.result
[10:33:58.058] }
[10:33:58.059] assign_globals() ...
[10:33:58.059] List of 1
[10:33:58.059]  $ kk: int 1
[10:33:58.059]  - attr(*, "where")=List of 1
[10:33:58.059]   ..$ kk:<environment: R_EmptyEnv> 
[10:33:58.059]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:58.059]  - attr(*, "resolved")= logi FALSE
[10:33:58.059]  - attr(*, "total_size")= num 56
[10:33:58.059]  - attr(*, "already-done")= logi TRUE
[10:33:58.064] - copied ‘kk’ to environment
[10:33:58.064] assign_globals() ... done
[10:33:58.065] plan(): Setting new future strategy stack:
[10:33:58.065] List of future strategies:
[10:33:58.065] 1. sequential:
[10:33:58.065]    - args: function (..., envir = parent.frame())
[10:33:58.065]    - tweaked: FALSE
[10:33:58.065]    - call: NULL
[10:33:58.065] plan(): nbrOfWorkers() = 1
[10:33:58.166] plan(): Setting new future strategy stack:
[10:33:58.166] List of future strategies:
[10:33:58.166] 1. sequential:
[10:33:58.166]    - args: function (..., envir = parent.frame())
[10:33:58.166]    - tweaked: FALSE
[10:33:58.166]    - call: plan(strategy)
[10:33:58.167] plan(): nbrOfWorkers() = 1
[10:33:58.167] SequentialFuture started (and completed)
[10:33:58.167] - Launch lazy future ... done
[10:33:58.167] run() for ‘SequentialFuture’ ... done
[10:33:58.167] getGlobalsAndPackages() ...
[10:33:58.167] Searching for globals...
[10:33:58.168] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:33:58.169] Searching for globals ... DONE
[10:33:58.169] Resolving globals: FALSE
[10:33:58.169] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:58.169] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:33:58.169] - globals: [1] ‘kk’
[10:33:58.170] 
[10:33:58.170] getGlobalsAndPackages() ... DONE
[10:33:58.170] run() for ‘Future’ ...
[10:33:58.170] - state: ‘created’
[10:33:58.170] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:58.170] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:58.171] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:58.171]   - Field: ‘label’
[10:33:58.171]   - Field: ‘local’
[10:33:58.171]   - Field: ‘owner’
[10:33:58.171]   - Field: ‘envir’
[10:33:58.171]   - Field: ‘packages’
[10:33:58.171]   - Field: ‘gc’
[10:33:58.171]   - Field: ‘conditions’
[10:33:58.171]   - Field: ‘expr’
[10:33:58.171]   - Field: ‘uuid’
[10:33:58.171]   - Field: ‘seed’
[10:33:58.172]   - Field: ‘version’
[10:33:58.172]   - Field: ‘result’
[10:33:58.172]   - Field: ‘asynchronous’
[10:33:58.172]   - Field: ‘calls’
[10:33:58.172]   - Field: ‘globals’
[10:33:58.172]   - Field: ‘stdout’
[10:33:58.172]   - Field: ‘earlySignal’
[10:33:58.172]   - Field: ‘lazy’
[10:33:58.172]   - Field: ‘state’
[10:33:58.172] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:58.172] - Launch lazy future ...
[10:33:58.173] Packages needed by the future expression (n = 0): <none>
[10:33:58.173] Packages needed by future strategies (n = 0): <none>
[10:33:58.173] {
[10:33:58.173]     {
[10:33:58.173]         {
[10:33:58.173]             ...future.startTime <- base::Sys.time()
[10:33:58.173]             {
[10:33:58.173]                 {
[10:33:58.173]                   {
[10:33:58.173]                     base::local({
[10:33:58.173]                       has_future <- base::requireNamespace("future", 
[10:33:58.173]                         quietly = TRUE)
[10:33:58.173]                       if (has_future) {
[10:33:58.173]                         ns <- base::getNamespace("future")
[10:33:58.173]                         version <- ns[[".package"]][["version"]]
[10:33:58.173]                         if (is.null(version)) 
[10:33:58.173]                           version <- utils::packageVersion("future")
[10:33:58.173]                       }
[10:33:58.173]                       else {
[10:33:58.173]                         version <- NULL
[10:33:58.173]                       }
[10:33:58.173]                       if (!has_future || version < "1.8.0") {
[10:33:58.173]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:58.173]                           "", base::R.version$version.string), 
[10:33:58.173]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:58.173]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:58.173]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:58.173]                             "release", "version")], collapse = " "), 
[10:33:58.173]                           hostname = base::Sys.info()[["nodename"]])
[10:33:58.173]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:58.173]                           info)
[10:33:58.173]                         info <- base::paste(info, collapse = "; ")
[10:33:58.173]                         if (!has_future) {
[10:33:58.173]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:58.173]                             info)
[10:33:58.173]                         }
[10:33:58.173]                         else {
[10:33:58.173]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:58.173]                             info, version)
[10:33:58.173]                         }
[10:33:58.173]                         base::stop(msg)
[10:33:58.173]                       }
[10:33:58.173]                     })
[10:33:58.173]                   }
[10:33:58.173]                   ...future.strategy.old <- future::plan("list")
[10:33:58.173]                   options(future.plan = NULL)
[10:33:58.173]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.173]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:58.173]                 }
[10:33:58.173]                 ...future.workdir <- getwd()
[10:33:58.173]             }
[10:33:58.173]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:58.173]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:58.173]         }
[10:33:58.173]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:58.173]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:58.173]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:58.173]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:58.173]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:58.173]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:58.173]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:58.173]             base::names(...future.oldOptions))
[10:33:58.173]     }
[10:33:58.173]     if (FALSE) {
[10:33:58.173]     }
[10:33:58.173]     else {
[10:33:58.173]         if (TRUE) {
[10:33:58.173]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:58.173]                 open = "w")
[10:33:58.173]         }
[10:33:58.173]         else {
[10:33:58.173]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:58.173]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:58.173]         }
[10:33:58.173]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:58.173]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:58.173]             base::sink(type = "output", split = FALSE)
[10:33:58.173]             base::close(...future.stdout)
[10:33:58.173]         }, add = TRUE)
[10:33:58.173]     }
[10:33:58.173]     ...future.frame <- base::sys.nframe()
[10:33:58.173]     ...future.conditions <- base::list()
[10:33:58.173]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:58.173]     if (FALSE) {
[10:33:58.173]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:58.173]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:58.173]     }
[10:33:58.173]     ...future.result <- base::tryCatch({
[10:33:58.173]         base::withCallingHandlers({
[10:33:58.173]             ...future.value <- base::withVisible(base::local({
[10:33:58.173]                 Sys.sleep(0.1)
[10:33:58.173]                 kk
[10:33:58.173]             }))
[10:33:58.173]             future::FutureResult(value = ...future.value$value, 
[10:33:58.173]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.173]                   ...future.rng), globalenv = if (FALSE) 
[10:33:58.173]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:58.173]                     ...future.globalenv.names))
[10:33:58.173]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:58.173]         }, condition = base::local({
[10:33:58.173]             c <- base::c
[10:33:58.173]             inherits <- base::inherits
[10:33:58.173]             invokeRestart <- base::invokeRestart
[10:33:58.173]             length <- base::length
[10:33:58.173]             list <- base::list
[10:33:58.173]             seq.int <- base::seq.int
[10:33:58.173]             signalCondition <- base::signalCondition
[10:33:58.173]             sys.calls <- base::sys.calls
[10:33:58.173]             `[[` <- base::`[[`
[10:33:58.173]             `+` <- base::`+`
[10:33:58.173]             `<<-` <- base::`<<-`
[10:33:58.173]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:58.173]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:58.173]                   3L)]
[10:33:58.173]             }
[10:33:58.173]             function(cond) {
[10:33:58.173]                 is_error <- inherits(cond, "error")
[10:33:58.173]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:58.173]                   NULL)
[10:33:58.173]                 if (is_error) {
[10:33:58.173]                   sessionInformation <- function() {
[10:33:58.173]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:58.173]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:58.173]                       search = base::search(), system = base::Sys.info())
[10:33:58.173]                   }
[10:33:58.173]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.173]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:58.173]                     cond$call), session = sessionInformation(), 
[10:33:58.173]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:58.173]                   signalCondition(cond)
[10:33:58.173]                 }
[10:33:58.173]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:58.173]                 "immediateCondition"))) {
[10:33:58.173]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:58.173]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.173]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:58.173]                   if (TRUE && !signal) {
[10:33:58.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.173]                     {
[10:33:58.173]                       inherits <- base::inherits
[10:33:58.173]                       invokeRestart <- base::invokeRestart
[10:33:58.173]                       is.null <- base::is.null
[10:33:58.173]                       muffled <- FALSE
[10:33:58.173]                       if (inherits(cond, "message")) {
[10:33:58.173]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.173]                         if (muffled) 
[10:33:58.173]                           invokeRestart("muffleMessage")
[10:33:58.173]                       }
[10:33:58.173]                       else if (inherits(cond, "warning")) {
[10:33:58.173]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.173]                         if (muffled) 
[10:33:58.173]                           invokeRestart("muffleWarning")
[10:33:58.173]                       }
[10:33:58.173]                       else if (inherits(cond, "condition")) {
[10:33:58.173]                         if (!is.null(pattern)) {
[10:33:58.173]                           computeRestarts <- base::computeRestarts
[10:33:58.173]                           grepl <- base::grepl
[10:33:58.173]                           restarts <- computeRestarts(cond)
[10:33:58.173]                           for (restart in restarts) {
[10:33:58.173]                             name <- restart$name
[10:33:58.173]                             if (is.null(name)) 
[10:33:58.173]                               next
[10:33:58.173]                             if (!grepl(pattern, name)) 
[10:33:58.173]                               next
[10:33:58.173]                             invokeRestart(restart)
[10:33:58.173]                             muffled <- TRUE
[10:33:58.173]                             break
[10:33:58.173]                           }
[10:33:58.173]                         }
[10:33:58.173]                       }
[10:33:58.173]                       invisible(muffled)
[10:33:58.173]                     }
[10:33:58.173]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.173]                   }
[10:33:58.173]                 }
[10:33:58.173]                 else {
[10:33:58.173]                   if (TRUE) {
[10:33:58.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.173]                     {
[10:33:58.173]                       inherits <- base::inherits
[10:33:58.173]                       invokeRestart <- base::invokeRestart
[10:33:58.173]                       is.null <- base::is.null
[10:33:58.173]                       muffled <- FALSE
[10:33:58.173]                       if (inherits(cond, "message")) {
[10:33:58.173]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.173]                         if (muffled) 
[10:33:58.173]                           invokeRestart("muffleMessage")
[10:33:58.173]                       }
[10:33:58.173]                       else if (inherits(cond, "warning")) {
[10:33:58.173]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.173]                         if (muffled) 
[10:33:58.173]                           invokeRestart("muffleWarning")
[10:33:58.173]                       }
[10:33:58.173]                       else if (inherits(cond, "condition")) {
[10:33:58.173]                         if (!is.null(pattern)) {
[10:33:58.173]                           computeRestarts <- base::computeRestarts
[10:33:58.173]                           grepl <- base::grepl
[10:33:58.173]                           restarts <- computeRestarts(cond)
[10:33:58.173]                           for (restart in restarts) {
[10:33:58.173]                             name <- restart$name
[10:33:58.173]                             if (is.null(name)) 
[10:33:58.173]                               next
[10:33:58.173]                             if (!grepl(pattern, name)) 
[10:33:58.173]                               next
[10:33:58.173]                             invokeRestart(restart)
[10:33:58.173]                             muffled <- TRUE
[10:33:58.173]                             break
[10:33:58.173]                           }
[10:33:58.173]                         }
[10:33:58.173]                       }
[10:33:58.173]                       invisible(muffled)
[10:33:58.173]                     }
[10:33:58.173]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.173]                   }
[10:33:58.173]                 }
[10:33:58.173]             }
[10:33:58.173]         }))
[10:33:58.173]     }, error = function(ex) {
[10:33:58.173]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:58.173]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.173]                 ...future.rng), started = ...future.startTime, 
[10:33:58.173]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:58.173]             version = "1.8"), class = "FutureResult")
[10:33:58.173]     }, finally = {
[10:33:58.173]         if (!identical(...future.workdir, getwd())) 
[10:33:58.173]             setwd(...future.workdir)
[10:33:58.173]         {
[10:33:58.173]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:58.173]                 ...future.oldOptions$nwarnings <- NULL
[10:33:58.173]             }
[10:33:58.173]             base::options(...future.oldOptions)
[10:33:58.173]             if (.Platform$OS.type == "windows") {
[10:33:58.173]                 old_names <- names(...future.oldEnvVars)
[10:33:58.173]                 envs <- base::Sys.getenv()
[10:33:58.173]                 names <- names(envs)
[10:33:58.173]                 common <- intersect(names, old_names)
[10:33:58.173]                 added <- setdiff(names, old_names)
[10:33:58.173]                 removed <- setdiff(old_names, names)
[10:33:58.173]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:58.173]                   envs[common]]
[10:33:58.173]                 NAMES <- toupper(changed)
[10:33:58.173]                 args <- list()
[10:33:58.173]                 for (kk in seq_along(NAMES)) {
[10:33:58.173]                   name <- changed[[kk]]
[10:33:58.173]                   NAME <- NAMES[[kk]]
[10:33:58.173]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.173]                     next
[10:33:58.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.173]                 }
[10:33:58.173]                 NAMES <- toupper(added)
[10:33:58.173]                 for (kk in seq_along(NAMES)) {
[10:33:58.173]                   name <- added[[kk]]
[10:33:58.173]                   NAME <- NAMES[[kk]]
[10:33:58.173]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.173]                     next
[10:33:58.173]                   args[[name]] <- ""
[10:33:58.173]                 }
[10:33:58.173]                 NAMES <- toupper(removed)
[10:33:58.173]                 for (kk in seq_along(NAMES)) {
[10:33:58.173]                   name <- removed[[kk]]
[10:33:58.173]                   NAME <- NAMES[[kk]]
[10:33:58.173]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.173]                     next
[10:33:58.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.173]                 }
[10:33:58.173]                 if (length(args) > 0) 
[10:33:58.173]                   base::do.call(base::Sys.setenv, args = args)
[10:33:58.173]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:58.173]             }
[10:33:58.173]             else {
[10:33:58.173]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:58.173]             }
[10:33:58.173]             {
[10:33:58.173]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:58.173]                   0L) {
[10:33:58.173]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:58.173]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:58.173]                   base::options(opts)
[10:33:58.173]                 }
[10:33:58.173]                 {
[10:33:58.173]                   {
[10:33:58.173]                     NULL
[10:33:58.173]                     RNGkind("Mersenne-Twister")
[10:33:58.173]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:58.173]                       inherits = FALSE)
[10:33:58.173]                   }
[10:33:58.173]                   options(future.plan = NULL)
[10:33:58.173]                   if (is.na(NA_character_)) 
[10:33:58.173]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.173]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:58.173]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:58.173]                     .init = FALSE)
[10:33:58.173]                 }
[10:33:58.173]             }
[10:33:58.173]         }
[10:33:58.173]     })
[10:33:58.173]     if (TRUE) {
[10:33:58.173]         base::sink(type = "output", split = FALSE)
[10:33:58.173]         if (TRUE) {
[10:33:58.173]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:58.173]         }
[10:33:58.173]         else {
[10:33:58.173]             ...future.result["stdout"] <- base::list(NULL)
[10:33:58.173]         }
[10:33:58.173]         base::close(...future.stdout)
[10:33:58.173]         ...future.stdout <- NULL
[10:33:58.173]     }
[10:33:58.173]     ...future.result$conditions <- ...future.conditions
[10:33:58.173]     ...future.result$finished <- base::Sys.time()
[10:33:58.173]     ...future.result
[10:33:58.173] }
[10:33:58.175] assign_globals() ...
[10:33:58.175] List of 1
[10:33:58.175]  $ kk: int 2
[10:33:58.175]  - attr(*, "where")=List of 1
[10:33:58.175]   ..$ kk:<environment: R_EmptyEnv> 
[10:33:58.175]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:58.175]  - attr(*, "resolved")= logi FALSE
[10:33:58.175]  - attr(*, "total_size")= num 56
[10:33:58.175]  - attr(*, "already-done")= logi TRUE
[10:33:58.179] - copied ‘kk’ to environment
[10:33:58.179] assign_globals() ... done
[10:33:58.180] plan(): Setting new future strategy stack:
[10:33:58.180] List of future strategies:
[10:33:58.180] 1. sequential:
[10:33:58.180]    - args: function (..., envir = parent.frame())
[10:33:58.180]    - tweaked: FALSE
[10:33:58.180]    - call: NULL
[10:33:58.180] plan(): nbrOfWorkers() = 1
[10:33:58.281] plan(): Setting new future strategy stack:
[10:33:58.281] List of future strategies:
[10:33:58.281] 1. sequential:
[10:33:58.281]    - args: function (..., envir = parent.frame())
[10:33:58.281]    - tweaked: FALSE
[10:33:58.281]    - call: plan(strategy)
[10:33:58.282] plan(): nbrOfWorkers() = 1
[10:33:58.282] SequentialFuture started (and completed)
[10:33:58.282] - Launch lazy future ... done
[10:33:58.282] run() for ‘SequentialFuture’ ... done
[10:33:58.282] getGlobalsAndPackages() ...
[10:33:58.282] Searching for globals...
[10:33:58.283] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:33:58.283] Searching for globals ... DONE
[10:33:58.284] Resolving globals: FALSE
[10:33:58.284] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:58.284] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:33:58.284] - globals: [1] ‘kk’
[10:33:58.284] 
[10:33:58.285] getGlobalsAndPackages() ... DONE
[10:33:58.285] run() for ‘Future’ ...
[10:33:58.285] - state: ‘created’
[10:33:58.285] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:58.285] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:58.285] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:58.285]   - Field: ‘label’
[10:33:58.286]   - Field: ‘local’
[10:33:58.286]   - Field: ‘owner’
[10:33:58.286]   - Field: ‘envir’
[10:33:58.286]   - Field: ‘packages’
[10:33:58.286]   - Field: ‘gc’
[10:33:58.286]   - Field: ‘conditions’
[10:33:58.286]   - Field: ‘expr’
[10:33:58.286]   - Field: ‘uuid’
[10:33:58.286]   - Field: ‘seed’
[10:33:58.286]   - Field: ‘version’
[10:33:58.286]   - Field: ‘result’
[10:33:58.287]   - Field: ‘asynchronous’
[10:33:58.287]   - Field: ‘calls’
[10:33:58.287]   - Field: ‘globals’
[10:33:58.287]   - Field: ‘stdout’
[10:33:58.287]   - Field: ‘earlySignal’
[10:33:58.287]   - Field: ‘lazy’
[10:33:58.287]   - Field: ‘state’
[10:33:58.287] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:58.287] - Launch lazy future ...
[10:33:58.288] Packages needed by the future expression (n = 0): <none>
[10:33:58.288] Packages needed by future strategies (n = 0): <none>
[10:33:58.288] {
[10:33:58.288]     {
[10:33:58.288]         {
[10:33:58.288]             ...future.startTime <- base::Sys.time()
[10:33:58.288]             {
[10:33:58.288]                 {
[10:33:58.288]                   {
[10:33:58.288]                     base::local({
[10:33:58.288]                       has_future <- base::requireNamespace("future", 
[10:33:58.288]                         quietly = TRUE)
[10:33:58.288]                       if (has_future) {
[10:33:58.288]                         ns <- base::getNamespace("future")
[10:33:58.288]                         version <- ns[[".package"]][["version"]]
[10:33:58.288]                         if (is.null(version)) 
[10:33:58.288]                           version <- utils::packageVersion("future")
[10:33:58.288]                       }
[10:33:58.288]                       else {
[10:33:58.288]                         version <- NULL
[10:33:58.288]                       }
[10:33:58.288]                       if (!has_future || version < "1.8.0") {
[10:33:58.288]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:58.288]                           "", base::R.version$version.string), 
[10:33:58.288]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:58.288]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:58.288]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:58.288]                             "release", "version")], collapse = " "), 
[10:33:58.288]                           hostname = base::Sys.info()[["nodename"]])
[10:33:58.288]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:58.288]                           info)
[10:33:58.288]                         info <- base::paste(info, collapse = "; ")
[10:33:58.288]                         if (!has_future) {
[10:33:58.288]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:58.288]                             info)
[10:33:58.288]                         }
[10:33:58.288]                         else {
[10:33:58.288]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:58.288]                             info, version)
[10:33:58.288]                         }
[10:33:58.288]                         base::stop(msg)
[10:33:58.288]                       }
[10:33:58.288]                     })
[10:33:58.288]                   }
[10:33:58.288]                   ...future.strategy.old <- future::plan("list")
[10:33:58.288]                   options(future.plan = NULL)
[10:33:58.288]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.288]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:58.288]                 }
[10:33:58.288]                 ...future.workdir <- getwd()
[10:33:58.288]             }
[10:33:58.288]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:58.288]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:58.288]         }
[10:33:58.288]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:58.288]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:58.288]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:58.288]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:58.288]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:58.288]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:58.288]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:58.288]             base::names(...future.oldOptions))
[10:33:58.288]     }
[10:33:58.288]     if (FALSE) {
[10:33:58.288]     }
[10:33:58.288]     else {
[10:33:58.288]         if (TRUE) {
[10:33:58.288]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:58.288]                 open = "w")
[10:33:58.288]         }
[10:33:58.288]         else {
[10:33:58.288]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:58.288]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:58.288]         }
[10:33:58.288]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:58.288]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:58.288]             base::sink(type = "output", split = FALSE)
[10:33:58.288]             base::close(...future.stdout)
[10:33:58.288]         }, add = TRUE)
[10:33:58.288]     }
[10:33:58.288]     ...future.frame <- base::sys.nframe()
[10:33:58.288]     ...future.conditions <- base::list()
[10:33:58.288]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:58.288]     if (FALSE) {
[10:33:58.288]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:58.288]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:58.288]     }
[10:33:58.288]     ...future.result <- base::tryCatch({
[10:33:58.288]         base::withCallingHandlers({
[10:33:58.288]             ...future.value <- base::withVisible(base::local({
[10:33:58.288]                 Sys.sleep(0.1)
[10:33:58.288]                 kk
[10:33:58.288]             }))
[10:33:58.288]             future::FutureResult(value = ...future.value$value, 
[10:33:58.288]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.288]                   ...future.rng), globalenv = if (FALSE) 
[10:33:58.288]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:58.288]                     ...future.globalenv.names))
[10:33:58.288]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:58.288]         }, condition = base::local({
[10:33:58.288]             c <- base::c
[10:33:58.288]             inherits <- base::inherits
[10:33:58.288]             invokeRestart <- base::invokeRestart
[10:33:58.288]             length <- base::length
[10:33:58.288]             list <- base::list
[10:33:58.288]             seq.int <- base::seq.int
[10:33:58.288]             signalCondition <- base::signalCondition
[10:33:58.288]             sys.calls <- base::sys.calls
[10:33:58.288]             `[[` <- base::`[[`
[10:33:58.288]             `+` <- base::`+`
[10:33:58.288]             `<<-` <- base::`<<-`
[10:33:58.288]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:58.288]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:58.288]                   3L)]
[10:33:58.288]             }
[10:33:58.288]             function(cond) {
[10:33:58.288]                 is_error <- inherits(cond, "error")
[10:33:58.288]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:58.288]                   NULL)
[10:33:58.288]                 if (is_error) {
[10:33:58.288]                   sessionInformation <- function() {
[10:33:58.288]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:58.288]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:58.288]                       search = base::search(), system = base::Sys.info())
[10:33:58.288]                   }
[10:33:58.288]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.288]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:58.288]                     cond$call), session = sessionInformation(), 
[10:33:58.288]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:58.288]                   signalCondition(cond)
[10:33:58.288]                 }
[10:33:58.288]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:58.288]                 "immediateCondition"))) {
[10:33:58.288]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:58.288]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.288]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:58.288]                   if (TRUE && !signal) {
[10:33:58.288]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.288]                     {
[10:33:58.288]                       inherits <- base::inherits
[10:33:58.288]                       invokeRestart <- base::invokeRestart
[10:33:58.288]                       is.null <- base::is.null
[10:33:58.288]                       muffled <- FALSE
[10:33:58.288]                       if (inherits(cond, "message")) {
[10:33:58.288]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.288]                         if (muffled) 
[10:33:58.288]                           invokeRestart("muffleMessage")
[10:33:58.288]                       }
[10:33:58.288]                       else if (inherits(cond, "warning")) {
[10:33:58.288]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.288]                         if (muffled) 
[10:33:58.288]                           invokeRestart("muffleWarning")
[10:33:58.288]                       }
[10:33:58.288]                       else if (inherits(cond, "condition")) {
[10:33:58.288]                         if (!is.null(pattern)) {
[10:33:58.288]                           computeRestarts <- base::computeRestarts
[10:33:58.288]                           grepl <- base::grepl
[10:33:58.288]                           restarts <- computeRestarts(cond)
[10:33:58.288]                           for (restart in restarts) {
[10:33:58.288]                             name <- restart$name
[10:33:58.288]                             if (is.null(name)) 
[10:33:58.288]                               next
[10:33:58.288]                             if (!grepl(pattern, name)) 
[10:33:58.288]                               next
[10:33:58.288]                             invokeRestart(restart)
[10:33:58.288]                             muffled <- TRUE
[10:33:58.288]                             break
[10:33:58.288]                           }
[10:33:58.288]                         }
[10:33:58.288]                       }
[10:33:58.288]                       invisible(muffled)
[10:33:58.288]                     }
[10:33:58.288]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.288]                   }
[10:33:58.288]                 }
[10:33:58.288]                 else {
[10:33:58.288]                   if (TRUE) {
[10:33:58.288]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.288]                     {
[10:33:58.288]                       inherits <- base::inherits
[10:33:58.288]                       invokeRestart <- base::invokeRestart
[10:33:58.288]                       is.null <- base::is.null
[10:33:58.288]                       muffled <- FALSE
[10:33:58.288]                       if (inherits(cond, "message")) {
[10:33:58.288]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.288]                         if (muffled) 
[10:33:58.288]                           invokeRestart("muffleMessage")
[10:33:58.288]                       }
[10:33:58.288]                       else if (inherits(cond, "warning")) {
[10:33:58.288]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.288]                         if (muffled) 
[10:33:58.288]                           invokeRestart("muffleWarning")
[10:33:58.288]                       }
[10:33:58.288]                       else if (inherits(cond, "condition")) {
[10:33:58.288]                         if (!is.null(pattern)) {
[10:33:58.288]                           computeRestarts <- base::computeRestarts
[10:33:58.288]                           grepl <- base::grepl
[10:33:58.288]                           restarts <- computeRestarts(cond)
[10:33:58.288]                           for (restart in restarts) {
[10:33:58.288]                             name <- restart$name
[10:33:58.288]                             if (is.null(name)) 
[10:33:58.288]                               next
[10:33:58.288]                             if (!grepl(pattern, name)) 
[10:33:58.288]                               next
[10:33:58.288]                             invokeRestart(restart)
[10:33:58.288]                             muffled <- TRUE
[10:33:58.288]                             break
[10:33:58.288]                           }
[10:33:58.288]                         }
[10:33:58.288]                       }
[10:33:58.288]                       invisible(muffled)
[10:33:58.288]                     }
[10:33:58.288]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.288]                   }
[10:33:58.288]                 }
[10:33:58.288]             }
[10:33:58.288]         }))
[10:33:58.288]     }, error = function(ex) {
[10:33:58.288]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:58.288]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.288]                 ...future.rng), started = ...future.startTime, 
[10:33:58.288]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:58.288]             version = "1.8"), class = "FutureResult")
[10:33:58.288]     }, finally = {
[10:33:58.288]         if (!identical(...future.workdir, getwd())) 
[10:33:58.288]             setwd(...future.workdir)
[10:33:58.288]         {
[10:33:58.288]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:58.288]                 ...future.oldOptions$nwarnings <- NULL
[10:33:58.288]             }
[10:33:58.288]             base::options(...future.oldOptions)
[10:33:58.288]             if (.Platform$OS.type == "windows") {
[10:33:58.288]                 old_names <- names(...future.oldEnvVars)
[10:33:58.288]                 envs <- base::Sys.getenv()
[10:33:58.288]                 names <- names(envs)
[10:33:58.288]                 common <- intersect(names, old_names)
[10:33:58.288]                 added <- setdiff(names, old_names)
[10:33:58.288]                 removed <- setdiff(old_names, names)
[10:33:58.288]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:58.288]                   envs[common]]
[10:33:58.288]                 NAMES <- toupper(changed)
[10:33:58.288]                 args <- list()
[10:33:58.288]                 for (kk in seq_along(NAMES)) {
[10:33:58.288]                   name <- changed[[kk]]
[10:33:58.288]                   NAME <- NAMES[[kk]]
[10:33:58.288]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.288]                     next
[10:33:58.288]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.288]                 }
[10:33:58.288]                 NAMES <- toupper(added)
[10:33:58.288]                 for (kk in seq_along(NAMES)) {
[10:33:58.288]                   name <- added[[kk]]
[10:33:58.288]                   NAME <- NAMES[[kk]]
[10:33:58.288]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.288]                     next
[10:33:58.288]                   args[[name]] <- ""
[10:33:58.288]                 }
[10:33:58.288]                 NAMES <- toupper(removed)
[10:33:58.288]                 for (kk in seq_along(NAMES)) {
[10:33:58.288]                   name <- removed[[kk]]
[10:33:58.288]                   NAME <- NAMES[[kk]]
[10:33:58.288]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.288]                     next
[10:33:58.288]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.288]                 }
[10:33:58.288]                 if (length(args) > 0) 
[10:33:58.288]                   base::do.call(base::Sys.setenv, args = args)
[10:33:58.288]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:58.288]             }
[10:33:58.288]             else {
[10:33:58.288]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:58.288]             }
[10:33:58.288]             {
[10:33:58.288]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:58.288]                   0L) {
[10:33:58.288]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:58.288]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:58.288]                   base::options(opts)
[10:33:58.288]                 }
[10:33:58.288]                 {
[10:33:58.288]                   {
[10:33:58.288]                     NULL
[10:33:58.288]                     RNGkind("Mersenne-Twister")
[10:33:58.288]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:58.288]                       inherits = FALSE)
[10:33:58.288]                   }
[10:33:58.288]                   options(future.plan = NULL)
[10:33:58.288]                   if (is.na(NA_character_)) 
[10:33:58.288]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.288]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:58.288]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:58.288]                     .init = FALSE)
[10:33:58.288]                 }
[10:33:58.288]             }
[10:33:58.288]         }
[10:33:58.288]     })
[10:33:58.288]     if (TRUE) {
[10:33:58.288]         base::sink(type = "output", split = FALSE)
[10:33:58.288]         if (TRUE) {
[10:33:58.288]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:58.288]         }
[10:33:58.288]         else {
[10:33:58.288]             ...future.result["stdout"] <- base::list(NULL)
[10:33:58.288]         }
[10:33:58.288]         base::close(...future.stdout)
[10:33:58.288]         ...future.stdout <- NULL
[10:33:58.288]     }
[10:33:58.288]     ...future.result$conditions <- ...future.conditions
[10:33:58.288]     ...future.result$finished <- base::Sys.time()
[10:33:58.288]     ...future.result
[10:33:58.288] }
[10:33:58.290] assign_globals() ...
[10:33:58.290] List of 1
[10:33:58.290]  $ kk: int 3
[10:33:58.290]  - attr(*, "where")=List of 1
[10:33:58.290]   ..$ kk:<environment: R_EmptyEnv> 
[10:33:58.290]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:58.290]  - attr(*, "resolved")= logi FALSE
[10:33:58.290]  - attr(*, "total_size")= num 56
[10:33:58.290]  - attr(*, "already-done")= logi TRUE
[10:33:58.292] - copied ‘kk’ to environment
[10:33:58.292] assign_globals() ... done
[10:33:58.292] plan(): Setting new future strategy stack:
[10:33:58.293] List of future strategies:
[10:33:58.293] 1. sequential:
[10:33:58.293]    - args: function (..., envir = parent.frame())
[10:33:58.293]    - tweaked: FALSE
[10:33:58.293]    - call: NULL
[10:33:58.293] plan(): nbrOfWorkers() = 1
[10:33:58.394] plan(): Setting new future strategy stack:
[10:33:58.394] List of future strategies:
[10:33:58.394] 1. sequential:
[10:33:58.394]    - args: function (..., envir = parent.frame())
[10:33:58.394]    - tweaked: FALSE
[10:33:58.394]    - call: plan(strategy)
[10:33:58.395] plan(): nbrOfWorkers() = 1
[10:33:58.395] SequentialFuture started (and completed)
[10:33:58.395] - Launch lazy future ... done
[10:33:58.395] run() for ‘SequentialFuture’ ... done
[10:33:58.395] resolve() on list ...
[10:33:58.395]  recursive: 0
[10:33:58.396]  length: 3
[10:33:58.396] 
[10:33:58.396] resolved() for ‘SequentialFuture’ ...
[10:33:58.396] - state: ‘finished’
[10:33:58.396] - run: TRUE
[10:33:58.396] - result: ‘FutureResult’
[10:33:58.396] resolved() for ‘SequentialFuture’ ... done
[10:33:58.396] Future #1
[10:33:58.396]  length: 2 (resolved future 1)
[10:33:58.396] resolved() for ‘SequentialFuture’ ...
[10:33:58.396] - state: ‘finished’
[10:33:58.397] - run: TRUE
[10:33:58.397] - result: ‘FutureResult’
[10:33:58.397] resolved() for ‘SequentialFuture’ ... done
[10:33:58.397] Future #2
[10:33:58.397]  length: 1 (resolved future 2)
[10:33:58.397] resolved() for ‘SequentialFuture’ ...
[10:33:58.397] - state: ‘finished’
[10:33:58.397] - run: TRUE
[10:33:58.397] - result: ‘FutureResult’
[10:33:58.398] resolved() for ‘SequentialFuture’ ... done
[10:33:58.398] Future #3
[10:33:58.398]  length: 0 (resolved future 3)
[10:33:58.398] resolve() on list ... DONE
[10:33:58.398] getGlobalsAndPackages() ...
[10:33:58.398] Searching for globals...
[10:33:58.399] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:33:58.399] Searching for globals ... DONE
[10:33:58.399] Resolving globals: FALSE
[10:33:58.400] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:58.400] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:33:58.400] - globals: [1] ‘kk’
[10:33:58.400] 
[10:33:58.400] getGlobalsAndPackages() ... DONE
[10:33:58.401] getGlobalsAndPackages() ...
[10:33:58.401] Searching for globals...
[10:33:58.402] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:33:58.402] Searching for globals ... DONE
[10:33:58.402] Resolving globals: FALSE
[10:33:58.402] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:58.402] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:33:58.403] - globals: [1] ‘kk’
[10:33:58.403] 
[10:33:58.403] getGlobalsAndPackages() ... DONE
[10:33:58.403] getGlobalsAndPackages() ...
[10:33:58.403] Searching for globals...
[10:33:58.404] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:33:58.404] Searching for globals ... DONE
[10:33:58.404] Resolving globals: FALSE
[10:33:58.405] The total size of the 1 globals is 56 bytes (56 bytes)
[10:33:58.405] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:33:58.405] - globals: [1] ‘kk’
[10:33:58.405] 
[10:33:58.405] getGlobalsAndPackages() ... DONE
[10:33:58.407] resolve() on list ...
[10:33:58.407]  recursive: 0
[10:33:58.407]  length: 3
[10:33:58.407] 
[10:33:58.407] run() for ‘Future’ ...
[10:33:58.408] - state: ‘created’
[10:33:58.408] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:58.408] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:58.408] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:58.408]   - Field: ‘label’
[10:33:58.408]   - Field: ‘local’
[10:33:58.408]   - Field: ‘owner’
[10:33:58.409]   - Field: ‘envir’
[10:33:58.409]   - Field: ‘packages’
[10:33:58.409]   - Field: ‘gc’
[10:33:58.409]   - Field: ‘conditions’
[10:33:58.409]   - Field: ‘expr’
[10:33:58.409]   - Field: ‘uuid’
[10:33:58.409]   - Field: ‘seed’
[10:33:58.409]   - Field: ‘version’
[10:33:58.409]   - Field: ‘result’
[10:33:58.409]   - Field: ‘asynchronous’
[10:33:58.409]   - Field: ‘calls’
[10:33:58.410]   - Field: ‘globals’
[10:33:58.410]   - Field: ‘stdout’
[10:33:58.410]   - Field: ‘earlySignal’
[10:33:58.410]   - Field: ‘lazy’
[10:33:58.410]   - Field: ‘state’
[10:33:58.410] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:58.410] - Launch lazy future ...
[10:33:58.410] Packages needed by the future expression (n = 0): <none>
[10:33:58.410] Packages needed by future strategies (n = 0): <none>
[10:33:58.411] {
[10:33:58.411]     {
[10:33:58.411]         {
[10:33:58.411]             ...future.startTime <- base::Sys.time()
[10:33:58.411]             {
[10:33:58.411]                 {
[10:33:58.411]                   {
[10:33:58.411]                     base::local({
[10:33:58.411]                       has_future <- base::requireNamespace("future", 
[10:33:58.411]                         quietly = TRUE)
[10:33:58.411]                       if (has_future) {
[10:33:58.411]                         ns <- base::getNamespace("future")
[10:33:58.411]                         version <- ns[[".package"]][["version"]]
[10:33:58.411]                         if (is.null(version)) 
[10:33:58.411]                           version <- utils::packageVersion("future")
[10:33:58.411]                       }
[10:33:58.411]                       else {
[10:33:58.411]                         version <- NULL
[10:33:58.411]                       }
[10:33:58.411]                       if (!has_future || version < "1.8.0") {
[10:33:58.411]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:58.411]                           "", base::R.version$version.string), 
[10:33:58.411]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:58.411]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:58.411]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:58.411]                             "release", "version")], collapse = " "), 
[10:33:58.411]                           hostname = base::Sys.info()[["nodename"]])
[10:33:58.411]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:58.411]                           info)
[10:33:58.411]                         info <- base::paste(info, collapse = "; ")
[10:33:58.411]                         if (!has_future) {
[10:33:58.411]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:58.411]                             info)
[10:33:58.411]                         }
[10:33:58.411]                         else {
[10:33:58.411]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:58.411]                             info, version)
[10:33:58.411]                         }
[10:33:58.411]                         base::stop(msg)
[10:33:58.411]                       }
[10:33:58.411]                     })
[10:33:58.411]                   }
[10:33:58.411]                   ...future.strategy.old <- future::plan("list")
[10:33:58.411]                   options(future.plan = NULL)
[10:33:58.411]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.411]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:58.411]                 }
[10:33:58.411]                 ...future.workdir <- getwd()
[10:33:58.411]             }
[10:33:58.411]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:58.411]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:58.411]         }
[10:33:58.411]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:58.411]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:58.411]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:58.411]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:58.411]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:58.411]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:58.411]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:58.411]             base::names(...future.oldOptions))
[10:33:58.411]     }
[10:33:58.411]     if (FALSE) {
[10:33:58.411]     }
[10:33:58.411]     else {
[10:33:58.411]         if (TRUE) {
[10:33:58.411]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:58.411]                 open = "w")
[10:33:58.411]         }
[10:33:58.411]         else {
[10:33:58.411]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:58.411]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:58.411]         }
[10:33:58.411]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:58.411]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:58.411]             base::sink(type = "output", split = FALSE)
[10:33:58.411]             base::close(...future.stdout)
[10:33:58.411]         }, add = TRUE)
[10:33:58.411]     }
[10:33:58.411]     ...future.frame <- base::sys.nframe()
[10:33:58.411]     ...future.conditions <- base::list()
[10:33:58.411]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:58.411]     if (FALSE) {
[10:33:58.411]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:58.411]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:58.411]     }
[10:33:58.411]     ...future.result <- base::tryCatch({
[10:33:58.411]         base::withCallingHandlers({
[10:33:58.411]             ...future.value <- base::withVisible(base::local({
[10:33:58.411]                 Sys.sleep(0.1)
[10:33:58.411]                 kk
[10:33:58.411]             }))
[10:33:58.411]             future::FutureResult(value = ...future.value$value, 
[10:33:58.411]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.411]                   ...future.rng), globalenv = if (FALSE) 
[10:33:58.411]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:58.411]                     ...future.globalenv.names))
[10:33:58.411]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:58.411]         }, condition = base::local({
[10:33:58.411]             c <- base::c
[10:33:58.411]             inherits <- base::inherits
[10:33:58.411]             invokeRestart <- base::invokeRestart
[10:33:58.411]             length <- base::length
[10:33:58.411]             list <- base::list
[10:33:58.411]             seq.int <- base::seq.int
[10:33:58.411]             signalCondition <- base::signalCondition
[10:33:58.411]             sys.calls <- base::sys.calls
[10:33:58.411]             `[[` <- base::`[[`
[10:33:58.411]             `+` <- base::`+`
[10:33:58.411]             `<<-` <- base::`<<-`
[10:33:58.411]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:58.411]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:58.411]                   3L)]
[10:33:58.411]             }
[10:33:58.411]             function(cond) {
[10:33:58.411]                 is_error <- inherits(cond, "error")
[10:33:58.411]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:58.411]                   NULL)
[10:33:58.411]                 if (is_error) {
[10:33:58.411]                   sessionInformation <- function() {
[10:33:58.411]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:58.411]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:58.411]                       search = base::search(), system = base::Sys.info())
[10:33:58.411]                   }
[10:33:58.411]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.411]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:58.411]                     cond$call), session = sessionInformation(), 
[10:33:58.411]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:58.411]                   signalCondition(cond)
[10:33:58.411]                 }
[10:33:58.411]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:58.411]                 "immediateCondition"))) {
[10:33:58.411]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:58.411]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.411]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:58.411]                   if (TRUE && !signal) {
[10:33:58.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.411]                     {
[10:33:58.411]                       inherits <- base::inherits
[10:33:58.411]                       invokeRestart <- base::invokeRestart
[10:33:58.411]                       is.null <- base::is.null
[10:33:58.411]                       muffled <- FALSE
[10:33:58.411]                       if (inherits(cond, "message")) {
[10:33:58.411]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.411]                         if (muffled) 
[10:33:58.411]                           invokeRestart("muffleMessage")
[10:33:58.411]                       }
[10:33:58.411]                       else if (inherits(cond, "warning")) {
[10:33:58.411]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.411]                         if (muffled) 
[10:33:58.411]                           invokeRestart("muffleWarning")
[10:33:58.411]                       }
[10:33:58.411]                       else if (inherits(cond, "condition")) {
[10:33:58.411]                         if (!is.null(pattern)) {
[10:33:58.411]                           computeRestarts <- base::computeRestarts
[10:33:58.411]                           grepl <- base::grepl
[10:33:58.411]                           restarts <- computeRestarts(cond)
[10:33:58.411]                           for (restart in restarts) {
[10:33:58.411]                             name <- restart$name
[10:33:58.411]                             if (is.null(name)) 
[10:33:58.411]                               next
[10:33:58.411]                             if (!grepl(pattern, name)) 
[10:33:58.411]                               next
[10:33:58.411]                             invokeRestart(restart)
[10:33:58.411]                             muffled <- TRUE
[10:33:58.411]                             break
[10:33:58.411]                           }
[10:33:58.411]                         }
[10:33:58.411]                       }
[10:33:58.411]                       invisible(muffled)
[10:33:58.411]                     }
[10:33:58.411]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.411]                   }
[10:33:58.411]                 }
[10:33:58.411]                 else {
[10:33:58.411]                   if (TRUE) {
[10:33:58.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.411]                     {
[10:33:58.411]                       inherits <- base::inherits
[10:33:58.411]                       invokeRestart <- base::invokeRestart
[10:33:58.411]                       is.null <- base::is.null
[10:33:58.411]                       muffled <- FALSE
[10:33:58.411]                       if (inherits(cond, "message")) {
[10:33:58.411]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.411]                         if (muffled) 
[10:33:58.411]                           invokeRestart("muffleMessage")
[10:33:58.411]                       }
[10:33:58.411]                       else if (inherits(cond, "warning")) {
[10:33:58.411]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.411]                         if (muffled) 
[10:33:58.411]                           invokeRestart("muffleWarning")
[10:33:58.411]                       }
[10:33:58.411]                       else if (inherits(cond, "condition")) {
[10:33:58.411]                         if (!is.null(pattern)) {
[10:33:58.411]                           computeRestarts <- base::computeRestarts
[10:33:58.411]                           grepl <- base::grepl
[10:33:58.411]                           restarts <- computeRestarts(cond)
[10:33:58.411]                           for (restart in restarts) {
[10:33:58.411]                             name <- restart$name
[10:33:58.411]                             if (is.null(name)) 
[10:33:58.411]                               next
[10:33:58.411]                             if (!grepl(pattern, name)) 
[10:33:58.411]                               next
[10:33:58.411]                             invokeRestart(restart)
[10:33:58.411]                             muffled <- TRUE
[10:33:58.411]                             break
[10:33:58.411]                           }
[10:33:58.411]                         }
[10:33:58.411]                       }
[10:33:58.411]                       invisible(muffled)
[10:33:58.411]                     }
[10:33:58.411]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.411]                   }
[10:33:58.411]                 }
[10:33:58.411]             }
[10:33:58.411]         }))
[10:33:58.411]     }, error = function(ex) {
[10:33:58.411]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:58.411]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.411]                 ...future.rng), started = ...future.startTime, 
[10:33:58.411]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:58.411]             version = "1.8"), class = "FutureResult")
[10:33:58.411]     }, finally = {
[10:33:58.411]         if (!identical(...future.workdir, getwd())) 
[10:33:58.411]             setwd(...future.workdir)
[10:33:58.411]         {
[10:33:58.411]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:58.411]                 ...future.oldOptions$nwarnings <- NULL
[10:33:58.411]             }
[10:33:58.411]             base::options(...future.oldOptions)
[10:33:58.411]             if (.Platform$OS.type == "windows") {
[10:33:58.411]                 old_names <- names(...future.oldEnvVars)
[10:33:58.411]                 envs <- base::Sys.getenv()
[10:33:58.411]                 names <- names(envs)
[10:33:58.411]                 common <- intersect(names, old_names)
[10:33:58.411]                 added <- setdiff(names, old_names)
[10:33:58.411]                 removed <- setdiff(old_names, names)
[10:33:58.411]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:58.411]                   envs[common]]
[10:33:58.411]                 NAMES <- toupper(changed)
[10:33:58.411]                 args <- list()
[10:33:58.411]                 for (kk in seq_along(NAMES)) {
[10:33:58.411]                   name <- changed[[kk]]
[10:33:58.411]                   NAME <- NAMES[[kk]]
[10:33:58.411]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.411]                     next
[10:33:58.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.411]                 }
[10:33:58.411]                 NAMES <- toupper(added)
[10:33:58.411]                 for (kk in seq_along(NAMES)) {
[10:33:58.411]                   name <- added[[kk]]
[10:33:58.411]                   NAME <- NAMES[[kk]]
[10:33:58.411]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.411]                     next
[10:33:58.411]                   args[[name]] <- ""
[10:33:58.411]                 }
[10:33:58.411]                 NAMES <- toupper(removed)
[10:33:58.411]                 for (kk in seq_along(NAMES)) {
[10:33:58.411]                   name <- removed[[kk]]
[10:33:58.411]                   NAME <- NAMES[[kk]]
[10:33:58.411]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.411]                     next
[10:33:58.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.411]                 }
[10:33:58.411]                 if (length(args) > 0) 
[10:33:58.411]                   base::do.call(base::Sys.setenv, args = args)
[10:33:58.411]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:58.411]             }
[10:33:58.411]             else {
[10:33:58.411]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:58.411]             }
[10:33:58.411]             {
[10:33:58.411]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:58.411]                   0L) {
[10:33:58.411]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:58.411]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:58.411]                   base::options(opts)
[10:33:58.411]                 }
[10:33:58.411]                 {
[10:33:58.411]                   {
[10:33:58.411]                     NULL
[10:33:58.411]                     RNGkind("Mersenne-Twister")
[10:33:58.411]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:58.411]                       inherits = FALSE)
[10:33:58.411]                   }
[10:33:58.411]                   options(future.plan = NULL)
[10:33:58.411]                   if (is.na(NA_character_)) 
[10:33:58.411]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.411]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:58.411]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:58.411]                     .init = FALSE)
[10:33:58.411]                 }
[10:33:58.411]             }
[10:33:58.411]         }
[10:33:58.411]     })
[10:33:58.411]     if (TRUE) {
[10:33:58.411]         base::sink(type = "output", split = FALSE)
[10:33:58.411]         if (TRUE) {
[10:33:58.411]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:58.411]         }
[10:33:58.411]         else {
[10:33:58.411]             ...future.result["stdout"] <- base::list(NULL)
[10:33:58.411]         }
[10:33:58.411]         base::close(...future.stdout)
[10:33:58.411]         ...future.stdout <- NULL
[10:33:58.411]     }
[10:33:58.411]     ...future.result$conditions <- ...future.conditions
[10:33:58.411]     ...future.result$finished <- base::Sys.time()
[10:33:58.411]     ...future.result
[10:33:58.411] }
[10:33:58.412] assign_globals() ...
[10:33:58.412] List of 1
[10:33:58.412]  $ kk: int 1
[10:33:58.412]  - attr(*, "where")=List of 1
[10:33:58.412]   ..$ kk:<environment: R_EmptyEnv> 
[10:33:58.412]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:58.412]  - attr(*, "resolved")= logi FALSE
[10:33:58.412]  - attr(*, "total_size")= num 56
[10:33:58.412]  - attr(*, "already-done")= logi TRUE
[10:33:58.415] - copied ‘kk’ to environment
[10:33:58.415] assign_globals() ... done
[10:33:58.415] plan(): Setting new future strategy stack:
[10:33:58.415] List of future strategies:
[10:33:58.415] 1. sequential:
[10:33:58.415]    - args: function (..., envir = parent.frame())
[10:33:58.415]    - tweaked: FALSE
[10:33:58.415]    - call: NULL
[10:33:58.416] plan(): nbrOfWorkers() = 1
[10:33:58.517] plan(): Setting new future strategy stack:
[10:33:58.517] List of future strategies:
[10:33:58.517] 1. sequential:
[10:33:58.517]    - args: function (..., envir = parent.frame())
[10:33:58.517]    - tweaked: FALSE
[10:33:58.517]    - call: plan(strategy)
[10:33:58.517] plan(): nbrOfWorkers() = 1
[10:33:58.518] SequentialFuture started (and completed)
[10:33:58.518] - Launch lazy future ... done
[10:33:58.518] run() for ‘SequentialFuture’ ... done
[10:33:58.518] resolved() for ‘SequentialFuture’ ...
[10:33:58.518] - state: ‘finished’
[10:33:58.518] - run: TRUE
[10:33:58.518] - result: ‘FutureResult’
[10:33:58.518] resolved() for ‘SequentialFuture’ ... done
[10:33:58.518] Future #1
[10:33:58.518]  length: 2 (resolved future 1)
[10:33:58.519] run() for ‘Future’ ...
[10:33:58.519] - state: ‘created’
[10:33:58.519] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:58.519] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:58.519] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:58.519]   - Field: ‘label’
[10:33:58.519]   - Field: ‘local’
[10:33:58.519]   - Field: ‘owner’
[10:33:58.520]   - Field: ‘envir’
[10:33:58.520]   - Field: ‘packages’
[10:33:58.520]   - Field: ‘gc’
[10:33:58.520]   - Field: ‘conditions’
[10:33:58.520]   - Field: ‘expr’
[10:33:58.520]   - Field: ‘uuid’
[10:33:58.520]   - Field: ‘seed’
[10:33:58.520]   - Field: ‘version’
[10:33:58.520]   - Field: ‘result’
[10:33:58.520]   - Field: ‘asynchronous’
[10:33:58.520]   - Field: ‘calls’
[10:33:58.521]   - Field: ‘globals’
[10:33:58.521]   - Field: ‘stdout’
[10:33:58.521]   - Field: ‘earlySignal’
[10:33:58.521]   - Field: ‘lazy’
[10:33:58.521]   - Field: ‘state’
[10:33:58.521] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:58.521] - Launch lazy future ...
[10:33:58.521] Packages needed by the future expression (n = 0): <none>
[10:33:58.521] Packages needed by future strategies (n = 0): <none>
[10:33:58.522] {
[10:33:58.522]     {
[10:33:58.522]         {
[10:33:58.522]             ...future.startTime <- base::Sys.time()
[10:33:58.522]             {
[10:33:58.522]                 {
[10:33:58.522]                   {
[10:33:58.522]                     base::local({
[10:33:58.522]                       has_future <- base::requireNamespace("future", 
[10:33:58.522]                         quietly = TRUE)
[10:33:58.522]                       if (has_future) {
[10:33:58.522]                         ns <- base::getNamespace("future")
[10:33:58.522]                         version <- ns[[".package"]][["version"]]
[10:33:58.522]                         if (is.null(version)) 
[10:33:58.522]                           version <- utils::packageVersion("future")
[10:33:58.522]                       }
[10:33:58.522]                       else {
[10:33:58.522]                         version <- NULL
[10:33:58.522]                       }
[10:33:58.522]                       if (!has_future || version < "1.8.0") {
[10:33:58.522]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:58.522]                           "", base::R.version$version.string), 
[10:33:58.522]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:58.522]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:58.522]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:58.522]                             "release", "version")], collapse = " "), 
[10:33:58.522]                           hostname = base::Sys.info()[["nodename"]])
[10:33:58.522]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:58.522]                           info)
[10:33:58.522]                         info <- base::paste(info, collapse = "; ")
[10:33:58.522]                         if (!has_future) {
[10:33:58.522]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:58.522]                             info)
[10:33:58.522]                         }
[10:33:58.522]                         else {
[10:33:58.522]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:58.522]                             info, version)
[10:33:58.522]                         }
[10:33:58.522]                         base::stop(msg)
[10:33:58.522]                       }
[10:33:58.522]                     })
[10:33:58.522]                   }
[10:33:58.522]                   ...future.strategy.old <- future::plan("list")
[10:33:58.522]                   options(future.plan = NULL)
[10:33:58.522]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.522]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:58.522]                 }
[10:33:58.522]                 ...future.workdir <- getwd()
[10:33:58.522]             }
[10:33:58.522]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:58.522]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:58.522]         }
[10:33:58.522]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:58.522]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:58.522]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:58.522]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:58.522]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:58.522]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:58.522]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:58.522]             base::names(...future.oldOptions))
[10:33:58.522]     }
[10:33:58.522]     if (FALSE) {
[10:33:58.522]     }
[10:33:58.522]     else {
[10:33:58.522]         if (TRUE) {
[10:33:58.522]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:58.522]                 open = "w")
[10:33:58.522]         }
[10:33:58.522]         else {
[10:33:58.522]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:58.522]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:58.522]         }
[10:33:58.522]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:58.522]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:58.522]             base::sink(type = "output", split = FALSE)
[10:33:58.522]             base::close(...future.stdout)
[10:33:58.522]         }, add = TRUE)
[10:33:58.522]     }
[10:33:58.522]     ...future.frame <- base::sys.nframe()
[10:33:58.522]     ...future.conditions <- base::list()
[10:33:58.522]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:58.522]     if (FALSE) {
[10:33:58.522]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:58.522]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:58.522]     }
[10:33:58.522]     ...future.result <- base::tryCatch({
[10:33:58.522]         base::withCallingHandlers({
[10:33:58.522]             ...future.value <- base::withVisible(base::local({
[10:33:58.522]                 Sys.sleep(0.1)
[10:33:58.522]                 kk
[10:33:58.522]             }))
[10:33:58.522]             future::FutureResult(value = ...future.value$value, 
[10:33:58.522]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.522]                   ...future.rng), globalenv = if (FALSE) 
[10:33:58.522]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:58.522]                     ...future.globalenv.names))
[10:33:58.522]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:58.522]         }, condition = base::local({
[10:33:58.522]             c <- base::c
[10:33:58.522]             inherits <- base::inherits
[10:33:58.522]             invokeRestart <- base::invokeRestart
[10:33:58.522]             length <- base::length
[10:33:58.522]             list <- base::list
[10:33:58.522]             seq.int <- base::seq.int
[10:33:58.522]             signalCondition <- base::signalCondition
[10:33:58.522]             sys.calls <- base::sys.calls
[10:33:58.522]             `[[` <- base::`[[`
[10:33:58.522]             `+` <- base::`+`
[10:33:58.522]             `<<-` <- base::`<<-`
[10:33:58.522]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:58.522]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:58.522]                   3L)]
[10:33:58.522]             }
[10:33:58.522]             function(cond) {
[10:33:58.522]                 is_error <- inherits(cond, "error")
[10:33:58.522]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:58.522]                   NULL)
[10:33:58.522]                 if (is_error) {
[10:33:58.522]                   sessionInformation <- function() {
[10:33:58.522]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:58.522]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:58.522]                       search = base::search(), system = base::Sys.info())
[10:33:58.522]                   }
[10:33:58.522]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.522]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:58.522]                     cond$call), session = sessionInformation(), 
[10:33:58.522]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:58.522]                   signalCondition(cond)
[10:33:58.522]                 }
[10:33:58.522]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:58.522]                 "immediateCondition"))) {
[10:33:58.522]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:58.522]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.522]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:58.522]                   if (TRUE && !signal) {
[10:33:58.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.522]                     {
[10:33:58.522]                       inherits <- base::inherits
[10:33:58.522]                       invokeRestart <- base::invokeRestart
[10:33:58.522]                       is.null <- base::is.null
[10:33:58.522]                       muffled <- FALSE
[10:33:58.522]                       if (inherits(cond, "message")) {
[10:33:58.522]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.522]                         if (muffled) 
[10:33:58.522]                           invokeRestart("muffleMessage")
[10:33:58.522]                       }
[10:33:58.522]                       else if (inherits(cond, "warning")) {
[10:33:58.522]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.522]                         if (muffled) 
[10:33:58.522]                           invokeRestart("muffleWarning")
[10:33:58.522]                       }
[10:33:58.522]                       else if (inherits(cond, "condition")) {
[10:33:58.522]                         if (!is.null(pattern)) {
[10:33:58.522]                           computeRestarts <- base::computeRestarts
[10:33:58.522]                           grepl <- base::grepl
[10:33:58.522]                           restarts <- computeRestarts(cond)
[10:33:58.522]                           for (restart in restarts) {
[10:33:58.522]                             name <- restart$name
[10:33:58.522]                             if (is.null(name)) 
[10:33:58.522]                               next
[10:33:58.522]                             if (!grepl(pattern, name)) 
[10:33:58.522]                               next
[10:33:58.522]                             invokeRestart(restart)
[10:33:58.522]                             muffled <- TRUE
[10:33:58.522]                             break
[10:33:58.522]                           }
[10:33:58.522]                         }
[10:33:58.522]                       }
[10:33:58.522]                       invisible(muffled)
[10:33:58.522]                     }
[10:33:58.522]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.522]                   }
[10:33:58.522]                 }
[10:33:58.522]                 else {
[10:33:58.522]                   if (TRUE) {
[10:33:58.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.522]                     {
[10:33:58.522]                       inherits <- base::inherits
[10:33:58.522]                       invokeRestart <- base::invokeRestart
[10:33:58.522]                       is.null <- base::is.null
[10:33:58.522]                       muffled <- FALSE
[10:33:58.522]                       if (inherits(cond, "message")) {
[10:33:58.522]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.522]                         if (muffled) 
[10:33:58.522]                           invokeRestart("muffleMessage")
[10:33:58.522]                       }
[10:33:58.522]                       else if (inherits(cond, "warning")) {
[10:33:58.522]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.522]                         if (muffled) 
[10:33:58.522]                           invokeRestart("muffleWarning")
[10:33:58.522]                       }
[10:33:58.522]                       else if (inherits(cond, "condition")) {
[10:33:58.522]                         if (!is.null(pattern)) {
[10:33:58.522]                           computeRestarts <- base::computeRestarts
[10:33:58.522]                           grepl <- base::grepl
[10:33:58.522]                           restarts <- computeRestarts(cond)
[10:33:58.522]                           for (restart in restarts) {
[10:33:58.522]                             name <- restart$name
[10:33:58.522]                             if (is.null(name)) 
[10:33:58.522]                               next
[10:33:58.522]                             if (!grepl(pattern, name)) 
[10:33:58.522]                               next
[10:33:58.522]                             invokeRestart(restart)
[10:33:58.522]                             muffled <- TRUE
[10:33:58.522]                             break
[10:33:58.522]                           }
[10:33:58.522]                         }
[10:33:58.522]                       }
[10:33:58.522]                       invisible(muffled)
[10:33:58.522]                     }
[10:33:58.522]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.522]                   }
[10:33:58.522]                 }
[10:33:58.522]             }
[10:33:58.522]         }))
[10:33:58.522]     }, error = function(ex) {
[10:33:58.522]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:58.522]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.522]                 ...future.rng), started = ...future.startTime, 
[10:33:58.522]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:58.522]             version = "1.8"), class = "FutureResult")
[10:33:58.522]     }, finally = {
[10:33:58.522]         if (!identical(...future.workdir, getwd())) 
[10:33:58.522]             setwd(...future.workdir)
[10:33:58.522]         {
[10:33:58.522]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:58.522]                 ...future.oldOptions$nwarnings <- NULL
[10:33:58.522]             }
[10:33:58.522]             base::options(...future.oldOptions)
[10:33:58.522]             if (.Platform$OS.type == "windows") {
[10:33:58.522]                 old_names <- names(...future.oldEnvVars)
[10:33:58.522]                 envs <- base::Sys.getenv()
[10:33:58.522]                 names <- names(envs)
[10:33:58.522]                 common <- intersect(names, old_names)
[10:33:58.522]                 added <- setdiff(names, old_names)
[10:33:58.522]                 removed <- setdiff(old_names, names)
[10:33:58.522]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:58.522]                   envs[common]]
[10:33:58.522]                 NAMES <- toupper(changed)
[10:33:58.522]                 args <- list()
[10:33:58.522]                 for (kk in seq_along(NAMES)) {
[10:33:58.522]                   name <- changed[[kk]]
[10:33:58.522]                   NAME <- NAMES[[kk]]
[10:33:58.522]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.522]                     next
[10:33:58.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.522]                 }
[10:33:58.522]                 NAMES <- toupper(added)
[10:33:58.522]                 for (kk in seq_along(NAMES)) {
[10:33:58.522]                   name <- added[[kk]]
[10:33:58.522]                   NAME <- NAMES[[kk]]
[10:33:58.522]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.522]                     next
[10:33:58.522]                   args[[name]] <- ""
[10:33:58.522]                 }
[10:33:58.522]                 NAMES <- toupper(removed)
[10:33:58.522]                 for (kk in seq_along(NAMES)) {
[10:33:58.522]                   name <- removed[[kk]]
[10:33:58.522]                   NAME <- NAMES[[kk]]
[10:33:58.522]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.522]                     next
[10:33:58.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.522]                 }
[10:33:58.522]                 if (length(args) > 0) 
[10:33:58.522]                   base::do.call(base::Sys.setenv, args = args)
[10:33:58.522]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:58.522]             }
[10:33:58.522]             else {
[10:33:58.522]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:58.522]             }
[10:33:58.522]             {
[10:33:58.522]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:58.522]                   0L) {
[10:33:58.522]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:58.522]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:58.522]                   base::options(opts)
[10:33:58.522]                 }
[10:33:58.522]                 {
[10:33:58.522]                   {
[10:33:58.522]                     NULL
[10:33:58.522]                     RNGkind("Mersenne-Twister")
[10:33:58.522]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:58.522]                       inherits = FALSE)
[10:33:58.522]                   }
[10:33:58.522]                   options(future.plan = NULL)
[10:33:58.522]                   if (is.na(NA_character_)) 
[10:33:58.522]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.522]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:58.522]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:58.522]                     .init = FALSE)
[10:33:58.522]                 }
[10:33:58.522]             }
[10:33:58.522]         }
[10:33:58.522]     })
[10:33:58.522]     if (TRUE) {
[10:33:58.522]         base::sink(type = "output", split = FALSE)
[10:33:58.522]         if (TRUE) {
[10:33:58.522]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:58.522]         }
[10:33:58.522]         else {
[10:33:58.522]             ...future.result["stdout"] <- base::list(NULL)
[10:33:58.522]         }
[10:33:58.522]         base::close(...future.stdout)
[10:33:58.522]         ...future.stdout <- NULL
[10:33:58.522]     }
[10:33:58.522]     ...future.result$conditions <- ...future.conditions
[10:33:58.522]     ...future.result$finished <- base::Sys.time()
[10:33:58.522]     ...future.result
[10:33:58.522] }
[10:33:58.523] assign_globals() ...
[10:33:58.523] List of 1
[10:33:58.523]  $ kk: int 2
[10:33:58.523]  - attr(*, "where")=List of 1
[10:33:58.523]   ..$ kk:<environment: R_EmptyEnv> 
[10:33:58.523]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:58.523]  - attr(*, "resolved")= logi FALSE
[10:33:58.523]  - attr(*, "total_size")= num 56
[10:33:58.523]  - attr(*, "already-done")= logi TRUE
[10:33:58.526] - copied ‘kk’ to environment
[10:33:58.526] assign_globals() ... done
[10:33:58.526] plan(): Setting new future strategy stack:
[10:33:58.526] List of future strategies:
[10:33:58.526] 1. sequential:
[10:33:58.526]    - args: function (..., envir = parent.frame())
[10:33:58.526]    - tweaked: FALSE
[10:33:58.526]    - call: NULL
[10:33:58.527] plan(): nbrOfWorkers() = 1
[10:33:58.628] plan(): Setting new future strategy stack:
[10:33:58.628] List of future strategies:
[10:33:58.628] 1. sequential:
[10:33:58.628]    - args: function (..., envir = parent.frame())
[10:33:58.628]    - tweaked: FALSE
[10:33:58.628]    - call: plan(strategy)
[10:33:58.628] plan(): nbrOfWorkers() = 1
[10:33:58.628] SequentialFuture started (and completed)
[10:33:58.628] - Launch lazy future ... done
[10:33:58.629] run() for ‘SequentialFuture’ ... done
[10:33:58.629] resolved() for ‘SequentialFuture’ ...
[10:33:58.629] - state: ‘finished’
[10:33:58.629] - run: TRUE
[10:33:58.629] - result: ‘FutureResult’
[10:33:58.629] resolved() for ‘SequentialFuture’ ... done
[10:33:58.629] Future #2
[10:33:58.629]  length: 1 (resolved future 2)
[10:33:58.629] run() for ‘Future’ ...
[10:33:58.629] - state: ‘created’
[10:33:58.630] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:58.630] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:58.630] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:58.630]   - Field: ‘label’
[10:33:58.630]   - Field: ‘local’
[10:33:58.630]   - Field: ‘owner’
[10:33:58.630]   - Field: ‘envir’
[10:33:58.630]   - Field: ‘packages’
[10:33:58.631]   - Field: ‘gc’
[10:33:58.631]   - Field: ‘conditions’
[10:33:58.631]   - Field: ‘expr’
[10:33:58.631]   - Field: ‘uuid’
[10:33:58.631]   - Field: ‘seed’
[10:33:58.631]   - Field: ‘version’
[10:33:58.631]   - Field: ‘result’
[10:33:58.631]   - Field: ‘asynchronous’
[10:33:58.631]   - Field: ‘calls’
[10:33:58.631]   - Field: ‘globals’
[10:33:58.631]   - Field: ‘stdout’
[10:33:58.632]   - Field: ‘earlySignal’
[10:33:58.632]   - Field: ‘lazy’
[10:33:58.632]   - Field: ‘state’
[10:33:58.632] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:58.632] - Launch lazy future ...
[10:33:58.632] Packages needed by the future expression (n = 0): <none>
[10:33:58.632] Packages needed by future strategies (n = 0): <none>
[10:33:58.633] {
[10:33:58.633]     {
[10:33:58.633]         {
[10:33:58.633]             ...future.startTime <- base::Sys.time()
[10:33:58.633]             {
[10:33:58.633]                 {
[10:33:58.633]                   {
[10:33:58.633]                     base::local({
[10:33:58.633]                       has_future <- base::requireNamespace("future", 
[10:33:58.633]                         quietly = TRUE)
[10:33:58.633]                       if (has_future) {
[10:33:58.633]                         ns <- base::getNamespace("future")
[10:33:58.633]                         version <- ns[[".package"]][["version"]]
[10:33:58.633]                         if (is.null(version)) 
[10:33:58.633]                           version <- utils::packageVersion("future")
[10:33:58.633]                       }
[10:33:58.633]                       else {
[10:33:58.633]                         version <- NULL
[10:33:58.633]                       }
[10:33:58.633]                       if (!has_future || version < "1.8.0") {
[10:33:58.633]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:58.633]                           "", base::R.version$version.string), 
[10:33:58.633]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:58.633]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:58.633]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:58.633]                             "release", "version")], collapse = " "), 
[10:33:58.633]                           hostname = base::Sys.info()[["nodename"]])
[10:33:58.633]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:58.633]                           info)
[10:33:58.633]                         info <- base::paste(info, collapse = "; ")
[10:33:58.633]                         if (!has_future) {
[10:33:58.633]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:58.633]                             info)
[10:33:58.633]                         }
[10:33:58.633]                         else {
[10:33:58.633]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:58.633]                             info, version)
[10:33:58.633]                         }
[10:33:58.633]                         base::stop(msg)
[10:33:58.633]                       }
[10:33:58.633]                     })
[10:33:58.633]                   }
[10:33:58.633]                   ...future.strategy.old <- future::plan("list")
[10:33:58.633]                   options(future.plan = NULL)
[10:33:58.633]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.633]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:58.633]                 }
[10:33:58.633]                 ...future.workdir <- getwd()
[10:33:58.633]             }
[10:33:58.633]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:58.633]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:58.633]         }
[10:33:58.633]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:58.633]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:58.633]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:58.633]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:58.633]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:58.633]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:58.633]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:58.633]             base::names(...future.oldOptions))
[10:33:58.633]     }
[10:33:58.633]     if (FALSE) {
[10:33:58.633]     }
[10:33:58.633]     else {
[10:33:58.633]         if (TRUE) {
[10:33:58.633]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:58.633]                 open = "w")
[10:33:58.633]         }
[10:33:58.633]         else {
[10:33:58.633]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:58.633]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:58.633]         }
[10:33:58.633]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:58.633]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:58.633]             base::sink(type = "output", split = FALSE)
[10:33:58.633]             base::close(...future.stdout)
[10:33:58.633]         }, add = TRUE)
[10:33:58.633]     }
[10:33:58.633]     ...future.frame <- base::sys.nframe()
[10:33:58.633]     ...future.conditions <- base::list()
[10:33:58.633]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:58.633]     if (FALSE) {
[10:33:58.633]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:58.633]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:58.633]     }
[10:33:58.633]     ...future.result <- base::tryCatch({
[10:33:58.633]         base::withCallingHandlers({
[10:33:58.633]             ...future.value <- base::withVisible(base::local({
[10:33:58.633]                 Sys.sleep(0.1)
[10:33:58.633]                 kk
[10:33:58.633]             }))
[10:33:58.633]             future::FutureResult(value = ...future.value$value, 
[10:33:58.633]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.633]                   ...future.rng), globalenv = if (FALSE) 
[10:33:58.633]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:58.633]                     ...future.globalenv.names))
[10:33:58.633]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:58.633]         }, condition = base::local({
[10:33:58.633]             c <- base::c
[10:33:58.633]             inherits <- base::inherits
[10:33:58.633]             invokeRestart <- base::invokeRestart
[10:33:58.633]             length <- base::length
[10:33:58.633]             list <- base::list
[10:33:58.633]             seq.int <- base::seq.int
[10:33:58.633]             signalCondition <- base::signalCondition
[10:33:58.633]             sys.calls <- base::sys.calls
[10:33:58.633]             `[[` <- base::`[[`
[10:33:58.633]             `+` <- base::`+`
[10:33:58.633]             `<<-` <- base::`<<-`
[10:33:58.633]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:58.633]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:58.633]                   3L)]
[10:33:58.633]             }
[10:33:58.633]             function(cond) {
[10:33:58.633]                 is_error <- inherits(cond, "error")
[10:33:58.633]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:58.633]                   NULL)
[10:33:58.633]                 if (is_error) {
[10:33:58.633]                   sessionInformation <- function() {
[10:33:58.633]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:58.633]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:58.633]                       search = base::search(), system = base::Sys.info())
[10:33:58.633]                   }
[10:33:58.633]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.633]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:58.633]                     cond$call), session = sessionInformation(), 
[10:33:58.633]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:58.633]                   signalCondition(cond)
[10:33:58.633]                 }
[10:33:58.633]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:58.633]                 "immediateCondition"))) {
[10:33:58.633]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:58.633]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.633]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:58.633]                   if (TRUE && !signal) {
[10:33:58.633]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.633]                     {
[10:33:58.633]                       inherits <- base::inherits
[10:33:58.633]                       invokeRestart <- base::invokeRestart
[10:33:58.633]                       is.null <- base::is.null
[10:33:58.633]                       muffled <- FALSE
[10:33:58.633]                       if (inherits(cond, "message")) {
[10:33:58.633]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.633]                         if (muffled) 
[10:33:58.633]                           invokeRestart("muffleMessage")
[10:33:58.633]                       }
[10:33:58.633]                       else if (inherits(cond, "warning")) {
[10:33:58.633]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.633]                         if (muffled) 
[10:33:58.633]                           invokeRestart("muffleWarning")
[10:33:58.633]                       }
[10:33:58.633]                       else if (inherits(cond, "condition")) {
[10:33:58.633]                         if (!is.null(pattern)) {
[10:33:58.633]                           computeRestarts <- base::computeRestarts
[10:33:58.633]                           grepl <- base::grepl
[10:33:58.633]                           restarts <- computeRestarts(cond)
[10:33:58.633]                           for (restart in restarts) {
[10:33:58.633]                             name <- restart$name
[10:33:58.633]                             if (is.null(name)) 
[10:33:58.633]                               next
[10:33:58.633]                             if (!grepl(pattern, name)) 
[10:33:58.633]                               next
[10:33:58.633]                             invokeRestart(restart)
[10:33:58.633]                             muffled <- TRUE
[10:33:58.633]                             break
[10:33:58.633]                           }
[10:33:58.633]                         }
[10:33:58.633]                       }
[10:33:58.633]                       invisible(muffled)
[10:33:58.633]                     }
[10:33:58.633]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.633]                   }
[10:33:58.633]                 }
[10:33:58.633]                 else {
[10:33:58.633]                   if (TRUE) {
[10:33:58.633]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.633]                     {
[10:33:58.633]                       inherits <- base::inherits
[10:33:58.633]                       invokeRestart <- base::invokeRestart
[10:33:58.633]                       is.null <- base::is.null
[10:33:58.633]                       muffled <- FALSE
[10:33:58.633]                       if (inherits(cond, "message")) {
[10:33:58.633]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.633]                         if (muffled) 
[10:33:58.633]                           invokeRestart("muffleMessage")
[10:33:58.633]                       }
[10:33:58.633]                       else if (inherits(cond, "warning")) {
[10:33:58.633]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.633]                         if (muffled) 
[10:33:58.633]                           invokeRestart("muffleWarning")
[10:33:58.633]                       }
[10:33:58.633]                       else if (inherits(cond, "condition")) {
[10:33:58.633]                         if (!is.null(pattern)) {
[10:33:58.633]                           computeRestarts <- base::computeRestarts
[10:33:58.633]                           grepl <- base::grepl
[10:33:58.633]                           restarts <- computeRestarts(cond)
[10:33:58.633]                           for (restart in restarts) {
[10:33:58.633]                             name <- restart$name
[10:33:58.633]                             if (is.null(name)) 
[10:33:58.633]                               next
[10:33:58.633]                             if (!grepl(pattern, name)) 
[10:33:58.633]                               next
[10:33:58.633]                             invokeRestart(restart)
[10:33:58.633]                             muffled <- TRUE
[10:33:58.633]                             break
[10:33:58.633]                           }
[10:33:58.633]                         }
[10:33:58.633]                       }
[10:33:58.633]                       invisible(muffled)
[10:33:58.633]                     }
[10:33:58.633]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.633]                   }
[10:33:58.633]                 }
[10:33:58.633]             }
[10:33:58.633]         }))
[10:33:58.633]     }, error = function(ex) {
[10:33:58.633]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:58.633]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.633]                 ...future.rng), started = ...future.startTime, 
[10:33:58.633]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:58.633]             version = "1.8"), class = "FutureResult")
[10:33:58.633]     }, finally = {
[10:33:58.633]         if (!identical(...future.workdir, getwd())) 
[10:33:58.633]             setwd(...future.workdir)
[10:33:58.633]         {
[10:33:58.633]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:58.633]                 ...future.oldOptions$nwarnings <- NULL
[10:33:58.633]             }
[10:33:58.633]             base::options(...future.oldOptions)
[10:33:58.633]             if (.Platform$OS.type == "windows") {
[10:33:58.633]                 old_names <- names(...future.oldEnvVars)
[10:33:58.633]                 envs <- base::Sys.getenv()
[10:33:58.633]                 names <- names(envs)
[10:33:58.633]                 common <- intersect(names, old_names)
[10:33:58.633]                 added <- setdiff(names, old_names)
[10:33:58.633]                 removed <- setdiff(old_names, names)
[10:33:58.633]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:58.633]                   envs[common]]
[10:33:58.633]                 NAMES <- toupper(changed)
[10:33:58.633]                 args <- list()
[10:33:58.633]                 for (kk in seq_along(NAMES)) {
[10:33:58.633]                   name <- changed[[kk]]
[10:33:58.633]                   NAME <- NAMES[[kk]]
[10:33:58.633]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.633]                     next
[10:33:58.633]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.633]                 }
[10:33:58.633]                 NAMES <- toupper(added)
[10:33:58.633]                 for (kk in seq_along(NAMES)) {
[10:33:58.633]                   name <- added[[kk]]
[10:33:58.633]                   NAME <- NAMES[[kk]]
[10:33:58.633]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.633]                     next
[10:33:58.633]                   args[[name]] <- ""
[10:33:58.633]                 }
[10:33:58.633]                 NAMES <- toupper(removed)
[10:33:58.633]                 for (kk in seq_along(NAMES)) {
[10:33:58.633]                   name <- removed[[kk]]
[10:33:58.633]                   NAME <- NAMES[[kk]]
[10:33:58.633]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.633]                     next
[10:33:58.633]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.633]                 }
[10:33:58.633]                 if (length(args) > 0) 
[10:33:58.633]                   base::do.call(base::Sys.setenv, args = args)
[10:33:58.633]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:58.633]             }
[10:33:58.633]             else {
[10:33:58.633]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:58.633]             }
[10:33:58.633]             {
[10:33:58.633]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:58.633]                   0L) {
[10:33:58.633]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:58.633]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:58.633]                   base::options(opts)
[10:33:58.633]                 }
[10:33:58.633]                 {
[10:33:58.633]                   {
[10:33:58.633]                     NULL
[10:33:58.633]                     RNGkind("Mersenne-Twister")
[10:33:58.633]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:58.633]                       inherits = FALSE)
[10:33:58.633]                   }
[10:33:58.633]                   options(future.plan = NULL)
[10:33:58.633]                   if (is.na(NA_character_)) 
[10:33:58.633]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.633]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:58.633]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:58.633]                     .init = FALSE)
[10:33:58.633]                 }
[10:33:58.633]             }
[10:33:58.633]         }
[10:33:58.633]     })
[10:33:58.633]     if (TRUE) {
[10:33:58.633]         base::sink(type = "output", split = FALSE)
[10:33:58.633]         if (TRUE) {
[10:33:58.633]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:58.633]         }
[10:33:58.633]         else {
[10:33:58.633]             ...future.result["stdout"] <- base::list(NULL)
[10:33:58.633]         }
[10:33:58.633]         base::close(...future.stdout)
[10:33:58.633]         ...future.stdout <- NULL
[10:33:58.633]     }
[10:33:58.633]     ...future.result$conditions <- ...future.conditions
[10:33:58.633]     ...future.result$finished <- base::Sys.time()
[10:33:58.633]     ...future.result
[10:33:58.633] }
[10:33:58.634] assign_globals() ...
[10:33:58.634] List of 1
[10:33:58.634]  $ kk: int 3
[10:33:58.634]  - attr(*, "where")=List of 1
[10:33:58.634]   ..$ kk:<environment: R_EmptyEnv> 
[10:33:58.634]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:33:58.634]  - attr(*, "resolved")= logi FALSE
[10:33:58.634]  - attr(*, "total_size")= num 56
[10:33:58.634]  - attr(*, "already-done")= logi TRUE
[10:33:58.638] - copied ‘kk’ to environment
[10:33:58.639] assign_globals() ... done
[10:33:58.639] plan(): Setting new future strategy stack:
[10:33:58.639] List of future strategies:
[10:33:58.639] 1. sequential:
[10:33:58.639]    - args: function (..., envir = parent.frame())
[10:33:58.639]    - tweaked: FALSE
[10:33:58.639]    - call: NULL
[10:33:58.639] plan(): nbrOfWorkers() = 1
[10:33:58.740] plan(): Setting new future strategy stack:
[10:33:58.740] List of future strategies:
[10:33:58.740] 1. sequential:
[10:33:58.740]    - args: function (..., envir = parent.frame())
[10:33:58.740]    - tweaked: FALSE
[10:33:58.740]    - call: plan(strategy)
[10:33:58.741] plan(): nbrOfWorkers() = 1
[10:33:58.741] SequentialFuture started (and completed)
[10:33:58.741] - Launch lazy future ... done
[10:33:58.741] run() for ‘SequentialFuture’ ... done
[10:33:58.742] resolved() for ‘SequentialFuture’ ...
[10:33:58.742] - state: ‘finished’
[10:33:58.742] - run: TRUE
[10:33:58.742] - result: ‘FutureResult’
[10:33:58.742] resolved() for ‘SequentialFuture’ ... done
[10:33:58.742] Future #3
[10:33:58.742]  length: 0 (resolved future 3)
[10:33:58.742] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[10:33:58.743] resolve() on environment ...
[10:33:58.743]  recursive: 0
[10:33:58.744]  elements: [2] ‘a’, ‘b’
[10:33:58.744]  length: 1 (resolved future 1)
[10:33:58.745]  length: 0 (resolved future 2)
[10:33:58.745] resolve() on environment ... DONE
[10:33:58.745] getGlobalsAndPackages() ...
[10:33:58.745] Searching for globals...
[10:33:58.745] 
[10:33:58.746] Searching for globals ... DONE
[10:33:58.746] - globals: [0] <none>
[10:33:58.746] getGlobalsAndPackages() ... DONE
[10:33:58.746] run() for ‘Future’ ...
[10:33:58.746] - state: ‘created’
[10:33:58.746] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:58.746] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:58.747] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:58.747]   - Field: ‘label’
[10:33:58.747]   - Field: ‘local’
[10:33:58.747]   - Field: ‘owner’
[10:33:58.747]   - Field: ‘envir’
[10:33:58.747]   - Field: ‘packages’
[10:33:58.747]   - Field: ‘gc’
[10:33:58.747]   - Field: ‘conditions’
[10:33:58.747]   - Field: ‘expr’
[10:33:58.747]   - Field: ‘uuid’
[10:33:58.747]   - Field: ‘seed’
[10:33:58.748]   - Field: ‘version’
[10:33:58.748]   - Field: ‘result’
[10:33:58.748]   - Field: ‘asynchronous’
[10:33:58.748]   - Field: ‘calls’
[10:33:58.748]   - Field: ‘globals’
[10:33:58.748]   - Field: ‘stdout’
[10:33:58.748]   - Field: ‘earlySignal’
[10:33:58.748]   - Field: ‘lazy’
[10:33:58.748]   - Field: ‘state’
[10:33:58.748] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:58.748] - Launch lazy future ...
[10:33:58.749] Packages needed by the future expression (n = 0): <none>
[10:33:58.749] Packages needed by future strategies (n = 0): <none>
[10:33:58.749] {
[10:33:58.749]     {
[10:33:58.749]         {
[10:33:58.749]             ...future.startTime <- base::Sys.time()
[10:33:58.749]             {
[10:33:58.749]                 {
[10:33:58.749]                   {
[10:33:58.749]                     base::local({
[10:33:58.749]                       has_future <- base::requireNamespace("future", 
[10:33:58.749]                         quietly = TRUE)
[10:33:58.749]                       if (has_future) {
[10:33:58.749]                         ns <- base::getNamespace("future")
[10:33:58.749]                         version <- ns[[".package"]][["version"]]
[10:33:58.749]                         if (is.null(version)) 
[10:33:58.749]                           version <- utils::packageVersion("future")
[10:33:58.749]                       }
[10:33:58.749]                       else {
[10:33:58.749]                         version <- NULL
[10:33:58.749]                       }
[10:33:58.749]                       if (!has_future || version < "1.8.0") {
[10:33:58.749]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:58.749]                           "", base::R.version$version.string), 
[10:33:58.749]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:58.749]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:58.749]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:58.749]                             "release", "version")], collapse = " "), 
[10:33:58.749]                           hostname = base::Sys.info()[["nodename"]])
[10:33:58.749]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:58.749]                           info)
[10:33:58.749]                         info <- base::paste(info, collapse = "; ")
[10:33:58.749]                         if (!has_future) {
[10:33:58.749]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:58.749]                             info)
[10:33:58.749]                         }
[10:33:58.749]                         else {
[10:33:58.749]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:58.749]                             info, version)
[10:33:58.749]                         }
[10:33:58.749]                         base::stop(msg)
[10:33:58.749]                       }
[10:33:58.749]                     })
[10:33:58.749]                   }
[10:33:58.749]                   ...future.strategy.old <- future::plan("list")
[10:33:58.749]                   options(future.plan = NULL)
[10:33:58.749]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.749]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:58.749]                 }
[10:33:58.749]                 ...future.workdir <- getwd()
[10:33:58.749]             }
[10:33:58.749]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:58.749]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:58.749]         }
[10:33:58.749]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:58.749]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:58.749]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:58.749]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:58.749]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:58.749]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:58.749]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:58.749]             base::names(...future.oldOptions))
[10:33:58.749]     }
[10:33:58.749]     if (FALSE) {
[10:33:58.749]     }
[10:33:58.749]     else {
[10:33:58.749]         if (TRUE) {
[10:33:58.749]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:58.749]                 open = "w")
[10:33:58.749]         }
[10:33:58.749]         else {
[10:33:58.749]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:58.749]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:58.749]         }
[10:33:58.749]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:58.749]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:58.749]             base::sink(type = "output", split = FALSE)
[10:33:58.749]             base::close(...future.stdout)
[10:33:58.749]         }, add = TRUE)
[10:33:58.749]     }
[10:33:58.749]     ...future.frame <- base::sys.nframe()
[10:33:58.749]     ...future.conditions <- base::list()
[10:33:58.749]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:58.749]     if (FALSE) {
[10:33:58.749]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:58.749]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:58.749]     }
[10:33:58.749]     ...future.result <- base::tryCatch({
[10:33:58.749]         base::withCallingHandlers({
[10:33:58.749]             ...future.value <- base::withVisible(base::local(1))
[10:33:58.749]             future::FutureResult(value = ...future.value$value, 
[10:33:58.749]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.749]                   ...future.rng), globalenv = if (FALSE) 
[10:33:58.749]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:58.749]                     ...future.globalenv.names))
[10:33:58.749]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:58.749]         }, condition = base::local({
[10:33:58.749]             c <- base::c
[10:33:58.749]             inherits <- base::inherits
[10:33:58.749]             invokeRestart <- base::invokeRestart
[10:33:58.749]             length <- base::length
[10:33:58.749]             list <- base::list
[10:33:58.749]             seq.int <- base::seq.int
[10:33:58.749]             signalCondition <- base::signalCondition
[10:33:58.749]             sys.calls <- base::sys.calls
[10:33:58.749]             `[[` <- base::`[[`
[10:33:58.749]             `+` <- base::`+`
[10:33:58.749]             `<<-` <- base::`<<-`
[10:33:58.749]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:58.749]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:58.749]                   3L)]
[10:33:58.749]             }
[10:33:58.749]             function(cond) {
[10:33:58.749]                 is_error <- inherits(cond, "error")
[10:33:58.749]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:58.749]                   NULL)
[10:33:58.749]                 if (is_error) {
[10:33:58.749]                   sessionInformation <- function() {
[10:33:58.749]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:58.749]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:58.749]                       search = base::search(), system = base::Sys.info())
[10:33:58.749]                   }
[10:33:58.749]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.749]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:58.749]                     cond$call), session = sessionInformation(), 
[10:33:58.749]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:58.749]                   signalCondition(cond)
[10:33:58.749]                 }
[10:33:58.749]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:58.749]                 "immediateCondition"))) {
[10:33:58.749]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:58.749]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.749]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:58.749]                   if (TRUE && !signal) {
[10:33:58.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.749]                     {
[10:33:58.749]                       inherits <- base::inherits
[10:33:58.749]                       invokeRestart <- base::invokeRestart
[10:33:58.749]                       is.null <- base::is.null
[10:33:58.749]                       muffled <- FALSE
[10:33:58.749]                       if (inherits(cond, "message")) {
[10:33:58.749]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.749]                         if (muffled) 
[10:33:58.749]                           invokeRestart("muffleMessage")
[10:33:58.749]                       }
[10:33:58.749]                       else if (inherits(cond, "warning")) {
[10:33:58.749]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.749]                         if (muffled) 
[10:33:58.749]                           invokeRestart("muffleWarning")
[10:33:58.749]                       }
[10:33:58.749]                       else if (inherits(cond, "condition")) {
[10:33:58.749]                         if (!is.null(pattern)) {
[10:33:58.749]                           computeRestarts <- base::computeRestarts
[10:33:58.749]                           grepl <- base::grepl
[10:33:58.749]                           restarts <- computeRestarts(cond)
[10:33:58.749]                           for (restart in restarts) {
[10:33:58.749]                             name <- restart$name
[10:33:58.749]                             if (is.null(name)) 
[10:33:58.749]                               next
[10:33:58.749]                             if (!grepl(pattern, name)) 
[10:33:58.749]                               next
[10:33:58.749]                             invokeRestart(restart)
[10:33:58.749]                             muffled <- TRUE
[10:33:58.749]                             break
[10:33:58.749]                           }
[10:33:58.749]                         }
[10:33:58.749]                       }
[10:33:58.749]                       invisible(muffled)
[10:33:58.749]                     }
[10:33:58.749]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.749]                   }
[10:33:58.749]                 }
[10:33:58.749]                 else {
[10:33:58.749]                   if (TRUE) {
[10:33:58.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.749]                     {
[10:33:58.749]                       inherits <- base::inherits
[10:33:58.749]                       invokeRestart <- base::invokeRestart
[10:33:58.749]                       is.null <- base::is.null
[10:33:58.749]                       muffled <- FALSE
[10:33:58.749]                       if (inherits(cond, "message")) {
[10:33:58.749]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.749]                         if (muffled) 
[10:33:58.749]                           invokeRestart("muffleMessage")
[10:33:58.749]                       }
[10:33:58.749]                       else if (inherits(cond, "warning")) {
[10:33:58.749]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.749]                         if (muffled) 
[10:33:58.749]                           invokeRestart("muffleWarning")
[10:33:58.749]                       }
[10:33:58.749]                       else if (inherits(cond, "condition")) {
[10:33:58.749]                         if (!is.null(pattern)) {
[10:33:58.749]                           computeRestarts <- base::computeRestarts
[10:33:58.749]                           grepl <- base::grepl
[10:33:58.749]                           restarts <- computeRestarts(cond)
[10:33:58.749]                           for (restart in restarts) {
[10:33:58.749]                             name <- restart$name
[10:33:58.749]                             if (is.null(name)) 
[10:33:58.749]                               next
[10:33:58.749]                             if (!grepl(pattern, name)) 
[10:33:58.749]                               next
[10:33:58.749]                             invokeRestart(restart)
[10:33:58.749]                             muffled <- TRUE
[10:33:58.749]                             break
[10:33:58.749]                           }
[10:33:58.749]                         }
[10:33:58.749]                       }
[10:33:58.749]                       invisible(muffled)
[10:33:58.749]                     }
[10:33:58.749]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.749]                   }
[10:33:58.749]                 }
[10:33:58.749]             }
[10:33:58.749]         }))
[10:33:58.749]     }, error = function(ex) {
[10:33:58.749]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:58.749]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.749]                 ...future.rng), started = ...future.startTime, 
[10:33:58.749]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:58.749]             version = "1.8"), class = "FutureResult")
[10:33:58.749]     }, finally = {
[10:33:58.749]         if (!identical(...future.workdir, getwd())) 
[10:33:58.749]             setwd(...future.workdir)
[10:33:58.749]         {
[10:33:58.749]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:58.749]                 ...future.oldOptions$nwarnings <- NULL
[10:33:58.749]             }
[10:33:58.749]             base::options(...future.oldOptions)
[10:33:58.749]             if (.Platform$OS.type == "windows") {
[10:33:58.749]                 old_names <- names(...future.oldEnvVars)
[10:33:58.749]                 envs <- base::Sys.getenv()
[10:33:58.749]                 names <- names(envs)
[10:33:58.749]                 common <- intersect(names, old_names)
[10:33:58.749]                 added <- setdiff(names, old_names)
[10:33:58.749]                 removed <- setdiff(old_names, names)
[10:33:58.749]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:58.749]                   envs[common]]
[10:33:58.749]                 NAMES <- toupper(changed)
[10:33:58.749]                 args <- list()
[10:33:58.749]                 for (kk in seq_along(NAMES)) {
[10:33:58.749]                   name <- changed[[kk]]
[10:33:58.749]                   NAME <- NAMES[[kk]]
[10:33:58.749]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.749]                     next
[10:33:58.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.749]                 }
[10:33:58.749]                 NAMES <- toupper(added)
[10:33:58.749]                 for (kk in seq_along(NAMES)) {
[10:33:58.749]                   name <- added[[kk]]
[10:33:58.749]                   NAME <- NAMES[[kk]]
[10:33:58.749]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.749]                     next
[10:33:58.749]                   args[[name]] <- ""
[10:33:58.749]                 }
[10:33:58.749]                 NAMES <- toupper(removed)
[10:33:58.749]                 for (kk in seq_along(NAMES)) {
[10:33:58.749]                   name <- removed[[kk]]
[10:33:58.749]                   NAME <- NAMES[[kk]]
[10:33:58.749]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.749]                     next
[10:33:58.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.749]                 }
[10:33:58.749]                 if (length(args) > 0) 
[10:33:58.749]                   base::do.call(base::Sys.setenv, args = args)
[10:33:58.749]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:58.749]             }
[10:33:58.749]             else {
[10:33:58.749]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:58.749]             }
[10:33:58.749]             {
[10:33:58.749]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:58.749]                   0L) {
[10:33:58.749]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:58.749]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:58.749]                   base::options(opts)
[10:33:58.749]                 }
[10:33:58.749]                 {
[10:33:58.749]                   {
[10:33:58.749]                     NULL
[10:33:58.749]                     RNGkind("Mersenne-Twister")
[10:33:58.749]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:58.749]                       inherits = FALSE)
[10:33:58.749]                   }
[10:33:58.749]                   options(future.plan = NULL)
[10:33:58.749]                   if (is.na(NA_character_)) 
[10:33:58.749]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.749]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:58.749]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:58.749]                     .init = FALSE)
[10:33:58.749]                 }
[10:33:58.749]             }
[10:33:58.749]         }
[10:33:58.749]     })
[10:33:58.749]     if (TRUE) {
[10:33:58.749]         base::sink(type = "output", split = FALSE)
[10:33:58.749]         if (TRUE) {
[10:33:58.749]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:58.749]         }
[10:33:58.749]         else {
[10:33:58.749]             ...future.result["stdout"] <- base::list(NULL)
[10:33:58.749]         }
[10:33:58.749]         base::close(...future.stdout)
[10:33:58.749]         ...future.stdout <- NULL
[10:33:58.749]     }
[10:33:58.749]     ...future.result$conditions <- ...future.conditions
[10:33:58.749]     ...future.result$finished <- base::Sys.time()
[10:33:58.749]     ...future.result
[10:33:58.749] }
[10:33:58.751] plan(): Setting new future strategy stack:
[10:33:58.751] List of future strategies:
[10:33:58.751] 1. sequential:
[10:33:58.751]    - args: function (..., envir = parent.frame())
[10:33:58.751]    - tweaked: FALSE
[10:33:58.751]    - call: NULL
[10:33:58.751] plan(): nbrOfWorkers() = 1
[10:33:58.752] plan(): Setting new future strategy stack:
[10:33:58.752] List of future strategies:
[10:33:58.752] 1. sequential:
[10:33:58.752]    - args: function (..., envir = parent.frame())
[10:33:58.752]    - tweaked: FALSE
[10:33:58.752]    - call: plan(strategy)
[10:33:58.752] plan(): nbrOfWorkers() = 1
[10:33:58.753] SequentialFuture started (and completed)
[10:33:58.753] - Launch lazy future ... done
[10:33:58.753] run() for ‘SequentialFuture’ ... done
[10:33:58.753] getGlobalsAndPackages() ...
[10:33:58.753] Searching for globals...
[10:33:58.753] 
[10:33:58.753] Searching for globals ... DONE
[10:33:58.754] - globals: [0] <none>
[10:33:58.754] getGlobalsAndPackages() ... DONE
[10:33:58.754] run() for ‘Future’ ...
[10:33:58.754] - state: ‘created’
[10:33:58.754] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:58.754] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:58.754] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:58.755]   - Field: ‘label’
[10:33:58.755]   - Field: ‘local’
[10:33:58.755]   - Field: ‘owner’
[10:33:58.755]   - Field: ‘envir’
[10:33:58.755]   - Field: ‘packages’
[10:33:58.755]   - Field: ‘gc’
[10:33:58.755]   - Field: ‘conditions’
[10:33:58.755]   - Field: ‘expr’
[10:33:58.755]   - Field: ‘uuid’
[10:33:58.755]   - Field: ‘seed’
[10:33:58.755]   - Field: ‘version’
[10:33:58.756]   - Field: ‘result’
[10:33:58.756]   - Field: ‘asynchronous’
[10:33:58.756]   - Field: ‘calls’
[10:33:58.756]   - Field: ‘globals’
[10:33:58.756]   - Field: ‘stdout’
[10:33:58.756]   - Field: ‘earlySignal’
[10:33:58.756]   - Field: ‘lazy’
[10:33:58.756]   - Field: ‘state’
[10:33:58.756] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:58.756] - Launch lazy future ...
[10:33:58.756] Packages needed by the future expression (n = 0): <none>
[10:33:58.757] Packages needed by future strategies (n = 0): <none>
[10:33:58.757] {
[10:33:58.757]     {
[10:33:58.757]         {
[10:33:58.757]             ...future.startTime <- base::Sys.time()
[10:33:58.757]             {
[10:33:58.757]                 {
[10:33:58.757]                   {
[10:33:58.757]                     base::local({
[10:33:58.757]                       has_future <- base::requireNamespace("future", 
[10:33:58.757]                         quietly = TRUE)
[10:33:58.757]                       if (has_future) {
[10:33:58.757]                         ns <- base::getNamespace("future")
[10:33:58.757]                         version <- ns[[".package"]][["version"]]
[10:33:58.757]                         if (is.null(version)) 
[10:33:58.757]                           version <- utils::packageVersion("future")
[10:33:58.757]                       }
[10:33:58.757]                       else {
[10:33:58.757]                         version <- NULL
[10:33:58.757]                       }
[10:33:58.757]                       if (!has_future || version < "1.8.0") {
[10:33:58.757]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:58.757]                           "", base::R.version$version.string), 
[10:33:58.757]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:58.757]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:58.757]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:58.757]                             "release", "version")], collapse = " "), 
[10:33:58.757]                           hostname = base::Sys.info()[["nodename"]])
[10:33:58.757]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:58.757]                           info)
[10:33:58.757]                         info <- base::paste(info, collapse = "; ")
[10:33:58.757]                         if (!has_future) {
[10:33:58.757]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:58.757]                             info)
[10:33:58.757]                         }
[10:33:58.757]                         else {
[10:33:58.757]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:58.757]                             info, version)
[10:33:58.757]                         }
[10:33:58.757]                         base::stop(msg)
[10:33:58.757]                       }
[10:33:58.757]                     })
[10:33:58.757]                   }
[10:33:58.757]                   ...future.strategy.old <- future::plan("list")
[10:33:58.757]                   options(future.plan = NULL)
[10:33:58.757]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.757]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:58.757]                 }
[10:33:58.757]                 ...future.workdir <- getwd()
[10:33:58.757]             }
[10:33:58.757]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:58.757]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:58.757]         }
[10:33:58.757]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:58.757]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:58.757]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:58.757]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:58.757]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:58.757]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:58.757]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:58.757]             base::names(...future.oldOptions))
[10:33:58.757]     }
[10:33:58.757]     if (FALSE) {
[10:33:58.757]     }
[10:33:58.757]     else {
[10:33:58.757]         if (TRUE) {
[10:33:58.757]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:58.757]                 open = "w")
[10:33:58.757]         }
[10:33:58.757]         else {
[10:33:58.757]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:58.757]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:58.757]         }
[10:33:58.757]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:58.757]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:58.757]             base::sink(type = "output", split = FALSE)
[10:33:58.757]             base::close(...future.stdout)
[10:33:58.757]         }, add = TRUE)
[10:33:58.757]     }
[10:33:58.757]     ...future.frame <- base::sys.nframe()
[10:33:58.757]     ...future.conditions <- base::list()
[10:33:58.757]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:58.757]     if (FALSE) {
[10:33:58.757]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:58.757]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:58.757]     }
[10:33:58.757]     ...future.result <- base::tryCatch({
[10:33:58.757]         base::withCallingHandlers({
[10:33:58.757]             ...future.value <- base::withVisible(base::local(2))
[10:33:58.757]             future::FutureResult(value = ...future.value$value, 
[10:33:58.757]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.757]                   ...future.rng), globalenv = if (FALSE) 
[10:33:58.757]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:58.757]                     ...future.globalenv.names))
[10:33:58.757]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:58.757]         }, condition = base::local({
[10:33:58.757]             c <- base::c
[10:33:58.757]             inherits <- base::inherits
[10:33:58.757]             invokeRestart <- base::invokeRestart
[10:33:58.757]             length <- base::length
[10:33:58.757]             list <- base::list
[10:33:58.757]             seq.int <- base::seq.int
[10:33:58.757]             signalCondition <- base::signalCondition
[10:33:58.757]             sys.calls <- base::sys.calls
[10:33:58.757]             `[[` <- base::`[[`
[10:33:58.757]             `+` <- base::`+`
[10:33:58.757]             `<<-` <- base::`<<-`
[10:33:58.757]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:58.757]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:58.757]                   3L)]
[10:33:58.757]             }
[10:33:58.757]             function(cond) {
[10:33:58.757]                 is_error <- inherits(cond, "error")
[10:33:58.757]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:58.757]                   NULL)
[10:33:58.757]                 if (is_error) {
[10:33:58.757]                   sessionInformation <- function() {
[10:33:58.757]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:58.757]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:58.757]                       search = base::search(), system = base::Sys.info())
[10:33:58.757]                   }
[10:33:58.757]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.757]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:58.757]                     cond$call), session = sessionInformation(), 
[10:33:58.757]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:58.757]                   signalCondition(cond)
[10:33:58.757]                 }
[10:33:58.757]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:58.757]                 "immediateCondition"))) {
[10:33:58.757]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:58.757]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.757]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:58.757]                   if (TRUE && !signal) {
[10:33:58.757]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.757]                     {
[10:33:58.757]                       inherits <- base::inherits
[10:33:58.757]                       invokeRestart <- base::invokeRestart
[10:33:58.757]                       is.null <- base::is.null
[10:33:58.757]                       muffled <- FALSE
[10:33:58.757]                       if (inherits(cond, "message")) {
[10:33:58.757]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.757]                         if (muffled) 
[10:33:58.757]                           invokeRestart("muffleMessage")
[10:33:58.757]                       }
[10:33:58.757]                       else if (inherits(cond, "warning")) {
[10:33:58.757]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.757]                         if (muffled) 
[10:33:58.757]                           invokeRestart("muffleWarning")
[10:33:58.757]                       }
[10:33:58.757]                       else if (inherits(cond, "condition")) {
[10:33:58.757]                         if (!is.null(pattern)) {
[10:33:58.757]                           computeRestarts <- base::computeRestarts
[10:33:58.757]                           grepl <- base::grepl
[10:33:58.757]                           restarts <- computeRestarts(cond)
[10:33:58.757]                           for (restart in restarts) {
[10:33:58.757]                             name <- restart$name
[10:33:58.757]                             if (is.null(name)) 
[10:33:58.757]                               next
[10:33:58.757]                             if (!grepl(pattern, name)) 
[10:33:58.757]                               next
[10:33:58.757]                             invokeRestart(restart)
[10:33:58.757]                             muffled <- TRUE
[10:33:58.757]                             break
[10:33:58.757]                           }
[10:33:58.757]                         }
[10:33:58.757]                       }
[10:33:58.757]                       invisible(muffled)
[10:33:58.757]                     }
[10:33:58.757]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.757]                   }
[10:33:58.757]                 }
[10:33:58.757]                 else {
[10:33:58.757]                   if (TRUE) {
[10:33:58.757]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.757]                     {
[10:33:58.757]                       inherits <- base::inherits
[10:33:58.757]                       invokeRestart <- base::invokeRestart
[10:33:58.757]                       is.null <- base::is.null
[10:33:58.757]                       muffled <- FALSE
[10:33:58.757]                       if (inherits(cond, "message")) {
[10:33:58.757]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.757]                         if (muffled) 
[10:33:58.757]                           invokeRestart("muffleMessage")
[10:33:58.757]                       }
[10:33:58.757]                       else if (inherits(cond, "warning")) {
[10:33:58.757]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.757]                         if (muffled) 
[10:33:58.757]                           invokeRestart("muffleWarning")
[10:33:58.757]                       }
[10:33:58.757]                       else if (inherits(cond, "condition")) {
[10:33:58.757]                         if (!is.null(pattern)) {
[10:33:58.757]                           computeRestarts <- base::computeRestarts
[10:33:58.757]                           grepl <- base::grepl
[10:33:58.757]                           restarts <- computeRestarts(cond)
[10:33:58.757]                           for (restart in restarts) {
[10:33:58.757]                             name <- restart$name
[10:33:58.757]                             if (is.null(name)) 
[10:33:58.757]                               next
[10:33:58.757]                             if (!grepl(pattern, name)) 
[10:33:58.757]                               next
[10:33:58.757]                             invokeRestart(restart)
[10:33:58.757]                             muffled <- TRUE
[10:33:58.757]                             break
[10:33:58.757]                           }
[10:33:58.757]                         }
[10:33:58.757]                       }
[10:33:58.757]                       invisible(muffled)
[10:33:58.757]                     }
[10:33:58.757]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.757]                   }
[10:33:58.757]                 }
[10:33:58.757]             }
[10:33:58.757]         }))
[10:33:58.757]     }, error = function(ex) {
[10:33:58.757]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:58.757]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.757]                 ...future.rng), started = ...future.startTime, 
[10:33:58.757]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:58.757]             version = "1.8"), class = "FutureResult")
[10:33:58.757]     }, finally = {
[10:33:58.757]         if (!identical(...future.workdir, getwd())) 
[10:33:58.757]             setwd(...future.workdir)
[10:33:58.757]         {
[10:33:58.757]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:58.757]                 ...future.oldOptions$nwarnings <- NULL
[10:33:58.757]             }
[10:33:58.757]             base::options(...future.oldOptions)
[10:33:58.757]             if (.Platform$OS.type == "windows") {
[10:33:58.757]                 old_names <- names(...future.oldEnvVars)
[10:33:58.757]                 envs <- base::Sys.getenv()
[10:33:58.757]                 names <- names(envs)
[10:33:58.757]                 common <- intersect(names, old_names)
[10:33:58.757]                 added <- setdiff(names, old_names)
[10:33:58.757]                 removed <- setdiff(old_names, names)
[10:33:58.757]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:58.757]                   envs[common]]
[10:33:58.757]                 NAMES <- toupper(changed)
[10:33:58.757]                 args <- list()
[10:33:58.757]                 for (kk in seq_along(NAMES)) {
[10:33:58.757]                   name <- changed[[kk]]
[10:33:58.757]                   NAME <- NAMES[[kk]]
[10:33:58.757]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.757]                     next
[10:33:58.757]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.757]                 }
[10:33:58.757]                 NAMES <- toupper(added)
[10:33:58.757]                 for (kk in seq_along(NAMES)) {
[10:33:58.757]                   name <- added[[kk]]
[10:33:58.757]                   NAME <- NAMES[[kk]]
[10:33:58.757]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.757]                     next
[10:33:58.757]                   args[[name]] <- ""
[10:33:58.757]                 }
[10:33:58.757]                 NAMES <- toupper(removed)
[10:33:58.757]                 for (kk in seq_along(NAMES)) {
[10:33:58.757]                   name <- removed[[kk]]
[10:33:58.757]                   NAME <- NAMES[[kk]]
[10:33:58.757]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.757]                     next
[10:33:58.757]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.757]                 }
[10:33:58.757]                 if (length(args) > 0) 
[10:33:58.757]                   base::do.call(base::Sys.setenv, args = args)
[10:33:58.757]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:58.757]             }
[10:33:58.757]             else {
[10:33:58.757]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:58.757]             }
[10:33:58.757]             {
[10:33:58.757]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:58.757]                   0L) {
[10:33:58.757]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:58.757]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:58.757]                   base::options(opts)
[10:33:58.757]                 }
[10:33:58.757]                 {
[10:33:58.757]                   {
[10:33:58.757]                     NULL
[10:33:58.757]                     RNGkind("Mersenne-Twister")
[10:33:58.757]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:58.757]                       inherits = FALSE)
[10:33:58.757]                   }
[10:33:58.757]                   options(future.plan = NULL)
[10:33:58.757]                   if (is.na(NA_character_)) 
[10:33:58.757]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.757]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:58.757]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:58.757]                     .init = FALSE)
[10:33:58.757]                 }
[10:33:58.757]             }
[10:33:58.757]         }
[10:33:58.757]     })
[10:33:58.757]     if (TRUE) {
[10:33:58.757]         base::sink(type = "output", split = FALSE)
[10:33:58.757]         if (TRUE) {
[10:33:58.757]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:58.757]         }
[10:33:58.757]         else {
[10:33:58.757]             ...future.result["stdout"] <- base::list(NULL)
[10:33:58.757]         }
[10:33:58.757]         base::close(...future.stdout)
[10:33:58.757]         ...future.stdout <- NULL
[10:33:58.757]     }
[10:33:58.757]     ...future.result$conditions <- ...future.conditions
[10:33:58.757]     ...future.result$finished <- base::Sys.time()
[10:33:58.757]     ...future.result
[10:33:58.757] }
[10:33:58.759] plan(): Setting new future strategy stack:
[10:33:58.759] List of future strategies:
[10:33:58.759] 1. sequential:
[10:33:58.759]    - args: function (..., envir = parent.frame())
[10:33:58.759]    - tweaked: FALSE
[10:33:58.759]    - call: NULL
[10:33:58.759] plan(): nbrOfWorkers() = 1
[10:33:58.760] plan(): Setting new future strategy stack:
[10:33:58.760] List of future strategies:
[10:33:58.760] 1. sequential:
[10:33:58.760]    - args: function (..., envir = parent.frame())
[10:33:58.760]    - tweaked: FALSE
[10:33:58.760]    - call: plan(strategy)
[10:33:58.760] plan(): nbrOfWorkers() = 1
[10:33:58.760] SequentialFuture started (and completed)
[10:33:58.761] - Launch lazy future ... done
[10:33:58.761] run() for ‘SequentialFuture’ ... done
[10:33:58.761] resolve() on environment ...
[10:33:58.761]  recursive: 0
[10:33:58.762]  elements: [3] ‘a’, ‘b’, ‘c’
[10:33:58.762] resolved() for ‘SequentialFuture’ ...
[10:33:58.762] - state: ‘finished’
[10:33:58.762] - run: TRUE
[10:33:58.762] - result: ‘FutureResult’
[10:33:58.762] resolved() for ‘SequentialFuture’ ... done
[10:33:58.762] Future #1
[10:33:58.762]  length: 2 (resolved future 1)
[10:33:58.762] resolved() for ‘SequentialFuture’ ...
[10:33:58.763] - state: ‘finished’
[10:33:58.763] - run: TRUE
[10:33:58.763] - result: ‘FutureResult’
[10:33:58.763] resolved() for ‘SequentialFuture’ ... done
[10:33:58.763] Future #2
[10:33:58.763]  length: 1 (resolved future 2)
[10:33:58.763]  length: 0 (resolved future 3)
[10:33:58.763] resolve() on environment ... DONE
[10:33:58.763] resolved() for ‘SequentialFuture’ ...
[10:33:58.763] - state: ‘finished’
[10:33:58.763] - run: TRUE
[10:33:58.764] - result: ‘FutureResult’
[10:33:58.764] resolved() for ‘SequentialFuture’ ... done
[10:33:58.764] resolved() for ‘SequentialFuture’ ...
[10:33:58.764] - state: ‘finished’
[10:33:58.764] - run: TRUE
[10:33:58.764] - result: ‘FutureResult’
[10:33:58.764] resolved() for ‘SequentialFuture’ ... done
[10:33:58.766] getGlobalsAndPackages() ...
[10:33:58.767] Searching for globals...
[10:33:58.767] - globals found: [1] ‘{’
[10:33:58.767] Searching for globals ... DONE
[10:33:58.767] Resolving globals: FALSE
[10:33:58.768] 
[10:33:58.768] 
[10:33:58.768] getGlobalsAndPackages() ... DONE
[10:33:58.768] run() for ‘Future’ ...
[10:33:58.768] - state: ‘created’
[10:33:58.768] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:58.769] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:58.769] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:58.769]   - Field: ‘label’
[10:33:58.769]   - Field: ‘local’
[10:33:58.769]   - Field: ‘owner’
[10:33:58.769]   - Field: ‘envir’
[10:33:58.769]   - Field: ‘packages’
[10:33:58.769]   - Field: ‘gc’
[10:33:58.769]   - Field: ‘conditions’
[10:33:58.769]   - Field: ‘expr’
[10:33:58.769]   - Field: ‘uuid’
[10:33:58.770]   - Field: ‘seed’
[10:33:58.770]   - Field: ‘version’
[10:33:58.770]   - Field: ‘result’
[10:33:58.770]   - Field: ‘asynchronous’
[10:33:58.770]   - Field: ‘calls’
[10:33:58.770]   - Field: ‘globals’
[10:33:58.770]   - Field: ‘stdout’
[10:33:58.770]   - Field: ‘earlySignal’
[10:33:58.770]   - Field: ‘lazy’
[10:33:58.770]   - Field: ‘state’
[10:33:58.770] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:58.771] - Launch lazy future ...
[10:33:58.771] Packages needed by the future expression (n = 0): <none>
[10:33:58.771] Packages needed by future strategies (n = 0): <none>
[10:33:58.771] {
[10:33:58.771]     {
[10:33:58.771]         {
[10:33:58.771]             ...future.startTime <- base::Sys.time()
[10:33:58.771]             {
[10:33:58.771]                 {
[10:33:58.771]                   {
[10:33:58.771]                     base::local({
[10:33:58.771]                       has_future <- base::requireNamespace("future", 
[10:33:58.771]                         quietly = TRUE)
[10:33:58.771]                       if (has_future) {
[10:33:58.771]                         ns <- base::getNamespace("future")
[10:33:58.771]                         version <- ns[[".package"]][["version"]]
[10:33:58.771]                         if (is.null(version)) 
[10:33:58.771]                           version <- utils::packageVersion("future")
[10:33:58.771]                       }
[10:33:58.771]                       else {
[10:33:58.771]                         version <- NULL
[10:33:58.771]                       }
[10:33:58.771]                       if (!has_future || version < "1.8.0") {
[10:33:58.771]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:58.771]                           "", base::R.version$version.string), 
[10:33:58.771]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:58.771]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:58.771]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:58.771]                             "release", "version")], collapse = " "), 
[10:33:58.771]                           hostname = base::Sys.info()[["nodename"]])
[10:33:58.771]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:58.771]                           info)
[10:33:58.771]                         info <- base::paste(info, collapse = "; ")
[10:33:58.771]                         if (!has_future) {
[10:33:58.771]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:58.771]                             info)
[10:33:58.771]                         }
[10:33:58.771]                         else {
[10:33:58.771]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:58.771]                             info, version)
[10:33:58.771]                         }
[10:33:58.771]                         base::stop(msg)
[10:33:58.771]                       }
[10:33:58.771]                     })
[10:33:58.771]                   }
[10:33:58.771]                   ...future.strategy.old <- future::plan("list")
[10:33:58.771]                   options(future.plan = NULL)
[10:33:58.771]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.771]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:58.771]                 }
[10:33:58.771]                 ...future.workdir <- getwd()
[10:33:58.771]             }
[10:33:58.771]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:58.771]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:58.771]         }
[10:33:58.771]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:58.771]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:58.771]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:58.771]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:58.771]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:58.771]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:58.771]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:58.771]             base::names(...future.oldOptions))
[10:33:58.771]     }
[10:33:58.771]     if (FALSE) {
[10:33:58.771]     }
[10:33:58.771]     else {
[10:33:58.771]         if (TRUE) {
[10:33:58.771]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:58.771]                 open = "w")
[10:33:58.771]         }
[10:33:58.771]         else {
[10:33:58.771]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:58.771]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:58.771]         }
[10:33:58.771]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:58.771]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:58.771]             base::sink(type = "output", split = FALSE)
[10:33:58.771]             base::close(...future.stdout)
[10:33:58.771]         }, add = TRUE)
[10:33:58.771]     }
[10:33:58.771]     ...future.frame <- base::sys.nframe()
[10:33:58.771]     ...future.conditions <- base::list()
[10:33:58.771]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:58.771]     if (FALSE) {
[10:33:58.771]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:58.771]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:58.771]     }
[10:33:58.771]     ...future.result <- base::tryCatch({
[10:33:58.771]         base::withCallingHandlers({
[10:33:58.771]             ...future.value <- base::withVisible(base::local({
[10:33:58.771]                 1
[10:33:58.771]             }))
[10:33:58.771]             future::FutureResult(value = ...future.value$value, 
[10:33:58.771]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.771]                   ...future.rng), globalenv = if (FALSE) 
[10:33:58.771]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:58.771]                     ...future.globalenv.names))
[10:33:58.771]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:58.771]         }, condition = base::local({
[10:33:58.771]             c <- base::c
[10:33:58.771]             inherits <- base::inherits
[10:33:58.771]             invokeRestart <- base::invokeRestart
[10:33:58.771]             length <- base::length
[10:33:58.771]             list <- base::list
[10:33:58.771]             seq.int <- base::seq.int
[10:33:58.771]             signalCondition <- base::signalCondition
[10:33:58.771]             sys.calls <- base::sys.calls
[10:33:58.771]             `[[` <- base::`[[`
[10:33:58.771]             `+` <- base::`+`
[10:33:58.771]             `<<-` <- base::`<<-`
[10:33:58.771]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:58.771]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:58.771]                   3L)]
[10:33:58.771]             }
[10:33:58.771]             function(cond) {
[10:33:58.771]                 is_error <- inherits(cond, "error")
[10:33:58.771]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:58.771]                   NULL)
[10:33:58.771]                 if (is_error) {
[10:33:58.771]                   sessionInformation <- function() {
[10:33:58.771]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:58.771]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:58.771]                       search = base::search(), system = base::Sys.info())
[10:33:58.771]                   }
[10:33:58.771]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.771]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:58.771]                     cond$call), session = sessionInformation(), 
[10:33:58.771]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:58.771]                   signalCondition(cond)
[10:33:58.771]                 }
[10:33:58.771]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:58.771]                 "immediateCondition"))) {
[10:33:58.771]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:58.771]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.771]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:58.771]                   if (TRUE && !signal) {
[10:33:58.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.771]                     {
[10:33:58.771]                       inherits <- base::inherits
[10:33:58.771]                       invokeRestart <- base::invokeRestart
[10:33:58.771]                       is.null <- base::is.null
[10:33:58.771]                       muffled <- FALSE
[10:33:58.771]                       if (inherits(cond, "message")) {
[10:33:58.771]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.771]                         if (muffled) 
[10:33:58.771]                           invokeRestart("muffleMessage")
[10:33:58.771]                       }
[10:33:58.771]                       else if (inherits(cond, "warning")) {
[10:33:58.771]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.771]                         if (muffled) 
[10:33:58.771]                           invokeRestart("muffleWarning")
[10:33:58.771]                       }
[10:33:58.771]                       else if (inherits(cond, "condition")) {
[10:33:58.771]                         if (!is.null(pattern)) {
[10:33:58.771]                           computeRestarts <- base::computeRestarts
[10:33:58.771]                           grepl <- base::grepl
[10:33:58.771]                           restarts <- computeRestarts(cond)
[10:33:58.771]                           for (restart in restarts) {
[10:33:58.771]                             name <- restart$name
[10:33:58.771]                             if (is.null(name)) 
[10:33:58.771]                               next
[10:33:58.771]                             if (!grepl(pattern, name)) 
[10:33:58.771]                               next
[10:33:58.771]                             invokeRestart(restart)
[10:33:58.771]                             muffled <- TRUE
[10:33:58.771]                             break
[10:33:58.771]                           }
[10:33:58.771]                         }
[10:33:58.771]                       }
[10:33:58.771]                       invisible(muffled)
[10:33:58.771]                     }
[10:33:58.771]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.771]                   }
[10:33:58.771]                 }
[10:33:58.771]                 else {
[10:33:58.771]                   if (TRUE) {
[10:33:58.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.771]                     {
[10:33:58.771]                       inherits <- base::inherits
[10:33:58.771]                       invokeRestart <- base::invokeRestart
[10:33:58.771]                       is.null <- base::is.null
[10:33:58.771]                       muffled <- FALSE
[10:33:58.771]                       if (inherits(cond, "message")) {
[10:33:58.771]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.771]                         if (muffled) 
[10:33:58.771]                           invokeRestart("muffleMessage")
[10:33:58.771]                       }
[10:33:58.771]                       else if (inherits(cond, "warning")) {
[10:33:58.771]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.771]                         if (muffled) 
[10:33:58.771]                           invokeRestart("muffleWarning")
[10:33:58.771]                       }
[10:33:58.771]                       else if (inherits(cond, "condition")) {
[10:33:58.771]                         if (!is.null(pattern)) {
[10:33:58.771]                           computeRestarts <- base::computeRestarts
[10:33:58.771]                           grepl <- base::grepl
[10:33:58.771]                           restarts <- computeRestarts(cond)
[10:33:58.771]                           for (restart in restarts) {
[10:33:58.771]                             name <- restart$name
[10:33:58.771]                             if (is.null(name)) 
[10:33:58.771]                               next
[10:33:58.771]                             if (!grepl(pattern, name)) 
[10:33:58.771]                               next
[10:33:58.771]                             invokeRestart(restart)
[10:33:58.771]                             muffled <- TRUE
[10:33:58.771]                             break
[10:33:58.771]                           }
[10:33:58.771]                         }
[10:33:58.771]                       }
[10:33:58.771]                       invisible(muffled)
[10:33:58.771]                     }
[10:33:58.771]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.771]                   }
[10:33:58.771]                 }
[10:33:58.771]             }
[10:33:58.771]         }))
[10:33:58.771]     }, error = function(ex) {
[10:33:58.771]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:58.771]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.771]                 ...future.rng), started = ...future.startTime, 
[10:33:58.771]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:58.771]             version = "1.8"), class = "FutureResult")
[10:33:58.771]     }, finally = {
[10:33:58.771]         if (!identical(...future.workdir, getwd())) 
[10:33:58.771]             setwd(...future.workdir)
[10:33:58.771]         {
[10:33:58.771]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:58.771]                 ...future.oldOptions$nwarnings <- NULL
[10:33:58.771]             }
[10:33:58.771]             base::options(...future.oldOptions)
[10:33:58.771]             if (.Platform$OS.type == "windows") {
[10:33:58.771]                 old_names <- names(...future.oldEnvVars)
[10:33:58.771]                 envs <- base::Sys.getenv()
[10:33:58.771]                 names <- names(envs)
[10:33:58.771]                 common <- intersect(names, old_names)
[10:33:58.771]                 added <- setdiff(names, old_names)
[10:33:58.771]                 removed <- setdiff(old_names, names)
[10:33:58.771]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:58.771]                   envs[common]]
[10:33:58.771]                 NAMES <- toupper(changed)
[10:33:58.771]                 args <- list()
[10:33:58.771]                 for (kk in seq_along(NAMES)) {
[10:33:58.771]                   name <- changed[[kk]]
[10:33:58.771]                   NAME <- NAMES[[kk]]
[10:33:58.771]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.771]                     next
[10:33:58.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.771]                 }
[10:33:58.771]                 NAMES <- toupper(added)
[10:33:58.771]                 for (kk in seq_along(NAMES)) {
[10:33:58.771]                   name <- added[[kk]]
[10:33:58.771]                   NAME <- NAMES[[kk]]
[10:33:58.771]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.771]                     next
[10:33:58.771]                   args[[name]] <- ""
[10:33:58.771]                 }
[10:33:58.771]                 NAMES <- toupper(removed)
[10:33:58.771]                 for (kk in seq_along(NAMES)) {
[10:33:58.771]                   name <- removed[[kk]]
[10:33:58.771]                   NAME <- NAMES[[kk]]
[10:33:58.771]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.771]                     next
[10:33:58.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.771]                 }
[10:33:58.771]                 if (length(args) > 0) 
[10:33:58.771]                   base::do.call(base::Sys.setenv, args = args)
[10:33:58.771]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:58.771]             }
[10:33:58.771]             else {
[10:33:58.771]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:58.771]             }
[10:33:58.771]             {
[10:33:58.771]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:58.771]                   0L) {
[10:33:58.771]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:58.771]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:58.771]                   base::options(opts)
[10:33:58.771]                 }
[10:33:58.771]                 {
[10:33:58.771]                   {
[10:33:58.771]                     NULL
[10:33:58.771]                     RNGkind("Mersenne-Twister")
[10:33:58.771]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:58.771]                       inherits = FALSE)
[10:33:58.771]                   }
[10:33:58.771]                   options(future.plan = NULL)
[10:33:58.771]                   if (is.na(NA_character_)) 
[10:33:58.771]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.771]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:58.771]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:58.771]                     .init = FALSE)
[10:33:58.771]                 }
[10:33:58.771]             }
[10:33:58.771]         }
[10:33:58.771]     })
[10:33:58.771]     if (TRUE) {
[10:33:58.771]         base::sink(type = "output", split = FALSE)
[10:33:58.771]         if (TRUE) {
[10:33:58.771]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:58.771]         }
[10:33:58.771]         else {
[10:33:58.771]             ...future.result["stdout"] <- base::list(NULL)
[10:33:58.771]         }
[10:33:58.771]         base::close(...future.stdout)
[10:33:58.771]         ...future.stdout <- NULL
[10:33:58.771]     }
[10:33:58.771]     ...future.result$conditions <- ...future.conditions
[10:33:58.771]     ...future.result$finished <- base::Sys.time()
[10:33:58.771]     ...future.result
[10:33:58.771] }
[10:33:58.773] plan(): Setting new future strategy stack:
[10:33:58.773] List of future strategies:
[10:33:58.773] 1. sequential:
[10:33:58.773]    - args: function (..., envir = parent.frame())
[10:33:58.773]    - tweaked: FALSE
[10:33:58.773]    - call: NULL
[10:33:58.773] plan(): nbrOfWorkers() = 1
[10:33:58.774] plan(): Setting new future strategy stack:
[10:33:58.774] List of future strategies:
[10:33:58.774] 1. sequential:
[10:33:58.774]    - args: function (..., envir = parent.frame())
[10:33:58.774]    - tweaked: FALSE
[10:33:58.774]    - call: plan(strategy)
[10:33:58.774] plan(): nbrOfWorkers() = 1
[10:33:58.775] SequentialFuture started (and completed)
[10:33:58.775] - Launch lazy future ... done
[10:33:58.775] run() for ‘SequentialFuture’ ... done
[10:33:58.775] getGlobalsAndPackages() ...
[10:33:58.775] Searching for globals...
[10:33:58.776] - globals found: [1] ‘{’
[10:33:58.776] Searching for globals ... DONE
[10:33:58.776] Resolving globals: FALSE
[10:33:58.776] 
[10:33:58.776] 
[10:33:58.776] getGlobalsAndPackages() ... DONE
[10:33:58.776] run() for ‘Future’ ...
[10:33:58.777] - state: ‘created’
[10:33:58.777] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:58.777] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:58.777] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:58.777]   - Field: ‘label’
[10:33:58.777]   - Field: ‘local’
[10:33:58.777]   - Field: ‘owner’
[10:33:58.777]   - Field: ‘envir’
[10:33:58.777]   - Field: ‘packages’
[10:33:58.778]   - Field: ‘gc’
[10:33:58.778]   - Field: ‘conditions’
[10:33:58.778]   - Field: ‘expr’
[10:33:58.778]   - Field: ‘uuid’
[10:33:58.778]   - Field: ‘seed’
[10:33:58.778]   - Field: ‘version’
[10:33:58.778]   - Field: ‘result’
[10:33:58.778]   - Field: ‘asynchronous’
[10:33:58.778]   - Field: ‘calls’
[10:33:58.778]   - Field: ‘globals’
[10:33:58.778]   - Field: ‘stdout’
[10:33:58.779]   - Field: ‘earlySignal’
[10:33:58.779]   - Field: ‘lazy’
[10:33:58.779]   - Field: ‘state’
[10:33:58.779] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:58.779] - Launch lazy future ...
[10:33:58.779] Packages needed by the future expression (n = 0): <none>
[10:33:58.779] Packages needed by future strategies (n = 0): <none>
[10:33:58.780] {
[10:33:58.780]     {
[10:33:58.780]         {
[10:33:58.780]             ...future.startTime <- base::Sys.time()
[10:33:58.780]             {
[10:33:58.780]                 {
[10:33:58.780]                   {
[10:33:58.780]                     base::local({
[10:33:58.780]                       has_future <- base::requireNamespace("future", 
[10:33:58.780]                         quietly = TRUE)
[10:33:58.780]                       if (has_future) {
[10:33:58.780]                         ns <- base::getNamespace("future")
[10:33:58.780]                         version <- ns[[".package"]][["version"]]
[10:33:58.780]                         if (is.null(version)) 
[10:33:58.780]                           version <- utils::packageVersion("future")
[10:33:58.780]                       }
[10:33:58.780]                       else {
[10:33:58.780]                         version <- NULL
[10:33:58.780]                       }
[10:33:58.780]                       if (!has_future || version < "1.8.0") {
[10:33:58.780]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:58.780]                           "", base::R.version$version.string), 
[10:33:58.780]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:58.780]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:58.780]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:58.780]                             "release", "version")], collapse = " "), 
[10:33:58.780]                           hostname = base::Sys.info()[["nodename"]])
[10:33:58.780]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:58.780]                           info)
[10:33:58.780]                         info <- base::paste(info, collapse = "; ")
[10:33:58.780]                         if (!has_future) {
[10:33:58.780]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:58.780]                             info)
[10:33:58.780]                         }
[10:33:58.780]                         else {
[10:33:58.780]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:58.780]                             info, version)
[10:33:58.780]                         }
[10:33:58.780]                         base::stop(msg)
[10:33:58.780]                       }
[10:33:58.780]                     })
[10:33:58.780]                   }
[10:33:58.780]                   ...future.strategy.old <- future::plan("list")
[10:33:58.780]                   options(future.plan = NULL)
[10:33:58.780]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.780]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:58.780]                 }
[10:33:58.780]                 ...future.workdir <- getwd()
[10:33:58.780]             }
[10:33:58.780]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:58.780]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:58.780]         }
[10:33:58.780]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:58.780]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:58.780]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:58.780]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:58.780]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:58.780]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:58.780]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:58.780]             base::names(...future.oldOptions))
[10:33:58.780]     }
[10:33:58.780]     if (FALSE) {
[10:33:58.780]     }
[10:33:58.780]     else {
[10:33:58.780]         if (TRUE) {
[10:33:58.780]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:58.780]                 open = "w")
[10:33:58.780]         }
[10:33:58.780]         else {
[10:33:58.780]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:58.780]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:58.780]         }
[10:33:58.780]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:58.780]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:58.780]             base::sink(type = "output", split = FALSE)
[10:33:58.780]             base::close(...future.stdout)
[10:33:58.780]         }, add = TRUE)
[10:33:58.780]     }
[10:33:58.780]     ...future.frame <- base::sys.nframe()
[10:33:58.780]     ...future.conditions <- base::list()
[10:33:58.780]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:58.780]     if (FALSE) {
[10:33:58.780]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:58.780]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:58.780]     }
[10:33:58.780]     ...future.result <- base::tryCatch({
[10:33:58.780]         base::withCallingHandlers({
[10:33:58.780]             ...future.value <- base::withVisible(base::local({
[10:33:58.780]                 2
[10:33:58.780]             }))
[10:33:58.780]             future::FutureResult(value = ...future.value$value, 
[10:33:58.780]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.780]                   ...future.rng), globalenv = if (FALSE) 
[10:33:58.780]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:58.780]                     ...future.globalenv.names))
[10:33:58.780]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:58.780]         }, condition = base::local({
[10:33:58.780]             c <- base::c
[10:33:58.780]             inherits <- base::inherits
[10:33:58.780]             invokeRestart <- base::invokeRestart
[10:33:58.780]             length <- base::length
[10:33:58.780]             list <- base::list
[10:33:58.780]             seq.int <- base::seq.int
[10:33:58.780]             signalCondition <- base::signalCondition
[10:33:58.780]             sys.calls <- base::sys.calls
[10:33:58.780]             `[[` <- base::`[[`
[10:33:58.780]             `+` <- base::`+`
[10:33:58.780]             `<<-` <- base::`<<-`
[10:33:58.780]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:58.780]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:58.780]                   3L)]
[10:33:58.780]             }
[10:33:58.780]             function(cond) {
[10:33:58.780]                 is_error <- inherits(cond, "error")
[10:33:58.780]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:58.780]                   NULL)
[10:33:58.780]                 if (is_error) {
[10:33:58.780]                   sessionInformation <- function() {
[10:33:58.780]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:58.780]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:58.780]                       search = base::search(), system = base::Sys.info())
[10:33:58.780]                   }
[10:33:58.780]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.780]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:58.780]                     cond$call), session = sessionInformation(), 
[10:33:58.780]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:58.780]                   signalCondition(cond)
[10:33:58.780]                 }
[10:33:58.780]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:58.780]                 "immediateCondition"))) {
[10:33:58.780]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:58.780]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.780]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:58.780]                   if (TRUE && !signal) {
[10:33:58.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.780]                     {
[10:33:58.780]                       inherits <- base::inherits
[10:33:58.780]                       invokeRestart <- base::invokeRestart
[10:33:58.780]                       is.null <- base::is.null
[10:33:58.780]                       muffled <- FALSE
[10:33:58.780]                       if (inherits(cond, "message")) {
[10:33:58.780]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.780]                         if (muffled) 
[10:33:58.780]                           invokeRestart("muffleMessage")
[10:33:58.780]                       }
[10:33:58.780]                       else if (inherits(cond, "warning")) {
[10:33:58.780]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.780]                         if (muffled) 
[10:33:58.780]                           invokeRestart("muffleWarning")
[10:33:58.780]                       }
[10:33:58.780]                       else if (inherits(cond, "condition")) {
[10:33:58.780]                         if (!is.null(pattern)) {
[10:33:58.780]                           computeRestarts <- base::computeRestarts
[10:33:58.780]                           grepl <- base::grepl
[10:33:58.780]                           restarts <- computeRestarts(cond)
[10:33:58.780]                           for (restart in restarts) {
[10:33:58.780]                             name <- restart$name
[10:33:58.780]                             if (is.null(name)) 
[10:33:58.780]                               next
[10:33:58.780]                             if (!grepl(pattern, name)) 
[10:33:58.780]                               next
[10:33:58.780]                             invokeRestart(restart)
[10:33:58.780]                             muffled <- TRUE
[10:33:58.780]                             break
[10:33:58.780]                           }
[10:33:58.780]                         }
[10:33:58.780]                       }
[10:33:58.780]                       invisible(muffled)
[10:33:58.780]                     }
[10:33:58.780]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.780]                   }
[10:33:58.780]                 }
[10:33:58.780]                 else {
[10:33:58.780]                   if (TRUE) {
[10:33:58.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.780]                     {
[10:33:58.780]                       inherits <- base::inherits
[10:33:58.780]                       invokeRestart <- base::invokeRestart
[10:33:58.780]                       is.null <- base::is.null
[10:33:58.780]                       muffled <- FALSE
[10:33:58.780]                       if (inherits(cond, "message")) {
[10:33:58.780]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.780]                         if (muffled) 
[10:33:58.780]                           invokeRestart("muffleMessage")
[10:33:58.780]                       }
[10:33:58.780]                       else if (inherits(cond, "warning")) {
[10:33:58.780]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.780]                         if (muffled) 
[10:33:58.780]                           invokeRestart("muffleWarning")
[10:33:58.780]                       }
[10:33:58.780]                       else if (inherits(cond, "condition")) {
[10:33:58.780]                         if (!is.null(pattern)) {
[10:33:58.780]                           computeRestarts <- base::computeRestarts
[10:33:58.780]                           grepl <- base::grepl
[10:33:58.780]                           restarts <- computeRestarts(cond)
[10:33:58.780]                           for (restart in restarts) {
[10:33:58.780]                             name <- restart$name
[10:33:58.780]                             if (is.null(name)) 
[10:33:58.780]                               next
[10:33:58.780]                             if (!grepl(pattern, name)) 
[10:33:58.780]                               next
[10:33:58.780]                             invokeRestart(restart)
[10:33:58.780]                             muffled <- TRUE
[10:33:58.780]                             break
[10:33:58.780]                           }
[10:33:58.780]                         }
[10:33:58.780]                       }
[10:33:58.780]                       invisible(muffled)
[10:33:58.780]                     }
[10:33:58.780]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.780]                   }
[10:33:58.780]                 }
[10:33:58.780]             }
[10:33:58.780]         }))
[10:33:58.780]     }, error = function(ex) {
[10:33:58.780]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:58.780]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.780]                 ...future.rng), started = ...future.startTime, 
[10:33:58.780]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:58.780]             version = "1.8"), class = "FutureResult")
[10:33:58.780]     }, finally = {
[10:33:58.780]         if (!identical(...future.workdir, getwd())) 
[10:33:58.780]             setwd(...future.workdir)
[10:33:58.780]         {
[10:33:58.780]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:58.780]                 ...future.oldOptions$nwarnings <- NULL
[10:33:58.780]             }
[10:33:58.780]             base::options(...future.oldOptions)
[10:33:58.780]             if (.Platform$OS.type == "windows") {
[10:33:58.780]                 old_names <- names(...future.oldEnvVars)
[10:33:58.780]                 envs <- base::Sys.getenv()
[10:33:58.780]                 names <- names(envs)
[10:33:58.780]                 common <- intersect(names, old_names)
[10:33:58.780]                 added <- setdiff(names, old_names)
[10:33:58.780]                 removed <- setdiff(old_names, names)
[10:33:58.780]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:58.780]                   envs[common]]
[10:33:58.780]                 NAMES <- toupper(changed)
[10:33:58.780]                 args <- list()
[10:33:58.780]                 for (kk in seq_along(NAMES)) {
[10:33:58.780]                   name <- changed[[kk]]
[10:33:58.780]                   NAME <- NAMES[[kk]]
[10:33:58.780]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.780]                     next
[10:33:58.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.780]                 }
[10:33:58.780]                 NAMES <- toupper(added)
[10:33:58.780]                 for (kk in seq_along(NAMES)) {
[10:33:58.780]                   name <- added[[kk]]
[10:33:58.780]                   NAME <- NAMES[[kk]]
[10:33:58.780]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.780]                     next
[10:33:58.780]                   args[[name]] <- ""
[10:33:58.780]                 }
[10:33:58.780]                 NAMES <- toupper(removed)
[10:33:58.780]                 for (kk in seq_along(NAMES)) {
[10:33:58.780]                   name <- removed[[kk]]
[10:33:58.780]                   NAME <- NAMES[[kk]]
[10:33:58.780]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.780]                     next
[10:33:58.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.780]                 }
[10:33:58.780]                 if (length(args) > 0) 
[10:33:58.780]                   base::do.call(base::Sys.setenv, args = args)
[10:33:58.780]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:58.780]             }
[10:33:58.780]             else {
[10:33:58.780]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:58.780]             }
[10:33:58.780]             {
[10:33:58.780]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:58.780]                   0L) {
[10:33:58.780]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:58.780]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:58.780]                   base::options(opts)
[10:33:58.780]                 }
[10:33:58.780]                 {
[10:33:58.780]                   {
[10:33:58.780]                     NULL
[10:33:58.780]                     RNGkind("Mersenne-Twister")
[10:33:58.780]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:58.780]                       inherits = FALSE)
[10:33:58.780]                   }
[10:33:58.780]                   options(future.plan = NULL)
[10:33:58.780]                   if (is.na(NA_character_)) 
[10:33:58.780]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.780]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:58.780]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:58.780]                     .init = FALSE)
[10:33:58.780]                 }
[10:33:58.780]             }
[10:33:58.780]         }
[10:33:58.780]     })
[10:33:58.780]     if (TRUE) {
[10:33:58.780]         base::sink(type = "output", split = FALSE)
[10:33:58.780]         if (TRUE) {
[10:33:58.780]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:58.780]         }
[10:33:58.780]         else {
[10:33:58.780]             ...future.result["stdout"] <- base::list(NULL)
[10:33:58.780]         }
[10:33:58.780]         base::close(...future.stdout)
[10:33:58.780]         ...future.stdout <- NULL
[10:33:58.780]     }
[10:33:58.780]     ...future.result$conditions <- ...future.conditions
[10:33:58.780]     ...future.result$finished <- base::Sys.time()
[10:33:58.780]     ...future.result
[10:33:58.780] }
[10:33:58.781] plan(): Setting new future strategy stack:
[10:33:58.781] List of future strategies:
[10:33:58.781] 1. sequential:
[10:33:58.781]    - args: function (..., envir = parent.frame())
[10:33:58.781]    - tweaked: FALSE
[10:33:58.781]    - call: NULL
[10:33:58.782] plan(): nbrOfWorkers() = 1
[10:33:58.782] plan(): Setting new future strategy stack:
[10:33:58.782] List of future strategies:
[10:33:58.782] 1. sequential:
[10:33:58.782]    - args: function (..., envir = parent.frame())
[10:33:58.782]    - tweaked: FALSE
[10:33:58.782]    - call: plan(strategy)
[10:33:58.783] plan(): nbrOfWorkers() = 1
[10:33:58.783] SequentialFuture started (and completed)
[10:33:58.783] - Launch lazy future ... done
[10:33:58.783] run() for ‘SequentialFuture’ ... done
[10:33:58.784] resolve() on environment ...
[10:33:58.784]  recursive: 0
[10:33:58.784]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[10:33:58.784] resolved() for ‘SequentialFuture’ ...
[10:33:58.784] - state: ‘finished’
[10:33:58.784] - run: TRUE
[10:33:58.784] - result: ‘FutureResult’
[10:33:58.785] resolved() for ‘SequentialFuture’ ... done
[10:33:58.785] Future #1
[10:33:58.785]  length: 2 (resolved future 1)
[10:33:58.785] resolved() for ‘SequentialFuture’ ...
[10:33:58.785] - state: ‘finished’
[10:33:58.785] - run: TRUE
[10:33:58.785] - result: ‘FutureResult’
[10:33:58.785] resolved() for ‘SequentialFuture’ ... done
[10:33:58.785] Future #2
[10:33:58.785]  length: 1 (resolved future 2)
[10:33:58.785]  length: 0 (resolved future 3)
[10:33:58.786] resolve() on environment ... DONE
[10:33:58.786] getGlobalsAndPackages() ...
[10:33:58.786] Searching for globals...
[10:33:58.786] - globals found: [1] ‘{’
[10:33:58.787] Searching for globals ... DONE
[10:33:58.787] Resolving globals: FALSE
[10:33:58.787] 
[10:33:58.787] 
[10:33:58.787] getGlobalsAndPackages() ... DONE
[10:33:58.787] run() for ‘Future’ ...
[10:33:58.787] - state: ‘created’
[10:33:58.788] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:58.788] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:58.788] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:58.788]   - Field: ‘label’
[10:33:58.788]   - Field: ‘local’
[10:33:58.788]   - Field: ‘owner’
[10:33:58.788]   - Field: ‘envir’
[10:33:58.788]   - Field: ‘packages’
[10:33:58.788]   - Field: ‘gc’
[10:33:58.788]   - Field: ‘conditions’
[10:33:58.789]   - Field: ‘expr’
[10:33:58.789]   - Field: ‘uuid’
[10:33:58.789]   - Field: ‘seed’
[10:33:58.789]   - Field: ‘version’
[10:33:58.789]   - Field: ‘result’
[10:33:58.789]   - Field: ‘asynchronous’
[10:33:58.789]   - Field: ‘calls’
[10:33:58.789]   - Field: ‘globals’
[10:33:58.789]   - Field: ‘stdout’
[10:33:58.789]   - Field: ‘earlySignal’
[10:33:58.789]   - Field: ‘lazy’
[10:33:58.790]   - Field: ‘state’
[10:33:58.790] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:58.790] - Launch lazy future ...
[10:33:58.790] Packages needed by the future expression (n = 0): <none>
[10:33:58.790] Packages needed by future strategies (n = 0): <none>
[10:33:58.791] {
[10:33:58.791]     {
[10:33:58.791]         {
[10:33:58.791]             ...future.startTime <- base::Sys.time()
[10:33:58.791]             {
[10:33:58.791]                 {
[10:33:58.791]                   {
[10:33:58.791]                     base::local({
[10:33:58.791]                       has_future <- base::requireNamespace("future", 
[10:33:58.791]                         quietly = TRUE)
[10:33:58.791]                       if (has_future) {
[10:33:58.791]                         ns <- base::getNamespace("future")
[10:33:58.791]                         version <- ns[[".package"]][["version"]]
[10:33:58.791]                         if (is.null(version)) 
[10:33:58.791]                           version <- utils::packageVersion("future")
[10:33:58.791]                       }
[10:33:58.791]                       else {
[10:33:58.791]                         version <- NULL
[10:33:58.791]                       }
[10:33:58.791]                       if (!has_future || version < "1.8.0") {
[10:33:58.791]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:58.791]                           "", base::R.version$version.string), 
[10:33:58.791]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:58.791]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:58.791]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:58.791]                             "release", "version")], collapse = " "), 
[10:33:58.791]                           hostname = base::Sys.info()[["nodename"]])
[10:33:58.791]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:58.791]                           info)
[10:33:58.791]                         info <- base::paste(info, collapse = "; ")
[10:33:58.791]                         if (!has_future) {
[10:33:58.791]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:58.791]                             info)
[10:33:58.791]                         }
[10:33:58.791]                         else {
[10:33:58.791]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:58.791]                             info, version)
[10:33:58.791]                         }
[10:33:58.791]                         base::stop(msg)
[10:33:58.791]                       }
[10:33:58.791]                     })
[10:33:58.791]                   }
[10:33:58.791]                   ...future.strategy.old <- future::plan("list")
[10:33:58.791]                   options(future.plan = NULL)
[10:33:58.791]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.791]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:58.791]                 }
[10:33:58.791]                 ...future.workdir <- getwd()
[10:33:58.791]             }
[10:33:58.791]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:58.791]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:58.791]         }
[10:33:58.791]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:58.791]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:58.791]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:58.791]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:58.791]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:58.791]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:58.791]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:58.791]             base::names(...future.oldOptions))
[10:33:58.791]     }
[10:33:58.791]     if (FALSE) {
[10:33:58.791]     }
[10:33:58.791]     else {
[10:33:58.791]         if (TRUE) {
[10:33:58.791]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:58.791]                 open = "w")
[10:33:58.791]         }
[10:33:58.791]         else {
[10:33:58.791]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:58.791]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:58.791]         }
[10:33:58.791]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:58.791]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:58.791]             base::sink(type = "output", split = FALSE)
[10:33:58.791]             base::close(...future.stdout)
[10:33:58.791]         }, add = TRUE)
[10:33:58.791]     }
[10:33:58.791]     ...future.frame <- base::sys.nframe()
[10:33:58.791]     ...future.conditions <- base::list()
[10:33:58.791]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:58.791]     if (FALSE) {
[10:33:58.791]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:58.791]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:58.791]     }
[10:33:58.791]     ...future.result <- base::tryCatch({
[10:33:58.791]         base::withCallingHandlers({
[10:33:58.791]             ...future.value <- base::withVisible(base::local({
[10:33:58.791]                 1
[10:33:58.791]             }))
[10:33:58.791]             future::FutureResult(value = ...future.value$value, 
[10:33:58.791]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.791]                   ...future.rng), globalenv = if (FALSE) 
[10:33:58.791]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:58.791]                     ...future.globalenv.names))
[10:33:58.791]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:58.791]         }, condition = base::local({
[10:33:58.791]             c <- base::c
[10:33:58.791]             inherits <- base::inherits
[10:33:58.791]             invokeRestart <- base::invokeRestart
[10:33:58.791]             length <- base::length
[10:33:58.791]             list <- base::list
[10:33:58.791]             seq.int <- base::seq.int
[10:33:58.791]             signalCondition <- base::signalCondition
[10:33:58.791]             sys.calls <- base::sys.calls
[10:33:58.791]             `[[` <- base::`[[`
[10:33:58.791]             `+` <- base::`+`
[10:33:58.791]             `<<-` <- base::`<<-`
[10:33:58.791]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:58.791]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:58.791]                   3L)]
[10:33:58.791]             }
[10:33:58.791]             function(cond) {
[10:33:58.791]                 is_error <- inherits(cond, "error")
[10:33:58.791]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:58.791]                   NULL)
[10:33:58.791]                 if (is_error) {
[10:33:58.791]                   sessionInformation <- function() {
[10:33:58.791]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:58.791]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:58.791]                       search = base::search(), system = base::Sys.info())
[10:33:58.791]                   }
[10:33:58.791]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.791]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:58.791]                     cond$call), session = sessionInformation(), 
[10:33:58.791]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:58.791]                   signalCondition(cond)
[10:33:58.791]                 }
[10:33:58.791]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:58.791]                 "immediateCondition"))) {
[10:33:58.791]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:58.791]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.791]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:58.791]                   if (TRUE && !signal) {
[10:33:58.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.791]                     {
[10:33:58.791]                       inherits <- base::inherits
[10:33:58.791]                       invokeRestart <- base::invokeRestart
[10:33:58.791]                       is.null <- base::is.null
[10:33:58.791]                       muffled <- FALSE
[10:33:58.791]                       if (inherits(cond, "message")) {
[10:33:58.791]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.791]                         if (muffled) 
[10:33:58.791]                           invokeRestart("muffleMessage")
[10:33:58.791]                       }
[10:33:58.791]                       else if (inherits(cond, "warning")) {
[10:33:58.791]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.791]                         if (muffled) 
[10:33:58.791]                           invokeRestart("muffleWarning")
[10:33:58.791]                       }
[10:33:58.791]                       else if (inherits(cond, "condition")) {
[10:33:58.791]                         if (!is.null(pattern)) {
[10:33:58.791]                           computeRestarts <- base::computeRestarts
[10:33:58.791]                           grepl <- base::grepl
[10:33:58.791]                           restarts <- computeRestarts(cond)
[10:33:58.791]                           for (restart in restarts) {
[10:33:58.791]                             name <- restart$name
[10:33:58.791]                             if (is.null(name)) 
[10:33:58.791]                               next
[10:33:58.791]                             if (!grepl(pattern, name)) 
[10:33:58.791]                               next
[10:33:58.791]                             invokeRestart(restart)
[10:33:58.791]                             muffled <- TRUE
[10:33:58.791]                             break
[10:33:58.791]                           }
[10:33:58.791]                         }
[10:33:58.791]                       }
[10:33:58.791]                       invisible(muffled)
[10:33:58.791]                     }
[10:33:58.791]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.791]                   }
[10:33:58.791]                 }
[10:33:58.791]                 else {
[10:33:58.791]                   if (TRUE) {
[10:33:58.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.791]                     {
[10:33:58.791]                       inherits <- base::inherits
[10:33:58.791]                       invokeRestart <- base::invokeRestart
[10:33:58.791]                       is.null <- base::is.null
[10:33:58.791]                       muffled <- FALSE
[10:33:58.791]                       if (inherits(cond, "message")) {
[10:33:58.791]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.791]                         if (muffled) 
[10:33:58.791]                           invokeRestart("muffleMessage")
[10:33:58.791]                       }
[10:33:58.791]                       else if (inherits(cond, "warning")) {
[10:33:58.791]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.791]                         if (muffled) 
[10:33:58.791]                           invokeRestart("muffleWarning")
[10:33:58.791]                       }
[10:33:58.791]                       else if (inherits(cond, "condition")) {
[10:33:58.791]                         if (!is.null(pattern)) {
[10:33:58.791]                           computeRestarts <- base::computeRestarts
[10:33:58.791]                           grepl <- base::grepl
[10:33:58.791]                           restarts <- computeRestarts(cond)
[10:33:58.791]                           for (restart in restarts) {
[10:33:58.791]                             name <- restart$name
[10:33:58.791]                             if (is.null(name)) 
[10:33:58.791]                               next
[10:33:58.791]                             if (!grepl(pattern, name)) 
[10:33:58.791]                               next
[10:33:58.791]                             invokeRestart(restart)
[10:33:58.791]                             muffled <- TRUE
[10:33:58.791]                             break
[10:33:58.791]                           }
[10:33:58.791]                         }
[10:33:58.791]                       }
[10:33:58.791]                       invisible(muffled)
[10:33:58.791]                     }
[10:33:58.791]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.791]                   }
[10:33:58.791]                 }
[10:33:58.791]             }
[10:33:58.791]         }))
[10:33:58.791]     }, error = function(ex) {
[10:33:58.791]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:58.791]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.791]                 ...future.rng), started = ...future.startTime, 
[10:33:58.791]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:58.791]             version = "1.8"), class = "FutureResult")
[10:33:58.791]     }, finally = {
[10:33:58.791]         if (!identical(...future.workdir, getwd())) 
[10:33:58.791]             setwd(...future.workdir)
[10:33:58.791]         {
[10:33:58.791]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:58.791]                 ...future.oldOptions$nwarnings <- NULL
[10:33:58.791]             }
[10:33:58.791]             base::options(...future.oldOptions)
[10:33:58.791]             if (.Platform$OS.type == "windows") {
[10:33:58.791]                 old_names <- names(...future.oldEnvVars)
[10:33:58.791]                 envs <- base::Sys.getenv()
[10:33:58.791]                 names <- names(envs)
[10:33:58.791]                 common <- intersect(names, old_names)
[10:33:58.791]                 added <- setdiff(names, old_names)
[10:33:58.791]                 removed <- setdiff(old_names, names)
[10:33:58.791]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:58.791]                   envs[common]]
[10:33:58.791]                 NAMES <- toupper(changed)
[10:33:58.791]                 args <- list()
[10:33:58.791]                 for (kk in seq_along(NAMES)) {
[10:33:58.791]                   name <- changed[[kk]]
[10:33:58.791]                   NAME <- NAMES[[kk]]
[10:33:58.791]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.791]                     next
[10:33:58.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.791]                 }
[10:33:58.791]                 NAMES <- toupper(added)
[10:33:58.791]                 for (kk in seq_along(NAMES)) {
[10:33:58.791]                   name <- added[[kk]]
[10:33:58.791]                   NAME <- NAMES[[kk]]
[10:33:58.791]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.791]                     next
[10:33:58.791]                   args[[name]] <- ""
[10:33:58.791]                 }
[10:33:58.791]                 NAMES <- toupper(removed)
[10:33:58.791]                 for (kk in seq_along(NAMES)) {
[10:33:58.791]                   name <- removed[[kk]]
[10:33:58.791]                   NAME <- NAMES[[kk]]
[10:33:58.791]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.791]                     next
[10:33:58.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.791]                 }
[10:33:58.791]                 if (length(args) > 0) 
[10:33:58.791]                   base::do.call(base::Sys.setenv, args = args)
[10:33:58.791]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:58.791]             }
[10:33:58.791]             else {
[10:33:58.791]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:58.791]             }
[10:33:58.791]             {
[10:33:58.791]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:58.791]                   0L) {
[10:33:58.791]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:58.791]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:58.791]                   base::options(opts)
[10:33:58.791]                 }
[10:33:58.791]                 {
[10:33:58.791]                   {
[10:33:58.791]                     NULL
[10:33:58.791]                     RNGkind("Mersenne-Twister")
[10:33:58.791]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:58.791]                       inherits = FALSE)
[10:33:58.791]                   }
[10:33:58.791]                   options(future.plan = NULL)
[10:33:58.791]                   if (is.na(NA_character_)) 
[10:33:58.791]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.791]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:58.791]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:58.791]                     .init = FALSE)
[10:33:58.791]                 }
[10:33:58.791]             }
[10:33:58.791]         }
[10:33:58.791]     })
[10:33:58.791]     if (TRUE) {
[10:33:58.791]         base::sink(type = "output", split = FALSE)
[10:33:58.791]         if (TRUE) {
[10:33:58.791]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:58.791]         }
[10:33:58.791]         else {
[10:33:58.791]             ...future.result["stdout"] <- base::list(NULL)
[10:33:58.791]         }
[10:33:58.791]         base::close(...future.stdout)
[10:33:58.791]         ...future.stdout <- NULL
[10:33:58.791]     }
[10:33:58.791]     ...future.result$conditions <- ...future.conditions
[10:33:58.791]     ...future.result$finished <- base::Sys.time()
[10:33:58.791]     ...future.result
[10:33:58.791] }
[10:33:58.793] plan(): Setting new future strategy stack:
[10:33:58.793] List of future strategies:
[10:33:58.793] 1. sequential:
[10:33:58.793]    - args: function (..., envir = parent.frame())
[10:33:58.793]    - tweaked: FALSE
[10:33:58.793]    - call: NULL
[10:33:58.794] plan(): nbrOfWorkers() = 1
[10:33:58.794] plan(): Setting new future strategy stack:
[10:33:58.795] List of future strategies:
[10:33:58.795] 1. sequential:
[10:33:58.795]    - args: function (..., envir = parent.frame())
[10:33:58.795]    - tweaked: FALSE
[10:33:58.795]    - call: plan(strategy)
[10:33:58.795] plan(): nbrOfWorkers() = 1
[10:33:58.795] SequentialFuture started (and completed)
[10:33:58.795] - Launch lazy future ... done
[10:33:58.795] run() for ‘SequentialFuture’ ... done
[10:33:58.795] getGlobalsAndPackages() ...
[10:33:58.796] Searching for globals...
[10:33:58.796] - globals found: [1] ‘{’
[10:33:58.796] Searching for globals ... DONE
[10:33:58.796] Resolving globals: FALSE
[10:33:58.797] 
[10:33:58.797] 
[10:33:58.797] getGlobalsAndPackages() ... DONE
[10:33:58.797] run() for ‘Future’ ...
[10:33:58.797] - state: ‘created’
[10:33:58.797] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:58.797] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:58.798] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:58.798]   - Field: ‘label’
[10:33:58.798]   - Field: ‘local’
[10:33:58.798]   - Field: ‘owner’
[10:33:58.798]   - Field: ‘envir’
[10:33:58.798]   - Field: ‘packages’
[10:33:58.798]   - Field: ‘gc’
[10:33:58.798]   - Field: ‘conditions’
[10:33:58.798]   - Field: ‘expr’
[10:33:58.798]   - Field: ‘uuid’
[10:33:58.799]   - Field: ‘seed’
[10:33:58.799]   - Field: ‘version’
[10:33:58.799]   - Field: ‘result’
[10:33:58.799]   - Field: ‘asynchronous’
[10:33:58.799]   - Field: ‘calls’
[10:33:58.799]   - Field: ‘globals’
[10:33:58.799]   - Field: ‘stdout’
[10:33:58.799]   - Field: ‘earlySignal’
[10:33:58.799]   - Field: ‘lazy’
[10:33:58.799]   - Field: ‘state’
[10:33:58.799] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:58.799] - Launch lazy future ...
[10:33:58.800] Packages needed by the future expression (n = 0): <none>
[10:33:58.800] Packages needed by future strategies (n = 0): <none>
[10:33:58.800] {
[10:33:58.800]     {
[10:33:58.800]         {
[10:33:58.800]             ...future.startTime <- base::Sys.time()
[10:33:58.800]             {
[10:33:58.800]                 {
[10:33:58.800]                   {
[10:33:58.800]                     base::local({
[10:33:58.800]                       has_future <- base::requireNamespace("future", 
[10:33:58.800]                         quietly = TRUE)
[10:33:58.800]                       if (has_future) {
[10:33:58.800]                         ns <- base::getNamespace("future")
[10:33:58.800]                         version <- ns[[".package"]][["version"]]
[10:33:58.800]                         if (is.null(version)) 
[10:33:58.800]                           version <- utils::packageVersion("future")
[10:33:58.800]                       }
[10:33:58.800]                       else {
[10:33:58.800]                         version <- NULL
[10:33:58.800]                       }
[10:33:58.800]                       if (!has_future || version < "1.8.0") {
[10:33:58.800]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:58.800]                           "", base::R.version$version.string), 
[10:33:58.800]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:58.800]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:58.800]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:58.800]                             "release", "version")], collapse = " "), 
[10:33:58.800]                           hostname = base::Sys.info()[["nodename"]])
[10:33:58.800]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:58.800]                           info)
[10:33:58.800]                         info <- base::paste(info, collapse = "; ")
[10:33:58.800]                         if (!has_future) {
[10:33:58.800]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:58.800]                             info)
[10:33:58.800]                         }
[10:33:58.800]                         else {
[10:33:58.800]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:58.800]                             info, version)
[10:33:58.800]                         }
[10:33:58.800]                         base::stop(msg)
[10:33:58.800]                       }
[10:33:58.800]                     })
[10:33:58.800]                   }
[10:33:58.800]                   ...future.strategy.old <- future::plan("list")
[10:33:58.800]                   options(future.plan = NULL)
[10:33:58.800]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.800]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:58.800]                 }
[10:33:58.800]                 ...future.workdir <- getwd()
[10:33:58.800]             }
[10:33:58.800]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:58.800]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:58.800]         }
[10:33:58.800]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:58.800]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:58.800]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:58.800]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:58.800]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:58.800]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:58.800]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:58.800]             base::names(...future.oldOptions))
[10:33:58.800]     }
[10:33:58.800]     if (FALSE) {
[10:33:58.800]     }
[10:33:58.800]     else {
[10:33:58.800]         if (TRUE) {
[10:33:58.800]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:58.800]                 open = "w")
[10:33:58.800]         }
[10:33:58.800]         else {
[10:33:58.800]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:58.800]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:58.800]         }
[10:33:58.800]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:58.800]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:58.800]             base::sink(type = "output", split = FALSE)
[10:33:58.800]             base::close(...future.stdout)
[10:33:58.800]         }, add = TRUE)
[10:33:58.800]     }
[10:33:58.800]     ...future.frame <- base::sys.nframe()
[10:33:58.800]     ...future.conditions <- base::list()
[10:33:58.800]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:58.800]     if (FALSE) {
[10:33:58.800]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:58.800]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:58.800]     }
[10:33:58.800]     ...future.result <- base::tryCatch({
[10:33:58.800]         base::withCallingHandlers({
[10:33:58.800]             ...future.value <- base::withVisible(base::local({
[10:33:58.800]                 2
[10:33:58.800]             }))
[10:33:58.800]             future::FutureResult(value = ...future.value$value, 
[10:33:58.800]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.800]                   ...future.rng), globalenv = if (FALSE) 
[10:33:58.800]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:58.800]                     ...future.globalenv.names))
[10:33:58.800]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:58.800]         }, condition = base::local({
[10:33:58.800]             c <- base::c
[10:33:58.800]             inherits <- base::inherits
[10:33:58.800]             invokeRestart <- base::invokeRestart
[10:33:58.800]             length <- base::length
[10:33:58.800]             list <- base::list
[10:33:58.800]             seq.int <- base::seq.int
[10:33:58.800]             signalCondition <- base::signalCondition
[10:33:58.800]             sys.calls <- base::sys.calls
[10:33:58.800]             `[[` <- base::`[[`
[10:33:58.800]             `+` <- base::`+`
[10:33:58.800]             `<<-` <- base::`<<-`
[10:33:58.800]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:58.800]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:58.800]                   3L)]
[10:33:58.800]             }
[10:33:58.800]             function(cond) {
[10:33:58.800]                 is_error <- inherits(cond, "error")
[10:33:58.800]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:58.800]                   NULL)
[10:33:58.800]                 if (is_error) {
[10:33:58.800]                   sessionInformation <- function() {
[10:33:58.800]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:58.800]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:58.800]                       search = base::search(), system = base::Sys.info())
[10:33:58.800]                   }
[10:33:58.800]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.800]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:58.800]                     cond$call), session = sessionInformation(), 
[10:33:58.800]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:58.800]                   signalCondition(cond)
[10:33:58.800]                 }
[10:33:58.800]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:58.800]                 "immediateCondition"))) {
[10:33:58.800]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:58.800]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.800]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:58.800]                   if (TRUE && !signal) {
[10:33:58.800]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.800]                     {
[10:33:58.800]                       inherits <- base::inherits
[10:33:58.800]                       invokeRestart <- base::invokeRestart
[10:33:58.800]                       is.null <- base::is.null
[10:33:58.800]                       muffled <- FALSE
[10:33:58.800]                       if (inherits(cond, "message")) {
[10:33:58.800]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.800]                         if (muffled) 
[10:33:58.800]                           invokeRestart("muffleMessage")
[10:33:58.800]                       }
[10:33:58.800]                       else if (inherits(cond, "warning")) {
[10:33:58.800]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.800]                         if (muffled) 
[10:33:58.800]                           invokeRestart("muffleWarning")
[10:33:58.800]                       }
[10:33:58.800]                       else if (inherits(cond, "condition")) {
[10:33:58.800]                         if (!is.null(pattern)) {
[10:33:58.800]                           computeRestarts <- base::computeRestarts
[10:33:58.800]                           grepl <- base::grepl
[10:33:58.800]                           restarts <- computeRestarts(cond)
[10:33:58.800]                           for (restart in restarts) {
[10:33:58.800]                             name <- restart$name
[10:33:58.800]                             if (is.null(name)) 
[10:33:58.800]                               next
[10:33:58.800]                             if (!grepl(pattern, name)) 
[10:33:58.800]                               next
[10:33:58.800]                             invokeRestart(restart)
[10:33:58.800]                             muffled <- TRUE
[10:33:58.800]                             break
[10:33:58.800]                           }
[10:33:58.800]                         }
[10:33:58.800]                       }
[10:33:58.800]                       invisible(muffled)
[10:33:58.800]                     }
[10:33:58.800]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.800]                   }
[10:33:58.800]                 }
[10:33:58.800]                 else {
[10:33:58.800]                   if (TRUE) {
[10:33:58.800]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.800]                     {
[10:33:58.800]                       inherits <- base::inherits
[10:33:58.800]                       invokeRestart <- base::invokeRestart
[10:33:58.800]                       is.null <- base::is.null
[10:33:58.800]                       muffled <- FALSE
[10:33:58.800]                       if (inherits(cond, "message")) {
[10:33:58.800]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.800]                         if (muffled) 
[10:33:58.800]                           invokeRestart("muffleMessage")
[10:33:58.800]                       }
[10:33:58.800]                       else if (inherits(cond, "warning")) {
[10:33:58.800]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.800]                         if (muffled) 
[10:33:58.800]                           invokeRestart("muffleWarning")
[10:33:58.800]                       }
[10:33:58.800]                       else if (inherits(cond, "condition")) {
[10:33:58.800]                         if (!is.null(pattern)) {
[10:33:58.800]                           computeRestarts <- base::computeRestarts
[10:33:58.800]                           grepl <- base::grepl
[10:33:58.800]                           restarts <- computeRestarts(cond)
[10:33:58.800]                           for (restart in restarts) {
[10:33:58.800]                             name <- restart$name
[10:33:58.800]                             if (is.null(name)) 
[10:33:58.800]                               next
[10:33:58.800]                             if (!grepl(pattern, name)) 
[10:33:58.800]                               next
[10:33:58.800]                             invokeRestart(restart)
[10:33:58.800]                             muffled <- TRUE
[10:33:58.800]                             break
[10:33:58.800]                           }
[10:33:58.800]                         }
[10:33:58.800]                       }
[10:33:58.800]                       invisible(muffled)
[10:33:58.800]                     }
[10:33:58.800]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.800]                   }
[10:33:58.800]                 }
[10:33:58.800]             }
[10:33:58.800]         }))
[10:33:58.800]     }, error = function(ex) {
[10:33:58.800]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:58.800]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.800]                 ...future.rng), started = ...future.startTime, 
[10:33:58.800]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:58.800]             version = "1.8"), class = "FutureResult")
[10:33:58.800]     }, finally = {
[10:33:58.800]         if (!identical(...future.workdir, getwd())) 
[10:33:58.800]             setwd(...future.workdir)
[10:33:58.800]         {
[10:33:58.800]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:58.800]                 ...future.oldOptions$nwarnings <- NULL
[10:33:58.800]             }
[10:33:58.800]             base::options(...future.oldOptions)
[10:33:58.800]             if (.Platform$OS.type == "windows") {
[10:33:58.800]                 old_names <- names(...future.oldEnvVars)
[10:33:58.800]                 envs <- base::Sys.getenv()
[10:33:58.800]                 names <- names(envs)
[10:33:58.800]                 common <- intersect(names, old_names)
[10:33:58.800]                 added <- setdiff(names, old_names)
[10:33:58.800]                 removed <- setdiff(old_names, names)
[10:33:58.800]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:58.800]                   envs[common]]
[10:33:58.800]                 NAMES <- toupper(changed)
[10:33:58.800]                 args <- list()
[10:33:58.800]                 for (kk in seq_along(NAMES)) {
[10:33:58.800]                   name <- changed[[kk]]
[10:33:58.800]                   NAME <- NAMES[[kk]]
[10:33:58.800]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.800]                     next
[10:33:58.800]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.800]                 }
[10:33:58.800]                 NAMES <- toupper(added)
[10:33:58.800]                 for (kk in seq_along(NAMES)) {
[10:33:58.800]                   name <- added[[kk]]
[10:33:58.800]                   NAME <- NAMES[[kk]]
[10:33:58.800]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.800]                     next
[10:33:58.800]                   args[[name]] <- ""
[10:33:58.800]                 }
[10:33:58.800]                 NAMES <- toupper(removed)
[10:33:58.800]                 for (kk in seq_along(NAMES)) {
[10:33:58.800]                   name <- removed[[kk]]
[10:33:58.800]                   NAME <- NAMES[[kk]]
[10:33:58.800]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.800]                     next
[10:33:58.800]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.800]                 }
[10:33:58.800]                 if (length(args) > 0) 
[10:33:58.800]                   base::do.call(base::Sys.setenv, args = args)
[10:33:58.800]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:58.800]             }
[10:33:58.800]             else {
[10:33:58.800]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:58.800]             }
[10:33:58.800]             {
[10:33:58.800]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:58.800]                   0L) {
[10:33:58.800]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:58.800]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:58.800]                   base::options(opts)
[10:33:58.800]                 }
[10:33:58.800]                 {
[10:33:58.800]                   {
[10:33:58.800]                     NULL
[10:33:58.800]                     RNGkind("Mersenne-Twister")
[10:33:58.800]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:58.800]                       inherits = FALSE)
[10:33:58.800]                   }
[10:33:58.800]                   options(future.plan = NULL)
[10:33:58.800]                   if (is.na(NA_character_)) 
[10:33:58.800]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.800]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:58.800]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:58.800]                     .init = FALSE)
[10:33:58.800]                 }
[10:33:58.800]             }
[10:33:58.800]         }
[10:33:58.800]     })
[10:33:58.800]     if (TRUE) {
[10:33:58.800]         base::sink(type = "output", split = FALSE)
[10:33:58.800]         if (TRUE) {
[10:33:58.800]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:58.800]         }
[10:33:58.800]         else {
[10:33:58.800]             ...future.result["stdout"] <- base::list(NULL)
[10:33:58.800]         }
[10:33:58.800]         base::close(...future.stdout)
[10:33:58.800]         ...future.stdout <- NULL
[10:33:58.800]     }
[10:33:58.800]     ...future.result$conditions <- ...future.conditions
[10:33:58.800]     ...future.result$finished <- base::Sys.time()
[10:33:58.800]     ...future.result
[10:33:58.800] }
[10:33:58.802] plan(): Setting new future strategy stack:
[10:33:58.802] List of future strategies:
[10:33:58.802] 1. sequential:
[10:33:58.802]    - args: function (..., envir = parent.frame())
[10:33:58.802]    - tweaked: FALSE
[10:33:58.802]    - call: NULL
[10:33:58.802] plan(): nbrOfWorkers() = 1
[10:33:58.803] plan(): Setting new future strategy stack:
[10:33:58.803] List of future strategies:
[10:33:58.803] 1. sequential:
[10:33:58.803]    - args: function (..., envir = parent.frame())
[10:33:58.803]    - tweaked: FALSE
[10:33:58.803]    - call: plan(strategy)
[10:33:58.803] plan(): nbrOfWorkers() = 1
[10:33:58.803] SequentialFuture started (and completed)
[10:33:58.804] - Launch lazy future ... done
[10:33:58.804] run() for ‘SequentialFuture’ ... done
[10:33:58.804] resolve() on environment ...
[10:33:58.804]  recursive: 0
[10:33:58.805]  elements: [3] ‘a’
[10:33:58.805] resolved() for ‘SequentialFuture’ ...
[10:33:58.805] - state: ‘finished’
[10:33:58.805] - run: TRUE
[10:33:58.805] - result: ‘FutureResult’
[10:33:58.805] resolved() for ‘SequentialFuture’ ... done
[10:33:58.805] Future #1
[10:33:58.805]  length: 2 (resolved future 1)
[10:33:58.805] resolved() for ‘SequentialFuture’ ...
[10:33:58.806] - state: ‘finished’
[10:33:58.806] - run: TRUE
[10:33:58.806] - result: ‘FutureResult’
[10:33:58.806] resolved() for ‘SequentialFuture’ ... done
[10:33:58.806] Future #2
[10:33:58.806]  length: 1 (resolved future 2)
[10:33:58.806]  length: 0 (resolved future 3)
[10:33:58.806] resolve() on environment ... DONE
[10:33:58.806] resolved() for ‘SequentialFuture’ ...
[10:33:58.806] - state: ‘finished’
[10:33:58.806] - run: TRUE
[10:33:58.807] - result: ‘FutureResult’
[10:33:58.807] resolved() for ‘SequentialFuture’ ... done
[10:33:58.807] resolve() on environment ...
[10:33:58.807]  recursive: 0
[10:33:58.808]  elements: [3] ‘b’
[10:33:58.808] resolved() for ‘SequentialFuture’ ...
[10:33:58.808] - state: ‘finished’
[10:33:58.808] - run: TRUE
[10:33:58.808] - result: ‘FutureResult’
[10:33:58.808] resolved() for ‘SequentialFuture’ ... done
[10:33:58.808] Future #1
[10:33:58.808]  length: 2 (resolved future 1)
[10:33:58.808] resolved() for ‘SequentialFuture’ ...
[10:33:58.808] - state: ‘finished’
[10:33:58.808] - run: TRUE
[10:33:58.809] - result: ‘FutureResult’
[10:33:58.809] resolved() for ‘SequentialFuture’ ... done
[10:33:58.809] Future #2
[10:33:58.809]  length: 1 (resolved future 2)
[10:33:58.809]  length: 0 (resolved future 3)
[10:33:58.809] resolve() on environment ... DONE
[10:33:58.809] resolve() on environment ...
[10:33:58.810]  recursive: 0
[10:33:58.810]  elements: [3] ‘c’
[10:33:58.810] resolved() for ‘SequentialFuture’ ...
[10:33:58.810] - state: ‘finished’
[10:33:58.810] - run: TRUE
[10:33:58.810] - result: ‘FutureResult’
[10:33:58.810] resolved() for ‘SequentialFuture’ ... done
[10:33:58.811] Future #1
[10:33:58.811]  length: 2 (resolved future 1)
[10:33:58.811] resolved() for ‘SequentialFuture’ ...
[10:33:58.811] - state: ‘finished’
[10:33:58.811] - run: TRUE
[10:33:58.811] - result: ‘FutureResult’
[10:33:58.811] resolved() for ‘SequentialFuture’ ... done
[10:33:58.811] Future #2
[10:33:58.811]  length: 1 (resolved future 2)
[10:33:58.811]  length: 0 (resolved future 3)
[10:33:58.811] resolve() on environment ... DONE
[10:33:58.812] resolve() on environment ...
[10:33:58.812]  recursive: 0
[10:33:58.812]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[10:33:58.812] resolved() for ‘SequentialFuture’ ...
[10:33:58.813] - state: ‘finished’
[10:33:58.813] - run: TRUE
[10:33:58.813] - result: ‘FutureResult’
[10:33:58.813] resolved() for ‘SequentialFuture’ ... done
[10:33:58.813] Future #1
[10:33:58.813]  length: 2 (resolved future 1)
[10:33:58.814] resolved() for ‘SequentialFuture’ ...
[10:33:58.814] - state: ‘finished’
[10:33:58.814] - run: TRUE
[10:33:58.814] - result: ‘FutureResult’
[10:33:58.814] resolved() for ‘SequentialFuture’ ... done
[10:33:58.814] Future #2
[10:33:58.814]  length: 1 (resolved future 2)
[10:33:58.814]  length: 0 (resolved future 3)
[10:33:58.814] resolve() on environment ... DONE
[10:33:58.815] resolve() on environment ...
[10:33:58.815]  recursive: 99
[10:33:58.815]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[10:33:58.815] resolved() for ‘SequentialFuture’ ...
[10:33:58.816] - state: ‘finished’
[10:33:58.816] - run: TRUE
[10:33:58.817] - result: ‘FutureResult’
[10:33:58.817] resolved() for ‘SequentialFuture’ ... done
[10:33:58.817] Future #1
[10:33:58.818] resolved() for ‘SequentialFuture’ ...
[10:33:58.818] - state: ‘finished’
[10:33:58.818] - run: TRUE
[10:33:58.818] - result: ‘FutureResult’
[10:33:58.818] resolved() for ‘SequentialFuture’ ... done
[10:33:58.818] A SequentialFuture was resolved
[10:33:58.818]  length: 2 (resolved future 1)
[10:33:58.818] resolved() for ‘SequentialFuture’ ...
[10:33:58.818] - state: ‘finished’
[10:33:58.818] - run: TRUE
[10:33:58.818] - result: ‘FutureResult’
[10:33:58.819] resolved() for ‘SequentialFuture’ ... done
[10:33:58.819] Future #2
[10:33:58.819] resolved() for ‘SequentialFuture’ ...
[10:33:58.819] - state: ‘finished’
[10:33:58.819] - run: TRUE
[10:33:58.819] - result: ‘FutureResult’
[10:33:58.819] resolved() for ‘SequentialFuture’ ... done
[10:33:58.819] A SequentialFuture was resolved
[10:33:58.819]  length: 1 (resolved future 2)
[10:33:58.819]  length: 0 (resolved future 3)
[10:33:58.819] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[10:33:58.821] resolve() on list environment ...
[10:33:58.821]  recursive: 0
[10:33:58.822]  length: 2
[10:33:58.822]  elements: ‘a’, ‘b’
[10:33:58.822]  length: 1 (resolved future 1)
[10:33:58.822]  length: 0 (resolved future 2)
[10:33:58.822] resolve() on list environment ... DONE
[10:33:58.822] getGlobalsAndPackages() ...
[10:33:58.822] Searching for globals...
[10:33:58.823] 
[10:33:58.823] Searching for globals ... DONE
[10:33:58.823] - globals: [0] <none>
[10:33:58.823] getGlobalsAndPackages() ... DONE
[10:33:58.823] run() for ‘Future’ ...
[10:33:58.823] - state: ‘created’
[10:33:58.823] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:58.824] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:58.824] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:58.824]   - Field: ‘label’
[10:33:58.824]   - Field: ‘local’
[10:33:58.824]   - Field: ‘owner’
[10:33:58.824]   - Field: ‘envir’
[10:33:58.824]   - Field: ‘packages’
[10:33:58.824]   - Field: ‘gc’
[10:33:58.824]   - Field: ‘conditions’
[10:33:58.824]   - Field: ‘expr’
[10:33:58.824]   - Field: ‘uuid’
[10:33:58.825]   - Field: ‘seed’
[10:33:58.825]   - Field: ‘version’
[10:33:58.825]   - Field: ‘result’
[10:33:58.825]   - Field: ‘asynchronous’
[10:33:58.825]   - Field: ‘calls’
[10:33:58.825]   - Field: ‘globals’
[10:33:58.825]   - Field: ‘stdout’
[10:33:58.825]   - Field: ‘earlySignal’
[10:33:58.825]   - Field: ‘lazy’
[10:33:58.825]   - Field: ‘state’
[10:33:58.825] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:58.826] - Launch lazy future ...
[10:33:58.826] Packages needed by the future expression (n = 0): <none>
[10:33:58.826] Packages needed by future strategies (n = 0): <none>
[10:33:58.826] {
[10:33:58.826]     {
[10:33:58.826]         {
[10:33:58.826]             ...future.startTime <- base::Sys.time()
[10:33:58.826]             {
[10:33:58.826]                 {
[10:33:58.826]                   {
[10:33:58.826]                     base::local({
[10:33:58.826]                       has_future <- base::requireNamespace("future", 
[10:33:58.826]                         quietly = TRUE)
[10:33:58.826]                       if (has_future) {
[10:33:58.826]                         ns <- base::getNamespace("future")
[10:33:58.826]                         version <- ns[[".package"]][["version"]]
[10:33:58.826]                         if (is.null(version)) 
[10:33:58.826]                           version <- utils::packageVersion("future")
[10:33:58.826]                       }
[10:33:58.826]                       else {
[10:33:58.826]                         version <- NULL
[10:33:58.826]                       }
[10:33:58.826]                       if (!has_future || version < "1.8.0") {
[10:33:58.826]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:58.826]                           "", base::R.version$version.string), 
[10:33:58.826]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:58.826]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:58.826]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:58.826]                             "release", "version")], collapse = " "), 
[10:33:58.826]                           hostname = base::Sys.info()[["nodename"]])
[10:33:58.826]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:58.826]                           info)
[10:33:58.826]                         info <- base::paste(info, collapse = "; ")
[10:33:58.826]                         if (!has_future) {
[10:33:58.826]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:58.826]                             info)
[10:33:58.826]                         }
[10:33:58.826]                         else {
[10:33:58.826]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:58.826]                             info, version)
[10:33:58.826]                         }
[10:33:58.826]                         base::stop(msg)
[10:33:58.826]                       }
[10:33:58.826]                     })
[10:33:58.826]                   }
[10:33:58.826]                   ...future.strategy.old <- future::plan("list")
[10:33:58.826]                   options(future.plan = NULL)
[10:33:58.826]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.826]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:58.826]                 }
[10:33:58.826]                 ...future.workdir <- getwd()
[10:33:58.826]             }
[10:33:58.826]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:58.826]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:58.826]         }
[10:33:58.826]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:58.826]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:58.826]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:58.826]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:58.826]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:58.826]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:58.826]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:58.826]             base::names(...future.oldOptions))
[10:33:58.826]     }
[10:33:58.826]     if (FALSE) {
[10:33:58.826]     }
[10:33:58.826]     else {
[10:33:58.826]         if (TRUE) {
[10:33:58.826]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:58.826]                 open = "w")
[10:33:58.826]         }
[10:33:58.826]         else {
[10:33:58.826]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:58.826]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:58.826]         }
[10:33:58.826]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:58.826]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:58.826]             base::sink(type = "output", split = FALSE)
[10:33:58.826]             base::close(...future.stdout)
[10:33:58.826]         }, add = TRUE)
[10:33:58.826]     }
[10:33:58.826]     ...future.frame <- base::sys.nframe()
[10:33:58.826]     ...future.conditions <- base::list()
[10:33:58.826]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:58.826]     if (FALSE) {
[10:33:58.826]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:58.826]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:58.826]     }
[10:33:58.826]     ...future.result <- base::tryCatch({
[10:33:58.826]         base::withCallingHandlers({
[10:33:58.826]             ...future.value <- base::withVisible(base::local(1))
[10:33:58.826]             future::FutureResult(value = ...future.value$value, 
[10:33:58.826]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.826]                   ...future.rng), globalenv = if (FALSE) 
[10:33:58.826]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:58.826]                     ...future.globalenv.names))
[10:33:58.826]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:58.826]         }, condition = base::local({
[10:33:58.826]             c <- base::c
[10:33:58.826]             inherits <- base::inherits
[10:33:58.826]             invokeRestart <- base::invokeRestart
[10:33:58.826]             length <- base::length
[10:33:58.826]             list <- base::list
[10:33:58.826]             seq.int <- base::seq.int
[10:33:58.826]             signalCondition <- base::signalCondition
[10:33:58.826]             sys.calls <- base::sys.calls
[10:33:58.826]             `[[` <- base::`[[`
[10:33:58.826]             `+` <- base::`+`
[10:33:58.826]             `<<-` <- base::`<<-`
[10:33:58.826]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:58.826]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:58.826]                   3L)]
[10:33:58.826]             }
[10:33:58.826]             function(cond) {
[10:33:58.826]                 is_error <- inherits(cond, "error")
[10:33:58.826]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:58.826]                   NULL)
[10:33:58.826]                 if (is_error) {
[10:33:58.826]                   sessionInformation <- function() {
[10:33:58.826]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:58.826]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:58.826]                       search = base::search(), system = base::Sys.info())
[10:33:58.826]                   }
[10:33:58.826]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.826]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:58.826]                     cond$call), session = sessionInformation(), 
[10:33:58.826]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:58.826]                   signalCondition(cond)
[10:33:58.826]                 }
[10:33:58.826]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:58.826]                 "immediateCondition"))) {
[10:33:58.826]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:58.826]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.826]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:58.826]                   if (TRUE && !signal) {
[10:33:58.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.826]                     {
[10:33:58.826]                       inherits <- base::inherits
[10:33:58.826]                       invokeRestart <- base::invokeRestart
[10:33:58.826]                       is.null <- base::is.null
[10:33:58.826]                       muffled <- FALSE
[10:33:58.826]                       if (inherits(cond, "message")) {
[10:33:58.826]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.826]                         if (muffled) 
[10:33:58.826]                           invokeRestart("muffleMessage")
[10:33:58.826]                       }
[10:33:58.826]                       else if (inherits(cond, "warning")) {
[10:33:58.826]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.826]                         if (muffled) 
[10:33:58.826]                           invokeRestart("muffleWarning")
[10:33:58.826]                       }
[10:33:58.826]                       else if (inherits(cond, "condition")) {
[10:33:58.826]                         if (!is.null(pattern)) {
[10:33:58.826]                           computeRestarts <- base::computeRestarts
[10:33:58.826]                           grepl <- base::grepl
[10:33:58.826]                           restarts <- computeRestarts(cond)
[10:33:58.826]                           for (restart in restarts) {
[10:33:58.826]                             name <- restart$name
[10:33:58.826]                             if (is.null(name)) 
[10:33:58.826]                               next
[10:33:58.826]                             if (!grepl(pattern, name)) 
[10:33:58.826]                               next
[10:33:58.826]                             invokeRestart(restart)
[10:33:58.826]                             muffled <- TRUE
[10:33:58.826]                             break
[10:33:58.826]                           }
[10:33:58.826]                         }
[10:33:58.826]                       }
[10:33:58.826]                       invisible(muffled)
[10:33:58.826]                     }
[10:33:58.826]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.826]                   }
[10:33:58.826]                 }
[10:33:58.826]                 else {
[10:33:58.826]                   if (TRUE) {
[10:33:58.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.826]                     {
[10:33:58.826]                       inherits <- base::inherits
[10:33:58.826]                       invokeRestart <- base::invokeRestart
[10:33:58.826]                       is.null <- base::is.null
[10:33:58.826]                       muffled <- FALSE
[10:33:58.826]                       if (inherits(cond, "message")) {
[10:33:58.826]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.826]                         if (muffled) 
[10:33:58.826]                           invokeRestart("muffleMessage")
[10:33:58.826]                       }
[10:33:58.826]                       else if (inherits(cond, "warning")) {
[10:33:58.826]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.826]                         if (muffled) 
[10:33:58.826]                           invokeRestart("muffleWarning")
[10:33:58.826]                       }
[10:33:58.826]                       else if (inherits(cond, "condition")) {
[10:33:58.826]                         if (!is.null(pattern)) {
[10:33:58.826]                           computeRestarts <- base::computeRestarts
[10:33:58.826]                           grepl <- base::grepl
[10:33:58.826]                           restarts <- computeRestarts(cond)
[10:33:58.826]                           for (restart in restarts) {
[10:33:58.826]                             name <- restart$name
[10:33:58.826]                             if (is.null(name)) 
[10:33:58.826]                               next
[10:33:58.826]                             if (!grepl(pattern, name)) 
[10:33:58.826]                               next
[10:33:58.826]                             invokeRestart(restart)
[10:33:58.826]                             muffled <- TRUE
[10:33:58.826]                             break
[10:33:58.826]                           }
[10:33:58.826]                         }
[10:33:58.826]                       }
[10:33:58.826]                       invisible(muffled)
[10:33:58.826]                     }
[10:33:58.826]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.826]                   }
[10:33:58.826]                 }
[10:33:58.826]             }
[10:33:58.826]         }))
[10:33:58.826]     }, error = function(ex) {
[10:33:58.826]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:58.826]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.826]                 ...future.rng), started = ...future.startTime, 
[10:33:58.826]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:58.826]             version = "1.8"), class = "FutureResult")
[10:33:58.826]     }, finally = {
[10:33:58.826]         if (!identical(...future.workdir, getwd())) 
[10:33:58.826]             setwd(...future.workdir)
[10:33:58.826]         {
[10:33:58.826]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:58.826]                 ...future.oldOptions$nwarnings <- NULL
[10:33:58.826]             }
[10:33:58.826]             base::options(...future.oldOptions)
[10:33:58.826]             if (.Platform$OS.type == "windows") {
[10:33:58.826]                 old_names <- names(...future.oldEnvVars)
[10:33:58.826]                 envs <- base::Sys.getenv()
[10:33:58.826]                 names <- names(envs)
[10:33:58.826]                 common <- intersect(names, old_names)
[10:33:58.826]                 added <- setdiff(names, old_names)
[10:33:58.826]                 removed <- setdiff(old_names, names)
[10:33:58.826]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:58.826]                   envs[common]]
[10:33:58.826]                 NAMES <- toupper(changed)
[10:33:58.826]                 args <- list()
[10:33:58.826]                 for (kk in seq_along(NAMES)) {
[10:33:58.826]                   name <- changed[[kk]]
[10:33:58.826]                   NAME <- NAMES[[kk]]
[10:33:58.826]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.826]                     next
[10:33:58.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.826]                 }
[10:33:58.826]                 NAMES <- toupper(added)
[10:33:58.826]                 for (kk in seq_along(NAMES)) {
[10:33:58.826]                   name <- added[[kk]]
[10:33:58.826]                   NAME <- NAMES[[kk]]
[10:33:58.826]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.826]                     next
[10:33:58.826]                   args[[name]] <- ""
[10:33:58.826]                 }
[10:33:58.826]                 NAMES <- toupper(removed)
[10:33:58.826]                 for (kk in seq_along(NAMES)) {
[10:33:58.826]                   name <- removed[[kk]]
[10:33:58.826]                   NAME <- NAMES[[kk]]
[10:33:58.826]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.826]                     next
[10:33:58.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.826]                 }
[10:33:58.826]                 if (length(args) > 0) 
[10:33:58.826]                   base::do.call(base::Sys.setenv, args = args)
[10:33:58.826]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:58.826]             }
[10:33:58.826]             else {
[10:33:58.826]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:58.826]             }
[10:33:58.826]             {
[10:33:58.826]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:58.826]                   0L) {
[10:33:58.826]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:58.826]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:58.826]                   base::options(opts)
[10:33:58.826]                 }
[10:33:58.826]                 {
[10:33:58.826]                   {
[10:33:58.826]                     NULL
[10:33:58.826]                     RNGkind("Mersenne-Twister")
[10:33:58.826]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:58.826]                       inherits = FALSE)
[10:33:58.826]                   }
[10:33:58.826]                   options(future.plan = NULL)
[10:33:58.826]                   if (is.na(NA_character_)) 
[10:33:58.826]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.826]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:58.826]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:58.826]                     .init = FALSE)
[10:33:58.826]                 }
[10:33:58.826]             }
[10:33:58.826]         }
[10:33:58.826]     })
[10:33:58.826]     if (TRUE) {
[10:33:58.826]         base::sink(type = "output", split = FALSE)
[10:33:58.826]         if (TRUE) {
[10:33:58.826]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:58.826]         }
[10:33:58.826]         else {
[10:33:58.826]             ...future.result["stdout"] <- base::list(NULL)
[10:33:58.826]         }
[10:33:58.826]         base::close(...future.stdout)
[10:33:58.826]         ...future.stdout <- NULL
[10:33:58.826]     }
[10:33:58.826]     ...future.result$conditions <- ...future.conditions
[10:33:58.826]     ...future.result$finished <- base::Sys.time()
[10:33:58.826]     ...future.result
[10:33:58.826] }
[10:33:58.828] plan(): Setting new future strategy stack:
[10:33:58.828] List of future strategies:
[10:33:58.828] 1. sequential:
[10:33:58.828]    - args: function (..., envir = parent.frame())
[10:33:58.828]    - tweaked: FALSE
[10:33:58.828]    - call: NULL
[10:33:58.828] plan(): nbrOfWorkers() = 1
[10:33:58.829] plan(): Setting new future strategy stack:
[10:33:58.829] List of future strategies:
[10:33:58.829] 1. sequential:
[10:33:58.829]    - args: function (..., envir = parent.frame())
[10:33:58.829]    - tweaked: FALSE
[10:33:58.829]    - call: plan(strategy)
[10:33:58.830] plan(): nbrOfWorkers() = 1
[10:33:58.830] SequentialFuture started (and completed)
[10:33:58.830] - Launch lazy future ... done
[10:33:58.830] run() for ‘SequentialFuture’ ... done
[10:33:58.830] getGlobalsAndPackages() ...
[10:33:58.830] Searching for globals...
[10:33:58.831] 
[10:33:58.831] Searching for globals ... DONE
[10:33:58.831] - globals: [0] <none>
[10:33:58.831] getGlobalsAndPackages() ... DONE
[10:33:58.831] run() for ‘Future’ ...
[10:33:58.831] - state: ‘created’
[10:33:58.831] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:58.832] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:58.832] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:58.832]   - Field: ‘label’
[10:33:58.832]   - Field: ‘local’
[10:33:58.832]   - Field: ‘owner’
[10:33:58.832]   - Field: ‘envir’
[10:33:58.832]   - Field: ‘packages’
[10:33:58.832]   - Field: ‘gc’
[10:33:58.832]   - Field: ‘conditions’
[10:33:58.833]   - Field: ‘expr’
[10:33:58.833]   - Field: ‘uuid’
[10:33:58.833]   - Field: ‘seed’
[10:33:58.833]   - Field: ‘version’
[10:33:58.833]   - Field: ‘result’
[10:33:58.833]   - Field: ‘asynchronous’
[10:33:58.833]   - Field: ‘calls’
[10:33:58.833]   - Field: ‘globals’
[10:33:58.833]   - Field: ‘stdout’
[10:33:58.833]   - Field: ‘earlySignal’
[10:33:58.833]   - Field: ‘lazy’
[10:33:58.834]   - Field: ‘state’
[10:33:58.834] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:58.834] - Launch lazy future ...
[10:33:58.834] Packages needed by the future expression (n = 0): <none>
[10:33:58.834] Packages needed by future strategies (n = 0): <none>
[10:33:58.834] {
[10:33:58.834]     {
[10:33:58.834]         {
[10:33:58.834]             ...future.startTime <- base::Sys.time()
[10:33:58.834]             {
[10:33:58.834]                 {
[10:33:58.834]                   {
[10:33:58.834]                     base::local({
[10:33:58.834]                       has_future <- base::requireNamespace("future", 
[10:33:58.834]                         quietly = TRUE)
[10:33:58.834]                       if (has_future) {
[10:33:58.834]                         ns <- base::getNamespace("future")
[10:33:58.834]                         version <- ns[[".package"]][["version"]]
[10:33:58.834]                         if (is.null(version)) 
[10:33:58.834]                           version <- utils::packageVersion("future")
[10:33:58.834]                       }
[10:33:58.834]                       else {
[10:33:58.834]                         version <- NULL
[10:33:58.834]                       }
[10:33:58.834]                       if (!has_future || version < "1.8.0") {
[10:33:58.834]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:58.834]                           "", base::R.version$version.string), 
[10:33:58.834]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:58.834]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:58.834]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:58.834]                             "release", "version")], collapse = " "), 
[10:33:58.834]                           hostname = base::Sys.info()[["nodename"]])
[10:33:58.834]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:58.834]                           info)
[10:33:58.834]                         info <- base::paste(info, collapse = "; ")
[10:33:58.834]                         if (!has_future) {
[10:33:58.834]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:58.834]                             info)
[10:33:58.834]                         }
[10:33:58.834]                         else {
[10:33:58.834]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:58.834]                             info, version)
[10:33:58.834]                         }
[10:33:58.834]                         base::stop(msg)
[10:33:58.834]                       }
[10:33:58.834]                     })
[10:33:58.834]                   }
[10:33:58.834]                   ...future.strategy.old <- future::plan("list")
[10:33:58.834]                   options(future.plan = NULL)
[10:33:58.834]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.834]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:58.834]                 }
[10:33:58.834]                 ...future.workdir <- getwd()
[10:33:58.834]             }
[10:33:58.834]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:58.834]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:58.834]         }
[10:33:58.834]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:58.834]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:58.834]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:58.834]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:58.834]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:58.834]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:58.834]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:58.834]             base::names(...future.oldOptions))
[10:33:58.834]     }
[10:33:58.834]     if (FALSE) {
[10:33:58.834]     }
[10:33:58.834]     else {
[10:33:58.834]         if (TRUE) {
[10:33:58.834]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:58.834]                 open = "w")
[10:33:58.834]         }
[10:33:58.834]         else {
[10:33:58.834]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:58.834]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:58.834]         }
[10:33:58.834]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:58.834]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:58.834]             base::sink(type = "output", split = FALSE)
[10:33:58.834]             base::close(...future.stdout)
[10:33:58.834]         }, add = TRUE)
[10:33:58.834]     }
[10:33:58.834]     ...future.frame <- base::sys.nframe()
[10:33:58.834]     ...future.conditions <- base::list()
[10:33:58.834]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:58.834]     if (FALSE) {
[10:33:58.834]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:58.834]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:58.834]     }
[10:33:58.834]     ...future.result <- base::tryCatch({
[10:33:58.834]         base::withCallingHandlers({
[10:33:58.834]             ...future.value <- base::withVisible(base::local(2))
[10:33:58.834]             future::FutureResult(value = ...future.value$value, 
[10:33:58.834]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.834]                   ...future.rng), globalenv = if (FALSE) 
[10:33:58.834]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:58.834]                     ...future.globalenv.names))
[10:33:58.834]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:58.834]         }, condition = base::local({
[10:33:58.834]             c <- base::c
[10:33:58.834]             inherits <- base::inherits
[10:33:58.834]             invokeRestart <- base::invokeRestart
[10:33:58.834]             length <- base::length
[10:33:58.834]             list <- base::list
[10:33:58.834]             seq.int <- base::seq.int
[10:33:58.834]             signalCondition <- base::signalCondition
[10:33:58.834]             sys.calls <- base::sys.calls
[10:33:58.834]             `[[` <- base::`[[`
[10:33:58.834]             `+` <- base::`+`
[10:33:58.834]             `<<-` <- base::`<<-`
[10:33:58.834]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:58.834]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:58.834]                   3L)]
[10:33:58.834]             }
[10:33:58.834]             function(cond) {
[10:33:58.834]                 is_error <- inherits(cond, "error")
[10:33:58.834]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:58.834]                   NULL)
[10:33:58.834]                 if (is_error) {
[10:33:58.834]                   sessionInformation <- function() {
[10:33:58.834]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:58.834]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:58.834]                       search = base::search(), system = base::Sys.info())
[10:33:58.834]                   }
[10:33:58.834]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.834]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:58.834]                     cond$call), session = sessionInformation(), 
[10:33:58.834]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:58.834]                   signalCondition(cond)
[10:33:58.834]                 }
[10:33:58.834]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:58.834]                 "immediateCondition"))) {
[10:33:58.834]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:58.834]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.834]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:58.834]                   if (TRUE && !signal) {
[10:33:58.834]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.834]                     {
[10:33:58.834]                       inherits <- base::inherits
[10:33:58.834]                       invokeRestart <- base::invokeRestart
[10:33:58.834]                       is.null <- base::is.null
[10:33:58.834]                       muffled <- FALSE
[10:33:58.834]                       if (inherits(cond, "message")) {
[10:33:58.834]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.834]                         if (muffled) 
[10:33:58.834]                           invokeRestart("muffleMessage")
[10:33:58.834]                       }
[10:33:58.834]                       else if (inherits(cond, "warning")) {
[10:33:58.834]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.834]                         if (muffled) 
[10:33:58.834]                           invokeRestart("muffleWarning")
[10:33:58.834]                       }
[10:33:58.834]                       else if (inherits(cond, "condition")) {
[10:33:58.834]                         if (!is.null(pattern)) {
[10:33:58.834]                           computeRestarts <- base::computeRestarts
[10:33:58.834]                           grepl <- base::grepl
[10:33:58.834]                           restarts <- computeRestarts(cond)
[10:33:58.834]                           for (restart in restarts) {
[10:33:58.834]                             name <- restart$name
[10:33:58.834]                             if (is.null(name)) 
[10:33:58.834]                               next
[10:33:58.834]                             if (!grepl(pattern, name)) 
[10:33:58.834]                               next
[10:33:58.834]                             invokeRestart(restart)
[10:33:58.834]                             muffled <- TRUE
[10:33:58.834]                             break
[10:33:58.834]                           }
[10:33:58.834]                         }
[10:33:58.834]                       }
[10:33:58.834]                       invisible(muffled)
[10:33:58.834]                     }
[10:33:58.834]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.834]                   }
[10:33:58.834]                 }
[10:33:58.834]                 else {
[10:33:58.834]                   if (TRUE) {
[10:33:58.834]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.834]                     {
[10:33:58.834]                       inherits <- base::inherits
[10:33:58.834]                       invokeRestart <- base::invokeRestart
[10:33:58.834]                       is.null <- base::is.null
[10:33:58.834]                       muffled <- FALSE
[10:33:58.834]                       if (inherits(cond, "message")) {
[10:33:58.834]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.834]                         if (muffled) 
[10:33:58.834]                           invokeRestart("muffleMessage")
[10:33:58.834]                       }
[10:33:58.834]                       else if (inherits(cond, "warning")) {
[10:33:58.834]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.834]                         if (muffled) 
[10:33:58.834]                           invokeRestart("muffleWarning")
[10:33:58.834]                       }
[10:33:58.834]                       else if (inherits(cond, "condition")) {
[10:33:58.834]                         if (!is.null(pattern)) {
[10:33:58.834]                           computeRestarts <- base::computeRestarts
[10:33:58.834]                           grepl <- base::grepl
[10:33:58.834]                           restarts <- computeRestarts(cond)
[10:33:58.834]                           for (restart in restarts) {
[10:33:58.834]                             name <- restart$name
[10:33:58.834]                             if (is.null(name)) 
[10:33:58.834]                               next
[10:33:58.834]                             if (!grepl(pattern, name)) 
[10:33:58.834]                               next
[10:33:58.834]                             invokeRestart(restart)
[10:33:58.834]                             muffled <- TRUE
[10:33:58.834]                             break
[10:33:58.834]                           }
[10:33:58.834]                         }
[10:33:58.834]                       }
[10:33:58.834]                       invisible(muffled)
[10:33:58.834]                     }
[10:33:58.834]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.834]                   }
[10:33:58.834]                 }
[10:33:58.834]             }
[10:33:58.834]         }))
[10:33:58.834]     }, error = function(ex) {
[10:33:58.834]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:58.834]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.834]                 ...future.rng), started = ...future.startTime, 
[10:33:58.834]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:58.834]             version = "1.8"), class = "FutureResult")
[10:33:58.834]     }, finally = {
[10:33:58.834]         if (!identical(...future.workdir, getwd())) 
[10:33:58.834]             setwd(...future.workdir)
[10:33:58.834]         {
[10:33:58.834]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:58.834]                 ...future.oldOptions$nwarnings <- NULL
[10:33:58.834]             }
[10:33:58.834]             base::options(...future.oldOptions)
[10:33:58.834]             if (.Platform$OS.type == "windows") {
[10:33:58.834]                 old_names <- names(...future.oldEnvVars)
[10:33:58.834]                 envs <- base::Sys.getenv()
[10:33:58.834]                 names <- names(envs)
[10:33:58.834]                 common <- intersect(names, old_names)
[10:33:58.834]                 added <- setdiff(names, old_names)
[10:33:58.834]                 removed <- setdiff(old_names, names)
[10:33:58.834]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:58.834]                   envs[common]]
[10:33:58.834]                 NAMES <- toupper(changed)
[10:33:58.834]                 args <- list()
[10:33:58.834]                 for (kk in seq_along(NAMES)) {
[10:33:58.834]                   name <- changed[[kk]]
[10:33:58.834]                   NAME <- NAMES[[kk]]
[10:33:58.834]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.834]                     next
[10:33:58.834]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.834]                 }
[10:33:58.834]                 NAMES <- toupper(added)
[10:33:58.834]                 for (kk in seq_along(NAMES)) {
[10:33:58.834]                   name <- added[[kk]]
[10:33:58.834]                   NAME <- NAMES[[kk]]
[10:33:58.834]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.834]                     next
[10:33:58.834]                   args[[name]] <- ""
[10:33:58.834]                 }
[10:33:58.834]                 NAMES <- toupper(removed)
[10:33:58.834]                 for (kk in seq_along(NAMES)) {
[10:33:58.834]                   name <- removed[[kk]]
[10:33:58.834]                   NAME <- NAMES[[kk]]
[10:33:58.834]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.834]                     next
[10:33:58.834]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.834]                 }
[10:33:58.834]                 if (length(args) > 0) 
[10:33:58.834]                   base::do.call(base::Sys.setenv, args = args)
[10:33:58.834]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:58.834]             }
[10:33:58.834]             else {
[10:33:58.834]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:58.834]             }
[10:33:58.834]             {
[10:33:58.834]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:58.834]                   0L) {
[10:33:58.834]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:58.834]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:58.834]                   base::options(opts)
[10:33:58.834]                 }
[10:33:58.834]                 {
[10:33:58.834]                   {
[10:33:58.834]                     NULL
[10:33:58.834]                     RNGkind("Mersenne-Twister")
[10:33:58.834]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:58.834]                       inherits = FALSE)
[10:33:58.834]                   }
[10:33:58.834]                   options(future.plan = NULL)
[10:33:58.834]                   if (is.na(NA_character_)) 
[10:33:58.834]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.834]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:58.834]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:58.834]                     .init = FALSE)
[10:33:58.834]                 }
[10:33:58.834]             }
[10:33:58.834]         }
[10:33:58.834]     })
[10:33:58.834]     if (TRUE) {
[10:33:58.834]         base::sink(type = "output", split = FALSE)
[10:33:58.834]         if (TRUE) {
[10:33:58.834]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:58.834]         }
[10:33:58.834]         else {
[10:33:58.834]             ...future.result["stdout"] <- base::list(NULL)
[10:33:58.834]         }
[10:33:58.834]         base::close(...future.stdout)
[10:33:58.834]         ...future.stdout <- NULL
[10:33:58.834]     }
[10:33:58.834]     ...future.result$conditions <- ...future.conditions
[10:33:58.834]     ...future.result$finished <- base::Sys.time()
[10:33:58.834]     ...future.result
[10:33:58.834] }
[10:33:58.836] plan(): Setting new future strategy stack:
[10:33:58.836] List of future strategies:
[10:33:58.836] 1. sequential:
[10:33:58.836]    - args: function (..., envir = parent.frame())
[10:33:58.836]    - tweaked: FALSE
[10:33:58.836]    - call: NULL
[10:33:58.837] plan(): nbrOfWorkers() = 1
[10:33:58.837] plan(): Setting new future strategy stack:
[10:33:58.837] List of future strategies:
[10:33:58.837] 1. sequential:
[10:33:58.837]    - args: function (..., envir = parent.frame())
[10:33:58.837]    - tweaked: FALSE
[10:33:58.837]    - call: plan(strategy)
[10:33:58.838] plan(): nbrOfWorkers() = 1
[10:33:58.838] SequentialFuture started (and completed)
[10:33:58.838] - Launch lazy future ... done
[10:33:58.838] run() for ‘SequentialFuture’ ... done
[10:33:58.839] resolve() on list environment ...
[10:33:58.839]  recursive: 0
[10:33:58.839]  length: 3
[10:33:58.840]  elements: ‘a’, ‘b’, ‘c’
[10:33:58.840] resolved() for ‘SequentialFuture’ ...
[10:33:58.840] - state: ‘finished’
[10:33:58.840] - run: TRUE
[10:33:58.840] - result: ‘FutureResult’
[10:33:58.840] resolved() for ‘SequentialFuture’ ... done
[10:33:58.840] Future #1
[10:33:58.840]  length: 2 (resolved future 1)
[10:33:58.840] resolved() for ‘SequentialFuture’ ...
[10:33:58.840] - state: ‘finished’
[10:33:58.841] - run: TRUE
[10:33:58.841] - result: ‘FutureResult’
[10:33:58.841] resolved() for ‘SequentialFuture’ ... done
[10:33:58.841] Future #2
[10:33:58.841]  length: 1 (resolved future 2)
[10:33:58.841]  length: 0 (resolved future 3)
[10:33:58.841] resolve() on list environment ... DONE
[10:33:58.842] getGlobalsAndPackages() ...
[10:33:58.842] Searching for globals...
[10:33:58.844] - globals found: [1] ‘{’
[10:33:58.845] Searching for globals ... DONE
[10:33:58.845] Resolving globals: FALSE
[10:33:58.845] 
[10:33:58.845] 
[10:33:58.845] getGlobalsAndPackages() ... DONE
[10:33:58.845] run() for ‘Future’ ...
[10:33:58.846] - state: ‘created’
[10:33:58.846] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:58.846] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:58.846] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:58.846]   - Field: ‘label’
[10:33:58.846]   - Field: ‘local’
[10:33:58.846]   - Field: ‘owner’
[10:33:58.846]   - Field: ‘envir’
[10:33:58.847]   - Field: ‘packages’
[10:33:58.847]   - Field: ‘gc’
[10:33:58.847]   - Field: ‘conditions’
[10:33:58.847]   - Field: ‘expr’
[10:33:58.847]   - Field: ‘uuid’
[10:33:58.847]   - Field: ‘seed’
[10:33:58.847]   - Field: ‘version’
[10:33:58.847]   - Field: ‘result’
[10:33:58.847]   - Field: ‘asynchronous’
[10:33:58.847]   - Field: ‘calls’
[10:33:58.847]   - Field: ‘globals’
[10:33:58.848]   - Field: ‘stdout’
[10:33:58.848]   - Field: ‘earlySignal’
[10:33:58.848]   - Field: ‘lazy’
[10:33:58.848]   - Field: ‘state’
[10:33:58.848] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:58.848] - Launch lazy future ...
[10:33:58.848] Packages needed by the future expression (n = 0): <none>
[10:33:58.848] Packages needed by future strategies (n = 0): <none>
[10:33:58.849] {
[10:33:58.849]     {
[10:33:58.849]         {
[10:33:58.849]             ...future.startTime <- base::Sys.time()
[10:33:58.849]             {
[10:33:58.849]                 {
[10:33:58.849]                   {
[10:33:58.849]                     base::local({
[10:33:58.849]                       has_future <- base::requireNamespace("future", 
[10:33:58.849]                         quietly = TRUE)
[10:33:58.849]                       if (has_future) {
[10:33:58.849]                         ns <- base::getNamespace("future")
[10:33:58.849]                         version <- ns[[".package"]][["version"]]
[10:33:58.849]                         if (is.null(version)) 
[10:33:58.849]                           version <- utils::packageVersion("future")
[10:33:58.849]                       }
[10:33:58.849]                       else {
[10:33:58.849]                         version <- NULL
[10:33:58.849]                       }
[10:33:58.849]                       if (!has_future || version < "1.8.0") {
[10:33:58.849]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:58.849]                           "", base::R.version$version.string), 
[10:33:58.849]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:58.849]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:58.849]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:58.849]                             "release", "version")], collapse = " "), 
[10:33:58.849]                           hostname = base::Sys.info()[["nodename"]])
[10:33:58.849]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:58.849]                           info)
[10:33:58.849]                         info <- base::paste(info, collapse = "; ")
[10:33:58.849]                         if (!has_future) {
[10:33:58.849]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:58.849]                             info)
[10:33:58.849]                         }
[10:33:58.849]                         else {
[10:33:58.849]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:58.849]                             info, version)
[10:33:58.849]                         }
[10:33:58.849]                         base::stop(msg)
[10:33:58.849]                       }
[10:33:58.849]                     })
[10:33:58.849]                   }
[10:33:58.849]                   ...future.strategy.old <- future::plan("list")
[10:33:58.849]                   options(future.plan = NULL)
[10:33:58.849]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.849]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:58.849]                 }
[10:33:58.849]                 ...future.workdir <- getwd()
[10:33:58.849]             }
[10:33:58.849]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:58.849]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:58.849]         }
[10:33:58.849]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:58.849]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:58.849]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:58.849]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:58.849]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:58.849]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:58.849]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:58.849]             base::names(...future.oldOptions))
[10:33:58.849]     }
[10:33:58.849]     if (FALSE) {
[10:33:58.849]     }
[10:33:58.849]     else {
[10:33:58.849]         if (TRUE) {
[10:33:58.849]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:58.849]                 open = "w")
[10:33:58.849]         }
[10:33:58.849]         else {
[10:33:58.849]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:58.849]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:58.849]         }
[10:33:58.849]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:58.849]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:58.849]             base::sink(type = "output", split = FALSE)
[10:33:58.849]             base::close(...future.stdout)
[10:33:58.849]         }, add = TRUE)
[10:33:58.849]     }
[10:33:58.849]     ...future.frame <- base::sys.nframe()
[10:33:58.849]     ...future.conditions <- base::list()
[10:33:58.849]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:58.849]     if (FALSE) {
[10:33:58.849]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:58.849]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:58.849]     }
[10:33:58.849]     ...future.result <- base::tryCatch({
[10:33:58.849]         base::withCallingHandlers({
[10:33:58.849]             ...future.value <- base::withVisible(base::local({
[10:33:58.849]                 1
[10:33:58.849]             }))
[10:33:58.849]             future::FutureResult(value = ...future.value$value, 
[10:33:58.849]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.849]                   ...future.rng), globalenv = if (FALSE) 
[10:33:58.849]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:58.849]                     ...future.globalenv.names))
[10:33:58.849]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:58.849]         }, condition = base::local({
[10:33:58.849]             c <- base::c
[10:33:58.849]             inherits <- base::inherits
[10:33:58.849]             invokeRestart <- base::invokeRestart
[10:33:58.849]             length <- base::length
[10:33:58.849]             list <- base::list
[10:33:58.849]             seq.int <- base::seq.int
[10:33:58.849]             signalCondition <- base::signalCondition
[10:33:58.849]             sys.calls <- base::sys.calls
[10:33:58.849]             `[[` <- base::`[[`
[10:33:58.849]             `+` <- base::`+`
[10:33:58.849]             `<<-` <- base::`<<-`
[10:33:58.849]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:58.849]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:58.849]                   3L)]
[10:33:58.849]             }
[10:33:58.849]             function(cond) {
[10:33:58.849]                 is_error <- inherits(cond, "error")
[10:33:58.849]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:58.849]                   NULL)
[10:33:58.849]                 if (is_error) {
[10:33:58.849]                   sessionInformation <- function() {
[10:33:58.849]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:58.849]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:58.849]                       search = base::search(), system = base::Sys.info())
[10:33:58.849]                   }
[10:33:58.849]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.849]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:58.849]                     cond$call), session = sessionInformation(), 
[10:33:58.849]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:58.849]                   signalCondition(cond)
[10:33:58.849]                 }
[10:33:58.849]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:58.849]                 "immediateCondition"))) {
[10:33:58.849]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:58.849]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.849]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:58.849]                   if (TRUE && !signal) {
[10:33:58.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.849]                     {
[10:33:58.849]                       inherits <- base::inherits
[10:33:58.849]                       invokeRestart <- base::invokeRestart
[10:33:58.849]                       is.null <- base::is.null
[10:33:58.849]                       muffled <- FALSE
[10:33:58.849]                       if (inherits(cond, "message")) {
[10:33:58.849]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.849]                         if (muffled) 
[10:33:58.849]                           invokeRestart("muffleMessage")
[10:33:58.849]                       }
[10:33:58.849]                       else if (inherits(cond, "warning")) {
[10:33:58.849]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.849]                         if (muffled) 
[10:33:58.849]                           invokeRestart("muffleWarning")
[10:33:58.849]                       }
[10:33:58.849]                       else if (inherits(cond, "condition")) {
[10:33:58.849]                         if (!is.null(pattern)) {
[10:33:58.849]                           computeRestarts <- base::computeRestarts
[10:33:58.849]                           grepl <- base::grepl
[10:33:58.849]                           restarts <- computeRestarts(cond)
[10:33:58.849]                           for (restart in restarts) {
[10:33:58.849]                             name <- restart$name
[10:33:58.849]                             if (is.null(name)) 
[10:33:58.849]                               next
[10:33:58.849]                             if (!grepl(pattern, name)) 
[10:33:58.849]                               next
[10:33:58.849]                             invokeRestart(restart)
[10:33:58.849]                             muffled <- TRUE
[10:33:58.849]                             break
[10:33:58.849]                           }
[10:33:58.849]                         }
[10:33:58.849]                       }
[10:33:58.849]                       invisible(muffled)
[10:33:58.849]                     }
[10:33:58.849]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.849]                   }
[10:33:58.849]                 }
[10:33:58.849]                 else {
[10:33:58.849]                   if (TRUE) {
[10:33:58.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.849]                     {
[10:33:58.849]                       inherits <- base::inherits
[10:33:58.849]                       invokeRestart <- base::invokeRestart
[10:33:58.849]                       is.null <- base::is.null
[10:33:58.849]                       muffled <- FALSE
[10:33:58.849]                       if (inherits(cond, "message")) {
[10:33:58.849]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.849]                         if (muffled) 
[10:33:58.849]                           invokeRestart("muffleMessage")
[10:33:58.849]                       }
[10:33:58.849]                       else if (inherits(cond, "warning")) {
[10:33:58.849]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.849]                         if (muffled) 
[10:33:58.849]                           invokeRestart("muffleWarning")
[10:33:58.849]                       }
[10:33:58.849]                       else if (inherits(cond, "condition")) {
[10:33:58.849]                         if (!is.null(pattern)) {
[10:33:58.849]                           computeRestarts <- base::computeRestarts
[10:33:58.849]                           grepl <- base::grepl
[10:33:58.849]                           restarts <- computeRestarts(cond)
[10:33:58.849]                           for (restart in restarts) {
[10:33:58.849]                             name <- restart$name
[10:33:58.849]                             if (is.null(name)) 
[10:33:58.849]                               next
[10:33:58.849]                             if (!grepl(pattern, name)) 
[10:33:58.849]                               next
[10:33:58.849]                             invokeRestart(restart)
[10:33:58.849]                             muffled <- TRUE
[10:33:58.849]                             break
[10:33:58.849]                           }
[10:33:58.849]                         }
[10:33:58.849]                       }
[10:33:58.849]                       invisible(muffled)
[10:33:58.849]                     }
[10:33:58.849]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.849]                   }
[10:33:58.849]                 }
[10:33:58.849]             }
[10:33:58.849]         }))
[10:33:58.849]     }, error = function(ex) {
[10:33:58.849]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:58.849]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.849]                 ...future.rng), started = ...future.startTime, 
[10:33:58.849]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:58.849]             version = "1.8"), class = "FutureResult")
[10:33:58.849]     }, finally = {
[10:33:58.849]         if (!identical(...future.workdir, getwd())) 
[10:33:58.849]             setwd(...future.workdir)
[10:33:58.849]         {
[10:33:58.849]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:58.849]                 ...future.oldOptions$nwarnings <- NULL
[10:33:58.849]             }
[10:33:58.849]             base::options(...future.oldOptions)
[10:33:58.849]             if (.Platform$OS.type == "windows") {
[10:33:58.849]                 old_names <- names(...future.oldEnvVars)
[10:33:58.849]                 envs <- base::Sys.getenv()
[10:33:58.849]                 names <- names(envs)
[10:33:58.849]                 common <- intersect(names, old_names)
[10:33:58.849]                 added <- setdiff(names, old_names)
[10:33:58.849]                 removed <- setdiff(old_names, names)
[10:33:58.849]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:58.849]                   envs[common]]
[10:33:58.849]                 NAMES <- toupper(changed)
[10:33:58.849]                 args <- list()
[10:33:58.849]                 for (kk in seq_along(NAMES)) {
[10:33:58.849]                   name <- changed[[kk]]
[10:33:58.849]                   NAME <- NAMES[[kk]]
[10:33:58.849]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.849]                     next
[10:33:58.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.849]                 }
[10:33:58.849]                 NAMES <- toupper(added)
[10:33:58.849]                 for (kk in seq_along(NAMES)) {
[10:33:58.849]                   name <- added[[kk]]
[10:33:58.849]                   NAME <- NAMES[[kk]]
[10:33:58.849]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.849]                     next
[10:33:58.849]                   args[[name]] <- ""
[10:33:58.849]                 }
[10:33:58.849]                 NAMES <- toupper(removed)
[10:33:58.849]                 for (kk in seq_along(NAMES)) {
[10:33:58.849]                   name <- removed[[kk]]
[10:33:58.849]                   NAME <- NAMES[[kk]]
[10:33:58.849]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.849]                     next
[10:33:58.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.849]                 }
[10:33:58.849]                 if (length(args) > 0) 
[10:33:58.849]                   base::do.call(base::Sys.setenv, args = args)
[10:33:58.849]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:58.849]             }
[10:33:58.849]             else {
[10:33:58.849]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:58.849]             }
[10:33:58.849]             {
[10:33:58.849]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:58.849]                   0L) {
[10:33:58.849]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:58.849]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:58.849]                   base::options(opts)
[10:33:58.849]                 }
[10:33:58.849]                 {
[10:33:58.849]                   {
[10:33:58.849]                     NULL
[10:33:58.849]                     RNGkind("Mersenne-Twister")
[10:33:58.849]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:58.849]                       inherits = FALSE)
[10:33:58.849]                   }
[10:33:58.849]                   options(future.plan = NULL)
[10:33:58.849]                   if (is.na(NA_character_)) 
[10:33:58.849]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.849]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:58.849]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:58.849]                     .init = FALSE)
[10:33:58.849]                 }
[10:33:58.849]             }
[10:33:58.849]         }
[10:33:58.849]     })
[10:33:58.849]     if (TRUE) {
[10:33:58.849]         base::sink(type = "output", split = FALSE)
[10:33:58.849]         if (TRUE) {
[10:33:58.849]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:58.849]         }
[10:33:58.849]         else {
[10:33:58.849]             ...future.result["stdout"] <- base::list(NULL)
[10:33:58.849]         }
[10:33:58.849]         base::close(...future.stdout)
[10:33:58.849]         ...future.stdout <- NULL
[10:33:58.849]     }
[10:33:58.849]     ...future.result$conditions <- ...future.conditions
[10:33:58.849]     ...future.result$finished <- base::Sys.time()
[10:33:58.849]     ...future.result
[10:33:58.849] }
[10:33:58.850] plan(): Setting new future strategy stack:
[10:33:58.850] List of future strategies:
[10:33:58.850] 1. sequential:
[10:33:58.850]    - args: function (..., envir = parent.frame())
[10:33:58.850]    - tweaked: FALSE
[10:33:58.850]    - call: NULL
[10:33:58.851] plan(): nbrOfWorkers() = 1
[10:33:58.851] plan(): Setting new future strategy stack:
[10:33:58.852] List of future strategies:
[10:33:58.852] 1. sequential:
[10:33:58.852]    - args: function (..., envir = parent.frame())
[10:33:58.852]    - tweaked: FALSE
[10:33:58.852]    - call: plan(strategy)
[10:33:58.852] plan(): nbrOfWorkers() = 1
[10:33:58.852] SequentialFuture started (and completed)
[10:33:58.852] - Launch lazy future ... done
[10:33:58.852] run() for ‘SequentialFuture’ ... done
[10:33:58.853] getGlobalsAndPackages() ...
[10:33:58.853] Searching for globals...
[10:33:58.853] - globals found: [1] ‘{’
[10:33:58.853] Searching for globals ... DONE
[10:33:58.853] Resolving globals: FALSE
[10:33:58.854] 
[10:33:58.854] 
[10:33:58.854] getGlobalsAndPackages() ... DONE
[10:33:58.854] run() for ‘Future’ ...
[10:33:58.854] - state: ‘created’
[10:33:58.854] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:58.855] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:58.855] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:58.855]   - Field: ‘label’
[10:33:58.855]   - Field: ‘local’
[10:33:58.855]   - Field: ‘owner’
[10:33:58.855]   - Field: ‘envir’
[10:33:58.855]   - Field: ‘packages’
[10:33:58.855]   - Field: ‘gc’
[10:33:58.855]   - Field: ‘conditions’
[10:33:58.855]   - Field: ‘expr’
[10:33:58.855]   - Field: ‘uuid’
[10:33:58.856]   - Field: ‘seed’
[10:33:58.856]   - Field: ‘version’
[10:33:58.856]   - Field: ‘result’
[10:33:58.856]   - Field: ‘asynchronous’
[10:33:58.856]   - Field: ‘calls’
[10:33:58.856]   - Field: ‘globals’
[10:33:58.856]   - Field: ‘stdout’
[10:33:58.856]   - Field: ‘earlySignal’
[10:33:58.856]   - Field: ‘lazy’
[10:33:58.856]   - Field: ‘state’
[10:33:58.856] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:58.857] - Launch lazy future ...
[10:33:58.857] Packages needed by the future expression (n = 0): <none>
[10:33:58.857] Packages needed by future strategies (n = 0): <none>
[10:33:58.857] {
[10:33:58.857]     {
[10:33:58.857]         {
[10:33:58.857]             ...future.startTime <- base::Sys.time()
[10:33:58.857]             {
[10:33:58.857]                 {
[10:33:58.857]                   {
[10:33:58.857]                     base::local({
[10:33:58.857]                       has_future <- base::requireNamespace("future", 
[10:33:58.857]                         quietly = TRUE)
[10:33:58.857]                       if (has_future) {
[10:33:58.857]                         ns <- base::getNamespace("future")
[10:33:58.857]                         version <- ns[[".package"]][["version"]]
[10:33:58.857]                         if (is.null(version)) 
[10:33:58.857]                           version <- utils::packageVersion("future")
[10:33:58.857]                       }
[10:33:58.857]                       else {
[10:33:58.857]                         version <- NULL
[10:33:58.857]                       }
[10:33:58.857]                       if (!has_future || version < "1.8.0") {
[10:33:58.857]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:58.857]                           "", base::R.version$version.string), 
[10:33:58.857]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:58.857]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:58.857]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:58.857]                             "release", "version")], collapse = " "), 
[10:33:58.857]                           hostname = base::Sys.info()[["nodename"]])
[10:33:58.857]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:58.857]                           info)
[10:33:58.857]                         info <- base::paste(info, collapse = "; ")
[10:33:58.857]                         if (!has_future) {
[10:33:58.857]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:58.857]                             info)
[10:33:58.857]                         }
[10:33:58.857]                         else {
[10:33:58.857]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:58.857]                             info, version)
[10:33:58.857]                         }
[10:33:58.857]                         base::stop(msg)
[10:33:58.857]                       }
[10:33:58.857]                     })
[10:33:58.857]                   }
[10:33:58.857]                   ...future.strategy.old <- future::plan("list")
[10:33:58.857]                   options(future.plan = NULL)
[10:33:58.857]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.857]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:58.857]                 }
[10:33:58.857]                 ...future.workdir <- getwd()
[10:33:58.857]             }
[10:33:58.857]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:58.857]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:58.857]         }
[10:33:58.857]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:58.857]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:58.857]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:58.857]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:58.857]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:58.857]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:58.857]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:58.857]             base::names(...future.oldOptions))
[10:33:58.857]     }
[10:33:58.857]     if (FALSE) {
[10:33:58.857]     }
[10:33:58.857]     else {
[10:33:58.857]         if (TRUE) {
[10:33:58.857]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:58.857]                 open = "w")
[10:33:58.857]         }
[10:33:58.857]         else {
[10:33:58.857]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:58.857]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:58.857]         }
[10:33:58.857]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:58.857]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:58.857]             base::sink(type = "output", split = FALSE)
[10:33:58.857]             base::close(...future.stdout)
[10:33:58.857]         }, add = TRUE)
[10:33:58.857]     }
[10:33:58.857]     ...future.frame <- base::sys.nframe()
[10:33:58.857]     ...future.conditions <- base::list()
[10:33:58.857]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:58.857]     if (FALSE) {
[10:33:58.857]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:58.857]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:58.857]     }
[10:33:58.857]     ...future.result <- base::tryCatch({
[10:33:58.857]         base::withCallingHandlers({
[10:33:58.857]             ...future.value <- base::withVisible(base::local({
[10:33:58.857]                 2
[10:33:58.857]             }))
[10:33:58.857]             future::FutureResult(value = ...future.value$value, 
[10:33:58.857]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.857]                   ...future.rng), globalenv = if (FALSE) 
[10:33:58.857]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:58.857]                     ...future.globalenv.names))
[10:33:58.857]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:58.857]         }, condition = base::local({
[10:33:58.857]             c <- base::c
[10:33:58.857]             inherits <- base::inherits
[10:33:58.857]             invokeRestart <- base::invokeRestart
[10:33:58.857]             length <- base::length
[10:33:58.857]             list <- base::list
[10:33:58.857]             seq.int <- base::seq.int
[10:33:58.857]             signalCondition <- base::signalCondition
[10:33:58.857]             sys.calls <- base::sys.calls
[10:33:58.857]             `[[` <- base::`[[`
[10:33:58.857]             `+` <- base::`+`
[10:33:58.857]             `<<-` <- base::`<<-`
[10:33:58.857]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:58.857]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:58.857]                   3L)]
[10:33:58.857]             }
[10:33:58.857]             function(cond) {
[10:33:58.857]                 is_error <- inherits(cond, "error")
[10:33:58.857]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:58.857]                   NULL)
[10:33:58.857]                 if (is_error) {
[10:33:58.857]                   sessionInformation <- function() {
[10:33:58.857]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:58.857]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:58.857]                       search = base::search(), system = base::Sys.info())
[10:33:58.857]                   }
[10:33:58.857]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.857]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:58.857]                     cond$call), session = sessionInformation(), 
[10:33:58.857]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:58.857]                   signalCondition(cond)
[10:33:58.857]                 }
[10:33:58.857]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:58.857]                 "immediateCondition"))) {
[10:33:58.857]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:58.857]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.857]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:58.857]                   if (TRUE && !signal) {
[10:33:58.857]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.857]                     {
[10:33:58.857]                       inherits <- base::inherits
[10:33:58.857]                       invokeRestart <- base::invokeRestart
[10:33:58.857]                       is.null <- base::is.null
[10:33:58.857]                       muffled <- FALSE
[10:33:58.857]                       if (inherits(cond, "message")) {
[10:33:58.857]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.857]                         if (muffled) 
[10:33:58.857]                           invokeRestart("muffleMessage")
[10:33:58.857]                       }
[10:33:58.857]                       else if (inherits(cond, "warning")) {
[10:33:58.857]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.857]                         if (muffled) 
[10:33:58.857]                           invokeRestart("muffleWarning")
[10:33:58.857]                       }
[10:33:58.857]                       else if (inherits(cond, "condition")) {
[10:33:58.857]                         if (!is.null(pattern)) {
[10:33:58.857]                           computeRestarts <- base::computeRestarts
[10:33:58.857]                           grepl <- base::grepl
[10:33:58.857]                           restarts <- computeRestarts(cond)
[10:33:58.857]                           for (restart in restarts) {
[10:33:58.857]                             name <- restart$name
[10:33:58.857]                             if (is.null(name)) 
[10:33:58.857]                               next
[10:33:58.857]                             if (!grepl(pattern, name)) 
[10:33:58.857]                               next
[10:33:58.857]                             invokeRestart(restart)
[10:33:58.857]                             muffled <- TRUE
[10:33:58.857]                             break
[10:33:58.857]                           }
[10:33:58.857]                         }
[10:33:58.857]                       }
[10:33:58.857]                       invisible(muffled)
[10:33:58.857]                     }
[10:33:58.857]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.857]                   }
[10:33:58.857]                 }
[10:33:58.857]                 else {
[10:33:58.857]                   if (TRUE) {
[10:33:58.857]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.857]                     {
[10:33:58.857]                       inherits <- base::inherits
[10:33:58.857]                       invokeRestart <- base::invokeRestart
[10:33:58.857]                       is.null <- base::is.null
[10:33:58.857]                       muffled <- FALSE
[10:33:58.857]                       if (inherits(cond, "message")) {
[10:33:58.857]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.857]                         if (muffled) 
[10:33:58.857]                           invokeRestart("muffleMessage")
[10:33:58.857]                       }
[10:33:58.857]                       else if (inherits(cond, "warning")) {
[10:33:58.857]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.857]                         if (muffled) 
[10:33:58.857]                           invokeRestart("muffleWarning")
[10:33:58.857]                       }
[10:33:58.857]                       else if (inherits(cond, "condition")) {
[10:33:58.857]                         if (!is.null(pattern)) {
[10:33:58.857]                           computeRestarts <- base::computeRestarts
[10:33:58.857]                           grepl <- base::grepl
[10:33:58.857]                           restarts <- computeRestarts(cond)
[10:33:58.857]                           for (restart in restarts) {
[10:33:58.857]                             name <- restart$name
[10:33:58.857]                             if (is.null(name)) 
[10:33:58.857]                               next
[10:33:58.857]                             if (!grepl(pattern, name)) 
[10:33:58.857]                               next
[10:33:58.857]                             invokeRestart(restart)
[10:33:58.857]                             muffled <- TRUE
[10:33:58.857]                             break
[10:33:58.857]                           }
[10:33:58.857]                         }
[10:33:58.857]                       }
[10:33:58.857]                       invisible(muffled)
[10:33:58.857]                     }
[10:33:58.857]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.857]                   }
[10:33:58.857]                 }
[10:33:58.857]             }
[10:33:58.857]         }))
[10:33:58.857]     }, error = function(ex) {
[10:33:58.857]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:58.857]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.857]                 ...future.rng), started = ...future.startTime, 
[10:33:58.857]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:58.857]             version = "1.8"), class = "FutureResult")
[10:33:58.857]     }, finally = {
[10:33:58.857]         if (!identical(...future.workdir, getwd())) 
[10:33:58.857]             setwd(...future.workdir)
[10:33:58.857]         {
[10:33:58.857]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:58.857]                 ...future.oldOptions$nwarnings <- NULL
[10:33:58.857]             }
[10:33:58.857]             base::options(...future.oldOptions)
[10:33:58.857]             if (.Platform$OS.type == "windows") {
[10:33:58.857]                 old_names <- names(...future.oldEnvVars)
[10:33:58.857]                 envs <- base::Sys.getenv()
[10:33:58.857]                 names <- names(envs)
[10:33:58.857]                 common <- intersect(names, old_names)
[10:33:58.857]                 added <- setdiff(names, old_names)
[10:33:58.857]                 removed <- setdiff(old_names, names)
[10:33:58.857]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:58.857]                   envs[common]]
[10:33:58.857]                 NAMES <- toupper(changed)
[10:33:58.857]                 args <- list()
[10:33:58.857]                 for (kk in seq_along(NAMES)) {
[10:33:58.857]                   name <- changed[[kk]]
[10:33:58.857]                   NAME <- NAMES[[kk]]
[10:33:58.857]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.857]                     next
[10:33:58.857]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.857]                 }
[10:33:58.857]                 NAMES <- toupper(added)
[10:33:58.857]                 for (kk in seq_along(NAMES)) {
[10:33:58.857]                   name <- added[[kk]]
[10:33:58.857]                   NAME <- NAMES[[kk]]
[10:33:58.857]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.857]                     next
[10:33:58.857]                   args[[name]] <- ""
[10:33:58.857]                 }
[10:33:58.857]                 NAMES <- toupper(removed)
[10:33:58.857]                 for (kk in seq_along(NAMES)) {
[10:33:58.857]                   name <- removed[[kk]]
[10:33:58.857]                   NAME <- NAMES[[kk]]
[10:33:58.857]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.857]                     next
[10:33:58.857]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.857]                 }
[10:33:58.857]                 if (length(args) > 0) 
[10:33:58.857]                   base::do.call(base::Sys.setenv, args = args)
[10:33:58.857]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:58.857]             }
[10:33:58.857]             else {
[10:33:58.857]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:58.857]             }
[10:33:58.857]             {
[10:33:58.857]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:58.857]                   0L) {
[10:33:58.857]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:58.857]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:58.857]                   base::options(opts)
[10:33:58.857]                 }
[10:33:58.857]                 {
[10:33:58.857]                   {
[10:33:58.857]                     NULL
[10:33:58.857]                     RNGkind("Mersenne-Twister")
[10:33:58.857]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:58.857]                       inherits = FALSE)
[10:33:58.857]                   }
[10:33:58.857]                   options(future.plan = NULL)
[10:33:58.857]                   if (is.na(NA_character_)) 
[10:33:58.857]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.857]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:58.857]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:58.857]                     .init = FALSE)
[10:33:58.857]                 }
[10:33:58.857]             }
[10:33:58.857]         }
[10:33:58.857]     })
[10:33:58.857]     if (TRUE) {
[10:33:58.857]         base::sink(type = "output", split = FALSE)
[10:33:58.857]         if (TRUE) {
[10:33:58.857]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:58.857]         }
[10:33:58.857]         else {
[10:33:58.857]             ...future.result["stdout"] <- base::list(NULL)
[10:33:58.857]         }
[10:33:58.857]         base::close(...future.stdout)
[10:33:58.857]         ...future.stdout <- NULL
[10:33:58.857]     }
[10:33:58.857]     ...future.result$conditions <- ...future.conditions
[10:33:58.857]     ...future.result$finished <- base::Sys.time()
[10:33:58.857]     ...future.result
[10:33:58.857] }
[10:33:58.859] plan(): Setting new future strategy stack:
[10:33:58.859] List of future strategies:
[10:33:58.859] 1. sequential:
[10:33:58.859]    - args: function (..., envir = parent.frame())
[10:33:58.859]    - tweaked: FALSE
[10:33:58.859]    - call: NULL
[10:33:58.859] plan(): nbrOfWorkers() = 1
[10:33:58.860] plan(): Setting new future strategy stack:
[10:33:58.860] List of future strategies:
[10:33:58.860] 1. sequential:
[10:33:58.860]    - args: function (..., envir = parent.frame())
[10:33:58.860]    - tweaked: FALSE
[10:33:58.860]    - call: plan(strategy)
[10:33:58.861] plan(): nbrOfWorkers() = 1
[10:33:58.861] SequentialFuture started (and completed)
[10:33:58.861] - Launch lazy future ... done
[10:33:58.861] run() for ‘SequentialFuture’ ... done
[10:33:58.861] resolve() on list environment ...
[10:33:58.861]  recursive: 0
[10:33:58.862]  length: 3
[10:33:58.862]  elements: ‘a’, ‘b’, ‘c’
[10:33:58.862] resolved() for ‘SequentialFuture’ ...
[10:33:58.862] - state: ‘finished’
[10:33:58.862] - run: TRUE
[10:33:58.862] - result: ‘FutureResult’
[10:33:58.863] resolved() for ‘SequentialFuture’ ... done
[10:33:58.863] Future #1
[10:33:58.863]  length: 2 (resolved future 1)
[10:33:58.863] resolved() for ‘SequentialFuture’ ...
[10:33:58.863] - state: ‘finished’
[10:33:58.863] - run: TRUE
[10:33:58.863] - result: ‘FutureResult’
[10:33:58.863] resolved() for ‘SequentialFuture’ ... done
[10:33:58.863] Future #2
[10:33:58.863]  length: 1 (resolved future 2)
[10:33:58.863]  length: 0 (resolved future 3)
[10:33:58.864] resolve() on list environment ... DONE
[10:33:58.864] getGlobalsAndPackages() ...
[10:33:58.864] Searching for globals...
[10:33:58.865] - globals found: [1] ‘{’
[10:33:58.865] Searching for globals ... DONE
[10:33:58.865] Resolving globals: FALSE
[10:33:58.865] 
[10:33:58.865] 
[10:33:58.865] getGlobalsAndPackages() ... DONE
[10:33:58.865] run() for ‘Future’ ...
[10:33:58.866] - state: ‘created’
[10:33:58.866] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:58.866] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:58.866] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:58.866]   - Field: ‘label’
[10:33:58.866]   - Field: ‘local’
[10:33:58.866]   - Field: ‘owner’
[10:33:58.866]   - Field: ‘envir’
[10:33:58.866]   - Field: ‘packages’
[10:33:58.867]   - Field: ‘gc’
[10:33:58.867]   - Field: ‘conditions’
[10:33:58.867]   - Field: ‘expr’
[10:33:58.867]   - Field: ‘uuid’
[10:33:58.867]   - Field: ‘seed’
[10:33:58.867]   - Field: ‘version’
[10:33:58.867]   - Field: ‘result’
[10:33:58.867]   - Field: ‘asynchronous’
[10:33:58.867]   - Field: ‘calls’
[10:33:58.867]   - Field: ‘globals’
[10:33:58.867]   - Field: ‘stdout’
[10:33:58.868]   - Field: ‘earlySignal’
[10:33:58.868]   - Field: ‘lazy’
[10:33:58.869]   - Field: ‘state’
[10:33:58.869] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:58.869] - Launch lazy future ...
[10:33:58.869] Packages needed by the future expression (n = 0): <none>
[10:33:58.869] Packages needed by future strategies (n = 0): <none>
[10:33:58.870] {
[10:33:58.870]     {
[10:33:58.870]         {
[10:33:58.870]             ...future.startTime <- base::Sys.time()
[10:33:58.870]             {
[10:33:58.870]                 {
[10:33:58.870]                   {
[10:33:58.870]                     base::local({
[10:33:58.870]                       has_future <- base::requireNamespace("future", 
[10:33:58.870]                         quietly = TRUE)
[10:33:58.870]                       if (has_future) {
[10:33:58.870]                         ns <- base::getNamespace("future")
[10:33:58.870]                         version <- ns[[".package"]][["version"]]
[10:33:58.870]                         if (is.null(version)) 
[10:33:58.870]                           version <- utils::packageVersion("future")
[10:33:58.870]                       }
[10:33:58.870]                       else {
[10:33:58.870]                         version <- NULL
[10:33:58.870]                       }
[10:33:58.870]                       if (!has_future || version < "1.8.0") {
[10:33:58.870]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:58.870]                           "", base::R.version$version.string), 
[10:33:58.870]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:58.870]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:58.870]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:58.870]                             "release", "version")], collapse = " "), 
[10:33:58.870]                           hostname = base::Sys.info()[["nodename"]])
[10:33:58.870]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:58.870]                           info)
[10:33:58.870]                         info <- base::paste(info, collapse = "; ")
[10:33:58.870]                         if (!has_future) {
[10:33:58.870]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:58.870]                             info)
[10:33:58.870]                         }
[10:33:58.870]                         else {
[10:33:58.870]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:58.870]                             info, version)
[10:33:58.870]                         }
[10:33:58.870]                         base::stop(msg)
[10:33:58.870]                       }
[10:33:58.870]                     })
[10:33:58.870]                   }
[10:33:58.870]                   ...future.strategy.old <- future::plan("list")
[10:33:58.870]                   options(future.plan = NULL)
[10:33:58.870]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.870]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:58.870]                 }
[10:33:58.870]                 ...future.workdir <- getwd()
[10:33:58.870]             }
[10:33:58.870]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:58.870]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:58.870]         }
[10:33:58.870]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:58.870]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:58.870]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:58.870]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:58.870]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:58.870]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:58.870]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:58.870]             base::names(...future.oldOptions))
[10:33:58.870]     }
[10:33:58.870]     if (FALSE) {
[10:33:58.870]     }
[10:33:58.870]     else {
[10:33:58.870]         if (TRUE) {
[10:33:58.870]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:58.870]                 open = "w")
[10:33:58.870]         }
[10:33:58.870]         else {
[10:33:58.870]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:58.870]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:58.870]         }
[10:33:58.870]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:58.870]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:58.870]             base::sink(type = "output", split = FALSE)
[10:33:58.870]             base::close(...future.stdout)
[10:33:58.870]         }, add = TRUE)
[10:33:58.870]     }
[10:33:58.870]     ...future.frame <- base::sys.nframe()
[10:33:58.870]     ...future.conditions <- base::list()
[10:33:58.870]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:58.870]     if (FALSE) {
[10:33:58.870]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:58.870]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:58.870]     }
[10:33:58.870]     ...future.result <- base::tryCatch({
[10:33:58.870]         base::withCallingHandlers({
[10:33:58.870]             ...future.value <- base::withVisible(base::local({
[10:33:58.870]                 1
[10:33:58.870]             }))
[10:33:58.870]             future::FutureResult(value = ...future.value$value, 
[10:33:58.870]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.870]                   ...future.rng), globalenv = if (FALSE) 
[10:33:58.870]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:58.870]                     ...future.globalenv.names))
[10:33:58.870]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:58.870]         }, condition = base::local({
[10:33:58.870]             c <- base::c
[10:33:58.870]             inherits <- base::inherits
[10:33:58.870]             invokeRestart <- base::invokeRestart
[10:33:58.870]             length <- base::length
[10:33:58.870]             list <- base::list
[10:33:58.870]             seq.int <- base::seq.int
[10:33:58.870]             signalCondition <- base::signalCondition
[10:33:58.870]             sys.calls <- base::sys.calls
[10:33:58.870]             `[[` <- base::`[[`
[10:33:58.870]             `+` <- base::`+`
[10:33:58.870]             `<<-` <- base::`<<-`
[10:33:58.870]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:58.870]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:58.870]                   3L)]
[10:33:58.870]             }
[10:33:58.870]             function(cond) {
[10:33:58.870]                 is_error <- inherits(cond, "error")
[10:33:58.870]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:58.870]                   NULL)
[10:33:58.870]                 if (is_error) {
[10:33:58.870]                   sessionInformation <- function() {
[10:33:58.870]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:58.870]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:58.870]                       search = base::search(), system = base::Sys.info())
[10:33:58.870]                   }
[10:33:58.870]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.870]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:58.870]                     cond$call), session = sessionInformation(), 
[10:33:58.870]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:58.870]                   signalCondition(cond)
[10:33:58.870]                 }
[10:33:58.870]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:58.870]                 "immediateCondition"))) {
[10:33:58.870]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:58.870]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.870]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:58.870]                   if (TRUE && !signal) {
[10:33:58.870]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.870]                     {
[10:33:58.870]                       inherits <- base::inherits
[10:33:58.870]                       invokeRestart <- base::invokeRestart
[10:33:58.870]                       is.null <- base::is.null
[10:33:58.870]                       muffled <- FALSE
[10:33:58.870]                       if (inherits(cond, "message")) {
[10:33:58.870]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.870]                         if (muffled) 
[10:33:58.870]                           invokeRestart("muffleMessage")
[10:33:58.870]                       }
[10:33:58.870]                       else if (inherits(cond, "warning")) {
[10:33:58.870]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.870]                         if (muffled) 
[10:33:58.870]                           invokeRestart("muffleWarning")
[10:33:58.870]                       }
[10:33:58.870]                       else if (inherits(cond, "condition")) {
[10:33:58.870]                         if (!is.null(pattern)) {
[10:33:58.870]                           computeRestarts <- base::computeRestarts
[10:33:58.870]                           grepl <- base::grepl
[10:33:58.870]                           restarts <- computeRestarts(cond)
[10:33:58.870]                           for (restart in restarts) {
[10:33:58.870]                             name <- restart$name
[10:33:58.870]                             if (is.null(name)) 
[10:33:58.870]                               next
[10:33:58.870]                             if (!grepl(pattern, name)) 
[10:33:58.870]                               next
[10:33:58.870]                             invokeRestart(restart)
[10:33:58.870]                             muffled <- TRUE
[10:33:58.870]                             break
[10:33:58.870]                           }
[10:33:58.870]                         }
[10:33:58.870]                       }
[10:33:58.870]                       invisible(muffled)
[10:33:58.870]                     }
[10:33:58.870]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.870]                   }
[10:33:58.870]                 }
[10:33:58.870]                 else {
[10:33:58.870]                   if (TRUE) {
[10:33:58.870]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.870]                     {
[10:33:58.870]                       inherits <- base::inherits
[10:33:58.870]                       invokeRestart <- base::invokeRestart
[10:33:58.870]                       is.null <- base::is.null
[10:33:58.870]                       muffled <- FALSE
[10:33:58.870]                       if (inherits(cond, "message")) {
[10:33:58.870]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.870]                         if (muffled) 
[10:33:58.870]                           invokeRestart("muffleMessage")
[10:33:58.870]                       }
[10:33:58.870]                       else if (inherits(cond, "warning")) {
[10:33:58.870]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.870]                         if (muffled) 
[10:33:58.870]                           invokeRestart("muffleWarning")
[10:33:58.870]                       }
[10:33:58.870]                       else if (inherits(cond, "condition")) {
[10:33:58.870]                         if (!is.null(pattern)) {
[10:33:58.870]                           computeRestarts <- base::computeRestarts
[10:33:58.870]                           grepl <- base::grepl
[10:33:58.870]                           restarts <- computeRestarts(cond)
[10:33:58.870]                           for (restart in restarts) {
[10:33:58.870]                             name <- restart$name
[10:33:58.870]                             if (is.null(name)) 
[10:33:58.870]                               next
[10:33:58.870]                             if (!grepl(pattern, name)) 
[10:33:58.870]                               next
[10:33:58.870]                             invokeRestart(restart)
[10:33:58.870]                             muffled <- TRUE
[10:33:58.870]                             break
[10:33:58.870]                           }
[10:33:58.870]                         }
[10:33:58.870]                       }
[10:33:58.870]                       invisible(muffled)
[10:33:58.870]                     }
[10:33:58.870]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.870]                   }
[10:33:58.870]                 }
[10:33:58.870]             }
[10:33:58.870]         }))
[10:33:58.870]     }, error = function(ex) {
[10:33:58.870]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:58.870]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.870]                 ...future.rng), started = ...future.startTime, 
[10:33:58.870]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:58.870]             version = "1.8"), class = "FutureResult")
[10:33:58.870]     }, finally = {
[10:33:58.870]         if (!identical(...future.workdir, getwd())) 
[10:33:58.870]             setwd(...future.workdir)
[10:33:58.870]         {
[10:33:58.870]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:58.870]                 ...future.oldOptions$nwarnings <- NULL
[10:33:58.870]             }
[10:33:58.870]             base::options(...future.oldOptions)
[10:33:58.870]             if (.Platform$OS.type == "windows") {
[10:33:58.870]                 old_names <- names(...future.oldEnvVars)
[10:33:58.870]                 envs <- base::Sys.getenv()
[10:33:58.870]                 names <- names(envs)
[10:33:58.870]                 common <- intersect(names, old_names)
[10:33:58.870]                 added <- setdiff(names, old_names)
[10:33:58.870]                 removed <- setdiff(old_names, names)
[10:33:58.870]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:58.870]                   envs[common]]
[10:33:58.870]                 NAMES <- toupper(changed)
[10:33:58.870]                 args <- list()
[10:33:58.870]                 for (kk in seq_along(NAMES)) {
[10:33:58.870]                   name <- changed[[kk]]
[10:33:58.870]                   NAME <- NAMES[[kk]]
[10:33:58.870]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.870]                     next
[10:33:58.870]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.870]                 }
[10:33:58.870]                 NAMES <- toupper(added)
[10:33:58.870]                 for (kk in seq_along(NAMES)) {
[10:33:58.870]                   name <- added[[kk]]
[10:33:58.870]                   NAME <- NAMES[[kk]]
[10:33:58.870]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.870]                     next
[10:33:58.870]                   args[[name]] <- ""
[10:33:58.870]                 }
[10:33:58.870]                 NAMES <- toupper(removed)
[10:33:58.870]                 for (kk in seq_along(NAMES)) {
[10:33:58.870]                   name <- removed[[kk]]
[10:33:58.870]                   NAME <- NAMES[[kk]]
[10:33:58.870]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.870]                     next
[10:33:58.870]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.870]                 }
[10:33:58.870]                 if (length(args) > 0) 
[10:33:58.870]                   base::do.call(base::Sys.setenv, args = args)
[10:33:58.870]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:58.870]             }
[10:33:58.870]             else {
[10:33:58.870]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:58.870]             }
[10:33:58.870]             {
[10:33:58.870]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:58.870]                   0L) {
[10:33:58.870]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:58.870]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:58.870]                   base::options(opts)
[10:33:58.870]                 }
[10:33:58.870]                 {
[10:33:58.870]                   {
[10:33:58.870]                     NULL
[10:33:58.870]                     RNGkind("Mersenne-Twister")
[10:33:58.870]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:58.870]                       inherits = FALSE)
[10:33:58.870]                   }
[10:33:58.870]                   options(future.plan = NULL)
[10:33:58.870]                   if (is.na(NA_character_)) 
[10:33:58.870]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.870]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:58.870]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:58.870]                     .init = FALSE)
[10:33:58.870]                 }
[10:33:58.870]             }
[10:33:58.870]         }
[10:33:58.870]     })
[10:33:58.870]     if (TRUE) {
[10:33:58.870]         base::sink(type = "output", split = FALSE)
[10:33:58.870]         if (TRUE) {
[10:33:58.870]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:58.870]         }
[10:33:58.870]         else {
[10:33:58.870]             ...future.result["stdout"] <- base::list(NULL)
[10:33:58.870]         }
[10:33:58.870]         base::close(...future.stdout)
[10:33:58.870]         ...future.stdout <- NULL
[10:33:58.870]     }
[10:33:58.870]     ...future.result$conditions <- ...future.conditions
[10:33:58.870]     ...future.result$finished <- base::Sys.time()
[10:33:58.870]     ...future.result
[10:33:58.870] }
[10:33:58.872] plan(): Setting new future strategy stack:
[10:33:58.872] List of future strategies:
[10:33:58.872] 1. sequential:
[10:33:58.872]    - args: function (..., envir = parent.frame())
[10:33:58.872]    - tweaked: FALSE
[10:33:58.872]    - call: NULL
[10:33:58.872] plan(): nbrOfWorkers() = 1
[10:33:58.873] plan(): Setting new future strategy stack:
[10:33:58.873] List of future strategies:
[10:33:58.873] 1. sequential:
[10:33:58.873]    - args: function (..., envir = parent.frame())
[10:33:58.873]    - tweaked: FALSE
[10:33:58.873]    - call: plan(strategy)
[10:33:58.873] plan(): nbrOfWorkers() = 1
[10:33:58.873] SequentialFuture started (and completed)
[10:33:58.873] - Launch lazy future ... done
[10:33:58.874] run() for ‘SequentialFuture’ ... done
[10:33:58.874] getGlobalsAndPackages() ...
[10:33:58.874] Searching for globals...
[10:33:58.875] - globals found: [2] ‘{’, ‘Sys.sleep’
[10:33:58.875] Searching for globals ... DONE
[10:33:58.875] Resolving globals: FALSE
[10:33:58.875] 
[10:33:58.875] 
[10:33:58.875] getGlobalsAndPackages() ... DONE
[10:33:58.876] run() for ‘Future’ ...
[10:33:58.876] - state: ‘created’
[10:33:58.876] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:58.876] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:58.876] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:58.876]   - Field: ‘label’
[10:33:58.876]   - Field: ‘local’
[10:33:58.877]   - Field: ‘owner’
[10:33:58.877]   - Field: ‘envir’
[10:33:58.877]   - Field: ‘packages’
[10:33:58.877]   - Field: ‘gc’
[10:33:58.877]   - Field: ‘conditions’
[10:33:58.877]   - Field: ‘expr’
[10:33:58.877]   - Field: ‘uuid’
[10:33:58.877]   - Field: ‘seed’
[10:33:58.877]   - Field: ‘version’
[10:33:58.877]   - Field: ‘result’
[10:33:58.877]   - Field: ‘asynchronous’
[10:33:58.878]   - Field: ‘calls’
[10:33:58.878]   - Field: ‘globals’
[10:33:58.878]   - Field: ‘stdout’
[10:33:58.878]   - Field: ‘earlySignal’
[10:33:58.878]   - Field: ‘lazy’
[10:33:58.878]   - Field: ‘state’
[10:33:58.878] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:58.878] - Launch lazy future ...
[10:33:58.878] Packages needed by the future expression (n = 0): <none>
[10:33:58.878] Packages needed by future strategies (n = 0): <none>
[10:33:58.879] {
[10:33:58.879]     {
[10:33:58.879]         {
[10:33:58.879]             ...future.startTime <- base::Sys.time()
[10:33:58.879]             {
[10:33:58.879]                 {
[10:33:58.879]                   {
[10:33:58.879]                     base::local({
[10:33:58.879]                       has_future <- base::requireNamespace("future", 
[10:33:58.879]                         quietly = TRUE)
[10:33:58.879]                       if (has_future) {
[10:33:58.879]                         ns <- base::getNamespace("future")
[10:33:58.879]                         version <- ns[[".package"]][["version"]]
[10:33:58.879]                         if (is.null(version)) 
[10:33:58.879]                           version <- utils::packageVersion("future")
[10:33:58.879]                       }
[10:33:58.879]                       else {
[10:33:58.879]                         version <- NULL
[10:33:58.879]                       }
[10:33:58.879]                       if (!has_future || version < "1.8.0") {
[10:33:58.879]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:58.879]                           "", base::R.version$version.string), 
[10:33:58.879]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:58.879]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:58.879]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:58.879]                             "release", "version")], collapse = " "), 
[10:33:58.879]                           hostname = base::Sys.info()[["nodename"]])
[10:33:58.879]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:58.879]                           info)
[10:33:58.879]                         info <- base::paste(info, collapse = "; ")
[10:33:58.879]                         if (!has_future) {
[10:33:58.879]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:58.879]                             info)
[10:33:58.879]                         }
[10:33:58.879]                         else {
[10:33:58.879]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:58.879]                             info, version)
[10:33:58.879]                         }
[10:33:58.879]                         base::stop(msg)
[10:33:58.879]                       }
[10:33:58.879]                     })
[10:33:58.879]                   }
[10:33:58.879]                   ...future.strategy.old <- future::plan("list")
[10:33:58.879]                   options(future.plan = NULL)
[10:33:58.879]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.879]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:58.879]                 }
[10:33:58.879]                 ...future.workdir <- getwd()
[10:33:58.879]             }
[10:33:58.879]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:58.879]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:58.879]         }
[10:33:58.879]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:58.879]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:58.879]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:58.879]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:58.879]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:58.879]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:58.879]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:58.879]             base::names(...future.oldOptions))
[10:33:58.879]     }
[10:33:58.879]     if (FALSE) {
[10:33:58.879]     }
[10:33:58.879]     else {
[10:33:58.879]         if (TRUE) {
[10:33:58.879]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:58.879]                 open = "w")
[10:33:58.879]         }
[10:33:58.879]         else {
[10:33:58.879]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:58.879]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:58.879]         }
[10:33:58.879]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:58.879]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:58.879]             base::sink(type = "output", split = FALSE)
[10:33:58.879]             base::close(...future.stdout)
[10:33:58.879]         }, add = TRUE)
[10:33:58.879]     }
[10:33:58.879]     ...future.frame <- base::sys.nframe()
[10:33:58.879]     ...future.conditions <- base::list()
[10:33:58.879]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:58.879]     if (FALSE) {
[10:33:58.879]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:58.879]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:58.879]     }
[10:33:58.879]     ...future.result <- base::tryCatch({
[10:33:58.879]         base::withCallingHandlers({
[10:33:58.879]             ...future.value <- base::withVisible(base::local({
[10:33:58.879]                 Sys.sleep(0.5)
[10:33:58.879]                 2
[10:33:58.879]             }))
[10:33:58.879]             future::FutureResult(value = ...future.value$value, 
[10:33:58.879]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.879]                   ...future.rng), globalenv = if (FALSE) 
[10:33:58.879]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:58.879]                     ...future.globalenv.names))
[10:33:58.879]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:58.879]         }, condition = base::local({
[10:33:58.879]             c <- base::c
[10:33:58.879]             inherits <- base::inherits
[10:33:58.879]             invokeRestart <- base::invokeRestart
[10:33:58.879]             length <- base::length
[10:33:58.879]             list <- base::list
[10:33:58.879]             seq.int <- base::seq.int
[10:33:58.879]             signalCondition <- base::signalCondition
[10:33:58.879]             sys.calls <- base::sys.calls
[10:33:58.879]             `[[` <- base::`[[`
[10:33:58.879]             `+` <- base::`+`
[10:33:58.879]             `<<-` <- base::`<<-`
[10:33:58.879]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:58.879]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:58.879]                   3L)]
[10:33:58.879]             }
[10:33:58.879]             function(cond) {
[10:33:58.879]                 is_error <- inherits(cond, "error")
[10:33:58.879]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:58.879]                   NULL)
[10:33:58.879]                 if (is_error) {
[10:33:58.879]                   sessionInformation <- function() {
[10:33:58.879]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:58.879]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:58.879]                       search = base::search(), system = base::Sys.info())
[10:33:58.879]                   }
[10:33:58.879]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.879]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:58.879]                     cond$call), session = sessionInformation(), 
[10:33:58.879]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:58.879]                   signalCondition(cond)
[10:33:58.879]                 }
[10:33:58.879]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:58.879]                 "immediateCondition"))) {
[10:33:58.879]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:58.879]                   ...future.conditions[[length(...future.conditions) + 
[10:33:58.879]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:58.879]                   if (TRUE && !signal) {
[10:33:58.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.879]                     {
[10:33:58.879]                       inherits <- base::inherits
[10:33:58.879]                       invokeRestart <- base::invokeRestart
[10:33:58.879]                       is.null <- base::is.null
[10:33:58.879]                       muffled <- FALSE
[10:33:58.879]                       if (inherits(cond, "message")) {
[10:33:58.879]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.879]                         if (muffled) 
[10:33:58.879]                           invokeRestart("muffleMessage")
[10:33:58.879]                       }
[10:33:58.879]                       else if (inherits(cond, "warning")) {
[10:33:58.879]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.879]                         if (muffled) 
[10:33:58.879]                           invokeRestart("muffleWarning")
[10:33:58.879]                       }
[10:33:58.879]                       else if (inherits(cond, "condition")) {
[10:33:58.879]                         if (!is.null(pattern)) {
[10:33:58.879]                           computeRestarts <- base::computeRestarts
[10:33:58.879]                           grepl <- base::grepl
[10:33:58.879]                           restarts <- computeRestarts(cond)
[10:33:58.879]                           for (restart in restarts) {
[10:33:58.879]                             name <- restart$name
[10:33:58.879]                             if (is.null(name)) 
[10:33:58.879]                               next
[10:33:58.879]                             if (!grepl(pattern, name)) 
[10:33:58.879]                               next
[10:33:58.879]                             invokeRestart(restart)
[10:33:58.879]                             muffled <- TRUE
[10:33:58.879]                             break
[10:33:58.879]                           }
[10:33:58.879]                         }
[10:33:58.879]                       }
[10:33:58.879]                       invisible(muffled)
[10:33:58.879]                     }
[10:33:58.879]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.879]                   }
[10:33:58.879]                 }
[10:33:58.879]                 else {
[10:33:58.879]                   if (TRUE) {
[10:33:58.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:58.879]                     {
[10:33:58.879]                       inherits <- base::inherits
[10:33:58.879]                       invokeRestart <- base::invokeRestart
[10:33:58.879]                       is.null <- base::is.null
[10:33:58.879]                       muffled <- FALSE
[10:33:58.879]                       if (inherits(cond, "message")) {
[10:33:58.879]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:58.879]                         if (muffled) 
[10:33:58.879]                           invokeRestart("muffleMessage")
[10:33:58.879]                       }
[10:33:58.879]                       else if (inherits(cond, "warning")) {
[10:33:58.879]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:58.879]                         if (muffled) 
[10:33:58.879]                           invokeRestart("muffleWarning")
[10:33:58.879]                       }
[10:33:58.879]                       else if (inherits(cond, "condition")) {
[10:33:58.879]                         if (!is.null(pattern)) {
[10:33:58.879]                           computeRestarts <- base::computeRestarts
[10:33:58.879]                           grepl <- base::grepl
[10:33:58.879]                           restarts <- computeRestarts(cond)
[10:33:58.879]                           for (restart in restarts) {
[10:33:58.879]                             name <- restart$name
[10:33:58.879]                             if (is.null(name)) 
[10:33:58.879]                               next
[10:33:58.879]                             if (!grepl(pattern, name)) 
[10:33:58.879]                               next
[10:33:58.879]                             invokeRestart(restart)
[10:33:58.879]                             muffled <- TRUE
[10:33:58.879]                             break
[10:33:58.879]                           }
[10:33:58.879]                         }
[10:33:58.879]                       }
[10:33:58.879]                       invisible(muffled)
[10:33:58.879]                     }
[10:33:58.879]                     muffleCondition(cond, pattern = "^muffle")
[10:33:58.879]                   }
[10:33:58.879]                 }
[10:33:58.879]             }
[10:33:58.879]         }))
[10:33:58.879]     }, error = function(ex) {
[10:33:58.879]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:58.879]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:58.879]                 ...future.rng), started = ...future.startTime, 
[10:33:58.879]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:58.879]             version = "1.8"), class = "FutureResult")
[10:33:58.879]     }, finally = {
[10:33:58.879]         if (!identical(...future.workdir, getwd())) 
[10:33:58.879]             setwd(...future.workdir)
[10:33:58.879]         {
[10:33:58.879]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:58.879]                 ...future.oldOptions$nwarnings <- NULL
[10:33:58.879]             }
[10:33:58.879]             base::options(...future.oldOptions)
[10:33:58.879]             if (.Platform$OS.type == "windows") {
[10:33:58.879]                 old_names <- names(...future.oldEnvVars)
[10:33:58.879]                 envs <- base::Sys.getenv()
[10:33:58.879]                 names <- names(envs)
[10:33:58.879]                 common <- intersect(names, old_names)
[10:33:58.879]                 added <- setdiff(names, old_names)
[10:33:58.879]                 removed <- setdiff(old_names, names)
[10:33:58.879]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:58.879]                   envs[common]]
[10:33:58.879]                 NAMES <- toupper(changed)
[10:33:58.879]                 args <- list()
[10:33:58.879]                 for (kk in seq_along(NAMES)) {
[10:33:58.879]                   name <- changed[[kk]]
[10:33:58.879]                   NAME <- NAMES[[kk]]
[10:33:58.879]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.879]                     next
[10:33:58.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.879]                 }
[10:33:58.879]                 NAMES <- toupper(added)
[10:33:58.879]                 for (kk in seq_along(NAMES)) {
[10:33:58.879]                   name <- added[[kk]]
[10:33:58.879]                   NAME <- NAMES[[kk]]
[10:33:58.879]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.879]                     next
[10:33:58.879]                   args[[name]] <- ""
[10:33:58.879]                 }
[10:33:58.879]                 NAMES <- toupper(removed)
[10:33:58.879]                 for (kk in seq_along(NAMES)) {
[10:33:58.879]                   name <- removed[[kk]]
[10:33:58.879]                   NAME <- NAMES[[kk]]
[10:33:58.879]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:58.879]                     next
[10:33:58.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:58.879]                 }
[10:33:58.879]                 if (length(args) > 0) 
[10:33:58.879]                   base::do.call(base::Sys.setenv, args = args)
[10:33:58.879]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:58.879]             }
[10:33:58.879]             else {
[10:33:58.879]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:58.879]             }
[10:33:58.879]             {
[10:33:58.879]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:58.879]                   0L) {
[10:33:58.879]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:58.879]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:58.879]                   base::options(opts)
[10:33:58.879]                 }
[10:33:58.879]                 {
[10:33:58.879]                   {
[10:33:58.879]                     NULL
[10:33:58.879]                     RNGkind("Mersenne-Twister")
[10:33:58.879]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:58.879]                       inherits = FALSE)
[10:33:58.879]                   }
[10:33:58.879]                   options(future.plan = NULL)
[10:33:58.879]                   if (is.na(NA_character_)) 
[10:33:58.879]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:58.879]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:58.879]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:58.879]                     .init = FALSE)
[10:33:58.879]                 }
[10:33:58.879]             }
[10:33:58.879]         }
[10:33:58.879]     })
[10:33:58.879]     if (TRUE) {
[10:33:58.879]         base::sink(type = "output", split = FALSE)
[10:33:58.879]         if (TRUE) {
[10:33:58.879]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:58.879]         }
[10:33:58.879]         else {
[10:33:58.879]             ...future.result["stdout"] <- base::list(NULL)
[10:33:58.879]         }
[10:33:58.879]         base::close(...future.stdout)
[10:33:58.879]         ...future.stdout <- NULL
[10:33:58.879]     }
[10:33:58.879]     ...future.result$conditions <- ...future.conditions
[10:33:58.879]     ...future.result$finished <- base::Sys.time()
[10:33:58.879]     ...future.result
[10:33:58.879] }
[10:33:58.880] plan(): Setting new future strategy stack:
[10:33:58.881] List of future strategies:
[10:33:58.881] 1. sequential:
[10:33:58.881]    - args: function (..., envir = parent.frame())
[10:33:58.881]    - tweaked: FALSE
[10:33:58.881]    - call: NULL
[10:33:58.881] plan(): nbrOfWorkers() = 1
[10:33:59.382] plan(): Setting new future strategy stack:
[10:33:59.383] List of future strategies:
[10:33:59.383] 1. sequential:
[10:33:59.383]    - args: function (..., envir = parent.frame())
[10:33:59.383]    - tweaked: FALSE
[10:33:59.383]    - call: plan(strategy)
[10:33:59.383] plan(): nbrOfWorkers() = 1
[10:33:59.383] SequentialFuture started (and completed)
[10:33:59.383] - Launch lazy future ... done
[10:33:59.384] run() for ‘SequentialFuture’ ... done
[10:33:59.384] getGlobalsAndPackages() ...
[10:33:59.384] Searching for globals...
[10:33:59.385] - globals found: [1] ‘{’
[10:33:59.385] Searching for globals ... DONE
[10:33:59.385] Resolving globals: FALSE
[10:33:59.385] 
[10:33:59.385] 
[10:33:59.385] getGlobalsAndPackages() ... DONE
[10:33:59.386] run() for ‘Future’ ...
[10:33:59.386] - state: ‘created’
[10:33:59.386] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:33:59.386] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:33:59.386] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:33:59.386]   - Field: ‘label’
[10:33:59.387]   - Field: ‘local’
[10:33:59.387]   - Field: ‘owner’
[10:33:59.387]   - Field: ‘envir’
[10:33:59.387]   - Field: ‘packages’
[10:33:59.387]   - Field: ‘gc’
[10:33:59.387]   - Field: ‘conditions’
[10:33:59.387]   - Field: ‘expr’
[10:33:59.387]   - Field: ‘uuid’
[10:33:59.387]   - Field: ‘seed’
[10:33:59.387]   - Field: ‘version’
[10:33:59.387]   - Field: ‘result’
[10:33:59.388]   - Field: ‘asynchronous’
[10:33:59.388]   - Field: ‘calls’
[10:33:59.388]   - Field: ‘globals’
[10:33:59.388]   - Field: ‘stdout’
[10:33:59.388]   - Field: ‘earlySignal’
[10:33:59.388]   - Field: ‘lazy’
[10:33:59.388]   - Field: ‘state’
[10:33:59.388] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:33:59.388] - Launch lazy future ...
[10:33:59.389] Packages needed by the future expression (n = 0): <none>
[10:33:59.389] Packages needed by future strategies (n = 0): <none>
[10:33:59.389] {
[10:33:59.389]     {
[10:33:59.389]         {
[10:33:59.389]             ...future.startTime <- base::Sys.time()
[10:33:59.389]             {
[10:33:59.389]                 {
[10:33:59.389]                   {
[10:33:59.389]                     base::local({
[10:33:59.389]                       has_future <- base::requireNamespace("future", 
[10:33:59.389]                         quietly = TRUE)
[10:33:59.389]                       if (has_future) {
[10:33:59.389]                         ns <- base::getNamespace("future")
[10:33:59.389]                         version <- ns[[".package"]][["version"]]
[10:33:59.389]                         if (is.null(version)) 
[10:33:59.389]                           version <- utils::packageVersion("future")
[10:33:59.389]                       }
[10:33:59.389]                       else {
[10:33:59.389]                         version <- NULL
[10:33:59.389]                       }
[10:33:59.389]                       if (!has_future || version < "1.8.0") {
[10:33:59.389]                         info <- base::c(r_version = base::gsub("R version ", 
[10:33:59.389]                           "", base::R.version$version.string), 
[10:33:59.389]                           platform = base::sprintf("%s (%s-bit)", 
[10:33:59.389]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:59.389]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:59.389]                             "release", "version")], collapse = " "), 
[10:33:59.389]                           hostname = base::Sys.info()[["nodename"]])
[10:33:59.389]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:33:59.389]                           info)
[10:33:59.389]                         info <- base::paste(info, collapse = "; ")
[10:33:59.389]                         if (!has_future) {
[10:33:59.389]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:59.389]                             info)
[10:33:59.389]                         }
[10:33:59.389]                         else {
[10:33:59.389]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:59.389]                             info, version)
[10:33:59.389]                         }
[10:33:59.389]                         base::stop(msg)
[10:33:59.389]                       }
[10:33:59.389]                     })
[10:33:59.389]                   }
[10:33:59.389]                   ...future.strategy.old <- future::plan("list")
[10:33:59.389]                   options(future.plan = NULL)
[10:33:59.389]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:59.389]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:59.389]                 }
[10:33:59.389]                 ...future.workdir <- getwd()
[10:33:59.389]             }
[10:33:59.389]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:59.389]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:59.389]         }
[10:33:59.389]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:59.389]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:59.389]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:59.389]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:59.389]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:59.389]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:59.389]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:59.389]             base::names(...future.oldOptions))
[10:33:59.389]     }
[10:33:59.389]     if (FALSE) {
[10:33:59.389]     }
[10:33:59.389]     else {
[10:33:59.389]         if (TRUE) {
[10:33:59.389]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:59.389]                 open = "w")
[10:33:59.389]         }
[10:33:59.389]         else {
[10:33:59.389]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:59.389]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:59.389]         }
[10:33:59.389]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:59.389]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:59.389]             base::sink(type = "output", split = FALSE)
[10:33:59.389]             base::close(...future.stdout)
[10:33:59.389]         }, add = TRUE)
[10:33:59.389]     }
[10:33:59.389]     ...future.frame <- base::sys.nframe()
[10:33:59.389]     ...future.conditions <- base::list()
[10:33:59.389]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:59.389]     if (FALSE) {
[10:33:59.389]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:59.389]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:59.389]     }
[10:33:59.389]     ...future.result <- base::tryCatch({
[10:33:59.389]         base::withCallingHandlers({
[10:33:59.389]             ...future.value <- base::withVisible(base::local({
[10:33:59.389]                 3
[10:33:59.389]             }))
[10:33:59.389]             future::FutureResult(value = ...future.value$value, 
[10:33:59.389]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:59.389]                   ...future.rng), globalenv = if (FALSE) 
[10:33:59.389]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:59.389]                     ...future.globalenv.names))
[10:33:59.389]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:59.389]         }, condition = base::local({
[10:33:59.389]             c <- base::c
[10:33:59.389]             inherits <- base::inherits
[10:33:59.389]             invokeRestart <- base::invokeRestart
[10:33:59.389]             length <- base::length
[10:33:59.389]             list <- base::list
[10:33:59.389]             seq.int <- base::seq.int
[10:33:59.389]             signalCondition <- base::signalCondition
[10:33:59.389]             sys.calls <- base::sys.calls
[10:33:59.389]             `[[` <- base::`[[`
[10:33:59.389]             `+` <- base::`+`
[10:33:59.389]             `<<-` <- base::`<<-`
[10:33:59.389]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:59.389]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:59.389]                   3L)]
[10:33:59.389]             }
[10:33:59.389]             function(cond) {
[10:33:59.389]                 is_error <- inherits(cond, "error")
[10:33:59.389]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:59.389]                   NULL)
[10:33:59.389]                 if (is_error) {
[10:33:59.389]                   sessionInformation <- function() {
[10:33:59.389]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:59.389]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:59.389]                       search = base::search(), system = base::Sys.info())
[10:33:59.389]                   }
[10:33:59.389]                   ...future.conditions[[length(...future.conditions) + 
[10:33:59.389]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:59.389]                     cond$call), session = sessionInformation(), 
[10:33:59.389]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:59.389]                   signalCondition(cond)
[10:33:59.389]                 }
[10:33:59.389]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:59.389]                 "immediateCondition"))) {
[10:33:59.389]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:59.389]                   ...future.conditions[[length(...future.conditions) + 
[10:33:59.389]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:59.389]                   if (TRUE && !signal) {
[10:33:59.389]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:59.389]                     {
[10:33:59.389]                       inherits <- base::inherits
[10:33:59.389]                       invokeRestart <- base::invokeRestart
[10:33:59.389]                       is.null <- base::is.null
[10:33:59.389]                       muffled <- FALSE
[10:33:59.389]                       if (inherits(cond, "message")) {
[10:33:59.389]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:59.389]                         if (muffled) 
[10:33:59.389]                           invokeRestart("muffleMessage")
[10:33:59.389]                       }
[10:33:59.389]                       else if (inherits(cond, "warning")) {
[10:33:59.389]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:59.389]                         if (muffled) 
[10:33:59.389]                           invokeRestart("muffleWarning")
[10:33:59.389]                       }
[10:33:59.389]                       else if (inherits(cond, "condition")) {
[10:33:59.389]                         if (!is.null(pattern)) {
[10:33:59.389]                           computeRestarts <- base::computeRestarts
[10:33:59.389]                           grepl <- base::grepl
[10:33:59.389]                           restarts <- computeRestarts(cond)
[10:33:59.389]                           for (restart in restarts) {
[10:33:59.389]                             name <- restart$name
[10:33:59.389]                             if (is.null(name)) 
[10:33:59.389]                               next
[10:33:59.389]                             if (!grepl(pattern, name)) 
[10:33:59.389]                               next
[10:33:59.389]                             invokeRestart(restart)
[10:33:59.389]                             muffled <- TRUE
[10:33:59.389]                             break
[10:33:59.389]                           }
[10:33:59.389]                         }
[10:33:59.389]                       }
[10:33:59.389]                       invisible(muffled)
[10:33:59.389]                     }
[10:33:59.389]                     muffleCondition(cond, pattern = "^muffle")
[10:33:59.389]                   }
[10:33:59.389]                 }
[10:33:59.389]                 else {
[10:33:59.389]                   if (TRUE) {
[10:33:59.389]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:59.389]                     {
[10:33:59.389]                       inherits <- base::inherits
[10:33:59.389]                       invokeRestart <- base::invokeRestart
[10:33:59.389]                       is.null <- base::is.null
[10:33:59.389]                       muffled <- FALSE
[10:33:59.389]                       if (inherits(cond, "message")) {
[10:33:59.389]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:59.389]                         if (muffled) 
[10:33:59.389]                           invokeRestart("muffleMessage")
[10:33:59.389]                       }
[10:33:59.389]                       else if (inherits(cond, "warning")) {
[10:33:59.389]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:59.389]                         if (muffled) 
[10:33:59.389]                           invokeRestart("muffleWarning")
[10:33:59.389]                       }
[10:33:59.389]                       else if (inherits(cond, "condition")) {
[10:33:59.389]                         if (!is.null(pattern)) {
[10:33:59.389]                           computeRestarts <- base::computeRestarts
[10:33:59.389]                           grepl <- base::grepl
[10:33:59.389]                           restarts <- computeRestarts(cond)
[10:33:59.389]                           for (restart in restarts) {
[10:33:59.389]                             name <- restart$name
[10:33:59.389]                             if (is.null(name)) 
[10:33:59.389]                               next
[10:33:59.389]                             if (!grepl(pattern, name)) 
[10:33:59.389]                               next
[10:33:59.389]                             invokeRestart(restart)
[10:33:59.389]                             muffled <- TRUE
[10:33:59.389]                             break
[10:33:59.389]                           }
[10:33:59.389]                         }
[10:33:59.389]                       }
[10:33:59.389]                       invisible(muffled)
[10:33:59.389]                     }
[10:33:59.389]                     muffleCondition(cond, pattern = "^muffle")
[10:33:59.389]                   }
[10:33:59.389]                 }
[10:33:59.389]             }
[10:33:59.389]         }))
[10:33:59.389]     }, error = function(ex) {
[10:33:59.389]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:59.389]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:59.389]                 ...future.rng), started = ...future.startTime, 
[10:33:59.389]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:59.389]             version = "1.8"), class = "FutureResult")
[10:33:59.389]     }, finally = {
[10:33:59.389]         if (!identical(...future.workdir, getwd())) 
[10:33:59.389]             setwd(...future.workdir)
[10:33:59.389]         {
[10:33:59.389]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:59.389]                 ...future.oldOptions$nwarnings <- NULL
[10:33:59.389]             }
[10:33:59.389]             base::options(...future.oldOptions)
[10:33:59.389]             if (.Platform$OS.type == "windows") {
[10:33:59.389]                 old_names <- names(...future.oldEnvVars)
[10:33:59.389]                 envs <- base::Sys.getenv()
[10:33:59.389]                 names <- names(envs)
[10:33:59.389]                 common <- intersect(names, old_names)
[10:33:59.389]                 added <- setdiff(names, old_names)
[10:33:59.389]                 removed <- setdiff(old_names, names)
[10:33:59.389]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:59.389]                   envs[common]]
[10:33:59.389]                 NAMES <- toupper(changed)
[10:33:59.389]                 args <- list()
[10:33:59.389]                 for (kk in seq_along(NAMES)) {
[10:33:59.389]                   name <- changed[[kk]]
[10:33:59.389]                   NAME <- NAMES[[kk]]
[10:33:59.389]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:59.389]                     next
[10:33:59.389]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:59.389]                 }
[10:33:59.389]                 NAMES <- toupper(added)
[10:33:59.389]                 for (kk in seq_along(NAMES)) {
[10:33:59.389]                   name <- added[[kk]]
[10:33:59.389]                   NAME <- NAMES[[kk]]
[10:33:59.389]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:59.389]                     next
[10:33:59.389]                   args[[name]] <- ""
[10:33:59.389]                 }
[10:33:59.389]                 NAMES <- toupper(removed)
[10:33:59.389]                 for (kk in seq_along(NAMES)) {
[10:33:59.389]                   name <- removed[[kk]]
[10:33:59.389]                   NAME <- NAMES[[kk]]
[10:33:59.389]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:59.389]                     next
[10:33:59.389]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:59.389]                 }
[10:33:59.389]                 if (length(args) > 0) 
[10:33:59.389]                   base::do.call(base::Sys.setenv, args = args)
[10:33:59.389]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:59.389]             }
[10:33:59.389]             else {
[10:33:59.389]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:59.389]             }
[10:33:59.389]             {
[10:33:59.389]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:59.389]                   0L) {
[10:33:59.389]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:59.389]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:59.389]                   base::options(opts)
[10:33:59.389]                 }
[10:33:59.389]                 {
[10:33:59.389]                   {
[10:33:59.389]                     NULL
[10:33:59.389]                     RNGkind("Mersenne-Twister")
[10:33:59.389]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:33:59.389]                       inherits = FALSE)
[10:33:59.389]                   }
[10:33:59.389]                   options(future.plan = NULL)
[10:33:59.389]                   if (is.na(NA_character_)) 
[10:33:59.389]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:59.389]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:59.389]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:59.389]                     .init = FALSE)
[10:33:59.389]                 }
[10:33:59.389]             }
[10:33:59.389]         }
[10:33:59.389]     })
[10:33:59.389]     if (TRUE) {
[10:33:59.389]         base::sink(type = "output", split = FALSE)
[10:33:59.389]         if (TRUE) {
[10:33:59.389]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:59.389]         }
[10:33:59.389]         else {
[10:33:59.389]             ...future.result["stdout"] <- base::list(NULL)
[10:33:59.389]         }
[10:33:59.389]         base::close(...future.stdout)
[10:33:59.389]         ...future.stdout <- NULL
[10:33:59.389]     }
[10:33:59.389]     ...future.result$conditions <- ...future.conditions
[10:33:59.389]     ...future.result$finished <- base::Sys.time()
[10:33:59.389]     ...future.result
[10:33:59.389] }
[10:33:59.391] plan(): Setting new future strategy stack:
[10:33:59.391] List of future strategies:
[10:33:59.391] 1. sequential:
[10:33:59.391]    - args: function (..., envir = parent.frame())
[10:33:59.391]    - tweaked: FALSE
[10:33:59.391]    - call: NULL
[10:33:59.391] plan(): nbrOfWorkers() = 1
[10:33:59.392] plan(): Setting new future strategy stack:
[10:33:59.392] List of future strategies:
[10:33:59.392] 1. sequential:
[10:33:59.392]    - args: function (..., envir = parent.frame())
[10:33:59.392]    - tweaked: FALSE
[10:33:59.392]    - call: plan(strategy)
[10:33:59.393] plan(): nbrOfWorkers() = 1
[10:33:59.393] SequentialFuture started (and completed)
[10:33:59.393] - Launch lazy future ... done
[10:33:59.393] run() for ‘SequentialFuture’ ... done
[10:33:59.394] resolve() on list environment ...
[10:33:59.394]  recursive: 0
[10:33:59.394]  length: 4
[10:33:59.394]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:33:59.395] resolved() for ‘SequentialFuture’ ...
[10:33:59.395] - state: ‘finished’
[10:33:59.395] - run: TRUE
[10:33:59.395] - result: ‘FutureResult’
[10:33:59.395] resolved() for ‘SequentialFuture’ ... done
[10:33:59.395] Future #1
[10:33:59.395]  length: 3 (resolved future 1)
[10:33:59.395] resolved() for ‘SequentialFuture’ ...
[10:33:59.395] - state: ‘finished’
[10:33:59.395] - run: TRUE
[10:33:59.395] - result: ‘FutureResult’
[10:33:59.396] resolved() for ‘SequentialFuture’ ... done
[10:33:59.396] Future #2
[10:33:59.398]  length: 2 (resolved future 2)
[10:33:59.398] resolved() for ‘SequentialFuture’ ...
[10:33:59.398] - state: ‘finished’
[10:33:59.398] - run: TRUE
[10:33:59.398] - result: ‘FutureResult’
[10:33:59.398] resolved() for ‘SequentialFuture’ ... done
[10:33:59.398] Future #3
[10:33:59.398]  length: 1 (resolved future 3)
[10:33:59.399]  length: 0 (resolved future 4)
[10:33:59.399] resolve() on list environment ... DONE
[10:33:59.399] resolved() for ‘SequentialFuture’ ...
[10:33:59.399] - state: ‘finished’
[10:33:59.399] - run: TRUE
[10:33:59.399] - result: ‘FutureResult’
[10:33:59.399] resolved() for ‘SequentialFuture’ ... done
[10:33:59.400] resolve() on list environment ...
[10:33:59.400]  recursive: 0
[10:33:59.400]  length: 4
[10:33:59.400]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:33:59.400] resolved() for ‘SequentialFuture’ ...
[10:33:59.401] - state: ‘finished’
[10:33:59.401] - run: TRUE
[10:33:59.401] - result: ‘FutureResult’
[10:33:59.401] resolved() for ‘SequentialFuture’ ... done
[10:33:59.401] Future #1
[10:33:59.401]  length: 3 (resolved future 1)
[10:33:59.401] resolved() for ‘SequentialFuture’ ...
[10:33:59.401] - state: ‘finished’
[10:33:59.401] - run: TRUE
[10:33:59.401] - result: ‘FutureResult’
[10:33:59.402] resolved() for ‘SequentialFuture’ ... done
[10:33:59.402] Future #2
[10:33:59.402]  length: 2 (resolved future 2)
[10:33:59.402] resolved() for ‘SequentialFuture’ ...
[10:33:59.402] - state: ‘finished’
[10:33:59.402] - run: TRUE
[10:33:59.402] - result: ‘FutureResult’
[10:33:59.402] resolved() for ‘SequentialFuture’ ... done
[10:33:59.402] Future #3
[10:33:59.402]  length: 1 (resolved future 3)
[10:33:59.402]  length: 0 (resolved future 4)
[10:33:59.403] resolve() on list environment ... DONE
[10:33:59.403] resolve() on list environment ...
[10:33:59.403]  recursive: 0
[10:33:59.404]  length: 4
[10:33:59.404]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:33:59.404] resolved() for ‘SequentialFuture’ ...
[10:33:59.404] - state: ‘finished’
[10:33:59.404] - run: TRUE
[10:33:59.404] - result: ‘FutureResult’
[10:33:59.404] resolved() for ‘SequentialFuture’ ... done
[10:33:59.404] Future #1
[10:33:59.405]  length: 3 (resolved future 1)
[10:33:59.405] resolved() for ‘SequentialFuture’ ...
[10:33:59.405] - state: ‘finished’
[10:33:59.405] - run: TRUE
[10:33:59.405] - result: ‘FutureResult’
[10:33:59.405] resolved() for ‘SequentialFuture’ ... done
[10:33:59.405] Future #2
[10:33:59.405]  length: 2 (resolved future 2)
[10:33:59.405] resolved() for ‘SequentialFuture’ ...
[10:33:59.405] - state: ‘finished’
[10:33:59.406] - run: TRUE
[10:33:59.406] - result: ‘FutureResult’
[10:33:59.406] resolved() for ‘SequentialFuture’ ... done
[10:33:59.406] Future #3
[10:33:59.406]  length: 1 (resolved future 3)
[10:33:59.406]  length: 0 (resolved future 4)
[10:33:59.406] resolve() on list environment ... DONE
[10:33:59.407] resolve() on list environment ...
[10:33:59.407]  recursive: 0
[10:33:59.407]  length: 4
[10:33:59.407]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:33:59.408] resolved() for ‘SequentialFuture’ ...
[10:33:59.408] - state: ‘finished’
[10:33:59.408] - run: TRUE
[10:33:59.408] - result: ‘FutureResult’
[10:33:59.408] resolved() for ‘SequentialFuture’ ... done
[10:33:59.408] Future #1
[10:33:59.408]  length: 3 (resolved future 1)
[10:33:59.408] resolved() for ‘SequentialFuture’ ...
[10:33:59.408] - state: ‘finished’
[10:33:59.408] - run: TRUE
[10:33:59.408] - result: ‘FutureResult’
[10:33:59.409] resolved() for ‘SequentialFuture’ ... done
[10:33:59.409] Future #2
[10:33:59.409]  length: 2 (resolved future 2)
[10:33:59.409] resolved() for ‘SequentialFuture’ ...
[10:33:59.409] - state: ‘finished’
[10:33:59.409] - run: TRUE
[10:33:59.409] - result: ‘FutureResult’
[10:33:59.409] resolved() for ‘SequentialFuture’ ... done
[10:33:59.409] Future #3
[10:33:59.409]  length: 1 (resolved future 3)
[10:33:59.410]  length: 0 (resolved future 4)
[10:33:59.410] resolve() on list environment ... DONE
[10:33:59.410] resolve() on list environment ...
[10:33:59.410]  recursive: 0
[10:33:59.411]  length: 4
[10:33:59.411]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:33:59.411] resolved() for ‘SequentialFuture’ ...
[10:33:59.411] - state: ‘finished’
[10:33:59.411] - run: TRUE
[10:33:59.411] - result: ‘FutureResult’
[10:33:59.411] resolved() for ‘SequentialFuture’ ... done
[10:33:59.411] Future #1
[10:33:59.412]  length: 3 (resolved future 1)
[10:33:59.412] resolved() for ‘SequentialFuture’ ...
[10:33:59.412] - state: ‘finished’
[10:33:59.412] - run: TRUE
[10:33:59.412] - result: ‘FutureResult’
[10:33:59.412] resolved() for ‘SequentialFuture’ ... done
[10:33:59.412] Future #2
[10:33:59.412]  length: 2 (resolved future 2)
[10:33:59.412] resolved() for ‘SequentialFuture’ ...
[10:33:59.412] - state: ‘finished’
[10:33:59.412] - run: TRUE
[10:33:59.413] - result: ‘FutureResult’
[10:33:59.413] resolved() for ‘SequentialFuture’ ... done
[10:33:59.413] Future #3
[10:33:59.413]  length: 1 (resolved future 3)
[10:33:59.413]  length: 0 (resolved future 4)
[10:33:59.413] resolve() on list environment ... DONE
[10:33:59.414] resolve() on list environment ...
[10:33:59.414]  recursive: 99
[10:33:59.414]  length: 4
[10:33:59.414]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:33:59.414] resolved() for ‘SequentialFuture’ ...
[10:33:59.415] - state: ‘finished’
[10:33:59.415] - run: TRUE
[10:33:59.415] - result: ‘FutureResult’
[10:33:59.415] resolved() for ‘SequentialFuture’ ... done
[10:33:59.415] Future #1
[10:33:59.415] resolved() for ‘SequentialFuture’ ...
[10:33:59.415] - state: ‘finished’
[10:33:59.415] - run: TRUE
[10:33:59.415] - result: ‘FutureResult’
[10:33:59.415] resolved() for ‘SequentialFuture’ ... done
[10:33:59.415] A SequentialFuture was resolved
[10:33:59.416]  length: 3 (resolved future 1)
[10:33:59.416] resolved() for ‘SequentialFuture’ ...
[10:33:59.416] - state: ‘finished’
[10:33:59.416] - run: TRUE
[10:33:59.416] - result: ‘FutureResult’
[10:33:59.416] resolved() for ‘SequentialFuture’ ... done
[10:33:59.416] Future #2
[10:33:59.416] resolved() for ‘SequentialFuture’ ...
[10:33:59.416] - state: ‘finished’
[10:33:59.416] - run: TRUE
[10:33:59.439] - result: ‘FutureResult’
[10:33:59.439] resolved() for ‘SequentialFuture’ ... done
[10:33:59.440] A SequentialFuture was resolved
[10:33:59.440]  length: 2 (resolved future 2)
[10:33:59.440] resolved() for ‘SequentialFuture’ ...
[10:33:59.440] - state: ‘finished’
[10:33:59.440] - run: TRUE
[10:33:59.440] - result: ‘FutureResult’
[10:33:59.440] resolved() for ‘SequentialFuture’ ... done
[10:33:59.440] Future #3
[10:33:59.441] resolved() for ‘SequentialFuture’ ...
[10:33:59.441] - state: ‘finished’
[10:33:59.441] - run: TRUE
[10:33:59.441] - result: ‘FutureResult’
[10:33:59.441] resolved() for ‘SequentialFuture’ ... done
[10:33:59.441] A SequentialFuture was resolved
[10:33:59.441]  length: 1 (resolved future 3)
[10:33:59.441]  length: 0 (resolved future 4)
[10:33:59.441] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('sequential') ...
- plan('multicore') ...
[10:33:59.442] plan(): Setting new future strategy stack:
[10:33:59.442] List of future strategies:
[10:33:59.442] 1. multicore:
[10:33:59.442]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:59.442]    - tweaked: FALSE
[10:33:59.442]    - call: plan(strategy)
[10:33:59.446] plan(): nbrOfWorkers() = 2
*** resolve() for lists ...
[10:33:59.446] resolve() on list ...
[10:33:59.446]  recursive: 0
[10:33:59.446]  length: 2
[10:33:59.447]  elements: ‘a’, ‘b’
[10:33:59.447]  length: 1 (resolved future 1)
[10:33:59.447]  length: 0 (resolved future 2)
[10:33:59.447] resolve() on list ... DONE
[10:33:59.447] getGlobalsAndPackages() ...
[10:33:59.447] Searching for globals...
[10:33:59.447] 
[10:33:59.447] Searching for globals ... DONE
[10:33:59.448] - globals: [0] <none>
[10:33:59.448] getGlobalsAndPackages() ... DONE
[10:33:59.448] run() for ‘Future’ ...
[10:33:59.448] - state: ‘created’
[10:33:59.448] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:59.452] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:59.452] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:59.452]   - Field: ‘label’
[10:33:59.452]   - Field: ‘local’
[10:33:59.452]   - Field: ‘owner’
[10:33:59.452]   - Field: ‘envir’
[10:33:59.452]   - Field: ‘workers’
[10:33:59.452]   - Field: ‘packages’
[10:33:59.452]   - Field: ‘gc’
[10:33:59.452]   - Field: ‘job’
[10:33:59.453]   - Field: ‘conditions’
[10:33:59.453]   - Field: ‘expr’
[10:33:59.453]   - Field: ‘uuid’
[10:33:59.453]   - Field: ‘seed’
[10:33:59.453]   - Field: ‘version’
[10:33:59.453]   - Field: ‘result’
[10:33:59.453]   - Field: ‘asynchronous’
[10:33:59.453]   - Field: ‘calls’
[10:33:59.453]   - Field: ‘globals’
[10:33:59.453]   - Field: ‘stdout’
[10:33:59.453]   - Field: ‘earlySignal’
[10:33:59.454]   - Field: ‘lazy’
[10:33:59.454]   - Field: ‘state’
[10:33:59.454] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:59.454] - Launch lazy future ...
[10:33:59.455] Packages needed by the future expression (n = 0): <none>
[10:33:59.455] Packages needed by future strategies (n = 0): <none>
[10:33:59.455] {
[10:33:59.455]     {
[10:33:59.455]         {
[10:33:59.455]             ...future.startTime <- base::Sys.time()
[10:33:59.455]             {
[10:33:59.455]                 {
[10:33:59.455]                   {
[10:33:59.455]                     {
[10:33:59.455]                       base::local({
[10:33:59.455]                         has_future <- base::requireNamespace("future", 
[10:33:59.455]                           quietly = TRUE)
[10:33:59.455]                         if (has_future) {
[10:33:59.455]                           ns <- base::getNamespace("future")
[10:33:59.455]                           version <- ns[[".package"]][["version"]]
[10:33:59.455]                           if (is.null(version)) 
[10:33:59.455]                             version <- utils::packageVersion("future")
[10:33:59.455]                         }
[10:33:59.455]                         else {
[10:33:59.455]                           version <- NULL
[10:33:59.455]                         }
[10:33:59.455]                         if (!has_future || version < "1.8.0") {
[10:33:59.455]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:59.455]                             "", base::R.version$version.string), 
[10:33:59.455]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:59.455]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:59.455]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:59.455]                               "release", "version")], collapse = " "), 
[10:33:59.455]                             hostname = base::Sys.info()[["nodename"]])
[10:33:59.455]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:59.455]                             info)
[10:33:59.455]                           info <- base::paste(info, collapse = "; ")
[10:33:59.455]                           if (!has_future) {
[10:33:59.455]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:59.455]                               info)
[10:33:59.455]                           }
[10:33:59.455]                           else {
[10:33:59.455]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:59.455]                               info, version)
[10:33:59.455]                           }
[10:33:59.455]                           base::stop(msg)
[10:33:59.455]                         }
[10:33:59.455]                       })
[10:33:59.455]                     }
[10:33:59.455]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:59.455]                     base::options(mc.cores = 1L)
[10:33:59.455]                   }
[10:33:59.455]                   ...future.strategy.old <- future::plan("list")
[10:33:59.455]                   options(future.plan = NULL)
[10:33:59.455]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:59.455]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:59.455]                 }
[10:33:59.455]                 ...future.workdir <- getwd()
[10:33:59.455]             }
[10:33:59.455]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:59.455]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:59.455]         }
[10:33:59.455]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:59.455]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:59.455]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:59.455]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:59.455]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:59.455]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:59.455]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:59.455]             base::names(...future.oldOptions))
[10:33:59.455]     }
[10:33:59.455]     if (FALSE) {
[10:33:59.455]     }
[10:33:59.455]     else {
[10:33:59.455]         if (TRUE) {
[10:33:59.455]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:59.455]                 open = "w")
[10:33:59.455]         }
[10:33:59.455]         else {
[10:33:59.455]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:59.455]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:59.455]         }
[10:33:59.455]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:59.455]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:59.455]             base::sink(type = "output", split = FALSE)
[10:33:59.455]             base::close(...future.stdout)
[10:33:59.455]         }, add = TRUE)
[10:33:59.455]     }
[10:33:59.455]     ...future.frame <- base::sys.nframe()
[10:33:59.455]     ...future.conditions <- base::list()
[10:33:59.455]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:59.455]     if (FALSE) {
[10:33:59.455]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:59.455]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:59.455]     }
[10:33:59.455]     ...future.result <- base::tryCatch({
[10:33:59.455]         base::withCallingHandlers({
[10:33:59.455]             ...future.value <- base::withVisible(base::local({
[10:33:59.455]                 withCallingHandlers({
[10:33:59.455]                   1
[10:33:59.455]                 }, immediateCondition = function(cond) {
[10:33:59.455]                   save_rds <- function (object, pathname, ...) 
[10:33:59.455]                   {
[10:33:59.455]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:59.455]                     if (file_test("-f", pathname_tmp)) {
[10:33:59.455]                       fi_tmp <- file.info(pathname_tmp)
[10:33:59.455]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:59.455]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:59.455]                         fi_tmp[["mtime"]])
[10:33:59.455]                     }
[10:33:59.455]                     tryCatch({
[10:33:59.455]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:59.455]                     }, error = function(ex) {
[10:33:59.455]                       msg <- conditionMessage(ex)
[10:33:59.455]                       fi_tmp <- file.info(pathname_tmp)
[10:33:59.455]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:59.455]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:59.455]                         fi_tmp[["mtime"]], msg)
[10:33:59.455]                       ex$message <- msg
[10:33:59.455]                       stop(ex)
[10:33:59.455]                     })
[10:33:59.455]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:59.455]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:59.455]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:59.455]                       fi_tmp <- file.info(pathname_tmp)
[10:33:59.455]                       fi <- file.info(pathname)
[10:33:59.455]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:59.455]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:59.455]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:59.455]                         fi[["size"]], fi[["mtime"]])
[10:33:59.455]                       stop(msg)
[10:33:59.455]                     }
[10:33:59.455]                     invisible(pathname)
[10:33:59.455]                   }
[10:33:59.455]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:59.455]                     rootPath = tempdir()) 
[10:33:59.455]                   {
[10:33:59.455]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:59.455]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:59.455]                       tmpdir = path, fileext = ".rds")
[10:33:59.455]                     save_rds(obj, file)
[10:33:59.455]                   }
[10:33:59.455]                   saveImmediateCondition(cond, path = "/tmp/RtmpuZEzLw/.future/immediateConditions")
[10:33:59.455]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:59.455]                   {
[10:33:59.455]                     inherits <- base::inherits
[10:33:59.455]                     invokeRestart <- base::invokeRestart
[10:33:59.455]                     is.null <- base::is.null
[10:33:59.455]                     muffled <- FALSE
[10:33:59.455]                     if (inherits(cond, "message")) {
[10:33:59.455]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:59.455]                       if (muffled) 
[10:33:59.455]                         invokeRestart("muffleMessage")
[10:33:59.455]                     }
[10:33:59.455]                     else if (inherits(cond, "warning")) {
[10:33:59.455]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:59.455]                       if (muffled) 
[10:33:59.455]                         invokeRestart("muffleWarning")
[10:33:59.455]                     }
[10:33:59.455]                     else if (inherits(cond, "condition")) {
[10:33:59.455]                       if (!is.null(pattern)) {
[10:33:59.455]                         computeRestarts <- base::computeRestarts
[10:33:59.455]                         grepl <- base::grepl
[10:33:59.455]                         restarts <- computeRestarts(cond)
[10:33:59.455]                         for (restart in restarts) {
[10:33:59.455]                           name <- restart$name
[10:33:59.455]                           if (is.null(name)) 
[10:33:59.455]                             next
[10:33:59.455]                           if (!grepl(pattern, name)) 
[10:33:59.455]                             next
[10:33:59.455]                           invokeRestart(restart)
[10:33:59.455]                           muffled <- TRUE
[10:33:59.455]                           break
[10:33:59.455]                         }
[10:33:59.455]                       }
[10:33:59.455]                     }
[10:33:59.455]                     invisible(muffled)
[10:33:59.455]                   }
[10:33:59.455]                   muffleCondition(cond)
[10:33:59.455]                 })
[10:33:59.455]             }))
[10:33:59.455]             future::FutureResult(value = ...future.value$value, 
[10:33:59.455]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:59.455]                   ...future.rng), globalenv = if (FALSE) 
[10:33:59.455]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:59.455]                     ...future.globalenv.names))
[10:33:59.455]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:59.455]         }, condition = base::local({
[10:33:59.455]             c <- base::c
[10:33:59.455]             inherits <- base::inherits
[10:33:59.455]             invokeRestart <- base::invokeRestart
[10:33:59.455]             length <- base::length
[10:33:59.455]             list <- base::list
[10:33:59.455]             seq.int <- base::seq.int
[10:33:59.455]             signalCondition <- base::signalCondition
[10:33:59.455]             sys.calls <- base::sys.calls
[10:33:59.455]             `[[` <- base::`[[`
[10:33:59.455]             `+` <- base::`+`
[10:33:59.455]             `<<-` <- base::`<<-`
[10:33:59.455]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:59.455]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:59.455]                   3L)]
[10:33:59.455]             }
[10:33:59.455]             function(cond) {
[10:33:59.455]                 is_error <- inherits(cond, "error")
[10:33:59.455]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:59.455]                   NULL)
[10:33:59.455]                 if (is_error) {
[10:33:59.455]                   sessionInformation <- function() {
[10:33:59.455]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:59.455]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:59.455]                       search = base::search(), system = base::Sys.info())
[10:33:59.455]                   }
[10:33:59.455]                   ...future.conditions[[length(...future.conditions) + 
[10:33:59.455]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:59.455]                     cond$call), session = sessionInformation(), 
[10:33:59.455]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:59.455]                   signalCondition(cond)
[10:33:59.455]                 }
[10:33:59.455]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:59.455]                 "immediateCondition"))) {
[10:33:59.455]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:59.455]                   ...future.conditions[[length(...future.conditions) + 
[10:33:59.455]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:59.455]                   if (TRUE && !signal) {
[10:33:59.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:59.455]                     {
[10:33:59.455]                       inherits <- base::inherits
[10:33:59.455]                       invokeRestart <- base::invokeRestart
[10:33:59.455]                       is.null <- base::is.null
[10:33:59.455]                       muffled <- FALSE
[10:33:59.455]                       if (inherits(cond, "message")) {
[10:33:59.455]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:59.455]                         if (muffled) 
[10:33:59.455]                           invokeRestart("muffleMessage")
[10:33:59.455]                       }
[10:33:59.455]                       else if (inherits(cond, "warning")) {
[10:33:59.455]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:59.455]                         if (muffled) 
[10:33:59.455]                           invokeRestart("muffleWarning")
[10:33:59.455]                       }
[10:33:59.455]                       else if (inherits(cond, "condition")) {
[10:33:59.455]                         if (!is.null(pattern)) {
[10:33:59.455]                           computeRestarts <- base::computeRestarts
[10:33:59.455]                           grepl <- base::grepl
[10:33:59.455]                           restarts <- computeRestarts(cond)
[10:33:59.455]                           for (restart in restarts) {
[10:33:59.455]                             name <- restart$name
[10:33:59.455]                             if (is.null(name)) 
[10:33:59.455]                               next
[10:33:59.455]                             if (!grepl(pattern, name)) 
[10:33:59.455]                               next
[10:33:59.455]                             invokeRestart(restart)
[10:33:59.455]                             muffled <- TRUE
[10:33:59.455]                             break
[10:33:59.455]                           }
[10:33:59.455]                         }
[10:33:59.455]                       }
[10:33:59.455]                       invisible(muffled)
[10:33:59.455]                     }
[10:33:59.455]                     muffleCondition(cond, pattern = "^muffle")
[10:33:59.455]                   }
[10:33:59.455]                 }
[10:33:59.455]                 else {
[10:33:59.455]                   if (TRUE) {
[10:33:59.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:59.455]                     {
[10:33:59.455]                       inherits <- base::inherits
[10:33:59.455]                       invokeRestart <- base::invokeRestart
[10:33:59.455]                       is.null <- base::is.null
[10:33:59.455]                       muffled <- FALSE
[10:33:59.455]                       if (inherits(cond, "message")) {
[10:33:59.455]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:59.455]                         if (muffled) 
[10:33:59.455]                           invokeRestart("muffleMessage")
[10:33:59.455]                       }
[10:33:59.455]                       else if (inherits(cond, "warning")) {
[10:33:59.455]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:59.455]                         if (muffled) 
[10:33:59.455]                           invokeRestart("muffleWarning")
[10:33:59.455]                       }
[10:33:59.455]                       else if (inherits(cond, "condition")) {
[10:33:59.455]                         if (!is.null(pattern)) {
[10:33:59.455]                           computeRestarts <- base::computeRestarts
[10:33:59.455]                           grepl <- base::grepl
[10:33:59.455]                           restarts <- computeRestarts(cond)
[10:33:59.455]                           for (restart in restarts) {
[10:33:59.455]                             name <- restart$name
[10:33:59.455]                             if (is.null(name)) 
[10:33:59.455]                               next
[10:33:59.455]                             if (!grepl(pattern, name)) 
[10:33:59.455]                               next
[10:33:59.455]                             invokeRestart(restart)
[10:33:59.455]                             muffled <- TRUE
[10:33:59.455]                             break
[10:33:59.455]                           }
[10:33:59.455]                         }
[10:33:59.455]                       }
[10:33:59.455]                       invisible(muffled)
[10:33:59.455]                     }
[10:33:59.455]                     muffleCondition(cond, pattern = "^muffle")
[10:33:59.455]                   }
[10:33:59.455]                 }
[10:33:59.455]             }
[10:33:59.455]         }))
[10:33:59.455]     }, error = function(ex) {
[10:33:59.455]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:59.455]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:59.455]                 ...future.rng), started = ...future.startTime, 
[10:33:59.455]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:59.455]             version = "1.8"), class = "FutureResult")
[10:33:59.455]     }, finally = {
[10:33:59.455]         if (!identical(...future.workdir, getwd())) 
[10:33:59.455]             setwd(...future.workdir)
[10:33:59.455]         {
[10:33:59.455]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:59.455]                 ...future.oldOptions$nwarnings <- NULL
[10:33:59.455]             }
[10:33:59.455]             base::options(...future.oldOptions)
[10:33:59.455]             if (.Platform$OS.type == "windows") {
[10:33:59.455]                 old_names <- names(...future.oldEnvVars)
[10:33:59.455]                 envs <- base::Sys.getenv()
[10:33:59.455]                 names <- names(envs)
[10:33:59.455]                 common <- intersect(names, old_names)
[10:33:59.455]                 added <- setdiff(names, old_names)
[10:33:59.455]                 removed <- setdiff(old_names, names)
[10:33:59.455]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:59.455]                   envs[common]]
[10:33:59.455]                 NAMES <- toupper(changed)
[10:33:59.455]                 args <- list()
[10:33:59.455]                 for (kk in seq_along(NAMES)) {
[10:33:59.455]                   name <- changed[[kk]]
[10:33:59.455]                   NAME <- NAMES[[kk]]
[10:33:59.455]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:59.455]                     next
[10:33:59.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:59.455]                 }
[10:33:59.455]                 NAMES <- toupper(added)
[10:33:59.455]                 for (kk in seq_along(NAMES)) {
[10:33:59.455]                   name <- added[[kk]]
[10:33:59.455]                   NAME <- NAMES[[kk]]
[10:33:59.455]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:59.455]                     next
[10:33:59.455]                   args[[name]] <- ""
[10:33:59.455]                 }
[10:33:59.455]                 NAMES <- toupper(removed)
[10:33:59.455]                 for (kk in seq_along(NAMES)) {
[10:33:59.455]                   name <- removed[[kk]]
[10:33:59.455]                   NAME <- NAMES[[kk]]
[10:33:59.455]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:59.455]                     next
[10:33:59.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:59.455]                 }
[10:33:59.455]                 if (length(args) > 0) 
[10:33:59.455]                   base::do.call(base::Sys.setenv, args = args)
[10:33:59.455]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:59.455]             }
[10:33:59.455]             else {
[10:33:59.455]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:59.455]             }
[10:33:59.455]             {
[10:33:59.455]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:59.455]                   0L) {
[10:33:59.455]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:59.455]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:59.455]                   base::options(opts)
[10:33:59.455]                 }
[10:33:59.455]                 {
[10:33:59.455]                   {
[10:33:59.455]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:59.455]                     NULL
[10:33:59.455]                   }
[10:33:59.455]                   options(future.plan = NULL)
[10:33:59.455]                   if (is.na(NA_character_)) 
[10:33:59.455]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:59.455]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:59.455]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:59.455]                     .init = FALSE)
[10:33:59.455]                 }
[10:33:59.455]             }
[10:33:59.455]         }
[10:33:59.455]     })
[10:33:59.455]     if (TRUE) {
[10:33:59.455]         base::sink(type = "output", split = FALSE)
[10:33:59.455]         if (TRUE) {
[10:33:59.455]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:59.455]         }
[10:33:59.455]         else {
[10:33:59.455]             ...future.result["stdout"] <- base::list(NULL)
[10:33:59.455]         }
[10:33:59.455]         base::close(...future.stdout)
[10:33:59.455]         ...future.stdout <- NULL
[10:33:59.455]     }
[10:33:59.455]     ...future.result$conditions <- ...future.conditions
[10:33:59.455]     ...future.result$finished <- base::Sys.time()
[10:33:59.455]     ...future.result
[10:33:59.455] }
[10:33:59.458] requestCore(): workers = 2
[10:33:59.460] MulticoreFuture started
[10:33:59.461] - Launch lazy future ... done
[10:33:59.461] plan(): Setting new future strategy stack:
[10:33:59.461] run() for ‘MulticoreFuture’ ... done
[10:33:59.462] getGlobalsAndPackages() ...
[10:33:59.462] Searching for globals...
[10:33:59.462] List of future strategies:
[10:33:59.462] 1. sequential:
[10:33:59.462]    - args: function (..., envir = parent.frame())
[10:33:59.462]    - tweaked: FALSE
[10:33:59.462]    - call: NULL
[10:33:59.462] plan(): nbrOfWorkers() = 1
[10:33:59.463] 
[10:33:59.463] Searching for globals ... DONE
[10:33:59.463] - globals: [0] <none>
[10:33:59.464] getGlobalsAndPackages() ... DONE
[10:33:59.464] run() for ‘Future’ ...
[10:33:59.464] plan(): Setting new future strategy stack:
[10:33:59.464] - state: ‘created’
[10:33:59.465] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:59.465] List of future strategies:
[10:33:59.465] 1. multicore:
[10:33:59.465]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:59.465]    - tweaked: FALSE
[10:33:59.465]    - call: plan(strategy)
[10:33:59.469] plan(): nbrOfWorkers() = 2
[10:33:59.470] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:59.470] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:59.470]   - Field: ‘label’
[10:33:59.471]   - Field: ‘local’
[10:33:59.471]   - Field: ‘owner’
[10:33:59.471]   - Field: ‘envir’
[10:33:59.471]   - Field: ‘workers’
[10:33:59.471]   - Field: ‘packages’
[10:33:59.471]   - Field: ‘gc’
[10:33:59.472]   - Field: ‘job’
[10:33:59.472]   - Field: ‘conditions’
[10:33:59.472]   - Field: ‘expr’
[10:33:59.472]   - Field: ‘uuid’
[10:33:59.472]   - Field: ‘seed’
[10:33:59.472]   - Field: ‘version’
[10:33:59.472]   - Field: ‘result’
[10:33:59.473]   - Field: ‘asynchronous’
[10:33:59.473]   - Field: ‘calls’
[10:33:59.473]   - Field: ‘globals’
[10:33:59.473]   - Field: ‘stdout’
[10:33:59.473]   - Field: ‘earlySignal’
[10:33:59.473]   - Field: ‘lazy’
[10:33:59.474]   - Field: ‘state’
[10:33:59.474] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:59.474] - Launch lazy future ...
[10:33:59.474] Packages needed by the future expression (n = 0): <none>
[10:33:59.474] Packages needed by future strategies (n = 0): <none>
[10:33:59.475] {
[10:33:59.475]     {
[10:33:59.475]         {
[10:33:59.475]             ...future.startTime <- base::Sys.time()
[10:33:59.475]             {
[10:33:59.475]                 {
[10:33:59.475]                   {
[10:33:59.475]                     {
[10:33:59.475]                       base::local({
[10:33:59.475]                         has_future <- base::requireNamespace("future", 
[10:33:59.475]                           quietly = TRUE)
[10:33:59.475]                         if (has_future) {
[10:33:59.475]                           ns <- base::getNamespace("future")
[10:33:59.475]                           version <- ns[[".package"]][["version"]]
[10:33:59.475]                           if (is.null(version)) 
[10:33:59.475]                             version <- utils::packageVersion("future")
[10:33:59.475]                         }
[10:33:59.475]                         else {
[10:33:59.475]                           version <- NULL
[10:33:59.475]                         }
[10:33:59.475]                         if (!has_future || version < "1.8.0") {
[10:33:59.475]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:59.475]                             "", base::R.version$version.string), 
[10:33:59.475]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:59.475]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:59.475]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:59.475]                               "release", "version")], collapse = " "), 
[10:33:59.475]                             hostname = base::Sys.info()[["nodename"]])
[10:33:59.475]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:59.475]                             info)
[10:33:59.475]                           info <- base::paste(info, collapse = "; ")
[10:33:59.475]                           if (!has_future) {
[10:33:59.475]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:59.475]                               info)
[10:33:59.475]                           }
[10:33:59.475]                           else {
[10:33:59.475]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:59.475]                               info, version)
[10:33:59.475]                           }
[10:33:59.475]                           base::stop(msg)
[10:33:59.475]                         }
[10:33:59.475]                       })
[10:33:59.475]                     }
[10:33:59.475]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:59.475]                     base::options(mc.cores = 1L)
[10:33:59.475]                   }
[10:33:59.475]                   ...future.strategy.old <- future::plan("list")
[10:33:59.475]                   options(future.plan = NULL)
[10:33:59.475]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:59.475]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:59.475]                 }
[10:33:59.475]                 ...future.workdir <- getwd()
[10:33:59.475]             }
[10:33:59.475]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:59.475]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:59.475]         }
[10:33:59.475]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:59.475]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:59.475]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:59.475]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:59.475]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:59.475]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:59.475]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:59.475]             base::names(...future.oldOptions))
[10:33:59.475]     }
[10:33:59.475]     if (FALSE) {
[10:33:59.475]     }
[10:33:59.475]     else {
[10:33:59.475]         if (TRUE) {
[10:33:59.475]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:59.475]                 open = "w")
[10:33:59.475]         }
[10:33:59.475]         else {
[10:33:59.475]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:59.475]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:59.475]         }
[10:33:59.475]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:59.475]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:59.475]             base::sink(type = "output", split = FALSE)
[10:33:59.475]             base::close(...future.stdout)
[10:33:59.475]         }, add = TRUE)
[10:33:59.475]     }
[10:33:59.475]     ...future.frame <- base::sys.nframe()
[10:33:59.475]     ...future.conditions <- base::list()
[10:33:59.475]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:59.475]     if (FALSE) {
[10:33:59.475]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:59.475]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:59.475]     }
[10:33:59.475]     ...future.result <- base::tryCatch({
[10:33:59.475]         base::withCallingHandlers({
[10:33:59.475]             ...future.value <- base::withVisible(base::local({
[10:33:59.475]                 withCallingHandlers({
[10:33:59.475]                   2
[10:33:59.475]                 }, immediateCondition = function(cond) {
[10:33:59.475]                   save_rds <- function (object, pathname, ...) 
[10:33:59.475]                   {
[10:33:59.475]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:59.475]                     if (file_test("-f", pathname_tmp)) {
[10:33:59.475]                       fi_tmp <- file.info(pathname_tmp)
[10:33:59.475]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:59.475]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:59.475]                         fi_tmp[["mtime"]])
[10:33:59.475]                     }
[10:33:59.475]                     tryCatch({
[10:33:59.475]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:59.475]                     }, error = function(ex) {
[10:33:59.475]                       msg <- conditionMessage(ex)
[10:33:59.475]                       fi_tmp <- file.info(pathname_tmp)
[10:33:59.475]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:59.475]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:59.475]                         fi_tmp[["mtime"]], msg)
[10:33:59.475]                       ex$message <- msg
[10:33:59.475]                       stop(ex)
[10:33:59.475]                     })
[10:33:59.475]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:59.475]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:59.475]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:59.475]                       fi_tmp <- file.info(pathname_tmp)
[10:33:59.475]                       fi <- file.info(pathname)
[10:33:59.475]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:59.475]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:59.475]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:59.475]                         fi[["size"]], fi[["mtime"]])
[10:33:59.475]                       stop(msg)
[10:33:59.475]                     }
[10:33:59.475]                     invisible(pathname)
[10:33:59.475]                   }
[10:33:59.475]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:59.475]                     rootPath = tempdir()) 
[10:33:59.475]                   {
[10:33:59.475]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:59.475]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:59.475]                       tmpdir = path, fileext = ".rds")
[10:33:59.475]                     save_rds(obj, file)
[10:33:59.475]                   }
[10:33:59.475]                   saveImmediateCondition(cond, path = "/tmp/RtmpuZEzLw/.future/immediateConditions")
[10:33:59.475]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:59.475]                   {
[10:33:59.475]                     inherits <- base::inherits
[10:33:59.475]                     invokeRestart <- base::invokeRestart
[10:33:59.475]                     is.null <- base::is.null
[10:33:59.475]                     muffled <- FALSE
[10:33:59.475]                     if (inherits(cond, "message")) {
[10:33:59.475]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:59.475]                       if (muffled) 
[10:33:59.475]                         invokeRestart("muffleMessage")
[10:33:59.475]                     }
[10:33:59.475]                     else if (inherits(cond, "warning")) {
[10:33:59.475]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:59.475]                       if (muffled) 
[10:33:59.475]                         invokeRestart("muffleWarning")
[10:33:59.475]                     }
[10:33:59.475]                     else if (inherits(cond, "condition")) {
[10:33:59.475]                       if (!is.null(pattern)) {
[10:33:59.475]                         computeRestarts <- base::computeRestarts
[10:33:59.475]                         grepl <- base::grepl
[10:33:59.475]                         restarts <- computeRestarts(cond)
[10:33:59.475]                         for (restart in restarts) {
[10:33:59.475]                           name <- restart$name
[10:33:59.475]                           if (is.null(name)) 
[10:33:59.475]                             next
[10:33:59.475]                           if (!grepl(pattern, name)) 
[10:33:59.475]                             next
[10:33:59.475]                           invokeRestart(restart)
[10:33:59.475]                           muffled <- TRUE
[10:33:59.475]                           break
[10:33:59.475]                         }
[10:33:59.475]                       }
[10:33:59.475]                     }
[10:33:59.475]                     invisible(muffled)
[10:33:59.475]                   }
[10:33:59.475]                   muffleCondition(cond)
[10:33:59.475]                 })
[10:33:59.475]             }))
[10:33:59.475]             future::FutureResult(value = ...future.value$value, 
[10:33:59.475]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:59.475]                   ...future.rng), globalenv = if (FALSE) 
[10:33:59.475]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:59.475]                     ...future.globalenv.names))
[10:33:59.475]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:59.475]         }, condition = base::local({
[10:33:59.475]             c <- base::c
[10:33:59.475]             inherits <- base::inherits
[10:33:59.475]             invokeRestart <- base::invokeRestart
[10:33:59.475]             length <- base::length
[10:33:59.475]             list <- base::list
[10:33:59.475]             seq.int <- base::seq.int
[10:33:59.475]             signalCondition <- base::signalCondition
[10:33:59.475]             sys.calls <- base::sys.calls
[10:33:59.475]             `[[` <- base::`[[`
[10:33:59.475]             `+` <- base::`+`
[10:33:59.475]             `<<-` <- base::`<<-`
[10:33:59.475]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:59.475]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:59.475]                   3L)]
[10:33:59.475]             }
[10:33:59.475]             function(cond) {
[10:33:59.475]                 is_error <- inherits(cond, "error")
[10:33:59.475]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:59.475]                   NULL)
[10:33:59.475]                 if (is_error) {
[10:33:59.475]                   sessionInformation <- function() {
[10:33:59.475]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:59.475]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:59.475]                       search = base::search(), system = base::Sys.info())
[10:33:59.475]                   }
[10:33:59.475]                   ...future.conditions[[length(...future.conditions) + 
[10:33:59.475]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:59.475]                     cond$call), session = sessionInformation(), 
[10:33:59.475]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:59.475]                   signalCondition(cond)
[10:33:59.475]                 }
[10:33:59.475]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:59.475]                 "immediateCondition"))) {
[10:33:59.475]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:59.475]                   ...future.conditions[[length(...future.conditions) + 
[10:33:59.475]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:59.475]                   if (TRUE && !signal) {
[10:33:59.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:59.475]                     {
[10:33:59.475]                       inherits <- base::inherits
[10:33:59.475]                       invokeRestart <- base::invokeRestart
[10:33:59.475]                       is.null <- base::is.null
[10:33:59.475]                       muffled <- FALSE
[10:33:59.475]                       if (inherits(cond, "message")) {
[10:33:59.475]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:59.475]                         if (muffled) 
[10:33:59.475]                           invokeRestart("muffleMessage")
[10:33:59.475]                       }
[10:33:59.475]                       else if (inherits(cond, "warning")) {
[10:33:59.475]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:59.475]                         if (muffled) 
[10:33:59.475]                           invokeRestart("muffleWarning")
[10:33:59.475]                       }
[10:33:59.475]                       else if (inherits(cond, "condition")) {
[10:33:59.475]                         if (!is.null(pattern)) {
[10:33:59.475]                           computeRestarts <- base::computeRestarts
[10:33:59.475]                           grepl <- base::grepl
[10:33:59.475]                           restarts <- computeRestarts(cond)
[10:33:59.475]                           for (restart in restarts) {
[10:33:59.475]                             name <- restart$name
[10:33:59.475]                             if (is.null(name)) 
[10:33:59.475]                               next
[10:33:59.475]                             if (!grepl(pattern, name)) 
[10:33:59.475]                               next
[10:33:59.475]                             invokeRestart(restart)
[10:33:59.475]                             muffled <- TRUE
[10:33:59.475]                             break
[10:33:59.475]                           }
[10:33:59.475]                         }
[10:33:59.475]                       }
[10:33:59.475]                       invisible(muffled)
[10:33:59.475]                     }
[10:33:59.475]                     muffleCondition(cond, pattern = "^muffle")
[10:33:59.475]                   }
[10:33:59.475]                 }
[10:33:59.475]                 else {
[10:33:59.475]                   if (TRUE) {
[10:33:59.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:59.475]                     {
[10:33:59.475]                       inherits <- base::inherits
[10:33:59.475]                       invokeRestart <- base::invokeRestart
[10:33:59.475]                       is.null <- base::is.null
[10:33:59.475]                       muffled <- FALSE
[10:33:59.475]                       if (inherits(cond, "message")) {
[10:33:59.475]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:59.475]                         if (muffled) 
[10:33:59.475]                           invokeRestart("muffleMessage")
[10:33:59.475]                       }
[10:33:59.475]                       else if (inherits(cond, "warning")) {
[10:33:59.475]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:59.475]                         if (muffled) 
[10:33:59.475]                           invokeRestart("muffleWarning")
[10:33:59.475]                       }
[10:33:59.475]                       else if (inherits(cond, "condition")) {
[10:33:59.475]                         if (!is.null(pattern)) {
[10:33:59.475]                           computeRestarts <- base::computeRestarts
[10:33:59.475]                           grepl <- base::grepl
[10:33:59.475]                           restarts <- computeRestarts(cond)
[10:33:59.475]                           for (restart in restarts) {
[10:33:59.475]                             name <- restart$name
[10:33:59.475]                             if (is.null(name)) 
[10:33:59.475]                               next
[10:33:59.475]                             if (!grepl(pattern, name)) 
[10:33:59.475]                               next
[10:33:59.475]                             invokeRestart(restart)
[10:33:59.475]                             muffled <- TRUE
[10:33:59.475]                             break
[10:33:59.475]                           }
[10:33:59.475]                         }
[10:33:59.475]                       }
[10:33:59.475]                       invisible(muffled)
[10:33:59.475]                     }
[10:33:59.475]                     muffleCondition(cond, pattern = "^muffle")
[10:33:59.475]                   }
[10:33:59.475]                 }
[10:33:59.475]             }
[10:33:59.475]         }))
[10:33:59.475]     }, error = function(ex) {
[10:33:59.475]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:59.475]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:59.475]                 ...future.rng), started = ...future.startTime, 
[10:33:59.475]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:59.475]             version = "1.8"), class = "FutureResult")
[10:33:59.475]     }, finally = {
[10:33:59.475]         if (!identical(...future.workdir, getwd())) 
[10:33:59.475]             setwd(...future.workdir)
[10:33:59.475]         {
[10:33:59.475]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:59.475]                 ...future.oldOptions$nwarnings <- NULL
[10:33:59.475]             }
[10:33:59.475]             base::options(...future.oldOptions)
[10:33:59.475]             if (.Platform$OS.type == "windows") {
[10:33:59.475]                 old_names <- names(...future.oldEnvVars)
[10:33:59.475]                 envs <- base::Sys.getenv()
[10:33:59.475]                 names <- names(envs)
[10:33:59.475]                 common <- intersect(names, old_names)
[10:33:59.475]                 added <- setdiff(names, old_names)
[10:33:59.475]                 removed <- setdiff(old_names, names)
[10:33:59.475]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:59.475]                   envs[common]]
[10:33:59.475]                 NAMES <- toupper(changed)
[10:33:59.475]                 args <- list()
[10:33:59.475]                 for (kk in seq_along(NAMES)) {
[10:33:59.475]                   name <- changed[[kk]]
[10:33:59.475]                   NAME <- NAMES[[kk]]
[10:33:59.475]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:59.475]                     next
[10:33:59.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:59.475]                 }
[10:33:59.475]                 NAMES <- toupper(added)
[10:33:59.475]                 for (kk in seq_along(NAMES)) {
[10:33:59.475]                   name <- added[[kk]]
[10:33:59.475]                   NAME <- NAMES[[kk]]
[10:33:59.475]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:59.475]                     next
[10:33:59.475]                   args[[name]] <- ""
[10:33:59.475]                 }
[10:33:59.475]                 NAMES <- toupper(removed)
[10:33:59.475]                 for (kk in seq_along(NAMES)) {
[10:33:59.475]                   name <- removed[[kk]]
[10:33:59.475]                   NAME <- NAMES[[kk]]
[10:33:59.475]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:59.475]                     next
[10:33:59.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:59.475]                 }
[10:33:59.475]                 if (length(args) > 0) 
[10:33:59.475]                   base::do.call(base::Sys.setenv, args = args)
[10:33:59.475]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:59.475]             }
[10:33:59.475]             else {
[10:33:59.475]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:59.475]             }
[10:33:59.475]             {
[10:33:59.475]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:59.475]                   0L) {
[10:33:59.475]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:59.475]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:59.475]                   base::options(opts)
[10:33:59.475]                 }
[10:33:59.475]                 {
[10:33:59.475]                   {
[10:33:59.475]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:59.475]                     NULL
[10:33:59.475]                   }
[10:33:59.475]                   options(future.plan = NULL)
[10:33:59.475]                   if (is.na(NA_character_)) 
[10:33:59.475]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:59.475]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:59.475]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:59.475]                     .init = FALSE)
[10:33:59.475]                 }
[10:33:59.475]             }
[10:33:59.475]         }
[10:33:59.475]     })
[10:33:59.475]     if (TRUE) {
[10:33:59.475]         base::sink(type = "output", split = FALSE)
[10:33:59.475]         if (TRUE) {
[10:33:59.475]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:59.475]         }
[10:33:59.475]         else {
[10:33:59.475]             ...future.result["stdout"] <- base::list(NULL)
[10:33:59.475]         }
[10:33:59.475]         base::close(...future.stdout)
[10:33:59.475]         ...future.stdout <- NULL
[10:33:59.475]     }
[10:33:59.475]     ...future.result$conditions <- ...future.conditions
[10:33:59.475]     ...future.result$finished <- base::Sys.time()
[10:33:59.475]     ...future.result
[10:33:59.475] }
[10:33:59.478] requestCore(): workers = 2
[10:33:59.484] MulticoreFuture started
[10:33:59.485] - Launch lazy future ... done
[10:33:59.485] run() for ‘MulticoreFuture’ ... done
[10:33:59.485] resolve() on list ...
[10:33:59.485]  recursive: 0
[10:33:59.486]  length: 3
[10:33:59.486] plan(): Setting new future strategy stack:
[10:33:59.486]  elements: ‘a’, ‘b’, ‘’
[10:33:59.486] List of future strategies:
[10:33:59.486] 1. sequential:
[10:33:59.486]    - args: function (..., envir = parent.frame())
[10:33:59.486]    - tweaked: FALSE
[10:33:59.486]    - call: NULL
[10:33:59.487] plan(): nbrOfWorkers() = 1
[10:33:59.488] Future #1
[10:33:59.488]  length: 2 (resolved future 1)
[10:33:59.489] plan(): Setting new future strategy stack:
[10:33:59.489] List of future strategies:
[10:33:59.489] 1. multicore:
[10:33:59.489]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:59.489]    - tweaked: FALSE
[10:33:59.489]    - call: plan(strategy)
[10:33:59.494] plan(): nbrOfWorkers() = 2
[10:33:59.494] Future #2
[10:33:59.495]  length: 1 (resolved future 2)
[10:33:59.495]  length: 0 (resolved future 3)
[10:33:59.495] resolve() on list ... DONE
[10:33:59.495] getGlobalsAndPackages() ...
[10:33:59.496] Searching for globals...
[10:33:59.496] 
[10:33:59.496] Searching for globals ... DONE
[10:33:59.497] - globals: [0] <none>
[10:33:59.497] getGlobalsAndPackages() ... DONE
[10:33:59.497] getGlobalsAndPackages() ...
[10:33:59.497] Searching for globals...
[10:33:59.498] 
[10:33:59.498] Searching for globals ... DONE
[10:33:59.498] - globals: [0] <none>
[10:33:59.498] getGlobalsAndPackages() ... DONE
[10:33:59.499] run() for ‘Future’ ...
[10:33:59.499] - state: ‘created’
[10:33:59.499] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:59.509] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:59.510] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:59.510]   - Field: ‘label’
[10:33:59.510]   - Field: ‘local’
[10:33:59.511]   - Field: ‘owner’
[10:33:59.511]   - Field: ‘envir’
[10:33:59.511]   - Field: ‘workers’
[10:33:59.511]   - Field: ‘packages’
[10:33:59.511]   - Field: ‘gc’
[10:33:59.511]   - Field: ‘job’
[10:33:59.512]   - Field: ‘conditions’
[10:33:59.512]   - Field: ‘expr’
[10:33:59.512]   - Field: ‘uuid’
[10:33:59.512]   - Field: ‘seed’
[10:33:59.512]   - Field: ‘version’
[10:33:59.512]   - Field: ‘result’
[10:33:59.513]   - Field: ‘asynchronous’
[10:33:59.513]   - Field: ‘calls’
[10:33:59.513]   - Field: ‘globals’
[10:33:59.513]   - Field: ‘stdout’
[10:33:59.513]   - Field: ‘earlySignal’
[10:33:59.513]   - Field: ‘lazy’
[10:33:59.514]   - Field: ‘state’
[10:33:59.514] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:59.514] - Launch lazy future ...
[10:33:59.514] Packages needed by the future expression (n = 0): <none>
[10:33:59.514] Packages needed by future strategies (n = 0): <none>
[10:33:59.515] {
[10:33:59.515]     {
[10:33:59.515]         {
[10:33:59.515]             ...future.startTime <- base::Sys.time()
[10:33:59.515]             {
[10:33:59.515]                 {
[10:33:59.515]                   {
[10:33:59.515]                     {
[10:33:59.515]                       base::local({
[10:33:59.515]                         has_future <- base::requireNamespace("future", 
[10:33:59.515]                           quietly = TRUE)
[10:33:59.515]                         if (has_future) {
[10:33:59.515]                           ns <- base::getNamespace("future")
[10:33:59.515]                           version <- ns[[".package"]][["version"]]
[10:33:59.515]                           if (is.null(version)) 
[10:33:59.515]                             version <- utils::packageVersion("future")
[10:33:59.515]                         }
[10:33:59.515]                         else {
[10:33:59.515]                           version <- NULL
[10:33:59.515]                         }
[10:33:59.515]                         if (!has_future || version < "1.8.0") {
[10:33:59.515]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:59.515]                             "", base::R.version$version.string), 
[10:33:59.515]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:59.515]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:59.515]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:59.515]                               "release", "version")], collapse = " "), 
[10:33:59.515]                             hostname = base::Sys.info()[["nodename"]])
[10:33:59.515]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:59.515]                             info)
[10:33:59.515]                           info <- base::paste(info, collapse = "; ")
[10:33:59.515]                           if (!has_future) {
[10:33:59.515]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:59.515]                               info)
[10:33:59.515]                           }
[10:33:59.515]                           else {
[10:33:59.515]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:59.515]                               info, version)
[10:33:59.515]                           }
[10:33:59.515]                           base::stop(msg)
[10:33:59.515]                         }
[10:33:59.515]                       })
[10:33:59.515]                     }
[10:33:59.515]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:59.515]                     base::options(mc.cores = 1L)
[10:33:59.515]                   }
[10:33:59.515]                   ...future.strategy.old <- future::plan("list")
[10:33:59.515]                   options(future.plan = NULL)
[10:33:59.515]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:59.515]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:59.515]                 }
[10:33:59.515]                 ...future.workdir <- getwd()
[10:33:59.515]             }
[10:33:59.515]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:59.515]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:59.515]         }
[10:33:59.515]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:59.515]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:59.515]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:59.515]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:59.515]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:59.515]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:59.515]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:59.515]             base::names(...future.oldOptions))
[10:33:59.515]     }
[10:33:59.515]     if (FALSE) {
[10:33:59.515]     }
[10:33:59.515]     else {
[10:33:59.515]         if (TRUE) {
[10:33:59.515]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:59.515]                 open = "w")
[10:33:59.515]         }
[10:33:59.515]         else {
[10:33:59.515]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:59.515]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:59.515]         }
[10:33:59.515]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:59.515]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:59.515]             base::sink(type = "output", split = FALSE)
[10:33:59.515]             base::close(...future.stdout)
[10:33:59.515]         }, add = TRUE)
[10:33:59.515]     }
[10:33:59.515]     ...future.frame <- base::sys.nframe()
[10:33:59.515]     ...future.conditions <- base::list()
[10:33:59.515]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:59.515]     if (FALSE) {
[10:33:59.515]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:59.515]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:59.515]     }
[10:33:59.515]     ...future.result <- base::tryCatch({
[10:33:59.515]         base::withCallingHandlers({
[10:33:59.515]             ...future.value <- base::withVisible(base::local({
[10:33:59.515]                 withCallingHandlers({
[10:33:59.515]                   2
[10:33:59.515]                 }, immediateCondition = function(cond) {
[10:33:59.515]                   save_rds <- function (object, pathname, ...) 
[10:33:59.515]                   {
[10:33:59.515]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:59.515]                     if (file_test("-f", pathname_tmp)) {
[10:33:59.515]                       fi_tmp <- file.info(pathname_tmp)
[10:33:59.515]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:59.515]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:59.515]                         fi_tmp[["mtime"]])
[10:33:59.515]                     }
[10:33:59.515]                     tryCatch({
[10:33:59.515]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:59.515]                     }, error = function(ex) {
[10:33:59.515]                       msg <- conditionMessage(ex)
[10:33:59.515]                       fi_tmp <- file.info(pathname_tmp)
[10:33:59.515]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:59.515]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:59.515]                         fi_tmp[["mtime"]], msg)
[10:33:59.515]                       ex$message <- msg
[10:33:59.515]                       stop(ex)
[10:33:59.515]                     })
[10:33:59.515]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:59.515]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:59.515]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:59.515]                       fi_tmp <- file.info(pathname_tmp)
[10:33:59.515]                       fi <- file.info(pathname)
[10:33:59.515]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:59.515]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:59.515]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:59.515]                         fi[["size"]], fi[["mtime"]])
[10:33:59.515]                       stop(msg)
[10:33:59.515]                     }
[10:33:59.515]                     invisible(pathname)
[10:33:59.515]                   }
[10:33:59.515]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:59.515]                     rootPath = tempdir()) 
[10:33:59.515]                   {
[10:33:59.515]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:59.515]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:59.515]                       tmpdir = path, fileext = ".rds")
[10:33:59.515]                     save_rds(obj, file)
[10:33:59.515]                   }
[10:33:59.515]                   saveImmediateCondition(cond, path = "/tmp/RtmpuZEzLw/.future/immediateConditions")
[10:33:59.515]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:59.515]                   {
[10:33:59.515]                     inherits <- base::inherits
[10:33:59.515]                     invokeRestart <- base::invokeRestart
[10:33:59.515]                     is.null <- base::is.null
[10:33:59.515]                     muffled <- FALSE
[10:33:59.515]                     if (inherits(cond, "message")) {
[10:33:59.515]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:59.515]                       if (muffled) 
[10:33:59.515]                         invokeRestart("muffleMessage")
[10:33:59.515]                     }
[10:33:59.515]                     else if (inherits(cond, "warning")) {
[10:33:59.515]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:59.515]                       if (muffled) 
[10:33:59.515]                         invokeRestart("muffleWarning")
[10:33:59.515]                     }
[10:33:59.515]                     else if (inherits(cond, "condition")) {
[10:33:59.515]                       if (!is.null(pattern)) {
[10:33:59.515]                         computeRestarts <- base::computeRestarts
[10:33:59.515]                         grepl <- base::grepl
[10:33:59.515]                         restarts <- computeRestarts(cond)
[10:33:59.515]                         for (restart in restarts) {
[10:33:59.515]                           name <- restart$name
[10:33:59.515]                           if (is.null(name)) 
[10:33:59.515]                             next
[10:33:59.515]                           if (!grepl(pattern, name)) 
[10:33:59.515]                             next
[10:33:59.515]                           invokeRestart(restart)
[10:33:59.515]                           muffled <- TRUE
[10:33:59.515]                           break
[10:33:59.515]                         }
[10:33:59.515]                       }
[10:33:59.515]                     }
[10:33:59.515]                     invisible(muffled)
[10:33:59.515]                   }
[10:33:59.515]                   muffleCondition(cond)
[10:33:59.515]                 })
[10:33:59.515]             }))
[10:33:59.515]             future::FutureResult(value = ...future.value$value, 
[10:33:59.515]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:59.515]                   ...future.rng), globalenv = if (FALSE) 
[10:33:59.515]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:59.515]                     ...future.globalenv.names))
[10:33:59.515]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:59.515]         }, condition = base::local({
[10:33:59.515]             c <- base::c
[10:33:59.515]             inherits <- base::inherits
[10:33:59.515]             invokeRestart <- base::invokeRestart
[10:33:59.515]             length <- base::length
[10:33:59.515]             list <- base::list
[10:33:59.515]             seq.int <- base::seq.int
[10:33:59.515]             signalCondition <- base::signalCondition
[10:33:59.515]             sys.calls <- base::sys.calls
[10:33:59.515]             `[[` <- base::`[[`
[10:33:59.515]             `+` <- base::`+`
[10:33:59.515]             `<<-` <- base::`<<-`
[10:33:59.515]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:59.515]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:59.515]                   3L)]
[10:33:59.515]             }
[10:33:59.515]             function(cond) {
[10:33:59.515]                 is_error <- inherits(cond, "error")
[10:33:59.515]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:59.515]                   NULL)
[10:33:59.515]                 if (is_error) {
[10:33:59.515]                   sessionInformation <- function() {
[10:33:59.515]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:59.515]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:59.515]                       search = base::search(), system = base::Sys.info())
[10:33:59.515]                   }
[10:33:59.515]                   ...future.conditions[[length(...future.conditions) + 
[10:33:59.515]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:59.515]                     cond$call), session = sessionInformation(), 
[10:33:59.515]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:59.515]                   signalCondition(cond)
[10:33:59.515]                 }
[10:33:59.515]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:59.515]                 "immediateCondition"))) {
[10:33:59.515]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:59.515]                   ...future.conditions[[length(...future.conditions) + 
[10:33:59.515]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:59.515]                   if (TRUE && !signal) {
[10:33:59.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:59.515]                     {
[10:33:59.515]                       inherits <- base::inherits
[10:33:59.515]                       invokeRestart <- base::invokeRestart
[10:33:59.515]                       is.null <- base::is.null
[10:33:59.515]                       muffled <- FALSE
[10:33:59.515]                       if (inherits(cond, "message")) {
[10:33:59.515]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:59.515]                         if (muffled) 
[10:33:59.515]                           invokeRestart("muffleMessage")
[10:33:59.515]                       }
[10:33:59.515]                       else if (inherits(cond, "warning")) {
[10:33:59.515]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:59.515]                         if (muffled) 
[10:33:59.515]                           invokeRestart("muffleWarning")
[10:33:59.515]                       }
[10:33:59.515]                       else if (inherits(cond, "condition")) {
[10:33:59.515]                         if (!is.null(pattern)) {
[10:33:59.515]                           computeRestarts <- base::computeRestarts
[10:33:59.515]                           grepl <- base::grepl
[10:33:59.515]                           restarts <- computeRestarts(cond)
[10:33:59.515]                           for (restart in restarts) {
[10:33:59.515]                             name <- restart$name
[10:33:59.515]                             if (is.null(name)) 
[10:33:59.515]                               next
[10:33:59.515]                             if (!grepl(pattern, name)) 
[10:33:59.515]                               next
[10:33:59.515]                             invokeRestart(restart)
[10:33:59.515]                             muffled <- TRUE
[10:33:59.515]                             break
[10:33:59.515]                           }
[10:33:59.515]                         }
[10:33:59.515]                       }
[10:33:59.515]                       invisible(muffled)
[10:33:59.515]                     }
[10:33:59.515]                     muffleCondition(cond, pattern = "^muffle")
[10:33:59.515]                   }
[10:33:59.515]                 }
[10:33:59.515]                 else {
[10:33:59.515]                   if (TRUE) {
[10:33:59.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:59.515]                     {
[10:33:59.515]                       inherits <- base::inherits
[10:33:59.515]                       invokeRestart <- base::invokeRestart
[10:33:59.515]                       is.null <- base::is.null
[10:33:59.515]                       muffled <- FALSE
[10:33:59.515]                       if (inherits(cond, "message")) {
[10:33:59.515]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:59.515]                         if (muffled) 
[10:33:59.515]                           invokeRestart("muffleMessage")
[10:33:59.515]                       }
[10:33:59.515]                       else if (inherits(cond, "warning")) {
[10:33:59.515]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:59.515]                         if (muffled) 
[10:33:59.515]                           invokeRestart("muffleWarning")
[10:33:59.515]                       }
[10:33:59.515]                       else if (inherits(cond, "condition")) {
[10:33:59.515]                         if (!is.null(pattern)) {
[10:33:59.515]                           computeRestarts <- base::computeRestarts
[10:33:59.515]                           grepl <- base::grepl
[10:33:59.515]                           restarts <- computeRestarts(cond)
[10:33:59.515]                           for (restart in restarts) {
[10:33:59.515]                             name <- restart$name
[10:33:59.515]                             if (is.null(name)) 
[10:33:59.515]                               next
[10:33:59.515]                             if (!grepl(pattern, name)) 
[10:33:59.515]                               next
[10:33:59.515]                             invokeRestart(restart)
[10:33:59.515]                             muffled <- TRUE
[10:33:59.515]                             break
[10:33:59.515]                           }
[10:33:59.515]                         }
[10:33:59.515]                       }
[10:33:59.515]                       invisible(muffled)
[10:33:59.515]                     }
[10:33:59.515]                     muffleCondition(cond, pattern = "^muffle")
[10:33:59.515]                   }
[10:33:59.515]                 }
[10:33:59.515]             }
[10:33:59.515]         }))
[10:33:59.515]     }, error = function(ex) {
[10:33:59.515]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:59.515]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:59.515]                 ...future.rng), started = ...future.startTime, 
[10:33:59.515]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:59.515]             version = "1.8"), class = "FutureResult")
[10:33:59.515]     }, finally = {
[10:33:59.515]         if (!identical(...future.workdir, getwd())) 
[10:33:59.515]             setwd(...future.workdir)
[10:33:59.515]         {
[10:33:59.515]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:59.515]                 ...future.oldOptions$nwarnings <- NULL
[10:33:59.515]             }
[10:33:59.515]             base::options(...future.oldOptions)
[10:33:59.515]             if (.Platform$OS.type == "windows") {
[10:33:59.515]                 old_names <- names(...future.oldEnvVars)
[10:33:59.515]                 envs <- base::Sys.getenv()
[10:33:59.515]                 names <- names(envs)
[10:33:59.515]                 common <- intersect(names, old_names)
[10:33:59.515]                 added <- setdiff(names, old_names)
[10:33:59.515]                 removed <- setdiff(old_names, names)
[10:33:59.515]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:59.515]                   envs[common]]
[10:33:59.515]                 NAMES <- toupper(changed)
[10:33:59.515]                 args <- list()
[10:33:59.515]                 for (kk in seq_along(NAMES)) {
[10:33:59.515]                   name <- changed[[kk]]
[10:33:59.515]                   NAME <- NAMES[[kk]]
[10:33:59.515]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:59.515]                     next
[10:33:59.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:59.515]                 }
[10:33:59.515]                 NAMES <- toupper(added)
[10:33:59.515]                 for (kk in seq_along(NAMES)) {
[10:33:59.515]                   name <- added[[kk]]
[10:33:59.515]                   NAME <- NAMES[[kk]]
[10:33:59.515]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:59.515]                     next
[10:33:59.515]                   args[[name]] <- ""
[10:33:59.515]                 }
[10:33:59.515]                 NAMES <- toupper(removed)
[10:33:59.515]                 for (kk in seq_along(NAMES)) {
[10:33:59.515]                   name <- removed[[kk]]
[10:33:59.515]                   NAME <- NAMES[[kk]]
[10:33:59.515]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:59.515]                     next
[10:33:59.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:59.515]                 }
[10:33:59.515]                 if (length(args) > 0) 
[10:33:59.515]                   base::do.call(base::Sys.setenv, args = args)
[10:33:59.515]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:59.515]             }
[10:33:59.515]             else {
[10:33:59.515]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:59.515]             }
[10:33:59.515]             {
[10:33:59.515]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:59.515]                   0L) {
[10:33:59.515]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:59.515]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:59.515]                   base::options(opts)
[10:33:59.515]                 }
[10:33:59.515]                 {
[10:33:59.515]                   {
[10:33:59.515]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:59.515]                     NULL
[10:33:59.515]                   }
[10:33:59.515]                   options(future.plan = NULL)
[10:33:59.515]                   if (is.na(NA_character_)) 
[10:33:59.515]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:59.515]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:59.515]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:59.515]                     .init = FALSE)
[10:33:59.515]                 }
[10:33:59.515]             }
[10:33:59.515]         }
[10:33:59.515]     })
[10:33:59.515]     if (TRUE) {
[10:33:59.515]         base::sink(type = "output", split = FALSE)
[10:33:59.515]         if (TRUE) {
[10:33:59.515]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:59.515]         }
[10:33:59.515]         else {
[10:33:59.515]             ...future.result["stdout"] <- base::list(NULL)
[10:33:59.515]         }
[10:33:59.515]         base::close(...future.stdout)
[10:33:59.515]         ...future.stdout <- NULL
[10:33:59.515]     }
[10:33:59.515]     ...future.result$conditions <- ...future.conditions
[10:33:59.515]     ...future.result$finished <- base::Sys.time()
[10:33:59.515]     ...future.result
[10:33:59.515] }
[10:33:59.518] requestCore(): workers = 2
[10:33:59.519] Poll #1 (0): usedCores() = 2, workers = 2
[10:33:59.530] result() for MulticoreFuture ...
[10:33:59.531] result() for MulticoreFuture ...
[10:33:59.531] result() for MulticoreFuture ... done
[10:33:59.531] result() for MulticoreFuture ... done
[10:33:59.531] result() for MulticoreFuture ...
[10:33:59.532] result() for MulticoreFuture ... done
[10:33:59.534] MulticoreFuture started
[10:33:59.534] - Launch lazy future ... done
[10:33:59.535] run() for ‘MulticoreFuture’ ... done
[10:33:59.535] resolve() on list ...
[10:33:59.535]  recursive: 0
[10:33:59.535] plan(): Setting new future strategy stack:
[10:33:59.535]  length: 3
[10:33:59.535]  elements: ‘a’, ‘b’, ‘’
[10:33:59.536] run() for ‘Future’ ...
[10:33:59.536] - state: ‘created’
[10:33:59.535] List of future strategies:
[10:33:59.535] 1. sequential:
[10:33:59.535]    - args: function (..., envir = parent.frame())
[10:33:59.535]    - tweaked: FALSE
[10:33:59.535]    - call: NULL
[10:33:59.536] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:59.536] plan(): nbrOfWorkers() = 1
[10:33:59.538] plan(): Setting new future strategy stack:
[10:33:59.539] List of future strategies:
[10:33:59.539] 1. multicore:
[10:33:59.539]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:59.539]    - tweaked: FALSE
[10:33:59.539]    - call: plan(strategy)
[10:33:59.541] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:59.542] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:59.542]   - Field: ‘label’
[10:33:59.542]   - Field: ‘local’
[10:33:59.542]   - Field: ‘owner’
[10:33:59.542]   - Field: ‘envir’
[10:33:59.543]   - Field: ‘workers’
[10:33:59.543]   - Field: ‘packages’
[10:33:59.543]   - Field: ‘gc’
[10:33:59.543]   - Field: ‘job’
[10:33:59.543]   - Field: ‘conditions’
[10:33:59.543] plan(): nbrOfWorkers() = 2
[10:33:59.543]   - Field: ‘expr’
[10:33:59.544]   - Field: ‘uuid’
[10:33:59.544]   - Field: ‘seed’
[10:33:59.544]   - Field: ‘version’
[10:33:59.544]   - Field: ‘result’
[10:33:59.544]   - Field: ‘asynchronous’
[10:33:59.544]   - Field: ‘calls’
[10:33:59.545]   - Field: ‘globals’
[10:33:59.545]   - Field: ‘stdout’
[10:33:59.545]   - Field: ‘earlySignal’
[10:33:59.545]   - Field: ‘lazy’
[10:33:59.545]   - Field: ‘state’
[10:33:59.545] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:59.546] - Launch lazy future ...
[10:33:59.546] Packages needed by the future expression (n = 0): <none>
[10:33:59.546] Packages needed by future strategies (n = 0): <none>
[10:33:59.547] {
[10:33:59.547]     {
[10:33:59.547]         {
[10:33:59.547]             ...future.startTime <- base::Sys.time()
[10:33:59.547]             {
[10:33:59.547]                 {
[10:33:59.547]                   {
[10:33:59.547]                     {
[10:33:59.547]                       base::local({
[10:33:59.547]                         has_future <- base::requireNamespace("future", 
[10:33:59.547]                           quietly = TRUE)
[10:33:59.547]                         if (has_future) {
[10:33:59.547]                           ns <- base::getNamespace("future")
[10:33:59.547]                           version <- ns[[".package"]][["version"]]
[10:33:59.547]                           if (is.null(version)) 
[10:33:59.547]                             version <- utils::packageVersion("future")
[10:33:59.547]                         }
[10:33:59.547]                         else {
[10:33:59.547]                           version <- NULL
[10:33:59.547]                         }
[10:33:59.547]                         if (!has_future || version < "1.8.0") {
[10:33:59.547]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:59.547]                             "", base::R.version$version.string), 
[10:33:59.547]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:59.547]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:59.547]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:59.547]                               "release", "version")], collapse = " "), 
[10:33:59.547]                             hostname = base::Sys.info()[["nodename"]])
[10:33:59.547]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:59.547]                             info)
[10:33:59.547]                           info <- base::paste(info, collapse = "; ")
[10:33:59.547]                           if (!has_future) {
[10:33:59.547]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:59.547]                               info)
[10:33:59.547]                           }
[10:33:59.547]                           else {
[10:33:59.547]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:59.547]                               info, version)
[10:33:59.547]                           }
[10:33:59.547]                           base::stop(msg)
[10:33:59.547]                         }
[10:33:59.547]                       })
[10:33:59.547]                     }
[10:33:59.547]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:59.547]                     base::options(mc.cores = 1L)
[10:33:59.547]                   }
[10:33:59.547]                   ...future.strategy.old <- future::plan("list")
[10:33:59.547]                   options(future.plan = NULL)
[10:33:59.547]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:59.547]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:59.547]                 }
[10:33:59.547]                 ...future.workdir <- getwd()
[10:33:59.547]             }
[10:33:59.547]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:59.547]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:59.547]         }
[10:33:59.547]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:59.547]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:59.547]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:59.547]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:59.547]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:59.547]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:59.547]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:59.547]             base::names(...future.oldOptions))
[10:33:59.547]     }
[10:33:59.547]     if (FALSE) {
[10:33:59.547]     }
[10:33:59.547]     else {
[10:33:59.547]         if (TRUE) {
[10:33:59.547]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:59.547]                 open = "w")
[10:33:59.547]         }
[10:33:59.547]         else {
[10:33:59.547]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:59.547]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:59.547]         }
[10:33:59.547]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:59.547]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:59.547]             base::sink(type = "output", split = FALSE)
[10:33:59.547]             base::close(...future.stdout)
[10:33:59.547]         }, add = TRUE)
[10:33:59.547]     }
[10:33:59.547]     ...future.frame <- base::sys.nframe()
[10:33:59.547]     ...future.conditions <- base::list()
[10:33:59.547]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:59.547]     if (FALSE) {
[10:33:59.547]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:59.547]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:59.547]     }
[10:33:59.547]     ...future.result <- base::tryCatch({
[10:33:59.547]         base::withCallingHandlers({
[10:33:59.547]             ...future.value <- base::withVisible(base::local({
[10:33:59.547]                 withCallingHandlers({
[10:33:59.547]                   1
[10:33:59.547]                 }, immediateCondition = function(cond) {
[10:33:59.547]                   save_rds <- function (object, pathname, ...) 
[10:33:59.547]                   {
[10:33:59.547]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:59.547]                     if (file_test("-f", pathname_tmp)) {
[10:33:59.547]                       fi_tmp <- file.info(pathname_tmp)
[10:33:59.547]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:59.547]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:59.547]                         fi_tmp[["mtime"]])
[10:33:59.547]                     }
[10:33:59.547]                     tryCatch({
[10:33:59.547]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:59.547]                     }, error = function(ex) {
[10:33:59.547]                       msg <- conditionMessage(ex)
[10:33:59.547]                       fi_tmp <- file.info(pathname_tmp)
[10:33:59.547]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:59.547]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:59.547]                         fi_tmp[["mtime"]], msg)
[10:33:59.547]                       ex$message <- msg
[10:33:59.547]                       stop(ex)
[10:33:59.547]                     })
[10:33:59.547]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:59.547]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:59.547]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:59.547]                       fi_tmp <- file.info(pathname_tmp)
[10:33:59.547]                       fi <- file.info(pathname)
[10:33:59.547]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:59.547]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:59.547]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:59.547]                         fi[["size"]], fi[["mtime"]])
[10:33:59.547]                       stop(msg)
[10:33:59.547]                     }
[10:33:59.547]                     invisible(pathname)
[10:33:59.547]                   }
[10:33:59.547]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:59.547]                     rootPath = tempdir()) 
[10:33:59.547]                   {
[10:33:59.547]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:59.547]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:59.547]                       tmpdir = path, fileext = ".rds")
[10:33:59.547]                     save_rds(obj, file)
[10:33:59.547]                   }
[10:33:59.547]                   saveImmediateCondition(cond, path = "/tmp/RtmpuZEzLw/.future/immediateConditions")
[10:33:59.547]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:59.547]                   {
[10:33:59.547]                     inherits <- base::inherits
[10:33:59.547]                     invokeRestart <- base::invokeRestart
[10:33:59.547]                     is.null <- base::is.null
[10:33:59.547]                     muffled <- FALSE
[10:33:59.547]                     if (inherits(cond, "message")) {
[10:33:59.547]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:59.547]                       if (muffled) 
[10:33:59.547]                         invokeRestart("muffleMessage")
[10:33:59.547]                     }
[10:33:59.547]                     else if (inherits(cond, "warning")) {
[10:33:59.547]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:59.547]                       if (muffled) 
[10:33:59.547]                         invokeRestart("muffleWarning")
[10:33:59.547]                     }
[10:33:59.547]                     else if (inherits(cond, "condition")) {
[10:33:59.547]                       if (!is.null(pattern)) {
[10:33:59.547]                         computeRestarts <- base::computeRestarts
[10:33:59.547]                         grepl <- base::grepl
[10:33:59.547]                         restarts <- computeRestarts(cond)
[10:33:59.547]                         for (restart in restarts) {
[10:33:59.547]                           name <- restart$name
[10:33:59.547]                           if (is.null(name)) 
[10:33:59.547]                             next
[10:33:59.547]                           if (!grepl(pattern, name)) 
[10:33:59.547]                             next
[10:33:59.547]                           invokeRestart(restart)
[10:33:59.547]                           muffled <- TRUE
[10:33:59.547]                           break
[10:33:59.547]                         }
[10:33:59.547]                       }
[10:33:59.547]                     }
[10:33:59.547]                     invisible(muffled)
[10:33:59.547]                   }
[10:33:59.547]                   muffleCondition(cond)
[10:33:59.547]                 })
[10:33:59.547]             }))
[10:33:59.547]             future::FutureResult(value = ...future.value$value, 
[10:33:59.547]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:59.547]                   ...future.rng), globalenv = if (FALSE) 
[10:33:59.547]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:59.547]                     ...future.globalenv.names))
[10:33:59.547]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:59.547]         }, condition = base::local({
[10:33:59.547]             c <- base::c
[10:33:59.547]             inherits <- base::inherits
[10:33:59.547]             invokeRestart <- base::invokeRestart
[10:33:59.547]             length <- base::length
[10:33:59.547]             list <- base::list
[10:33:59.547]             seq.int <- base::seq.int
[10:33:59.547]             signalCondition <- base::signalCondition
[10:33:59.547]             sys.calls <- base::sys.calls
[10:33:59.547]             `[[` <- base::`[[`
[10:33:59.547]             `+` <- base::`+`
[10:33:59.547]             `<<-` <- base::`<<-`
[10:33:59.547]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:59.547]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:59.547]                   3L)]
[10:33:59.547]             }
[10:33:59.547]             function(cond) {
[10:33:59.547]                 is_error <- inherits(cond, "error")
[10:33:59.547]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:59.547]                   NULL)
[10:33:59.547]                 if (is_error) {
[10:33:59.547]                   sessionInformation <- function() {
[10:33:59.547]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:59.547]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:59.547]                       search = base::search(), system = base::Sys.info())
[10:33:59.547]                   }
[10:33:59.547]                   ...future.conditions[[length(...future.conditions) + 
[10:33:59.547]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:59.547]                     cond$call), session = sessionInformation(), 
[10:33:59.547]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:59.547]                   signalCondition(cond)
[10:33:59.547]                 }
[10:33:59.547]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:59.547]                 "immediateCondition"))) {
[10:33:59.547]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:59.547]                   ...future.conditions[[length(...future.conditions) + 
[10:33:59.547]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:59.547]                   if (TRUE && !signal) {
[10:33:59.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:59.547]                     {
[10:33:59.547]                       inherits <- base::inherits
[10:33:59.547]                       invokeRestart <- base::invokeRestart
[10:33:59.547]                       is.null <- base::is.null
[10:33:59.547]                       muffled <- FALSE
[10:33:59.547]                       if (inherits(cond, "message")) {
[10:33:59.547]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:59.547]                         if (muffled) 
[10:33:59.547]                           invokeRestart("muffleMessage")
[10:33:59.547]                       }
[10:33:59.547]                       else if (inherits(cond, "warning")) {
[10:33:59.547]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:59.547]                         if (muffled) 
[10:33:59.547]                           invokeRestart("muffleWarning")
[10:33:59.547]                       }
[10:33:59.547]                       else if (inherits(cond, "condition")) {
[10:33:59.547]                         if (!is.null(pattern)) {
[10:33:59.547]                           computeRestarts <- base::computeRestarts
[10:33:59.547]                           grepl <- base::grepl
[10:33:59.547]                           restarts <- computeRestarts(cond)
[10:33:59.547]                           for (restart in restarts) {
[10:33:59.547]                             name <- restart$name
[10:33:59.547]                             if (is.null(name)) 
[10:33:59.547]                               next
[10:33:59.547]                             if (!grepl(pattern, name)) 
[10:33:59.547]                               next
[10:33:59.547]                             invokeRestart(restart)
[10:33:59.547]                             muffled <- TRUE
[10:33:59.547]                             break
[10:33:59.547]                           }
[10:33:59.547]                         }
[10:33:59.547]                       }
[10:33:59.547]                       invisible(muffled)
[10:33:59.547]                     }
[10:33:59.547]                     muffleCondition(cond, pattern = "^muffle")
[10:33:59.547]                   }
[10:33:59.547]                 }
[10:33:59.547]                 else {
[10:33:59.547]                   if (TRUE) {
[10:33:59.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:59.547]                     {
[10:33:59.547]                       inherits <- base::inherits
[10:33:59.547]                       invokeRestart <- base::invokeRestart
[10:33:59.547]                       is.null <- base::is.null
[10:33:59.547]                       muffled <- FALSE
[10:33:59.547]                       if (inherits(cond, "message")) {
[10:33:59.547]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:59.547]                         if (muffled) 
[10:33:59.547]                           invokeRestart("muffleMessage")
[10:33:59.547]                       }
[10:33:59.547]                       else if (inherits(cond, "warning")) {
[10:33:59.547]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:59.547]                         if (muffled) 
[10:33:59.547]                           invokeRestart("muffleWarning")
[10:33:59.547]                       }
[10:33:59.547]                       else if (inherits(cond, "condition")) {
[10:33:59.547]                         if (!is.null(pattern)) {
[10:33:59.547]                           computeRestarts <- base::computeRestarts
[10:33:59.547]                           grepl <- base::grepl
[10:33:59.547]                           restarts <- computeRestarts(cond)
[10:33:59.547]                           for (restart in restarts) {
[10:33:59.547]                             name <- restart$name
[10:33:59.547]                             if (is.null(name)) 
[10:33:59.547]                               next
[10:33:59.547]                             if (!grepl(pattern, name)) 
[10:33:59.547]                               next
[10:33:59.547]                             invokeRestart(restart)
[10:33:59.547]                             muffled <- TRUE
[10:33:59.547]                             break
[10:33:59.547]                           }
[10:33:59.547]                         }
[10:33:59.547]                       }
[10:33:59.547]                       invisible(muffled)
[10:33:59.547]                     }
[10:33:59.547]                     muffleCondition(cond, pattern = "^muffle")
[10:33:59.547]                   }
[10:33:59.547]                 }
[10:33:59.547]             }
[10:33:59.547]         }))
[10:33:59.547]     }, error = function(ex) {
[10:33:59.547]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:59.547]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:59.547]                 ...future.rng), started = ...future.startTime, 
[10:33:59.547]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:59.547]             version = "1.8"), class = "FutureResult")
[10:33:59.547]     }, finally = {
[10:33:59.547]         if (!identical(...future.workdir, getwd())) 
[10:33:59.547]             setwd(...future.workdir)
[10:33:59.547]         {
[10:33:59.547]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:59.547]                 ...future.oldOptions$nwarnings <- NULL
[10:33:59.547]             }
[10:33:59.547]             base::options(...future.oldOptions)
[10:33:59.547]             if (.Platform$OS.type == "windows") {
[10:33:59.547]                 old_names <- names(...future.oldEnvVars)
[10:33:59.547]                 envs <- base::Sys.getenv()
[10:33:59.547]                 names <- names(envs)
[10:33:59.547]                 common <- intersect(names, old_names)
[10:33:59.547]                 added <- setdiff(names, old_names)
[10:33:59.547]                 removed <- setdiff(old_names, names)
[10:33:59.547]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:59.547]                   envs[common]]
[10:33:59.547]                 NAMES <- toupper(changed)
[10:33:59.547]                 args <- list()
[10:33:59.547]                 for (kk in seq_along(NAMES)) {
[10:33:59.547]                   name <- changed[[kk]]
[10:33:59.547]                   NAME <- NAMES[[kk]]
[10:33:59.547]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:59.547]                     next
[10:33:59.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:59.547]                 }
[10:33:59.547]                 NAMES <- toupper(added)
[10:33:59.547]                 for (kk in seq_along(NAMES)) {
[10:33:59.547]                   name <- added[[kk]]
[10:33:59.547]                   NAME <- NAMES[[kk]]
[10:33:59.547]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:59.547]                     next
[10:33:59.547]                   args[[name]] <- ""
[10:33:59.547]                 }
[10:33:59.547]                 NAMES <- toupper(removed)
[10:33:59.547]                 for (kk in seq_along(NAMES)) {
[10:33:59.547]                   name <- removed[[kk]]
[10:33:59.547]                   NAME <- NAMES[[kk]]
[10:33:59.547]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:59.547]                     next
[10:33:59.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:59.547]                 }
[10:33:59.547]                 if (length(args) > 0) 
[10:33:59.547]                   base::do.call(base::Sys.setenv, args = args)
[10:33:59.547]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:59.547]             }
[10:33:59.547]             else {
[10:33:59.547]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:59.547]             }
[10:33:59.547]             {
[10:33:59.547]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:59.547]                   0L) {
[10:33:59.547]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:59.547]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:59.547]                   base::options(opts)
[10:33:59.547]                 }
[10:33:59.547]                 {
[10:33:59.547]                   {
[10:33:59.547]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:59.547]                     NULL
[10:33:59.547]                   }
[10:33:59.547]                   options(future.plan = NULL)
[10:33:59.547]                   if (is.na(NA_character_)) 
[10:33:59.547]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:59.547]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:59.547]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:59.547]                     .init = FALSE)
[10:33:59.547]                 }
[10:33:59.547]             }
[10:33:59.547]         }
[10:33:59.547]     })
[10:33:59.547]     if (TRUE) {
[10:33:59.547]         base::sink(type = "output", split = FALSE)
[10:33:59.547]         if (TRUE) {
[10:33:59.547]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:59.547]         }
[10:33:59.547]         else {
[10:33:59.547]             ...future.result["stdout"] <- base::list(NULL)
[10:33:59.547]         }
[10:33:59.547]         base::close(...future.stdout)
[10:33:59.547]         ...future.stdout <- NULL
[10:33:59.547]     }
[10:33:59.547]     ...future.result$conditions <- ...future.conditions
[10:33:59.547]     ...future.result$finished <- base::Sys.time()
[10:33:59.547]     ...future.result
[10:33:59.547] }
[10:33:59.550] requestCore(): workers = 2
[10:33:59.551] Poll #1 (0): usedCores() = 2, workers = 2
[10:33:59.574] result() for MulticoreFuture ...
[10:33:59.575] result() for MulticoreFuture ...
[10:33:59.575] result() for MulticoreFuture ... done
[10:33:59.575] result() for MulticoreFuture ... done
[10:33:59.578] result() for MulticoreFuture ...
[10:33:59.579] result() for MulticoreFuture ... done
[10:33:59.581] MulticoreFuture started
[10:33:59.582] - Launch lazy future ... done
[10:33:59.583] run() for ‘MulticoreFuture’ ... done
[10:33:59.583] plan(): Setting new future strategy stack:
[10:33:59.583] List of future strategies:
[10:33:59.583] 1. sequential:
[10:33:59.583]    - args: function (..., envir = parent.frame())
[10:33:59.583]    - tweaked: FALSE
[10:33:59.583]    - call: NULL
[10:33:59.585] plan(): nbrOfWorkers() = 1
[10:33:59.588] plan(): Setting new future strategy stack:
[10:33:59.589] List of future strategies:
[10:33:59.589] 1. multicore:
[10:33:59.589]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:59.589]    - tweaked: FALSE
[10:33:59.589]    - call: plan(strategy)
[10:33:59.594] Future #2
[10:33:59.595]  length: 2 (resolved future 2)
[10:33:59.595] plan(): nbrOfWorkers() = 2
[10:33:59.595]  length: 1 (resolved future 3)
[10:33:59.606] Future #1
[10:33:59.606]  length: 0 (resolved future 1)
[10:33:59.606] resolve() on list ... DONE
[10:33:59.607] getGlobalsAndPackages() ...
[10:33:59.607] Searching for globals...
[10:33:59.608] 
[10:33:59.608] Searching for globals ... DONE
[10:33:59.609] - globals: [0] <none>
[10:33:59.609] getGlobalsAndPackages() ... DONE
[10:33:59.609] getGlobalsAndPackages() ...
[10:33:59.609] Searching for globals...
[10:33:59.610] 
[10:33:59.610] Searching for globals ... DONE
[10:33:59.610] - globals: [0] <none>
[10:33:59.610] getGlobalsAndPackages() ... DONE
[10:33:59.611] resolve() on list ...
[10:33:59.611]  recursive: 0
[10:33:59.611]  length: 3
[10:33:59.611]  elements: ‘a’, ‘b’, ‘’
[10:33:59.612] run() for ‘Future’ ...
[10:33:59.612] - state: ‘created’
[10:33:59.612] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:59.617] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:59.617] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:59.618]   - Field: ‘label’
[10:33:59.618]   - Field: ‘local’
[10:33:59.618]   - Field: ‘owner’
[10:33:59.618]   - Field: ‘envir’
[10:33:59.618]   - Field: ‘workers’
[10:33:59.618]   - Field: ‘packages’
[10:33:59.619]   - Field: ‘gc’
[10:33:59.619]   - Field: ‘job’
[10:33:59.619]   - Field: ‘conditions’
[10:33:59.619]   - Field: ‘expr’
[10:33:59.619]   - Field: ‘uuid’
[10:33:59.619]   - Field: ‘seed’
[10:33:59.619]   - Field: ‘version’
[10:33:59.620]   - Field: ‘result’
[10:33:59.620]   - Field: ‘asynchronous’
[10:33:59.620]   - Field: ‘calls’
[10:33:59.620]   - Field: ‘globals’
[10:33:59.620]   - Field: ‘stdout’
[10:33:59.620]   - Field: ‘earlySignal’
[10:33:59.620]   - Field: ‘lazy’
[10:33:59.621]   - Field: ‘state’
[10:33:59.621] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:59.621] - Launch lazy future ...
[10:33:59.621] Packages needed by the future expression (n = 0): <none>
[10:33:59.621] Packages needed by future strategies (n = 0): <none>
[10:33:59.622] {
[10:33:59.622]     {
[10:33:59.622]         {
[10:33:59.622]             ...future.startTime <- base::Sys.time()
[10:33:59.622]             {
[10:33:59.622]                 {
[10:33:59.622]                   {
[10:33:59.622]                     {
[10:33:59.622]                       base::local({
[10:33:59.622]                         has_future <- base::requireNamespace("future", 
[10:33:59.622]                           quietly = TRUE)
[10:33:59.622]                         if (has_future) {
[10:33:59.622]                           ns <- base::getNamespace("future")
[10:33:59.622]                           version <- ns[[".package"]][["version"]]
[10:33:59.622]                           if (is.null(version)) 
[10:33:59.622]                             version <- utils::packageVersion("future")
[10:33:59.622]                         }
[10:33:59.622]                         else {
[10:33:59.622]                           version <- NULL
[10:33:59.622]                         }
[10:33:59.622]                         if (!has_future || version < "1.8.0") {
[10:33:59.622]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:59.622]                             "", base::R.version$version.string), 
[10:33:59.622]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:59.622]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:59.622]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:59.622]                               "release", "version")], collapse = " "), 
[10:33:59.622]                             hostname = base::Sys.info()[["nodename"]])
[10:33:59.622]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:59.622]                             info)
[10:33:59.622]                           info <- base::paste(info, collapse = "; ")
[10:33:59.622]                           if (!has_future) {
[10:33:59.622]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:59.622]                               info)
[10:33:59.622]                           }
[10:33:59.622]                           else {
[10:33:59.622]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:59.622]                               info, version)
[10:33:59.622]                           }
[10:33:59.622]                           base::stop(msg)
[10:33:59.622]                         }
[10:33:59.622]                       })
[10:33:59.622]                     }
[10:33:59.622]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:59.622]                     base::options(mc.cores = 1L)
[10:33:59.622]                   }
[10:33:59.622]                   ...future.strategy.old <- future::plan("list")
[10:33:59.622]                   options(future.plan = NULL)
[10:33:59.622]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:59.622]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:59.622]                 }
[10:33:59.622]                 ...future.workdir <- getwd()
[10:33:59.622]             }
[10:33:59.622]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:59.622]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:59.622]         }
[10:33:59.622]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:59.622]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:59.622]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:59.622]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:59.622]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:59.622]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:59.622]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:59.622]             base::names(...future.oldOptions))
[10:33:59.622]     }
[10:33:59.622]     if (FALSE) {
[10:33:59.622]     }
[10:33:59.622]     else {
[10:33:59.622]         if (TRUE) {
[10:33:59.622]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:59.622]                 open = "w")
[10:33:59.622]         }
[10:33:59.622]         else {
[10:33:59.622]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:59.622]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:59.622]         }
[10:33:59.622]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:59.622]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:59.622]             base::sink(type = "output", split = FALSE)
[10:33:59.622]             base::close(...future.stdout)
[10:33:59.622]         }, add = TRUE)
[10:33:59.622]     }
[10:33:59.622]     ...future.frame <- base::sys.nframe()
[10:33:59.622]     ...future.conditions <- base::list()
[10:33:59.622]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:59.622]     if (FALSE) {
[10:33:59.622]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:59.622]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:59.622]     }
[10:33:59.622]     ...future.result <- base::tryCatch({
[10:33:59.622]         base::withCallingHandlers({
[10:33:59.622]             ...future.value <- base::withVisible(base::local({
[10:33:59.622]                 withCallingHandlers({
[10:33:59.622]                   1
[10:33:59.622]                 }, immediateCondition = function(cond) {
[10:33:59.622]                   save_rds <- function (object, pathname, ...) 
[10:33:59.622]                   {
[10:33:59.622]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:59.622]                     if (file_test("-f", pathname_tmp)) {
[10:33:59.622]                       fi_tmp <- file.info(pathname_tmp)
[10:33:59.622]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:59.622]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:59.622]                         fi_tmp[["mtime"]])
[10:33:59.622]                     }
[10:33:59.622]                     tryCatch({
[10:33:59.622]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:59.622]                     }, error = function(ex) {
[10:33:59.622]                       msg <- conditionMessage(ex)
[10:33:59.622]                       fi_tmp <- file.info(pathname_tmp)
[10:33:59.622]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:59.622]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:59.622]                         fi_tmp[["mtime"]], msg)
[10:33:59.622]                       ex$message <- msg
[10:33:59.622]                       stop(ex)
[10:33:59.622]                     })
[10:33:59.622]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:59.622]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:59.622]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:59.622]                       fi_tmp <- file.info(pathname_tmp)
[10:33:59.622]                       fi <- file.info(pathname)
[10:33:59.622]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:59.622]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:59.622]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:59.622]                         fi[["size"]], fi[["mtime"]])
[10:33:59.622]                       stop(msg)
[10:33:59.622]                     }
[10:33:59.622]                     invisible(pathname)
[10:33:59.622]                   }
[10:33:59.622]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:59.622]                     rootPath = tempdir()) 
[10:33:59.622]                   {
[10:33:59.622]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:59.622]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:59.622]                       tmpdir = path, fileext = ".rds")
[10:33:59.622]                     save_rds(obj, file)
[10:33:59.622]                   }
[10:33:59.622]                   saveImmediateCondition(cond, path = "/tmp/RtmpuZEzLw/.future/immediateConditions")
[10:33:59.622]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:59.622]                   {
[10:33:59.622]                     inherits <- base::inherits
[10:33:59.622]                     invokeRestart <- base::invokeRestart
[10:33:59.622]                     is.null <- base::is.null
[10:33:59.622]                     muffled <- FALSE
[10:33:59.622]                     if (inherits(cond, "message")) {
[10:33:59.622]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:59.622]                       if (muffled) 
[10:33:59.622]                         invokeRestart("muffleMessage")
[10:33:59.622]                     }
[10:33:59.622]                     else if (inherits(cond, "warning")) {
[10:33:59.622]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:59.622]                       if (muffled) 
[10:33:59.622]                         invokeRestart("muffleWarning")
[10:33:59.622]                     }
[10:33:59.622]                     else if (inherits(cond, "condition")) {
[10:33:59.622]                       if (!is.null(pattern)) {
[10:33:59.622]                         computeRestarts <- base::computeRestarts
[10:33:59.622]                         grepl <- base::grepl
[10:33:59.622]                         restarts <- computeRestarts(cond)
[10:33:59.622]                         for (restart in restarts) {
[10:33:59.622]                           name <- restart$name
[10:33:59.622]                           if (is.null(name)) 
[10:33:59.622]                             next
[10:33:59.622]                           if (!grepl(pattern, name)) 
[10:33:59.622]                             next
[10:33:59.622]                           invokeRestart(restart)
[10:33:59.622]                           muffled <- TRUE
[10:33:59.622]                           break
[10:33:59.622]                         }
[10:33:59.622]                       }
[10:33:59.622]                     }
[10:33:59.622]                     invisible(muffled)
[10:33:59.622]                   }
[10:33:59.622]                   muffleCondition(cond)
[10:33:59.622]                 })
[10:33:59.622]             }))
[10:33:59.622]             future::FutureResult(value = ...future.value$value, 
[10:33:59.622]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:59.622]                   ...future.rng), globalenv = if (FALSE) 
[10:33:59.622]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:59.622]                     ...future.globalenv.names))
[10:33:59.622]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:59.622]         }, condition = base::local({
[10:33:59.622]             c <- base::c
[10:33:59.622]             inherits <- base::inherits
[10:33:59.622]             invokeRestart <- base::invokeRestart
[10:33:59.622]             length <- base::length
[10:33:59.622]             list <- base::list
[10:33:59.622]             seq.int <- base::seq.int
[10:33:59.622]             signalCondition <- base::signalCondition
[10:33:59.622]             sys.calls <- base::sys.calls
[10:33:59.622]             `[[` <- base::`[[`
[10:33:59.622]             `+` <- base::`+`
[10:33:59.622]             `<<-` <- base::`<<-`
[10:33:59.622]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:59.622]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:59.622]                   3L)]
[10:33:59.622]             }
[10:33:59.622]             function(cond) {
[10:33:59.622]                 is_error <- inherits(cond, "error")
[10:33:59.622]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:59.622]                   NULL)
[10:33:59.622]                 if (is_error) {
[10:33:59.622]                   sessionInformation <- function() {
[10:33:59.622]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:59.622]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:59.622]                       search = base::search(), system = base::Sys.info())
[10:33:59.622]                   }
[10:33:59.622]                   ...future.conditions[[length(...future.conditions) + 
[10:33:59.622]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:59.622]                     cond$call), session = sessionInformation(), 
[10:33:59.622]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:59.622]                   signalCondition(cond)
[10:33:59.622]                 }
[10:33:59.622]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:59.622]                 "immediateCondition"))) {
[10:33:59.622]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:59.622]                   ...future.conditions[[length(...future.conditions) + 
[10:33:59.622]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:59.622]                   if (TRUE && !signal) {
[10:33:59.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:59.622]                     {
[10:33:59.622]                       inherits <- base::inherits
[10:33:59.622]                       invokeRestart <- base::invokeRestart
[10:33:59.622]                       is.null <- base::is.null
[10:33:59.622]                       muffled <- FALSE
[10:33:59.622]                       if (inherits(cond, "message")) {
[10:33:59.622]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:59.622]                         if (muffled) 
[10:33:59.622]                           invokeRestart("muffleMessage")
[10:33:59.622]                       }
[10:33:59.622]                       else if (inherits(cond, "warning")) {
[10:33:59.622]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:59.622]                         if (muffled) 
[10:33:59.622]                           invokeRestart("muffleWarning")
[10:33:59.622]                       }
[10:33:59.622]                       else if (inherits(cond, "condition")) {
[10:33:59.622]                         if (!is.null(pattern)) {
[10:33:59.622]                           computeRestarts <- base::computeRestarts
[10:33:59.622]                           grepl <- base::grepl
[10:33:59.622]                           restarts <- computeRestarts(cond)
[10:33:59.622]                           for (restart in restarts) {
[10:33:59.622]                             name <- restart$name
[10:33:59.622]                             if (is.null(name)) 
[10:33:59.622]                               next
[10:33:59.622]                             if (!grepl(pattern, name)) 
[10:33:59.622]                               next
[10:33:59.622]                             invokeRestart(restart)
[10:33:59.622]                             muffled <- TRUE
[10:33:59.622]                             break
[10:33:59.622]                           }
[10:33:59.622]                         }
[10:33:59.622]                       }
[10:33:59.622]                       invisible(muffled)
[10:33:59.622]                     }
[10:33:59.622]                     muffleCondition(cond, pattern = "^muffle")
[10:33:59.622]                   }
[10:33:59.622]                 }
[10:33:59.622]                 else {
[10:33:59.622]                   if (TRUE) {
[10:33:59.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:59.622]                     {
[10:33:59.622]                       inherits <- base::inherits
[10:33:59.622]                       invokeRestart <- base::invokeRestart
[10:33:59.622]                       is.null <- base::is.null
[10:33:59.622]                       muffled <- FALSE
[10:33:59.622]                       if (inherits(cond, "message")) {
[10:33:59.622]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:59.622]                         if (muffled) 
[10:33:59.622]                           invokeRestart("muffleMessage")
[10:33:59.622]                       }
[10:33:59.622]                       else if (inherits(cond, "warning")) {
[10:33:59.622]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:59.622]                         if (muffled) 
[10:33:59.622]                           invokeRestart("muffleWarning")
[10:33:59.622]                       }
[10:33:59.622]                       else if (inherits(cond, "condition")) {
[10:33:59.622]                         if (!is.null(pattern)) {
[10:33:59.622]                           computeRestarts <- base::computeRestarts
[10:33:59.622]                           grepl <- base::grepl
[10:33:59.622]                           restarts <- computeRestarts(cond)
[10:33:59.622]                           for (restart in restarts) {
[10:33:59.622]                             name <- restart$name
[10:33:59.622]                             if (is.null(name)) 
[10:33:59.622]                               next
[10:33:59.622]                             if (!grepl(pattern, name)) 
[10:33:59.622]                               next
[10:33:59.622]                             invokeRestart(restart)
[10:33:59.622]                             muffled <- TRUE
[10:33:59.622]                             break
[10:33:59.622]                           }
[10:33:59.622]                         }
[10:33:59.622]                       }
[10:33:59.622]                       invisible(muffled)
[10:33:59.622]                     }
[10:33:59.622]                     muffleCondition(cond, pattern = "^muffle")
[10:33:59.622]                   }
[10:33:59.622]                 }
[10:33:59.622]             }
[10:33:59.622]         }))
[10:33:59.622]     }, error = function(ex) {
[10:33:59.622]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:59.622]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:59.622]                 ...future.rng), started = ...future.startTime, 
[10:33:59.622]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:59.622]             version = "1.8"), class = "FutureResult")
[10:33:59.622]     }, finally = {
[10:33:59.622]         if (!identical(...future.workdir, getwd())) 
[10:33:59.622]             setwd(...future.workdir)
[10:33:59.622]         {
[10:33:59.622]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:59.622]                 ...future.oldOptions$nwarnings <- NULL
[10:33:59.622]             }
[10:33:59.622]             base::options(...future.oldOptions)
[10:33:59.622]             if (.Platform$OS.type == "windows") {
[10:33:59.622]                 old_names <- names(...future.oldEnvVars)
[10:33:59.622]                 envs <- base::Sys.getenv()
[10:33:59.622]                 names <- names(envs)
[10:33:59.622]                 common <- intersect(names, old_names)
[10:33:59.622]                 added <- setdiff(names, old_names)
[10:33:59.622]                 removed <- setdiff(old_names, names)
[10:33:59.622]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:59.622]                   envs[common]]
[10:33:59.622]                 NAMES <- toupper(changed)
[10:33:59.622]                 args <- list()
[10:33:59.622]                 for (kk in seq_along(NAMES)) {
[10:33:59.622]                   name <- changed[[kk]]
[10:33:59.622]                   NAME <- NAMES[[kk]]
[10:33:59.622]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:59.622]                     next
[10:33:59.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:59.622]                 }
[10:33:59.622]                 NAMES <- toupper(added)
[10:33:59.622]                 for (kk in seq_along(NAMES)) {
[10:33:59.622]                   name <- added[[kk]]
[10:33:59.622]                   NAME <- NAMES[[kk]]
[10:33:59.622]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:59.622]                     next
[10:33:59.622]                   args[[name]] <- ""
[10:33:59.622]                 }
[10:33:59.622]                 NAMES <- toupper(removed)
[10:33:59.622]                 for (kk in seq_along(NAMES)) {
[10:33:59.622]                   name <- removed[[kk]]
[10:33:59.622]                   NAME <- NAMES[[kk]]
[10:33:59.622]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:59.622]                     next
[10:33:59.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:59.622]                 }
[10:33:59.622]                 if (length(args) > 0) 
[10:33:59.622]                   base::do.call(base::Sys.setenv, args = args)
[10:33:59.622]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:59.622]             }
[10:33:59.622]             else {
[10:33:59.622]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:59.622]             }
[10:33:59.622]             {
[10:33:59.622]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:59.622]                   0L) {
[10:33:59.622]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:59.622]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:59.622]                   base::options(opts)
[10:33:59.622]                 }
[10:33:59.622]                 {
[10:33:59.622]                   {
[10:33:59.622]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:59.622]                     NULL
[10:33:59.622]                   }
[10:33:59.622]                   options(future.plan = NULL)
[10:33:59.622]                   if (is.na(NA_character_)) 
[10:33:59.622]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:59.622]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:59.622]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:59.622]                     .init = FALSE)
[10:33:59.622]                 }
[10:33:59.622]             }
[10:33:59.622]         }
[10:33:59.622]     })
[10:33:59.622]     if (TRUE) {
[10:33:59.622]         base::sink(type = "output", split = FALSE)
[10:33:59.622]         if (TRUE) {
[10:33:59.622]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:59.622]         }
[10:33:59.622]         else {
[10:33:59.622]             ...future.result["stdout"] <- base::list(NULL)
[10:33:59.622]         }
[10:33:59.622]         base::close(...future.stdout)
[10:33:59.622]         ...future.stdout <- NULL
[10:33:59.622]     }
[10:33:59.622]     ...future.result$conditions <- ...future.conditions
[10:33:59.622]     ...future.result$finished <- base::Sys.time()
[10:33:59.622]     ...future.result
[10:33:59.622] }
[10:33:59.626] requestCore(): workers = 2
[10:33:59.626] Poll #1 (0): usedCores() = 2, workers = 2
[10:33:59.637] result() for MulticoreFuture ...
[10:33:59.637] result() for MulticoreFuture ...
[10:33:59.638] result() for MulticoreFuture ... done
[10:33:59.638] result() for MulticoreFuture ... done
[10:33:59.638] result() for MulticoreFuture ...
[10:33:59.638] result() for MulticoreFuture ... done
[10:33:59.640] MulticoreFuture started
[10:33:59.641] - Launch lazy future ... done
[10:33:59.641] run() for ‘MulticoreFuture’ ... done
[10:33:59.642] plan(): Setting new future strategy stack:
[10:33:59.642] List of future strategies:
[10:33:59.642] 1. sequential:
[10:33:59.642]    - args: function (..., envir = parent.frame())
[10:33:59.642]    - tweaked: FALSE
[10:33:59.642]    - call: NULL
[10:33:59.643] plan(): nbrOfWorkers() = 1
[10:33:59.645] plan(): Setting new future strategy stack:
[10:33:59.646] List of future strategies:
[10:33:59.646] 1. multicore:
[10:33:59.646]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:59.646]    - tweaked: FALSE
[10:33:59.646]    - call: plan(strategy)
[10:33:59.651] plan(): nbrOfWorkers() = 2
[10:33:59.651] Future #1
[10:33:59.652]  length: 2 (resolved future 1)
[10:33:59.652] run() for ‘Future’ ...
[10:33:59.652] - state: ‘created’
[10:33:59.652] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:59.657] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:59.657] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:59.657]   - Field: ‘label’
[10:33:59.658]   - Field: ‘local’
[10:33:59.658]   - Field: ‘owner’
[10:33:59.658]   - Field: ‘envir’
[10:33:59.658]   - Field: ‘workers’
[10:33:59.658]   - Field: ‘packages’
[10:33:59.658]   - Field: ‘gc’
[10:33:59.658]   - Field: ‘job’
[10:33:59.659]   - Field: ‘conditions’
[10:33:59.659]   - Field: ‘expr’
[10:33:59.659]   - Field: ‘uuid’
[10:33:59.659]   - Field: ‘seed’
[10:33:59.659]   - Field: ‘version’
[10:33:59.659]   - Field: ‘result’
[10:33:59.660]   - Field: ‘asynchronous’
[10:33:59.660]   - Field: ‘calls’
[10:33:59.660]   - Field: ‘globals’
[10:33:59.660]   - Field: ‘stdout’
[10:33:59.660]   - Field: ‘earlySignal’
[10:33:59.661]   - Field: ‘lazy’
[10:33:59.661]   - Field: ‘state’
[10:33:59.661] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:59.661] - Launch lazy future ...
[10:33:59.662] Packages needed by the future expression (n = 0): <none>
[10:33:59.662] Packages needed by future strategies (n = 0): <none>
[10:33:59.663] {
[10:33:59.663]     {
[10:33:59.663]         {
[10:33:59.663]             ...future.startTime <- base::Sys.time()
[10:33:59.663]             {
[10:33:59.663]                 {
[10:33:59.663]                   {
[10:33:59.663]                     {
[10:33:59.663]                       base::local({
[10:33:59.663]                         has_future <- base::requireNamespace("future", 
[10:33:59.663]                           quietly = TRUE)
[10:33:59.663]                         if (has_future) {
[10:33:59.663]                           ns <- base::getNamespace("future")
[10:33:59.663]                           version <- ns[[".package"]][["version"]]
[10:33:59.663]                           if (is.null(version)) 
[10:33:59.663]                             version <- utils::packageVersion("future")
[10:33:59.663]                         }
[10:33:59.663]                         else {
[10:33:59.663]                           version <- NULL
[10:33:59.663]                         }
[10:33:59.663]                         if (!has_future || version < "1.8.0") {
[10:33:59.663]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:59.663]                             "", base::R.version$version.string), 
[10:33:59.663]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:59.663]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:59.663]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:59.663]                               "release", "version")], collapse = " "), 
[10:33:59.663]                             hostname = base::Sys.info()[["nodename"]])
[10:33:59.663]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:59.663]                             info)
[10:33:59.663]                           info <- base::paste(info, collapse = "; ")
[10:33:59.663]                           if (!has_future) {
[10:33:59.663]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:59.663]                               info)
[10:33:59.663]                           }
[10:33:59.663]                           else {
[10:33:59.663]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:59.663]                               info, version)
[10:33:59.663]                           }
[10:33:59.663]                           base::stop(msg)
[10:33:59.663]                         }
[10:33:59.663]                       })
[10:33:59.663]                     }
[10:33:59.663]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:59.663]                     base::options(mc.cores = 1L)
[10:33:59.663]                   }
[10:33:59.663]                   ...future.strategy.old <- future::plan("list")
[10:33:59.663]                   options(future.plan = NULL)
[10:33:59.663]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:59.663]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:59.663]                 }
[10:33:59.663]                 ...future.workdir <- getwd()
[10:33:59.663]             }
[10:33:59.663]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:59.663]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:59.663]         }
[10:33:59.663]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:59.663]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:59.663]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:59.663]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:59.663]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:59.663]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:59.663]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:59.663]             base::names(...future.oldOptions))
[10:33:59.663]     }
[10:33:59.663]     if (FALSE) {
[10:33:59.663]     }
[10:33:59.663]     else {
[10:33:59.663]         if (TRUE) {
[10:33:59.663]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:59.663]                 open = "w")
[10:33:59.663]         }
[10:33:59.663]         else {
[10:33:59.663]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:59.663]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:59.663]         }
[10:33:59.663]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:59.663]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:59.663]             base::sink(type = "output", split = FALSE)
[10:33:59.663]             base::close(...future.stdout)
[10:33:59.663]         }, add = TRUE)
[10:33:59.663]     }
[10:33:59.663]     ...future.frame <- base::sys.nframe()
[10:33:59.663]     ...future.conditions <- base::list()
[10:33:59.663]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:59.663]     if (FALSE) {
[10:33:59.663]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:59.663]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:59.663]     }
[10:33:59.663]     ...future.result <- base::tryCatch({
[10:33:59.663]         base::withCallingHandlers({
[10:33:59.663]             ...future.value <- base::withVisible(base::local({
[10:33:59.663]                 withCallingHandlers({
[10:33:59.663]                   2
[10:33:59.663]                 }, immediateCondition = function(cond) {
[10:33:59.663]                   save_rds <- function (object, pathname, ...) 
[10:33:59.663]                   {
[10:33:59.663]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:59.663]                     if (file_test("-f", pathname_tmp)) {
[10:33:59.663]                       fi_tmp <- file.info(pathname_tmp)
[10:33:59.663]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:59.663]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:59.663]                         fi_tmp[["mtime"]])
[10:33:59.663]                     }
[10:33:59.663]                     tryCatch({
[10:33:59.663]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:59.663]                     }, error = function(ex) {
[10:33:59.663]                       msg <- conditionMessage(ex)
[10:33:59.663]                       fi_tmp <- file.info(pathname_tmp)
[10:33:59.663]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:59.663]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:59.663]                         fi_tmp[["mtime"]], msg)
[10:33:59.663]                       ex$message <- msg
[10:33:59.663]                       stop(ex)
[10:33:59.663]                     })
[10:33:59.663]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:59.663]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:59.663]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:59.663]                       fi_tmp <- file.info(pathname_tmp)
[10:33:59.663]                       fi <- file.info(pathname)
[10:33:59.663]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:59.663]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:59.663]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:59.663]                         fi[["size"]], fi[["mtime"]])
[10:33:59.663]                       stop(msg)
[10:33:59.663]                     }
[10:33:59.663]                     invisible(pathname)
[10:33:59.663]                   }
[10:33:59.663]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:59.663]                     rootPath = tempdir()) 
[10:33:59.663]                   {
[10:33:59.663]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:59.663]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:59.663]                       tmpdir = path, fileext = ".rds")
[10:33:59.663]                     save_rds(obj, file)
[10:33:59.663]                   }
[10:33:59.663]                   saveImmediateCondition(cond, path = "/tmp/RtmpuZEzLw/.future/immediateConditions")
[10:33:59.663]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:59.663]                   {
[10:33:59.663]                     inherits <- base::inherits
[10:33:59.663]                     invokeRestart <- base::invokeRestart
[10:33:59.663]                     is.null <- base::is.null
[10:33:59.663]                     muffled <- FALSE
[10:33:59.663]                     if (inherits(cond, "message")) {
[10:33:59.663]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:59.663]                       if (muffled) 
[10:33:59.663]                         invokeRestart("muffleMessage")
[10:33:59.663]                     }
[10:33:59.663]                     else if (inherits(cond, "warning")) {
[10:33:59.663]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:59.663]                       if (muffled) 
[10:33:59.663]                         invokeRestart("muffleWarning")
[10:33:59.663]                     }
[10:33:59.663]                     else if (inherits(cond, "condition")) {
[10:33:59.663]                       if (!is.null(pattern)) {
[10:33:59.663]                         computeRestarts <- base::computeRestarts
[10:33:59.663]                         grepl <- base::grepl
[10:33:59.663]                         restarts <- computeRestarts(cond)
[10:33:59.663]                         for (restart in restarts) {
[10:33:59.663]                           name <- restart$name
[10:33:59.663]                           if (is.null(name)) 
[10:33:59.663]                             next
[10:33:59.663]                           if (!grepl(pattern, name)) 
[10:33:59.663]                             next
[10:33:59.663]                           invokeRestart(restart)
[10:33:59.663]                           muffled <- TRUE
[10:33:59.663]                           break
[10:33:59.663]                         }
[10:33:59.663]                       }
[10:33:59.663]                     }
[10:33:59.663]                     invisible(muffled)
[10:33:59.663]                   }
[10:33:59.663]                   muffleCondition(cond)
[10:33:59.663]                 })
[10:33:59.663]             }))
[10:33:59.663]             future::FutureResult(value = ...future.value$value, 
[10:33:59.663]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:59.663]                   ...future.rng), globalenv = if (FALSE) 
[10:33:59.663]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:59.663]                     ...future.globalenv.names))
[10:33:59.663]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:59.663]         }, condition = base::local({
[10:33:59.663]             c <- base::c
[10:33:59.663]             inherits <- base::inherits
[10:33:59.663]             invokeRestart <- base::invokeRestart
[10:33:59.663]             length <- base::length
[10:33:59.663]             list <- base::list
[10:33:59.663]             seq.int <- base::seq.int
[10:33:59.663]             signalCondition <- base::signalCondition
[10:33:59.663]             sys.calls <- base::sys.calls
[10:33:59.663]             `[[` <- base::`[[`
[10:33:59.663]             `+` <- base::`+`
[10:33:59.663]             `<<-` <- base::`<<-`
[10:33:59.663]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:59.663]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:59.663]                   3L)]
[10:33:59.663]             }
[10:33:59.663]             function(cond) {
[10:33:59.663]                 is_error <- inherits(cond, "error")
[10:33:59.663]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:59.663]                   NULL)
[10:33:59.663]                 if (is_error) {
[10:33:59.663]                   sessionInformation <- function() {
[10:33:59.663]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:59.663]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:59.663]                       search = base::search(), system = base::Sys.info())
[10:33:59.663]                   }
[10:33:59.663]                   ...future.conditions[[length(...future.conditions) + 
[10:33:59.663]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:59.663]                     cond$call), session = sessionInformation(), 
[10:33:59.663]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:59.663]                   signalCondition(cond)
[10:33:59.663]                 }
[10:33:59.663]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:59.663]                 "immediateCondition"))) {
[10:33:59.663]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:59.663]                   ...future.conditions[[length(...future.conditions) + 
[10:33:59.663]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:59.663]                   if (TRUE && !signal) {
[10:33:59.663]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:59.663]                     {
[10:33:59.663]                       inherits <- base::inherits
[10:33:59.663]                       invokeRestart <- base::invokeRestart
[10:33:59.663]                       is.null <- base::is.null
[10:33:59.663]                       muffled <- FALSE
[10:33:59.663]                       if (inherits(cond, "message")) {
[10:33:59.663]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:59.663]                         if (muffled) 
[10:33:59.663]                           invokeRestart("muffleMessage")
[10:33:59.663]                       }
[10:33:59.663]                       else if (inherits(cond, "warning")) {
[10:33:59.663]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:59.663]                         if (muffled) 
[10:33:59.663]                           invokeRestart("muffleWarning")
[10:33:59.663]                       }
[10:33:59.663]                       else if (inherits(cond, "condition")) {
[10:33:59.663]                         if (!is.null(pattern)) {
[10:33:59.663]                           computeRestarts <- base::computeRestarts
[10:33:59.663]                           grepl <- base::grepl
[10:33:59.663]                           restarts <- computeRestarts(cond)
[10:33:59.663]                           for (restart in restarts) {
[10:33:59.663]                             name <- restart$name
[10:33:59.663]                             if (is.null(name)) 
[10:33:59.663]                               next
[10:33:59.663]                             if (!grepl(pattern, name)) 
[10:33:59.663]                               next
[10:33:59.663]                             invokeRestart(restart)
[10:33:59.663]                             muffled <- TRUE
[10:33:59.663]                             break
[10:33:59.663]                           }
[10:33:59.663]                         }
[10:33:59.663]                       }
[10:33:59.663]                       invisible(muffled)
[10:33:59.663]                     }
[10:33:59.663]                     muffleCondition(cond, pattern = "^muffle")
[10:33:59.663]                   }
[10:33:59.663]                 }
[10:33:59.663]                 else {
[10:33:59.663]                   if (TRUE) {
[10:33:59.663]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:59.663]                     {
[10:33:59.663]                       inherits <- base::inherits
[10:33:59.663]                       invokeRestart <- base::invokeRestart
[10:33:59.663]                       is.null <- base::is.null
[10:33:59.663]                       muffled <- FALSE
[10:33:59.663]                       if (inherits(cond, "message")) {
[10:33:59.663]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:59.663]                         if (muffled) 
[10:33:59.663]                           invokeRestart("muffleMessage")
[10:33:59.663]                       }
[10:33:59.663]                       else if (inherits(cond, "warning")) {
[10:33:59.663]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:59.663]                         if (muffled) 
[10:33:59.663]                           invokeRestart("muffleWarning")
[10:33:59.663]                       }
[10:33:59.663]                       else if (inherits(cond, "condition")) {
[10:33:59.663]                         if (!is.null(pattern)) {
[10:33:59.663]                           computeRestarts <- base::computeRestarts
[10:33:59.663]                           grepl <- base::grepl
[10:33:59.663]                           restarts <- computeRestarts(cond)
[10:33:59.663]                           for (restart in restarts) {
[10:33:59.663]                             name <- restart$name
[10:33:59.663]                             if (is.null(name)) 
[10:33:59.663]                               next
[10:33:59.663]                             if (!grepl(pattern, name)) 
[10:33:59.663]                               next
[10:33:59.663]                             invokeRestart(restart)
[10:33:59.663]                             muffled <- TRUE
[10:33:59.663]                             break
[10:33:59.663]                           }
[10:33:59.663]                         }
[10:33:59.663]                       }
[10:33:59.663]                       invisible(muffled)
[10:33:59.663]                     }
[10:33:59.663]                     muffleCondition(cond, pattern = "^muffle")
[10:33:59.663]                   }
[10:33:59.663]                 }
[10:33:59.663]             }
[10:33:59.663]         }))
[10:33:59.663]     }, error = function(ex) {
[10:33:59.663]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:59.663]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:59.663]                 ...future.rng), started = ...future.startTime, 
[10:33:59.663]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:59.663]             version = "1.8"), class = "FutureResult")
[10:33:59.663]     }, finally = {
[10:33:59.663]         if (!identical(...future.workdir, getwd())) 
[10:33:59.663]             setwd(...future.workdir)
[10:33:59.663]         {
[10:33:59.663]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:59.663]                 ...future.oldOptions$nwarnings <- NULL
[10:33:59.663]             }
[10:33:59.663]             base::options(...future.oldOptions)
[10:33:59.663]             if (.Platform$OS.type == "windows") {
[10:33:59.663]                 old_names <- names(...future.oldEnvVars)
[10:33:59.663]                 envs <- base::Sys.getenv()
[10:33:59.663]                 names <- names(envs)
[10:33:59.663]                 common <- intersect(names, old_names)
[10:33:59.663]                 added <- setdiff(names, old_names)
[10:33:59.663]                 removed <- setdiff(old_names, names)
[10:33:59.663]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:59.663]                   envs[common]]
[10:33:59.663]                 NAMES <- toupper(changed)
[10:33:59.663]                 args <- list()
[10:33:59.663]                 for (kk in seq_along(NAMES)) {
[10:33:59.663]                   name <- changed[[kk]]
[10:33:59.663]                   NAME <- NAMES[[kk]]
[10:33:59.663]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:59.663]                     next
[10:33:59.663]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:59.663]                 }
[10:33:59.663]                 NAMES <- toupper(added)
[10:33:59.663]                 for (kk in seq_along(NAMES)) {
[10:33:59.663]                   name <- added[[kk]]
[10:33:59.663]                   NAME <- NAMES[[kk]]
[10:33:59.663]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:59.663]                     next
[10:33:59.663]                   args[[name]] <- ""
[10:33:59.663]                 }
[10:33:59.663]                 NAMES <- toupper(removed)
[10:33:59.663]                 for (kk in seq_along(NAMES)) {
[10:33:59.663]                   name <- removed[[kk]]
[10:33:59.663]                   NAME <- NAMES[[kk]]
[10:33:59.663]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:59.663]                     next
[10:33:59.663]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:59.663]                 }
[10:33:59.663]                 if (length(args) > 0) 
[10:33:59.663]                   base::do.call(base::Sys.setenv, args = args)
[10:33:59.663]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:59.663]             }
[10:33:59.663]             else {
[10:33:59.663]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:59.663]             }
[10:33:59.663]             {
[10:33:59.663]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:59.663]                   0L) {
[10:33:59.663]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:59.663]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:59.663]                   base::options(opts)
[10:33:59.663]                 }
[10:33:59.663]                 {
[10:33:59.663]                   {
[10:33:59.663]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:59.663]                     NULL
[10:33:59.663]                   }
[10:33:59.663]                   options(future.plan = NULL)
[10:33:59.663]                   if (is.na(NA_character_)) 
[10:33:59.663]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:59.663]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:59.663]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:59.663]                     .init = FALSE)
[10:33:59.663]                 }
[10:33:59.663]             }
[10:33:59.663]         }
[10:33:59.663]     })
[10:33:59.663]     if (TRUE) {
[10:33:59.663]         base::sink(type = "output", split = FALSE)
[10:33:59.663]         if (TRUE) {
[10:33:59.663]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:59.663]         }
[10:33:59.663]         else {
[10:33:59.663]             ...future.result["stdout"] <- base::list(NULL)
[10:33:59.663]         }
[10:33:59.663]         base::close(...future.stdout)
[10:33:59.663]         ...future.stdout <- NULL
[10:33:59.663]     }
[10:33:59.663]     ...future.result$conditions <- ...future.conditions
[10:33:59.663]     ...future.result$finished <- base::Sys.time()
[10:33:59.663]     ...future.result
[10:33:59.663] }
[10:33:59.667] requestCore(): workers = 2
[10:33:59.667] Poll #1 (0): usedCores() = 2, workers = 2
[10:33:59.678] result() for MulticoreFuture ...
[10:33:59.679] result() for MulticoreFuture ...
[10:33:59.679] result() for MulticoreFuture ... done
[10:33:59.679] result() for MulticoreFuture ... done
[10:33:59.679] result() for MulticoreFuture ...
[10:33:59.680] result() for MulticoreFuture ... done
[10:33:59.682] MulticoreFuture started
[10:33:59.683] - Launch lazy future ... done
[10:33:59.683] run() for ‘MulticoreFuture’ ... done
[10:33:59.684] plan(): Setting new future strategy stack:
[10:33:59.684] List of future strategies:
[10:33:59.684] 1. sequential:
[10:33:59.684]    - args: function (..., envir = parent.frame())
[10:33:59.684]    - tweaked: FALSE
[10:33:59.684]    - call: NULL
[10:33:59.685] plan(): nbrOfWorkers() = 1
[10:33:59.687] plan(): Setting new future strategy stack:
[10:33:59.688] List of future strategies:
[10:33:59.688] 1. multicore:
[10:33:59.688]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:59.688]    - tweaked: FALSE
[10:33:59.688]    - call: plan(strategy)
[10:33:59.694]  length: 1 (resolved future 3)
[10:33:59.694] plan(): nbrOfWorkers() = 2
[10:33:59.704] Future #2
[10:33:59.705]  length: 0 (resolved future 2)
[10:33:59.705] resolve() on list ... DONE
[10:33:59.706] getGlobalsAndPackages() ...
[10:33:59.706] Searching for globals...
[10:33:59.707] 
[10:33:59.707] Searching for globals ... DONE
[10:33:59.707] - globals: [0] <none>
[10:33:59.707] getGlobalsAndPackages() ... DONE
[10:33:59.708] run() for ‘Future’ ...
[10:33:59.708] - state: ‘created’
[10:33:59.708] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:59.713] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:59.714] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:59.714]   - Field: ‘label’
[10:33:59.714]   - Field: ‘local’
[10:33:59.714]   - Field: ‘owner’
[10:33:59.714]   - Field: ‘envir’
[10:33:59.714]   - Field: ‘workers’
[10:33:59.715]   - Field: ‘packages’
[10:33:59.715]   - Field: ‘gc’
[10:33:59.715]   - Field: ‘job’
[10:33:59.715]   - Field: ‘conditions’
[10:33:59.715]   - Field: ‘expr’
[10:33:59.715]   - Field: ‘uuid’
[10:33:59.715]   - Field: ‘seed’
[10:33:59.716]   - Field: ‘version’
[10:33:59.716]   - Field: ‘result’
[10:33:59.716]   - Field: ‘asynchronous’
[10:33:59.716]   - Field: ‘calls’
[10:33:59.716]   - Field: ‘globals’
[10:33:59.716]   - Field: ‘stdout’
[10:33:59.716]   - Field: ‘earlySignal’
[10:33:59.717]   - Field: ‘lazy’
[10:33:59.717]   - Field: ‘state’
[10:33:59.717] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:59.717] - Launch lazy future ...
[10:33:59.722] Packages needed by the future expression (n = 0): <none>
[10:33:59.722] Packages needed by future strategies (n = 0): <none>
[10:33:59.723] {
[10:33:59.723]     {
[10:33:59.723]         {
[10:33:59.723]             ...future.startTime <- base::Sys.time()
[10:33:59.723]             {
[10:33:59.723]                 {
[10:33:59.723]                   {
[10:33:59.723]                     {
[10:33:59.723]                       base::local({
[10:33:59.723]                         has_future <- base::requireNamespace("future", 
[10:33:59.723]                           quietly = TRUE)
[10:33:59.723]                         if (has_future) {
[10:33:59.723]                           ns <- base::getNamespace("future")
[10:33:59.723]                           version <- ns[[".package"]][["version"]]
[10:33:59.723]                           if (is.null(version)) 
[10:33:59.723]                             version <- utils::packageVersion("future")
[10:33:59.723]                         }
[10:33:59.723]                         else {
[10:33:59.723]                           version <- NULL
[10:33:59.723]                         }
[10:33:59.723]                         if (!has_future || version < "1.8.0") {
[10:33:59.723]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:59.723]                             "", base::R.version$version.string), 
[10:33:59.723]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:59.723]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:59.723]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:59.723]                               "release", "version")], collapse = " "), 
[10:33:59.723]                             hostname = base::Sys.info()[["nodename"]])
[10:33:59.723]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:59.723]                             info)
[10:33:59.723]                           info <- base::paste(info, collapse = "; ")
[10:33:59.723]                           if (!has_future) {
[10:33:59.723]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:59.723]                               info)
[10:33:59.723]                           }
[10:33:59.723]                           else {
[10:33:59.723]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:59.723]                               info, version)
[10:33:59.723]                           }
[10:33:59.723]                           base::stop(msg)
[10:33:59.723]                         }
[10:33:59.723]                       })
[10:33:59.723]                     }
[10:33:59.723]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:59.723]                     base::options(mc.cores = 1L)
[10:33:59.723]                   }
[10:33:59.723]                   ...future.strategy.old <- future::plan("list")
[10:33:59.723]                   options(future.plan = NULL)
[10:33:59.723]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:59.723]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:59.723]                 }
[10:33:59.723]                 ...future.workdir <- getwd()
[10:33:59.723]             }
[10:33:59.723]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:59.723]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:59.723]         }
[10:33:59.723]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:59.723]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:59.723]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:59.723]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:59.723]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:59.723]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:59.723]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:59.723]             base::names(...future.oldOptions))
[10:33:59.723]     }
[10:33:59.723]     if (FALSE) {
[10:33:59.723]     }
[10:33:59.723]     else {
[10:33:59.723]         if (TRUE) {
[10:33:59.723]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:59.723]                 open = "w")
[10:33:59.723]         }
[10:33:59.723]         else {
[10:33:59.723]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:59.723]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:59.723]         }
[10:33:59.723]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:59.723]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:59.723]             base::sink(type = "output", split = FALSE)
[10:33:59.723]             base::close(...future.stdout)
[10:33:59.723]         }, add = TRUE)
[10:33:59.723]     }
[10:33:59.723]     ...future.frame <- base::sys.nframe()
[10:33:59.723]     ...future.conditions <- base::list()
[10:33:59.723]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:59.723]     if (FALSE) {
[10:33:59.723]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:59.723]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:59.723]     }
[10:33:59.723]     ...future.result <- base::tryCatch({
[10:33:59.723]         base::withCallingHandlers({
[10:33:59.723]             ...future.value <- base::withVisible(base::local({
[10:33:59.723]                 withCallingHandlers({
[10:33:59.723]                   1
[10:33:59.723]                 }, immediateCondition = function(cond) {
[10:33:59.723]                   save_rds <- function (object, pathname, ...) 
[10:33:59.723]                   {
[10:33:59.723]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:59.723]                     if (file_test("-f", pathname_tmp)) {
[10:33:59.723]                       fi_tmp <- file.info(pathname_tmp)
[10:33:59.723]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:59.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:59.723]                         fi_tmp[["mtime"]])
[10:33:59.723]                     }
[10:33:59.723]                     tryCatch({
[10:33:59.723]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:59.723]                     }, error = function(ex) {
[10:33:59.723]                       msg <- conditionMessage(ex)
[10:33:59.723]                       fi_tmp <- file.info(pathname_tmp)
[10:33:59.723]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:59.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:59.723]                         fi_tmp[["mtime"]], msg)
[10:33:59.723]                       ex$message <- msg
[10:33:59.723]                       stop(ex)
[10:33:59.723]                     })
[10:33:59.723]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:59.723]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:59.723]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:59.723]                       fi_tmp <- file.info(pathname_tmp)
[10:33:59.723]                       fi <- file.info(pathname)
[10:33:59.723]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:59.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:59.723]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:59.723]                         fi[["size"]], fi[["mtime"]])
[10:33:59.723]                       stop(msg)
[10:33:59.723]                     }
[10:33:59.723]                     invisible(pathname)
[10:33:59.723]                   }
[10:33:59.723]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:59.723]                     rootPath = tempdir()) 
[10:33:59.723]                   {
[10:33:59.723]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:59.723]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:59.723]                       tmpdir = path, fileext = ".rds")
[10:33:59.723]                     save_rds(obj, file)
[10:33:59.723]                   }
[10:33:59.723]                   saveImmediateCondition(cond, path = "/tmp/RtmpuZEzLw/.future/immediateConditions")
[10:33:59.723]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:59.723]                   {
[10:33:59.723]                     inherits <- base::inherits
[10:33:59.723]                     invokeRestart <- base::invokeRestart
[10:33:59.723]                     is.null <- base::is.null
[10:33:59.723]                     muffled <- FALSE
[10:33:59.723]                     if (inherits(cond, "message")) {
[10:33:59.723]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:59.723]                       if (muffled) 
[10:33:59.723]                         invokeRestart("muffleMessage")
[10:33:59.723]                     }
[10:33:59.723]                     else if (inherits(cond, "warning")) {
[10:33:59.723]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:59.723]                       if (muffled) 
[10:33:59.723]                         invokeRestart("muffleWarning")
[10:33:59.723]                     }
[10:33:59.723]                     else if (inherits(cond, "condition")) {
[10:33:59.723]                       if (!is.null(pattern)) {
[10:33:59.723]                         computeRestarts <- base::computeRestarts
[10:33:59.723]                         grepl <- base::grepl
[10:33:59.723]                         restarts <- computeRestarts(cond)
[10:33:59.723]                         for (restart in restarts) {
[10:33:59.723]                           name <- restart$name
[10:33:59.723]                           if (is.null(name)) 
[10:33:59.723]                             next
[10:33:59.723]                           if (!grepl(pattern, name)) 
[10:33:59.723]                             next
[10:33:59.723]                           invokeRestart(restart)
[10:33:59.723]                           muffled <- TRUE
[10:33:59.723]                           break
[10:33:59.723]                         }
[10:33:59.723]                       }
[10:33:59.723]                     }
[10:33:59.723]                     invisible(muffled)
[10:33:59.723]                   }
[10:33:59.723]                   muffleCondition(cond)
[10:33:59.723]                 })
[10:33:59.723]             }))
[10:33:59.723]             future::FutureResult(value = ...future.value$value, 
[10:33:59.723]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:59.723]                   ...future.rng), globalenv = if (FALSE) 
[10:33:59.723]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:59.723]                     ...future.globalenv.names))
[10:33:59.723]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:59.723]         }, condition = base::local({
[10:33:59.723]             c <- base::c
[10:33:59.723]             inherits <- base::inherits
[10:33:59.723]             invokeRestart <- base::invokeRestart
[10:33:59.723]             length <- base::length
[10:33:59.723]             list <- base::list
[10:33:59.723]             seq.int <- base::seq.int
[10:33:59.723]             signalCondition <- base::signalCondition
[10:33:59.723]             sys.calls <- base::sys.calls
[10:33:59.723]             `[[` <- base::`[[`
[10:33:59.723]             `+` <- base::`+`
[10:33:59.723]             `<<-` <- base::`<<-`
[10:33:59.723]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:59.723]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:59.723]                   3L)]
[10:33:59.723]             }
[10:33:59.723]             function(cond) {
[10:33:59.723]                 is_error <- inherits(cond, "error")
[10:33:59.723]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:59.723]                   NULL)
[10:33:59.723]                 if (is_error) {
[10:33:59.723]                   sessionInformation <- function() {
[10:33:59.723]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:59.723]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:59.723]                       search = base::search(), system = base::Sys.info())
[10:33:59.723]                   }
[10:33:59.723]                   ...future.conditions[[length(...future.conditions) + 
[10:33:59.723]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:59.723]                     cond$call), session = sessionInformation(), 
[10:33:59.723]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:59.723]                   signalCondition(cond)
[10:33:59.723]                 }
[10:33:59.723]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:59.723]                 "immediateCondition"))) {
[10:33:59.723]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:59.723]                   ...future.conditions[[length(...future.conditions) + 
[10:33:59.723]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:59.723]                   if (TRUE && !signal) {
[10:33:59.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:59.723]                     {
[10:33:59.723]                       inherits <- base::inherits
[10:33:59.723]                       invokeRestart <- base::invokeRestart
[10:33:59.723]                       is.null <- base::is.null
[10:33:59.723]                       muffled <- FALSE
[10:33:59.723]                       if (inherits(cond, "message")) {
[10:33:59.723]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:59.723]                         if (muffled) 
[10:33:59.723]                           invokeRestart("muffleMessage")
[10:33:59.723]                       }
[10:33:59.723]                       else if (inherits(cond, "warning")) {
[10:33:59.723]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:59.723]                         if (muffled) 
[10:33:59.723]                           invokeRestart("muffleWarning")
[10:33:59.723]                       }
[10:33:59.723]                       else if (inherits(cond, "condition")) {
[10:33:59.723]                         if (!is.null(pattern)) {
[10:33:59.723]                           computeRestarts <- base::computeRestarts
[10:33:59.723]                           grepl <- base::grepl
[10:33:59.723]                           restarts <- computeRestarts(cond)
[10:33:59.723]                           for (restart in restarts) {
[10:33:59.723]                             name <- restart$name
[10:33:59.723]                             if (is.null(name)) 
[10:33:59.723]                               next
[10:33:59.723]                             if (!grepl(pattern, name)) 
[10:33:59.723]                               next
[10:33:59.723]                             invokeRestart(restart)
[10:33:59.723]                             muffled <- TRUE
[10:33:59.723]                             break
[10:33:59.723]                           }
[10:33:59.723]                         }
[10:33:59.723]                       }
[10:33:59.723]                       invisible(muffled)
[10:33:59.723]                     }
[10:33:59.723]                     muffleCondition(cond, pattern = "^muffle")
[10:33:59.723]                   }
[10:33:59.723]                 }
[10:33:59.723]                 else {
[10:33:59.723]                   if (TRUE) {
[10:33:59.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:59.723]                     {
[10:33:59.723]                       inherits <- base::inherits
[10:33:59.723]                       invokeRestart <- base::invokeRestart
[10:33:59.723]                       is.null <- base::is.null
[10:33:59.723]                       muffled <- FALSE
[10:33:59.723]                       if (inherits(cond, "message")) {
[10:33:59.723]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:59.723]                         if (muffled) 
[10:33:59.723]                           invokeRestart("muffleMessage")
[10:33:59.723]                       }
[10:33:59.723]                       else if (inherits(cond, "warning")) {
[10:33:59.723]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:59.723]                         if (muffled) 
[10:33:59.723]                           invokeRestart("muffleWarning")
[10:33:59.723]                       }
[10:33:59.723]                       else if (inherits(cond, "condition")) {
[10:33:59.723]                         if (!is.null(pattern)) {
[10:33:59.723]                           computeRestarts <- base::computeRestarts
[10:33:59.723]                           grepl <- base::grepl
[10:33:59.723]                           restarts <- computeRestarts(cond)
[10:33:59.723]                           for (restart in restarts) {
[10:33:59.723]                             name <- restart$name
[10:33:59.723]                             if (is.null(name)) 
[10:33:59.723]                               next
[10:33:59.723]                             if (!grepl(pattern, name)) 
[10:33:59.723]                               next
[10:33:59.723]                             invokeRestart(restart)
[10:33:59.723]                             muffled <- TRUE
[10:33:59.723]                             break
[10:33:59.723]                           }
[10:33:59.723]                         }
[10:33:59.723]                       }
[10:33:59.723]                       invisible(muffled)
[10:33:59.723]                     }
[10:33:59.723]                     muffleCondition(cond, pattern = "^muffle")
[10:33:59.723]                   }
[10:33:59.723]                 }
[10:33:59.723]             }
[10:33:59.723]         }))
[10:33:59.723]     }, error = function(ex) {
[10:33:59.723]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:59.723]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:59.723]                 ...future.rng), started = ...future.startTime, 
[10:33:59.723]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:59.723]             version = "1.8"), class = "FutureResult")
[10:33:59.723]     }, finally = {
[10:33:59.723]         if (!identical(...future.workdir, getwd())) 
[10:33:59.723]             setwd(...future.workdir)
[10:33:59.723]         {
[10:33:59.723]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:59.723]                 ...future.oldOptions$nwarnings <- NULL
[10:33:59.723]             }
[10:33:59.723]             base::options(...future.oldOptions)
[10:33:59.723]             if (.Platform$OS.type == "windows") {
[10:33:59.723]                 old_names <- names(...future.oldEnvVars)
[10:33:59.723]                 envs <- base::Sys.getenv()
[10:33:59.723]                 names <- names(envs)
[10:33:59.723]                 common <- intersect(names, old_names)
[10:33:59.723]                 added <- setdiff(names, old_names)
[10:33:59.723]                 removed <- setdiff(old_names, names)
[10:33:59.723]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:59.723]                   envs[common]]
[10:33:59.723]                 NAMES <- toupper(changed)
[10:33:59.723]                 args <- list()
[10:33:59.723]                 for (kk in seq_along(NAMES)) {
[10:33:59.723]                   name <- changed[[kk]]
[10:33:59.723]                   NAME <- NAMES[[kk]]
[10:33:59.723]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:59.723]                     next
[10:33:59.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:59.723]                 }
[10:33:59.723]                 NAMES <- toupper(added)
[10:33:59.723]                 for (kk in seq_along(NAMES)) {
[10:33:59.723]                   name <- added[[kk]]
[10:33:59.723]                   NAME <- NAMES[[kk]]
[10:33:59.723]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:59.723]                     next
[10:33:59.723]                   args[[name]] <- ""
[10:33:59.723]                 }
[10:33:59.723]                 NAMES <- toupper(removed)
[10:33:59.723]                 for (kk in seq_along(NAMES)) {
[10:33:59.723]                   name <- removed[[kk]]
[10:33:59.723]                   NAME <- NAMES[[kk]]
[10:33:59.723]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:59.723]                     next
[10:33:59.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:59.723]                 }
[10:33:59.723]                 if (length(args) > 0) 
[10:33:59.723]                   base::do.call(base::Sys.setenv, args = args)
[10:33:59.723]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:59.723]             }
[10:33:59.723]             else {
[10:33:59.723]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:59.723]             }
[10:33:59.723]             {
[10:33:59.723]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:59.723]                   0L) {
[10:33:59.723]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:59.723]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:59.723]                   base::options(opts)
[10:33:59.723]                 }
[10:33:59.723]                 {
[10:33:59.723]                   {
[10:33:59.723]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:59.723]                     NULL
[10:33:59.723]                   }
[10:33:59.723]                   options(future.plan = NULL)
[10:33:59.723]                   if (is.na(NA_character_)) 
[10:33:59.723]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:59.723]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:59.723]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:59.723]                     .init = FALSE)
[10:33:59.723]                 }
[10:33:59.723]             }
[10:33:59.723]         }
[10:33:59.723]     })
[10:33:59.723]     if (TRUE) {
[10:33:59.723]         base::sink(type = "output", split = FALSE)
[10:33:59.723]         if (TRUE) {
[10:33:59.723]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:59.723]         }
[10:33:59.723]         else {
[10:33:59.723]             ...future.result["stdout"] <- base::list(NULL)
[10:33:59.723]         }
[10:33:59.723]         base::close(...future.stdout)
[10:33:59.723]         ...future.stdout <- NULL
[10:33:59.723]     }
[10:33:59.723]     ...future.result$conditions <- ...future.conditions
[10:33:59.723]     ...future.result$finished <- base::Sys.time()
[10:33:59.723]     ...future.result
[10:33:59.723] }
[10:33:59.726] requestCore(): workers = 2
[10:33:59.727] Poll #1 (0): usedCores() = 2, workers = 2
[10:33:59.738] result() for MulticoreFuture ...
[10:33:59.739] result() for MulticoreFuture ...
[10:33:59.739] result() for MulticoreFuture ... done
[10:33:59.740] result() for MulticoreFuture ... done
[10:33:59.740] result() for MulticoreFuture ...
[10:33:59.740] result() for MulticoreFuture ... done
[10:33:59.743] MulticoreFuture started
[10:33:59.743] - Launch lazy future ... done
[10:33:59.744] run() for ‘MulticoreFuture’ ... done
[10:33:59.744] plan(): Setting new future strategy stack:
[10:33:59.744] getGlobalsAndPackages() ...
[10:33:59.745] Searching for globals...
[10:33:59.744] List of future strategies:
[10:33:59.744] 1. sequential:
[10:33:59.744]    - args: function (..., envir = parent.frame())
[10:33:59.744]    - tweaked: FALSE
[10:33:59.744]    - call: NULL
[10:33:59.746] plan(): nbrOfWorkers() = 1
[10:33:59.747] - globals found: [2] ‘{’, ‘Sys.sleep’
[10:33:59.748] Searching for globals ... DONE
[10:33:59.748] plan(): Setting new future strategy stack:
[10:33:59.748] Resolving globals: FALSE
[10:33:59.748] List of future strategies:
[10:33:59.748] 1. multicore:
[10:33:59.748]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:33:59.748]    - tweaked: FALSE
[10:33:59.748]    - call: plan(strategy)
[10:33:59.749] 
[10:33:59.749] 
[10:33:59.749] getGlobalsAndPackages() ... DONE
[10:33:59.750] run() for ‘Future’ ...
[10:33:59.750] - state: ‘created’
[10:33:59.750] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:33:59.753] plan(): nbrOfWorkers() = 2
[10:33:59.755] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:33:59.755] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:33:59.756]   - Field: ‘label’
[10:33:59.756]   - Field: ‘local’
[10:33:59.756]   - Field: ‘owner’
[10:33:59.756]   - Field: ‘envir’
[10:33:59.756]   - Field: ‘workers’
[10:33:59.756]   - Field: ‘packages’
[10:33:59.757]   - Field: ‘gc’
[10:33:59.757]   - Field: ‘job’
[10:33:59.757]   - Field: ‘conditions’
[10:33:59.757]   - Field: ‘expr’
[10:33:59.757]   - Field: ‘uuid’
[10:33:59.757]   - Field: ‘seed’
[10:33:59.757]   - Field: ‘version’
[10:33:59.758]   - Field: ‘result’
[10:33:59.758]   - Field: ‘asynchronous’
[10:33:59.758]   - Field: ‘calls’
[10:33:59.758]   - Field: ‘globals’
[10:33:59.758]   - Field: ‘stdout’
[10:33:59.758]   - Field: ‘earlySignal’
[10:33:59.758]   - Field: ‘lazy’
[10:33:59.759]   - Field: ‘state’
[10:33:59.759] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:33:59.759] - Launch lazy future ...
[10:33:59.759] Packages needed by the future expression (n = 0): <none>
[10:33:59.760] Packages needed by future strategies (n = 0): <none>
[10:33:59.760] {
[10:33:59.760]     {
[10:33:59.760]         {
[10:33:59.760]             ...future.startTime <- base::Sys.time()
[10:33:59.760]             {
[10:33:59.760]                 {
[10:33:59.760]                   {
[10:33:59.760]                     {
[10:33:59.760]                       base::local({
[10:33:59.760]                         has_future <- base::requireNamespace("future", 
[10:33:59.760]                           quietly = TRUE)
[10:33:59.760]                         if (has_future) {
[10:33:59.760]                           ns <- base::getNamespace("future")
[10:33:59.760]                           version <- ns[[".package"]][["version"]]
[10:33:59.760]                           if (is.null(version)) 
[10:33:59.760]                             version <- utils::packageVersion("future")
[10:33:59.760]                         }
[10:33:59.760]                         else {
[10:33:59.760]                           version <- NULL
[10:33:59.760]                         }
[10:33:59.760]                         if (!has_future || version < "1.8.0") {
[10:33:59.760]                           info <- base::c(r_version = base::gsub("R version ", 
[10:33:59.760]                             "", base::R.version$version.string), 
[10:33:59.760]                             platform = base::sprintf("%s (%s-bit)", 
[10:33:59.760]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:33:59.760]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:33:59.760]                               "release", "version")], collapse = " "), 
[10:33:59.760]                             hostname = base::Sys.info()[["nodename"]])
[10:33:59.760]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:33:59.760]                             info)
[10:33:59.760]                           info <- base::paste(info, collapse = "; ")
[10:33:59.760]                           if (!has_future) {
[10:33:59.760]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:33:59.760]                               info)
[10:33:59.760]                           }
[10:33:59.760]                           else {
[10:33:59.760]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:33:59.760]                               info, version)
[10:33:59.760]                           }
[10:33:59.760]                           base::stop(msg)
[10:33:59.760]                         }
[10:33:59.760]                       })
[10:33:59.760]                     }
[10:33:59.760]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:33:59.760]                     base::options(mc.cores = 1L)
[10:33:59.760]                   }
[10:33:59.760]                   ...future.strategy.old <- future::plan("list")
[10:33:59.760]                   options(future.plan = NULL)
[10:33:59.760]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:33:59.760]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:33:59.760]                 }
[10:33:59.760]                 ...future.workdir <- getwd()
[10:33:59.760]             }
[10:33:59.760]             ...future.oldOptions <- base::as.list(base::.Options)
[10:33:59.760]             ...future.oldEnvVars <- base::Sys.getenv()
[10:33:59.760]         }
[10:33:59.760]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:33:59.760]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:33:59.760]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:33:59.760]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:33:59.760]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:33:59.760]             future.stdout.windows.reencode = NULL, width = 80L)
[10:33:59.760]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:33:59.760]             base::names(...future.oldOptions))
[10:33:59.760]     }
[10:33:59.760]     if (FALSE) {
[10:33:59.760]     }
[10:33:59.760]     else {
[10:33:59.760]         if (TRUE) {
[10:33:59.760]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:33:59.760]                 open = "w")
[10:33:59.760]         }
[10:33:59.760]         else {
[10:33:59.760]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:33:59.760]                 windows = "NUL", "/dev/null"), open = "w")
[10:33:59.760]         }
[10:33:59.760]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:33:59.760]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:33:59.760]             base::sink(type = "output", split = FALSE)
[10:33:59.760]             base::close(...future.stdout)
[10:33:59.760]         }, add = TRUE)
[10:33:59.760]     }
[10:33:59.760]     ...future.frame <- base::sys.nframe()
[10:33:59.760]     ...future.conditions <- base::list()
[10:33:59.760]     ...future.rng <- base::globalenv()$.Random.seed
[10:33:59.760]     if (FALSE) {
[10:33:59.760]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:33:59.760]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:33:59.760]     }
[10:33:59.760]     ...future.result <- base::tryCatch({
[10:33:59.760]         base::withCallingHandlers({
[10:33:59.760]             ...future.value <- base::withVisible(base::local({
[10:33:59.760]                 withCallingHandlers({
[10:33:59.760]                   {
[10:33:59.760]                     Sys.sleep(0.5)
[10:33:59.760]                     2
[10:33:59.760]                   }
[10:33:59.760]                 }, immediateCondition = function(cond) {
[10:33:59.760]                   save_rds <- function (object, pathname, ...) 
[10:33:59.760]                   {
[10:33:59.760]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:33:59.760]                     if (file_test("-f", pathname_tmp)) {
[10:33:59.760]                       fi_tmp <- file.info(pathname_tmp)
[10:33:59.760]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:33:59.760]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:59.760]                         fi_tmp[["mtime"]])
[10:33:59.760]                     }
[10:33:59.760]                     tryCatch({
[10:33:59.760]                       saveRDS(object, file = pathname_tmp, ...)
[10:33:59.760]                     }, error = function(ex) {
[10:33:59.760]                       msg <- conditionMessage(ex)
[10:33:59.760]                       fi_tmp <- file.info(pathname_tmp)
[10:33:59.760]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:33:59.760]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:59.760]                         fi_tmp[["mtime"]], msg)
[10:33:59.760]                       ex$message <- msg
[10:33:59.760]                       stop(ex)
[10:33:59.760]                     })
[10:33:59.760]                     stopifnot(file_test("-f", pathname_tmp))
[10:33:59.760]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:33:59.760]                     if (!res || file_test("-f", pathname_tmp)) {
[10:33:59.760]                       fi_tmp <- file.info(pathname_tmp)
[10:33:59.760]                       fi <- file.info(pathname)
[10:33:59.760]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:33:59.760]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:33:59.760]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:33:59.760]                         fi[["size"]], fi[["mtime"]])
[10:33:59.760]                       stop(msg)
[10:33:59.760]                     }
[10:33:59.760]                     invisible(pathname)
[10:33:59.760]                   }
[10:33:59.760]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:33:59.760]                     rootPath = tempdir()) 
[10:33:59.760]                   {
[10:33:59.760]                     obj <- list(time = Sys.time(), condition = cond)
[10:33:59.760]                     file <- tempfile(pattern = class(cond)[1], 
[10:33:59.760]                       tmpdir = path, fileext = ".rds")
[10:33:59.760]                     save_rds(obj, file)
[10:33:59.760]                   }
[10:33:59.760]                   saveImmediateCondition(cond, path = "/tmp/RtmpuZEzLw/.future/immediateConditions")
[10:33:59.760]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:59.760]                   {
[10:33:59.760]                     inherits <- base::inherits
[10:33:59.760]                     invokeRestart <- base::invokeRestart
[10:33:59.760]                     is.null <- base::is.null
[10:33:59.760]                     muffled <- FALSE
[10:33:59.760]                     if (inherits(cond, "message")) {
[10:33:59.760]                       muffled <- grepl(pattern, "muffleMessage")
[10:33:59.760]                       if (muffled) 
[10:33:59.760]                         invokeRestart("muffleMessage")
[10:33:59.760]                     }
[10:33:59.760]                     else if (inherits(cond, "warning")) {
[10:33:59.760]                       muffled <- grepl(pattern, "muffleWarning")
[10:33:59.760]                       if (muffled) 
[10:33:59.760]                         invokeRestart("muffleWarning")
[10:33:59.760]                     }
[10:33:59.760]                     else if (inherits(cond, "condition")) {
[10:33:59.760]                       if (!is.null(pattern)) {
[10:33:59.760]                         computeRestarts <- base::computeRestarts
[10:33:59.760]                         grepl <- base::grepl
[10:33:59.760]                         restarts <- computeRestarts(cond)
[10:33:59.760]                         for (restart in restarts) {
[10:33:59.760]                           name <- restart$name
[10:33:59.760]                           if (is.null(name)) 
[10:33:59.760]                             next
[10:33:59.760]                           if (!grepl(pattern, name)) 
[10:33:59.760]                             next
[10:33:59.760]                           invokeRestart(restart)
[10:33:59.760]                           muffled <- TRUE
[10:33:59.760]                           break
[10:33:59.760]                         }
[10:33:59.760]                       }
[10:33:59.760]                     }
[10:33:59.760]                     invisible(muffled)
[10:33:59.760]                   }
[10:33:59.760]                   muffleCondition(cond)
[10:33:59.760]                 })
[10:33:59.760]             }))
[10:33:59.760]             future::FutureResult(value = ...future.value$value, 
[10:33:59.760]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:59.760]                   ...future.rng), globalenv = if (FALSE) 
[10:33:59.760]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:33:59.760]                     ...future.globalenv.names))
[10:33:59.760]                 else NULL, started = ...future.startTime, version = "1.8")
[10:33:59.760]         }, condition = base::local({
[10:33:59.760]             c <- base::c
[10:33:59.760]             inherits <- base::inherits
[10:33:59.760]             invokeRestart <- base::invokeRestart
[10:33:59.760]             length <- base::length
[10:33:59.760]             list <- base::list
[10:33:59.760]             seq.int <- base::seq.int
[10:33:59.760]             signalCondition <- base::signalCondition
[10:33:59.760]             sys.calls <- base::sys.calls
[10:33:59.760]             `[[` <- base::`[[`
[10:33:59.760]             `+` <- base::`+`
[10:33:59.760]             `<<-` <- base::`<<-`
[10:33:59.760]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:33:59.760]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:33:59.760]                   3L)]
[10:33:59.760]             }
[10:33:59.760]             function(cond) {
[10:33:59.760]                 is_error <- inherits(cond, "error")
[10:33:59.760]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:33:59.760]                   NULL)
[10:33:59.760]                 if (is_error) {
[10:33:59.760]                   sessionInformation <- function() {
[10:33:59.760]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:33:59.760]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:33:59.760]                       search = base::search(), system = base::Sys.info())
[10:33:59.760]                   }
[10:33:59.760]                   ...future.conditions[[length(...future.conditions) + 
[10:33:59.760]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:33:59.760]                     cond$call), session = sessionInformation(), 
[10:33:59.760]                     timestamp = base::Sys.time(), signaled = 0L)
[10:33:59.760]                   signalCondition(cond)
[10:33:59.760]                 }
[10:33:59.760]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:33:59.760]                 "immediateCondition"))) {
[10:33:59.760]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:33:59.760]                   ...future.conditions[[length(...future.conditions) + 
[10:33:59.760]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:33:59.760]                   if (TRUE && !signal) {
[10:33:59.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:59.760]                     {
[10:33:59.760]                       inherits <- base::inherits
[10:33:59.760]                       invokeRestart <- base::invokeRestart
[10:33:59.760]                       is.null <- base::is.null
[10:33:59.760]                       muffled <- FALSE
[10:33:59.760]                       if (inherits(cond, "message")) {
[10:33:59.760]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:59.760]                         if (muffled) 
[10:33:59.760]                           invokeRestart("muffleMessage")
[10:33:59.760]                       }
[10:33:59.760]                       else if (inherits(cond, "warning")) {
[10:33:59.760]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:59.760]                         if (muffled) 
[10:33:59.760]                           invokeRestart("muffleWarning")
[10:33:59.760]                       }
[10:33:59.760]                       else if (inherits(cond, "condition")) {
[10:33:59.760]                         if (!is.null(pattern)) {
[10:33:59.760]                           computeRestarts <- base::computeRestarts
[10:33:59.760]                           grepl <- base::grepl
[10:33:59.760]                           restarts <- computeRestarts(cond)
[10:33:59.760]                           for (restart in restarts) {
[10:33:59.760]                             name <- restart$name
[10:33:59.760]                             if (is.null(name)) 
[10:33:59.760]                               next
[10:33:59.760]                             if (!grepl(pattern, name)) 
[10:33:59.760]                               next
[10:33:59.760]                             invokeRestart(restart)
[10:33:59.760]                             muffled <- TRUE
[10:33:59.760]                             break
[10:33:59.760]                           }
[10:33:59.760]                         }
[10:33:59.760]                       }
[10:33:59.760]                       invisible(muffled)
[10:33:59.760]                     }
[10:33:59.760]                     muffleCondition(cond, pattern = "^muffle")
[10:33:59.760]                   }
[10:33:59.760]                 }
[10:33:59.760]                 else {
[10:33:59.760]                   if (TRUE) {
[10:33:59.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:33:59.760]                     {
[10:33:59.760]                       inherits <- base::inherits
[10:33:59.760]                       invokeRestart <- base::invokeRestart
[10:33:59.760]                       is.null <- base::is.null
[10:33:59.760]                       muffled <- FALSE
[10:33:59.760]                       if (inherits(cond, "message")) {
[10:33:59.760]                         muffled <- grepl(pattern, "muffleMessage")
[10:33:59.760]                         if (muffled) 
[10:33:59.760]                           invokeRestart("muffleMessage")
[10:33:59.760]                       }
[10:33:59.760]                       else if (inherits(cond, "warning")) {
[10:33:59.760]                         muffled <- grepl(pattern, "muffleWarning")
[10:33:59.760]                         if (muffled) 
[10:33:59.760]                           invokeRestart("muffleWarning")
[10:33:59.760]                       }
[10:33:59.760]                       else if (inherits(cond, "condition")) {
[10:33:59.760]                         if (!is.null(pattern)) {
[10:33:59.760]                           computeRestarts <- base::computeRestarts
[10:33:59.760]                           grepl <- base::grepl
[10:33:59.760]                           restarts <- computeRestarts(cond)
[10:33:59.760]                           for (restart in restarts) {
[10:33:59.760]                             name <- restart$name
[10:33:59.760]                             if (is.null(name)) 
[10:33:59.760]                               next
[10:33:59.760]                             if (!grepl(pattern, name)) 
[10:33:59.760]                               next
[10:33:59.760]                             invokeRestart(restart)
[10:33:59.760]                             muffled <- TRUE
[10:33:59.760]                             break
[10:33:59.760]                           }
[10:33:59.760]                         }
[10:33:59.760]                       }
[10:33:59.760]                       invisible(muffled)
[10:33:59.760]                     }
[10:33:59.760]                     muffleCondition(cond, pattern = "^muffle")
[10:33:59.760]                   }
[10:33:59.760]                 }
[10:33:59.760]             }
[10:33:59.760]         }))
[10:33:59.760]     }, error = function(ex) {
[10:33:59.760]         base::structure(base::list(value = NULL, visible = NULL, 
[10:33:59.760]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:33:59.760]                 ...future.rng), started = ...future.startTime, 
[10:33:59.760]             finished = Sys.time(), session_uuid = NA_character_, 
[10:33:59.760]             version = "1.8"), class = "FutureResult")
[10:33:59.760]     }, finally = {
[10:33:59.760]         if (!identical(...future.workdir, getwd())) 
[10:33:59.760]             setwd(...future.workdir)
[10:33:59.760]         {
[10:33:59.760]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:33:59.760]                 ...future.oldOptions$nwarnings <- NULL
[10:33:59.760]             }
[10:33:59.760]             base::options(...future.oldOptions)
[10:33:59.760]             if (.Platform$OS.type == "windows") {
[10:33:59.760]                 old_names <- names(...future.oldEnvVars)
[10:33:59.760]                 envs <- base::Sys.getenv()
[10:33:59.760]                 names <- names(envs)
[10:33:59.760]                 common <- intersect(names, old_names)
[10:33:59.760]                 added <- setdiff(names, old_names)
[10:33:59.760]                 removed <- setdiff(old_names, names)
[10:33:59.760]                 changed <- common[...future.oldEnvVars[common] != 
[10:33:59.760]                   envs[common]]
[10:33:59.760]                 NAMES <- toupper(changed)
[10:33:59.760]                 args <- list()
[10:33:59.760]                 for (kk in seq_along(NAMES)) {
[10:33:59.760]                   name <- changed[[kk]]
[10:33:59.760]                   NAME <- NAMES[[kk]]
[10:33:59.760]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:59.760]                     next
[10:33:59.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:59.760]                 }
[10:33:59.760]                 NAMES <- toupper(added)
[10:33:59.760]                 for (kk in seq_along(NAMES)) {
[10:33:59.760]                   name <- added[[kk]]
[10:33:59.760]                   NAME <- NAMES[[kk]]
[10:33:59.760]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:59.760]                     next
[10:33:59.760]                   args[[name]] <- ""
[10:33:59.760]                 }
[10:33:59.760]                 NAMES <- toupper(removed)
[10:33:59.760]                 for (kk in seq_along(NAMES)) {
[10:33:59.760]                   name <- removed[[kk]]
[10:33:59.760]                   NAME <- NAMES[[kk]]
[10:33:59.760]                   if (name != NAME && is.element(NAME, old_names)) 
[10:33:59.760]                     next
[10:33:59.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:33:59.760]                 }
[10:33:59.760]                 if (length(args) > 0) 
[10:33:59.760]                   base::do.call(base::Sys.setenv, args = args)
[10:33:59.760]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:33:59.760]             }
[10:33:59.760]             else {
[10:33:59.760]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:33:59.760]             }
[10:33:59.760]             {
[10:33:59.760]                 if (base::length(...future.futureOptionsAdded) > 
[10:33:59.760]                   0L) {
[10:33:59.760]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:33:59.760]                   base::names(opts) <- ...future.futureOptionsAdded
[10:33:59.760]                   base::options(opts)
[10:33:59.760]                 }
[10:33:59.760]                 {
[10:33:59.760]                   {
[10:33:59.760]                     base::options(mc.cores = ...future.mc.cores.old)
[10:33:59.760]                     NULL
[10:33:59.760]                   }
[10:33:59.760]                   options(future.plan = NULL)
[10:33:59.760]                   if (is.na(NA_character_)) 
[10:33:59.760]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:33:59.760]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:33:59.760]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:33:59.760]                     .init = FALSE)
[10:33:59.760]                 }
[10:33:59.760]             }
[10:33:59.760]         }
[10:33:59.760]     })
[10:33:59.760]     if (TRUE) {
[10:33:59.760]         base::sink(type = "output", split = FALSE)
[10:33:59.760]         if (TRUE) {
[10:33:59.760]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:33:59.760]         }
[10:33:59.760]         else {
[10:33:59.760]             ...future.result["stdout"] <- base::list(NULL)
[10:33:59.760]         }
[10:33:59.760]         base::close(...future.stdout)
[10:33:59.760]         ...future.stdout <- NULL
[10:33:59.760]     }
[10:33:59.760]     ...future.result$conditions <- ...future.conditions
[10:33:59.760]     ...future.result$finished <- base::Sys.time()
[10:33:59.760]     ...future.result
[10:33:59.760] }
[10:33:59.764] requestCore(): workers = 2
[10:33:59.764] Poll #1 (0): usedCores() = 2, workers = 2
[10:33:59.775] result() for MulticoreFuture ...
[10:33:59.776] result() for MulticoreFuture ...
[10:33:59.776] result() for MulticoreFuture ... done
[10:33:59.776] result() for MulticoreFuture ... done
[10:33:59.776] result() for MulticoreFuture ...
[10:33:59.776] result() for MulticoreFuture ... done
[10:33:59.779] MulticoreFuture started
[10:33:59.780] - Launch lazy future ... done
[10:33:59.780] run() for ‘MulticoreFuture’ ... done
[10:33:59.780] plan(): Setting new future strategy stack:
[10:33:59.780] resolve() on list ...
[10:33:59.781]  recursive: 0
[10:33:59.781]  length: 1
[10:33:59.781] 
[10:33:59.780] List of future strategies:
[10:33:59.780] 1. sequential:
[10:33:59.780]    - args: function (..., envir = parent.frame())
[10:33:59.780]    - tweaked: FALSE
[10:33:59.780]    - call: NULL
[10:33:59.781] plan(): nbrOfWorkers() = 1
[10:33:59.782] Future #1
[10:33:59.782]  length: 0 (resolved future 1)
[10:33:59.782] resolve() on list ... DONE
[10:33:59.783] resolve() on list ...
[10:33:59.783]  recursive: 0
[10:33:59.783]  length: 1
[10:33:59.783] 
[10:34:00.285] plan(): Setting new future strategy stack:
[10:34:00.285] List of future strategies:
[10:34:00.285] 1. multicore:
[10:34:00.285]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:34:00.285]    - tweaked: FALSE
[10:34:00.285]    - call: plan(strategy)
[10:34:00.291] plan(): nbrOfWorkers() = 2
[10:34:00.293] Future #1
[10:34:00.293]  length: 0 (resolved future 1)
[10:34:00.293] resolve() on list ... DONE
[10:34:00.294] resolve() on list ...
[10:34:00.294]  recursive: 0
[10:34:00.294]  length: 1
[10:34:00.294] 
[10:34:00.295]  length: 0 (resolved future 1)
[10:34:00.295] resolve() on list ... DONE
[10:34:00.295] resolve() on list ...
[10:34:00.295]  recursive: 0
[10:34:00.295]  length: 4
[10:34:00.295] 
[10:34:00.296] Future #1
[10:34:00.296]  length: 3 (resolved future 1)
[10:34:00.296] Future #2
[10:34:00.296]  length: 2 (resolved future 2)
[10:34:00.297]  length: 1 (resolved future 3)
[10:34:00.297]  length: 0 (resolved future 4)
[10:34:00.297] resolve() on list ... DONE
[10:34:00.297] resolve() on list ...
[10:34:00.297]  recursive: 0
[10:34:00.297]  length: 4
[10:34:00.298] 
[10:34:00.298] Future #1
[10:34:00.298]  length: 3 (resolved future 1)
[10:34:00.298] Future #2
[10:34:00.298]  length: 2 (resolved future 2)
[10:34:00.299]  length: 1 (resolved future 3)
[10:34:00.299]  length: 0 (resolved future 4)
[10:34:00.299] resolve() on list ... DONE
[10:34:00.299] resolve() on list ...
[10:34:00.299]  recursive: 0
[10:34:00.300]  length: 1
[10:34:00.300] 
[10:34:00.300]  length: 0 (resolved future 1)
[10:34:00.300] resolve() on list ... DONE
[10:34:00.300] getGlobalsAndPackages() ...
[10:34:00.300] Searching for globals...
[10:34:00.302] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:34:00.303] Searching for globals ... DONE
[10:34:00.303] Resolving globals: FALSE
[10:34:00.303] The total size of the 1 globals is 56 bytes (56 bytes)
[10:34:00.304] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:34:00.304] - globals: [1] ‘kk’
[10:34:00.304] 
[10:34:00.304] getGlobalsAndPackages() ... DONE
[10:34:00.305] run() for ‘Future’ ...
[10:34:00.305] - state: ‘created’
[10:34:00.305] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:34:00.315] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:00.315] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:34:00.315]   - Field: ‘label’
[10:34:00.316]   - Field: ‘local’
[10:34:00.316]   - Field: ‘owner’
[10:34:00.316]   - Field: ‘envir’
[10:34:00.317]   - Field: ‘workers’
[10:34:00.317]   - Field: ‘packages’
[10:34:00.317]   - Field: ‘gc’
[10:34:00.317]   - Field: ‘job’
[10:34:00.318]   - Field: ‘conditions’
[10:34:00.318]   - Field: ‘expr’
[10:34:00.318]   - Field: ‘uuid’
[10:34:00.318]   - Field: ‘seed’
[10:34:00.318]   - Field: ‘version’
[10:34:00.319]   - Field: ‘result’
[10:34:00.319]   - Field: ‘asynchronous’
[10:34:00.319]   - Field: ‘calls’
[10:34:00.319]   - Field: ‘globals’
[10:34:00.319]   - Field: ‘stdout’
[10:34:00.319]   - Field: ‘earlySignal’
[10:34:00.320]   - Field: ‘lazy’
[10:34:00.320]   - Field: ‘state’
[10:34:00.320] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:34:00.320] - Launch lazy future ...
[10:34:00.320] Packages needed by the future expression (n = 0): <none>
[10:34:00.321] Packages needed by future strategies (n = 0): <none>
[10:34:00.321] {
[10:34:00.321]     {
[10:34:00.321]         {
[10:34:00.321]             ...future.startTime <- base::Sys.time()
[10:34:00.321]             {
[10:34:00.321]                 {
[10:34:00.321]                   {
[10:34:00.321]                     {
[10:34:00.321]                       base::local({
[10:34:00.321]                         has_future <- base::requireNamespace("future", 
[10:34:00.321]                           quietly = TRUE)
[10:34:00.321]                         if (has_future) {
[10:34:00.321]                           ns <- base::getNamespace("future")
[10:34:00.321]                           version <- ns[[".package"]][["version"]]
[10:34:00.321]                           if (is.null(version)) 
[10:34:00.321]                             version <- utils::packageVersion("future")
[10:34:00.321]                         }
[10:34:00.321]                         else {
[10:34:00.321]                           version <- NULL
[10:34:00.321]                         }
[10:34:00.321]                         if (!has_future || version < "1.8.0") {
[10:34:00.321]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:00.321]                             "", base::R.version$version.string), 
[10:34:00.321]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:00.321]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:00.321]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:00.321]                               "release", "version")], collapse = " "), 
[10:34:00.321]                             hostname = base::Sys.info()[["nodename"]])
[10:34:00.321]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:00.321]                             info)
[10:34:00.321]                           info <- base::paste(info, collapse = "; ")
[10:34:00.321]                           if (!has_future) {
[10:34:00.321]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:00.321]                               info)
[10:34:00.321]                           }
[10:34:00.321]                           else {
[10:34:00.321]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:00.321]                               info, version)
[10:34:00.321]                           }
[10:34:00.321]                           base::stop(msg)
[10:34:00.321]                         }
[10:34:00.321]                       })
[10:34:00.321]                     }
[10:34:00.321]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:00.321]                     base::options(mc.cores = 1L)
[10:34:00.321]                   }
[10:34:00.321]                   ...future.strategy.old <- future::plan("list")
[10:34:00.321]                   options(future.plan = NULL)
[10:34:00.321]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:00.321]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:00.321]                 }
[10:34:00.321]                 ...future.workdir <- getwd()
[10:34:00.321]             }
[10:34:00.321]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:00.321]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:00.321]         }
[10:34:00.321]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:00.321]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:00.321]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:00.321]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:00.321]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:00.321]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:00.321]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:00.321]             base::names(...future.oldOptions))
[10:34:00.321]     }
[10:34:00.321]     if (FALSE) {
[10:34:00.321]     }
[10:34:00.321]     else {
[10:34:00.321]         if (TRUE) {
[10:34:00.321]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:00.321]                 open = "w")
[10:34:00.321]         }
[10:34:00.321]         else {
[10:34:00.321]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:00.321]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:00.321]         }
[10:34:00.321]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:00.321]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:00.321]             base::sink(type = "output", split = FALSE)
[10:34:00.321]             base::close(...future.stdout)
[10:34:00.321]         }, add = TRUE)
[10:34:00.321]     }
[10:34:00.321]     ...future.frame <- base::sys.nframe()
[10:34:00.321]     ...future.conditions <- base::list()
[10:34:00.321]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:00.321]     if (FALSE) {
[10:34:00.321]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:00.321]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:00.321]     }
[10:34:00.321]     ...future.result <- base::tryCatch({
[10:34:00.321]         base::withCallingHandlers({
[10:34:00.321]             ...future.value <- base::withVisible(base::local({
[10:34:00.321]                 withCallingHandlers({
[10:34:00.321]                   {
[10:34:00.321]                     Sys.sleep(0.1)
[10:34:00.321]                     kk
[10:34:00.321]                   }
[10:34:00.321]                 }, immediateCondition = function(cond) {
[10:34:00.321]                   save_rds <- function (object, pathname, ...) 
[10:34:00.321]                   {
[10:34:00.321]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:34:00.321]                     if (file_test("-f", pathname_tmp)) {
[10:34:00.321]                       fi_tmp <- file.info(pathname_tmp)
[10:34:00.321]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:34:00.321]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:00.321]                         fi_tmp[["mtime"]])
[10:34:00.321]                     }
[10:34:00.321]                     tryCatch({
[10:34:00.321]                       saveRDS(object, file = pathname_tmp, ...)
[10:34:00.321]                     }, error = function(ex) {
[10:34:00.321]                       msg <- conditionMessage(ex)
[10:34:00.321]                       fi_tmp <- file.info(pathname_tmp)
[10:34:00.321]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:34:00.321]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:00.321]                         fi_tmp[["mtime"]], msg)
[10:34:00.321]                       ex$message <- msg
[10:34:00.321]                       stop(ex)
[10:34:00.321]                     })
[10:34:00.321]                     stopifnot(file_test("-f", pathname_tmp))
[10:34:00.321]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:34:00.321]                     if (!res || file_test("-f", pathname_tmp)) {
[10:34:00.321]                       fi_tmp <- file.info(pathname_tmp)
[10:34:00.321]                       fi <- file.info(pathname)
[10:34:00.321]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:34:00.321]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:00.321]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:34:00.321]                         fi[["size"]], fi[["mtime"]])
[10:34:00.321]                       stop(msg)
[10:34:00.321]                     }
[10:34:00.321]                     invisible(pathname)
[10:34:00.321]                   }
[10:34:00.321]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:34:00.321]                     rootPath = tempdir()) 
[10:34:00.321]                   {
[10:34:00.321]                     obj <- list(time = Sys.time(), condition = cond)
[10:34:00.321]                     file <- tempfile(pattern = class(cond)[1], 
[10:34:00.321]                       tmpdir = path, fileext = ".rds")
[10:34:00.321]                     save_rds(obj, file)
[10:34:00.321]                   }
[10:34:00.321]                   saveImmediateCondition(cond, path = "/tmp/RtmpuZEzLw/.future/immediateConditions")
[10:34:00.321]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:00.321]                   {
[10:34:00.321]                     inherits <- base::inherits
[10:34:00.321]                     invokeRestart <- base::invokeRestart
[10:34:00.321]                     is.null <- base::is.null
[10:34:00.321]                     muffled <- FALSE
[10:34:00.321]                     if (inherits(cond, "message")) {
[10:34:00.321]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:00.321]                       if (muffled) 
[10:34:00.321]                         invokeRestart("muffleMessage")
[10:34:00.321]                     }
[10:34:00.321]                     else if (inherits(cond, "warning")) {
[10:34:00.321]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:00.321]                       if (muffled) 
[10:34:00.321]                         invokeRestart("muffleWarning")
[10:34:00.321]                     }
[10:34:00.321]                     else if (inherits(cond, "condition")) {
[10:34:00.321]                       if (!is.null(pattern)) {
[10:34:00.321]                         computeRestarts <- base::computeRestarts
[10:34:00.321]                         grepl <- base::grepl
[10:34:00.321]                         restarts <- computeRestarts(cond)
[10:34:00.321]                         for (restart in restarts) {
[10:34:00.321]                           name <- restart$name
[10:34:00.321]                           if (is.null(name)) 
[10:34:00.321]                             next
[10:34:00.321]                           if (!grepl(pattern, name)) 
[10:34:00.321]                             next
[10:34:00.321]                           invokeRestart(restart)
[10:34:00.321]                           muffled <- TRUE
[10:34:00.321]                           break
[10:34:00.321]                         }
[10:34:00.321]                       }
[10:34:00.321]                     }
[10:34:00.321]                     invisible(muffled)
[10:34:00.321]                   }
[10:34:00.321]                   muffleCondition(cond)
[10:34:00.321]                 })
[10:34:00.321]             }))
[10:34:00.321]             future::FutureResult(value = ...future.value$value, 
[10:34:00.321]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:00.321]                   ...future.rng), globalenv = if (FALSE) 
[10:34:00.321]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:00.321]                     ...future.globalenv.names))
[10:34:00.321]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:00.321]         }, condition = base::local({
[10:34:00.321]             c <- base::c
[10:34:00.321]             inherits <- base::inherits
[10:34:00.321]             invokeRestart <- base::invokeRestart
[10:34:00.321]             length <- base::length
[10:34:00.321]             list <- base::list
[10:34:00.321]             seq.int <- base::seq.int
[10:34:00.321]             signalCondition <- base::signalCondition
[10:34:00.321]             sys.calls <- base::sys.calls
[10:34:00.321]             `[[` <- base::`[[`
[10:34:00.321]             `+` <- base::`+`
[10:34:00.321]             `<<-` <- base::`<<-`
[10:34:00.321]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:00.321]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:00.321]                   3L)]
[10:34:00.321]             }
[10:34:00.321]             function(cond) {
[10:34:00.321]                 is_error <- inherits(cond, "error")
[10:34:00.321]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:00.321]                   NULL)
[10:34:00.321]                 if (is_error) {
[10:34:00.321]                   sessionInformation <- function() {
[10:34:00.321]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:00.321]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:00.321]                       search = base::search(), system = base::Sys.info())
[10:34:00.321]                   }
[10:34:00.321]                   ...future.conditions[[length(...future.conditions) + 
[10:34:00.321]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:00.321]                     cond$call), session = sessionInformation(), 
[10:34:00.321]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:00.321]                   signalCondition(cond)
[10:34:00.321]                 }
[10:34:00.321]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:00.321]                 "immediateCondition"))) {
[10:34:00.321]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:00.321]                   ...future.conditions[[length(...future.conditions) + 
[10:34:00.321]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:00.321]                   if (TRUE && !signal) {
[10:34:00.321]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:00.321]                     {
[10:34:00.321]                       inherits <- base::inherits
[10:34:00.321]                       invokeRestart <- base::invokeRestart
[10:34:00.321]                       is.null <- base::is.null
[10:34:00.321]                       muffled <- FALSE
[10:34:00.321]                       if (inherits(cond, "message")) {
[10:34:00.321]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:00.321]                         if (muffled) 
[10:34:00.321]                           invokeRestart("muffleMessage")
[10:34:00.321]                       }
[10:34:00.321]                       else if (inherits(cond, "warning")) {
[10:34:00.321]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:00.321]                         if (muffled) 
[10:34:00.321]                           invokeRestart("muffleWarning")
[10:34:00.321]                       }
[10:34:00.321]                       else if (inherits(cond, "condition")) {
[10:34:00.321]                         if (!is.null(pattern)) {
[10:34:00.321]                           computeRestarts <- base::computeRestarts
[10:34:00.321]                           grepl <- base::grepl
[10:34:00.321]                           restarts <- computeRestarts(cond)
[10:34:00.321]                           for (restart in restarts) {
[10:34:00.321]                             name <- restart$name
[10:34:00.321]                             if (is.null(name)) 
[10:34:00.321]                               next
[10:34:00.321]                             if (!grepl(pattern, name)) 
[10:34:00.321]                               next
[10:34:00.321]                             invokeRestart(restart)
[10:34:00.321]                             muffled <- TRUE
[10:34:00.321]                             break
[10:34:00.321]                           }
[10:34:00.321]                         }
[10:34:00.321]                       }
[10:34:00.321]                       invisible(muffled)
[10:34:00.321]                     }
[10:34:00.321]                     muffleCondition(cond, pattern = "^muffle")
[10:34:00.321]                   }
[10:34:00.321]                 }
[10:34:00.321]                 else {
[10:34:00.321]                   if (TRUE) {
[10:34:00.321]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:00.321]                     {
[10:34:00.321]                       inherits <- base::inherits
[10:34:00.321]                       invokeRestart <- base::invokeRestart
[10:34:00.321]                       is.null <- base::is.null
[10:34:00.321]                       muffled <- FALSE
[10:34:00.321]                       if (inherits(cond, "message")) {
[10:34:00.321]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:00.321]                         if (muffled) 
[10:34:00.321]                           invokeRestart("muffleMessage")
[10:34:00.321]                       }
[10:34:00.321]                       else if (inherits(cond, "warning")) {
[10:34:00.321]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:00.321]                         if (muffled) 
[10:34:00.321]                           invokeRestart("muffleWarning")
[10:34:00.321]                       }
[10:34:00.321]                       else if (inherits(cond, "condition")) {
[10:34:00.321]                         if (!is.null(pattern)) {
[10:34:00.321]                           computeRestarts <- base::computeRestarts
[10:34:00.321]                           grepl <- base::grepl
[10:34:00.321]                           restarts <- computeRestarts(cond)
[10:34:00.321]                           for (restart in restarts) {
[10:34:00.321]                             name <- restart$name
[10:34:00.321]                             if (is.null(name)) 
[10:34:00.321]                               next
[10:34:00.321]                             if (!grepl(pattern, name)) 
[10:34:00.321]                               next
[10:34:00.321]                             invokeRestart(restart)
[10:34:00.321]                             muffled <- TRUE
[10:34:00.321]                             break
[10:34:00.321]                           }
[10:34:00.321]                         }
[10:34:00.321]                       }
[10:34:00.321]                       invisible(muffled)
[10:34:00.321]                     }
[10:34:00.321]                     muffleCondition(cond, pattern = "^muffle")
[10:34:00.321]                   }
[10:34:00.321]                 }
[10:34:00.321]             }
[10:34:00.321]         }))
[10:34:00.321]     }, error = function(ex) {
[10:34:00.321]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:00.321]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:00.321]                 ...future.rng), started = ...future.startTime, 
[10:34:00.321]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:00.321]             version = "1.8"), class = "FutureResult")
[10:34:00.321]     }, finally = {
[10:34:00.321]         if (!identical(...future.workdir, getwd())) 
[10:34:00.321]             setwd(...future.workdir)
[10:34:00.321]         {
[10:34:00.321]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:00.321]                 ...future.oldOptions$nwarnings <- NULL
[10:34:00.321]             }
[10:34:00.321]             base::options(...future.oldOptions)
[10:34:00.321]             if (.Platform$OS.type == "windows") {
[10:34:00.321]                 old_names <- names(...future.oldEnvVars)
[10:34:00.321]                 envs <- base::Sys.getenv()
[10:34:00.321]                 names <- names(envs)
[10:34:00.321]                 common <- intersect(names, old_names)
[10:34:00.321]                 added <- setdiff(names, old_names)
[10:34:00.321]                 removed <- setdiff(old_names, names)
[10:34:00.321]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:00.321]                   envs[common]]
[10:34:00.321]                 NAMES <- toupper(changed)
[10:34:00.321]                 args <- list()
[10:34:00.321]                 for (kk in seq_along(NAMES)) {
[10:34:00.321]                   name <- changed[[kk]]
[10:34:00.321]                   NAME <- NAMES[[kk]]
[10:34:00.321]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:00.321]                     next
[10:34:00.321]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:00.321]                 }
[10:34:00.321]                 NAMES <- toupper(added)
[10:34:00.321]                 for (kk in seq_along(NAMES)) {
[10:34:00.321]                   name <- added[[kk]]
[10:34:00.321]                   NAME <- NAMES[[kk]]
[10:34:00.321]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:00.321]                     next
[10:34:00.321]                   args[[name]] <- ""
[10:34:00.321]                 }
[10:34:00.321]                 NAMES <- toupper(removed)
[10:34:00.321]                 for (kk in seq_along(NAMES)) {
[10:34:00.321]                   name <- removed[[kk]]
[10:34:00.321]                   NAME <- NAMES[[kk]]
[10:34:00.321]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:00.321]                     next
[10:34:00.321]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:00.321]                 }
[10:34:00.321]                 if (length(args) > 0) 
[10:34:00.321]                   base::do.call(base::Sys.setenv, args = args)
[10:34:00.321]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:00.321]             }
[10:34:00.321]             else {
[10:34:00.321]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:00.321]             }
[10:34:00.321]             {
[10:34:00.321]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:00.321]                   0L) {
[10:34:00.321]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:00.321]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:00.321]                   base::options(opts)
[10:34:00.321]                 }
[10:34:00.321]                 {
[10:34:00.321]                   {
[10:34:00.321]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:00.321]                     NULL
[10:34:00.321]                   }
[10:34:00.321]                   options(future.plan = NULL)
[10:34:00.321]                   if (is.na(NA_character_)) 
[10:34:00.321]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:00.321]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:00.321]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:00.321]                     .init = FALSE)
[10:34:00.321]                 }
[10:34:00.321]             }
[10:34:00.321]         }
[10:34:00.321]     })
[10:34:00.321]     if (TRUE) {
[10:34:00.321]         base::sink(type = "output", split = FALSE)
[10:34:00.321]         if (TRUE) {
[10:34:00.321]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:00.321]         }
[10:34:00.321]         else {
[10:34:00.321]             ...future.result["stdout"] <- base::list(NULL)
[10:34:00.321]         }
[10:34:00.321]         base::close(...future.stdout)
[10:34:00.321]         ...future.stdout <- NULL
[10:34:00.321]     }
[10:34:00.321]     ...future.result$conditions <- ...future.conditions
[10:34:00.321]     ...future.result$finished <- base::Sys.time()
[10:34:00.321]     ...future.result
[10:34:00.321] }
[10:34:00.324] assign_globals() ...
[10:34:00.324] List of 1
[10:34:00.324]  $ kk: int 1
[10:34:00.324]  - attr(*, "where")=List of 1
[10:34:00.324]   ..$ kk:<environment: R_EmptyEnv> 
[10:34:00.324]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:34:00.324]  - attr(*, "resolved")= logi FALSE
[10:34:00.324]  - attr(*, "total_size")= num 56
[10:34:00.324]  - attr(*, "already-done")= logi TRUE
[10:34:00.328] - copied ‘kk’ to environment
[10:34:00.328] assign_globals() ... done
[10:34:00.329] requestCore(): workers = 2
[10:34:00.329] Poll #1 (0): usedCores() = 2, workers = 2
[10:34:00.340] result() for MulticoreFuture ...
[10:34:00.340] result() for MulticoreFuture ...
[10:34:00.341] result() for MulticoreFuture ... done
[10:34:00.341] result() for MulticoreFuture ... done
[10:34:00.341] result() for MulticoreFuture ...
[10:34:00.341] result() for MulticoreFuture ... done
[10:34:00.343] MulticoreFuture started
[10:34:00.344] - Launch lazy future ... done
[10:34:00.344] run() for ‘MulticoreFuture’ ... done
[10:34:00.345] getGlobalsAndPackages() ...
[10:34:00.345] Searching for globals...
[10:34:00.345] plan(): Setting new future strategy stack:
[10:34:00.345] List of future strategies:
[10:34:00.345] 1. sequential:
[10:34:00.345]    - args: function (..., envir = parent.frame())
[10:34:00.345]    - tweaked: FALSE
[10:34:00.345]    - call: NULL
[10:34:00.346] plan(): nbrOfWorkers() = 1
[10:34:00.348] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:34:00.348] Searching for globals ... DONE
[10:34:00.349] Resolving globals: FALSE
[10:34:00.350] The total size of the 1 globals is 56 bytes (56 bytes)
[10:34:00.350] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:34:00.350] - globals: [1] ‘kk’
[10:34:00.351] 
[10:34:00.351] getGlobalsAndPackages() ... DONE
[10:34:00.351] run() for ‘Future’ ...
[10:34:00.351] - state: ‘created’
[10:34:00.352] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:34:00.357] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:00.357] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:34:00.357]   - Field: ‘label’
[10:34:00.358]   - Field: ‘local’
[10:34:00.358]   - Field: ‘owner’
[10:34:00.358]   - Field: ‘envir’
[10:34:00.358]   - Field: ‘workers’
[10:34:00.358]   - Field: ‘packages’
[10:34:00.358]   - Field: ‘gc’
[10:34:00.359]   - Field: ‘job’
[10:34:00.359]   - Field: ‘conditions’
[10:34:00.359]   - Field: ‘expr’
[10:34:00.359]   - Field: ‘uuid’
[10:34:00.359]   - Field: ‘seed’
[10:34:00.359]   - Field: ‘version’
[10:34:00.359]   - Field: ‘result’
[10:34:00.360]   - Field: ‘asynchronous’
[10:34:00.360]   - Field: ‘calls’
[10:34:00.360]   - Field: ‘globals’
[10:34:00.360]   - Field: ‘stdout’
[10:34:00.360]   - Field: ‘earlySignal’
[10:34:00.360]   - Field: ‘lazy’
[10:34:00.360]   - Field: ‘state’
[10:34:00.360] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:34:00.361] - Launch lazy future ...
[10:34:00.361] Packages needed by the future expression (n = 0): <none>
[10:34:00.361] Packages needed by future strategies (n = 0): <none>
[10:34:00.362] {
[10:34:00.362]     {
[10:34:00.362]         {
[10:34:00.362]             ...future.startTime <- base::Sys.time()
[10:34:00.362]             {
[10:34:00.362]                 {
[10:34:00.362]                   {
[10:34:00.362]                     {
[10:34:00.362]                       base::local({
[10:34:00.362]                         has_future <- base::requireNamespace("future", 
[10:34:00.362]                           quietly = TRUE)
[10:34:00.362]                         if (has_future) {
[10:34:00.362]                           ns <- base::getNamespace("future")
[10:34:00.362]                           version <- ns[[".package"]][["version"]]
[10:34:00.362]                           if (is.null(version)) 
[10:34:00.362]                             version <- utils::packageVersion("future")
[10:34:00.362]                         }
[10:34:00.362]                         else {
[10:34:00.362]                           version <- NULL
[10:34:00.362]                         }
[10:34:00.362]                         if (!has_future || version < "1.8.0") {
[10:34:00.362]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:00.362]                             "", base::R.version$version.string), 
[10:34:00.362]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:00.362]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:00.362]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:00.362]                               "release", "version")], collapse = " "), 
[10:34:00.362]                             hostname = base::Sys.info()[["nodename"]])
[10:34:00.362]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:00.362]                             info)
[10:34:00.362]                           info <- base::paste(info, collapse = "; ")
[10:34:00.362]                           if (!has_future) {
[10:34:00.362]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:00.362]                               info)
[10:34:00.362]                           }
[10:34:00.362]                           else {
[10:34:00.362]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:00.362]                               info, version)
[10:34:00.362]                           }
[10:34:00.362]                           base::stop(msg)
[10:34:00.362]                         }
[10:34:00.362]                       })
[10:34:00.362]                     }
[10:34:00.362]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:00.362]                     base::options(mc.cores = 1L)
[10:34:00.362]                   }
[10:34:00.362]                   ...future.strategy.old <- future::plan("list")
[10:34:00.362]                   options(future.plan = NULL)
[10:34:00.362]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:00.362]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:00.362]                 }
[10:34:00.362]                 ...future.workdir <- getwd()
[10:34:00.362]             }
[10:34:00.362]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:00.362]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:00.362]         }
[10:34:00.362]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:00.362]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:00.362]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:00.362]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:00.362]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:00.362]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:00.362]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:00.362]             base::names(...future.oldOptions))
[10:34:00.362]     }
[10:34:00.362]     if (FALSE) {
[10:34:00.362]     }
[10:34:00.362]     else {
[10:34:00.362]         if (TRUE) {
[10:34:00.362]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:00.362]                 open = "w")
[10:34:00.362]         }
[10:34:00.362]         else {
[10:34:00.362]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:00.362]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:00.362]         }
[10:34:00.362]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:00.362]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:00.362]             base::sink(type = "output", split = FALSE)
[10:34:00.362]             base::close(...future.stdout)
[10:34:00.362]         }, add = TRUE)
[10:34:00.362]     }
[10:34:00.362]     ...future.frame <- base::sys.nframe()
[10:34:00.362]     ...future.conditions <- base::list()
[10:34:00.362]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:00.362]     if (FALSE) {
[10:34:00.362]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:00.362]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:00.362]     }
[10:34:00.362]     ...future.result <- base::tryCatch({
[10:34:00.362]         base::withCallingHandlers({
[10:34:00.362]             ...future.value <- base::withVisible(base::local({
[10:34:00.362]                 withCallingHandlers({
[10:34:00.362]                   {
[10:34:00.362]                     Sys.sleep(0.1)
[10:34:00.362]                     kk
[10:34:00.362]                   }
[10:34:00.362]                 }, immediateCondition = function(cond) {
[10:34:00.362]                   save_rds <- function (object, pathname, ...) 
[10:34:00.362]                   {
[10:34:00.362]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:34:00.362]                     if (file_test("-f", pathname_tmp)) {
[10:34:00.362]                       fi_tmp <- file.info(pathname_tmp)
[10:34:00.362]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:34:00.362]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:00.362]                         fi_tmp[["mtime"]])
[10:34:00.362]                     }
[10:34:00.362]                     tryCatch({
[10:34:00.362]                       saveRDS(object, file = pathname_tmp, ...)
[10:34:00.362]                     }, error = function(ex) {
[10:34:00.362]                       msg <- conditionMessage(ex)
[10:34:00.362]                       fi_tmp <- file.info(pathname_tmp)
[10:34:00.362]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:34:00.362]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:00.362]                         fi_tmp[["mtime"]], msg)
[10:34:00.362]                       ex$message <- msg
[10:34:00.362]                       stop(ex)
[10:34:00.362]                     })
[10:34:00.362]                     stopifnot(file_test("-f", pathname_tmp))
[10:34:00.362]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:34:00.362]                     if (!res || file_test("-f", pathname_tmp)) {
[10:34:00.362]                       fi_tmp <- file.info(pathname_tmp)
[10:34:00.362]                       fi <- file.info(pathname)
[10:34:00.362]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:34:00.362]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:00.362]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:34:00.362]                         fi[["size"]], fi[["mtime"]])
[10:34:00.362]                       stop(msg)
[10:34:00.362]                     }
[10:34:00.362]                     invisible(pathname)
[10:34:00.362]                   }
[10:34:00.362]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:34:00.362]                     rootPath = tempdir()) 
[10:34:00.362]                   {
[10:34:00.362]                     obj <- list(time = Sys.time(), condition = cond)
[10:34:00.362]                     file <- tempfile(pattern = class(cond)[1], 
[10:34:00.362]                       tmpdir = path, fileext = ".rds")
[10:34:00.362]                     save_rds(obj, file)
[10:34:00.362]                   }
[10:34:00.362]                   saveImmediateCondition(cond, path = "/tmp/RtmpuZEzLw/.future/immediateConditions")
[10:34:00.362]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:00.362]                   {
[10:34:00.362]                     inherits <- base::inherits
[10:34:00.362]                     invokeRestart <- base::invokeRestart
[10:34:00.362]                     is.null <- base::is.null
[10:34:00.362]                     muffled <- FALSE
[10:34:00.362]                     if (inherits(cond, "message")) {
[10:34:00.362]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:00.362]                       if (muffled) 
[10:34:00.362]                         invokeRestart("muffleMessage")
[10:34:00.362]                     }
[10:34:00.362]                     else if (inherits(cond, "warning")) {
[10:34:00.362]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:00.362]                       if (muffled) 
[10:34:00.362]                         invokeRestart("muffleWarning")
[10:34:00.362]                     }
[10:34:00.362]                     else if (inherits(cond, "condition")) {
[10:34:00.362]                       if (!is.null(pattern)) {
[10:34:00.362]                         computeRestarts <- base::computeRestarts
[10:34:00.362]                         grepl <- base::grepl
[10:34:00.362]                         restarts <- computeRestarts(cond)
[10:34:00.362]                         for (restart in restarts) {
[10:34:00.362]                           name <- restart$name
[10:34:00.362]                           if (is.null(name)) 
[10:34:00.362]                             next
[10:34:00.362]                           if (!grepl(pattern, name)) 
[10:34:00.362]                             next
[10:34:00.362]                           invokeRestart(restart)
[10:34:00.362]                           muffled <- TRUE
[10:34:00.362]                           break
[10:34:00.362]                         }
[10:34:00.362]                       }
[10:34:00.362]                     }
[10:34:00.362]                     invisible(muffled)
[10:34:00.362]                   }
[10:34:00.362]                   muffleCondition(cond)
[10:34:00.362]                 })
[10:34:00.362]             }))
[10:34:00.362]             future::FutureResult(value = ...future.value$value, 
[10:34:00.362]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:00.362]                   ...future.rng), globalenv = if (FALSE) 
[10:34:00.362]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:00.362]                     ...future.globalenv.names))
[10:34:00.362]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:00.362]         }, condition = base::local({
[10:34:00.362]             c <- base::c
[10:34:00.362]             inherits <- base::inherits
[10:34:00.362]             invokeRestart <- base::invokeRestart
[10:34:00.362]             length <- base::length
[10:34:00.362]             list <- base::list
[10:34:00.362]             seq.int <- base::seq.int
[10:34:00.362]             signalCondition <- base::signalCondition
[10:34:00.362]             sys.calls <- base::sys.calls
[10:34:00.362]             `[[` <- base::`[[`
[10:34:00.362]             `+` <- base::`+`
[10:34:00.362]             `<<-` <- base::`<<-`
[10:34:00.362]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:00.362]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:00.362]                   3L)]
[10:34:00.362]             }
[10:34:00.362]             function(cond) {
[10:34:00.362]                 is_error <- inherits(cond, "error")
[10:34:00.362]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:00.362]                   NULL)
[10:34:00.362]                 if (is_error) {
[10:34:00.362]                   sessionInformation <- function() {
[10:34:00.362]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:00.362]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:00.362]                       search = base::search(), system = base::Sys.info())
[10:34:00.362]                   }
[10:34:00.362]                   ...future.conditions[[length(...future.conditions) + 
[10:34:00.362]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:00.362]                     cond$call), session = sessionInformation(), 
[10:34:00.362]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:00.362]                   signalCondition(cond)
[10:34:00.362]                 }
[10:34:00.362]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:00.362]                 "immediateCondition"))) {
[10:34:00.362]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:00.362]                   ...future.conditions[[length(...future.conditions) + 
[10:34:00.362]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:00.362]                   if (TRUE && !signal) {
[10:34:00.362]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:00.362]                     {
[10:34:00.362]                       inherits <- base::inherits
[10:34:00.362]                       invokeRestart <- base::invokeRestart
[10:34:00.362]                       is.null <- base::is.null
[10:34:00.362]                       muffled <- FALSE
[10:34:00.362]                       if (inherits(cond, "message")) {
[10:34:00.362]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:00.362]                         if (muffled) 
[10:34:00.362]                           invokeRestart("muffleMessage")
[10:34:00.362]                       }
[10:34:00.362]                       else if (inherits(cond, "warning")) {
[10:34:00.362]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:00.362]                         if (muffled) 
[10:34:00.362]                           invokeRestart("muffleWarning")
[10:34:00.362]                       }
[10:34:00.362]                       else if (inherits(cond, "condition")) {
[10:34:00.362]                         if (!is.null(pattern)) {
[10:34:00.362]                           computeRestarts <- base::computeRestarts
[10:34:00.362]                           grepl <- base::grepl
[10:34:00.362]                           restarts <- computeRestarts(cond)
[10:34:00.362]                           for (restart in restarts) {
[10:34:00.362]                             name <- restart$name
[10:34:00.362]                             if (is.null(name)) 
[10:34:00.362]                               next
[10:34:00.362]                             if (!grepl(pattern, name)) 
[10:34:00.362]                               next
[10:34:00.362]                             invokeRestart(restart)
[10:34:00.362]                             muffled <- TRUE
[10:34:00.362]                             break
[10:34:00.362]                           }
[10:34:00.362]                         }
[10:34:00.362]                       }
[10:34:00.362]                       invisible(muffled)
[10:34:00.362]                     }
[10:34:00.362]                     muffleCondition(cond, pattern = "^muffle")
[10:34:00.362]                   }
[10:34:00.362]                 }
[10:34:00.362]                 else {
[10:34:00.362]                   if (TRUE) {
[10:34:00.362]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:00.362]                     {
[10:34:00.362]                       inherits <- base::inherits
[10:34:00.362]                       invokeRestart <- base::invokeRestart
[10:34:00.362]                       is.null <- base::is.null
[10:34:00.362]                       muffled <- FALSE
[10:34:00.362]                       if (inherits(cond, "message")) {
[10:34:00.362]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:00.362]                         if (muffled) 
[10:34:00.362]                           invokeRestart("muffleMessage")
[10:34:00.362]                       }
[10:34:00.362]                       else if (inherits(cond, "warning")) {
[10:34:00.362]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:00.362]                         if (muffled) 
[10:34:00.362]                           invokeRestart("muffleWarning")
[10:34:00.362]                       }
[10:34:00.362]                       else if (inherits(cond, "condition")) {
[10:34:00.362]                         if (!is.null(pattern)) {
[10:34:00.362]                           computeRestarts <- base::computeRestarts
[10:34:00.362]                           grepl <- base::grepl
[10:34:00.362]                           restarts <- computeRestarts(cond)
[10:34:00.362]                           for (restart in restarts) {
[10:34:00.362]                             name <- restart$name
[10:34:00.362]                             if (is.null(name)) 
[10:34:00.362]                               next
[10:34:00.362]                             if (!grepl(pattern, name)) 
[10:34:00.362]                               next
[10:34:00.362]                             invokeRestart(restart)
[10:34:00.362]                             muffled <- TRUE
[10:34:00.362]                             break
[10:34:00.362]                           }
[10:34:00.362]                         }
[10:34:00.362]                       }
[10:34:00.362]                       invisible(muffled)
[10:34:00.362]                     }
[10:34:00.362]                     muffleCondition(cond, pattern = "^muffle")
[10:34:00.362]                   }
[10:34:00.362]                 }
[10:34:00.362]             }
[10:34:00.362]         }))
[10:34:00.362]     }, error = function(ex) {
[10:34:00.362]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:00.362]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:00.362]                 ...future.rng), started = ...future.startTime, 
[10:34:00.362]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:00.362]             version = "1.8"), class = "FutureResult")
[10:34:00.362]     }, finally = {
[10:34:00.362]         if (!identical(...future.workdir, getwd())) 
[10:34:00.362]             setwd(...future.workdir)
[10:34:00.362]         {
[10:34:00.362]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:00.362]                 ...future.oldOptions$nwarnings <- NULL
[10:34:00.362]             }
[10:34:00.362]             base::options(...future.oldOptions)
[10:34:00.362]             if (.Platform$OS.type == "windows") {
[10:34:00.362]                 old_names <- names(...future.oldEnvVars)
[10:34:00.362]                 envs <- base::Sys.getenv()
[10:34:00.362]                 names <- names(envs)
[10:34:00.362]                 common <- intersect(names, old_names)
[10:34:00.362]                 added <- setdiff(names, old_names)
[10:34:00.362]                 removed <- setdiff(old_names, names)
[10:34:00.362]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:00.362]                   envs[common]]
[10:34:00.362]                 NAMES <- toupper(changed)
[10:34:00.362]                 args <- list()
[10:34:00.362]                 for (kk in seq_along(NAMES)) {
[10:34:00.362]                   name <- changed[[kk]]
[10:34:00.362]                   NAME <- NAMES[[kk]]
[10:34:00.362]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:00.362]                     next
[10:34:00.362]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:00.362]                 }
[10:34:00.362]                 NAMES <- toupper(added)
[10:34:00.362]                 for (kk in seq_along(NAMES)) {
[10:34:00.362]                   name <- added[[kk]]
[10:34:00.362]                   NAME <- NAMES[[kk]]
[10:34:00.362]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:00.362]                     next
[10:34:00.362]                   args[[name]] <- ""
[10:34:00.362]                 }
[10:34:00.362]                 NAMES <- toupper(removed)
[10:34:00.362]                 for (kk in seq_along(NAMES)) {
[10:34:00.362]                   name <- removed[[kk]]
[10:34:00.362]                   NAME <- NAMES[[kk]]
[10:34:00.362]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:00.362]                     next
[10:34:00.362]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:00.362]                 }
[10:34:00.362]                 if (length(args) > 0) 
[10:34:00.362]                   base::do.call(base::Sys.setenv, args = args)
[10:34:00.362]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:00.362]             }
[10:34:00.362]             else {
[10:34:00.362]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:00.362]             }
[10:34:00.362]             {
[10:34:00.362]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:00.362]                   0L) {
[10:34:00.362]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:00.362]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:00.362]                   base::options(opts)
[10:34:00.362]                 }
[10:34:00.362]                 {
[10:34:00.362]                   {
[10:34:00.362]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:00.362]                     NULL
[10:34:00.362]                   }
[10:34:00.362]                   options(future.plan = NULL)
[10:34:00.362]                   if (is.na(NA_character_)) 
[10:34:00.362]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:00.362]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:00.362]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:00.362]                     .init = FALSE)
[10:34:00.362]                 }
[10:34:00.362]             }
[10:34:00.362]         }
[10:34:00.362]     })
[10:34:00.362]     if (TRUE) {
[10:34:00.362]         base::sink(type = "output", split = FALSE)
[10:34:00.362]         if (TRUE) {
[10:34:00.362]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:00.362]         }
[10:34:00.362]         else {
[10:34:00.362]             ...future.result["stdout"] <- base::list(NULL)
[10:34:00.362]         }
[10:34:00.362]         base::close(...future.stdout)
[10:34:00.362]         ...future.stdout <- NULL
[10:34:00.362]     }
[10:34:00.362]     ...future.result$conditions <- ...future.conditions
[10:34:00.362]     ...future.result$finished <- base::Sys.time()
[10:34:00.362]     ...future.result
[10:34:00.362] }
[10:34:00.365] assign_globals() ...
[10:34:00.366] List of 1
[10:34:00.366]  $ kk: int 2
[10:34:00.366]  - attr(*, "where")=List of 1
[10:34:00.366]   ..$ kk:<environment: R_EmptyEnv> 
[10:34:00.366]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:34:00.366]  - attr(*, "resolved")= logi FALSE
[10:34:00.366]  - attr(*, "total_size")= num 56
[10:34:00.366]  - attr(*, "already-done")= logi TRUE
[10:34:00.370] - copied ‘kk’ to environment
[10:34:00.370] assign_globals() ... done
[10:34:00.370] requestCore(): workers = 2
[10:34:00.370] Poll #1 (0): usedCores() = 2, workers = 2
[10:34:00.381] result() for MulticoreFuture ...
[10:34:00.382] result() for MulticoreFuture ...
[10:34:00.382] result() for MulticoreFuture ... done
[10:34:00.382] result() for MulticoreFuture ... done
[10:34:00.382] result() for MulticoreFuture ...
[10:34:00.382] result() for MulticoreFuture ... done
[10:34:00.385] MulticoreFuture started
[10:34:00.385] - Launch lazy future ... done
[10:34:00.386] run() for ‘MulticoreFuture’ ... done
[10:34:00.386] getGlobalsAndPackages() ...
[10:34:00.386] Searching for globals...
[10:34:00.386] plan(): Setting new future strategy stack:
[10:34:00.387] List of future strategies:
[10:34:00.387] 1. sequential:
[10:34:00.387]    - args: function (..., envir = parent.frame())
[10:34:00.387]    - tweaked: FALSE
[10:34:00.387]    - call: NULL
[10:34:00.388] plan(): nbrOfWorkers() = 1
[10:34:00.390] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:34:00.390] Searching for globals ... DONE
[10:34:00.390] Resolving globals: FALSE
[10:34:00.391] The total size of the 1 globals is 56 bytes (56 bytes)
[10:34:00.392] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:34:00.392] - globals: [1] ‘kk’
[10:34:00.397] 
[10:34:00.397] getGlobalsAndPackages() ... DONE
[10:34:00.398] run() for ‘Future’ ...
[10:34:00.398] - state: ‘created’
[10:34:00.399] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:34:00.405] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:00.406] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:34:00.406]   - Field: ‘label’
[10:34:00.406]   - Field: ‘local’
[10:34:00.406]   - Field: ‘owner’
[10:34:00.406]   - Field: ‘envir’
[10:34:00.407]   - Field: ‘workers’
[10:34:00.407]   - Field: ‘packages’
[10:34:00.407]   - Field: ‘gc’
[10:34:00.407]   - Field: ‘job’
[10:34:00.407]   - Field: ‘conditions’
[10:34:00.407]   - Field: ‘expr’
[10:34:00.408]   - Field: ‘uuid’
[10:34:00.408]   - Field: ‘seed’
[10:34:00.408]   - Field: ‘version’
[10:34:00.408]   - Field: ‘result’
[10:34:00.408]   - Field: ‘asynchronous’
[10:34:00.409]   - Field: ‘calls’
[10:34:00.409]   - Field: ‘globals’
[10:34:00.409]   - Field: ‘stdout’
[10:34:00.409]   - Field: ‘earlySignal’
[10:34:00.409]   - Field: ‘lazy’
[10:34:00.409]   - Field: ‘state’
[10:34:00.410] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:34:00.410] - Launch lazy future ...
[10:34:00.410] Packages needed by the future expression (n = 0): <none>
[10:34:00.411] Packages needed by future strategies (n = 0): <none>
[10:34:00.412] {
[10:34:00.412]     {
[10:34:00.412]         {
[10:34:00.412]             ...future.startTime <- base::Sys.time()
[10:34:00.412]             {
[10:34:00.412]                 {
[10:34:00.412]                   {
[10:34:00.412]                     {
[10:34:00.412]                       base::local({
[10:34:00.412]                         has_future <- base::requireNamespace("future", 
[10:34:00.412]                           quietly = TRUE)
[10:34:00.412]                         if (has_future) {
[10:34:00.412]                           ns <- base::getNamespace("future")
[10:34:00.412]                           version <- ns[[".package"]][["version"]]
[10:34:00.412]                           if (is.null(version)) 
[10:34:00.412]                             version <- utils::packageVersion("future")
[10:34:00.412]                         }
[10:34:00.412]                         else {
[10:34:00.412]                           version <- NULL
[10:34:00.412]                         }
[10:34:00.412]                         if (!has_future || version < "1.8.0") {
[10:34:00.412]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:00.412]                             "", base::R.version$version.string), 
[10:34:00.412]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:00.412]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:00.412]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:00.412]                               "release", "version")], collapse = " "), 
[10:34:00.412]                             hostname = base::Sys.info()[["nodename"]])
[10:34:00.412]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:00.412]                             info)
[10:34:00.412]                           info <- base::paste(info, collapse = "; ")
[10:34:00.412]                           if (!has_future) {
[10:34:00.412]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:00.412]                               info)
[10:34:00.412]                           }
[10:34:00.412]                           else {
[10:34:00.412]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:00.412]                               info, version)
[10:34:00.412]                           }
[10:34:00.412]                           base::stop(msg)
[10:34:00.412]                         }
[10:34:00.412]                       })
[10:34:00.412]                     }
[10:34:00.412]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:00.412]                     base::options(mc.cores = 1L)
[10:34:00.412]                   }
[10:34:00.412]                   ...future.strategy.old <- future::plan("list")
[10:34:00.412]                   options(future.plan = NULL)
[10:34:00.412]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:00.412]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:00.412]                 }
[10:34:00.412]                 ...future.workdir <- getwd()
[10:34:00.412]             }
[10:34:00.412]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:00.412]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:00.412]         }
[10:34:00.412]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:00.412]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:00.412]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:00.412]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:00.412]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:00.412]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:00.412]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:00.412]             base::names(...future.oldOptions))
[10:34:00.412]     }
[10:34:00.412]     if (FALSE) {
[10:34:00.412]     }
[10:34:00.412]     else {
[10:34:00.412]         if (TRUE) {
[10:34:00.412]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:00.412]                 open = "w")
[10:34:00.412]         }
[10:34:00.412]         else {
[10:34:00.412]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:00.412]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:00.412]         }
[10:34:00.412]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:00.412]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:00.412]             base::sink(type = "output", split = FALSE)
[10:34:00.412]             base::close(...future.stdout)
[10:34:00.412]         }, add = TRUE)
[10:34:00.412]     }
[10:34:00.412]     ...future.frame <- base::sys.nframe()
[10:34:00.412]     ...future.conditions <- base::list()
[10:34:00.412]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:00.412]     if (FALSE) {
[10:34:00.412]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:00.412]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:00.412]     }
[10:34:00.412]     ...future.result <- base::tryCatch({
[10:34:00.412]         base::withCallingHandlers({
[10:34:00.412]             ...future.value <- base::withVisible(base::local({
[10:34:00.412]                 withCallingHandlers({
[10:34:00.412]                   {
[10:34:00.412]                     Sys.sleep(0.1)
[10:34:00.412]                     kk
[10:34:00.412]                   }
[10:34:00.412]                 }, immediateCondition = function(cond) {
[10:34:00.412]                   save_rds <- function (object, pathname, ...) 
[10:34:00.412]                   {
[10:34:00.412]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:34:00.412]                     if (file_test("-f", pathname_tmp)) {
[10:34:00.412]                       fi_tmp <- file.info(pathname_tmp)
[10:34:00.412]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:34:00.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:00.412]                         fi_tmp[["mtime"]])
[10:34:00.412]                     }
[10:34:00.412]                     tryCatch({
[10:34:00.412]                       saveRDS(object, file = pathname_tmp, ...)
[10:34:00.412]                     }, error = function(ex) {
[10:34:00.412]                       msg <- conditionMessage(ex)
[10:34:00.412]                       fi_tmp <- file.info(pathname_tmp)
[10:34:00.412]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:34:00.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:00.412]                         fi_tmp[["mtime"]], msg)
[10:34:00.412]                       ex$message <- msg
[10:34:00.412]                       stop(ex)
[10:34:00.412]                     })
[10:34:00.412]                     stopifnot(file_test("-f", pathname_tmp))
[10:34:00.412]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:34:00.412]                     if (!res || file_test("-f", pathname_tmp)) {
[10:34:00.412]                       fi_tmp <- file.info(pathname_tmp)
[10:34:00.412]                       fi <- file.info(pathname)
[10:34:00.412]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:34:00.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:00.412]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:34:00.412]                         fi[["size"]], fi[["mtime"]])
[10:34:00.412]                       stop(msg)
[10:34:00.412]                     }
[10:34:00.412]                     invisible(pathname)
[10:34:00.412]                   }
[10:34:00.412]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:34:00.412]                     rootPath = tempdir()) 
[10:34:00.412]                   {
[10:34:00.412]                     obj <- list(time = Sys.time(), condition = cond)
[10:34:00.412]                     file <- tempfile(pattern = class(cond)[1], 
[10:34:00.412]                       tmpdir = path, fileext = ".rds")
[10:34:00.412]                     save_rds(obj, file)
[10:34:00.412]                   }
[10:34:00.412]                   saveImmediateCondition(cond, path = "/tmp/RtmpuZEzLw/.future/immediateConditions")
[10:34:00.412]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:00.412]                   {
[10:34:00.412]                     inherits <- base::inherits
[10:34:00.412]                     invokeRestart <- base::invokeRestart
[10:34:00.412]                     is.null <- base::is.null
[10:34:00.412]                     muffled <- FALSE
[10:34:00.412]                     if (inherits(cond, "message")) {
[10:34:00.412]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:00.412]                       if (muffled) 
[10:34:00.412]                         invokeRestart("muffleMessage")
[10:34:00.412]                     }
[10:34:00.412]                     else if (inherits(cond, "warning")) {
[10:34:00.412]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:00.412]                       if (muffled) 
[10:34:00.412]                         invokeRestart("muffleWarning")
[10:34:00.412]                     }
[10:34:00.412]                     else if (inherits(cond, "condition")) {
[10:34:00.412]                       if (!is.null(pattern)) {
[10:34:00.412]                         computeRestarts <- base::computeRestarts
[10:34:00.412]                         grepl <- base::grepl
[10:34:00.412]                         restarts <- computeRestarts(cond)
[10:34:00.412]                         for (restart in restarts) {
[10:34:00.412]                           name <- restart$name
[10:34:00.412]                           if (is.null(name)) 
[10:34:00.412]                             next
[10:34:00.412]                           if (!grepl(pattern, name)) 
[10:34:00.412]                             next
[10:34:00.412]                           invokeRestart(restart)
[10:34:00.412]                           muffled <- TRUE
[10:34:00.412]                           break
[10:34:00.412]                         }
[10:34:00.412]                       }
[10:34:00.412]                     }
[10:34:00.412]                     invisible(muffled)
[10:34:00.412]                   }
[10:34:00.412]                   muffleCondition(cond)
[10:34:00.412]                 })
[10:34:00.412]             }))
[10:34:00.412]             future::FutureResult(value = ...future.value$value, 
[10:34:00.412]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:00.412]                   ...future.rng), globalenv = if (FALSE) 
[10:34:00.412]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:00.412]                     ...future.globalenv.names))
[10:34:00.412]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:00.412]         }, condition = base::local({
[10:34:00.412]             c <- base::c
[10:34:00.412]             inherits <- base::inherits
[10:34:00.412]             invokeRestart <- base::invokeRestart
[10:34:00.412]             length <- base::length
[10:34:00.412]             list <- base::list
[10:34:00.412]             seq.int <- base::seq.int
[10:34:00.412]             signalCondition <- base::signalCondition
[10:34:00.412]             sys.calls <- base::sys.calls
[10:34:00.412]             `[[` <- base::`[[`
[10:34:00.412]             `+` <- base::`+`
[10:34:00.412]             `<<-` <- base::`<<-`
[10:34:00.412]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:00.412]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:00.412]                   3L)]
[10:34:00.412]             }
[10:34:00.412]             function(cond) {
[10:34:00.412]                 is_error <- inherits(cond, "error")
[10:34:00.412]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:00.412]                   NULL)
[10:34:00.412]                 if (is_error) {
[10:34:00.412]                   sessionInformation <- function() {
[10:34:00.412]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:00.412]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:00.412]                       search = base::search(), system = base::Sys.info())
[10:34:00.412]                   }
[10:34:00.412]                   ...future.conditions[[length(...future.conditions) + 
[10:34:00.412]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:00.412]                     cond$call), session = sessionInformation(), 
[10:34:00.412]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:00.412]                   signalCondition(cond)
[10:34:00.412]                 }
[10:34:00.412]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:00.412]                 "immediateCondition"))) {
[10:34:00.412]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:00.412]                   ...future.conditions[[length(...future.conditions) + 
[10:34:00.412]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:00.412]                   if (TRUE && !signal) {
[10:34:00.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:00.412]                     {
[10:34:00.412]                       inherits <- base::inherits
[10:34:00.412]                       invokeRestart <- base::invokeRestart
[10:34:00.412]                       is.null <- base::is.null
[10:34:00.412]                       muffled <- FALSE
[10:34:00.412]                       if (inherits(cond, "message")) {
[10:34:00.412]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:00.412]                         if (muffled) 
[10:34:00.412]                           invokeRestart("muffleMessage")
[10:34:00.412]                       }
[10:34:00.412]                       else if (inherits(cond, "warning")) {
[10:34:00.412]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:00.412]                         if (muffled) 
[10:34:00.412]                           invokeRestart("muffleWarning")
[10:34:00.412]                       }
[10:34:00.412]                       else if (inherits(cond, "condition")) {
[10:34:00.412]                         if (!is.null(pattern)) {
[10:34:00.412]                           computeRestarts <- base::computeRestarts
[10:34:00.412]                           grepl <- base::grepl
[10:34:00.412]                           restarts <- computeRestarts(cond)
[10:34:00.412]                           for (restart in restarts) {
[10:34:00.412]                             name <- restart$name
[10:34:00.412]                             if (is.null(name)) 
[10:34:00.412]                               next
[10:34:00.412]                             if (!grepl(pattern, name)) 
[10:34:00.412]                               next
[10:34:00.412]                             invokeRestart(restart)
[10:34:00.412]                             muffled <- TRUE
[10:34:00.412]                             break
[10:34:00.412]                           }
[10:34:00.412]                         }
[10:34:00.412]                       }
[10:34:00.412]                       invisible(muffled)
[10:34:00.412]                     }
[10:34:00.412]                     muffleCondition(cond, pattern = "^muffle")
[10:34:00.412]                   }
[10:34:00.412]                 }
[10:34:00.412]                 else {
[10:34:00.412]                   if (TRUE) {
[10:34:00.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:00.412]                     {
[10:34:00.412]                       inherits <- base::inherits
[10:34:00.412]                       invokeRestart <- base::invokeRestart
[10:34:00.412]                       is.null <- base::is.null
[10:34:00.412]                       muffled <- FALSE
[10:34:00.412]                       if (inherits(cond, "message")) {
[10:34:00.412]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:00.412]                         if (muffled) 
[10:34:00.412]                           invokeRestart("muffleMessage")
[10:34:00.412]                       }
[10:34:00.412]                       else if (inherits(cond, "warning")) {
[10:34:00.412]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:00.412]                         if (muffled) 
[10:34:00.412]                           invokeRestart("muffleWarning")
[10:34:00.412]                       }
[10:34:00.412]                       else if (inherits(cond, "condition")) {
[10:34:00.412]                         if (!is.null(pattern)) {
[10:34:00.412]                           computeRestarts <- base::computeRestarts
[10:34:00.412]                           grepl <- base::grepl
[10:34:00.412]                           restarts <- computeRestarts(cond)
[10:34:00.412]                           for (restart in restarts) {
[10:34:00.412]                             name <- restart$name
[10:34:00.412]                             if (is.null(name)) 
[10:34:00.412]                               next
[10:34:00.412]                             if (!grepl(pattern, name)) 
[10:34:00.412]                               next
[10:34:00.412]                             invokeRestart(restart)
[10:34:00.412]                             muffled <- TRUE
[10:34:00.412]                             break
[10:34:00.412]                           }
[10:34:00.412]                         }
[10:34:00.412]                       }
[10:34:00.412]                       invisible(muffled)
[10:34:00.412]                     }
[10:34:00.412]                     muffleCondition(cond, pattern = "^muffle")
[10:34:00.412]                   }
[10:34:00.412]                 }
[10:34:00.412]             }
[10:34:00.412]         }))
[10:34:00.412]     }, error = function(ex) {
[10:34:00.412]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:00.412]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:00.412]                 ...future.rng), started = ...future.startTime, 
[10:34:00.412]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:00.412]             version = "1.8"), class = "FutureResult")
[10:34:00.412]     }, finally = {
[10:34:00.412]         if (!identical(...future.workdir, getwd())) 
[10:34:00.412]             setwd(...future.workdir)
[10:34:00.412]         {
[10:34:00.412]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:00.412]                 ...future.oldOptions$nwarnings <- NULL
[10:34:00.412]             }
[10:34:00.412]             base::options(...future.oldOptions)
[10:34:00.412]             if (.Platform$OS.type == "windows") {
[10:34:00.412]                 old_names <- names(...future.oldEnvVars)
[10:34:00.412]                 envs <- base::Sys.getenv()
[10:34:00.412]                 names <- names(envs)
[10:34:00.412]                 common <- intersect(names, old_names)
[10:34:00.412]                 added <- setdiff(names, old_names)
[10:34:00.412]                 removed <- setdiff(old_names, names)
[10:34:00.412]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:00.412]                   envs[common]]
[10:34:00.412]                 NAMES <- toupper(changed)
[10:34:00.412]                 args <- list()
[10:34:00.412]                 for (kk in seq_along(NAMES)) {
[10:34:00.412]                   name <- changed[[kk]]
[10:34:00.412]                   NAME <- NAMES[[kk]]
[10:34:00.412]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:00.412]                     next
[10:34:00.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:00.412]                 }
[10:34:00.412]                 NAMES <- toupper(added)
[10:34:00.412]                 for (kk in seq_along(NAMES)) {
[10:34:00.412]                   name <- added[[kk]]
[10:34:00.412]                   NAME <- NAMES[[kk]]
[10:34:00.412]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:00.412]                     next
[10:34:00.412]                   args[[name]] <- ""
[10:34:00.412]                 }
[10:34:00.412]                 NAMES <- toupper(removed)
[10:34:00.412]                 for (kk in seq_along(NAMES)) {
[10:34:00.412]                   name <- removed[[kk]]
[10:34:00.412]                   NAME <- NAMES[[kk]]
[10:34:00.412]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:00.412]                     next
[10:34:00.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:00.412]                 }
[10:34:00.412]                 if (length(args) > 0) 
[10:34:00.412]                   base::do.call(base::Sys.setenv, args = args)
[10:34:00.412]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:00.412]             }
[10:34:00.412]             else {
[10:34:00.412]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:00.412]             }
[10:34:00.412]             {
[10:34:00.412]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:00.412]                   0L) {
[10:34:00.412]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:00.412]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:00.412]                   base::options(opts)
[10:34:00.412]                 }
[10:34:00.412]                 {
[10:34:00.412]                   {
[10:34:00.412]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:00.412]                     NULL
[10:34:00.412]                   }
[10:34:00.412]                   options(future.plan = NULL)
[10:34:00.412]                   if (is.na(NA_character_)) 
[10:34:00.412]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:00.412]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:00.412]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:00.412]                     .init = FALSE)
[10:34:00.412]                 }
[10:34:00.412]             }
[10:34:00.412]         }
[10:34:00.412]     })
[10:34:00.412]     if (TRUE) {
[10:34:00.412]         base::sink(type = "output", split = FALSE)
[10:34:00.412]         if (TRUE) {
[10:34:00.412]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:00.412]         }
[10:34:00.412]         else {
[10:34:00.412]             ...future.result["stdout"] <- base::list(NULL)
[10:34:00.412]         }
[10:34:00.412]         base::close(...future.stdout)
[10:34:00.412]         ...future.stdout <- NULL
[10:34:00.412]     }
[10:34:00.412]     ...future.result$conditions <- ...future.conditions
[10:34:00.412]     ...future.result$finished <- base::Sys.time()
[10:34:00.412]     ...future.result
[10:34:00.412] }
[10:34:00.414] assign_globals() ...
[10:34:00.414] List of 1
[10:34:00.414]  $ kk: int 3
[10:34:00.414]  - attr(*, "where")=List of 1
[10:34:00.414]   ..$ kk:<environment: R_EmptyEnv> 
[10:34:00.414]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:34:00.414]  - attr(*, "resolved")= logi FALSE
[10:34:00.414]  - attr(*, "total_size")= num 56
[10:34:00.414]  - attr(*, "already-done")= logi TRUE
[10:34:00.418] - copied ‘kk’ to environment
[10:34:00.418] assign_globals() ... done
[10:34:00.418] requestCore(): workers = 2
[10:34:00.419] Poll #1 (0): usedCores() = 2, workers = 2
[10:34:00.449] plan(): Setting new future strategy stack:
[10:34:00.450] List of future strategies:
[10:34:00.450] 1. multicore:
[10:34:00.450]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:34:00.450]    - tweaked: FALSE
[10:34:00.450]    - call: plan(strategy)
[10:34:00.450] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[10:34:00.454] plan(): nbrOfWorkers() = 2
[10:34:00.461] result() for MulticoreFuture ...
[10:34:00.462] result() for MulticoreFuture ...
[10:34:00.462] result() for MulticoreFuture ... done
[10:34:00.462] result() for MulticoreFuture ... done
[10:34:00.462] result() for MulticoreFuture ...
[10:34:00.462] result() for MulticoreFuture ... done
[10:34:00.465] MulticoreFuture started
[10:34:00.465] - Launch lazy future ... done
[10:34:00.466] run() for ‘MulticoreFuture’ ... done
[10:34:00.466] resolve() on list ...
[10:34:00.466]  recursive: 0
[10:34:00.466] plan(): Setting new future strategy stack:
[10:34:00.466]  length: 3
[10:34:00.467] 
[10:34:00.467] Future #1
[10:34:00.467]  length: 2 (resolved future 1)
[10:34:00.466] List of future strategies:
[10:34:00.466] 1. sequential:
[10:34:00.466]    - args: function (..., envir = parent.frame())
[10:34:00.466]    - tweaked: FALSE
[10:34:00.466]    - call: NULL
[10:34:00.467] plan(): nbrOfWorkers() = 1
[10:34:00.491] plan(): Setting new future strategy stack:
[10:34:00.491] List of future strategies:
[10:34:00.491] 1. multicore:
[10:34:00.491]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:34:00.491]    - tweaked: FALSE
[10:34:00.491]    - call: plan(strategy)
[10:34:00.495] plan(): nbrOfWorkers() = 2
[10:34:00.499] Future #2
[10:34:00.499]  length: 1 (resolved future 2)
[10:34:00.570] plan(): Setting new future strategy stack:
[10:34:00.570] List of future strategies:
[10:34:00.570] 1. multicore:
[10:34:00.570]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:34:00.570]    - tweaked: FALSE
[10:34:00.570]    - call: plan(strategy)
[10:34:00.575] plan(): nbrOfWorkers() = 2
[10:34:00.581] Future #3
[10:34:00.581]  length: 0 (resolved future 3)
[10:34:00.582] resolve() on list ... DONE
[10:34:00.582] getGlobalsAndPackages() ...
[10:34:00.582] Searching for globals...
[10:34:00.584] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:34:00.584] Searching for globals ... DONE
[10:34:00.584] Resolving globals: FALSE
[10:34:00.585] The total size of the 1 globals is 56 bytes (56 bytes)
[10:34:00.586] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:34:00.586] - globals: [1] ‘kk’
[10:34:00.586] 
[10:34:00.586] getGlobalsAndPackages() ... DONE
[10:34:00.587] getGlobalsAndPackages() ...
[10:34:00.587] Searching for globals...
[10:34:00.588] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:34:00.589] Searching for globals ... DONE
[10:34:00.589] Resolving globals: FALSE
[10:34:00.589] The total size of the 1 globals is 56 bytes (56 bytes)
[10:34:00.590] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:34:00.590] - globals: [1] ‘kk’
[10:34:00.590] 
[10:34:00.590] getGlobalsAndPackages() ... DONE
[10:34:00.591] getGlobalsAndPackages() ...
[10:34:00.591] Searching for globals...
[10:34:00.592] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:34:00.592] Searching for globals ... DONE
[10:34:00.593] Resolving globals: FALSE
[10:34:00.593] The total size of the 1 globals is 56 bytes (56 bytes)
[10:34:00.594] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:34:00.594] - globals: [1] ‘kk’
[10:34:00.594] 
[10:34:00.594] getGlobalsAndPackages() ... DONE
[10:34:00.594] resolve() on list ...
[10:34:00.595]  recursive: 0
[10:34:00.595]  length: 3
[10:34:00.595] 
[10:34:00.595] run() for ‘Future’ ...
[10:34:00.595] - state: ‘created’
[10:34:00.595] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:34:00.600] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:00.600] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:34:00.600]   - Field: ‘label’
[10:34:00.601]   - Field: ‘local’
[10:34:00.601]   - Field: ‘owner’
[10:34:00.601]   - Field: ‘envir’
[10:34:00.601]   - Field: ‘workers’
[10:34:00.601]   - Field: ‘packages’
[10:34:00.601]   - Field: ‘gc’
[10:34:00.602]   - Field: ‘job’
[10:34:00.602]   - Field: ‘conditions’
[10:34:00.605]   - Field: ‘expr’
[10:34:00.606]   - Field: ‘uuid’
[10:34:00.606]   - Field: ‘seed’
[10:34:00.606]   - Field: ‘version’
[10:34:00.606]   - Field: ‘result’
[10:34:00.607]   - Field: ‘asynchronous’
[10:34:00.607]   - Field: ‘calls’
[10:34:00.607]   - Field: ‘globals’
[10:34:00.607]   - Field: ‘stdout’
[10:34:00.608]   - Field: ‘earlySignal’
[10:34:00.608]   - Field: ‘lazy’
[10:34:00.608]   - Field: ‘state’
[10:34:00.608] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:34:00.609] - Launch lazy future ...
[10:34:00.609] Packages needed by the future expression (n = 0): <none>
[10:34:00.609] Packages needed by future strategies (n = 0): <none>
[10:34:00.610] {
[10:34:00.610]     {
[10:34:00.610]         {
[10:34:00.610]             ...future.startTime <- base::Sys.time()
[10:34:00.610]             {
[10:34:00.610]                 {
[10:34:00.610]                   {
[10:34:00.610]                     {
[10:34:00.610]                       base::local({
[10:34:00.610]                         has_future <- base::requireNamespace("future", 
[10:34:00.610]                           quietly = TRUE)
[10:34:00.610]                         if (has_future) {
[10:34:00.610]                           ns <- base::getNamespace("future")
[10:34:00.610]                           version <- ns[[".package"]][["version"]]
[10:34:00.610]                           if (is.null(version)) 
[10:34:00.610]                             version <- utils::packageVersion("future")
[10:34:00.610]                         }
[10:34:00.610]                         else {
[10:34:00.610]                           version <- NULL
[10:34:00.610]                         }
[10:34:00.610]                         if (!has_future || version < "1.8.0") {
[10:34:00.610]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:00.610]                             "", base::R.version$version.string), 
[10:34:00.610]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:00.610]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:00.610]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:00.610]                               "release", "version")], collapse = " "), 
[10:34:00.610]                             hostname = base::Sys.info()[["nodename"]])
[10:34:00.610]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:00.610]                             info)
[10:34:00.610]                           info <- base::paste(info, collapse = "; ")
[10:34:00.610]                           if (!has_future) {
[10:34:00.610]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:00.610]                               info)
[10:34:00.610]                           }
[10:34:00.610]                           else {
[10:34:00.610]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:00.610]                               info, version)
[10:34:00.610]                           }
[10:34:00.610]                           base::stop(msg)
[10:34:00.610]                         }
[10:34:00.610]                       })
[10:34:00.610]                     }
[10:34:00.610]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:00.610]                     base::options(mc.cores = 1L)
[10:34:00.610]                   }
[10:34:00.610]                   ...future.strategy.old <- future::plan("list")
[10:34:00.610]                   options(future.plan = NULL)
[10:34:00.610]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:00.610]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:00.610]                 }
[10:34:00.610]                 ...future.workdir <- getwd()
[10:34:00.610]             }
[10:34:00.610]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:00.610]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:00.610]         }
[10:34:00.610]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:00.610]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:00.610]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:00.610]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:00.610]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:00.610]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:00.610]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:00.610]             base::names(...future.oldOptions))
[10:34:00.610]     }
[10:34:00.610]     if (FALSE) {
[10:34:00.610]     }
[10:34:00.610]     else {
[10:34:00.610]         if (TRUE) {
[10:34:00.610]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:00.610]                 open = "w")
[10:34:00.610]         }
[10:34:00.610]         else {
[10:34:00.610]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:00.610]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:00.610]         }
[10:34:00.610]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:00.610]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:00.610]             base::sink(type = "output", split = FALSE)
[10:34:00.610]             base::close(...future.stdout)
[10:34:00.610]         }, add = TRUE)
[10:34:00.610]     }
[10:34:00.610]     ...future.frame <- base::sys.nframe()
[10:34:00.610]     ...future.conditions <- base::list()
[10:34:00.610]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:00.610]     if (FALSE) {
[10:34:00.610]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:00.610]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:00.610]     }
[10:34:00.610]     ...future.result <- base::tryCatch({
[10:34:00.610]         base::withCallingHandlers({
[10:34:00.610]             ...future.value <- base::withVisible(base::local({
[10:34:00.610]                 withCallingHandlers({
[10:34:00.610]                   {
[10:34:00.610]                     Sys.sleep(0.1)
[10:34:00.610]                     kk
[10:34:00.610]                   }
[10:34:00.610]                 }, immediateCondition = function(cond) {
[10:34:00.610]                   save_rds <- function (object, pathname, ...) 
[10:34:00.610]                   {
[10:34:00.610]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:34:00.610]                     if (file_test("-f", pathname_tmp)) {
[10:34:00.610]                       fi_tmp <- file.info(pathname_tmp)
[10:34:00.610]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:34:00.610]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:00.610]                         fi_tmp[["mtime"]])
[10:34:00.610]                     }
[10:34:00.610]                     tryCatch({
[10:34:00.610]                       saveRDS(object, file = pathname_tmp, ...)
[10:34:00.610]                     }, error = function(ex) {
[10:34:00.610]                       msg <- conditionMessage(ex)
[10:34:00.610]                       fi_tmp <- file.info(pathname_tmp)
[10:34:00.610]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:34:00.610]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:00.610]                         fi_tmp[["mtime"]], msg)
[10:34:00.610]                       ex$message <- msg
[10:34:00.610]                       stop(ex)
[10:34:00.610]                     })
[10:34:00.610]                     stopifnot(file_test("-f", pathname_tmp))
[10:34:00.610]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:34:00.610]                     if (!res || file_test("-f", pathname_tmp)) {
[10:34:00.610]                       fi_tmp <- file.info(pathname_tmp)
[10:34:00.610]                       fi <- file.info(pathname)
[10:34:00.610]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:34:00.610]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:00.610]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:34:00.610]                         fi[["size"]], fi[["mtime"]])
[10:34:00.610]                       stop(msg)
[10:34:00.610]                     }
[10:34:00.610]                     invisible(pathname)
[10:34:00.610]                   }
[10:34:00.610]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:34:00.610]                     rootPath = tempdir()) 
[10:34:00.610]                   {
[10:34:00.610]                     obj <- list(time = Sys.time(), condition = cond)
[10:34:00.610]                     file <- tempfile(pattern = class(cond)[1], 
[10:34:00.610]                       tmpdir = path, fileext = ".rds")
[10:34:00.610]                     save_rds(obj, file)
[10:34:00.610]                   }
[10:34:00.610]                   saveImmediateCondition(cond, path = "/tmp/RtmpuZEzLw/.future/immediateConditions")
[10:34:00.610]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:00.610]                   {
[10:34:00.610]                     inherits <- base::inherits
[10:34:00.610]                     invokeRestart <- base::invokeRestart
[10:34:00.610]                     is.null <- base::is.null
[10:34:00.610]                     muffled <- FALSE
[10:34:00.610]                     if (inherits(cond, "message")) {
[10:34:00.610]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:00.610]                       if (muffled) 
[10:34:00.610]                         invokeRestart("muffleMessage")
[10:34:00.610]                     }
[10:34:00.610]                     else if (inherits(cond, "warning")) {
[10:34:00.610]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:00.610]                       if (muffled) 
[10:34:00.610]                         invokeRestart("muffleWarning")
[10:34:00.610]                     }
[10:34:00.610]                     else if (inherits(cond, "condition")) {
[10:34:00.610]                       if (!is.null(pattern)) {
[10:34:00.610]                         computeRestarts <- base::computeRestarts
[10:34:00.610]                         grepl <- base::grepl
[10:34:00.610]                         restarts <- computeRestarts(cond)
[10:34:00.610]                         for (restart in restarts) {
[10:34:00.610]                           name <- restart$name
[10:34:00.610]                           if (is.null(name)) 
[10:34:00.610]                             next
[10:34:00.610]                           if (!grepl(pattern, name)) 
[10:34:00.610]                             next
[10:34:00.610]                           invokeRestart(restart)
[10:34:00.610]                           muffled <- TRUE
[10:34:00.610]                           break
[10:34:00.610]                         }
[10:34:00.610]                       }
[10:34:00.610]                     }
[10:34:00.610]                     invisible(muffled)
[10:34:00.610]                   }
[10:34:00.610]                   muffleCondition(cond)
[10:34:00.610]                 })
[10:34:00.610]             }))
[10:34:00.610]             future::FutureResult(value = ...future.value$value, 
[10:34:00.610]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:00.610]                   ...future.rng), globalenv = if (FALSE) 
[10:34:00.610]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:00.610]                     ...future.globalenv.names))
[10:34:00.610]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:00.610]         }, condition = base::local({
[10:34:00.610]             c <- base::c
[10:34:00.610]             inherits <- base::inherits
[10:34:00.610]             invokeRestart <- base::invokeRestart
[10:34:00.610]             length <- base::length
[10:34:00.610]             list <- base::list
[10:34:00.610]             seq.int <- base::seq.int
[10:34:00.610]             signalCondition <- base::signalCondition
[10:34:00.610]             sys.calls <- base::sys.calls
[10:34:00.610]             `[[` <- base::`[[`
[10:34:00.610]             `+` <- base::`+`
[10:34:00.610]             `<<-` <- base::`<<-`
[10:34:00.610]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:00.610]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:00.610]                   3L)]
[10:34:00.610]             }
[10:34:00.610]             function(cond) {
[10:34:00.610]                 is_error <- inherits(cond, "error")
[10:34:00.610]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:00.610]                   NULL)
[10:34:00.610]                 if (is_error) {
[10:34:00.610]                   sessionInformation <- function() {
[10:34:00.610]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:00.610]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:00.610]                       search = base::search(), system = base::Sys.info())
[10:34:00.610]                   }
[10:34:00.610]                   ...future.conditions[[length(...future.conditions) + 
[10:34:00.610]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:00.610]                     cond$call), session = sessionInformation(), 
[10:34:00.610]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:00.610]                   signalCondition(cond)
[10:34:00.610]                 }
[10:34:00.610]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:00.610]                 "immediateCondition"))) {
[10:34:00.610]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:00.610]                   ...future.conditions[[length(...future.conditions) + 
[10:34:00.610]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:00.610]                   if (TRUE && !signal) {
[10:34:00.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:00.610]                     {
[10:34:00.610]                       inherits <- base::inherits
[10:34:00.610]                       invokeRestart <- base::invokeRestart
[10:34:00.610]                       is.null <- base::is.null
[10:34:00.610]                       muffled <- FALSE
[10:34:00.610]                       if (inherits(cond, "message")) {
[10:34:00.610]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:00.610]                         if (muffled) 
[10:34:00.610]                           invokeRestart("muffleMessage")
[10:34:00.610]                       }
[10:34:00.610]                       else if (inherits(cond, "warning")) {
[10:34:00.610]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:00.610]                         if (muffled) 
[10:34:00.610]                           invokeRestart("muffleWarning")
[10:34:00.610]                       }
[10:34:00.610]                       else if (inherits(cond, "condition")) {
[10:34:00.610]                         if (!is.null(pattern)) {
[10:34:00.610]                           computeRestarts <- base::computeRestarts
[10:34:00.610]                           grepl <- base::grepl
[10:34:00.610]                           restarts <- computeRestarts(cond)
[10:34:00.610]                           for (restart in restarts) {
[10:34:00.610]                             name <- restart$name
[10:34:00.610]                             if (is.null(name)) 
[10:34:00.610]                               next
[10:34:00.610]                             if (!grepl(pattern, name)) 
[10:34:00.610]                               next
[10:34:00.610]                             invokeRestart(restart)
[10:34:00.610]                             muffled <- TRUE
[10:34:00.610]                             break
[10:34:00.610]                           }
[10:34:00.610]                         }
[10:34:00.610]                       }
[10:34:00.610]                       invisible(muffled)
[10:34:00.610]                     }
[10:34:00.610]                     muffleCondition(cond, pattern = "^muffle")
[10:34:00.610]                   }
[10:34:00.610]                 }
[10:34:00.610]                 else {
[10:34:00.610]                   if (TRUE) {
[10:34:00.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:00.610]                     {
[10:34:00.610]                       inherits <- base::inherits
[10:34:00.610]                       invokeRestart <- base::invokeRestart
[10:34:00.610]                       is.null <- base::is.null
[10:34:00.610]                       muffled <- FALSE
[10:34:00.610]                       if (inherits(cond, "message")) {
[10:34:00.610]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:00.610]                         if (muffled) 
[10:34:00.610]                           invokeRestart("muffleMessage")
[10:34:00.610]                       }
[10:34:00.610]                       else if (inherits(cond, "warning")) {
[10:34:00.610]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:00.610]                         if (muffled) 
[10:34:00.610]                           invokeRestart("muffleWarning")
[10:34:00.610]                       }
[10:34:00.610]                       else if (inherits(cond, "condition")) {
[10:34:00.610]                         if (!is.null(pattern)) {
[10:34:00.610]                           computeRestarts <- base::computeRestarts
[10:34:00.610]                           grepl <- base::grepl
[10:34:00.610]                           restarts <- computeRestarts(cond)
[10:34:00.610]                           for (restart in restarts) {
[10:34:00.610]                             name <- restart$name
[10:34:00.610]                             if (is.null(name)) 
[10:34:00.610]                               next
[10:34:00.610]                             if (!grepl(pattern, name)) 
[10:34:00.610]                               next
[10:34:00.610]                             invokeRestart(restart)
[10:34:00.610]                             muffled <- TRUE
[10:34:00.610]                             break
[10:34:00.610]                           }
[10:34:00.610]                         }
[10:34:00.610]                       }
[10:34:00.610]                       invisible(muffled)
[10:34:00.610]                     }
[10:34:00.610]                     muffleCondition(cond, pattern = "^muffle")
[10:34:00.610]                   }
[10:34:00.610]                 }
[10:34:00.610]             }
[10:34:00.610]         }))
[10:34:00.610]     }, error = function(ex) {
[10:34:00.610]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:00.610]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:00.610]                 ...future.rng), started = ...future.startTime, 
[10:34:00.610]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:00.610]             version = "1.8"), class = "FutureResult")
[10:34:00.610]     }, finally = {
[10:34:00.610]         if (!identical(...future.workdir, getwd())) 
[10:34:00.610]             setwd(...future.workdir)
[10:34:00.610]         {
[10:34:00.610]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:00.610]                 ...future.oldOptions$nwarnings <- NULL
[10:34:00.610]             }
[10:34:00.610]             base::options(...future.oldOptions)
[10:34:00.610]             if (.Platform$OS.type == "windows") {
[10:34:00.610]                 old_names <- names(...future.oldEnvVars)
[10:34:00.610]                 envs <- base::Sys.getenv()
[10:34:00.610]                 names <- names(envs)
[10:34:00.610]                 common <- intersect(names, old_names)
[10:34:00.610]                 added <- setdiff(names, old_names)
[10:34:00.610]                 removed <- setdiff(old_names, names)
[10:34:00.610]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:00.610]                   envs[common]]
[10:34:00.610]                 NAMES <- toupper(changed)
[10:34:00.610]                 args <- list()
[10:34:00.610]                 for (kk in seq_along(NAMES)) {
[10:34:00.610]                   name <- changed[[kk]]
[10:34:00.610]                   NAME <- NAMES[[kk]]
[10:34:00.610]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:00.610]                     next
[10:34:00.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:00.610]                 }
[10:34:00.610]                 NAMES <- toupper(added)
[10:34:00.610]                 for (kk in seq_along(NAMES)) {
[10:34:00.610]                   name <- added[[kk]]
[10:34:00.610]                   NAME <- NAMES[[kk]]
[10:34:00.610]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:00.610]                     next
[10:34:00.610]                   args[[name]] <- ""
[10:34:00.610]                 }
[10:34:00.610]                 NAMES <- toupper(removed)
[10:34:00.610]                 for (kk in seq_along(NAMES)) {
[10:34:00.610]                   name <- removed[[kk]]
[10:34:00.610]                   NAME <- NAMES[[kk]]
[10:34:00.610]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:00.610]                     next
[10:34:00.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:00.610]                 }
[10:34:00.610]                 if (length(args) > 0) 
[10:34:00.610]                   base::do.call(base::Sys.setenv, args = args)
[10:34:00.610]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:00.610]             }
[10:34:00.610]             else {
[10:34:00.610]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:00.610]             }
[10:34:00.610]             {
[10:34:00.610]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:00.610]                   0L) {
[10:34:00.610]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:00.610]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:00.610]                   base::options(opts)
[10:34:00.610]                 }
[10:34:00.610]                 {
[10:34:00.610]                   {
[10:34:00.610]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:00.610]                     NULL
[10:34:00.610]                   }
[10:34:00.610]                   options(future.plan = NULL)
[10:34:00.610]                   if (is.na(NA_character_)) 
[10:34:00.610]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:00.610]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:00.610]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:00.610]                     .init = FALSE)
[10:34:00.610]                 }
[10:34:00.610]             }
[10:34:00.610]         }
[10:34:00.610]     })
[10:34:00.610]     if (TRUE) {
[10:34:00.610]         base::sink(type = "output", split = FALSE)
[10:34:00.610]         if (TRUE) {
[10:34:00.610]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:00.610]         }
[10:34:00.610]         else {
[10:34:00.610]             ...future.result["stdout"] <- base::list(NULL)
[10:34:00.610]         }
[10:34:00.610]         base::close(...future.stdout)
[10:34:00.610]         ...future.stdout <- NULL
[10:34:00.610]     }
[10:34:00.610]     ...future.result$conditions <- ...future.conditions
[10:34:00.610]     ...future.result$finished <- base::Sys.time()
[10:34:00.610]     ...future.result
[10:34:00.610] }
[10:34:00.613] assign_globals() ...
[10:34:00.613] List of 1
[10:34:00.613]  $ kk: int 1
[10:34:00.613]  - attr(*, "where")=List of 1
[10:34:00.613]   ..$ kk:<environment: R_EmptyEnv> 
[10:34:00.613]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:34:00.613]  - attr(*, "resolved")= logi FALSE
[10:34:00.613]  - attr(*, "total_size")= num 56
[10:34:00.613]  - attr(*, "already-done")= logi TRUE
[10:34:00.618] - copied ‘kk’ to environment
[10:34:00.618] assign_globals() ... done
[10:34:00.618] requestCore(): workers = 2
[10:34:00.619] Poll #1 (0): usedCores() = 2, workers = 2
[10:34:00.629] result() for MulticoreFuture ...
[10:34:00.630] result() for MulticoreFuture ...
[10:34:00.630] result() for MulticoreFuture ... done
[10:34:00.630] result() for MulticoreFuture ... done
[10:34:00.631] result() for MulticoreFuture ...
[10:34:00.631] result() for MulticoreFuture ... done
[10:34:00.634] MulticoreFuture started
[10:34:00.635] - Launch lazy future ... done
[10:34:00.635] run() for ‘MulticoreFuture’ ... done
[10:34:00.635] plan(): Setting new future strategy stack:
[10:34:00.635] List of future strategies:
[10:34:00.635] 1. sequential:
[10:34:00.635]    - args: function (..., envir = parent.frame())
[10:34:00.635]    - tweaked: FALSE
[10:34:00.635]    - call: NULL
[10:34:00.636] plan(): nbrOfWorkers() = 1
[10:34:00.646] run() for ‘Future’ ...
[10:34:00.646] - state: ‘created’
[10:34:00.646] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:34:00.652] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:00.652] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:34:00.652]   - Field: ‘label’
[10:34:00.652]   - Field: ‘local’
[10:34:00.652]   - Field: ‘owner’
[10:34:00.653]   - Field: ‘envir’
[10:34:00.653]   - Field: ‘workers’
[10:34:00.653]   - Field: ‘packages’
[10:34:00.653]   - Field: ‘gc’
[10:34:00.653]   - Field: ‘job’
[10:34:00.654]   - Field: ‘conditions’
[10:34:00.654]   - Field: ‘expr’
[10:34:00.654]   - Field: ‘uuid’
[10:34:00.654]   - Field: ‘seed’
[10:34:00.654]   - Field: ‘version’
[10:34:00.654]   - Field: ‘result’
[10:34:00.655]   - Field: ‘asynchronous’
[10:34:00.655]   - Field: ‘calls’
[10:34:00.655]   - Field: ‘globals’
[10:34:00.655]   - Field: ‘stdout’
[10:34:00.655]   - Field: ‘earlySignal’
[10:34:00.655]   - Field: ‘lazy’
[10:34:00.656]   - Field: ‘state’
[10:34:00.656] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:34:00.656] - Launch lazy future ...
[10:34:00.656] Packages needed by the future expression (n = 0): <none>
[10:34:00.657] Packages needed by future strategies (n = 0): <none>
[10:34:00.657] {
[10:34:00.657]     {
[10:34:00.657]         {
[10:34:00.657]             ...future.startTime <- base::Sys.time()
[10:34:00.657]             {
[10:34:00.657]                 {
[10:34:00.657]                   {
[10:34:00.657]                     {
[10:34:00.657]                       base::local({
[10:34:00.657]                         has_future <- base::requireNamespace("future", 
[10:34:00.657]                           quietly = TRUE)
[10:34:00.657]                         if (has_future) {
[10:34:00.657]                           ns <- base::getNamespace("future")
[10:34:00.657]                           version <- ns[[".package"]][["version"]]
[10:34:00.657]                           if (is.null(version)) 
[10:34:00.657]                             version <- utils::packageVersion("future")
[10:34:00.657]                         }
[10:34:00.657]                         else {
[10:34:00.657]                           version <- NULL
[10:34:00.657]                         }
[10:34:00.657]                         if (!has_future || version < "1.8.0") {
[10:34:00.657]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:00.657]                             "", base::R.version$version.string), 
[10:34:00.657]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:00.657]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:00.657]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:00.657]                               "release", "version")], collapse = " "), 
[10:34:00.657]                             hostname = base::Sys.info()[["nodename"]])
[10:34:00.657]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:00.657]                             info)
[10:34:00.657]                           info <- base::paste(info, collapse = "; ")
[10:34:00.657]                           if (!has_future) {
[10:34:00.657]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:00.657]                               info)
[10:34:00.657]                           }
[10:34:00.657]                           else {
[10:34:00.657]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:00.657]                               info, version)
[10:34:00.657]                           }
[10:34:00.657]                           base::stop(msg)
[10:34:00.657]                         }
[10:34:00.657]                       })
[10:34:00.657]                     }
[10:34:00.657]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:00.657]                     base::options(mc.cores = 1L)
[10:34:00.657]                   }
[10:34:00.657]                   ...future.strategy.old <- future::plan("list")
[10:34:00.657]                   options(future.plan = NULL)
[10:34:00.657]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:00.657]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:00.657]                 }
[10:34:00.657]                 ...future.workdir <- getwd()
[10:34:00.657]             }
[10:34:00.657]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:00.657]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:00.657]         }
[10:34:00.657]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:00.657]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:00.657]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:00.657]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:00.657]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:00.657]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:00.657]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:00.657]             base::names(...future.oldOptions))
[10:34:00.657]     }
[10:34:00.657]     if (FALSE) {
[10:34:00.657]     }
[10:34:00.657]     else {
[10:34:00.657]         if (TRUE) {
[10:34:00.657]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:00.657]                 open = "w")
[10:34:00.657]         }
[10:34:00.657]         else {
[10:34:00.657]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:00.657]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:00.657]         }
[10:34:00.657]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:00.657]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:00.657]             base::sink(type = "output", split = FALSE)
[10:34:00.657]             base::close(...future.stdout)
[10:34:00.657]         }, add = TRUE)
[10:34:00.657]     }
[10:34:00.657]     ...future.frame <- base::sys.nframe()
[10:34:00.657]     ...future.conditions <- base::list()
[10:34:00.657]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:00.657]     if (FALSE) {
[10:34:00.657]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:00.657]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:00.657]     }
[10:34:00.657]     ...future.result <- base::tryCatch({
[10:34:00.657]         base::withCallingHandlers({
[10:34:00.657]             ...future.value <- base::withVisible(base::local({
[10:34:00.657]                 withCallingHandlers({
[10:34:00.657]                   {
[10:34:00.657]                     Sys.sleep(0.1)
[10:34:00.657]                     kk
[10:34:00.657]                   }
[10:34:00.657]                 }, immediateCondition = function(cond) {
[10:34:00.657]                   save_rds <- function (object, pathname, ...) 
[10:34:00.657]                   {
[10:34:00.657]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:34:00.657]                     if (file_test("-f", pathname_tmp)) {
[10:34:00.657]                       fi_tmp <- file.info(pathname_tmp)
[10:34:00.657]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:34:00.657]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:00.657]                         fi_tmp[["mtime"]])
[10:34:00.657]                     }
[10:34:00.657]                     tryCatch({
[10:34:00.657]                       saveRDS(object, file = pathname_tmp, ...)
[10:34:00.657]                     }, error = function(ex) {
[10:34:00.657]                       msg <- conditionMessage(ex)
[10:34:00.657]                       fi_tmp <- file.info(pathname_tmp)
[10:34:00.657]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:34:00.657]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:00.657]                         fi_tmp[["mtime"]], msg)
[10:34:00.657]                       ex$message <- msg
[10:34:00.657]                       stop(ex)
[10:34:00.657]                     })
[10:34:00.657]                     stopifnot(file_test("-f", pathname_tmp))
[10:34:00.657]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:34:00.657]                     if (!res || file_test("-f", pathname_tmp)) {
[10:34:00.657]                       fi_tmp <- file.info(pathname_tmp)
[10:34:00.657]                       fi <- file.info(pathname)
[10:34:00.657]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:34:00.657]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:00.657]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:34:00.657]                         fi[["size"]], fi[["mtime"]])
[10:34:00.657]                       stop(msg)
[10:34:00.657]                     }
[10:34:00.657]                     invisible(pathname)
[10:34:00.657]                   }
[10:34:00.657]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:34:00.657]                     rootPath = tempdir()) 
[10:34:00.657]                   {
[10:34:00.657]                     obj <- list(time = Sys.time(), condition = cond)
[10:34:00.657]                     file <- tempfile(pattern = class(cond)[1], 
[10:34:00.657]                       tmpdir = path, fileext = ".rds")
[10:34:00.657]                     save_rds(obj, file)
[10:34:00.657]                   }
[10:34:00.657]                   saveImmediateCondition(cond, path = "/tmp/RtmpuZEzLw/.future/immediateConditions")
[10:34:00.657]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:00.657]                   {
[10:34:00.657]                     inherits <- base::inherits
[10:34:00.657]                     invokeRestart <- base::invokeRestart
[10:34:00.657]                     is.null <- base::is.null
[10:34:00.657]                     muffled <- FALSE
[10:34:00.657]                     if (inherits(cond, "message")) {
[10:34:00.657]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:00.657]                       if (muffled) 
[10:34:00.657]                         invokeRestart("muffleMessage")
[10:34:00.657]                     }
[10:34:00.657]                     else if (inherits(cond, "warning")) {
[10:34:00.657]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:00.657]                       if (muffled) 
[10:34:00.657]                         invokeRestart("muffleWarning")
[10:34:00.657]                     }
[10:34:00.657]                     else if (inherits(cond, "condition")) {
[10:34:00.657]                       if (!is.null(pattern)) {
[10:34:00.657]                         computeRestarts <- base::computeRestarts
[10:34:00.657]                         grepl <- base::grepl
[10:34:00.657]                         restarts <- computeRestarts(cond)
[10:34:00.657]                         for (restart in restarts) {
[10:34:00.657]                           name <- restart$name
[10:34:00.657]                           if (is.null(name)) 
[10:34:00.657]                             next
[10:34:00.657]                           if (!grepl(pattern, name)) 
[10:34:00.657]                             next
[10:34:00.657]                           invokeRestart(restart)
[10:34:00.657]                           muffled <- TRUE
[10:34:00.657]                           break
[10:34:00.657]                         }
[10:34:00.657]                       }
[10:34:00.657]                     }
[10:34:00.657]                     invisible(muffled)
[10:34:00.657]                   }
[10:34:00.657]                   muffleCondition(cond)
[10:34:00.657]                 })
[10:34:00.657]             }))
[10:34:00.657]             future::FutureResult(value = ...future.value$value, 
[10:34:00.657]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:00.657]                   ...future.rng), globalenv = if (FALSE) 
[10:34:00.657]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:00.657]                     ...future.globalenv.names))
[10:34:00.657]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:00.657]         }, condition = base::local({
[10:34:00.657]             c <- base::c
[10:34:00.657]             inherits <- base::inherits
[10:34:00.657]             invokeRestart <- base::invokeRestart
[10:34:00.657]             length <- base::length
[10:34:00.657]             list <- base::list
[10:34:00.657]             seq.int <- base::seq.int
[10:34:00.657]             signalCondition <- base::signalCondition
[10:34:00.657]             sys.calls <- base::sys.calls
[10:34:00.657]             `[[` <- base::`[[`
[10:34:00.657]             `+` <- base::`+`
[10:34:00.657]             `<<-` <- base::`<<-`
[10:34:00.657]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:00.657]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:00.657]                   3L)]
[10:34:00.657]             }
[10:34:00.657]             function(cond) {
[10:34:00.657]                 is_error <- inherits(cond, "error")
[10:34:00.657]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:00.657]                   NULL)
[10:34:00.657]                 if (is_error) {
[10:34:00.657]                   sessionInformation <- function() {
[10:34:00.657]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:00.657]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:00.657]                       search = base::search(), system = base::Sys.info())
[10:34:00.657]                   }
[10:34:00.657]                   ...future.conditions[[length(...future.conditions) + 
[10:34:00.657]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:00.657]                     cond$call), session = sessionInformation(), 
[10:34:00.657]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:00.657]                   signalCondition(cond)
[10:34:00.657]                 }
[10:34:00.657]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:00.657]                 "immediateCondition"))) {
[10:34:00.657]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:00.657]                   ...future.conditions[[length(...future.conditions) + 
[10:34:00.657]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:00.657]                   if (TRUE && !signal) {
[10:34:00.657]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:00.657]                     {
[10:34:00.657]                       inherits <- base::inherits
[10:34:00.657]                       invokeRestart <- base::invokeRestart
[10:34:00.657]                       is.null <- base::is.null
[10:34:00.657]                       muffled <- FALSE
[10:34:00.657]                       if (inherits(cond, "message")) {
[10:34:00.657]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:00.657]                         if (muffled) 
[10:34:00.657]                           invokeRestart("muffleMessage")
[10:34:00.657]                       }
[10:34:00.657]                       else if (inherits(cond, "warning")) {
[10:34:00.657]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:00.657]                         if (muffled) 
[10:34:00.657]                           invokeRestart("muffleWarning")
[10:34:00.657]                       }
[10:34:00.657]                       else if (inherits(cond, "condition")) {
[10:34:00.657]                         if (!is.null(pattern)) {
[10:34:00.657]                           computeRestarts <- base::computeRestarts
[10:34:00.657]                           grepl <- base::grepl
[10:34:00.657]                           restarts <- computeRestarts(cond)
[10:34:00.657]                           for (restart in restarts) {
[10:34:00.657]                             name <- restart$name
[10:34:00.657]                             if (is.null(name)) 
[10:34:00.657]                               next
[10:34:00.657]                             if (!grepl(pattern, name)) 
[10:34:00.657]                               next
[10:34:00.657]                             invokeRestart(restart)
[10:34:00.657]                             muffled <- TRUE
[10:34:00.657]                             break
[10:34:00.657]                           }
[10:34:00.657]                         }
[10:34:00.657]                       }
[10:34:00.657]                       invisible(muffled)
[10:34:00.657]                     }
[10:34:00.657]                     muffleCondition(cond, pattern = "^muffle")
[10:34:00.657]                   }
[10:34:00.657]                 }
[10:34:00.657]                 else {
[10:34:00.657]                   if (TRUE) {
[10:34:00.657]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:00.657]                     {
[10:34:00.657]                       inherits <- base::inherits
[10:34:00.657]                       invokeRestart <- base::invokeRestart
[10:34:00.657]                       is.null <- base::is.null
[10:34:00.657]                       muffled <- FALSE
[10:34:00.657]                       if (inherits(cond, "message")) {
[10:34:00.657]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:00.657]                         if (muffled) 
[10:34:00.657]                           invokeRestart("muffleMessage")
[10:34:00.657]                       }
[10:34:00.657]                       else if (inherits(cond, "warning")) {
[10:34:00.657]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:00.657]                         if (muffled) 
[10:34:00.657]                           invokeRestart("muffleWarning")
[10:34:00.657]                       }
[10:34:00.657]                       else if (inherits(cond, "condition")) {
[10:34:00.657]                         if (!is.null(pattern)) {
[10:34:00.657]                           computeRestarts <- base::computeRestarts
[10:34:00.657]                           grepl <- base::grepl
[10:34:00.657]                           restarts <- computeRestarts(cond)
[10:34:00.657]                           for (restart in restarts) {
[10:34:00.657]                             name <- restart$name
[10:34:00.657]                             if (is.null(name)) 
[10:34:00.657]                               next
[10:34:00.657]                             if (!grepl(pattern, name)) 
[10:34:00.657]                               next
[10:34:00.657]                             invokeRestart(restart)
[10:34:00.657]                             muffled <- TRUE
[10:34:00.657]                             break
[10:34:00.657]                           }
[10:34:00.657]                         }
[10:34:00.657]                       }
[10:34:00.657]                       invisible(muffled)
[10:34:00.657]                     }
[10:34:00.657]                     muffleCondition(cond, pattern = "^muffle")
[10:34:00.657]                   }
[10:34:00.657]                 }
[10:34:00.657]             }
[10:34:00.657]         }))
[10:34:00.657]     }, error = function(ex) {
[10:34:00.657]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:00.657]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:00.657]                 ...future.rng), started = ...future.startTime, 
[10:34:00.657]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:00.657]             version = "1.8"), class = "FutureResult")
[10:34:00.657]     }, finally = {
[10:34:00.657]         if (!identical(...future.workdir, getwd())) 
[10:34:00.657]             setwd(...future.workdir)
[10:34:00.657]         {
[10:34:00.657]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:00.657]                 ...future.oldOptions$nwarnings <- NULL
[10:34:00.657]             }
[10:34:00.657]             base::options(...future.oldOptions)
[10:34:00.657]             if (.Platform$OS.type == "windows") {
[10:34:00.657]                 old_names <- names(...future.oldEnvVars)
[10:34:00.657]                 envs <- base::Sys.getenv()
[10:34:00.657]                 names <- names(envs)
[10:34:00.657]                 common <- intersect(names, old_names)
[10:34:00.657]                 added <- setdiff(names, old_names)
[10:34:00.657]                 removed <- setdiff(old_names, names)
[10:34:00.657]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:00.657]                   envs[common]]
[10:34:00.657]                 NAMES <- toupper(changed)
[10:34:00.657]                 args <- list()
[10:34:00.657]                 for (kk in seq_along(NAMES)) {
[10:34:00.657]                   name <- changed[[kk]]
[10:34:00.657]                   NAME <- NAMES[[kk]]
[10:34:00.657]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:00.657]                     next
[10:34:00.657]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:00.657]                 }
[10:34:00.657]                 NAMES <- toupper(added)
[10:34:00.657]                 for (kk in seq_along(NAMES)) {
[10:34:00.657]                   name <- added[[kk]]
[10:34:00.657]                   NAME <- NAMES[[kk]]
[10:34:00.657]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:00.657]                     next
[10:34:00.657]                   args[[name]] <- ""
[10:34:00.657]                 }
[10:34:00.657]                 NAMES <- toupper(removed)
[10:34:00.657]                 for (kk in seq_along(NAMES)) {
[10:34:00.657]                   name <- removed[[kk]]
[10:34:00.657]                   NAME <- NAMES[[kk]]
[10:34:00.657]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:00.657]                     next
[10:34:00.657]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:00.657]                 }
[10:34:00.657]                 if (length(args) > 0) 
[10:34:00.657]                   base::do.call(base::Sys.setenv, args = args)
[10:34:00.657]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:00.657]             }
[10:34:00.657]             else {
[10:34:00.657]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:00.657]             }
[10:34:00.657]             {
[10:34:00.657]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:00.657]                   0L) {
[10:34:00.657]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:00.657]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:00.657]                   base::options(opts)
[10:34:00.657]                 }
[10:34:00.657]                 {
[10:34:00.657]                   {
[10:34:00.657]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:00.657]                     NULL
[10:34:00.657]                   }
[10:34:00.657]                   options(future.plan = NULL)
[10:34:00.657]                   if (is.na(NA_character_)) 
[10:34:00.657]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:00.657]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:00.657]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:00.657]                     .init = FALSE)
[10:34:00.657]                 }
[10:34:00.657]             }
[10:34:00.657]         }
[10:34:00.657]     })
[10:34:00.657]     if (TRUE) {
[10:34:00.657]         base::sink(type = "output", split = FALSE)
[10:34:00.657]         if (TRUE) {
[10:34:00.657]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:00.657]         }
[10:34:00.657]         else {
[10:34:00.657]             ...future.result["stdout"] <- base::list(NULL)
[10:34:00.657]         }
[10:34:00.657]         base::close(...future.stdout)
[10:34:00.657]         ...future.stdout <- NULL
[10:34:00.657]     }
[10:34:00.657]     ...future.result$conditions <- ...future.conditions
[10:34:00.657]     ...future.result$finished <- base::Sys.time()
[10:34:00.657]     ...future.result
[10:34:00.657] }
[10:34:00.661] assign_globals() ...
[10:34:00.661] List of 1
[10:34:00.661]  $ kk: int 2
[10:34:00.661]  - attr(*, "where")=List of 1
[10:34:00.661]   ..$ kk:<environment: R_EmptyEnv> 
[10:34:00.661]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:34:00.661]  - attr(*, "resolved")= logi FALSE
[10:34:00.661]  - attr(*, "total_size")= num 56
[10:34:00.661]  - attr(*, "already-done")= logi TRUE
[10:34:00.665] - copied ‘kk’ to environment
[10:34:00.665] assign_globals() ... done
[10:34:00.666] requestCore(): workers = 2
[10:34:00.666] Poll #1 (0): usedCores() = 2, workers = 2
[10:34:00.677] result() for MulticoreFuture ...
[10:34:00.677] result() for MulticoreFuture ...
[10:34:00.678] result() for MulticoreFuture ... done
[10:34:00.678] result() for MulticoreFuture ... done
[10:34:00.678] result() for MulticoreFuture ...
[10:34:00.678] result() for MulticoreFuture ... done
[10:34:00.680] MulticoreFuture started
[10:34:00.681] - Launch lazy future ... done
[10:34:00.681] run() for ‘MulticoreFuture’ ... done
[10:34:00.682] plan(): Setting new future strategy stack:
[10:34:00.682] List of future strategies:
[10:34:00.682] 1. sequential:
[10:34:00.682]    - args: function (..., envir = parent.frame())
[10:34:00.682]    - tweaked: FALSE
[10:34:00.682]    - call: NULL
[10:34:00.683] plan(): nbrOfWorkers() = 1
[10:34:00.692] run() for ‘Future’ ...
[10:34:00.692] - state: ‘created’
[10:34:00.693] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:34:00.698] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:00.699] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:34:00.699]   - Field: ‘label’
[10:34:00.699]   - Field: ‘local’
[10:34:00.699]   - Field: ‘owner’
[10:34:00.699]   - Field: ‘envir’
[10:34:00.699]   - Field: ‘workers’
[10:34:00.700]   - Field: ‘packages’
[10:34:00.700]   - Field: ‘gc’
[10:34:00.700]   - Field: ‘job’
[10:34:00.700]   - Field: ‘conditions’
[10:34:00.700]   - Field: ‘expr’
[10:34:00.700]   - Field: ‘uuid’
[10:34:00.701]   - Field: ‘seed’
[10:34:00.701]   - Field: ‘version’
[10:34:00.701]   - Field: ‘result’
[10:34:00.701]   - Field: ‘asynchronous’
[10:34:00.701]   - Field: ‘calls’
[10:34:00.701]   - Field: ‘globals’
[10:34:00.702]   - Field: ‘stdout’
[10:34:00.702]   - Field: ‘earlySignal’
[10:34:00.702]   - Field: ‘lazy’
[10:34:00.702]   - Field: ‘state’
[10:34:00.702] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:34:00.702] - Launch lazy future ...
[10:34:00.703] Packages needed by the future expression (n = 0): <none>
[10:34:00.703] Packages needed by future strategies (n = 0): <none>
[10:34:00.704] {
[10:34:00.704]     {
[10:34:00.704]         {
[10:34:00.704]             ...future.startTime <- base::Sys.time()
[10:34:00.704]             {
[10:34:00.704]                 {
[10:34:00.704]                   {
[10:34:00.704]                     {
[10:34:00.704]                       base::local({
[10:34:00.704]                         has_future <- base::requireNamespace("future", 
[10:34:00.704]                           quietly = TRUE)
[10:34:00.704]                         if (has_future) {
[10:34:00.704]                           ns <- base::getNamespace("future")
[10:34:00.704]                           version <- ns[[".package"]][["version"]]
[10:34:00.704]                           if (is.null(version)) 
[10:34:00.704]                             version <- utils::packageVersion("future")
[10:34:00.704]                         }
[10:34:00.704]                         else {
[10:34:00.704]                           version <- NULL
[10:34:00.704]                         }
[10:34:00.704]                         if (!has_future || version < "1.8.0") {
[10:34:00.704]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:00.704]                             "", base::R.version$version.string), 
[10:34:00.704]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:00.704]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:00.704]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:00.704]                               "release", "version")], collapse = " "), 
[10:34:00.704]                             hostname = base::Sys.info()[["nodename"]])
[10:34:00.704]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:00.704]                             info)
[10:34:00.704]                           info <- base::paste(info, collapse = "; ")
[10:34:00.704]                           if (!has_future) {
[10:34:00.704]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:00.704]                               info)
[10:34:00.704]                           }
[10:34:00.704]                           else {
[10:34:00.704]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:00.704]                               info, version)
[10:34:00.704]                           }
[10:34:00.704]                           base::stop(msg)
[10:34:00.704]                         }
[10:34:00.704]                       })
[10:34:00.704]                     }
[10:34:00.704]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:00.704]                     base::options(mc.cores = 1L)
[10:34:00.704]                   }
[10:34:00.704]                   ...future.strategy.old <- future::plan("list")
[10:34:00.704]                   options(future.plan = NULL)
[10:34:00.704]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:00.704]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:00.704]                 }
[10:34:00.704]                 ...future.workdir <- getwd()
[10:34:00.704]             }
[10:34:00.704]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:00.704]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:00.704]         }
[10:34:00.704]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:00.704]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:00.704]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:00.704]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:00.704]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:00.704]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:00.704]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:00.704]             base::names(...future.oldOptions))
[10:34:00.704]     }
[10:34:00.704]     if (FALSE) {
[10:34:00.704]     }
[10:34:00.704]     else {
[10:34:00.704]         if (TRUE) {
[10:34:00.704]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:00.704]                 open = "w")
[10:34:00.704]         }
[10:34:00.704]         else {
[10:34:00.704]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:00.704]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:00.704]         }
[10:34:00.704]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:00.704]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:00.704]             base::sink(type = "output", split = FALSE)
[10:34:00.704]             base::close(...future.stdout)
[10:34:00.704]         }, add = TRUE)
[10:34:00.704]     }
[10:34:00.704]     ...future.frame <- base::sys.nframe()
[10:34:00.704]     ...future.conditions <- base::list()
[10:34:00.704]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:00.704]     if (FALSE) {
[10:34:00.704]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:00.704]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:00.704]     }
[10:34:00.704]     ...future.result <- base::tryCatch({
[10:34:00.704]         base::withCallingHandlers({
[10:34:00.704]             ...future.value <- base::withVisible(base::local({
[10:34:00.704]                 withCallingHandlers({
[10:34:00.704]                   {
[10:34:00.704]                     Sys.sleep(0.1)
[10:34:00.704]                     kk
[10:34:00.704]                   }
[10:34:00.704]                 }, immediateCondition = function(cond) {
[10:34:00.704]                   save_rds <- function (object, pathname, ...) 
[10:34:00.704]                   {
[10:34:00.704]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:34:00.704]                     if (file_test("-f", pathname_tmp)) {
[10:34:00.704]                       fi_tmp <- file.info(pathname_tmp)
[10:34:00.704]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:34:00.704]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:00.704]                         fi_tmp[["mtime"]])
[10:34:00.704]                     }
[10:34:00.704]                     tryCatch({
[10:34:00.704]                       saveRDS(object, file = pathname_tmp, ...)
[10:34:00.704]                     }, error = function(ex) {
[10:34:00.704]                       msg <- conditionMessage(ex)
[10:34:00.704]                       fi_tmp <- file.info(pathname_tmp)
[10:34:00.704]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:34:00.704]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:00.704]                         fi_tmp[["mtime"]], msg)
[10:34:00.704]                       ex$message <- msg
[10:34:00.704]                       stop(ex)
[10:34:00.704]                     })
[10:34:00.704]                     stopifnot(file_test("-f", pathname_tmp))
[10:34:00.704]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:34:00.704]                     if (!res || file_test("-f", pathname_tmp)) {
[10:34:00.704]                       fi_tmp <- file.info(pathname_tmp)
[10:34:00.704]                       fi <- file.info(pathname)
[10:34:00.704]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:34:00.704]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:00.704]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:34:00.704]                         fi[["size"]], fi[["mtime"]])
[10:34:00.704]                       stop(msg)
[10:34:00.704]                     }
[10:34:00.704]                     invisible(pathname)
[10:34:00.704]                   }
[10:34:00.704]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:34:00.704]                     rootPath = tempdir()) 
[10:34:00.704]                   {
[10:34:00.704]                     obj <- list(time = Sys.time(), condition = cond)
[10:34:00.704]                     file <- tempfile(pattern = class(cond)[1], 
[10:34:00.704]                       tmpdir = path, fileext = ".rds")
[10:34:00.704]                     save_rds(obj, file)
[10:34:00.704]                   }
[10:34:00.704]                   saveImmediateCondition(cond, path = "/tmp/RtmpuZEzLw/.future/immediateConditions")
[10:34:00.704]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:00.704]                   {
[10:34:00.704]                     inherits <- base::inherits
[10:34:00.704]                     invokeRestart <- base::invokeRestart
[10:34:00.704]                     is.null <- base::is.null
[10:34:00.704]                     muffled <- FALSE
[10:34:00.704]                     if (inherits(cond, "message")) {
[10:34:00.704]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:00.704]                       if (muffled) 
[10:34:00.704]                         invokeRestart("muffleMessage")
[10:34:00.704]                     }
[10:34:00.704]                     else if (inherits(cond, "warning")) {
[10:34:00.704]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:00.704]                       if (muffled) 
[10:34:00.704]                         invokeRestart("muffleWarning")
[10:34:00.704]                     }
[10:34:00.704]                     else if (inherits(cond, "condition")) {
[10:34:00.704]                       if (!is.null(pattern)) {
[10:34:00.704]                         computeRestarts <- base::computeRestarts
[10:34:00.704]                         grepl <- base::grepl
[10:34:00.704]                         restarts <- computeRestarts(cond)
[10:34:00.704]                         for (restart in restarts) {
[10:34:00.704]                           name <- restart$name
[10:34:00.704]                           if (is.null(name)) 
[10:34:00.704]                             next
[10:34:00.704]                           if (!grepl(pattern, name)) 
[10:34:00.704]                             next
[10:34:00.704]                           invokeRestart(restart)
[10:34:00.704]                           muffled <- TRUE
[10:34:00.704]                           break
[10:34:00.704]                         }
[10:34:00.704]                       }
[10:34:00.704]                     }
[10:34:00.704]                     invisible(muffled)
[10:34:00.704]                   }
[10:34:00.704]                   muffleCondition(cond)
[10:34:00.704]                 })
[10:34:00.704]             }))
[10:34:00.704]             future::FutureResult(value = ...future.value$value, 
[10:34:00.704]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:00.704]                   ...future.rng), globalenv = if (FALSE) 
[10:34:00.704]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:00.704]                     ...future.globalenv.names))
[10:34:00.704]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:00.704]         }, condition = base::local({
[10:34:00.704]             c <- base::c
[10:34:00.704]             inherits <- base::inherits
[10:34:00.704]             invokeRestart <- base::invokeRestart
[10:34:00.704]             length <- base::length
[10:34:00.704]             list <- base::list
[10:34:00.704]             seq.int <- base::seq.int
[10:34:00.704]             signalCondition <- base::signalCondition
[10:34:00.704]             sys.calls <- base::sys.calls
[10:34:00.704]             `[[` <- base::`[[`
[10:34:00.704]             `+` <- base::`+`
[10:34:00.704]             `<<-` <- base::`<<-`
[10:34:00.704]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:00.704]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:00.704]                   3L)]
[10:34:00.704]             }
[10:34:00.704]             function(cond) {
[10:34:00.704]                 is_error <- inherits(cond, "error")
[10:34:00.704]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:00.704]                   NULL)
[10:34:00.704]                 if (is_error) {
[10:34:00.704]                   sessionInformation <- function() {
[10:34:00.704]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:00.704]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:00.704]                       search = base::search(), system = base::Sys.info())
[10:34:00.704]                   }
[10:34:00.704]                   ...future.conditions[[length(...future.conditions) + 
[10:34:00.704]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:00.704]                     cond$call), session = sessionInformation(), 
[10:34:00.704]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:00.704]                   signalCondition(cond)
[10:34:00.704]                 }
[10:34:00.704]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:00.704]                 "immediateCondition"))) {
[10:34:00.704]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:00.704]                   ...future.conditions[[length(...future.conditions) + 
[10:34:00.704]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:00.704]                   if (TRUE && !signal) {
[10:34:00.704]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:00.704]                     {
[10:34:00.704]                       inherits <- base::inherits
[10:34:00.704]                       invokeRestart <- base::invokeRestart
[10:34:00.704]                       is.null <- base::is.null
[10:34:00.704]                       muffled <- FALSE
[10:34:00.704]                       if (inherits(cond, "message")) {
[10:34:00.704]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:00.704]                         if (muffled) 
[10:34:00.704]                           invokeRestart("muffleMessage")
[10:34:00.704]                       }
[10:34:00.704]                       else if (inherits(cond, "warning")) {
[10:34:00.704]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:00.704]                         if (muffled) 
[10:34:00.704]                           invokeRestart("muffleWarning")
[10:34:00.704]                       }
[10:34:00.704]                       else if (inherits(cond, "condition")) {
[10:34:00.704]                         if (!is.null(pattern)) {
[10:34:00.704]                           computeRestarts <- base::computeRestarts
[10:34:00.704]                           grepl <- base::grepl
[10:34:00.704]                           restarts <- computeRestarts(cond)
[10:34:00.704]                           for (restart in restarts) {
[10:34:00.704]                             name <- restart$name
[10:34:00.704]                             if (is.null(name)) 
[10:34:00.704]                               next
[10:34:00.704]                             if (!grepl(pattern, name)) 
[10:34:00.704]                               next
[10:34:00.704]                             invokeRestart(restart)
[10:34:00.704]                             muffled <- TRUE
[10:34:00.704]                             break
[10:34:00.704]                           }
[10:34:00.704]                         }
[10:34:00.704]                       }
[10:34:00.704]                       invisible(muffled)
[10:34:00.704]                     }
[10:34:00.704]                     muffleCondition(cond, pattern = "^muffle")
[10:34:00.704]                   }
[10:34:00.704]                 }
[10:34:00.704]                 else {
[10:34:00.704]                   if (TRUE) {
[10:34:00.704]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:00.704]                     {
[10:34:00.704]                       inherits <- base::inherits
[10:34:00.704]                       invokeRestart <- base::invokeRestart
[10:34:00.704]                       is.null <- base::is.null
[10:34:00.704]                       muffled <- FALSE
[10:34:00.704]                       if (inherits(cond, "message")) {
[10:34:00.704]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:00.704]                         if (muffled) 
[10:34:00.704]                           invokeRestart("muffleMessage")
[10:34:00.704]                       }
[10:34:00.704]                       else if (inherits(cond, "warning")) {
[10:34:00.704]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:00.704]                         if (muffled) 
[10:34:00.704]                           invokeRestart("muffleWarning")
[10:34:00.704]                       }
[10:34:00.704]                       else if (inherits(cond, "condition")) {
[10:34:00.704]                         if (!is.null(pattern)) {
[10:34:00.704]                           computeRestarts <- base::computeRestarts
[10:34:00.704]                           grepl <- base::grepl
[10:34:00.704]                           restarts <- computeRestarts(cond)
[10:34:00.704]                           for (restart in restarts) {
[10:34:00.704]                             name <- restart$name
[10:34:00.704]                             if (is.null(name)) 
[10:34:00.704]                               next
[10:34:00.704]                             if (!grepl(pattern, name)) 
[10:34:00.704]                               next
[10:34:00.704]                             invokeRestart(restart)
[10:34:00.704]                             muffled <- TRUE
[10:34:00.704]                             break
[10:34:00.704]                           }
[10:34:00.704]                         }
[10:34:00.704]                       }
[10:34:00.704]                       invisible(muffled)
[10:34:00.704]                     }
[10:34:00.704]                     muffleCondition(cond, pattern = "^muffle")
[10:34:00.704]                   }
[10:34:00.704]                 }
[10:34:00.704]             }
[10:34:00.704]         }))
[10:34:00.704]     }, error = function(ex) {
[10:34:00.704]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:00.704]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:00.704]                 ...future.rng), started = ...future.startTime, 
[10:34:00.704]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:00.704]             version = "1.8"), class = "FutureResult")
[10:34:00.704]     }, finally = {
[10:34:00.704]         if (!identical(...future.workdir, getwd())) 
[10:34:00.704]             setwd(...future.workdir)
[10:34:00.704]         {
[10:34:00.704]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:00.704]                 ...future.oldOptions$nwarnings <- NULL
[10:34:00.704]             }
[10:34:00.704]             base::options(...future.oldOptions)
[10:34:00.704]             if (.Platform$OS.type == "windows") {
[10:34:00.704]                 old_names <- names(...future.oldEnvVars)
[10:34:00.704]                 envs <- base::Sys.getenv()
[10:34:00.704]                 names <- names(envs)
[10:34:00.704]                 common <- intersect(names, old_names)
[10:34:00.704]                 added <- setdiff(names, old_names)
[10:34:00.704]                 removed <- setdiff(old_names, names)
[10:34:00.704]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:00.704]                   envs[common]]
[10:34:00.704]                 NAMES <- toupper(changed)
[10:34:00.704]                 args <- list()
[10:34:00.704]                 for (kk in seq_along(NAMES)) {
[10:34:00.704]                   name <- changed[[kk]]
[10:34:00.704]                   NAME <- NAMES[[kk]]
[10:34:00.704]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:00.704]                     next
[10:34:00.704]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:00.704]                 }
[10:34:00.704]                 NAMES <- toupper(added)
[10:34:00.704]                 for (kk in seq_along(NAMES)) {
[10:34:00.704]                   name <- added[[kk]]
[10:34:00.704]                   NAME <- NAMES[[kk]]
[10:34:00.704]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:00.704]                     next
[10:34:00.704]                   args[[name]] <- ""
[10:34:00.704]                 }
[10:34:00.704]                 NAMES <- toupper(removed)
[10:34:00.704]                 for (kk in seq_along(NAMES)) {
[10:34:00.704]                   name <- removed[[kk]]
[10:34:00.704]                   NAME <- NAMES[[kk]]
[10:34:00.704]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:00.704]                     next
[10:34:00.704]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:00.704]                 }
[10:34:00.704]                 if (length(args) > 0) 
[10:34:00.704]                   base::do.call(base::Sys.setenv, args = args)
[10:34:00.704]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:00.704]             }
[10:34:00.704]             else {
[10:34:00.704]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:00.704]             }
[10:34:00.704]             {
[10:34:00.704]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:00.704]                   0L) {
[10:34:00.704]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:00.704]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:00.704]                   base::options(opts)
[10:34:00.704]                 }
[10:34:00.704]                 {
[10:34:00.704]                   {
[10:34:00.704]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:00.704]                     NULL
[10:34:00.704]                   }
[10:34:00.704]                   options(future.plan = NULL)
[10:34:00.704]                   if (is.na(NA_character_)) 
[10:34:00.704]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:00.704]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:00.704]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:00.704]                     .init = FALSE)
[10:34:00.704]                 }
[10:34:00.704]             }
[10:34:00.704]         }
[10:34:00.704]     })
[10:34:00.704]     if (TRUE) {
[10:34:00.704]         base::sink(type = "output", split = FALSE)
[10:34:00.704]         if (TRUE) {
[10:34:00.704]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:00.704]         }
[10:34:00.704]         else {
[10:34:00.704]             ...future.result["stdout"] <- base::list(NULL)
[10:34:00.704]         }
[10:34:00.704]         base::close(...future.stdout)
[10:34:00.704]         ...future.stdout <- NULL
[10:34:00.704]     }
[10:34:00.704]     ...future.result$conditions <- ...future.conditions
[10:34:00.704]     ...future.result$finished <- base::Sys.time()
[10:34:00.704]     ...future.result
[10:34:00.704] }
[10:34:00.707] assign_globals() ...
[10:34:00.707] List of 1
[10:34:00.707]  $ kk: int 3
[10:34:00.707]  - attr(*, "where")=List of 1
[10:34:00.707]   ..$ kk:<environment: R_EmptyEnv> 
[10:34:00.707]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:34:00.707]  - attr(*, "resolved")= logi FALSE
[10:34:00.707]  - attr(*, "total_size")= num 56
[10:34:00.707]  - attr(*, "already-done")= logi TRUE
[10:34:00.718] - copied ‘kk’ to environment
[10:34:00.718] assign_globals() ... done
[10:34:00.718] requestCore(): workers = 2
[10:34:00.719] Poll #1 (0): usedCores() = 2, workers = 2
[10:34:00.739] plan(): Setting new future strategy stack:
[10:34:00.739] List of future strategies:
[10:34:00.739] 1. multicore:
[10:34:00.739]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:34:00.739]    - tweaked: FALSE
[10:34:00.739]    - call: plan(strategy)
[10:34:00.744] plan(): nbrOfWorkers() = 2
[10:34:00.750] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[10:34:00.761] result() for MulticoreFuture ...
[10:34:00.762] result() for MulticoreFuture ...
[10:34:00.762] result() for MulticoreFuture ... done
[10:34:00.762] result() for MulticoreFuture ... done
[10:34:00.762] result() for MulticoreFuture ...
[10:34:00.762] result() for MulticoreFuture ... done
[10:34:00.765] MulticoreFuture started
[10:34:00.765] - Launch lazy future ... done
[10:34:00.766] run() for ‘MulticoreFuture’ ... done
[10:34:00.766] plan(): Setting new future strategy stack:
[10:34:00.767] List of future strategies:
[10:34:00.767] 1. sequential:
[10:34:00.767]    - args: function (..., envir = parent.frame())
[10:34:00.767]    - tweaked: FALSE
[10:34:00.767]    - call: NULL
[10:34:00.768] plan(): nbrOfWorkers() = 1
[10:34:00.786] plan(): Setting new future strategy stack:
[10:34:00.786] List of future strategies:
[10:34:00.786] 1. multicore:
[10:34:00.786]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:34:00.786]    - tweaked: FALSE
[10:34:00.786]    - call: plan(strategy)
[10:34:00.787] Future #1
[10:34:00.788]  length: 2 (resolved future 1)
[10:34:00.790] plan(): nbrOfWorkers() = 2
[10:34:00.791] Future #2
[10:34:00.791]  length: 1 (resolved future 2)
[10:34:00.871] plan(): Setting new future strategy stack:
[10:34:00.871] List of future strategies:
[10:34:00.871] 1. multicore:
[10:34:00.871]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:34:00.871]    - tweaked: FALSE
[10:34:00.871]    - call: plan(strategy)
[10:34:00.877] plan(): nbrOfWorkers() = 2
[10:34:00.877] Future #3
[10:34:00.877]  length: 0 (resolved future 3)
[10:34:00.878] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[10:34:00.879] resolve() on environment ...
[10:34:00.879]  recursive: 0
[10:34:00.880]  elements: [2] ‘a’, ‘b’
[10:34:00.880]  length: 1 (resolved future 1)
[10:34:00.880]  length: 0 (resolved future 2)
[10:34:00.880] resolve() on environment ... DONE
[10:34:00.881] getGlobalsAndPackages() ...
[10:34:00.881] Searching for globals...
[10:34:00.882] 
[10:34:00.882] Searching for globals ... DONE
[10:34:00.882] - globals: [0] <none>
[10:34:00.882] getGlobalsAndPackages() ... DONE
[10:34:00.883] run() for ‘Future’ ...
[10:34:00.883] - state: ‘created’
[10:34:00.883] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:34:00.888] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:00.888] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:34:00.888]   - Field: ‘label’
[10:34:00.888]   - Field: ‘local’
[10:34:00.888]   - Field: ‘owner’
[10:34:00.889]   - Field: ‘envir’
[10:34:00.889]   - Field: ‘workers’
[10:34:00.889]   - Field: ‘packages’
[10:34:00.889]   - Field: ‘gc’
[10:34:00.889]   - Field: ‘job’
[10:34:00.889]   - Field: ‘conditions’
[10:34:00.890]   - Field: ‘expr’
[10:34:00.890]   - Field: ‘uuid’
[10:34:00.890]   - Field: ‘seed’
[10:34:00.890]   - Field: ‘version’
[10:34:00.890]   - Field: ‘result’
[10:34:00.890]   - Field: ‘asynchronous’
[10:34:00.891]   - Field: ‘calls’
[10:34:00.891]   - Field: ‘globals’
[10:34:00.891]   - Field: ‘stdout’
[10:34:00.891]   - Field: ‘earlySignal’
[10:34:00.891]   - Field: ‘lazy’
[10:34:00.891]   - Field: ‘state’
[10:34:00.891] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:34:00.892] - Launch lazy future ...
[10:34:00.892] Packages needed by the future expression (n = 0): <none>
[10:34:00.892] Packages needed by future strategies (n = 0): <none>
[10:34:00.893] {
[10:34:00.893]     {
[10:34:00.893]         {
[10:34:00.893]             ...future.startTime <- base::Sys.time()
[10:34:00.893]             {
[10:34:00.893]                 {
[10:34:00.893]                   {
[10:34:00.893]                     {
[10:34:00.893]                       base::local({
[10:34:00.893]                         has_future <- base::requireNamespace("future", 
[10:34:00.893]                           quietly = TRUE)
[10:34:00.893]                         if (has_future) {
[10:34:00.893]                           ns <- base::getNamespace("future")
[10:34:00.893]                           version <- ns[[".package"]][["version"]]
[10:34:00.893]                           if (is.null(version)) 
[10:34:00.893]                             version <- utils::packageVersion("future")
[10:34:00.893]                         }
[10:34:00.893]                         else {
[10:34:00.893]                           version <- NULL
[10:34:00.893]                         }
[10:34:00.893]                         if (!has_future || version < "1.8.0") {
[10:34:00.893]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:00.893]                             "", base::R.version$version.string), 
[10:34:00.893]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:00.893]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:00.893]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:00.893]                               "release", "version")], collapse = " "), 
[10:34:00.893]                             hostname = base::Sys.info()[["nodename"]])
[10:34:00.893]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:00.893]                             info)
[10:34:00.893]                           info <- base::paste(info, collapse = "; ")
[10:34:00.893]                           if (!has_future) {
[10:34:00.893]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:00.893]                               info)
[10:34:00.893]                           }
[10:34:00.893]                           else {
[10:34:00.893]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:00.893]                               info, version)
[10:34:00.893]                           }
[10:34:00.893]                           base::stop(msg)
[10:34:00.893]                         }
[10:34:00.893]                       })
[10:34:00.893]                     }
[10:34:00.893]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:00.893]                     base::options(mc.cores = 1L)
[10:34:00.893]                   }
[10:34:00.893]                   ...future.strategy.old <- future::plan("list")
[10:34:00.893]                   options(future.plan = NULL)
[10:34:00.893]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:00.893]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:00.893]                 }
[10:34:00.893]                 ...future.workdir <- getwd()
[10:34:00.893]             }
[10:34:00.893]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:00.893]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:00.893]         }
[10:34:00.893]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:00.893]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:00.893]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:00.893]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:00.893]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:00.893]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:00.893]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:00.893]             base::names(...future.oldOptions))
[10:34:00.893]     }
[10:34:00.893]     if (FALSE) {
[10:34:00.893]     }
[10:34:00.893]     else {
[10:34:00.893]         if (TRUE) {
[10:34:00.893]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:00.893]                 open = "w")
[10:34:00.893]         }
[10:34:00.893]         else {
[10:34:00.893]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:00.893]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:00.893]         }
[10:34:00.893]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:00.893]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:00.893]             base::sink(type = "output", split = FALSE)
[10:34:00.893]             base::close(...future.stdout)
[10:34:00.893]         }, add = TRUE)
[10:34:00.893]     }
[10:34:00.893]     ...future.frame <- base::sys.nframe()
[10:34:00.893]     ...future.conditions <- base::list()
[10:34:00.893]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:00.893]     if (FALSE) {
[10:34:00.893]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:00.893]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:00.893]     }
[10:34:00.893]     ...future.result <- base::tryCatch({
[10:34:00.893]         base::withCallingHandlers({
[10:34:00.893]             ...future.value <- base::withVisible(base::local({
[10:34:00.893]                 withCallingHandlers({
[10:34:00.893]                   1
[10:34:00.893]                 }, immediateCondition = function(cond) {
[10:34:00.893]                   save_rds <- function (object, pathname, ...) 
[10:34:00.893]                   {
[10:34:00.893]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:34:00.893]                     if (file_test("-f", pathname_tmp)) {
[10:34:00.893]                       fi_tmp <- file.info(pathname_tmp)
[10:34:00.893]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:34:00.893]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:00.893]                         fi_tmp[["mtime"]])
[10:34:00.893]                     }
[10:34:00.893]                     tryCatch({
[10:34:00.893]                       saveRDS(object, file = pathname_tmp, ...)
[10:34:00.893]                     }, error = function(ex) {
[10:34:00.893]                       msg <- conditionMessage(ex)
[10:34:00.893]                       fi_tmp <- file.info(pathname_tmp)
[10:34:00.893]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:34:00.893]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:00.893]                         fi_tmp[["mtime"]], msg)
[10:34:00.893]                       ex$message <- msg
[10:34:00.893]                       stop(ex)
[10:34:00.893]                     })
[10:34:00.893]                     stopifnot(file_test("-f", pathname_tmp))
[10:34:00.893]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:34:00.893]                     if (!res || file_test("-f", pathname_tmp)) {
[10:34:00.893]                       fi_tmp <- file.info(pathname_tmp)
[10:34:00.893]                       fi <- file.info(pathname)
[10:34:00.893]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:34:00.893]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:00.893]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:34:00.893]                         fi[["size"]], fi[["mtime"]])
[10:34:00.893]                       stop(msg)
[10:34:00.893]                     }
[10:34:00.893]                     invisible(pathname)
[10:34:00.893]                   }
[10:34:00.893]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:34:00.893]                     rootPath = tempdir()) 
[10:34:00.893]                   {
[10:34:00.893]                     obj <- list(time = Sys.time(), condition = cond)
[10:34:00.893]                     file <- tempfile(pattern = class(cond)[1], 
[10:34:00.893]                       tmpdir = path, fileext = ".rds")
[10:34:00.893]                     save_rds(obj, file)
[10:34:00.893]                   }
[10:34:00.893]                   saveImmediateCondition(cond, path = "/tmp/RtmpuZEzLw/.future/immediateConditions")
[10:34:00.893]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:00.893]                   {
[10:34:00.893]                     inherits <- base::inherits
[10:34:00.893]                     invokeRestart <- base::invokeRestart
[10:34:00.893]                     is.null <- base::is.null
[10:34:00.893]                     muffled <- FALSE
[10:34:00.893]                     if (inherits(cond, "message")) {
[10:34:00.893]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:00.893]                       if (muffled) 
[10:34:00.893]                         invokeRestart("muffleMessage")
[10:34:00.893]                     }
[10:34:00.893]                     else if (inherits(cond, "warning")) {
[10:34:00.893]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:00.893]                       if (muffled) 
[10:34:00.893]                         invokeRestart("muffleWarning")
[10:34:00.893]                     }
[10:34:00.893]                     else if (inherits(cond, "condition")) {
[10:34:00.893]                       if (!is.null(pattern)) {
[10:34:00.893]                         computeRestarts <- base::computeRestarts
[10:34:00.893]                         grepl <- base::grepl
[10:34:00.893]                         restarts <- computeRestarts(cond)
[10:34:00.893]                         for (restart in restarts) {
[10:34:00.893]                           name <- restart$name
[10:34:00.893]                           if (is.null(name)) 
[10:34:00.893]                             next
[10:34:00.893]                           if (!grepl(pattern, name)) 
[10:34:00.893]                             next
[10:34:00.893]                           invokeRestart(restart)
[10:34:00.893]                           muffled <- TRUE
[10:34:00.893]                           break
[10:34:00.893]                         }
[10:34:00.893]                       }
[10:34:00.893]                     }
[10:34:00.893]                     invisible(muffled)
[10:34:00.893]                   }
[10:34:00.893]                   muffleCondition(cond)
[10:34:00.893]                 })
[10:34:00.893]             }))
[10:34:00.893]             future::FutureResult(value = ...future.value$value, 
[10:34:00.893]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:00.893]                   ...future.rng), globalenv = if (FALSE) 
[10:34:00.893]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:00.893]                     ...future.globalenv.names))
[10:34:00.893]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:00.893]         }, condition = base::local({
[10:34:00.893]             c <- base::c
[10:34:00.893]             inherits <- base::inherits
[10:34:00.893]             invokeRestart <- base::invokeRestart
[10:34:00.893]             length <- base::length
[10:34:00.893]             list <- base::list
[10:34:00.893]             seq.int <- base::seq.int
[10:34:00.893]             signalCondition <- base::signalCondition
[10:34:00.893]             sys.calls <- base::sys.calls
[10:34:00.893]             `[[` <- base::`[[`
[10:34:00.893]             `+` <- base::`+`
[10:34:00.893]             `<<-` <- base::`<<-`
[10:34:00.893]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:00.893]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:00.893]                   3L)]
[10:34:00.893]             }
[10:34:00.893]             function(cond) {
[10:34:00.893]                 is_error <- inherits(cond, "error")
[10:34:00.893]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:00.893]                   NULL)
[10:34:00.893]                 if (is_error) {
[10:34:00.893]                   sessionInformation <- function() {
[10:34:00.893]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:00.893]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:00.893]                       search = base::search(), system = base::Sys.info())
[10:34:00.893]                   }
[10:34:00.893]                   ...future.conditions[[length(...future.conditions) + 
[10:34:00.893]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:00.893]                     cond$call), session = sessionInformation(), 
[10:34:00.893]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:00.893]                   signalCondition(cond)
[10:34:00.893]                 }
[10:34:00.893]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:00.893]                 "immediateCondition"))) {
[10:34:00.893]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:00.893]                   ...future.conditions[[length(...future.conditions) + 
[10:34:00.893]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:00.893]                   if (TRUE && !signal) {
[10:34:00.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:00.893]                     {
[10:34:00.893]                       inherits <- base::inherits
[10:34:00.893]                       invokeRestart <- base::invokeRestart
[10:34:00.893]                       is.null <- base::is.null
[10:34:00.893]                       muffled <- FALSE
[10:34:00.893]                       if (inherits(cond, "message")) {
[10:34:00.893]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:00.893]                         if (muffled) 
[10:34:00.893]                           invokeRestart("muffleMessage")
[10:34:00.893]                       }
[10:34:00.893]                       else if (inherits(cond, "warning")) {
[10:34:00.893]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:00.893]                         if (muffled) 
[10:34:00.893]                           invokeRestart("muffleWarning")
[10:34:00.893]                       }
[10:34:00.893]                       else if (inherits(cond, "condition")) {
[10:34:00.893]                         if (!is.null(pattern)) {
[10:34:00.893]                           computeRestarts <- base::computeRestarts
[10:34:00.893]                           grepl <- base::grepl
[10:34:00.893]                           restarts <- computeRestarts(cond)
[10:34:00.893]                           for (restart in restarts) {
[10:34:00.893]                             name <- restart$name
[10:34:00.893]                             if (is.null(name)) 
[10:34:00.893]                               next
[10:34:00.893]                             if (!grepl(pattern, name)) 
[10:34:00.893]                               next
[10:34:00.893]                             invokeRestart(restart)
[10:34:00.893]                             muffled <- TRUE
[10:34:00.893]                             break
[10:34:00.893]                           }
[10:34:00.893]                         }
[10:34:00.893]                       }
[10:34:00.893]                       invisible(muffled)
[10:34:00.893]                     }
[10:34:00.893]                     muffleCondition(cond, pattern = "^muffle")
[10:34:00.893]                   }
[10:34:00.893]                 }
[10:34:00.893]                 else {
[10:34:00.893]                   if (TRUE) {
[10:34:00.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:00.893]                     {
[10:34:00.893]                       inherits <- base::inherits
[10:34:00.893]                       invokeRestart <- base::invokeRestart
[10:34:00.893]                       is.null <- base::is.null
[10:34:00.893]                       muffled <- FALSE
[10:34:00.893]                       if (inherits(cond, "message")) {
[10:34:00.893]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:00.893]                         if (muffled) 
[10:34:00.893]                           invokeRestart("muffleMessage")
[10:34:00.893]                       }
[10:34:00.893]                       else if (inherits(cond, "warning")) {
[10:34:00.893]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:00.893]                         if (muffled) 
[10:34:00.893]                           invokeRestart("muffleWarning")
[10:34:00.893]                       }
[10:34:00.893]                       else if (inherits(cond, "condition")) {
[10:34:00.893]                         if (!is.null(pattern)) {
[10:34:00.893]                           computeRestarts <- base::computeRestarts
[10:34:00.893]                           grepl <- base::grepl
[10:34:00.893]                           restarts <- computeRestarts(cond)
[10:34:00.893]                           for (restart in restarts) {
[10:34:00.893]                             name <- restart$name
[10:34:00.893]                             if (is.null(name)) 
[10:34:00.893]                               next
[10:34:00.893]                             if (!grepl(pattern, name)) 
[10:34:00.893]                               next
[10:34:00.893]                             invokeRestart(restart)
[10:34:00.893]                             muffled <- TRUE
[10:34:00.893]                             break
[10:34:00.893]                           }
[10:34:00.893]                         }
[10:34:00.893]                       }
[10:34:00.893]                       invisible(muffled)
[10:34:00.893]                     }
[10:34:00.893]                     muffleCondition(cond, pattern = "^muffle")
[10:34:00.893]                   }
[10:34:00.893]                 }
[10:34:00.893]             }
[10:34:00.893]         }))
[10:34:00.893]     }, error = function(ex) {
[10:34:00.893]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:00.893]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:00.893]                 ...future.rng), started = ...future.startTime, 
[10:34:00.893]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:00.893]             version = "1.8"), class = "FutureResult")
[10:34:00.893]     }, finally = {
[10:34:00.893]         if (!identical(...future.workdir, getwd())) 
[10:34:00.893]             setwd(...future.workdir)
[10:34:00.893]         {
[10:34:00.893]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:00.893]                 ...future.oldOptions$nwarnings <- NULL
[10:34:00.893]             }
[10:34:00.893]             base::options(...future.oldOptions)
[10:34:00.893]             if (.Platform$OS.type == "windows") {
[10:34:00.893]                 old_names <- names(...future.oldEnvVars)
[10:34:00.893]                 envs <- base::Sys.getenv()
[10:34:00.893]                 names <- names(envs)
[10:34:00.893]                 common <- intersect(names, old_names)
[10:34:00.893]                 added <- setdiff(names, old_names)
[10:34:00.893]                 removed <- setdiff(old_names, names)
[10:34:00.893]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:00.893]                   envs[common]]
[10:34:00.893]                 NAMES <- toupper(changed)
[10:34:00.893]                 args <- list()
[10:34:00.893]                 for (kk in seq_along(NAMES)) {
[10:34:00.893]                   name <- changed[[kk]]
[10:34:00.893]                   NAME <- NAMES[[kk]]
[10:34:00.893]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:00.893]                     next
[10:34:00.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:00.893]                 }
[10:34:00.893]                 NAMES <- toupper(added)
[10:34:00.893]                 for (kk in seq_along(NAMES)) {
[10:34:00.893]                   name <- added[[kk]]
[10:34:00.893]                   NAME <- NAMES[[kk]]
[10:34:00.893]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:00.893]                     next
[10:34:00.893]                   args[[name]] <- ""
[10:34:00.893]                 }
[10:34:00.893]                 NAMES <- toupper(removed)
[10:34:00.893]                 for (kk in seq_along(NAMES)) {
[10:34:00.893]                   name <- removed[[kk]]
[10:34:00.893]                   NAME <- NAMES[[kk]]
[10:34:00.893]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:00.893]                     next
[10:34:00.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:00.893]                 }
[10:34:00.893]                 if (length(args) > 0) 
[10:34:00.893]                   base::do.call(base::Sys.setenv, args = args)
[10:34:00.893]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:00.893]             }
[10:34:00.893]             else {
[10:34:00.893]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:00.893]             }
[10:34:00.893]             {
[10:34:00.893]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:00.893]                   0L) {
[10:34:00.893]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:00.893]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:00.893]                   base::options(opts)
[10:34:00.893]                 }
[10:34:00.893]                 {
[10:34:00.893]                   {
[10:34:00.893]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:00.893]                     NULL
[10:34:00.893]                   }
[10:34:00.893]                   options(future.plan = NULL)
[10:34:00.893]                   if (is.na(NA_character_)) 
[10:34:00.893]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:00.893]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:00.893]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:00.893]                     .init = FALSE)
[10:34:00.893]                 }
[10:34:00.893]             }
[10:34:00.893]         }
[10:34:00.893]     })
[10:34:00.893]     if (TRUE) {
[10:34:00.893]         base::sink(type = "output", split = FALSE)
[10:34:00.893]         if (TRUE) {
[10:34:00.893]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:00.893]         }
[10:34:00.893]         else {
[10:34:00.893]             ...future.result["stdout"] <- base::list(NULL)
[10:34:00.893]         }
[10:34:00.893]         base::close(...future.stdout)
[10:34:00.893]         ...future.stdout <- NULL
[10:34:00.893]     }
[10:34:00.893]     ...future.result$conditions <- ...future.conditions
[10:34:00.893]     ...future.result$finished <- base::Sys.time()
[10:34:00.893]     ...future.result
[10:34:00.893] }
[10:34:00.897] requestCore(): workers = 2
[10:34:00.897] Poll #1 (0): usedCores() = 2, workers = 2
[10:34:00.908] result() for MulticoreFuture ...
[10:34:00.909] result() for MulticoreFuture ...
[10:34:00.909] result() for MulticoreFuture ... done
[10:34:00.909] result() for MulticoreFuture ... done
[10:34:00.909] result() for MulticoreFuture ...
[10:34:00.909] result() for MulticoreFuture ... done
[10:34:00.912] MulticoreFuture started
[10:34:00.913] - Launch lazy future ... done
[10:34:00.913] run() for ‘MulticoreFuture’ ... done
[10:34:00.913] getGlobalsAndPackages() ...
[10:34:00.914] Searching for globals...
[10:34:00.914] plan(): Setting new future strategy stack:
[10:34:00.914] 
[10:34:00.914] List of future strategies:
[10:34:00.914] 1. sequential:
[10:34:00.914]    - args: function (..., envir = parent.frame())
[10:34:00.914]    - tweaked: FALSE
[10:34:00.914]    - call: NULL
[10:34:00.915] Searching for globals ... DONE
[10:34:00.915] - globals: [0] <none>
[10:34:00.915] plan(): nbrOfWorkers() = 1
[10:34:00.915] getGlobalsAndPackages() ... DONE
[10:34:00.915] run() for ‘Future’ ...
[10:34:00.916] - state: ‘created’
[10:34:00.916] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:34:00.917] plan(): Setting new future strategy stack:
[10:34:00.917] List of future strategies:
[10:34:00.917] 1. multicore:
[10:34:00.917]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:34:00.917]    - tweaked: FALSE
[10:34:00.917]    - call: plan(strategy)
[10:34:00.921] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:00.921] plan(): nbrOfWorkers() = 2
[10:34:00.922] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:34:00.922]   - Field: ‘label’
[10:34:00.922]   - Field: ‘local’
[10:34:00.922]   - Field: ‘owner’
[10:34:00.922]   - Field: ‘envir’
[10:34:00.922]   - Field: ‘workers’
[10:34:00.922]   - Field: ‘packages’
[10:34:00.923]   - Field: ‘gc’
[10:34:00.923]   - Field: ‘job’
[10:34:00.923]   - Field: ‘conditions’
[10:34:00.923]   - Field: ‘expr’
[10:34:00.923]   - Field: ‘uuid’
[10:34:00.923]   - Field: ‘seed’
[10:34:00.924]   - Field: ‘version’
[10:34:00.924]   - Field: ‘result’
[10:34:00.924]   - Field: ‘asynchronous’
[10:34:00.924]   - Field: ‘calls’
[10:34:00.924]   - Field: ‘globals’
[10:34:00.924]   - Field: ‘stdout’
[10:34:00.924]   - Field: ‘earlySignal’
[10:34:00.925]   - Field: ‘lazy’
[10:34:00.925]   - Field: ‘state’
[10:34:00.925] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:34:00.925] - Launch lazy future ...
[10:34:00.926] Packages needed by the future expression (n = 0): <none>
[10:34:00.926] Packages needed by future strategies (n = 0): <none>
[10:34:00.926] {
[10:34:00.926]     {
[10:34:00.926]         {
[10:34:00.926]             ...future.startTime <- base::Sys.time()
[10:34:00.926]             {
[10:34:00.926]                 {
[10:34:00.926]                   {
[10:34:00.926]                     {
[10:34:00.926]                       base::local({
[10:34:00.926]                         has_future <- base::requireNamespace("future", 
[10:34:00.926]                           quietly = TRUE)
[10:34:00.926]                         if (has_future) {
[10:34:00.926]                           ns <- base::getNamespace("future")
[10:34:00.926]                           version <- ns[[".package"]][["version"]]
[10:34:00.926]                           if (is.null(version)) 
[10:34:00.926]                             version <- utils::packageVersion("future")
[10:34:00.926]                         }
[10:34:00.926]                         else {
[10:34:00.926]                           version <- NULL
[10:34:00.926]                         }
[10:34:00.926]                         if (!has_future || version < "1.8.0") {
[10:34:00.926]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:00.926]                             "", base::R.version$version.string), 
[10:34:00.926]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:00.926]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:00.926]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:00.926]                               "release", "version")], collapse = " "), 
[10:34:00.926]                             hostname = base::Sys.info()[["nodename"]])
[10:34:00.926]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:00.926]                             info)
[10:34:00.926]                           info <- base::paste(info, collapse = "; ")
[10:34:00.926]                           if (!has_future) {
[10:34:00.926]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:00.926]                               info)
[10:34:00.926]                           }
[10:34:00.926]                           else {
[10:34:00.926]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:00.926]                               info, version)
[10:34:00.926]                           }
[10:34:00.926]                           base::stop(msg)
[10:34:00.926]                         }
[10:34:00.926]                       })
[10:34:00.926]                     }
[10:34:00.926]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:00.926]                     base::options(mc.cores = 1L)
[10:34:00.926]                   }
[10:34:00.926]                   ...future.strategy.old <- future::plan("list")
[10:34:00.926]                   options(future.plan = NULL)
[10:34:00.926]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:00.926]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:00.926]                 }
[10:34:00.926]                 ...future.workdir <- getwd()
[10:34:00.926]             }
[10:34:00.926]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:00.926]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:00.926]         }
[10:34:00.926]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:00.926]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:00.926]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:00.926]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:00.926]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:00.926]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:00.926]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:00.926]             base::names(...future.oldOptions))
[10:34:00.926]     }
[10:34:00.926]     if (FALSE) {
[10:34:00.926]     }
[10:34:00.926]     else {
[10:34:00.926]         if (TRUE) {
[10:34:00.926]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:00.926]                 open = "w")
[10:34:00.926]         }
[10:34:00.926]         else {
[10:34:00.926]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:00.926]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:00.926]         }
[10:34:00.926]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:00.926]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:00.926]             base::sink(type = "output", split = FALSE)
[10:34:00.926]             base::close(...future.stdout)
[10:34:00.926]         }, add = TRUE)
[10:34:00.926]     }
[10:34:00.926]     ...future.frame <- base::sys.nframe()
[10:34:00.926]     ...future.conditions <- base::list()
[10:34:00.926]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:00.926]     if (FALSE) {
[10:34:00.926]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:00.926]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:00.926]     }
[10:34:00.926]     ...future.result <- base::tryCatch({
[10:34:00.926]         base::withCallingHandlers({
[10:34:00.926]             ...future.value <- base::withVisible(base::local({
[10:34:00.926]                 withCallingHandlers({
[10:34:00.926]                   2
[10:34:00.926]                 }, immediateCondition = function(cond) {
[10:34:00.926]                   save_rds <- function (object, pathname, ...) 
[10:34:00.926]                   {
[10:34:00.926]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:34:00.926]                     if (file_test("-f", pathname_tmp)) {
[10:34:00.926]                       fi_tmp <- file.info(pathname_tmp)
[10:34:00.926]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:34:00.926]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:00.926]                         fi_tmp[["mtime"]])
[10:34:00.926]                     }
[10:34:00.926]                     tryCatch({
[10:34:00.926]                       saveRDS(object, file = pathname_tmp, ...)
[10:34:00.926]                     }, error = function(ex) {
[10:34:00.926]                       msg <- conditionMessage(ex)
[10:34:00.926]                       fi_tmp <- file.info(pathname_tmp)
[10:34:00.926]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:34:00.926]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:00.926]                         fi_tmp[["mtime"]], msg)
[10:34:00.926]                       ex$message <- msg
[10:34:00.926]                       stop(ex)
[10:34:00.926]                     })
[10:34:00.926]                     stopifnot(file_test("-f", pathname_tmp))
[10:34:00.926]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:34:00.926]                     if (!res || file_test("-f", pathname_tmp)) {
[10:34:00.926]                       fi_tmp <- file.info(pathname_tmp)
[10:34:00.926]                       fi <- file.info(pathname)
[10:34:00.926]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:34:00.926]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:00.926]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:34:00.926]                         fi[["size"]], fi[["mtime"]])
[10:34:00.926]                       stop(msg)
[10:34:00.926]                     }
[10:34:00.926]                     invisible(pathname)
[10:34:00.926]                   }
[10:34:00.926]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:34:00.926]                     rootPath = tempdir()) 
[10:34:00.926]                   {
[10:34:00.926]                     obj <- list(time = Sys.time(), condition = cond)
[10:34:00.926]                     file <- tempfile(pattern = class(cond)[1], 
[10:34:00.926]                       tmpdir = path, fileext = ".rds")
[10:34:00.926]                     save_rds(obj, file)
[10:34:00.926]                   }
[10:34:00.926]                   saveImmediateCondition(cond, path = "/tmp/RtmpuZEzLw/.future/immediateConditions")
[10:34:00.926]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:00.926]                   {
[10:34:00.926]                     inherits <- base::inherits
[10:34:00.926]                     invokeRestart <- base::invokeRestart
[10:34:00.926]                     is.null <- base::is.null
[10:34:00.926]                     muffled <- FALSE
[10:34:00.926]                     if (inherits(cond, "message")) {
[10:34:00.926]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:00.926]                       if (muffled) 
[10:34:00.926]                         invokeRestart("muffleMessage")
[10:34:00.926]                     }
[10:34:00.926]                     else if (inherits(cond, "warning")) {
[10:34:00.926]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:00.926]                       if (muffled) 
[10:34:00.926]                         invokeRestart("muffleWarning")
[10:34:00.926]                     }
[10:34:00.926]                     else if (inherits(cond, "condition")) {
[10:34:00.926]                       if (!is.null(pattern)) {
[10:34:00.926]                         computeRestarts <- base::computeRestarts
[10:34:00.926]                         grepl <- base::grepl
[10:34:00.926]                         restarts <- computeRestarts(cond)
[10:34:00.926]                         for (restart in restarts) {
[10:34:00.926]                           name <- restart$name
[10:34:00.926]                           if (is.null(name)) 
[10:34:00.926]                             next
[10:34:00.926]                           if (!grepl(pattern, name)) 
[10:34:00.926]                             next
[10:34:00.926]                           invokeRestart(restart)
[10:34:00.926]                           muffled <- TRUE
[10:34:00.926]                           break
[10:34:00.926]                         }
[10:34:00.926]                       }
[10:34:00.926]                     }
[10:34:00.926]                     invisible(muffled)
[10:34:00.926]                   }
[10:34:00.926]                   muffleCondition(cond)
[10:34:00.926]                 })
[10:34:00.926]             }))
[10:34:00.926]             future::FutureResult(value = ...future.value$value, 
[10:34:00.926]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:00.926]                   ...future.rng), globalenv = if (FALSE) 
[10:34:00.926]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:00.926]                     ...future.globalenv.names))
[10:34:00.926]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:00.926]         }, condition = base::local({
[10:34:00.926]             c <- base::c
[10:34:00.926]             inherits <- base::inherits
[10:34:00.926]             invokeRestart <- base::invokeRestart
[10:34:00.926]             length <- base::length
[10:34:00.926]             list <- base::list
[10:34:00.926]             seq.int <- base::seq.int
[10:34:00.926]             signalCondition <- base::signalCondition
[10:34:00.926]             sys.calls <- base::sys.calls
[10:34:00.926]             `[[` <- base::`[[`
[10:34:00.926]             `+` <- base::`+`
[10:34:00.926]             `<<-` <- base::`<<-`
[10:34:00.926]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:00.926]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:00.926]                   3L)]
[10:34:00.926]             }
[10:34:00.926]             function(cond) {
[10:34:00.926]                 is_error <- inherits(cond, "error")
[10:34:00.926]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:00.926]                   NULL)
[10:34:00.926]                 if (is_error) {
[10:34:00.926]                   sessionInformation <- function() {
[10:34:00.926]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:00.926]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:00.926]                       search = base::search(), system = base::Sys.info())
[10:34:00.926]                   }
[10:34:00.926]                   ...future.conditions[[length(...future.conditions) + 
[10:34:00.926]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:00.926]                     cond$call), session = sessionInformation(), 
[10:34:00.926]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:00.926]                   signalCondition(cond)
[10:34:00.926]                 }
[10:34:00.926]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:00.926]                 "immediateCondition"))) {
[10:34:00.926]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:00.926]                   ...future.conditions[[length(...future.conditions) + 
[10:34:00.926]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:00.926]                   if (TRUE && !signal) {
[10:34:00.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:00.926]                     {
[10:34:00.926]                       inherits <- base::inherits
[10:34:00.926]                       invokeRestart <- base::invokeRestart
[10:34:00.926]                       is.null <- base::is.null
[10:34:00.926]                       muffled <- FALSE
[10:34:00.926]                       if (inherits(cond, "message")) {
[10:34:00.926]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:00.926]                         if (muffled) 
[10:34:00.926]                           invokeRestart("muffleMessage")
[10:34:00.926]                       }
[10:34:00.926]                       else if (inherits(cond, "warning")) {
[10:34:00.926]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:00.926]                         if (muffled) 
[10:34:00.926]                           invokeRestart("muffleWarning")
[10:34:00.926]                       }
[10:34:00.926]                       else if (inherits(cond, "condition")) {
[10:34:00.926]                         if (!is.null(pattern)) {
[10:34:00.926]                           computeRestarts <- base::computeRestarts
[10:34:00.926]                           grepl <- base::grepl
[10:34:00.926]                           restarts <- computeRestarts(cond)
[10:34:00.926]                           for (restart in restarts) {
[10:34:00.926]                             name <- restart$name
[10:34:00.926]                             if (is.null(name)) 
[10:34:00.926]                               next
[10:34:00.926]                             if (!grepl(pattern, name)) 
[10:34:00.926]                               next
[10:34:00.926]                             invokeRestart(restart)
[10:34:00.926]                             muffled <- TRUE
[10:34:00.926]                             break
[10:34:00.926]                           }
[10:34:00.926]                         }
[10:34:00.926]                       }
[10:34:00.926]                       invisible(muffled)
[10:34:00.926]                     }
[10:34:00.926]                     muffleCondition(cond, pattern = "^muffle")
[10:34:00.926]                   }
[10:34:00.926]                 }
[10:34:00.926]                 else {
[10:34:00.926]                   if (TRUE) {
[10:34:00.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:00.926]                     {
[10:34:00.926]                       inherits <- base::inherits
[10:34:00.926]                       invokeRestart <- base::invokeRestart
[10:34:00.926]                       is.null <- base::is.null
[10:34:00.926]                       muffled <- FALSE
[10:34:00.926]                       if (inherits(cond, "message")) {
[10:34:00.926]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:00.926]                         if (muffled) 
[10:34:00.926]                           invokeRestart("muffleMessage")
[10:34:00.926]                       }
[10:34:00.926]                       else if (inherits(cond, "warning")) {
[10:34:00.926]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:00.926]                         if (muffled) 
[10:34:00.926]                           invokeRestart("muffleWarning")
[10:34:00.926]                       }
[10:34:00.926]                       else if (inherits(cond, "condition")) {
[10:34:00.926]                         if (!is.null(pattern)) {
[10:34:00.926]                           computeRestarts <- base::computeRestarts
[10:34:00.926]                           grepl <- base::grepl
[10:34:00.926]                           restarts <- computeRestarts(cond)
[10:34:00.926]                           for (restart in restarts) {
[10:34:00.926]                             name <- restart$name
[10:34:00.926]                             if (is.null(name)) 
[10:34:00.926]                               next
[10:34:00.926]                             if (!grepl(pattern, name)) 
[10:34:00.926]                               next
[10:34:00.926]                             invokeRestart(restart)
[10:34:00.926]                             muffled <- TRUE
[10:34:00.926]                             break
[10:34:00.926]                           }
[10:34:00.926]                         }
[10:34:00.926]                       }
[10:34:00.926]                       invisible(muffled)
[10:34:00.926]                     }
[10:34:00.926]                     muffleCondition(cond, pattern = "^muffle")
[10:34:00.926]                   }
[10:34:00.926]                 }
[10:34:00.926]             }
[10:34:00.926]         }))
[10:34:00.926]     }, error = function(ex) {
[10:34:00.926]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:00.926]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:00.926]                 ...future.rng), started = ...future.startTime, 
[10:34:00.926]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:00.926]             version = "1.8"), class = "FutureResult")
[10:34:00.926]     }, finally = {
[10:34:00.926]         if (!identical(...future.workdir, getwd())) 
[10:34:00.926]             setwd(...future.workdir)
[10:34:00.926]         {
[10:34:00.926]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:00.926]                 ...future.oldOptions$nwarnings <- NULL
[10:34:00.926]             }
[10:34:00.926]             base::options(...future.oldOptions)
[10:34:00.926]             if (.Platform$OS.type == "windows") {
[10:34:00.926]                 old_names <- names(...future.oldEnvVars)
[10:34:00.926]                 envs <- base::Sys.getenv()
[10:34:00.926]                 names <- names(envs)
[10:34:00.926]                 common <- intersect(names, old_names)
[10:34:00.926]                 added <- setdiff(names, old_names)
[10:34:00.926]                 removed <- setdiff(old_names, names)
[10:34:00.926]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:00.926]                   envs[common]]
[10:34:00.926]                 NAMES <- toupper(changed)
[10:34:00.926]                 args <- list()
[10:34:00.926]                 for (kk in seq_along(NAMES)) {
[10:34:00.926]                   name <- changed[[kk]]
[10:34:00.926]                   NAME <- NAMES[[kk]]
[10:34:00.926]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:00.926]                     next
[10:34:00.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:00.926]                 }
[10:34:00.926]                 NAMES <- toupper(added)
[10:34:00.926]                 for (kk in seq_along(NAMES)) {
[10:34:00.926]                   name <- added[[kk]]
[10:34:00.926]                   NAME <- NAMES[[kk]]
[10:34:00.926]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:00.926]                     next
[10:34:00.926]                   args[[name]] <- ""
[10:34:00.926]                 }
[10:34:00.926]                 NAMES <- toupper(removed)
[10:34:00.926]                 for (kk in seq_along(NAMES)) {
[10:34:00.926]                   name <- removed[[kk]]
[10:34:00.926]                   NAME <- NAMES[[kk]]
[10:34:00.926]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:00.926]                     next
[10:34:00.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:00.926]                 }
[10:34:00.926]                 if (length(args) > 0) 
[10:34:00.926]                   base::do.call(base::Sys.setenv, args = args)
[10:34:00.926]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:00.926]             }
[10:34:00.926]             else {
[10:34:00.926]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:00.926]             }
[10:34:00.926]             {
[10:34:00.926]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:00.926]                   0L) {
[10:34:00.926]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:00.926]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:00.926]                   base::options(opts)
[10:34:00.926]                 }
[10:34:00.926]                 {
[10:34:00.926]                   {
[10:34:00.926]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:00.926]                     NULL
[10:34:00.926]                   }
[10:34:00.926]                   options(future.plan = NULL)
[10:34:00.926]                   if (is.na(NA_character_)) 
[10:34:00.926]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:00.926]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:00.926]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:00.926]                     .init = FALSE)
[10:34:00.926]                 }
[10:34:00.926]             }
[10:34:00.926]         }
[10:34:00.926]     })
[10:34:00.926]     if (TRUE) {
[10:34:00.926]         base::sink(type = "output", split = FALSE)
[10:34:00.926]         if (TRUE) {
[10:34:00.926]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:00.926]         }
[10:34:00.926]         else {
[10:34:00.926]             ...future.result["stdout"] <- base::list(NULL)
[10:34:00.926]         }
[10:34:00.926]         base::close(...future.stdout)
[10:34:00.926]         ...future.stdout <- NULL
[10:34:00.926]     }
[10:34:00.926]     ...future.result$conditions <- ...future.conditions
[10:34:00.926]     ...future.result$finished <- base::Sys.time()
[10:34:00.926]     ...future.result
[10:34:00.926] }
[10:34:00.930] requestCore(): workers = 2
[10:34:00.930] Poll #1 (0): usedCores() = 2, workers = 2
[10:34:00.941] result() for MulticoreFuture ...
[10:34:00.942] result() for MulticoreFuture ...
[10:34:00.942] result() for MulticoreFuture ... done
[10:34:00.943] result() for MulticoreFuture ... done
[10:34:00.943] result() for MulticoreFuture ...
[10:34:00.943] result() for MulticoreFuture ... done
[10:34:00.945] MulticoreFuture started
[10:34:00.951] - Launch lazy future ... done
[10:34:00.951] plan(): Setting new future strategy stack:
[10:34:00.951] run() for ‘MulticoreFuture’ ... done
[10:34:00.952] List of future strategies:
[10:34:00.952] 1. sequential:
[10:34:00.952]    - args: function (..., envir = parent.frame())
[10:34:00.952]    - tweaked: FALSE
[10:34:00.952]    - call: NULL
[10:34:00.953] plan(): nbrOfWorkers() = 1
[10:34:00.954] resolve() on environment ...
[10:34:00.954]  recursive: 0
[10:34:00.956] plan(): Setting new future strategy stack:
[10:34:00.956]  elements: [3] ‘a’, ‘b’, ‘c’
[10:34:00.957] Future #1
[10:34:00.956] List of future strategies:
[10:34:00.956] 1. multicore:
[10:34:00.956]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:34:00.956]    - tweaked: FALSE
[10:34:00.956]    - call: plan(strategy)
[10:34:00.957]  length: 2 (resolved future 1)
[10:34:00.962] plan(): nbrOfWorkers() = 2
[10:34:00.963] Future #2
[10:34:00.963]  length: 1 (resolved future 2)
[10:34:00.964]  length: 0 (resolved future 3)
[10:34:00.964] resolve() on environment ... DONE
[10:34:00.966] getGlobalsAndPackages() ...
[10:34:00.966] Searching for globals...
[10:34:00.967] - globals found: [1] ‘{’
[10:34:00.967] Searching for globals ... DONE
[10:34:00.967] Resolving globals: FALSE
[10:34:00.968] 
[10:34:00.968] 
[10:34:00.969] getGlobalsAndPackages() ... DONE
[10:34:00.969] run() for ‘Future’ ...
[10:34:00.969] - state: ‘created’
[10:34:00.969] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:34:00.974] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:00.974] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:34:00.974]   - Field: ‘label’
[10:34:00.974]   - Field: ‘local’
[10:34:00.975]   - Field: ‘owner’
[10:34:00.975]   - Field: ‘envir’
[10:34:00.975]   - Field: ‘workers’
[10:34:00.975]   - Field: ‘packages’
[10:34:00.975]   - Field: ‘gc’
[10:34:00.975]   - Field: ‘job’
[10:34:00.976]   - Field: ‘conditions’
[10:34:00.976]   - Field: ‘expr’
[10:34:00.976]   - Field: ‘uuid’
[10:34:00.976]   - Field: ‘seed’
[10:34:00.976]   - Field: ‘version’
[10:34:00.976]   - Field: ‘result’
[10:34:00.976]   - Field: ‘asynchronous’
[10:34:00.976]   - Field: ‘calls’
[10:34:00.977]   - Field: ‘globals’
[10:34:00.977]   - Field: ‘stdout’
[10:34:00.977]   - Field: ‘earlySignal’
[10:34:00.977]   - Field: ‘lazy’
[10:34:00.977]   - Field: ‘state’
[10:34:00.977] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:34:00.977] - Launch lazy future ...
[10:34:00.978] Packages needed by the future expression (n = 0): <none>
[10:34:00.978] Packages needed by future strategies (n = 0): <none>
[10:34:00.979] {
[10:34:00.979]     {
[10:34:00.979]         {
[10:34:00.979]             ...future.startTime <- base::Sys.time()
[10:34:00.979]             {
[10:34:00.979]                 {
[10:34:00.979]                   {
[10:34:00.979]                     {
[10:34:00.979]                       base::local({
[10:34:00.979]                         has_future <- base::requireNamespace("future", 
[10:34:00.979]                           quietly = TRUE)
[10:34:00.979]                         if (has_future) {
[10:34:00.979]                           ns <- base::getNamespace("future")
[10:34:00.979]                           version <- ns[[".package"]][["version"]]
[10:34:00.979]                           if (is.null(version)) 
[10:34:00.979]                             version <- utils::packageVersion("future")
[10:34:00.979]                         }
[10:34:00.979]                         else {
[10:34:00.979]                           version <- NULL
[10:34:00.979]                         }
[10:34:00.979]                         if (!has_future || version < "1.8.0") {
[10:34:00.979]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:00.979]                             "", base::R.version$version.string), 
[10:34:00.979]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:00.979]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:00.979]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:00.979]                               "release", "version")], collapse = " "), 
[10:34:00.979]                             hostname = base::Sys.info()[["nodename"]])
[10:34:00.979]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:00.979]                             info)
[10:34:00.979]                           info <- base::paste(info, collapse = "; ")
[10:34:00.979]                           if (!has_future) {
[10:34:00.979]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:00.979]                               info)
[10:34:00.979]                           }
[10:34:00.979]                           else {
[10:34:00.979]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:00.979]                               info, version)
[10:34:00.979]                           }
[10:34:00.979]                           base::stop(msg)
[10:34:00.979]                         }
[10:34:00.979]                       })
[10:34:00.979]                     }
[10:34:00.979]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:00.979]                     base::options(mc.cores = 1L)
[10:34:00.979]                   }
[10:34:00.979]                   ...future.strategy.old <- future::plan("list")
[10:34:00.979]                   options(future.plan = NULL)
[10:34:00.979]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:00.979]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:00.979]                 }
[10:34:00.979]                 ...future.workdir <- getwd()
[10:34:00.979]             }
[10:34:00.979]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:00.979]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:00.979]         }
[10:34:00.979]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:00.979]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:00.979]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:00.979]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:00.979]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:00.979]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:00.979]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:00.979]             base::names(...future.oldOptions))
[10:34:00.979]     }
[10:34:00.979]     if (FALSE) {
[10:34:00.979]     }
[10:34:00.979]     else {
[10:34:00.979]         if (TRUE) {
[10:34:00.979]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:00.979]                 open = "w")
[10:34:00.979]         }
[10:34:00.979]         else {
[10:34:00.979]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:00.979]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:00.979]         }
[10:34:00.979]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:00.979]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:00.979]             base::sink(type = "output", split = FALSE)
[10:34:00.979]             base::close(...future.stdout)
[10:34:00.979]         }, add = TRUE)
[10:34:00.979]     }
[10:34:00.979]     ...future.frame <- base::sys.nframe()
[10:34:00.979]     ...future.conditions <- base::list()
[10:34:00.979]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:00.979]     if (FALSE) {
[10:34:00.979]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:00.979]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:00.979]     }
[10:34:00.979]     ...future.result <- base::tryCatch({
[10:34:00.979]         base::withCallingHandlers({
[10:34:00.979]             ...future.value <- base::withVisible(base::local({
[10:34:00.979]                 withCallingHandlers({
[10:34:00.979]                   {
[10:34:00.979]                     1
[10:34:00.979]                   }
[10:34:00.979]                 }, immediateCondition = function(cond) {
[10:34:00.979]                   save_rds <- function (object, pathname, ...) 
[10:34:00.979]                   {
[10:34:00.979]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:34:00.979]                     if (file_test("-f", pathname_tmp)) {
[10:34:00.979]                       fi_tmp <- file.info(pathname_tmp)
[10:34:00.979]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:34:00.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:00.979]                         fi_tmp[["mtime"]])
[10:34:00.979]                     }
[10:34:00.979]                     tryCatch({
[10:34:00.979]                       saveRDS(object, file = pathname_tmp, ...)
[10:34:00.979]                     }, error = function(ex) {
[10:34:00.979]                       msg <- conditionMessage(ex)
[10:34:00.979]                       fi_tmp <- file.info(pathname_tmp)
[10:34:00.979]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:34:00.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:00.979]                         fi_tmp[["mtime"]], msg)
[10:34:00.979]                       ex$message <- msg
[10:34:00.979]                       stop(ex)
[10:34:00.979]                     })
[10:34:00.979]                     stopifnot(file_test("-f", pathname_tmp))
[10:34:00.979]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:34:00.979]                     if (!res || file_test("-f", pathname_tmp)) {
[10:34:00.979]                       fi_tmp <- file.info(pathname_tmp)
[10:34:00.979]                       fi <- file.info(pathname)
[10:34:00.979]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:34:00.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:00.979]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:34:00.979]                         fi[["size"]], fi[["mtime"]])
[10:34:00.979]                       stop(msg)
[10:34:00.979]                     }
[10:34:00.979]                     invisible(pathname)
[10:34:00.979]                   }
[10:34:00.979]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:34:00.979]                     rootPath = tempdir()) 
[10:34:00.979]                   {
[10:34:00.979]                     obj <- list(time = Sys.time(), condition = cond)
[10:34:00.979]                     file <- tempfile(pattern = class(cond)[1], 
[10:34:00.979]                       tmpdir = path, fileext = ".rds")
[10:34:00.979]                     save_rds(obj, file)
[10:34:00.979]                   }
[10:34:00.979]                   saveImmediateCondition(cond, path = "/tmp/RtmpuZEzLw/.future/immediateConditions")
[10:34:00.979]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:00.979]                   {
[10:34:00.979]                     inherits <- base::inherits
[10:34:00.979]                     invokeRestart <- base::invokeRestart
[10:34:00.979]                     is.null <- base::is.null
[10:34:00.979]                     muffled <- FALSE
[10:34:00.979]                     if (inherits(cond, "message")) {
[10:34:00.979]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:00.979]                       if (muffled) 
[10:34:00.979]                         invokeRestart("muffleMessage")
[10:34:00.979]                     }
[10:34:00.979]                     else if (inherits(cond, "warning")) {
[10:34:00.979]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:00.979]                       if (muffled) 
[10:34:00.979]                         invokeRestart("muffleWarning")
[10:34:00.979]                     }
[10:34:00.979]                     else if (inherits(cond, "condition")) {
[10:34:00.979]                       if (!is.null(pattern)) {
[10:34:00.979]                         computeRestarts <- base::computeRestarts
[10:34:00.979]                         grepl <- base::grepl
[10:34:00.979]                         restarts <- computeRestarts(cond)
[10:34:00.979]                         for (restart in restarts) {
[10:34:00.979]                           name <- restart$name
[10:34:00.979]                           if (is.null(name)) 
[10:34:00.979]                             next
[10:34:00.979]                           if (!grepl(pattern, name)) 
[10:34:00.979]                             next
[10:34:00.979]                           invokeRestart(restart)
[10:34:00.979]                           muffled <- TRUE
[10:34:00.979]                           break
[10:34:00.979]                         }
[10:34:00.979]                       }
[10:34:00.979]                     }
[10:34:00.979]                     invisible(muffled)
[10:34:00.979]                   }
[10:34:00.979]                   muffleCondition(cond)
[10:34:00.979]                 })
[10:34:00.979]             }))
[10:34:00.979]             future::FutureResult(value = ...future.value$value, 
[10:34:00.979]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:00.979]                   ...future.rng), globalenv = if (FALSE) 
[10:34:00.979]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:00.979]                     ...future.globalenv.names))
[10:34:00.979]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:00.979]         }, condition = base::local({
[10:34:00.979]             c <- base::c
[10:34:00.979]             inherits <- base::inherits
[10:34:00.979]             invokeRestart <- base::invokeRestart
[10:34:00.979]             length <- base::length
[10:34:00.979]             list <- base::list
[10:34:00.979]             seq.int <- base::seq.int
[10:34:00.979]             signalCondition <- base::signalCondition
[10:34:00.979]             sys.calls <- base::sys.calls
[10:34:00.979]             `[[` <- base::`[[`
[10:34:00.979]             `+` <- base::`+`
[10:34:00.979]             `<<-` <- base::`<<-`
[10:34:00.979]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:00.979]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:00.979]                   3L)]
[10:34:00.979]             }
[10:34:00.979]             function(cond) {
[10:34:00.979]                 is_error <- inherits(cond, "error")
[10:34:00.979]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:00.979]                   NULL)
[10:34:00.979]                 if (is_error) {
[10:34:00.979]                   sessionInformation <- function() {
[10:34:00.979]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:00.979]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:00.979]                       search = base::search(), system = base::Sys.info())
[10:34:00.979]                   }
[10:34:00.979]                   ...future.conditions[[length(...future.conditions) + 
[10:34:00.979]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:00.979]                     cond$call), session = sessionInformation(), 
[10:34:00.979]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:00.979]                   signalCondition(cond)
[10:34:00.979]                 }
[10:34:00.979]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:00.979]                 "immediateCondition"))) {
[10:34:00.979]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:00.979]                   ...future.conditions[[length(...future.conditions) + 
[10:34:00.979]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:00.979]                   if (TRUE && !signal) {
[10:34:00.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:00.979]                     {
[10:34:00.979]                       inherits <- base::inherits
[10:34:00.979]                       invokeRestart <- base::invokeRestart
[10:34:00.979]                       is.null <- base::is.null
[10:34:00.979]                       muffled <- FALSE
[10:34:00.979]                       if (inherits(cond, "message")) {
[10:34:00.979]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:00.979]                         if (muffled) 
[10:34:00.979]                           invokeRestart("muffleMessage")
[10:34:00.979]                       }
[10:34:00.979]                       else if (inherits(cond, "warning")) {
[10:34:00.979]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:00.979]                         if (muffled) 
[10:34:00.979]                           invokeRestart("muffleWarning")
[10:34:00.979]                       }
[10:34:00.979]                       else if (inherits(cond, "condition")) {
[10:34:00.979]                         if (!is.null(pattern)) {
[10:34:00.979]                           computeRestarts <- base::computeRestarts
[10:34:00.979]                           grepl <- base::grepl
[10:34:00.979]                           restarts <- computeRestarts(cond)
[10:34:00.979]                           for (restart in restarts) {
[10:34:00.979]                             name <- restart$name
[10:34:00.979]                             if (is.null(name)) 
[10:34:00.979]                               next
[10:34:00.979]                             if (!grepl(pattern, name)) 
[10:34:00.979]                               next
[10:34:00.979]                             invokeRestart(restart)
[10:34:00.979]                             muffled <- TRUE
[10:34:00.979]                             break
[10:34:00.979]                           }
[10:34:00.979]                         }
[10:34:00.979]                       }
[10:34:00.979]                       invisible(muffled)
[10:34:00.979]                     }
[10:34:00.979]                     muffleCondition(cond, pattern = "^muffle")
[10:34:00.979]                   }
[10:34:00.979]                 }
[10:34:00.979]                 else {
[10:34:00.979]                   if (TRUE) {
[10:34:00.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:00.979]                     {
[10:34:00.979]                       inherits <- base::inherits
[10:34:00.979]                       invokeRestart <- base::invokeRestart
[10:34:00.979]                       is.null <- base::is.null
[10:34:00.979]                       muffled <- FALSE
[10:34:00.979]                       if (inherits(cond, "message")) {
[10:34:00.979]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:00.979]                         if (muffled) 
[10:34:00.979]                           invokeRestart("muffleMessage")
[10:34:00.979]                       }
[10:34:00.979]                       else if (inherits(cond, "warning")) {
[10:34:00.979]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:00.979]                         if (muffled) 
[10:34:00.979]                           invokeRestart("muffleWarning")
[10:34:00.979]                       }
[10:34:00.979]                       else if (inherits(cond, "condition")) {
[10:34:00.979]                         if (!is.null(pattern)) {
[10:34:00.979]                           computeRestarts <- base::computeRestarts
[10:34:00.979]                           grepl <- base::grepl
[10:34:00.979]                           restarts <- computeRestarts(cond)
[10:34:00.979]                           for (restart in restarts) {
[10:34:00.979]                             name <- restart$name
[10:34:00.979]                             if (is.null(name)) 
[10:34:00.979]                               next
[10:34:00.979]                             if (!grepl(pattern, name)) 
[10:34:00.979]                               next
[10:34:00.979]                             invokeRestart(restart)
[10:34:00.979]                             muffled <- TRUE
[10:34:00.979]                             break
[10:34:00.979]                           }
[10:34:00.979]                         }
[10:34:00.979]                       }
[10:34:00.979]                       invisible(muffled)
[10:34:00.979]                     }
[10:34:00.979]                     muffleCondition(cond, pattern = "^muffle")
[10:34:00.979]                   }
[10:34:00.979]                 }
[10:34:00.979]             }
[10:34:00.979]         }))
[10:34:00.979]     }, error = function(ex) {
[10:34:00.979]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:00.979]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:00.979]                 ...future.rng), started = ...future.startTime, 
[10:34:00.979]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:00.979]             version = "1.8"), class = "FutureResult")
[10:34:00.979]     }, finally = {
[10:34:00.979]         if (!identical(...future.workdir, getwd())) 
[10:34:00.979]             setwd(...future.workdir)
[10:34:00.979]         {
[10:34:00.979]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:00.979]                 ...future.oldOptions$nwarnings <- NULL
[10:34:00.979]             }
[10:34:00.979]             base::options(...future.oldOptions)
[10:34:00.979]             if (.Platform$OS.type == "windows") {
[10:34:00.979]                 old_names <- names(...future.oldEnvVars)
[10:34:00.979]                 envs <- base::Sys.getenv()
[10:34:00.979]                 names <- names(envs)
[10:34:00.979]                 common <- intersect(names, old_names)
[10:34:00.979]                 added <- setdiff(names, old_names)
[10:34:00.979]                 removed <- setdiff(old_names, names)
[10:34:00.979]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:00.979]                   envs[common]]
[10:34:00.979]                 NAMES <- toupper(changed)
[10:34:00.979]                 args <- list()
[10:34:00.979]                 for (kk in seq_along(NAMES)) {
[10:34:00.979]                   name <- changed[[kk]]
[10:34:00.979]                   NAME <- NAMES[[kk]]
[10:34:00.979]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:00.979]                     next
[10:34:00.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:00.979]                 }
[10:34:00.979]                 NAMES <- toupper(added)
[10:34:00.979]                 for (kk in seq_along(NAMES)) {
[10:34:00.979]                   name <- added[[kk]]
[10:34:00.979]                   NAME <- NAMES[[kk]]
[10:34:00.979]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:00.979]                     next
[10:34:00.979]                   args[[name]] <- ""
[10:34:00.979]                 }
[10:34:00.979]                 NAMES <- toupper(removed)
[10:34:00.979]                 for (kk in seq_along(NAMES)) {
[10:34:00.979]                   name <- removed[[kk]]
[10:34:00.979]                   NAME <- NAMES[[kk]]
[10:34:00.979]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:00.979]                     next
[10:34:00.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:00.979]                 }
[10:34:00.979]                 if (length(args) > 0) 
[10:34:00.979]                   base::do.call(base::Sys.setenv, args = args)
[10:34:00.979]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:00.979]             }
[10:34:00.979]             else {
[10:34:00.979]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:00.979]             }
[10:34:00.979]             {
[10:34:00.979]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:00.979]                   0L) {
[10:34:00.979]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:00.979]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:00.979]                   base::options(opts)
[10:34:00.979]                 }
[10:34:00.979]                 {
[10:34:00.979]                   {
[10:34:00.979]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:00.979]                     NULL
[10:34:00.979]                   }
[10:34:00.979]                   options(future.plan = NULL)
[10:34:00.979]                   if (is.na(NA_character_)) 
[10:34:00.979]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:00.979]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:00.979]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:00.979]                     .init = FALSE)
[10:34:00.979]                 }
[10:34:00.979]             }
[10:34:00.979]         }
[10:34:00.979]     })
[10:34:00.979]     if (TRUE) {
[10:34:00.979]         base::sink(type = "output", split = FALSE)
[10:34:00.979]         if (TRUE) {
[10:34:00.979]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:00.979]         }
[10:34:00.979]         else {
[10:34:00.979]             ...future.result["stdout"] <- base::list(NULL)
[10:34:00.979]         }
[10:34:00.979]         base::close(...future.stdout)
[10:34:00.979]         ...future.stdout <- NULL
[10:34:00.979]     }
[10:34:00.979]     ...future.result$conditions <- ...future.conditions
[10:34:00.979]     ...future.result$finished <- base::Sys.time()
[10:34:00.979]     ...future.result
[10:34:00.979] }
[10:34:00.981] requestCore(): workers = 2
[10:34:00.982] Poll #1 (0): usedCores() = 2, workers = 2
[10:34:00.992] result() for MulticoreFuture ...
[10:34:00.993] result() for MulticoreFuture ...
[10:34:00.993] result() for MulticoreFuture ... done
[10:34:00.993] result() for MulticoreFuture ... done
[10:34:00.994] result() for MulticoreFuture ...
[10:34:00.994] result() for MulticoreFuture ... done
[10:34:00.996] MulticoreFuture started
[10:34:00.996] - Launch lazy future ... done
[10:34:00.997] run() for ‘MulticoreFuture’ ... done
[10:34:00.998] plan(): Setting new future strategy stack:
[10:34:00.998] getGlobalsAndPackages() ...
[10:34:00.998] Searching for globals...
[10:34:00.998] List of future strategies:
[10:34:00.998] 1. sequential:
[10:34:00.998]    - args: function (..., envir = parent.frame())
[10:34:00.998]    - tweaked: FALSE
[10:34:00.998]    - call: NULL
[10:34:00.999] plan(): nbrOfWorkers() = 1
[10:34:01.000] - globals found: [1] ‘{’
[10:34:01.001] Searching for globals ... DONE
[10:34:01.001] Resolving globals: FALSE
[10:34:01.002] 
[10:34:01.002] 
[10:34:01.002] plan(): Setting new future strategy stack:
[10:34:01.002] getGlobalsAndPackages() ... DONE
[10:34:01.003] run() for ‘Future’ ...
[10:34:01.003] List of future strategies:
[10:34:01.003] 1. multicore:
[10:34:01.003]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:34:01.003]    - tweaked: FALSE
[10:34:01.003]    - call: plan(strategy)
[10:34:01.003] - state: ‘created’
[10:34:01.004] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:34:01.009] plan(): nbrOfWorkers() = 2
[10:34:01.010] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:01.010] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:34:01.010]   - Field: ‘label’
[10:34:01.010]   - Field: ‘local’
[10:34:01.010]   - Field: ‘owner’
[10:34:01.010]   - Field: ‘envir’
[10:34:01.011]   - Field: ‘workers’
[10:34:01.011]   - Field: ‘packages’
[10:34:01.011]   - Field: ‘gc’
[10:34:01.011]   - Field: ‘job’
[10:34:01.011]   - Field: ‘conditions’
[10:34:01.011]   - Field: ‘expr’
[10:34:01.011]   - Field: ‘uuid’
[10:34:01.012]   - Field: ‘seed’
[10:34:01.012]   - Field: ‘version’
[10:34:01.012]   - Field: ‘result’
[10:34:01.012]   - Field: ‘asynchronous’
[10:34:01.012]   - Field: ‘calls’
[10:34:01.012]   - Field: ‘globals’
[10:34:01.012]   - Field: ‘stdout’
[10:34:01.013]   - Field: ‘earlySignal’
[10:34:01.013]   - Field: ‘lazy’
[10:34:01.013]   - Field: ‘state’
[10:34:01.013] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:34:01.013] - Launch lazy future ...
[10:34:01.014] Packages needed by the future expression (n = 0): <none>
[10:34:01.014] Packages needed by future strategies (n = 0): <none>
[10:34:01.015] {
[10:34:01.015]     {
[10:34:01.015]         {
[10:34:01.015]             ...future.startTime <- base::Sys.time()
[10:34:01.015]             {
[10:34:01.015]                 {
[10:34:01.015]                   {
[10:34:01.015]                     {
[10:34:01.015]                       base::local({
[10:34:01.015]                         has_future <- base::requireNamespace("future", 
[10:34:01.015]                           quietly = TRUE)
[10:34:01.015]                         if (has_future) {
[10:34:01.015]                           ns <- base::getNamespace("future")
[10:34:01.015]                           version <- ns[[".package"]][["version"]]
[10:34:01.015]                           if (is.null(version)) 
[10:34:01.015]                             version <- utils::packageVersion("future")
[10:34:01.015]                         }
[10:34:01.015]                         else {
[10:34:01.015]                           version <- NULL
[10:34:01.015]                         }
[10:34:01.015]                         if (!has_future || version < "1.8.0") {
[10:34:01.015]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:01.015]                             "", base::R.version$version.string), 
[10:34:01.015]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:01.015]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:01.015]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:01.015]                               "release", "version")], collapse = " "), 
[10:34:01.015]                             hostname = base::Sys.info()[["nodename"]])
[10:34:01.015]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:01.015]                             info)
[10:34:01.015]                           info <- base::paste(info, collapse = "; ")
[10:34:01.015]                           if (!has_future) {
[10:34:01.015]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:01.015]                               info)
[10:34:01.015]                           }
[10:34:01.015]                           else {
[10:34:01.015]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:01.015]                               info, version)
[10:34:01.015]                           }
[10:34:01.015]                           base::stop(msg)
[10:34:01.015]                         }
[10:34:01.015]                       })
[10:34:01.015]                     }
[10:34:01.015]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:01.015]                     base::options(mc.cores = 1L)
[10:34:01.015]                   }
[10:34:01.015]                   ...future.strategy.old <- future::plan("list")
[10:34:01.015]                   options(future.plan = NULL)
[10:34:01.015]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:01.015]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:01.015]                 }
[10:34:01.015]                 ...future.workdir <- getwd()
[10:34:01.015]             }
[10:34:01.015]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:01.015]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:01.015]         }
[10:34:01.015]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:01.015]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:01.015]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:01.015]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:01.015]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:01.015]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:01.015]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:01.015]             base::names(...future.oldOptions))
[10:34:01.015]     }
[10:34:01.015]     if (FALSE) {
[10:34:01.015]     }
[10:34:01.015]     else {
[10:34:01.015]         if (TRUE) {
[10:34:01.015]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:01.015]                 open = "w")
[10:34:01.015]         }
[10:34:01.015]         else {
[10:34:01.015]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:01.015]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:01.015]         }
[10:34:01.015]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:01.015]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:01.015]             base::sink(type = "output", split = FALSE)
[10:34:01.015]             base::close(...future.stdout)
[10:34:01.015]         }, add = TRUE)
[10:34:01.015]     }
[10:34:01.015]     ...future.frame <- base::sys.nframe()
[10:34:01.015]     ...future.conditions <- base::list()
[10:34:01.015]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:01.015]     if (FALSE) {
[10:34:01.015]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:01.015]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:01.015]     }
[10:34:01.015]     ...future.result <- base::tryCatch({
[10:34:01.015]         base::withCallingHandlers({
[10:34:01.015]             ...future.value <- base::withVisible(base::local({
[10:34:01.015]                 withCallingHandlers({
[10:34:01.015]                   {
[10:34:01.015]                     2
[10:34:01.015]                   }
[10:34:01.015]                 }, immediateCondition = function(cond) {
[10:34:01.015]                   save_rds <- function (object, pathname, ...) 
[10:34:01.015]                   {
[10:34:01.015]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:34:01.015]                     if (file_test("-f", pathname_tmp)) {
[10:34:01.015]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.015]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:34:01.015]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.015]                         fi_tmp[["mtime"]])
[10:34:01.015]                     }
[10:34:01.015]                     tryCatch({
[10:34:01.015]                       saveRDS(object, file = pathname_tmp, ...)
[10:34:01.015]                     }, error = function(ex) {
[10:34:01.015]                       msg <- conditionMessage(ex)
[10:34:01.015]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.015]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:34:01.015]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.015]                         fi_tmp[["mtime"]], msg)
[10:34:01.015]                       ex$message <- msg
[10:34:01.015]                       stop(ex)
[10:34:01.015]                     })
[10:34:01.015]                     stopifnot(file_test("-f", pathname_tmp))
[10:34:01.015]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:34:01.015]                     if (!res || file_test("-f", pathname_tmp)) {
[10:34:01.015]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.015]                       fi <- file.info(pathname)
[10:34:01.015]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:34:01.015]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.015]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:34:01.015]                         fi[["size"]], fi[["mtime"]])
[10:34:01.015]                       stop(msg)
[10:34:01.015]                     }
[10:34:01.015]                     invisible(pathname)
[10:34:01.015]                   }
[10:34:01.015]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:34:01.015]                     rootPath = tempdir()) 
[10:34:01.015]                   {
[10:34:01.015]                     obj <- list(time = Sys.time(), condition = cond)
[10:34:01.015]                     file <- tempfile(pattern = class(cond)[1], 
[10:34:01.015]                       tmpdir = path, fileext = ".rds")
[10:34:01.015]                     save_rds(obj, file)
[10:34:01.015]                   }
[10:34:01.015]                   saveImmediateCondition(cond, path = "/tmp/RtmpuZEzLw/.future/immediateConditions")
[10:34:01.015]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.015]                   {
[10:34:01.015]                     inherits <- base::inherits
[10:34:01.015]                     invokeRestart <- base::invokeRestart
[10:34:01.015]                     is.null <- base::is.null
[10:34:01.015]                     muffled <- FALSE
[10:34:01.015]                     if (inherits(cond, "message")) {
[10:34:01.015]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:01.015]                       if (muffled) 
[10:34:01.015]                         invokeRestart("muffleMessage")
[10:34:01.015]                     }
[10:34:01.015]                     else if (inherits(cond, "warning")) {
[10:34:01.015]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:01.015]                       if (muffled) 
[10:34:01.015]                         invokeRestart("muffleWarning")
[10:34:01.015]                     }
[10:34:01.015]                     else if (inherits(cond, "condition")) {
[10:34:01.015]                       if (!is.null(pattern)) {
[10:34:01.015]                         computeRestarts <- base::computeRestarts
[10:34:01.015]                         grepl <- base::grepl
[10:34:01.015]                         restarts <- computeRestarts(cond)
[10:34:01.015]                         for (restart in restarts) {
[10:34:01.015]                           name <- restart$name
[10:34:01.015]                           if (is.null(name)) 
[10:34:01.015]                             next
[10:34:01.015]                           if (!grepl(pattern, name)) 
[10:34:01.015]                             next
[10:34:01.015]                           invokeRestart(restart)
[10:34:01.015]                           muffled <- TRUE
[10:34:01.015]                           break
[10:34:01.015]                         }
[10:34:01.015]                       }
[10:34:01.015]                     }
[10:34:01.015]                     invisible(muffled)
[10:34:01.015]                   }
[10:34:01.015]                   muffleCondition(cond)
[10:34:01.015]                 })
[10:34:01.015]             }))
[10:34:01.015]             future::FutureResult(value = ...future.value$value, 
[10:34:01.015]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:01.015]                   ...future.rng), globalenv = if (FALSE) 
[10:34:01.015]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:01.015]                     ...future.globalenv.names))
[10:34:01.015]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:01.015]         }, condition = base::local({
[10:34:01.015]             c <- base::c
[10:34:01.015]             inherits <- base::inherits
[10:34:01.015]             invokeRestart <- base::invokeRestart
[10:34:01.015]             length <- base::length
[10:34:01.015]             list <- base::list
[10:34:01.015]             seq.int <- base::seq.int
[10:34:01.015]             signalCondition <- base::signalCondition
[10:34:01.015]             sys.calls <- base::sys.calls
[10:34:01.015]             `[[` <- base::`[[`
[10:34:01.015]             `+` <- base::`+`
[10:34:01.015]             `<<-` <- base::`<<-`
[10:34:01.015]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:01.015]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:01.015]                   3L)]
[10:34:01.015]             }
[10:34:01.015]             function(cond) {
[10:34:01.015]                 is_error <- inherits(cond, "error")
[10:34:01.015]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:01.015]                   NULL)
[10:34:01.015]                 if (is_error) {
[10:34:01.015]                   sessionInformation <- function() {
[10:34:01.015]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:01.015]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:01.015]                       search = base::search(), system = base::Sys.info())
[10:34:01.015]                   }
[10:34:01.015]                   ...future.conditions[[length(...future.conditions) + 
[10:34:01.015]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:01.015]                     cond$call), session = sessionInformation(), 
[10:34:01.015]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:01.015]                   signalCondition(cond)
[10:34:01.015]                 }
[10:34:01.015]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:01.015]                 "immediateCondition"))) {
[10:34:01.015]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:01.015]                   ...future.conditions[[length(...future.conditions) + 
[10:34:01.015]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:01.015]                   if (TRUE && !signal) {
[10:34:01.015]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.015]                     {
[10:34:01.015]                       inherits <- base::inherits
[10:34:01.015]                       invokeRestart <- base::invokeRestart
[10:34:01.015]                       is.null <- base::is.null
[10:34:01.015]                       muffled <- FALSE
[10:34:01.015]                       if (inherits(cond, "message")) {
[10:34:01.015]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:01.015]                         if (muffled) 
[10:34:01.015]                           invokeRestart("muffleMessage")
[10:34:01.015]                       }
[10:34:01.015]                       else if (inherits(cond, "warning")) {
[10:34:01.015]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:01.015]                         if (muffled) 
[10:34:01.015]                           invokeRestart("muffleWarning")
[10:34:01.015]                       }
[10:34:01.015]                       else if (inherits(cond, "condition")) {
[10:34:01.015]                         if (!is.null(pattern)) {
[10:34:01.015]                           computeRestarts <- base::computeRestarts
[10:34:01.015]                           grepl <- base::grepl
[10:34:01.015]                           restarts <- computeRestarts(cond)
[10:34:01.015]                           for (restart in restarts) {
[10:34:01.015]                             name <- restart$name
[10:34:01.015]                             if (is.null(name)) 
[10:34:01.015]                               next
[10:34:01.015]                             if (!grepl(pattern, name)) 
[10:34:01.015]                               next
[10:34:01.015]                             invokeRestart(restart)
[10:34:01.015]                             muffled <- TRUE
[10:34:01.015]                             break
[10:34:01.015]                           }
[10:34:01.015]                         }
[10:34:01.015]                       }
[10:34:01.015]                       invisible(muffled)
[10:34:01.015]                     }
[10:34:01.015]                     muffleCondition(cond, pattern = "^muffle")
[10:34:01.015]                   }
[10:34:01.015]                 }
[10:34:01.015]                 else {
[10:34:01.015]                   if (TRUE) {
[10:34:01.015]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.015]                     {
[10:34:01.015]                       inherits <- base::inherits
[10:34:01.015]                       invokeRestart <- base::invokeRestart
[10:34:01.015]                       is.null <- base::is.null
[10:34:01.015]                       muffled <- FALSE
[10:34:01.015]                       if (inherits(cond, "message")) {
[10:34:01.015]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:01.015]                         if (muffled) 
[10:34:01.015]                           invokeRestart("muffleMessage")
[10:34:01.015]                       }
[10:34:01.015]                       else if (inherits(cond, "warning")) {
[10:34:01.015]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:01.015]                         if (muffled) 
[10:34:01.015]                           invokeRestart("muffleWarning")
[10:34:01.015]                       }
[10:34:01.015]                       else if (inherits(cond, "condition")) {
[10:34:01.015]                         if (!is.null(pattern)) {
[10:34:01.015]                           computeRestarts <- base::computeRestarts
[10:34:01.015]                           grepl <- base::grepl
[10:34:01.015]                           restarts <- computeRestarts(cond)
[10:34:01.015]                           for (restart in restarts) {
[10:34:01.015]                             name <- restart$name
[10:34:01.015]                             if (is.null(name)) 
[10:34:01.015]                               next
[10:34:01.015]                             if (!grepl(pattern, name)) 
[10:34:01.015]                               next
[10:34:01.015]                             invokeRestart(restart)
[10:34:01.015]                             muffled <- TRUE
[10:34:01.015]                             break
[10:34:01.015]                           }
[10:34:01.015]                         }
[10:34:01.015]                       }
[10:34:01.015]                       invisible(muffled)
[10:34:01.015]                     }
[10:34:01.015]                     muffleCondition(cond, pattern = "^muffle")
[10:34:01.015]                   }
[10:34:01.015]                 }
[10:34:01.015]             }
[10:34:01.015]         }))
[10:34:01.015]     }, error = function(ex) {
[10:34:01.015]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:01.015]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:01.015]                 ...future.rng), started = ...future.startTime, 
[10:34:01.015]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:01.015]             version = "1.8"), class = "FutureResult")
[10:34:01.015]     }, finally = {
[10:34:01.015]         if (!identical(...future.workdir, getwd())) 
[10:34:01.015]             setwd(...future.workdir)
[10:34:01.015]         {
[10:34:01.015]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:01.015]                 ...future.oldOptions$nwarnings <- NULL
[10:34:01.015]             }
[10:34:01.015]             base::options(...future.oldOptions)
[10:34:01.015]             if (.Platform$OS.type == "windows") {
[10:34:01.015]                 old_names <- names(...future.oldEnvVars)
[10:34:01.015]                 envs <- base::Sys.getenv()
[10:34:01.015]                 names <- names(envs)
[10:34:01.015]                 common <- intersect(names, old_names)
[10:34:01.015]                 added <- setdiff(names, old_names)
[10:34:01.015]                 removed <- setdiff(old_names, names)
[10:34:01.015]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:01.015]                   envs[common]]
[10:34:01.015]                 NAMES <- toupper(changed)
[10:34:01.015]                 args <- list()
[10:34:01.015]                 for (kk in seq_along(NAMES)) {
[10:34:01.015]                   name <- changed[[kk]]
[10:34:01.015]                   NAME <- NAMES[[kk]]
[10:34:01.015]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.015]                     next
[10:34:01.015]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:01.015]                 }
[10:34:01.015]                 NAMES <- toupper(added)
[10:34:01.015]                 for (kk in seq_along(NAMES)) {
[10:34:01.015]                   name <- added[[kk]]
[10:34:01.015]                   NAME <- NAMES[[kk]]
[10:34:01.015]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.015]                     next
[10:34:01.015]                   args[[name]] <- ""
[10:34:01.015]                 }
[10:34:01.015]                 NAMES <- toupper(removed)
[10:34:01.015]                 for (kk in seq_along(NAMES)) {
[10:34:01.015]                   name <- removed[[kk]]
[10:34:01.015]                   NAME <- NAMES[[kk]]
[10:34:01.015]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.015]                     next
[10:34:01.015]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:01.015]                 }
[10:34:01.015]                 if (length(args) > 0) 
[10:34:01.015]                   base::do.call(base::Sys.setenv, args = args)
[10:34:01.015]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:01.015]             }
[10:34:01.015]             else {
[10:34:01.015]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:01.015]             }
[10:34:01.015]             {
[10:34:01.015]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:01.015]                   0L) {
[10:34:01.015]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:01.015]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:01.015]                   base::options(opts)
[10:34:01.015]                 }
[10:34:01.015]                 {
[10:34:01.015]                   {
[10:34:01.015]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:01.015]                     NULL
[10:34:01.015]                   }
[10:34:01.015]                   options(future.plan = NULL)
[10:34:01.015]                   if (is.na(NA_character_)) 
[10:34:01.015]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:01.015]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:01.015]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:01.015]                     .init = FALSE)
[10:34:01.015]                 }
[10:34:01.015]             }
[10:34:01.015]         }
[10:34:01.015]     })
[10:34:01.015]     if (TRUE) {
[10:34:01.015]         base::sink(type = "output", split = FALSE)
[10:34:01.015]         if (TRUE) {
[10:34:01.015]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:01.015]         }
[10:34:01.015]         else {
[10:34:01.015]             ...future.result["stdout"] <- base::list(NULL)
[10:34:01.015]         }
[10:34:01.015]         base::close(...future.stdout)
[10:34:01.015]         ...future.stdout <- NULL
[10:34:01.015]     }
[10:34:01.015]     ...future.result$conditions <- ...future.conditions
[10:34:01.015]     ...future.result$finished <- base::Sys.time()
[10:34:01.015]     ...future.result
[10:34:01.015] }
[10:34:01.018] requestCore(): workers = 2
[10:34:01.019] Poll #1 (0): usedCores() = 2, workers = 2
[10:34:01.030] result() for MulticoreFuture ...
[10:34:01.030] result() for MulticoreFuture ...
[10:34:01.031] result() for MulticoreFuture ... done
[10:34:01.031] result() for MulticoreFuture ... done
[10:34:01.031] result() for MulticoreFuture ...
[10:34:01.031] result() for MulticoreFuture ... done
[10:34:01.034] MulticoreFuture started
[10:34:01.034] - Launch lazy future ... done
[10:34:01.034] run() for ‘MulticoreFuture’ ... done
[10:34:01.035] plan(): Setting new future strategy stack:
[10:34:01.036] List of future strategies:
[10:34:01.036] 1. sequential:
[10:34:01.036]    - args: function (..., envir = parent.frame())
[10:34:01.036]    - tweaked: FALSE
[10:34:01.036]    - call: NULL
[10:34:01.037] resolve() on environment ...
[10:34:01.037] plan(): nbrOfWorkers() = 1
[10:34:01.037]  recursive: 0
[10:34:01.038]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[10:34:01.039] Future #1
[10:34:01.039]  length: 2 (resolved future 1)
[10:34:01.040] plan(): Setting new future strategy stack:
[10:34:01.040] List of future strategies:
[10:34:01.040] 1. multicore:
[10:34:01.040]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:34:01.040]    - tweaked: FALSE
[10:34:01.040]    - call: plan(strategy)
[10:34:01.045] plan(): nbrOfWorkers() = 2
[10:34:01.046] Future #2
[10:34:01.046]  length: 1 (resolved future 2)
[10:34:01.046]  length: 0 (resolved future 3)
[10:34:01.046] resolve() on environment ... DONE
[10:34:01.047] getGlobalsAndPackages() ...
[10:34:01.047] Searching for globals...
[10:34:01.054] - globals found: [1] ‘{’
[10:34:01.055] Searching for globals ... DONE
[10:34:01.055] Resolving globals: FALSE
[10:34:01.056] 
[10:34:01.056] 
[10:34:01.057] getGlobalsAndPackages() ... DONE
[10:34:01.057] run() for ‘Future’ ...
[10:34:01.058] - state: ‘created’
[10:34:01.058] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:34:01.063] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:01.064] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:34:01.064]   - Field: ‘label’
[10:34:01.064]   - Field: ‘local’
[10:34:01.064]   - Field: ‘owner’
[10:34:01.064]   - Field: ‘envir’
[10:34:01.065]   - Field: ‘workers’
[10:34:01.065]   - Field: ‘packages’
[10:34:01.065]   - Field: ‘gc’
[10:34:01.065]   - Field: ‘job’
[10:34:01.065]   - Field: ‘conditions’
[10:34:01.065]   - Field: ‘expr’
[10:34:01.066]   - Field: ‘uuid’
[10:34:01.066]   - Field: ‘seed’
[10:34:01.066]   - Field: ‘version’
[10:34:01.066]   - Field: ‘result’
[10:34:01.067]   - Field: ‘asynchronous’
[10:34:01.067]   - Field: ‘calls’
[10:34:01.067]   - Field: ‘globals’
[10:34:01.067]   - Field: ‘stdout’
[10:34:01.067]   - Field: ‘earlySignal’
[10:34:01.068]   - Field: ‘lazy’
[10:34:01.068]   - Field: ‘state’
[10:34:01.068] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:34:01.068] - Launch lazy future ...
[10:34:01.068] Packages needed by the future expression (n = 0): <none>
[10:34:01.069] Packages needed by future strategies (n = 0): <none>
[10:34:01.069] {
[10:34:01.069]     {
[10:34:01.069]         {
[10:34:01.069]             ...future.startTime <- base::Sys.time()
[10:34:01.069]             {
[10:34:01.069]                 {
[10:34:01.069]                   {
[10:34:01.069]                     {
[10:34:01.069]                       base::local({
[10:34:01.069]                         has_future <- base::requireNamespace("future", 
[10:34:01.069]                           quietly = TRUE)
[10:34:01.069]                         if (has_future) {
[10:34:01.069]                           ns <- base::getNamespace("future")
[10:34:01.069]                           version <- ns[[".package"]][["version"]]
[10:34:01.069]                           if (is.null(version)) 
[10:34:01.069]                             version <- utils::packageVersion("future")
[10:34:01.069]                         }
[10:34:01.069]                         else {
[10:34:01.069]                           version <- NULL
[10:34:01.069]                         }
[10:34:01.069]                         if (!has_future || version < "1.8.0") {
[10:34:01.069]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:01.069]                             "", base::R.version$version.string), 
[10:34:01.069]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:01.069]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:01.069]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:01.069]                               "release", "version")], collapse = " "), 
[10:34:01.069]                             hostname = base::Sys.info()[["nodename"]])
[10:34:01.069]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:01.069]                             info)
[10:34:01.069]                           info <- base::paste(info, collapse = "; ")
[10:34:01.069]                           if (!has_future) {
[10:34:01.069]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:01.069]                               info)
[10:34:01.069]                           }
[10:34:01.069]                           else {
[10:34:01.069]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:01.069]                               info, version)
[10:34:01.069]                           }
[10:34:01.069]                           base::stop(msg)
[10:34:01.069]                         }
[10:34:01.069]                       })
[10:34:01.069]                     }
[10:34:01.069]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:01.069]                     base::options(mc.cores = 1L)
[10:34:01.069]                   }
[10:34:01.069]                   ...future.strategy.old <- future::plan("list")
[10:34:01.069]                   options(future.plan = NULL)
[10:34:01.069]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:01.069]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:01.069]                 }
[10:34:01.069]                 ...future.workdir <- getwd()
[10:34:01.069]             }
[10:34:01.069]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:01.069]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:01.069]         }
[10:34:01.069]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:01.069]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:01.069]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:01.069]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:01.069]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:01.069]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:01.069]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:01.069]             base::names(...future.oldOptions))
[10:34:01.069]     }
[10:34:01.069]     if (FALSE) {
[10:34:01.069]     }
[10:34:01.069]     else {
[10:34:01.069]         if (TRUE) {
[10:34:01.069]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:01.069]                 open = "w")
[10:34:01.069]         }
[10:34:01.069]         else {
[10:34:01.069]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:01.069]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:01.069]         }
[10:34:01.069]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:01.069]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:01.069]             base::sink(type = "output", split = FALSE)
[10:34:01.069]             base::close(...future.stdout)
[10:34:01.069]         }, add = TRUE)
[10:34:01.069]     }
[10:34:01.069]     ...future.frame <- base::sys.nframe()
[10:34:01.069]     ...future.conditions <- base::list()
[10:34:01.069]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:01.069]     if (FALSE) {
[10:34:01.069]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:01.069]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:01.069]     }
[10:34:01.069]     ...future.result <- base::tryCatch({
[10:34:01.069]         base::withCallingHandlers({
[10:34:01.069]             ...future.value <- base::withVisible(base::local({
[10:34:01.069]                 withCallingHandlers({
[10:34:01.069]                   {
[10:34:01.069]                     1
[10:34:01.069]                   }
[10:34:01.069]                 }, immediateCondition = function(cond) {
[10:34:01.069]                   save_rds <- function (object, pathname, ...) 
[10:34:01.069]                   {
[10:34:01.069]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:34:01.069]                     if (file_test("-f", pathname_tmp)) {
[10:34:01.069]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.069]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:34:01.069]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.069]                         fi_tmp[["mtime"]])
[10:34:01.069]                     }
[10:34:01.069]                     tryCatch({
[10:34:01.069]                       saveRDS(object, file = pathname_tmp, ...)
[10:34:01.069]                     }, error = function(ex) {
[10:34:01.069]                       msg <- conditionMessage(ex)
[10:34:01.069]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.069]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:34:01.069]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.069]                         fi_tmp[["mtime"]], msg)
[10:34:01.069]                       ex$message <- msg
[10:34:01.069]                       stop(ex)
[10:34:01.069]                     })
[10:34:01.069]                     stopifnot(file_test("-f", pathname_tmp))
[10:34:01.069]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:34:01.069]                     if (!res || file_test("-f", pathname_tmp)) {
[10:34:01.069]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.069]                       fi <- file.info(pathname)
[10:34:01.069]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:34:01.069]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.069]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:34:01.069]                         fi[["size"]], fi[["mtime"]])
[10:34:01.069]                       stop(msg)
[10:34:01.069]                     }
[10:34:01.069]                     invisible(pathname)
[10:34:01.069]                   }
[10:34:01.069]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:34:01.069]                     rootPath = tempdir()) 
[10:34:01.069]                   {
[10:34:01.069]                     obj <- list(time = Sys.time(), condition = cond)
[10:34:01.069]                     file <- tempfile(pattern = class(cond)[1], 
[10:34:01.069]                       tmpdir = path, fileext = ".rds")
[10:34:01.069]                     save_rds(obj, file)
[10:34:01.069]                   }
[10:34:01.069]                   saveImmediateCondition(cond, path = "/tmp/RtmpuZEzLw/.future/immediateConditions")
[10:34:01.069]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.069]                   {
[10:34:01.069]                     inherits <- base::inherits
[10:34:01.069]                     invokeRestart <- base::invokeRestart
[10:34:01.069]                     is.null <- base::is.null
[10:34:01.069]                     muffled <- FALSE
[10:34:01.069]                     if (inherits(cond, "message")) {
[10:34:01.069]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:01.069]                       if (muffled) 
[10:34:01.069]                         invokeRestart("muffleMessage")
[10:34:01.069]                     }
[10:34:01.069]                     else if (inherits(cond, "warning")) {
[10:34:01.069]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:01.069]                       if (muffled) 
[10:34:01.069]                         invokeRestart("muffleWarning")
[10:34:01.069]                     }
[10:34:01.069]                     else if (inherits(cond, "condition")) {
[10:34:01.069]                       if (!is.null(pattern)) {
[10:34:01.069]                         computeRestarts <- base::computeRestarts
[10:34:01.069]                         grepl <- base::grepl
[10:34:01.069]                         restarts <- computeRestarts(cond)
[10:34:01.069]                         for (restart in restarts) {
[10:34:01.069]                           name <- restart$name
[10:34:01.069]                           if (is.null(name)) 
[10:34:01.069]                             next
[10:34:01.069]                           if (!grepl(pattern, name)) 
[10:34:01.069]                             next
[10:34:01.069]                           invokeRestart(restart)
[10:34:01.069]                           muffled <- TRUE
[10:34:01.069]                           break
[10:34:01.069]                         }
[10:34:01.069]                       }
[10:34:01.069]                     }
[10:34:01.069]                     invisible(muffled)
[10:34:01.069]                   }
[10:34:01.069]                   muffleCondition(cond)
[10:34:01.069]                 })
[10:34:01.069]             }))
[10:34:01.069]             future::FutureResult(value = ...future.value$value, 
[10:34:01.069]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:01.069]                   ...future.rng), globalenv = if (FALSE) 
[10:34:01.069]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:01.069]                     ...future.globalenv.names))
[10:34:01.069]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:01.069]         }, condition = base::local({
[10:34:01.069]             c <- base::c
[10:34:01.069]             inherits <- base::inherits
[10:34:01.069]             invokeRestart <- base::invokeRestart
[10:34:01.069]             length <- base::length
[10:34:01.069]             list <- base::list
[10:34:01.069]             seq.int <- base::seq.int
[10:34:01.069]             signalCondition <- base::signalCondition
[10:34:01.069]             sys.calls <- base::sys.calls
[10:34:01.069]             `[[` <- base::`[[`
[10:34:01.069]             `+` <- base::`+`
[10:34:01.069]             `<<-` <- base::`<<-`
[10:34:01.069]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:01.069]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:01.069]                   3L)]
[10:34:01.069]             }
[10:34:01.069]             function(cond) {
[10:34:01.069]                 is_error <- inherits(cond, "error")
[10:34:01.069]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:01.069]                   NULL)
[10:34:01.069]                 if (is_error) {
[10:34:01.069]                   sessionInformation <- function() {
[10:34:01.069]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:01.069]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:01.069]                       search = base::search(), system = base::Sys.info())
[10:34:01.069]                   }
[10:34:01.069]                   ...future.conditions[[length(...future.conditions) + 
[10:34:01.069]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:01.069]                     cond$call), session = sessionInformation(), 
[10:34:01.069]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:01.069]                   signalCondition(cond)
[10:34:01.069]                 }
[10:34:01.069]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:01.069]                 "immediateCondition"))) {
[10:34:01.069]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:01.069]                   ...future.conditions[[length(...future.conditions) + 
[10:34:01.069]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:01.069]                   if (TRUE && !signal) {
[10:34:01.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.069]                     {
[10:34:01.069]                       inherits <- base::inherits
[10:34:01.069]                       invokeRestart <- base::invokeRestart
[10:34:01.069]                       is.null <- base::is.null
[10:34:01.069]                       muffled <- FALSE
[10:34:01.069]                       if (inherits(cond, "message")) {
[10:34:01.069]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:01.069]                         if (muffled) 
[10:34:01.069]                           invokeRestart("muffleMessage")
[10:34:01.069]                       }
[10:34:01.069]                       else if (inherits(cond, "warning")) {
[10:34:01.069]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:01.069]                         if (muffled) 
[10:34:01.069]                           invokeRestart("muffleWarning")
[10:34:01.069]                       }
[10:34:01.069]                       else if (inherits(cond, "condition")) {
[10:34:01.069]                         if (!is.null(pattern)) {
[10:34:01.069]                           computeRestarts <- base::computeRestarts
[10:34:01.069]                           grepl <- base::grepl
[10:34:01.069]                           restarts <- computeRestarts(cond)
[10:34:01.069]                           for (restart in restarts) {
[10:34:01.069]                             name <- restart$name
[10:34:01.069]                             if (is.null(name)) 
[10:34:01.069]                               next
[10:34:01.069]                             if (!grepl(pattern, name)) 
[10:34:01.069]                               next
[10:34:01.069]                             invokeRestart(restart)
[10:34:01.069]                             muffled <- TRUE
[10:34:01.069]                             break
[10:34:01.069]                           }
[10:34:01.069]                         }
[10:34:01.069]                       }
[10:34:01.069]                       invisible(muffled)
[10:34:01.069]                     }
[10:34:01.069]                     muffleCondition(cond, pattern = "^muffle")
[10:34:01.069]                   }
[10:34:01.069]                 }
[10:34:01.069]                 else {
[10:34:01.069]                   if (TRUE) {
[10:34:01.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.069]                     {
[10:34:01.069]                       inherits <- base::inherits
[10:34:01.069]                       invokeRestart <- base::invokeRestart
[10:34:01.069]                       is.null <- base::is.null
[10:34:01.069]                       muffled <- FALSE
[10:34:01.069]                       if (inherits(cond, "message")) {
[10:34:01.069]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:01.069]                         if (muffled) 
[10:34:01.069]                           invokeRestart("muffleMessage")
[10:34:01.069]                       }
[10:34:01.069]                       else if (inherits(cond, "warning")) {
[10:34:01.069]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:01.069]                         if (muffled) 
[10:34:01.069]                           invokeRestart("muffleWarning")
[10:34:01.069]                       }
[10:34:01.069]                       else if (inherits(cond, "condition")) {
[10:34:01.069]                         if (!is.null(pattern)) {
[10:34:01.069]                           computeRestarts <- base::computeRestarts
[10:34:01.069]                           grepl <- base::grepl
[10:34:01.069]                           restarts <- computeRestarts(cond)
[10:34:01.069]                           for (restart in restarts) {
[10:34:01.069]                             name <- restart$name
[10:34:01.069]                             if (is.null(name)) 
[10:34:01.069]                               next
[10:34:01.069]                             if (!grepl(pattern, name)) 
[10:34:01.069]                               next
[10:34:01.069]                             invokeRestart(restart)
[10:34:01.069]                             muffled <- TRUE
[10:34:01.069]                             break
[10:34:01.069]                           }
[10:34:01.069]                         }
[10:34:01.069]                       }
[10:34:01.069]                       invisible(muffled)
[10:34:01.069]                     }
[10:34:01.069]                     muffleCondition(cond, pattern = "^muffle")
[10:34:01.069]                   }
[10:34:01.069]                 }
[10:34:01.069]             }
[10:34:01.069]         }))
[10:34:01.069]     }, error = function(ex) {
[10:34:01.069]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:01.069]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:01.069]                 ...future.rng), started = ...future.startTime, 
[10:34:01.069]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:01.069]             version = "1.8"), class = "FutureResult")
[10:34:01.069]     }, finally = {
[10:34:01.069]         if (!identical(...future.workdir, getwd())) 
[10:34:01.069]             setwd(...future.workdir)
[10:34:01.069]         {
[10:34:01.069]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:01.069]                 ...future.oldOptions$nwarnings <- NULL
[10:34:01.069]             }
[10:34:01.069]             base::options(...future.oldOptions)
[10:34:01.069]             if (.Platform$OS.type == "windows") {
[10:34:01.069]                 old_names <- names(...future.oldEnvVars)
[10:34:01.069]                 envs <- base::Sys.getenv()
[10:34:01.069]                 names <- names(envs)
[10:34:01.069]                 common <- intersect(names, old_names)
[10:34:01.069]                 added <- setdiff(names, old_names)
[10:34:01.069]                 removed <- setdiff(old_names, names)
[10:34:01.069]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:01.069]                   envs[common]]
[10:34:01.069]                 NAMES <- toupper(changed)
[10:34:01.069]                 args <- list()
[10:34:01.069]                 for (kk in seq_along(NAMES)) {
[10:34:01.069]                   name <- changed[[kk]]
[10:34:01.069]                   NAME <- NAMES[[kk]]
[10:34:01.069]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.069]                     next
[10:34:01.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:01.069]                 }
[10:34:01.069]                 NAMES <- toupper(added)
[10:34:01.069]                 for (kk in seq_along(NAMES)) {
[10:34:01.069]                   name <- added[[kk]]
[10:34:01.069]                   NAME <- NAMES[[kk]]
[10:34:01.069]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.069]                     next
[10:34:01.069]                   args[[name]] <- ""
[10:34:01.069]                 }
[10:34:01.069]                 NAMES <- toupper(removed)
[10:34:01.069]                 for (kk in seq_along(NAMES)) {
[10:34:01.069]                   name <- removed[[kk]]
[10:34:01.069]                   NAME <- NAMES[[kk]]
[10:34:01.069]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.069]                     next
[10:34:01.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:01.069]                 }
[10:34:01.069]                 if (length(args) > 0) 
[10:34:01.069]                   base::do.call(base::Sys.setenv, args = args)
[10:34:01.069]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:01.069]             }
[10:34:01.069]             else {
[10:34:01.069]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:01.069]             }
[10:34:01.069]             {
[10:34:01.069]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:01.069]                   0L) {
[10:34:01.069]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:01.069]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:01.069]                   base::options(opts)
[10:34:01.069]                 }
[10:34:01.069]                 {
[10:34:01.069]                   {
[10:34:01.069]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:01.069]                     NULL
[10:34:01.069]                   }
[10:34:01.069]                   options(future.plan = NULL)
[10:34:01.069]                   if (is.na(NA_character_)) 
[10:34:01.069]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:01.069]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:01.069]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:01.069]                     .init = FALSE)
[10:34:01.069]                 }
[10:34:01.069]             }
[10:34:01.069]         }
[10:34:01.069]     })
[10:34:01.069]     if (TRUE) {
[10:34:01.069]         base::sink(type = "output", split = FALSE)
[10:34:01.069]         if (TRUE) {
[10:34:01.069]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:01.069]         }
[10:34:01.069]         else {
[10:34:01.069]             ...future.result["stdout"] <- base::list(NULL)
[10:34:01.069]         }
[10:34:01.069]         base::close(...future.stdout)
[10:34:01.069]         ...future.stdout <- NULL
[10:34:01.069]     }
[10:34:01.069]     ...future.result$conditions <- ...future.conditions
[10:34:01.069]     ...future.result$finished <- base::Sys.time()
[10:34:01.069]     ...future.result
[10:34:01.069] }
[10:34:01.072] requestCore(): workers = 2
[10:34:01.072] Poll #1 (0): usedCores() = 2, workers = 2
[10:34:01.083] result() for MulticoreFuture ...
[10:34:01.084] result() for MulticoreFuture ...
[10:34:01.084] result() for MulticoreFuture ... done
[10:34:01.084] result() for MulticoreFuture ... done
[10:34:01.084] result() for MulticoreFuture ...
[10:34:01.084] result() for MulticoreFuture ... done
[10:34:01.087] MulticoreFuture started
[10:34:01.088] - Launch lazy future ... done
[10:34:01.088] run() for ‘MulticoreFuture’ ... done
[10:34:01.088] plan(): Setting new future strategy stack:
[10:34:01.089] getGlobalsAndPackages() ...
[10:34:01.089] Searching for globals...
[10:34:01.089] List of future strategies:
[10:34:01.089] 1. sequential:
[10:34:01.089]    - args: function (..., envir = parent.frame())
[10:34:01.089]    - tweaked: FALSE
[10:34:01.089]    - call: NULL
[10:34:01.090] plan(): nbrOfWorkers() = 1
[10:34:01.091] - globals found: [1] ‘{’
[10:34:01.091] Searching for globals ... DONE
[10:34:01.091] Resolving globals: FALSE
[10:34:01.092] 
[10:34:01.092] 
[10:34:01.092] plan(): Setting new future strategy stack:
[10:34:01.092] getGlobalsAndPackages() ... DONE
[10:34:01.092] List of future strategies:
[10:34:01.092] 1. multicore:
[10:34:01.092]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:34:01.092]    - tweaked: FALSE
[10:34:01.092]    - call: plan(strategy)
[10:34:01.092] run() for ‘Future’ ...
[10:34:01.093] - state: ‘created’
[10:34:01.093] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:34:01.097] plan(): nbrOfWorkers() = 2
[10:34:01.098] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:01.098] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:34:01.098]   - Field: ‘label’
[10:34:01.098]   - Field: ‘local’
[10:34:01.098]   - Field: ‘owner’
[10:34:01.099]   - Field: ‘envir’
[10:34:01.099]   - Field: ‘workers’
[10:34:01.099]   - Field: ‘packages’
[10:34:01.099]   - Field: ‘gc’
[10:34:01.099]   - Field: ‘job’
[10:34:01.099]   - Field: ‘conditions’
[10:34:01.099]   - Field: ‘expr’
[10:34:01.100]   - Field: ‘uuid’
[10:34:01.100]   - Field: ‘seed’
[10:34:01.100]   - Field: ‘version’
[10:34:01.100]   - Field: ‘result’
[10:34:01.100]   - Field: ‘asynchronous’
[10:34:01.100]   - Field: ‘calls’
[10:34:01.101]   - Field: ‘globals’
[10:34:01.101]   - Field: ‘stdout’
[10:34:01.101]   - Field: ‘earlySignal’
[10:34:01.102]   - Field: ‘lazy’
[10:34:01.102]   - Field: ‘state’
[10:34:01.102] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:34:01.102] - Launch lazy future ...
[10:34:01.103] Packages needed by the future expression (n = 0): <none>
[10:34:01.103] Packages needed by future strategies (n = 0): <none>
[10:34:01.104] {
[10:34:01.104]     {
[10:34:01.104]         {
[10:34:01.104]             ...future.startTime <- base::Sys.time()
[10:34:01.104]             {
[10:34:01.104]                 {
[10:34:01.104]                   {
[10:34:01.104]                     {
[10:34:01.104]                       base::local({
[10:34:01.104]                         has_future <- base::requireNamespace("future", 
[10:34:01.104]                           quietly = TRUE)
[10:34:01.104]                         if (has_future) {
[10:34:01.104]                           ns <- base::getNamespace("future")
[10:34:01.104]                           version <- ns[[".package"]][["version"]]
[10:34:01.104]                           if (is.null(version)) 
[10:34:01.104]                             version <- utils::packageVersion("future")
[10:34:01.104]                         }
[10:34:01.104]                         else {
[10:34:01.104]                           version <- NULL
[10:34:01.104]                         }
[10:34:01.104]                         if (!has_future || version < "1.8.0") {
[10:34:01.104]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:01.104]                             "", base::R.version$version.string), 
[10:34:01.104]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:01.104]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:01.104]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:01.104]                               "release", "version")], collapse = " "), 
[10:34:01.104]                             hostname = base::Sys.info()[["nodename"]])
[10:34:01.104]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:01.104]                             info)
[10:34:01.104]                           info <- base::paste(info, collapse = "; ")
[10:34:01.104]                           if (!has_future) {
[10:34:01.104]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:01.104]                               info)
[10:34:01.104]                           }
[10:34:01.104]                           else {
[10:34:01.104]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:01.104]                               info, version)
[10:34:01.104]                           }
[10:34:01.104]                           base::stop(msg)
[10:34:01.104]                         }
[10:34:01.104]                       })
[10:34:01.104]                     }
[10:34:01.104]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:01.104]                     base::options(mc.cores = 1L)
[10:34:01.104]                   }
[10:34:01.104]                   ...future.strategy.old <- future::plan("list")
[10:34:01.104]                   options(future.plan = NULL)
[10:34:01.104]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:01.104]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:01.104]                 }
[10:34:01.104]                 ...future.workdir <- getwd()
[10:34:01.104]             }
[10:34:01.104]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:01.104]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:01.104]         }
[10:34:01.104]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:01.104]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:01.104]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:01.104]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:01.104]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:01.104]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:01.104]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:01.104]             base::names(...future.oldOptions))
[10:34:01.104]     }
[10:34:01.104]     if (FALSE) {
[10:34:01.104]     }
[10:34:01.104]     else {
[10:34:01.104]         if (TRUE) {
[10:34:01.104]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:01.104]                 open = "w")
[10:34:01.104]         }
[10:34:01.104]         else {
[10:34:01.104]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:01.104]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:01.104]         }
[10:34:01.104]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:01.104]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:01.104]             base::sink(type = "output", split = FALSE)
[10:34:01.104]             base::close(...future.stdout)
[10:34:01.104]         }, add = TRUE)
[10:34:01.104]     }
[10:34:01.104]     ...future.frame <- base::sys.nframe()
[10:34:01.104]     ...future.conditions <- base::list()
[10:34:01.104]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:01.104]     if (FALSE) {
[10:34:01.104]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:01.104]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:01.104]     }
[10:34:01.104]     ...future.result <- base::tryCatch({
[10:34:01.104]         base::withCallingHandlers({
[10:34:01.104]             ...future.value <- base::withVisible(base::local({
[10:34:01.104]                 withCallingHandlers({
[10:34:01.104]                   {
[10:34:01.104]                     2
[10:34:01.104]                   }
[10:34:01.104]                 }, immediateCondition = function(cond) {
[10:34:01.104]                   save_rds <- function (object, pathname, ...) 
[10:34:01.104]                   {
[10:34:01.104]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:34:01.104]                     if (file_test("-f", pathname_tmp)) {
[10:34:01.104]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.104]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:34:01.104]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.104]                         fi_tmp[["mtime"]])
[10:34:01.104]                     }
[10:34:01.104]                     tryCatch({
[10:34:01.104]                       saveRDS(object, file = pathname_tmp, ...)
[10:34:01.104]                     }, error = function(ex) {
[10:34:01.104]                       msg <- conditionMessage(ex)
[10:34:01.104]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.104]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:34:01.104]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.104]                         fi_tmp[["mtime"]], msg)
[10:34:01.104]                       ex$message <- msg
[10:34:01.104]                       stop(ex)
[10:34:01.104]                     })
[10:34:01.104]                     stopifnot(file_test("-f", pathname_tmp))
[10:34:01.104]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:34:01.104]                     if (!res || file_test("-f", pathname_tmp)) {
[10:34:01.104]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.104]                       fi <- file.info(pathname)
[10:34:01.104]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:34:01.104]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.104]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:34:01.104]                         fi[["size"]], fi[["mtime"]])
[10:34:01.104]                       stop(msg)
[10:34:01.104]                     }
[10:34:01.104]                     invisible(pathname)
[10:34:01.104]                   }
[10:34:01.104]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:34:01.104]                     rootPath = tempdir()) 
[10:34:01.104]                   {
[10:34:01.104]                     obj <- list(time = Sys.time(), condition = cond)
[10:34:01.104]                     file <- tempfile(pattern = class(cond)[1], 
[10:34:01.104]                       tmpdir = path, fileext = ".rds")
[10:34:01.104]                     save_rds(obj, file)
[10:34:01.104]                   }
[10:34:01.104]                   saveImmediateCondition(cond, path = "/tmp/RtmpuZEzLw/.future/immediateConditions")
[10:34:01.104]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.104]                   {
[10:34:01.104]                     inherits <- base::inherits
[10:34:01.104]                     invokeRestart <- base::invokeRestart
[10:34:01.104]                     is.null <- base::is.null
[10:34:01.104]                     muffled <- FALSE
[10:34:01.104]                     if (inherits(cond, "message")) {
[10:34:01.104]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:01.104]                       if (muffled) 
[10:34:01.104]                         invokeRestart("muffleMessage")
[10:34:01.104]                     }
[10:34:01.104]                     else if (inherits(cond, "warning")) {
[10:34:01.104]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:01.104]                       if (muffled) 
[10:34:01.104]                         invokeRestart("muffleWarning")
[10:34:01.104]                     }
[10:34:01.104]                     else if (inherits(cond, "condition")) {
[10:34:01.104]                       if (!is.null(pattern)) {
[10:34:01.104]                         computeRestarts <- base::computeRestarts
[10:34:01.104]                         grepl <- base::grepl
[10:34:01.104]                         restarts <- computeRestarts(cond)
[10:34:01.104]                         for (restart in restarts) {
[10:34:01.104]                           name <- restart$name
[10:34:01.104]                           if (is.null(name)) 
[10:34:01.104]                             next
[10:34:01.104]                           if (!grepl(pattern, name)) 
[10:34:01.104]                             next
[10:34:01.104]                           invokeRestart(restart)
[10:34:01.104]                           muffled <- TRUE
[10:34:01.104]                           break
[10:34:01.104]                         }
[10:34:01.104]                       }
[10:34:01.104]                     }
[10:34:01.104]                     invisible(muffled)
[10:34:01.104]                   }
[10:34:01.104]                   muffleCondition(cond)
[10:34:01.104]                 })
[10:34:01.104]             }))
[10:34:01.104]             future::FutureResult(value = ...future.value$value, 
[10:34:01.104]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:01.104]                   ...future.rng), globalenv = if (FALSE) 
[10:34:01.104]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:01.104]                     ...future.globalenv.names))
[10:34:01.104]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:01.104]         }, condition = base::local({
[10:34:01.104]             c <- base::c
[10:34:01.104]             inherits <- base::inherits
[10:34:01.104]             invokeRestart <- base::invokeRestart
[10:34:01.104]             length <- base::length
[10:34:01.104]             list <- base::list
[10:34:01.104]             seq.int <- base::seq.int
[10:34:01.104]             signalCondition <- base::signalCondition
[10:34:01.104]             sys.calls <- base::sys.calls
[10:34:01.104]             `[[` <- base::`[[`
[10:34:01.104]             `+` <- base::`+`
[10:34:01.104]             `<<-` <- base::`<<-`
[10:34:01.104]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:01.104]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:01.104]                   3L)]
[10:34:01.104]             }
[10:34:01.104]             function(cond) {
[10:34:01.104]                 is_error <- inherits(cond, "error")
[10:34:01.104]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:01.104]                   NULL)
[10:34:01.104]                 if (is_error) {
[10:34:01.104]                   sessionInformation <- function() {
[10:34:01.104]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:01.104]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:01.104]                       search = base::search(), system = base::Sys.info())
[10:34:01.104]                   }
[10:34:01.104]                   ...future.conditions[[length(...future.conditions) + 
[10:34:01.104]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:01.104]                     cond$call), session = sessionInformation(), 
[10:34:01.104]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:01.104]                   signalCondition(cond)
[10:34:01.104]                 }
[10:34:01.104]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:01.104]                 "immediateCondition"))) {
[10:34:01.104]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:01.104]                   ...future.conditions[[length(...future.conditions) + 
[10:34:01.104]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:01.104]                   if (TRUE && !signal) {
[10:34:01.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.104]                     {
[10:34:01.104]                       inherits <- base::inherits
[10:34:01.104]                       invokeRestart <- base::invokeRestart
[10:34:01.104]                       is.null <- base::is.null
[10:34:01.104]                       muffled <- FALSE
[10:34:01.104]                       if (inherits(cond, "message")) {
[10:34:01.104]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:01.104]                         if (muffled) 
[10:34:01.104]                           invokeRestart("muffleMessage")
[10:34:01.104]                       }
[10:34:01.104]                       else if (inherits(cond, "warning")) {
[10:34:01.104]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:01.104]                         if (muffled) 
[10:34:01.104]                           invokeRestart("muffleWarning")
[10:34:01.104]                       }
[10:34:01.104]                       else if (inherits(cond, "condition")) {
[10:34:01.104]                         if (!is.null(pattern)) {
[10:34:01.104]                           computeRestarts <- base::computeRestarts
[10:34:01.104]                           grepl <- base::grepl
[10:34:01.104]                           restarts <- computeRestarts(cond)
[10:34:01.104]                           for (restart in restarts) {
[10:34:01.104]                             name <- restart$name
[10:34:01.104]                             if (is.null(name)) 
[10:34:01.104]                               next
[10:34:01.104]                             if (!grepl(pattern, name)) 
[10:34:01.104]                               next
[10:34:01.104]                             invokeRestart(restart)
[10:34:01.104]                             muffled <- TRUE
[10:34:01.104]                             break
[10:34:01.104]                           }
[10:34:01.104]                         }
[10:34:01.104]                       }
[10:34:01.104]                       invisible(muffled)
[10:34:01.104]                     }
[10:34:01.104]                     muffleCondition(cond, pattern = "^muffle")
[10:34:01.104]                   }
[10:34:01.104]                 }
[10:34:01.104]                 else {
[10:34:01.104]                   if (TRUE) {
[10:34:01.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.104]                     {
[10:34:01.104]                       inherits <- base::inherits
[10:34:01.104]                       invokeRestart <- base::invokeRestart
[10:34:01.104]                       is.null <- base::is.null
[10:34:01.104]                       muffled <- FALSE
[10:34:01.104]                       if (inherits(cond, "message")) {
[10:34:01.104]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:01.104]                         if (muffled) 
[10:34:01.104]                           invokeRestart("muffleMessage")
[10:34:01.104]                       }
[10:34:01.104]                       else if (inherits(cond, "warning")) {
[10:34:01.104]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:01.104]                         if (muffled) 
[10:34:01.104]                           invokeRestart("muffleWarning")
[10:34:01.104]                       }
[10:34:01.104]                       else if (inherits(cond, "condition")) {
[10:34:01.104]                         if (!is.null(pattern)) {
[10:34:01.104]                           computeRestarts <- base::computeRestarts
[10:34:01.104]                           grepl <- base::grepl
[10:34:01.104]                           restarts <- computeRestarts(cond)
[10:34:01.104]                           for (restart in restarts) {
[10:34:01.104]                             name <- restart$name
[10:34:01.104]                             if (is.null(name)) 
[10:34:01.104]                               next
[10:34:01.104]                             if (!grepl(pattern, name)) 
[10:34:01.104]                               next
[10:34:01.104]                             invokeRestart(restart)
[10:34:01.104]                             muffled <- TRUE
[10:34:01.104]                             break
[10:34:01.104]                           }
[10:34:01.104]                         }
[10:34:01.104]                       }
[10:34:01.104]                       invisible(muffled)
[10:34:01.104]                     }
[10:34:01.104]                     muffleCondition(cond, pattern = "^muffle")
[10:34:01.104]                   }
[10:34:01.104]                 }
[10:34:01.104]             }
[10:34:01.104]         }))
[10:34:01.104]     }, error = function(ex) {
[10:34:01.104]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:01.104]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:01.104]                 ...future.rng), started = ...future.startTime, 
[10:34:01.104]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:01.104]             version = "1.8"), class = "FutureResult")
[10:34:01.104]     }, finally = {
[10:34:01.104]         if (!identical(...future.workdir, getwd())) 
[10:34:01.104]             setwd(...future.workdir)
[10:34:01.104]         {
[10:34:01.104]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:01.104]                 ...future.oldOptions$nwarnings <- NULL
[10:34:01.104]             }
[10:34:01.104]             base::options(...future.oldOptions)
[10:34:01.104]             if (.Platform$OS.type == "windows") {
[10:34:01.104]                 old_names <- names(...future.oldEnvVars)
[10:34:01.104]                 envs <- base::Sys.getenv()
[10:34:01.104]                 names <- names(envs)
[10:34:01.104]                 common <- intersect(names, old_names)
[10:34:01.104]                 added <- setdiff(names, old_names)
[10:34:01.104]                 removed <- setdiff(old_names, names)
[10:34:01.104]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:01.104]                   envs[common]]
[10:34:01.104]                 NAMES <- toupper(changed)
[10:34:01.104]                 args <- list()
[10:34:01.104]                 for (kk in seq_along(NAMES)) {
[10:34:01.104]                   name <- changed[[kk]]
[10:34:01.104]                   NAME <- NAMES[[kk]]
[10:34:01.104]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.104]                     next
[10:34:01.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:01.104]                 }
[10:34:01.104]                 NAMES <- toupper(added)
[10:34:01.104]                 for (kk in seq_along(NAMES)) {
[10:34:01.104]                   name <- added[[kk]]
[10:34:01.104]                   NAME <- NAMES[[kk]]
[10:34:01.104]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.104]                     next
[10:34:01.104]                   args[[name]] <- ""
[10:34:01.104]                 }
[10:34:01.104]                 NAMES <- toupper(removed)
[10:34:01.104]                 for (kk in seq_along(NAMES)) {
[10:34:01.104]                   name <- removed[[kk]]
[10:34:01.104]                   NAME <- NAMES[[kk]]
[10:34:01.104]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.104]                     next
[10:34:01.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:01.104]                 }
[10:34:01.104]                 if (length(args) > 0) 
[10:34:01.104]                   base::do.call(base::Sys.setenv, args = args)
[10:34:01.104]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:01.104]             }
[10:34:01.104]             else {
[10:34:01.104]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:01.104]             }
[10:34:01.104]             {
[10:34:01.104]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:01.104]                   0L) {
[10:34:01.104]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:01.104]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:01.104]                   base::options(opts)
[10:34:01.104]                 }
[10:34:01.104]                 {
[10:34:01.104]                   {
[10:34:01.104]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:01.104]                     NULL
[10:34:01.104]                   }
[10:34:01.104]                   options(future.plan = NULL)
[10:34:01.104]                   if (is.na(NA_character_)) 
[10:34:01.104]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:01.104]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:01.104]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:01.104]                     .init = FALSE)
[10:34:01.104]                 }
[10:34:01.104]             }
[10:34:01.104]         }
[10:34:01.104]     })
[10:34:01.104]     if (TRUE) {
[10:34:01.104]         base::sink(type = "output", split = FALSE)
[10:34:01.104]         if (TRUE) {
[10:34:01.104]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:01.104]         }
[10:34:01.104]         else {
[10:34:01.104]             ...future.result["stdout"] <- base::list(NULL)
[10:34:01.104]         }
[10:34:01.104]         base::close(...future.stdout)
[10:34:01.104]         ...future.stdout <- NULL
[10:34:01.104]     }
[10:34:01.104]     ...future.result$conditions <- ...future.conditions
[10:34:01.104]     ...future.result$finished <- base::Sys.time()
[10:34:01.104]     ...future.result
[10:34:01.104] }
[10:34:01.107] requestCore(): workers = 2
[10:34:01.108] Poll #1 (0): usedCores() = 2, workers = 2
[10:34:01.118] result() for MulticoreFuture ...
[10:34:01.119] result() for MulticoreFuture ...
[10:34:01.119] result() for MulticoreFuture ... done
[10:34:01.119] result() for MulticoreFuture ... done
[10:34:01.120] result() for MulticoreFuture ...
[10:34:01.120] result() for MulticoreFuture ... done
[10:34:01.122] MulticoreFuture started
[10:34:01.123] - Launch lazy future ... done
[10:34:01.123] run() for ‘MulticoreFuture’ ... done
[10:34:01.124] plan(): Setting new future strategy stack:
[10:34:01.124] List of future strategies:
[10:34:01.124] 1. sequential:
[10:34:01.124]    - args: function (..., envir = parent.frame())
[10:34:01.124]    - tweaked: FALSE
[10:34:01.124]    - call: NULL
[10:34:01.125] plan(): nbrOfWorkers() = 1
[10:34:01.125] resolve() on environment ...
[10:34:01.125]  recursive: 0
[10:34:01.126]  elements: [3] ‘a’
[10:34:01.126] Future #1
[10:34:01.127]  length: 2 (resolved future 1)
[10:34:01.127] plan(): Setting new future strategy stack:
[10:34:01.127] List of future strategies:
[10:34:01.127] 1. multicore:
[10:34:01.127]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:34:01.127]    - tweaked: FALSE
[10:34:01.127]    - call: plan(strategy)
[10:34:01.132] plan(): nbrOfWorkers() = 2
[10:34:01.133] Future #2
[10:34:01.133]  length: 1 (resolved future 2)
[10:34:01.133]  length: 0 (resolved future 3)
[10:34:01.133] resolve() on environment ... DONE
[10:34:01.134] resolve() on environment ...
[10:34:01.134]  recursive: 0
[10:34:01.135]  elements: [3] ‘b’
[10:34:01.135] Future #1
[10:34:01.135]  length: 2 (resolved future 1)
[10:34:01.136] Future #2
[10:34:01.136]  length: 1 (resolved future 2)
[10:34:01.136]  length: 0 (resolved future 3)
[10:34:01.136] resolve() on environment ... DONE
[10:34:01.137] resolve() on environment ...
[10:34:01.137]  recursive: 0
[10:34:01.138]  elements: [3] ‘c’
[10:34:01.138] Future #1
[10:34:01.138]  length: 2 (resolved future 1)
[10:34:01.143] Future #2
[10:34:01.143]  length: 1 (resolved future 2)
[10:34:01.144]  length: 0 (resolved future 3)
[10:34:01.144] resolve() on environment ... DONE
[10:34:01.146] resolve() on environment ...
[10:34:01.146]  recursive: 0
[10:34:01.148]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[10:34:01.148] Future #1
[10:34:01.148] result() for MulticoreFuture ...
[10:34:01.149] result() for MulticoreFuture ...
[10:34:01.149] result() for MulticoreFuture ... done
[10:34:01.150] result() for MulticoreFuture ... done
[10:34:01.150] result() for MulticoreFuture ...
[10:34:01.150] result() for MulticoreFuture ... done
[10:34:01.150]  length: 2 (resolved future 1)
[10:34:01.151] Future #2
[10:34:01.151] result() for MulticoreFuture ...
[10:34:01.152] result() for MulticoreFuture ...
[10:34:01.152] result() for MulticoreFuture ... done
[10:34:01.152] result() for MulticoreFuture ... done
[10:34:01.152] result() for MulticoreFuture ...
[10:34:01.152] result() for MulticoreFuture ... done
[10:34:01.153]  length: 1 (resolved future 2)
[10:34:01.153]  length: 0 (resolved future 3)
[10:34:01.153] resolve() on environment ... DONE
[10:34:01.154] resolve() on environment ...
[10:34:01.154]  recursive: 99
[10:34:01.155]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[10:34:01.155] Future #1
[10:34:01.155] result() for MulticoreFuture ...
[10:34:01.156] result() for MulticoreFuture ... done
[10:34:01.156] result() for MulticoreFuture ...
[10:34:01.156] result() for MulticoreFuture ... done
[10:34:01.156] A MulticoreFuture was resolved
[10:34:01.156]  length: 2 (resolved future 1)
[10:34:01.156] Future #2
[10:34:01.156] result() for MulticoreFuture ...
[10:34:01.156] result() for MulticoreFuture ... done
[10:34:01.156] result() for MulticoreFuture ...
[10:34:01.157] result() for MulticoreFuture ... done
[10:34:01.157] A MulticoreFuture was resolved
[10:34:01.157]  length: 1 (resolved future 2)
[10:34:01.157]  length: 0 (resolved future 3)
[10:34:01.157] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[10:34:01.158] resolve() on list environment ...
[10:34:01.158]  recursive: 0
[10:34:01.159]  length: 2
[10:34:01.159]  elements: ‘a’, ‘b’
[10:34:01.159]  length: 1 (resolved future 1)
[10:34:01.159]  length: 0 (resolved future 2)
[10:34:01.159] resolve() on list environment ... DONE
[10:34:01.159] getGlobalsAndPackages() ...
[10:34:01.159] Searching for globals...
[10:34:01.160] 
[10:34:01.160] Searching for globals ... DONE
[10:34:01.160] - globals: [0] <none>
[10:34:01.160] getGlobalsAndPackages() ... DONE
[10:34:01.160] run() for ‘Future’ ...
[10:34:01.161] - state: ‘created’
[10:34:01.161] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:34:01.165] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:01.165] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:34:01.165]   - Field: ‘label’
[10:34:01.165]   - Field: ‘local’
[10:34:01.165]   - Field: ‘owner’
[10:34:01.165]   - Field: ‘envir’
[10:34:01.165]   - Field: ‘workers’
[10:34:01.165]   - Field: ‘packages’
[10:34:01.166]   - Field: ‘gc’
[10:34:01.166]   - Field: ‘job’
[10:34:01.166]   - Field: ‘conditions’
[10:34:01.166]   - Field: ‘expr’
[10:34:01.166]   - Field: ‘uuid’
[10:34:01.166]   - Field: ‘seed’
[10:34:01.166]   - Field: ‘version’
[10:34:01.166]   - Field: ‘result’
[10:34:01.166]   - Field: ‘asynchronous’
[10:34:01.166]   - Field: ‘calls’
[10:34:01.167]   - Field: ‘globals’
[10:34:01.167]   - Field: ‘stdout’
[10:34:01.167]   - Field: ‘earlySignal’
[10:34:01.167]   - Field: ‘lazy’
[10:34:01.167]   - Field: ‘state’
[10:34:01.167] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:34:01.167] - Launch lazy future ...
[10:34:01.168] Packages needed by the future expression (n = 0): <none>
[10:34:01.168] Packages needed by future strategies (n = 0): <none>
[10:34:01.168] {
[10:34:01.168]     {
[10:34:01.168]         {
[10:34:01.168]             ...future.startTime <- base::Sys.time()
[10:34:01.168]             {
[10:34:01.168]                 {
[10:34:01.168]                   {
[10:34:01.168]                     {
[10:34:01.168]                       base::local({
[10:34:01.168]                         has_future <- base::requireNamespace("future", 
[10:34:01.168]                           quietly = TRUE)
[10:34:01.168]                         if (has_future) {
[10:34:01.168]                           ns <- base::getNamespace("future")
[10:34:01.168]                           version <- ns[[".package"]][["version"]]
[10:34:01.168]                           if (is.null(version)) 
[10:34:01.168]                             version <- utils::packageVersion("future")
[10:34:01.168]                         }
[10:34:01.168]                         else {
[10:34:01.168]                           version <- NULL
[10:34:01.168]                         }
[10:34:01.168]                         if (!has_future || version < "1.8.0") {
[10:34:01.168]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:01.168]                             "", base::R.version$version.string), 
[10:34:01.168]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:01.168]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:01.168]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:01.168]                               "release", "version")], collapse = " "), 
[10:34:01.168]                             hostname = base::Sys.info()[["nodename"]])
[10:34:01.168]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:01.168]                             info)
[10:34:01.168]                           info <- base::paste(info, collapse = "; ")
[10:34:01.168]                           if (!has_future) {
[10:34:01.168]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:01.168]                               info)
[10:34:01.168]                           }
[10:34:01.168]                           else {
[10:34:01.168]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:01.168]                               info, version)
[10:34:01.168]                           }
[10:34:01.168]                           base::stop(msg)
[10:34:01.168]                         }
[10:34:01.168]                       })
[10:34:01.168]                     }
[10:34:01.168]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:01.168]                     base::options(mc.cores = 1L)
[10:34:01.168]                   }
[10:34:01.168]                   ...future.strategy.old <- future::plan("list")
[10:34:01.168]                   options(future.plan = NULL)
[10:34:01.168]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:01.168]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:01.168]                 }
[10:34:01.168]                 ...future.workdir <- getwd()
[10:34:01.168]             }
[10:34:01.168]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:01.168]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:01.168]         }
[10:34:01.168]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:01.168]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:01.168]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:01.168]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:01.168]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:01.168]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:01.168]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:01.168]             base::names(...future.oldOptions))
[10:34:01.168]     }
[10:34:01.168]     if (FALSE) {
[10:34:01.168]     }
[10:34:01.168]     else {
[10:34:01.168]         if (TRUE) {
[10:34:01.168]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:01.168]                 open = "w")
[10:34:01.168]         }
[10:34:01.168]         else {
[10:34:01.168]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:01.168]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:01.168]         }
[10:34:01.168]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:01.168]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:01.168]             base::sink(type = "output", split = FALSE)
[10:34:01.168]             base::close(...future.stdout)
[10:34:01.168]         }, add = TRUE)
[10:34:01.168]     }
[10:34:01.168]     ...future.frame <- base::sys.nframe()
[10:34:01.168]     ...future.conditions <- base::list()
[10:34:01.168]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:01.168]     if (FALSE) {
[10:34:01.168]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:01.168]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:01.168]     }
[10:34:01.168]     ...future.result <- base::tryCatch({
[10:34:01.168]         base::withCallingHandlers({
[10:34:01.168]             ...future.value <- base::withVisible(base::local({
[10:34:01.168]                 withCallingHandlers({
[10:34:01.168]                   1
[10:34:01.168]                 }, immediateCondition = function(cond) {
[10:34:01.168]                   save_rds <- function (object, pathname, ...) 
[10:34:01.168]                   {
[10:34:01.168]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:34:01.168]                     if (file_test("-f", pathname_tmp)) {
[10:34:01.168]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.168]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:34:01.168]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.168]                         fi_tmp[["mtime"]])
[10:34:01.168]                     }
[10:34:01.168]                     tryCatch({
[10:34:01.168]                       saveRDS(object, file = pathname_tmp, ...)
[10:34:01.168]                     }, error = function(ex) {
[10:34:01.168]                       msg <- conditionMessage(ex)
[10:34:01.168]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.168]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:34:01.168]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.168]                         fi_tmp[["mtime"]], msg)
[10:34:01.168]                       ex$message <- msg
[10:34:01.168]                       stop(ex)
[10:34:01.168]                     })
[10:34:01.168]                     stopifnot(file_test("-f", pathname_tmp))
[10:34:01.168]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:34:01.168]                     if (!res || file_test("-f", pathname_tmp)) {
[10:34:01.168]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.168]                       fi <- file.info(pathname)
[10:34:01.168]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:34:01.168]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.168]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:34:01.168]                         fi[["size"]], fi[["mtime"]])
[10:34:01.168]                       stop(msg)
[10:34:01.168]                     }
[10:34:01.168]                     invisible(pathname)
[10:34:01.168]                   }
[10:34:01.168]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:34:01.168]                     rootPath = tempdir()) 
[10:34:01.168]                   {
[10:34:01.168]                     obj <- list(time = Sys.time(), condition = cond)
[10:34:01.168]                     file <- tempfile(pattern = class(cond)[1], 
[10:34:01.168]                       tmpdir = path, fileext = ".rds")
[10:34:01.168]                     save_rds(obj, file)
[10:34:01.168]                   }
[10:34:01.168]                   saveImmediateCondition(cond, path = "/tmp/RtmpuZEzLw/.future/immediateConditions")
[10:34:01.168]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.168]                   {
[10:34:01.168]                     inherits <- base::inherits
[10:34:01.168]                     invokeRestart <- base::invokeRestart
[10:34:01.168]                     is.null <- base::is.null
[10:34:01.168]                     muffled <- FALSE
[10:34:01.168]                     if (inherits(cond, "message")) {
[10:34:01.168]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:01.168]                       if (muffled) 
[10:34:01.168]                         invokeRestart("muffleMessage")
[10:34:01.168]                     }
[10:34:01.168]                     else if (inherits(cond, "warning")) {
[10:34:01.168]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:01.168]                       if (muffled) 
[10:34:01.168]                         invokeRestart("muffleWarning")
[10:34:01.168]                     }
[10:34:01.168]                     else if (inherits(cond, "condition")) {
[10:34:01.168]                       if (!is.null(pattern)) {
[10:34:01.168]                         computeRestarts <- base::computeRestarts
[10:34:01.168]                         grepl <- base::grepl
[10:34:01.168]                         restarts <- computeRestarts(cond)
[10:34:01.168]                         for (restart in restarts) {
[10:34:01.168]                           name <- restart$name
[10:34:01.168]                           if (is.null(name)) 
[10:34:01.168]                             next
[10:34:01.168]                           if (!grepl(pattern, name)) 
[10:34:01.168]                             next
[10:34:01.168]                           invokeRestart(restart)
[10:34:01.168]                           muffled <- TRUE
[10:34:01.168]                           break
[10:34:01.168]                         }
[10:34:01.168]                       }
[10:34:01.168]                     }
[10:34:01.168]                     invisible(muffled)
[10:34:01.168]                   }
[10:34:01.168]                   muffleCondition(cond)
[10:34:01.168]                 })
[10:34:01.168]             }))
[10:34:01.168]             future::FutureResult(value = ...future.value$value, 
[10:34:01.168]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:01.168]                   ...future.rng), globalenv = if (FALSE) 
[10:34:01.168]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:01.168]                     ...future.globalenv.names))
[10:34:01.168]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:01.168]         }, condition = base::local({
[10:34:01.168]             c <- base::c
[10:34:01.168]             inherits <- base::inherits
[10:34:01.168]             invokeRestart <- base::invokeRestart
[10:34:01.168]             length <- base::length
[10:34:01.168]             list <- base::list
[10:34:01.168]             seq.int <- base::seq.int
[10:34:01.168]             signalCondition <- base::signalCondition
[10:34:01.168]             sys.calls <- base::sys.calls
[10:34:01.168]             `[[` <- base::`[[`
[10:34:01.168]             `+` <- base::`+`
[10:34:01.168]             `<<-` <- base::`<<-`
[10:34:01.168]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:01.168]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:01.168]                   3L)]
[10:34:01.168]             }
[10:34:01.168]             function(cond) {
[10:34:01.168]                 is_error <- inherits(cond, "error")
[10:34:01.168]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:01.168]                   NULL)
[10:34:01.168]                 if (is_error) {
[10:34:01.168]                   sessionInformation <- function() {
[10:34:01.168]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:01.168]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:01.168]                       search = base::search(), system = base::Sys.info())
[10:34:01.168]                   }
[10:34:01.168]                   ...future.conditions[[length(...future.conditions) + 
[10:34:01.168]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:01.168]                     cond$call), session = sessionInformation(), 
[10:34:01.168]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:01.168]                   signalCondition(cond)
[10:34:01.168]                 }
[10:34:01.168]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:01.168]                 "immediateCondition"))) {
[10:34:01.168]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:01.168]                   ...future.conditions[[length(...future.conditions) + 
[10:34:01.168]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:01.168]                   if (TRUE && !signal) {
[10:34:01.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.168]                     {
[10:34:01.168]                       inherits <- base::inherits
[10:34:01.168]                       invokeRestart <- base::invokeRestart
[10:34:01.168]                       is.null <- base::is.null
[10:34:01.168]                       muffled <- FALSE
[10:34:01.168]                       if (inherits(cond, "message")) {
[10:34:01.168]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:01.168]                         if (muffled) 
[10:34:01.168]                           invokeRestart("muffleMessage")
[10:34:01.168]                       }
[10:34:01.168]                       else if (inherits(cond, "warning")) {
[10:34:01.168]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:01.168]                         if (muffled) 
[10:34:01.168]                           invokeRestart("muffleWarning")
[10:34:01.168]                       }
[10:34:01.168]                       else if (inherits(cond, "condition")) {
[10:34:01.168]                         if (!is.null(pattern)) {
[10:34:01.168]                           computeRestarts <- base::computeRestarts
[10:34:01.168]                           grepl <- base::grepl
[10:34:01.168]                           restarts <- computeRestarts(cond)
[10:34:01.168]                           for (restart in restarts) {
[10:34:01.168]                             name <- restart$name
[10:34:01.168]                             if (is.null(name)) 
[10:34:01.168]                               next
[10:34:01.168]                             if (!grepl(pattern, name)) 
[10:34:01.168]                               next
[10:34:01.168]                             invokeRestart(restart)
[10:34:01.168]                             muffled <- TRUE
[10:34:01.168]                             break
[10:34:01.168]                           }
[10:34:01.168]                         }
[10:34:01.168]                       }
[10:34:01.168]                       invisible(muffled)
[10:34:01.168]                     }
[10:34:01.168]                     muffleCondition(cond, pattern = "^muffle")
[10:34:01.168]                   }
[10:34:01.168]                 }
[10:34:01.168]                 else {
[10:34:01.168]                   if (TRUE) {
[10:34:01.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.168]                     {
[10:34:01.168]                       inherits <- base::inherits
[10:34:01.168]                       invokeRestart <- base::invokeRestart
[10:34:01.168]                       is.null <- base::is.null
[10:34:01.168]                       muffled <- FALSE
[10:34:01.168]                       if (inherits(cond, "message")) {
[10:34:01.168]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:01.168]                         if (muffled) 
[10:34:01.168]                           invokeRestart("muffleMessage")
[10:34:01.168]                       }
[10:34:01.168]                       else if (inherits(cond, "warning")) {
[10:34:01.168]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:01.168]                         if (muffled) 
[10:34:01.168]                           invokeRestart("muffleWarning")
[10:34:01.168]                       }
[10:34:01.168]                       else if (inherits(cond, "condition")) {
[10:34:01.168]                         if (!is.null(pattern)) {
[10:34:01.168]                           computeRestarts <- base::computeRestarts
[10:34:01.168]                           grepl <- base::grepl
[10:34:01.168]                           restarts <- computeRestarts(cond)
[10:34:01.168]                           for (restart in restarts) {
[10:34:01.168]                             name <- restart$name
[10:34:01.168]                             if (is.null(name)) 
[10:34:01.168]                               next
[10:34:01.168]                             if (!grepl(pattern, name)) 
[10:34:01.168]                               next
[10:34:01.168]                             invokeRestart(restart)
[10:34:01.168]                             muffled <- TRUE
[10:34:01.168]                             break
[10:34:01.168]                           }
[10:34:01.168]                         }
[10:34:01.168]                       }
[10:34:01.168]                       invisible(muffled)
[10:34:01.168]                     }
[10:34:01.168]                     muffleCondition(cond, pattern = "^muffle")
[10:34:01.168]                   }
[10:34:01.168]                 }
[10:34:01.168]             }
[10:34:01.168]         }))
[10:34:01.168]     }, error = function(ex) {
[10:34:01.168]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:01.168]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:01.168]                 ...future.rng), started = ...future.startTime, 
[10:34:01.168]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:01.168]             version = "1.8"), class = "FutureResult")
[10:34:01.168]     }, finally = {
[10:34:01.168]         if (!identical(...future.workdir, getwd())) 
[10:34:01.168]             setwd(...future.workdir)
[10:34:01.168]         {
[10:34:01.168]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:01.168]                 ...future.oldOptions$nwarnings <- NULL
[10:34:01.168]             }
[10:34:01.168]             base::options(...future.oldOptions)
[10:34:01.168]             if (.Platform$OS.type == "windows") {
[10:34:01.168]                 old_names <- names(...future.oldEnvVars)
[10:34:01.168]                 envs <- base::Sys.getenv()
[10:34:01.168]                 names <- names(envs)
[10:34:01.168]                 common <- intersect(names, old_names)
[10:34:01.168]                 added <- setdiff(names, old_names)
[10:34:01.168]                 removed <- setdiff(old_names, names)
[10:34:01.168]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:01.168]                   envs[common]]
[10:34:01.168]                 NAMES <- toupper(changed)
[10:34:01.168]                 args <- list()
[10:34:01.168]                 for (kk in seq_along(NAMES)) {
[10:34:01.168]                   name <- changed[[kk]]
[10:34:01.168]                   NAME <- NAMES[[kk]]
[10:34:01.168]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.168]                     next
[10:34:01.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:01.168]                 }
[10:34:01.168]                 NAMES <- toupper(added)
[10:34:01.168]                 for (kk in seq_along(NAMES)) {
[10:34:01.168]                   name <- added[[kk]]
[10:34:01.168]                   NAME <- NAMES[[kk]]
[10:34:01.168]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.168]                     next
[10:34:01.168]                   args[[name]] <- ""
[10:34:01.168]                 }
[10:34:01.168]                 NAMES <- toupper(removed)
[10:34:01.168]                 for (kk in seq_along(NAMES)) {
[10:34:01.168]                   name <- removed[[kk]]
[10:34:01.168]                   NAME <- NAMES[[kk]]
[10:34:01.168]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.168]                     next
[10:34:01.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:01.168]                 }
[10:34:01.168]                 if (length(args) > 0) 
[10:34:01.168]                   base::do.call(base::Sys.setenv, args = args)
[10:34:01.168]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:01.168]             }
[10:34:01.168]             else {
[10:34:01.168]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:01.168]             }
[10:34:01.168]             {
[10:34:01.168]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:01.168]                   0L) {
[10:34:01.168]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:01.168]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:01.168]                   base::options(opts)
[10:34:01.168]                 }
[10:34:01.168]                 {
[10:34:01.168]                   {
[10:34:01.168]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:01.168]                     NULL
[10:34:01.168]                   }
[10:34:01.168]                   options(future.plan = NULL)
[10:34:01.168]                   if (is.na(NA_character_)) 
[10:34:01.168]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:01.168]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:01.168]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:01.168]                     .init = FALSE)
[10:34:01.168]                 }
[10:34:01.168]             }
[10:34:01.168]         }
[10:34:01.168]     })
[10:34:01.168]     if (TRUE) {
[10:34:01.168]         base::sink(type = "output", split = FALSE)
[10:34:01.168]         if (TRUE) {
[10:34:01.168]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:01.168]         }
[10:34:01.168]         else {
[10:34:01.168]             ...future.result["stdout"] <- base::list(NULL)
[10:34:01.168]         }
[10:34:01.168]         base::close(...future.stdout)
[10:34:01.168]         ...future.stdout <- NULL
[10:34:01.168]     }
[10:34:01.168]     ...future.result$conditions <- ...future.conditions
[10:34:01.168]     ...future.result$finished <- base::Sys.time()
[10:34:01.168]     ...future.result
[10:34:01.168] }
[10:34:01.170] requestCore(): workers = 2
[10:34:01.172] MulticoreFuture started
[10:34:01.173] - Launch lazy future ... done
[10:34:01.173] run() for ‘MulticoreFuture’ ... done
[10:34:01.173] getGlobalsAndPackages() ...
[10:34:01.173] Searching for globals...
[10:34:01.173] plan(): Setting new future strategy stack:
[10:34:01.174] 
[10:34:01.174] List of future strategies:
[10:34:01.174] 1. sequential:
[10:34:01.174]    - args: function (..., envir = parent.frame())
[10:34:01.174]    - tweaked: FALSE
[10:34:01.174]    - call: NULL
[10:34:01.174] Searching for globals ... DONE
[10:34:01.175] - globals: [0] <none>
[10:34:01.175] plan(): nbrOfWorkers() = 1
[10:34:01.175] getGlobalsAndPackages() ... DONE
[10:34:01.175] run() for ‘Future’ ...
[10:34:01.175] - state: ‘created’
[10:34:01.176] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:34:01.176] plan(): Setting new future strategy stack:
[10:34:01.177] List of future strategies:
[10:34:01.177] 1. multicore:
[10:34:01.177]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:34:01.177]    - tweaked: FALSE
[10:34:01.177]    - call: plan(strategy)
[10:34:01.181] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:01.181] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:34:01.181]   - Field: ‘label’
[10:34:01.181]   - Field: ‘local’
[10:34:01.181]   - Field: ‘owner’
[10:34:01.182] plan(): nbrOfWorkers() = 2
[10:34:01.182]   - Field: ‘envir’
[10:34:01.182]   - Field: ‘workers’
[10:34:01.182]   - Field: ‘packages’
[10:34:01.182]   - Field: ‘gc’
[10:34:01.182]   - Field: ‘job’
[10:34:01.182]   - Field: ‘conditions’
[10:34:01.182]   - Field: ‘expr’
[10:34:01.183]   - Field: ‘uuid’
[10:34:01.183]   - Field: ‘seed’
[10:34:01.183]   - Field: ‘version’
[10:34:01.183]   - Field: ‘result’
[10:34:01.183]   - Field: ‘asynchronous’
[10:34:01.183]   - Field: ‘calls’
[10:34:01.184]   - Field: ‘globals’
[10:34:01.184]   - Field: ‘stdout’
[10:34:01.184]   - Field: ‘earlySignal’
[10:34:01.184]   - Field: ‘lazy’
[10:34:01.184]   - Field: ‘state’
[10:34:01.184] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:34:01.184] - Launch lazy future ...
[10:34:01.185] Packages needed by the future expression (n = 0): <none>
[10:34:01.185] Packages needed by future strategies (n = 0): <none>
[10:34:01.186] {
[10:34:01.186]     {
[10:34:01.186]         {
[10:34:01.186]             ...future.startTime <- base::Sys.time()
[10:34:01.186]             {
[10:34:01.186]                 {
[10:34:01.186]                   {
[10:34:01.186]                     {
[10:34:01.186]                       base::local({
[10:34:01.186]                         has_future <- base::requireNamespace("future", 
[10:34:01.186]                           quietly = TRUE)
[10:34:01.186]                         if (has_future) {
[10:34:01.186]                           ns <- base::getNamespace("future")
[10:34:01.186]                           version <- ns[[".package"]][["version"]]
[10:34:01.186]                           if (is.null(version)) 
[10:34:01.186]                             version <- utils::packageVersion("future")
[10:34:01.186]                         }
[10:34:01.186]                         else {
[10:34:01.186]                           version <- NULL
[10:34:01.186]                         }
[10:34:01.186]                         if (!has_future || version < "1.8.0") {
[10:34:01.186]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:01.186]                             "", base::R.version$version.string), 
[10:34:01.186]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:01.186]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:01.186]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:01.186]                               "release", "version")], collapse = " "), 
[10:34:01.186]                             hostname = base::Sys.info()[["nodename"]])
[10:34:01.186]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:01.186]                             info)
[10:34:01.186]                           info <- base::paste(info, collapse = "; ")
[10:34:01.186]                           if (!has_future) {
[10:34:01.186]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:01.186]                               info)
[10:34:01.186]                           }
[10:34:01.186]                           else {
[10:34:01.186]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:01.186]                               info, version)
[10:34:01.186]                           }
[10:34:01.186]                           base::stop(msg)
[10:34:01.186]                         }
[10:34:01.186]                       })
[10:34:01.186]                     }
[10:34:01.186]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:01.186]                     base::options(mc.cores = 1L)
[10:34:01.186]                   }
[10:34:01.186]                   ...future.strategy.old <- future::plan("list")
[10:34:01.186]                   options(future.plan = NULL)
[10:34:01.186]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:01.186]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:01.186]                 }
[10:34:01.186]                 ...future.workdir <- getwd()
[10:34:01.186]             }
[10:34:01.186]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:01.186]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:01.186]         }
[10:34:01.186]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:01.186]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:01.186]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:01.186]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:01.186]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:01.186]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:01.186]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:01.186]             base::names(...future.oldOptions))
[10:34:01.186]     }
[10:34:01.186]     if (FALSE) {
[10:34:01.186]     }
[10:34:01.186]     else {
[10:34:01.186]         if (TRUE) {
[10:34:01.186]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:01.186]                 open = "w")
[10:34:01.186]         }
[10:34:01.186]         else {
[10:34:01.186]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:01.186]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:01.186]         }
[10:34:01.186]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:01.186]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:01.186]             base::sink(type = "output", split = FALSE)
[10:34:01.186]             base::close(...future.stdout)
[10:34:01.186]         }, add = TRUE)
[10:34:01.186]     }
[10:34:01.186]     ...future.frame <- base::sys.nframe()
[10:34:01.186]     ...future.conditions <- base::list()
[10:34:01.186]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:01.186]     if (FALSE) {
[10:34:01.186]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:01.186]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:01.186]     }
[10:34:01.186]     ...future.result <- base::tryCatch({
[10:34:01.186]         base::withCallingHandlers({
[10:34:01.186]             ...future.value <- base::withVisible(base::local({
[10:34:01.186]                 withCallingHandlers({
[10:34:01.186]                   2
[10:34:01.186]                 }, immediateCondition = function(cond) {
[10:34:01.186]                   save_rds <- function (object, pathname, ...) 
[10:34:01.186]                   {
[10:34:01.186]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:34:01.186]                     if (file_test("-f", pathname_tmp)) {
[10:34:01.186]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.186]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:34:01.186]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.186]                         fi_tmp[["mtime"]])
[10:34:01.186]                     }
[10:34:01.186]                     tryCatch({
[10:34:01.186]                       saveRDS(object, file = pathname_tmp, ...)
[10:34:01.186]                     }, error = function(ex) {
[10:34:01.186]                       msg <- conditionMessage(ex)
[10:34:01.186]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.186]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:34:01.186]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.186]                         fi_tmp[["mtime"]], msg)
[10:34:01.186]                       ex$message <- msg
[10:34:01.186]                       stop(ex)
[10:34:01.186]                     })
[10:34:01.186]                     stopifnot(file_test("-f", pathname_tmp))
[10:34:01.186]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:34:01.186]                     if (!res || file_test("-f", pathname_tmp)) {
[10:34:01.186]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.186]                       fi <- file.info(pathname)
[10:34:01.186]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:34:01.186]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.186]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:34:01.186]                         fi[["size"]], fi[["mtime"]])
[10:34:01.186]                       stop(msg)
[10:34:01.186]                     }
[10:34:01.186]                     invisible(pathname)
[10:34:01.186]                   }
[10:34:01.186]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:34:01.186]                     rootPath = tempdir()) 
[10:34:01.186]                   {
[10:34:01.186]                     obj <- list(time = Sys.time(), condition = cond)
[10:34:01.186]                     file <- tempfile(pattern = class(cond)[1], 
[10:34:01.186]                       tmpdir = path, fileext = ".rds")
[10:34:01.186]                     save_rds(obj, file)
[10:34:01.186]                   }
[10:34:01.186]                   saveImmediateCondition(cond, path = "/tmp/RtmpuZEzLw/.future/immediateConditions")
[10:34:01.186]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.186]                   {
[10:34:01.186]                     inherits <- base::inherits
[10:34:01.186]                     invokeRestart <- base::invokeRestart
[10:34:01.186]                     is.null <- base::is.null
[10:34:01.186]                     muffled <- FALSE
[10:34:01.186]                     if (inherits(cond, "message")) {
[10:34:01.186]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:01.186]                       if (muffled) 
[10:34:01.186]                         invokeRestart("muffleMessage")
[10:34:01.186]                     }
[10:34:01.186]                     else if (inherits(cond, "warning")) {
[10:34:01.186]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:01.186]                       if (muffled) 
[10:34:01.186]                         invokeRestart("muffleWarning")
[10:34:01.186]                     }
[10:34:01.186]                     else if (inherits(cond, "condition")) {
[10:34:01.186]                       if (!is.null(pattern)) {
[10:34:01.186]                         computeRestarts <- base::computeRestarts
[10:34:01.186]                         grepl <- base::grepl
[10:34:01.186]                         restarts <- computeRestarts(cond)
[10:34:01.186]                         for (restart in restarts) {
[10:34:01.186]                           name <- restart$name
[10:34:01.186]                           if (is.null(name)) 
[10:34:01.186]                             next
[10:34:01.186]                           if (!grepl(pattern, name)) 
[10:34:01.186]                             next
[10:34:01.186]                           invokeRestart(restart)
[10:34:01.186]                           muffled <- TRUE
[10:34:01.186]                           break
[10:34:01.186]                         }
[10:34:01.186]                       }
[10:34:01.186]                     }
[10:34:01.186]                     invisible(muffled)
[10:34:01.186]                   }
[10:34:01.186]                   muffleCondition(cond)
[10:34:01.186]                 })
[10:34:01.186]             }))
[10:34:01.186]             future::FutureResult(value = ...future.value$value, 
[10:34:01.186]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:01.186]                   ...future.rng), globalenv = if (FALSE) 
[10:34:01.186]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:01.186]                     ...future.globalenv.names))
[10:34:01.186]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:01.186]         }, condition = base::local({
[10:34:01.186]             c <- base::c
[10:34:01.186]             inherits <- base::inherits
[10:34:01.186]             invokeRestart <- base::invokeRestart
[10:34:01.186]             length <- base::length
[10:34:01.186]             list <- base::list
[10:34:01.186]             seq.int <- base::seq.int
[10:34:01.186]             signalCondition <- base::signalCondition
[10:34:01.186]             sys.calls <- base::sys.calls
[10:34:01.186]             `[[` <- base::`[[`
[10:34:01.186]             `+` <- base::`+`
[10:34:01.186]             `<<-` <- base::`<<-`
[10:34:01.186]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:01.186]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:01.186]                   3L)]
[10:34:01.186]             }
[10:34:01.186]             function(cond) {
[10:34:01.186]                 is_error <- inherits(cond, "error")
[10:34:01.186]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:01.186]                   NULL)
[10:34:01.186]                 if (is_error) {
[10:34:01.186]                   sessionInformation <- function() {
[10:34:01.186]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:01.186]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:01.186]                       search = base::search(), system = base::Sys.info())
[10:34:01.186]                   }
[10:34:01.186]                   ...future.conditions[[length(...future.conditions) + 
[10:34:01.186]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:01.186]                     cond$call), session = sessionInformation(), 
[10:34:01.186]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:01.186]                   signalCondition(cond)
[10:34:01.186]                 }
[10:34:01.186]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:01.186]                 "immediateCondition"))) {
[10:34:01.186]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:01.186]                   ...future.conditions[[length(...future.conditions) + 
[10:34:01.186]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:01.186]                   if (TRUE && !signal) {
[10:34:01.186]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.186]                     {
[10:34:01.186]                       inherits <- base::inherits
[10:34:01.186]                       invokeRestart <- base::invokeRestart
[10:34:01.186]                       is.null <- base::is.null
[10:34:01.186]                       muffled <- FALSE
[10:34:01.186]                       if (inherits(cond, "message")) {
[10:34:01.186]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:01.186]                         if (muffled) 
[10:34:01.186]                           invokeRestart("muffleMessage")
[10:34:01.186]                       }
[10:34:01.186]                       else if (inherits(cond, "warning")) {
[10:34:01.186]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:01.186]                         if (muffled) 
[10:34:01.186]                           invokeRestart("muffleWarning")
[10:34:01.186]                       }
[10:34:01.186]                       else if (inherits(cond, "condition")) {
[10:34:01.186]                         if (!is.null(pattern)) {
[10:34:01.186]                           computeRestarts <- base::computeRestarts
[10:34:01.186]                           grepl <- base::grepl
[10:34:01.186]                           restarts <- computeRestarts(cond)
[10:34:01.186]                           for (restart in restarts) {
[10:34:01.186]                             name <- restart$name
[10:34:01.186]                             if (is.null(name)) 
[10:34:01.186]                               next
[10:34:01.186]                             if (!grepl(pattern, name)) 
[10:34:01.186]                               next
[10:34:01.186]                             invokeRestart(restart)
[10:34:01.186]                             muffled <- TRUE
[10:34:01.186]                             break
[10:34:01.186]                           }
[10:34:01.186]                         }
[10:34:01.186]                       }
[10:34:01.186]                       invisible(muffled)
[10:34:01.186]                     }
[10:34:01.186]                     muffleCondition(cond, pattern = "^muffle")
[10:34:01.186]                   }
[10:34:01.186]                 }
[10:34:01.186]                 else {
[10:34:01.186]                   if (TRUE) {
[10:34:01.186]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.186]                     {
[10:34:01.186]                       inherits <- base::inherits
[10:34:01.186]                       invokeRestart <- base::invokeRestart
[10:34:01.186]                       is.null <- base::is.null
[10:34:01.186]                       muffled <- FALSE
[10:34:01.186]                       if (inherits(cond, "message")) {
[10:34:01.186]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:01.186]                         if (muffled) 
[10:34:01.186]                           invokeRestart("muffleMessage")
[10:34:01.186]                       }
[10:34:01.186]                       else if (inherits(cond, "warning")) {
[10:34:01.186]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:01.186]                         if (muffled) 
[10:34:01.186]                           invokeRestart("muffleWarning")
[10:34:01.186]                       }
[10:34:01.186]                       else if (inherits(cond, "condition")) {
[10:34:01.186]                         if (!is.null(pattern)) {
[10:34:01.186]                           computeRestarts <- base::computeRestarts
[10:34:01.186]                           grepl <- base::grepl
[10:34:01.186]                           restarts <- computeRestarts(cond)
[10:34:01.186]                           for (restart in restarts) {
[10:34:01.186]                             name <- restart$name
[10:34:01.186]                             if (is.null(name)) 
[10:34:01.186]                               next
[10:34:01.186]                             if (!grepl(pattern, name)) 
[10:34:01.186]                               next
[10:34:01.186]                             invokeRestart(restart)
[10:34:01.186]                             muffled <- TRUE
[10:34:01.186]                             break
[10:34:01.186]                           }
[10:34:01.186]                         }
[10:34:01.186]                       }
[10:34:01.186]                       invisible(muffled)
[10:34:01.186]                     }
[10:34:01.186]                     muffleCondition(cond, pattern = "^muffle")
[10:34:01.186]                   }
[10:34:01.186]                 }
[10:34:01.186]             }
[10:34:01.186]         }))
[10:34:01.186]     }, error = function(ex) {
[10:34:01.186]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:01.186]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:01.186]                 ...future.rng), started = ...future.startTime, 
[10:34:01.186]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:01.186]             version = "1.8"), class = "FutureResult")
[10:34:01.186]     }, finally = {
[10:34:01.186]         if (!identical(...future.workdir, getwd())) 
[10:34:01.186]             setwd(...future.workdir)
[10:34:01.186]         {
[10:34:01.186]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:01.186]                 ...future.oldOptions$nwarnings <- NULL
[10:34:01.186]             }
[10:34:01.186]             base::options(...future.oldOptions)
[10:34:01.186]             if (.Platform$OS.type == "windows") {
[10:34:01.186]                 old_names <- names(...future.oldEnvVars)
[10:34:01.186]                 envs <- base::Sys.getenv()
[10:34:01.186]                 names <- names(envs)
[10:34:01.186]                 common <- intersect(names, old_names)
[10:34:01.186]                 added <- setdiff(names, old_names)
[10:34:01.186]                 removed <- setdiff(old_names, names)
[10:34:01.186]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:01.186]                   envs[common]]
[10:34:01.186]                 NAMES <- toupper(changed)
[10:34:01.186]                 args <- list()
[10:34:01.186]                 for (kk in seq_along(NAMES)) {
[10:34:01.186]                   name <- changed[[kk]]
[10:34:01.186]                   NAME <- NAMES[[kk]]
[10:34:01.186]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.186]                     next
[10:34:01.186]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:01.186]                 }
[10:34:01.186]                 NAMES <- toupper(added)
[10:34:01.186]                 for (kk in seq_along(NAMES)) {
[10:34:01.186]                   name <- added[[kk]]
[10:34:01.186]                   NAME <- NAMES[[kk]]
[10:34:01.186]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.186]                     next
[10:34:01.186]                   args[[name]] <- ""
[10:34:01.186]                 }
[10:34:01.186]                 NAMES <- toupper(removed)
[10:34:01.186]                 for (kk in seq_along(NAMES)) {
[10:34:01.186]                   name <- removed[[kk]]
[10:34:01.186]                   NAME <- NAMES[[kk]]
[10:34:01.186]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.186]                     next
[10:34:01.186]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:01.186]                 }
[10:34:01.186]                 if (length(args) > 0) 
[10:34:01.186]                   base::do.call(base::Sys.setenv, args = args)
[10:34:01.186]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:01.186]             }
[10:34:01.186]             else {
[10:34:01.186]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:01.186]             }
[10:34:01.186]             {
[10:34:01.186]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:01.186]                   0L) {
[10:34:01.186]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:01.186]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:01.186]                   base::options(opts)
[10:34:01.186]                 }
[10:34:01.186]                 {
[10:34:01.186]                   {
[10:34:01.186]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:01.186]                     NULL
[10:34:01.186]                   }
[10:34:01.186]                   options(future.plan = NULL)
[10:34:01.186]                   if (is.na(NA_character_)) 
[10:34:01.186]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:01.186]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:01.186]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:01.186]                     .init = FALSE)
[10:34:01.186]                 }
[10:34:01.186]             }
[10:34:01.186]         }
[10:34:01.186]     })
[10:34:01.186]     if (TRUE) {
[10:34:01.186]         base::sink(type = "output", split = FALSE)
[10:34:01.186]         if (TRUE) {
[10:34:01.186]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:01.186]         }
[10:34:01.186]         else {
[10:34:01.186]             ...future.result["stdout"] <- base::list(NULL)
[10:34:01.186]         }
[10:34:01.186]         base::close(...future.stdout)
[10:34:01.186]         ...future.stdout <- NULL
[10:34:01.186]     }
[10:34:01.186]     ...future.result$conditions <- ...future.conditions
[10:34:01.186]     ...future.result$finished <- base::Sys.time()
[10:34:01.186]     ...future.result
[10:34:01.186] }
[10:34:01.189] requestCore(): workers = 2
[10:34:01.191] MulticoreFuture started
[10:34:01.192] - Launch lazy future ... done
[10:34:01.192] run() for ‘MulticoreFuture’ ... done
[10:34:01.192] plan(): Setting new future strategy stack:
[10:34:01.193] List of future strategies:
[10:34:01.193] 1. sequential:
[10:34:01.193]    - args: function (..., envir = parent.frame())
[10:34:01.193]    - tweaked: FALSE
[10:34:01.193]    - call: NULL
[10:34:01.198] plan(): nbrOfWorkers() = 1
[10:34:01.198] resolve() on list environment ...
[10:34:01.199]  recursive: 0
[10:34:01.201] plan(): Setting new future strategy stack:
[10:34:01.201]  length: 3
[10:34:01.201] List of future strategies:
[10:34:01.201] 1. multicore:
[10:34:01.201]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:34:01.201]    - tweaked: FALSE
[10:34:01.201]    - call: plan(strategy)
[10:34:01.202]  elements: ‘a’, ‘b’, ‘c’
[10:34:01.203] Future #1
[10:34:01.203]  length: 2 (resolved future 1)
[10:34:01.207] plan(): nbrOfWorkers() = 2
[10:34:01.208] Future #2
[10:34:01.208]  length: 1 (resolved future 2)
[10:34:01.208]  length: 0 (resolved future 3)
[10:34:01.208] resolve() on list environment ... DONE
[10:34:01.210] getGlobalsAndPackages() ...
[10:34:01.210] Searching for globals...
[10:34:01.211] - globals found: [1] ‘{’
[10:34:01.212] Searching for globals ... DONE
[10:34:01.212] Resolving globals: FALSE
[10:34:01.212] 
[10:34:01.213] 
[10:34:01.213] getGlobalsAndPackages() ... DONE
[10:34:01.213] run() for ‘Future’ ...
[10:34:01.214] - state: ‘created’
[10:34:01.214] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:34:01.218] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:01.219] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:34:01.219]   - Field: ‘label’
[10:34:01.219]   - Field: ‘local’
[10:34:01.219]   - Field: ‘owner’
[10:34:01.219]   - Field: ‘envir’
[10:34:01.219]   - Field: ‘workers’
[10:34:01.219]   - Field: ‘packages’
[10:34:01.220]   - Field: ‘gc’
[10:34:01.220]   - Field: ‘job’
[10:34:01.220]   - Field: ‘conditions’
[10:34:01.220]   - Field: ‘expr’
[10:34:01.220]   - Field: ‘uuid’
[10:34:01.220]   - Field: ‘seed’
[10:34:01.220]   - Field: ‘version’
[10:34:01.220]   - Field: ‘result’
[10:34:01.221]   - Field: ‘asynchronous’
[10:34:01.221]   - Field: ‘calls’
[10:34:01.221]   - Field: ‘globals’
[10:34:01.221]   - Field: ‘stdout’
[10:34:01.221]   - Field: ‘earlySignal’
[10:34:01.221]   - Field: ‘lazy’
[10:34:01.221]   - Field: ‘state’
[10:34:01.222] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:34:01.222] - Launch lazy future ...
[10:34:01.222] Packages needed by the future expression (n = 0): <none>
[10:34:01.222] Packages needed by future strategies (n = 0): <none>
[10:34:01.223] {
[10:34:01.223]     {
[10:34:01.223]         {
[10:34:01.223]             ...future.startTime <- base::Sys.time()
[10:34:01.223]             {
[10:34:01.223]                 {
[10:34:01.223]                   {
[10:34:01.223]                     {
[10:34:01.223]                       base::local({
[10:34:01.223]                         has_future <- base::requireNamespace("future", 
[10:34:01.223]                           quietly = TRUE)
[10:34:01.223]                         if (has_future) {
[10:34:01.223]                           ns <- base::getNamespace("future")
[10:34:01.223]                           version <- ns[[".package"]][["version"]]
[10:34:01.223]                           if (is.null(version)) 
[10:34:01.223]                             version <- utils::packageVersion("future")
[10:34:01.223]                         }
[10:34:01.223]                         else {
[10:34:01.223]                           version <- NULL
[10:34:01.223]                         }
[10:34:01.223]                         if (!has_future || version < "1.8.0") {
[10:34:01.223]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:01.223]                             "", base::R.version$version.string), 
[10:34:01.223]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:01.223]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:01.223]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:01.223]                               "release", "version")], collapse = " "), 
[10:34:01.223]                             hostname = base::Sys.info()[["nodename"]])
[10:34:01.223]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:01.223]                             info)
[10:34:01.223]                           info <- base::paste(info, collapse = "; ")
[10:34:01.223]                           if (!has_future) {
[10:34:01.223]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:01.223]                               info)
[10:34:01.223]                           }
[10:34:01.223]                           else {
[10:34:01.223]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:01.223]                               info, version)
[10:34:01.223]                           }
[10:34:01.223]                           base::stop(msg)
[10:34:01.223]                         }
[10:34:01.223]                       })
[10:34:01.223]                     }
[10:34:01.223]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:01.223]                     base::options(mc.cores = 1L)
[10:34:01.223]                   }
[10:34:01.223]                   ...future.strategy.old <- future::plan("list")
[10:34:01.223]                   options(future.plan = NULL)
[10:34:01.223]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:01.223]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:01.223]                 }
[10:34:01.223]                 ...future.workdir <- getwd()
[10:34:01.223]             }
[10:34:01.223]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:01.223]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:01.223]         }
[10:34:01.223]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:01.223]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:01.223]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:01.223]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:01.223]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:01.223]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:01.223]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:01.223]             base::names(...future.oldOptions))
[10:34:01.223]     }
[10:34:01.223]     if (FALSE) {
[10:34:01.223]     }
[10:34:01.223]     else {
[10:34:01.223]         if (TRUE) {
[10:34:01.223]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:01.223]                 open = "w")
[10:34:01.223]         }
[10:34:01.223]         else {
[10:34:01.223]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:01.223]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:01.223]         }
[10:34:01.223]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:01.223]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:01.223]             base::sink(type = "output", split = FALSE)
[10:34:01.223]             base::close(...future.stdout)
[10:34:01.223]         }, add = TRUE)
[10:34:01.223]     }
[10:34:01.223]     ...future.frame <- base::sys.nframe()
[10:34:01.223]     ...future.conditions <- base::list()
[10:34:01.223]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:01.223]     if (FALSE) {
[10:34:01.223]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:01.223]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:01.223]     }
[10:34:01.223]     ...future.result <- base::tryCatch({
[10:34:01.223]         base::withCallingHandlers({
[10:34:01.223]             ...future.value <- base::withVisible(base::local({
[10:34:01.223]                 withCallingHandlers({
[10:34:01.223]                   {
[10:34:01.223]                     1
[10:34:01.223]                   }
[10:34:01.223]                 }, immediateCondition = function(cond) {
[10:34:01.223]                   save_rds <- function (object, pathname, ...) 
[10:34:01.223]                   {
[10:34:01.223]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:34:01.223]                     if (file_test("-f", pathname_tmp)) {
[10:34:01.223]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.223]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:34:01.223]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.223]                         fi_tmp[["mtime"]])
[10:34:01.223]                     }
[10:34:01.223]                     tryCatch({
[10:34:01.223]                       saveRDS(object, file = pathname_tmp, ...)
[10:34:01.223]                     }, error = function(ex) {
[10:34:01.223]                       msg <- conditionMessage(ex)
[10:34:01.223]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.223]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:34:01.223]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.223]                         fi_tmp[["mtime"]], msg)
[10:34:01.223]                       ex$message <- msg
[10:34:01.223]                       stop(ex)
[10:34:01.223]                     })
[10:34:01.223]                     stopifnot(file_test("-f", pathname_tmp))
[10:34:01.223]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:34:01.223]                     if (!res || file_test("-f", pathname_tmp)) {
[10:34:01.223]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.223]                       fi <- file.info(pathname)
[10:34:01.223]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:34:01.223]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.223]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:34:01.223]                         fi[["size"]], fi[["mtime"]])
[10:34:01.223]                       stop(msg)
[10:34:01.223]                     }
[10:34:01.223]                     invisible(pathname)
[10:34:01.223]                   }
[10:34:01.223]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:34:01.223]                     rootPath = tempdir()) 
[10:34:01.223]                   {
[10:34:01.223]                     obj <- list(time = Sys.time(), condition = cond)
[10:34:01.223]                     file <- tempfile(pattern = class(cond)[1], 
[10:34:01.223]                       tmpdir = path, fileext = ".rds")
[10:34:01.223]                     save_rds(obj, file)
[10:34:01.223]                   }
[10:34:01.223]                   saveImmediateCondition(cond, path = "/tmp/RtmpuZEzLw/.future/immediateConditions")
[10:34:01.223]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.223]                   {
[10:34:01.223]                     inherits <- base::inherits
[10:34:01.223]                     invokeRestart <- base::invokeRestart
[10:34:01.223]                     is.null <- base::is.null
[10:34:01.223]                     muffled <- FALSE
[10:34:01.223]                     if (inherits(cond, "message")) {
[10:34:01.223]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:01.223]                       if (muffled) 
[10:34:01.223]                         invokeRestart("muffleMessage")
[10:34:01.223]                     }
[10:34:01.223]                     else if (inherits(cond, "warning")) {
[10:34:01.223]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:01.223]                       if (muffled) 
[10:34:01.223]                         invokeRestart("muffleWarning")
[10:34:01.223]                     }
[10:34:01.223]                     else if (inherits(cond, "condition")) {
[10:34:01.223]                       if (!is.null(pattern)) {
[10:34:01.223]                         computeRestarts <- base::computeRestarts
[10:34:01.223]                         grepl <- base::grepl
[10:34:01.223]                         restarts <- computeRestarts(cond)
[10:34:01.223]                         for (restart in restarts) {
[10:34:01.223]                           name <- restart$name
[10:34:01.223]                           if (is.null(name)) 
[10:34:01.223]                             next
[10:34:01.223]                           if (!grepl(pattern, name)) 
[10:34:01.223]                             next
[10:34:01.223]                           invokeRestart(restart)
[10:34:01.223]                           muffled <- TRUE
[10:34:01.223]                           break
[10:34:01.223]                         }
[10:34:01.223]                       }
[10:34:01.223]                     }
[10:34:01.223]                     invisible(muffled)
[10:34:01.223]                   }
[10:34:01.223]                   muffleCondition(cond)
[10:34:01.223]                 })
[10:34:01.223]             }))
[10:34:01.223]             future::FutureResult(value = ...future.value$value, 
[10:34:01.223]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:01.223]                   ...future.rng), globalenv = if (FALSE) 
[10:34:01.223]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:01.223]                     ...future.globalenv.names))
[10:34:01.223]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:01.223]         }, condition = base::local({
[10:34:01.223]             c <- base::c
[10:34:01.223]             inherits <- base::inherits
[10:34:01.223]             invokeRestart <- base::invokeRestart
[10:34:01.223]             length <- base::length
[10:34:01.223]             list <- base::list
[10:34:01.223]             seq.int <- base::seq.int
[10:34:01.223]             signalCondition <- base::signalCondition
[10:34:01.223]             sys.calls <- base::sys.calls
[10:34:01.223]             `[[` <- base::`[[`
[10:34:01.223]             `+` <- base::`+`
[10:34:01.223]             `<<-` <- base::`<<-`
[10:34:01.223]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:01.223]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:01.223]                   3L)]
[10:34:01.223]             }
[10:34:01.223]             function(cond) {
[10:34:01.223]                 is_error <- inherits(cond, "error")
[10:34:01.223]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:01.223]                   NULL)
[10:34:01.223]                 if (is_error) {
[10:34:01.223]                   sessionInformation <- function() {
[10:34:01.223]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:01.223]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:01.223]                       search = base::search(), system = base::Sys.info())
[10:34:01.223]                   }
[10:34:01.223]                   ...future.conditions[[length(...future.conditions) + 
[10:34:01.223]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:01.223]                     cond$call), session = sessionInformation(), 
[10:34:01.223]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:01.223]                   signalCondition(cond)
[10:34:01.223]                 }
[10:34:01.223]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:01.223]                 "immediateCondition"))) {
[10:34:01.223]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:01.223]                   ...future.conditions[[length(...future.conditions) + 
[10:34:01.223]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:01.223]                   if (TRUE && !signal) {
[10:34:01.223]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.223]                     {
[10:34:01.223]                       inherits <- base::inherits
[10:34:01.223]                       invokeRestart <- base::invokeRestart
[10:34:01.223]                       is.null <- base::is.null
[10:34:01.223]                       muffled <- FALSE
[10:34:01.223]                       if (inherits(cond, "message")) {
[10:34:01.223]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:01.223]                         if (muffled) 
[10:34:01.223]                           invokeRestart("muffleMessage")
[10:34:01.223]                       }
[10:34:01.223]                       else if (inherits(cond, "warning")) {
[10:34:01.223]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:01.223]                         if (muffled) 
[10:34:01.223]                           invokeRestart("muffleWarning")
[10:34:01.223]                       }
[10:34:01.223]                       else if (inherits(cond, "condition")) {
[10:34:01.223]                         if (!is.null(pattern)) {
[10:34:01.223]                           computeRestarts <- base::computeRestarts
[10:34:01.223]                           grepl <- base::grepl
[10:34:01.223]                           restarts <- computeRestarts(cond)
[10:34:01.223]                           for (restart in restarts) {
[10:34:01.223]                             name <- restart$name
[10:34:01.223]                             if (is.null(name)) 
[10:34:01.223]                               next
[10:34:01.223]                             if (!grepl(pattern, name)) 
[10:34:01.223]                               next
[10:34:01.223]                             invokeRestart(restart)
[10:34:01.223]                             muffled <- TRUE
[10:34:01.223]                             break
[10:34:01.223]                           }
[10:34:01.223]                         }
[10:34:01.223]                       }
[10:34:01.223]                       invisible(muffled)
[10:34:01.223]                     }
[10:34:01.223]                     muffleCondition(cond, pattern = "^muffle")
[10:34:01.223]                   }
[10:34:01.223]                 }
[10:34:01.223]                 else {
[10:34:01.223]                   if (TRUE) {
[10:34:01.223]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.223]                     {
[10:34:01.223]                       inherits <- base::inherits
[10:34:01.223]                       invokeRestart <- base::invokeRestart
[10:34:01.223]                       is.null <- base::is.null
[10:34:01.223]                       muffled <- FALSE
[10:34:01.223]                       if (inherits(cond, "message")) {
[10:34:01.223]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:01.223]                         if (muffled) 
[10:34:01.223]                           invokeRestart("muffleMessage")
[10:34:01.223]                       }
[10:34:01.223]                       else if (inherits(cond, "warning")) {
[10:34:01.223]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:01.223]                         if (muffled) 
[10:34:01.223]                           invokeRestart("muffleWarning")
[10:34:01.223]                       }
[10:34:01.223]                       else if (inherits(cond, "condition")) {
[10:34:01.223]                         if (!is.null(pattern)) {
[10:34:01.223]                           computeRestarts <- base::computeRestarts
[10:34:01.223]                           grepl <- base::grepl
[10:34:01.223]                           restarts <- computeRestarts(cond)
[10:34:01.223]                           for (restart in restarts) {
[10:34:01.223]                             name <- restart$name
[10:34:01.223]                             if (is.null(name)) 
[10:34:01.223]                               next
[10:34:01.223]                             if (!grepl(pattern, name)) 
[10:34:01.223]                               next
[10:34:01.223]                             invokeRestart(restart)
[10:34:01.223]                             muffled <- TRUE
[10:34:01.223]                             break
[10:34:01.223]                           }
[10:34:01.223]                         }
[10:34:01.223]                       }
[10:34:01.223]                       invisible(muffled)
[10:34:01.223]                     }
[10:34:01.223]                     muffleCondition(cond, pattern = "^muffle")
[10:34:01.223]                   }
[10:34:01.223]                 }
[10:34:01.223]             }
[10:34:01.223]         }))
[10:34:01.223]     }, error = function(ex) {
[10:34:01.223]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:01.223]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:01.223]                 ...future.rng), started = ...future.startTime, 
[10:34:01.223]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:01.223]             version = "1.8"), class = "FutureResult")
[10:34:01.223]     }, finally = {
[10:34:01.223]         if (!identical(...future.workdir, getwd())) 
[10:34:01.223]             setwd(...future.workdir)
[10:34:01.223]         {
[10:34:01.223]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:01.223]                 ...future.oldOptions$nwarnings <- NULL
[10:34:01.223]             }
[10:34:01.223]             base::options(...future.oldOptions)
[10:34:01.223]             if (.Platform$OS.type == "windows") {
[10:34:01.223]                 old_names <- names(...future.oldEnvVars)
[10:34:01.223]                 envs <- base::Sys.getenv()
[10:34:01.223]                 names <- names(envs)
[10:34:01.223]                 common <- intersect(names, old_names)
[10:34:01.223]                 added <- setdiff(names, old_names)
[10:34:01.223]                 removed <- setdiff(old_names, names)
[10:34:01.223]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:01.223]                   envs[common]]
[10:34:01.223]                 NAMES <- toupper(changed)
[10:34:01.223]                 args <- list()
[10:34:01.223]                 for (kk in seq_along(NAMES)) {
[10:34:01.223]                   name <- changed[[kk]]
[10:34:01.223]                   NAME <- NAMES[[kk]]
[10:34:01.223]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.223]                     next
[10:34:01.223]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:01.223]                 }
[10:34:01.223]                 NAMES <- toupper(added)
[10:34:01.223]                 for (kk in seq_along(NAMES)) {
[10:34:01.223]                   name <- added[[kk]]
[10:34:01.223]                   NAME <- NAMES[[kk]]
[10:34:01.223]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.223]                     next
[10:34:01.223]                   args[[name]] <- ""
[10:34:01.223]                 }
[10:34:01.223]                 NAMES <- toupper(removed)
[10:34:01.223]                 for (kk in seq_along(NAMES)) {
[10:34:01.223]                   name <- removed[[kk]]
[10:34:01.223]                   NAME <- NAMES[[kk]]
[10:34:01.223]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.223]                     next
[10:34:01.223]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:01.223]                 }
[10:34:01.223]                 if (length(args) > 0) 
[10:34:01.223]                   base::do.call(base::Sys.setenv, args = args)
[10:34:01.223]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:01.223]             }
[10:34:01.223]             else {
[10:34:01.223]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:01.223]             }
[10:34:01.223]             {
[10:34:01.223]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:01.223]                   0L) {
[10:34:01.223]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:01.223]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:01.223]                   base::options(opts)
[10:34:01.223]                 }
[10:34:01.223]                 {
[10:34:01.223]                   {
[10:34:01.223]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:01.223]                     NULL
[10:34:01.223]                   }
[10:34:01.223]                   options(future.plan = NULL)
[10:34:01.223]                   if (is.na(NA_character_)) 
[10:34:01.223]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:01.223]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:01.223]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:01.223]                     .init = FALSE)
[10:34:01.223]                 }
[10:34:01.223]             }
[10:34:01.223]         }
[10:34:01.223]     })
[10:34:01.223]     if (TRUE) {
[10:34:01.223]         base::sink(type = "output", split = FALSE)
[10:34:01.223]         if (TRUE) {
[10:34:01.223]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:01.223]         }
[10:34:01.223]         else {
[10:34:01.223]             ...future.result["stdout"] <- base::list(NULL)
[10:34:01.223]         }
[10:34:01.223]         base::close(...future.stdout)
[10:34:01.223]         ...future.stdout <- NULL
[10:34:01.223]     }
[10:34:01.223]     ...future.result$conditions <- ...future.conditions
[10:34:01.223]     ...future.result$finished <- base::Sys.time()
[10:34:01.223]     ...future.result
[10:34:01.223] }
[10:34:01.225] requestCore(): workers = 2
[10:34:01.226] Poll #1 (0): usedCores() = 2, workers = 2
[10:34:01.236] result() for MulticoreFuture ...
[10:34:01.237] result() for MulticoreFuture ...
[10:34:01.237] result() for MulticoreFuture ... done
[10:34:01.238] result() for MulticoreFuture ... done
[10:34:01.238] result() for MulticoreFuture ...
[10:34:01.238] result() for MulticoreFuture ... done
[10:34:01.240] MulticoreFuture started
[10:34:01.241] - Launch lazy future ... done
[10:34:01.241] run() for ‘MulticoreFuture’ ... done
[10:34:01.242] plan(): Setting new future strategy stack:
[10:34:01.243] getGlobalsAndPackages() ...
[10:34:01.243] Searching for globals...
[10:34:01.242] List of future strategies:
[10:34:01.242] 1. sequential:
[10:34:01.242]    - args: function (..., envir = parent.frame())
[10:34:01.242]    - tweaked: FALSE
[10:34:01.242]    - call: NULL
[10:34:01.243] plan(): nbrOfWorkers() = 1
[10:34:01.245] - globals found: [1] ‘{’
[10:34:01.245] Searching for globals ... DONE
[10:34:01.246] Resolving globals: FALSE
[10:34:01.246] 
[10:34:01.246] plan(): Setting new future strategy stack:
[10:34:01.246] 
[10:34:01.247] getGlobalsAndPackages() ... DONE
[10:34:01.247] List of future strategies:
[10:34:01.247] 1. multicore:
[10:34:01.247]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:34:01.247]    - tweaked: FALSE
[10:34:01.247]    - call: plan(strategy)
[10:34:01.247] run() for ‘Future’ ...
[10:34:01.248] - state: ‘created’
[10:34:01.248] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:34:01.253] plan(): nbrOfWorkers() = 2
[10:34:01.253] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:01.253] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:34:01.253]   - Field: ‘label’
[10:34:01.253]   - Field: ‘local’
[10:34:01.254]   - Field: ‘owner’
[10:34:01.254]   - Field: ‘envir’
[10:34:01.254]   - Field: ‘workers’
[10:34:01.254]   - Field: ‘packages’
[10:34:01.254]   - Field: ‘gc’
[10:34:01.254]   - Field: ‘job’
[10:34:01.254]   - Field: ‘conditions’
[10:34:01.255]   - Field: ‘expr’
[10:34:01.255]   - Field: ‘uuid’
[10:34:01.255]   - Field: ‘seed’
[10:34:01.255]   - Field: ‘version’
[10:34:01.255]   - Field: ‘result’
[10:34:01.255]   - Field: ‘asynchronous’
[10:34:01.255]   - Field: ‘calls’
[10:34:01.256]   - Field: ‘globals’
[10:34:01.256]   - Field: ‘stdout’
[10:34:01.256]   - Field: ‘earlySignal’
[10:34:01.256]   - Field: ‘lazy’
[10:34:01.256]   - Field: ‘state’
[10:34:01.256] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:34:01.256] - Launch lazy future ...
[10:34:01.257] Packages needed by the future expression (n = 0): <none>
[10:34:01.257] Packages needed by future strategies (n = 0): <none>
[10:34:01.258] {
[10:34:01.258]     {
[10:34:01.258]         {
[10:34:01.258]             ...future.startTime <- base::Sys.time()
[10:34:01.258]             {
[10:34:01.258]                 {
[10:34:01.258]                   {
[10:34:01.258]                     {
[10:34:01.258]                       base::local({
[10:34:01.258]                         has_future <- base::requireNamespace("future", 
[10:34:01.258]                           quietly = TRUE)
[10:34:01.258]                         if (has_future) {
[10:34:01.258]                           ns <- base::getNamespace("future")
[10:34:01.258]                           version <- ns[[".package"]][["version"]]
[10:34:01.258]                           if (is.null(version)) 
[10:34:01.258]                             version <- utils::packageVersion("future")
[10:34:01.258]                         }
[10:34:01.258]                         else {
[10:34:01.258]                           version <- NULL
[10:34:01.258]                         }
[10:34:01.258]                         if (!has_future || version < "1.8.0") {
[10:34:01.258]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:01.258]                             "", base::R.version$version.string), 
[10:34:01.258]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:01.258]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:01.258]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:01.258]                               "release", "version")], collapse = " "), 
[10:34:01.258]                             hostname = base::Sys.info()[["nodename"]])
[10:34:01.258]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:01.258]                             info)
[10:34:01.258]                           info <- base::paste(info, collapse = "; ")
[10:34:01.258]                           if (!has_future) {
[10:34:01.258]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:01.258]                               info)
[10:34:01.258]                           }
[10:34:01.258]                           else {
[10:34:01.258]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:01.258]                               info, version)
[10:34:01.258]                           }
[10:34:01.258]                           base::stop(msg)
[10:34:01.258]                         }
[10:34:01.258]                       })
[10:34:01.258]                     }
[10:34:01.258]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:01.258]                     base::options(mc.cores = 1L)
[10:34:01.258]                   }
[10:34:01.258]                   ...future.strategy.old <- future::plan("list")
[10:34:01.258]                   options(future.plan = NULL)
[10:34:01.258]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:01.258]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:01.258]                 }
[10:34:01.258]                 ...future.workdir <- getwd()
[10:34:01.258]             }
[10:34:01.258]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:01.258]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:01.258]         }
[10:34:01.258]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:01.258]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:01.258]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:01.258]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:01.258]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:01.258]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:01.258]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:01.258]             base::names(...future.oldOptions))
[10:34:01.258]     }
[10:34:01.258]     if (FALSE) {
[10:34:01.258]     }
[10:34:01.258]     else {
[10:34:01.258]         if (TRUE) {
[10:34:01.258]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:01.258]                 open = "w")
[10:34:01.258]         }
[10:34:01.258]         else {
[10:34:01.258]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:01.258]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:01.258]         }
[10:34:01.258]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:01.258]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:01.258]             base::sink(type = "output", split = FALSE)
[10:34:01.258]             base::close(...future.stdout)
[10:34:01.258]         }, add = TRUE)
[10:34:01.258]     }
[10:34:01.258]     ...future.frame <- base::sys.nframe()
[10:34:01.258]     ...future.conditions <- base::list()
[10:34:01.258]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:01.258]     if (FALSE) {
[10:34:01.258]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:01.258]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:01.258]     }
[10:34:01.258]     ...future.result <- base::tryCatch({
[10:34:01.258]         base::withCallingHandlers({
[10:34:01.258]             ...future.value <- base::withVisible(base::local({
[10:34:01.258]                 withCallingHandlers({
[10:34:01.258]                   {
[10:34:01.258]                     2
[10:34:01.258]                   }
[10:34:01.258]                 }, immediateCondition = function(cond) {
[10:34:01.258]                   save_rds <- function (object, pathname, ...) 
[10:34:01.258]                   {
[10:34:01.258]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:34:01.258]                     if (file_test("-f", pathname_tmp)) {
[10:34:01.258]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.258]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:34:01.258]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.258]                         fi_tmp[["mtime"]])
[10:34:01.258]                     }
[10:34:01.258]                     tryCatch({
[10:34:01.258]                       saveRDS(object, file = pathname_tmp, ...)
[10:34:01.258]                     }, error = function(ex) {
[10:34:01.258]                       msg <- conditionMessage(ex)
[10:34:01.258]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.258]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:34:01.258]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.258]                         fi_tmp[["mtime"]], msg)
[10:34:01.258]                       ex$message <- msg
[10:34:01.258]                       stop(ex)
[10:34:01.258]                     })
[10:34:01.258]                     stopifnot(file_test("-f", pathname_tmp))
[10:34:01.258]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:34:01.258]                     if (!res || file_test("-f", pathname_tmp)) {
[10:34:01.258]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.258]                       fi <- file.info(pathname)
[10:34:01.258]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:34:01.258]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.258]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:34:01.258]                         fi[["size"]], fi[["mtime"]])
[10:34:01.258]                       stop(msg)
[10:34:01.258]                     }
[10:34:01.258]                     invisible(pathname)
[10:34:01.258]                   }
[10:34:01.258]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:34:01.258]                     rootPath = tempdir()) 
[10:34:01.258]                   {
[10:34:01.258]                     obj <- list(time = Sys.time(), condition = cond)
[10:34:01.258]                     file <- tempfile(pattern = class(cond)[1], 
[10:34:01.258]                       tmpdir = path, fileext = ".rds")
[10:34:01.258]                     save_rds(obj, file)
[10:34:01.258]                   }
[10:34:01.258]                   saveImmediateCondition(cond, path = "/tmp/RtmpuZEzLw/.future/immediateConditions")
[10:34:01.258]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.258]                   {
[10:34:01.258]                     inherits <- base::inherits
[10:34:01.258]                     invokeRestart <- base::invokeRestart
[10:34:01.258]                     is.null <- base::is.null
[10:34:01.258]                     muffled <- FALSE
[10:34:01.258]                     if (inherits(cond, "message")) {
[10:34:01.258]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:01.258]                       if (muffled) 
[10:34:01.258]                         invokeRestart("muffleMessage")
[10:34:01.258]                     }
[10:34:01.258]                     else if (inherits(cond, "warning")) {
[10:34:01.258]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:01.258]                       if (muffled) 
[10:34:01.258]                         invokeRestart("muffleWarning")
[10:34:01.258]                     }
[10:34:01.258]                     else if (inherits(cond, "condition")) {
[10:34:01.258]                       if (!is.null(pattern)) {
[10:34:01.258]                         computeRestarts <- base::computeRestarts
[10:34:01.258]                         grepl <- base::grepl
[10:34:01.258]                         restarts <- computeRestarts(cond)
[10:34:01.258]                         for (restart in restarts) {
[10:34:01.258]                           name <- restart$name
[10:34:01.258]                           if (is.null(name)) 
[10:34:01.258]                             next
[10:34:01.258]                           if (!grepl(pattern, name)) 
[10:34:01.258]                             next
[10:34:01.258]                           invokeRestart(restart)
[10:34:01.258]                           muffled <- TRUE
[10:34:01.258]                           break
[10:34:01.258]                         }
[10:34:01.258]                       }
[10:34:01.258]                     }
[10:34:01.258]                     invisible(muffled)
[10:34:01.258]                   }
[10:34:01.258]                   muffleCondition(cond)
[10:34:01.258]                 })
[10:34:01.258]             }))
[10:34:01.258]             future::FutureResult(value = ...future.value$value, 
[10:34:01.258]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:01.258]                   ...future.rng), globalenv = if (FALSE) 
[10:34:01.258]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:01.258]                     ...future.globalenv.names))
[10:34:01.258]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:01.258]         }, condition = base::local({
[10:34:01.258]             c <- base::c
[10:34:01.258]             inherits <- base::inherits
[10:34:01.258]             invokeRestart <- base::invokeRestart
[10:34:01.258]             length <- base::length
[10:34:01.258]             list <- base::list
[10:34:01.258]             seq.int <- base::seq.int
[10:34:01.258]             signalCondition <- base::signalCondition
[10:34:01.258]             sys.calls <- base::sys.calls
[10:34:01.258]             `[[` <- base::`[[`
[10:34:01.258]             `+` <- base::`+`
[10:34:01.258]             `<<-` <- base::`<<-`
[10:34:01.258]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:01.258]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:01.258]                   3L)]
[10:34:01.258]             }
[10:34:01.258]             function(cond) {
[10:34:01.258]                 is_error <- inherits(cond, "error")
[10:34:01.258]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:01.258]                   NULL)
[10:34:01.258]                 if (is_error) {
[10:34:01.258]                   sessionInformation <- function() {
[10:34:01.258]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:01.258]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:01.258]                       search = base::search(), system = base::Sys.info())
[10:34:01.258]                   }
[10:34:01.258]                   ...future.conditions[[length(...future.conditions) + 
[10:34:01.258]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:01.258]                     cond$call), session = sessionInformation(), 
[10:34:01.258]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:01.258]                   signalCondition(cond)
[10:34:01.258]                 }
[10:34:01.258]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:01.258]                 "immediateCondition"))) {
[10:34:01.258]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:01.258]                   ...future.conditions[[length(...future.conditions) + 
[10:34:01.258]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:01.258]                   if (TRUE && !signal) {
[10:34:01.258]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.258]                     {
[10:34:01.258]                       inherits <- base::inherits
[10:34:01.258]                       invokeRestart <- base::invokeRestart
[10:34:01.258]                       is.null <- base::is.null
[10:34:01.258]                       muffled <- FALSE
[10:34:01.258]                       if (inherits(cond, "message")) {
[10:34:01.258]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:01.258]                         if (muffled) 
[10:34:01.258]                           invokeRestart("muffleMessage")
[10:34:01.258]                       }
[10:34:01.258]                       else if (inherits(cond, "warning")) {
[10:34:01.258]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:01.258]                         if (muffled) 
[10:34:01.258]                           invokeRestart("muffleWarning")
[10:34:01.258]                       }
[10:34:01.258]                       else if (inherits(cond, "condition")) {
[10:34:01.258]                         if (!is.null(pattern)) {
[10:34:01.258]                           computeRestarts <- base::computeRestarts
[10:34:01.258]                           grepl <- base::grepl
[10:34:01.258]                           restarts <- computeRestarts(cond)
[10:34:01.258]                           for (restart in restarts) {
[10:34:01.258]                             name <- restart$name
[10:34:01.258]                             if (is.null(name)) 
[10:34:01.258]                               next
[10:34:01.258]                             if (!grepl(pattern, name)) 
[10:34:01.258]                               next
[10:34:01.258]                             invokeRestart(restart)
[10:34:01.258]                             muffled <- TRUE
[10:34:01.258]                             break
[10:34:01.258]                           }
[10:34:01.258]                         }
[10:34:01.258]                       }
[10:34:01.258]                       invisible(muffled)
[10:34:01.258]                     }
[10:34:01.258]                     muffleCondition(cond, pattern = "^muffle")
[10:34:01.258]                   }
[10:34:01.258]                 }
[10:34:01.258]                 else {
[10:34:01.258]                   if (TRUE) {
[10:34:01.258]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.258]                     {
[10:34:01.258]                       inherits <- base::inherits
[10:34:01.258]                       invokeRestart <- base::invokeRestart
[10:34:01.258]                       is.null <- base::is.null
[10:34:01.258]                       muffled <- FALSE
[10:34:01.258]                       if (inherits(cond, "message")) {
[10:34:01.258]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:01.258]                         if (muffled) 
[10:34:01.258]                           invokeRestart("muffleMessage")
[10:34:01.258]                       }
[10:34:01.258]                       else if (inherits(cond, "warning")) {
[10:34:01.258]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:01.258]                         if (muffled) 
[10:34:01.258]                           invokeRestart("muffleWarning")
[10:34:01.258]                       }
[10:34:01.258]                       else if (inherits(cond, "condition")) {
[10:34:01.258]                         if (!is.null(pattern)) {
[10:34:01.258]                           computeRestarts <- base::computeRestarts
[10:34:01.258]                           grepl <- base::grepl
[10:34:01.258]                           restarts <- computeRestarts(cond)
[10:34:01.258]                           for (restart in restarts) {
[10:34:01.258]                             name <- restart$name
[10:34:01.258]                             if (is.null(name)) 
[10:34:01.258]                               next
[10:34:01.258]                             if (!grepl(pattern, name)) 
[10:34:01.258]                               next
[10:34:01.258]                             invokeRestart(restart)
[10:34:01.258]                             muffled <- TRUE
[10:34:01.258]                             break
[10:34:01.258]                           }
[10:34:01.258]                         }
[10:34:01.258]                       }
[10:34:01.258]                       invisible(muffled)
[10:34:01.258]                     }
[10:34:01.258]                     muffleCondition(cond, pattern = "^muffle")
[10:34:01.258]                   }
[10:34:01.258]                 }
[10:34:01.258]             }
[10:34:01.258]         }))
[10:34:01.258]     }, error = function(ex) {
[10:34:01.258]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:01.258]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:01.258]                 ...future.rng), started = ...future.startTime, 
[10:34:01.258]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:01.258]             version = "1.8"), class = "FutureResult")
[10:34:01.258]     }, finally = {
[10:34:01.258]         if (!identical(...future.workdir, getwd())) 
[10:34:01.258]             setwd(...future.workdir)
[10:34:01.258]         {
[10:34:01.258]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:01.258]                 ...future.oldOptions$nwarnings <- NULL
[10:34:01.258]             }
[10:34:01.258]             base::options(...future.oldOptions)
[10:34:01.258]             if (.Platform$OS.type == "windows") {
[10:34:01.258]                 old_names <- names(...future.oldEnvVars)
[10:34:01.258]                 envs <- base::Sys.getenv()
[10:34:01.258]                 names <- names(envs)
[10:34:01.258]                 common <- intersect(names, old_names)
[10:34:01.258]                 added <- setdiff(names, old_names)
[10:34:01.258]                 removed <- setdiff(old_names, names)
[10:34:01.258]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:01.258]                   envs[common]]
[10:34:01.258]                 NAMES <- toupper(changed)
[10:34:01.258]                 args <- list()
[10:34:01.258]                 for (kk in seq_along(NAMES)) {
[10:34:01.258]                   name <- changed[[kk]]
[10:34:01.258]                   NAME <- NAMES[[kk]]
[10:34:01.258]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.258]                     next
[10:34:01.258]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:01.258]                 }
[10:34:01.258]                 NAMES <- toupper(added)
[10:34:01.258]                 for (kk in seq_along(NAMES)) {
[10:34:01.258]                   name <- added[[kk]]
[10:34:01.258]                   NAME <- NAMES[[kk]]
[10:34:01.258]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.258]                     next
[10:34:01.258]                   args[[name]] <- ""
[10:34:01.258]                 }
[10:34:01.258]                 NAMES <- toupper(removed)
[10:34:01.258]                 for (kk in seq_along(NAMES)) {
[10:34:01.258]                   name <- removed[[kk]]
[10:34:01.258]                   NAME <- NAMES[[kk]]
[10:34:01.258]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.258]                     next
[10:34:01.258]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:01.258]                 }
[10:34:01.258]                 if (length(args) > 0) 
[10:34:01.258]                   base::do.call(base::Sys.setenv, args = args)
[10:34:01.258]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:01.258]             }
[10:34:01.258]             else {
[10:34:01.258]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:01.258]             }
[10:34:01.258]             {
[10:34:01.258]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:01.258]                   0L) {
[10:34:01.258]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:01.258]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:01.258]                   base::options(opts)
[10:34:01.258]                 }
[10:34:01.258]                 {
[10:34:01.258]                   {
[10:34:01.258]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:01.258]                     NULL
[10:34:01.258]                   }
[10:34:01.258]                   options(future.plan = NULL)
[10:34:01.258]                   if (is.na(NA_character_)) 
[10:34:01.258]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:01.258]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:01.258]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:01.258]                     .init = FALSE)
[10:34:01.258]                 }
[10:34:01.258]             }
[10:34:01.258]         }
[10:34:01.258]     })
[10:34:01.258]     if (TRUE) {
[10:34:01.258]         base::sink(type = "output", split = FALSE)
[10:34:01.258]         if (TRUE) {
[10:34:01.258]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:01.258]         }
[10:34:01.258]         else {
[10:34:01.258]             ...future.result["stdout"] <- base::list(NULL)
[10:34:01.258]         }
[10:34:01.258]         base::close(...future.stdout)
[10:34:01.258]         ...future.stdout <- NULL
[10:34:01.258]     }
[10:34:01.258]     ...future.result$conditions <- ...future.conditions
[10:34:01.258]     ...future.result$finished <- base::Sys.time()
[10:34:01.258]     ...future.result
[10:34:01.258] }
[10:34:01.261] requestCore(): workers = 2
[10:34:01.262] Poll #1 (0): usedCores() = 2, workers = 2
[10:34:01.272] result() for MulticoreFuture ...
[10:34:01.273] result() for MulticoreFuture ...
[10:34:01.274] result() for MulticoreFuture ... done
[10:34:01.274] result() for MulticoreFuture ... done
[10:34:01.274] result() for MulticoreFuture ...
[10:34:01.274] result() for MulticoreFuture ... done
[10:34:01.277] MulticoreFuture started
[10:34:01.277] - Launch lazy future ... done
[10:34:01.277] run() for ‘MulticoreFuture’ ... done
[10:34:01.278] plan(): Setting new future strategy stack:
[10:34:01.278] List of future strategies:
[10:34:01.278] 1. sequential:
[10:34:01.278]    - args: function (..., envir = parent.frame())
[10:34:01.278]    - tweaked: FALSE
[10:34:01.278]    - call: NULL
[10:34:01.279] resolve() on list environment ...
[10:34:01.279]  recursive: 0
[10:34:01.279] plan(): nbrOfWorkers() = 1
[10:34:01.280]  length: 3
[10:34:01.280]  elements: ‘a’, ‘b’, ‘c’
[10:34:01.281] Future #1
[10:34:01.281]  length: 2 (resolved future 1)
[10:34:01.281] plan(): Setting new future strategy stack:
[10:34:01.281] List of future strategies:
[10:34:01.281] 1. multicore:
[10:34:01.281]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:34:01.281]    - tweaked: FALSE
[10:34:01.281]    - call: plan(strategy)
[10:34:01.291]  length: 1 (resolved future 3)
[10:34:01.291] plan(): nbrOfWorkers() = 2
[10:34:01.302] Future #2
[10:34:01.306]  length: 0 (resolved future 2)
[10:34:01.306] resolve() on list environment ... DONE
[10:34:01.308] getGlobalsAndPackages() ...
[10:34:01.308] Searching for globals...
[10:34:01.311] - globals found: [1] ‘{’
[10:34:01.311] Searching for globals ... DONE
[10:34:01.311] Resolving globals: FALSE
[10:34:01.312] 
[10:34:01.312] 
[10:34:01.312] getGlobalsAndPackages() ... DONE
[10:34:01.313] run() for ‘Future’ ...
[10:34:01.313] - state: ‘created’
[10:34:01.313] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:34:01.318] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:01.319] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:34:01.319]   - Field: ‘label’
[10:34:01.319]   - Field: ‘local’
[10:34:01.319]   - Field: ‘owner’
[10:34:01.320]   - Field: ‘envir’
[10:34:01.320]   - Field: ‘workers’
[10:34:01.320]   - Field: ‘packages’
[10:34:01.320]   - Field: ‘gc’
[10:34:01.320]   - Field: ‘job’
[10:34:01.321]   - Field: ‘conditions’
[10:34:01.321]   - Field: ‘expr’
[10:34:01.321]   - Field: ‘uuid’
[10:34:01.321]   - Field: ‘seed’
[10:34:01.321]   - Field: ‘version’
[10:34:01.321]   - Field: ‘result’
[10:34:01.322]   - Field: ‘asynchronous’
[10:34:01.322]   - Field: ‘calls’
[10:34:01.322]   - Field: ‘globals’
[10:34:01.322]   - Field: ‘stdout’
[10:34:01.322]   - Field: ‘earlySignal’
[10:34:01.322]   - Field: ‘lazy’
[10:34:01.322]   - Field: ‘state’
[10:34:01.323] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:34:01.323] - Launch lazy future ...
[10:34:01.323] Packages needed by the future expression (n = 0): <none>
[10:34:01.323] Packages needed by future strategies (n = 0): <none>
[10:34:01.324] {
[10:34:01.324]     {
[10:34:01.324]         {
[10:34:01.324]             ...future.startTime <- base::Sys.time()
[10:34:01.324]             {
[10:34:01.324]                 {
[10:34:01.324]                   {
[10:34:01.324]                     {
[10:34:01.324]                       base::local({
[10:34:01.324]                         has_future <- base::requireNamespace("future", 
[10:34:01.324]                           quietly = TRUE)
[10:34:01.324]                         if (has_future) {
[10:34:01.324]                           ns <- base::getNamespace("future")
[10:34:01.324]                           version <- ns[[".package"]][["version"]]
[10:34:01.324]                           if (is.null(version)) 
[10:34:01.324]                             version <- utils::packageVersion("future")
[10:34:01.324]                         }
[10:34:01.324]                         else {
[10:34:01.324]                           version <- NULL
[10:34:01.324]                         }
[10:34:01.324]                         if (!has_future || version < "1.8.0") {
[10:34:01.324]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:01.324]                             "", base::R.version$version.string), 
[10:34:01.324]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:01.324]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:01.324]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:01.324]                               "release", "version")], collapse = " "), 
[10:34:01.324]                             hostname = base::Sys.info()[["nodename"]])
[10:34:01.324]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:01.324]                             info)
[10:34:01.324]                           info <- base::paste(info, collapse = "; ")
[10:34:01.324]                           if (!has_future) {
[10:34:01.324]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:01.324]                               info)
[10:34:01.324]                           }
[10:34:01.324]                           else {
[10:34:01.324]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:01.324]                               info, version)
[10:34:01.324]                           }
[10:34:01.324]                           base::stop(msg)
[10:34:01.324]                         }
[10:34:01.324]                       })
[10:34:01.324]                     }
[10:34:01.324]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:01.324]                     base::options(mc.cores = 1L)
[10:34:01.324]                   }
[10:34:01.324]                   ...future.strategy.old <- future::plan("list")
[10:34:01.324]                   options(future.plan = NULL)
[10:34:01.324]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:01.324]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:01.324]                 }
[10:34:01.324]                 ...future.workdir <- getwd()
[10:34:01.324]             }
[10:34:01.324]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:01.324]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:01.324]         }
[10:34:01.324]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:01.324]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:01.324]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:01.324]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:01.324]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:01.324]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:01.324]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:01.324]             base::names(...future.oldOptions))
[10:34:01.324]     }
[10:34:01.324]     if (FALSE) {
[10:34:01.324]     }
[10:34:01.324]     else {
[10:34:01.324]         if (TRUE) {
[10:34:01.324]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:01.324]                 open = "w")
[10:34:01.324]         }
[10:34:01.324]         else {
[10:34:01.324]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:01.324]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:01.324]         }
[10:34:01.324]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:01.324]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:01.324]             base::sink(type = "output", split = FALSE)
[10:34:01.324]             base::close(...future.stdout)
[10:34:01.324]         }, add = TRUE)
[10:34:01.324]     }
[10:34:01.324]     ...future.frame <- base::sys.nframe()
[10:34:01.324]     ...future.conditions <- base::list()
[10:34:01.324]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:01.324]     if (FALSE) {
[10:34:01.324]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:01.324]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:01.324]     }
[10:34:01.324]     ...future.result <- base::tryCatch({
[10:34:01.324]         base::withCallingHandlers({
[10:34:01.324]             ...future.value <- base::withVisible(base::local({
[10:34:01.324]                 withCallingHandlers({
[10:34:01.324]                   {
[10:34:01.324]                     1
[10:34:01.324]                   }
[10:34:01.324]                 }, immediateCondition = function(cond) {
[10:34:01.324]                   save_rds <- function (object, pathname, ...) 
[10:34:01.324]                   {
[10:34:01.324]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:34:01.324]                     if (file_test("-f", pathname_tmp)) {
[10:34:01.324]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.324]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:34:01.324]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.324]                         fi_tmp[["mtime"]])
[10:34:01.324]                     }
[10:34:01.324]                     tryCatch({
[10:34:01.324]                       saveRDS(object, file = pathname_tmp, ...)
[10:34:01.324]                     }, error = function(ex) {
[10:34:01.324]                       msg <- conditionMessage(ex)
[10:34:01.324]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.324]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:34:01.324]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.324]                         fi_tmp[["mtime"]], msg)
[10:34:01.324]                       ex$message <- msg
[10:34:01.324]                       stop(ex)
[10:34:01.324]                     })
[10:34:01.324]                     stopifnot(file_test("-f", pathname_tmp))
[10:34:01.324]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:34:01.324]                     if (!res || file_test("-f", pathname_tmp)) {
[10:34:01.324]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.324]                       fi <- file.info(pathname)
[10:34:01.324]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:34:01.324]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.324]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:34:01.324]                         fi[["size"]], fi[["mtime"]])
[10:34:01.324]                       stop(msg)
[10:34:01.324]                     }
[10:34:01.324]                     invisible(pathname)
[10:34:01.324]                   }
[10:34:01.324]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:34:01.324]                     rootPath = tempdir()) 
[10:34:01.324]                   {
[10:34:01.324]                     obj <- list(time = Sys.time(), condition = cond)
[10:34:01.324]                     file <- tempfile(pattern = class(cond)[1], 
[10:34:01.324]                       tmpdir = path, fileext = ".rds")
[10:34:01.324]                     save_rds(obj, file)
[10:34:01.324]                   }
[10:34:01.324]                   saveImmediateCondition(cond, path = "/tmp/RtmpuZEzLw/.future/immediateConditions")
[10:34:01.324]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.324]                   {
[10:34:01.324]                     inherits <- base::inherits
[10:34:01.324]                     invokeRestart <- base::invokeRestart
[10:34:01.324]                     is.null <- base::is.null
[10:34:01.324]                     muffled <- FALSE
[10:34:01.324]                     if (inherits(cond, "message")) {
[10:34:01.324]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:01.324]                       if (muffled) 
[10:34:01.324]                         invokeRestart("muffleMessage")
[10:34:01.324]                     }
[10:34:01.324]                     else if (inherits(cond, "warning")) {
[10:34:01.324]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:01.324]                       if (muffled) 
[10:34:01.324]                         invokeRestart("muffleWarning")
[10:34:01.324]                     }
[10:34:01.324]                     else if (inherits(cond, "condition")) {
[10:34:01.324]                       if (!is.null(pattern)) {
[10:34:01.324]                         computeRestarts <- base::computeRestarts
[10:34:01.324]                         grepl <- base::grepl
[10:34:01.324]                         restarts <- computeRestarts(cond)
[10:34:01.324]                         for (restart in restarts) {
[10:34:01.324]                           name <- restart$name
[10:34:01.324]                           if (is.null(name)) 
[10:34:01.324]                             next
[10:34:01.324]                           if (!grepl(pattern, name)) 
[10:34:01.324]                             next
[10:34:01.324]                           invokeRestart(restart)
[10:34:01.324]                           muffled <- TRUE
[10:34:01.324]                           break
[10:34:01.324]                         }
[10:34:01.324]                       }
[10:34:01.324]                     }
[10:34:01.324]                     invisible(muffled)
[10:34:01.324]                   }
[10:34:01.324]                   muffleCondition(cond)
[10:34:01.324]                 })
[10:34:01.324]             }))
[10:34:01.324]             future::FutureResult(value = ...future.value$value, 
[10:34:01.324]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:01.324]                   ...future.rng), globalenv = if (FALSE) 
[10:34:01.324]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:01.324]                     ...future.globalenv.names))
[10:34:01.324]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:01.324]         }, condition = base::local({
[10:34:01.324]             c <- base::c
[10:34:01.324]             inherits <- base::inherits
[10:34:01.324]             invokeRestart <- base::invokeRestart
[10:34:01.324]             length <- base::length
[10:34:01.324]             list <- base::list
[10:34:01.324]             seq.int <- base::seq.int
[10:34:01.324]             signalCondition <- base::signalCondition
[10:34:01.324]             sys.calls <- base::sys.calls
[10:34:01.324]             `[[` <- base::`[[`
[10:34:01.324]             `+` <- base::`+`
[10:34:01.324]             `<<-` <- base::`<<-`
[10:34:01.324]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:01.324]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:01.324]                   3L)]
[10:34:01.324]             }
[10:34:01.324]             function(cond) {
[10:34:01.324]                 is_error <- inherits(cond, "error")
[10:34:01.324]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:01.324]                   NULL)
[10:34:01.324]                 if (is_error) {
[10:34:01.324]                   sessionInformation <- function() {
[10:34:01.324]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:01.324]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:01.324]                       search = base::search(), system = base::Sys.info())
[10:34:01.324]                   }
[10:34:01.324]                   ...future.conditions[[length(...future.conditions) + 
[10:34:01.324]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:01.324]                     cond$call), session = sessionInformation(), 
[10:34:01.324]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:01.324]                   signalCondition(cond)
[10:34:01.324]                 }
[10:34:01.324]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:01.324]                 "immediateCondition"))) {
[10:34:01.324]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:01.324]                   ...future.conditions[[length(...future.conditions) + 
[10:34:01.324]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:01.324]                   if (TRUE && !signal) {
[10:34:01.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.324]                     {
[10:34:01.324]                       inherits <- base::inherits
[10:34:01.324]                       invokeRestart <- base::invokeRestart
[10:34:01.324]                       is.null <- base::is.null
[10:34:01.324]                       muffled <- FALSE
[10:34:01.324]                       if (inherits(cond, "message")) {
[10:34:01.324]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:01.324]                         if (muffled) 
[10:34:01.324]                           invokeRestart("muffleMessage")
[10:34:01.324]                       }
[10:34:01.324]                       else if (inherits(cond, "warning")) {
[10:34:01.324]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:01.324]                         if (muffled) 
[10:34:01.324]                           invokeRestart("muffleWarning")
[10:34:01.324]                       }
[10:34:01.324]                       else if (inherits(cond, "condition")) {
[10:34:01.324]                         if (!is.null(pattern)) {
[10:34:01.324]                           computeRestarts <- base::computeRestarts
[10:34:01.324]                           grepl <- base::grepl
[10:34:01.324]                           restarts <- computeRestarts(cond)
[10:34:01.324]                           for (restart in restarts) {
[10:34:01.324]                             name <- restart$name
[10:34:01.324]                             if (is.null(name)) 
[10:34:01.324]                               next
[10:34:01.324]                             if (!grepl(pattern, name)) 
[10:34:01.324]                               next
[10:34:01.324]                             invokeRestart(restart)
[10:34:01.324]                             muffled <- TRUE
[10:34:01.324]                             break
[10:34:01.324]                           }
[10:34:01.324]                         }
[10:34:01.324]                       }
[10:34:01.324]                       invisible(muffled)
[10:34:01.324]                     }
[10:34:01.324]                     muffleCondition(cond, pattern = "^muffle")
[10:34:01.324]                   }
[10:34:01.324]                 }
[10:34:01.324]                 else {
[10:34:01.324]                   if (TRUE) {
[10:34:01.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.324]                     {
[10:34:01.324]                       inherits <- base::inherits
[10:34:01.324]                       invokeRestart <- base::invokeRestart
[10:34:01.324]                       is.null <- base::is.null
[10:34:01.324]                       muffled <- FALSE
[10:34:01.324]                       if (inherits(cond, "message")) {
[10:34:01.324]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:01.324]                         if (muffled) 
[10:34:01.324]                           invokeRestart("muffleMessage")
[10:34:01.324]                       }
[10:34:01.324]                       else if (inherits(cond, "warning")) {
[10:34:01.324]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:01.324]                         if (muffled) 
[10:34:01.324]                           invokeRestart("muffleWarning")
[10:34:01.324]                       }
[10:34:01.324]                       else if (inherits(cond, "condition")) {
[10:34:01.324]                         if (!is.null(pattern)) {
[10:34:01.324]                           computeRestarts <- base::computeRestarts
[10:34:01.324]                           grepl <- base::grepl
[10:34:01.324]                           restarts <- computeRestarts(cond)
[10:34:01.324]                           for (restart in restarts) {
[10:34:01.324]                             name <- restart$name
[10:34:01.324]                             if (is.null(name)) 
[10:34:01.324]                               next
[10:34:01.324]                             if (!grepl(pattern, name)) 
[10:34:01.324]                               next
[10:34:01.324]                             invokeRestart(restart)
[10:34:01.324]                             muffled <- TRUE
[10:34:01.324]                             break
[10:34:01.324]                           }
[10:34:01.324]                         }
[10:34:01.324]                       }
[10:34:01.324]                       invisible(muffled)
[10:34:01.324]                     }
[10:34:01.324]                     muffleCondition(cond, pattern = "^muffle")
[10:34:01.324]                   }
[10:34:01.324]                 }
[10:34:01.324]             }
[10:34:01.324]         }))
[10:34:01.324]     }, error = function(ex) {
[10:34:01.324]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:01.324]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:01.324]                 ...future.rng), started = ...future.startTime, 
[10:34:01.324]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:01.324]             version = "1.8"), class = "FutureResult")
[10:34:01.324]     }, finally = {
[10:34:01.324]         if (!identical(...future.workdir, getwd())) 
[10:34:01.324]             setwd(...future.workdir)
[10:34:01.324]         {
[10:34:01.324]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:01.324]                 ...future.oldOptions$nwarnings <- NULL
[10:34:01.324]             }
[10:34:01.324]             base::options(...future.oldOptions)
[10:34:01.324]             if (.Platform$OS.type == "windows") {
[10:34:01.324]                 old_names <- names(...future.oldEnvVars)
[10:34:01.324]                 envs <- base::Sys.getenv()
[10:34:01.324]                 names <- names(envs)
[10:34:01.324]                 common <- intersect(names, old_names)
[10:34:01.324]                 added <- setdiff(names, old_names)
[10:34:01.324]                 removed <- setdiff(old_names, names)
[10:34:01.324]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:01.324]                   envs[common]]
[10:34:01.324]                 NAMES <- toupper(changed)
[10:34:01.324]                 args <- list()
[10:34:01.324]                 for (kk in seq_along(NAMES)) {
[10:34:01.324]                   name <- changed[[kk]]
[10:34:01.324]                   NAME <- NAMES[[kk]]
[10:34:01.324]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.324]                     next
[10:34:01.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:01.324]                 }
[10:34:01.324]                 NAMES <- toupper(added)
[10:34:01.324]                 for (kk in seq_along(NAMES)) {
[10:34:01.324]                   name <- added[[kk]]
[10:34:01.324]                   NAME <- NAMES[[kk]]
[10:34:01.324]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.324]                     next
[10:34:01.324]                   args[[name]] <- ""
[10:34:01.324]                 }
[10:34:01.324]                 NAMES <- toupper(removed)
[10:34:01.324]                 for (kk in seq_along(NAMES)) {
[10:34:01.324]                   name <- removed[[kk]]
[10:34:01.324]                   NAME <- NAMES[[kk]]
[10:34:01.324]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.324]                     next
[10:34:01.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:01.324]                 }
[10:34:01.324]                 if (length(args) > 0) 
[10:34:01.324]                   base::do.call(base::Sys.setenv, args = args)
[10:34:01.324]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:01.324]             }
[10:34:01.324]             else {
[10:34:01.324]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:01.324]             }
[10:34:01.324]             {
[10:34:01.324]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:01.324]                   0L) {
[10:34:01.324]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:01.324]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:01.324]                   base::options(opts)
[10:34:01.324]                 }
[10:34:01.324]                 {
[10:34:01.324]                   {
[10:34:01.324]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:01.324]                     NULL
[10:34:01.324]                   }
[10:34:01.324]                   options(future.plan = NULL)
[10:34:01.324]                   if (is.na(NA_character_)) 
[10:34:01.324]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:01.324]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:01.324]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:01.324]                     .init = FALSE)
[10:34:01.324]                 }
[10:34:01.324]             }
[10:34:01.324]         }
[10:34:01.324]     })
[10:34:01.324]     if (TRUE) {
[10:34:01.324]         base::sink(type = "output", split = FALSE)
[10:34:01.324]         if (TRUE) {
[10:34:01.324]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:01.324]         }
[10:34:01.324]         else {
[10:34:01.324]             ...future.result["stdout"] <- base::list(NULL)
[10:34:01.324]         }
[10:34:01.324]         base::close(...future.stdout)
[10:34:01.324]         ...future.stdout <- NULL
[10:34:01.324]     }
[10:34:01.324]     ...future.result$conditions <- ...future.conditions
[10:34:01.324]     ...future.result$finished <- base::Sys.time()
[10:34:01.324]     ...future.result
[10:34:01.324] }
[10:34:01.327] requestCore(): workers = 2
[10:34:01.327] Poll #1 (0): usedCores() = 2, workers = 2
[10:34:01.337] result() for MulticoreFuture ...
[10:34:01.338] result() for MulticoreFuture ...
[10:34:01.338] result() for MulticoreFuture ... done
[10:34:01.339] result() for MulticoreFuture ... done
[10:34:01.339] result() for MulticoreFuture ...
[10:34:01.339] result() for MulticoreFuture ... done
[10:34:01.341] MulticoreFuture started
[10:34:01.341] - Launch lazy future ... done
[10:34:01.342] run() for ‘MulticoreFuture’ ... done
[10:34:01.342] plan(): Setting new future strategy stack:
[10:34:01.343] getGlobalsAndPackages() ...
[10:34:01.343] Searching for globals...
[10:34:01.343] List of future strategies:
[10:34:01.343] 1. sequential:
[10:34:01.343]    - args: function (..., envir = parent.frame())
[10:34:01.343]    - tweaked: FALSE
[10:34:01.343]    - call: NULL
[10:34:01.344] plan(): nbrOfWorkers() = 1
[10:34:01.346] - globals found: [2] ‘{’, ‘Sys.sleep’
[10:34:01.347] Searching for globals ... DONE
[10:34:01.347] plan(): Setting new future strategy stack:
[10:34:01.347] Resolving globals: FALSE
[10:34:01.347] List of future strategies:
[10:34:01.347] 1. multicore:
[10:34:01.347]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:34:01.347]    - tweaked: FALSE
[10:34:01.347]    - call: plan(strategy)
[10:34:01.348] 
[10:34:01.348] 
[10:34:01.348] getGlobalsAndPackages() ... DONE
[10:34:01.349] run() for ‘Future’ ...
[10:34:01.349] - state: ‘created’
[10:34:01.350] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:34:01.353] plan(): nbrOfWorkers() = 2
[10:34:01.354] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:01.354] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:34:01.355]   - Field: ‘label’
[10:34:01.355]   - Field: ‘local’
[10:34:01.355]   - Field: ‘owner’
[10:34:01.355]   - Field: ‘envir’
[10:34:01.355]   - Field: ‘workers’
[10:34:01.355]   - Field: ‘packages’
[10:34:01.356]   - Field: ‘gc’
[10:34:01.356]   - Field: ‘job’
[10:34:01.356]   - Field: ‘conditions’
[10:34:01.356]   - Field: ‘expr’
[10:34:01.356]   - Field: ‘uuid’
[10:34:01.356]   - Field: ‘seed’
[10:34:01.356]   - Field: ‘version’
[10:34:01.356]   - Field: ‘result’
[10:34:01.357]   - Field: ‘asynchronous’
[10:34:01.357]   - Field: ‘calls’
[10:34:01.357]   - Field: ‘globals’
[10:34:01.357]   - Field: ‘stdout’
[10:34:01.357]   - Field: ‘earlySignal’
[10:34:01.357]   - Field: ‘lazy’
[10:34:01.358]   - Field: ‘state’
[10:34:01.358] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:34:01.358] - Launch lazy future ...
[10:34:01.358] Packages needed by the future expression (n = 0): <none>
[10:34:01.358] Packages needed by future strategies (n = 0): <none>
[10:34:01.359] {
[10:34:01.359]     {
[10:34:01.359]         {
[10:34:01.359]             ...future.startTime <- base::Sys.time()
[10:34:01.359]             {
[10:34:01.359]                 {
[10:34:01.359]                   {
[10:34:01.359]                     {
[10:34:01.359]                       base::local({
[10:34:01.359]                         has_future <- base::requireNamespace("future", 
[10:34:01.359]                           quietly = TRUE)
[10:34:01.359]                         if (has_future) {
[10:34:01.359]                           ns <- base::getNamespace("future")
[10:34:01.359]                           version <- ns[[".package"]][["version"]]
[10:34:01.359]                           if (is.null(version)) 
[10:34:01.359]                             version <- utils::packageVersion("future")
[10:34:01.359]                         }
[10:34:01.359]                         else {
[10:34:01.359]                           version <- NULL
[10:34:01.359]                         }
[10:34:01.359]                         if (!has_future || version < "1.8.0") {
[10:34:01.359]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:01.359]                             "", base::R.version$version.string), 
[10:34:01.359]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:01.359]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:01.359]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:01.359]                               "release", "version")], collapse = " "), 
[10:34:01.359]                             hostname = base::Sys.info()[["nodename"]])
[10:34:01.359]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:01.359]                             info)
[10:34:01.359]                           info <- base::paste(info, collapse = "; ")
[10:34:01.359]                           if (!has_future) {
[10:34:01.359]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:01.359]                               info)
[10:34:01.359]                           }
[10:34:01.359]                           else {
[10:34:01.359]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:01.359]                               info, version)
[10:34:01.359]                           }
[10:34:01.359]                           base::stop(msg)
[10:34:01.359]                         }
[10:34:01.359]                       })
[10:34:01.359]                     }
[10:34:01.359]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:01.359]                     base::options(mc.cores = 1L)
[10:34:01.359]                   }
[10:34:01.359]                   ...future.strategy.old <- future::plan("list")
[10:34:01.359]                   options(future.plan = NULL)
[10:34:01.359]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:01.359]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:01.359]                 }
[10:34:01.359]                 ...future.workdir <- getwd()
[10:34:01.359]             }
[10:34:01.359]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:01.359]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:01.359]         }
[10:34:01.359]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:01.359]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:01.359]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:01.359]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:01.359]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:01.359]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:01.359]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:01.359]             base::names(...future.oldOptions))
[10:34:01.359]     }
[10:34:01.359]     if (FALSE) {
[10:34:01.359]     }
[10:34:01.359]     else {
[10:34:01.359]         if (TRUE) {
[10:34:01.359]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:01.359]                 open = "w")
[10:34:01.359]         }
[10:34:01.359]         else {
[10:34:01.359]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:01.359]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:01.359]         }
[10:34:01.359]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:01.359]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:01.359]             base::sink(type = "output", split = FALSE)
[10:34:01.359]             base::close(...future.stdout)
[10:34:01.359]         }, add = TRUE)
[10:34:01.359]     }
[10:34:01.359]     ...future.frame <- base::sys.nframe()
[10:34:01.359]     ...future.conditions <- base::list()
[10:34:01.359]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:01.359]     if (FALSE) {
[10:34:01.359]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:01.359]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:01.359]     }
[10:34:01.359]     ...future.result <- base::tryCatch({
[10:34:01.359]         base::withCallingHandlers({
[10:34:01.359]             ...future.value <- base::withVisible(base::local({
[10:34:01.359]                 withCallingHandlers({
[10:34:01.359]                   {
[10:34:01.359]                     Sys.sleep(0.5)
[10:34:01.359]                     2
[10:34:01.359]                   }
[10:34:01.359]                 }, immediateCondition = function(cond) {
[10:34:01.359]                   save_rds <- function (object, pathname, ...) 
[10:34:01.359]                   {
[10:34:01.359]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:34:01.359]                     if (file_test("-f", pathname_tmp)) {
[10:34:01.359]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.359]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:34:01.359]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.359]                         fi_tmp[["mtime"]])
[10:34:01.359]                     }
[10:34:01.359]                     tryCatch({
[10:34:01.359]                       saveRDS(object, file = pathname_tmp, ...)
[10:34:01.359]                     }, error = function(ex) {
[10:34:01.359]                       msg <- conditionMessage(ex)
[10:34:01.359]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.359]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:34:01.359]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.359]                         fi_tmp[["mtime"]], msg)
[10:34:01.359]                       ex$message <- msg
[10:34:01.359]                       stop(ex)
[10:34:01.359]                     })
[10:34:01.359]                     stopifnot(file_test("-f", pathname_tmp))
[10:34:01.359]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:34:01.359]                     if (!res || file_test("-f", pathname_tmp)) {
[10:34:01.359]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.359]                       fi <- file.info(pathname)
[10:34:01.359]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:34:01.359]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.359]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:34:01.359]                         fi[["size"]], fi[["mtime"]])
[10:34:01.359]                       stop(msg)
[10:34:01.359]                     }
[10:34:01.359]                     invisible(pathname)
[10:34:01.359]                   }
[10:34:01.359]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:34:01.359]                     rootPath = tempdir()) 
[10:34:01.359]                   {
[10:34:01.359]                     obj <- list(time = Sys.time(), condition = cond)
[10:34:01.359]                     file <- tempfile(pattern = class(cond)[1], 
[10:34:01.359]                       tmpdir = path, fileext = ".rds")
[10:34:01.359]                     save_rds(obj, file)
[10:34:01.359]                   }
[10:34:01.359]                   saveImmediateCondition(cond, path = "/tmp/RtmpuZEzLw/.future/immediateConditions")
[10:34:01.359]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.359]                   {
[10:34:01.359]                     inherits <- base::inherits
[10:34:01.359]                     invokeRestart <- base::invokeRestart
[10:34:01.359]                     is.null <- base::is.null
[10:34:01.359]                     muffled <- FALSE
[10:34:01.359]                     if (inherits(cond, "message")) {
[10:34:01.359]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:01.359]                       if (muffled) 
[10:34:01.359]                         invokeRestart("muffleMessage")
[10:34:01.359]                     }
[10:34:01.359]                     else if (inherits(cond, "warning")) {
[10:34:01.359]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:01.359]                       if (muffled) 
[10:34:01.359]                         invokeRestart("muffleWarning")
[10:34:01.359]                     }
[10:34:01.359]                     else if (inherits(cond, "condition")) {
[10:34:01.359]                       if (!is.null(pattern)) {
[10:34:01.359]                         computeRestarts <- base::computeRestarts
[10:34:01.359]                         grepl <- base::grepl
[10:34:01.359]                         restarts <- computeRestarts(cond)
[10:34:01.359]                         for (restart in restarts) {
[10:34:01.359]                           name <- restart$name
[10:34:01.359]                           if (is.null(name)) 
[10:34:01.359]                             next
[10:34:01.359]                           if (!grepl(pattern, name)) 
[10:34:01.359]                             next
[10:34:01.359]                           invokeRestart(restart)
[10:34:01.359]                           muffled <- TRUE
[10:34:01.359]                           break
[10:34:01.359]                         }
[10:34:01.359]                       }
[10:34:01.359]                     }
[10:34:01.359]                     invisible(muffled)
[10:34:01.359]                   }
[10:34:01.359]                   muffleCondition(cond)
[10:34:01.359]                 })
[10:34:01.359]             }))
[10:34:01.359]             future::FutureResult(value = ...future.value$value, 
[10:34:01.359]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:01.359]                   ...future.rng), globalenv = if (FALSE) 
[10:34:01.359]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:01.359]                     ...future.globalenv.names))
[10:34:01.359]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:01.359]         }, condition = base::local({
[10:34:01.359]             c <- base::c
[10:34:01.359]             inherits <- base::inherits
[10:34:01.359]             invokeRestart <- base::invokeRestart
[10:34:01.359]             length <- base::length
[10:34:01.359]             list <- base::list
[10:34:01.359]             seq.int <- base::seq.int
[10:34:01.359]             signalCondition <- base::signalCondition
[10:34:01.359]             sys.calls <- base::sys.calls
[10:34:01.359]             `[[` <- base::`[[`
[10:34:01.359]             `+` <- base::`+`
[10:34:01.359]             `<<-` <- base::`<<-`
[10:34:01.359]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:01.359]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:01.359]                   3L)]
[10:34:01.359]             }
[10:34:01.359]             function(cond) {
[10:34:01.359]                 is_error <- inherits(cond, "error")
[10:34:01.359]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:01.359]                   NULL)
[10:34:01.359]                 if (is_error) {
[10:34:01.359]                   sessionInformation <- function() {
[10:34:01.359]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:01.359]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:01.359]                       search = base::search(), system = base::Sys.info())
[10:34:01.359]                   }
[10:34:01.359]                   ...future.conditions[[length(...future.conditions) + 
[10:34:01.359]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:01.359]                     cond$call), session = sessionInformation(), 
[10:34:01.359]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:01.359]                   signalCondition(cond)
[10:34:01.359]                 }
[10:34:01.359]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:01.359]                 "immediateCondition"))) {
[10:34:01.359]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:01.359]                   ...future.conditions[[length(...future.conditions) + 
[10:34:01.359]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:01.359]                   if (TRUE && !signal) {
[10:34:01.359]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.359]                     {
[10:34:01.359]                       inherits <- base::inherits
[10:34:01.359]                       invokeRestart <- base::invokeRestart
[10:34:01.359]                       is.null <- base::is.null
[10:34:01.359]                       muffled <- FALSE
[10:34:01.359]                       if (inherits(cond, "message")) {
[10:34:01.359]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:01.359]                         if (muffled) 
[10:34:01.359]                           invokeRestart("muffleMessage")
[10:34:01.359]                       }
[10:34:01.359]                       else if (inherits(cond, "warning")) {
[10:34:01.359]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:01.359]                         if (muffled) 
[10:34:01.359]                           invokeRestart("muffleWarning")
[10:34:01.359]                       }
[10:34:01.359]                       else if (inherits(cond, "condition")) {
[10:34:01.359]                         if (!is.null(pattern)) {
[10:34:01.359]                           computeRestarts <- base::computeRestarts
[10:34:01.359]                           grepl <- base::grepl
[10:34:01.359]                           restarts <- computeRestarts(cond)
[10:34:01.359]                           for (restart in restarts) {
[10:34:01.359]                             name <- restart$name
[10:34:01.359]                             if (is.null(name)) 
[10:34:01.359]                               next
[10:34:01.359]                             if (!grepl(pattern, name)) 
[10:34:01.359]                               next
[10:34:01.359]                             invokeRestart(restart)
[10:34:01.359]                             muffled <- TRUE
[10:34:01.359]                             break
[10:34:01.359]                           }
[10:34:01.359]                         }
[10:34:01.359]                       }
[10:34:01.359]                       invisible(muffled)
[10:34:01.359]                     }
[10:34:01.359]                     muffleCondition(cond, pattern = "^muffle")
[10:34:01.359]                   }
[10:34:01.359]                 }
[10:34:01.359]                 else {
[10:34:01.359]                   if (TRUE) {
[10:34:01.359]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.359]                     {
[10:34:01.359]                       inherits <- base::inherits
[10:34:01.359]                       invokeRestart <- base::invokeRestart
[10:34:01.359]                       is.null <- base::is.null
[10:34:01.359]                       muffled <- FALSE
[10:34:01.359]                       if (inherits(cond, "message")) {
[10:34:01.359]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:01.359]                         if (muffled) 
[10:34:01.359]                           invokeRestart("muffleMessage")
[10:34:01.359]                       }
[10:34:01.359]                       else if (inherits(cond, "warning")) {
[10:34:01.359]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:01.359]                         if (muffled) 
[10:34:01.359]                           invokeRestart("muffleWarning")
[10:34:01.359]                       }
[10:34:01.359]                       else if (inherits(cond, "condition")) {
[10:34:01.359]                         if (!is.null(pattern)) {
[10:34:01.359]                           computeRestarts <- base::computeRestarts
[10:34:01.359]                           grepl <- base::grepl
[10:34:01.359]                           restarts <- computeRestarts(cond)
[10:34:01.359]                           for (restart in restarts) {
[10:34:01.359]                             name <- restart$name
[10:34:01.359]                             if (is.null(name)) 
[10:34:01.359]                               next
[10:34:01.359]                             if (!grepl(pattern, name)) 
[10:34:01.359]                               next
[10:34:01.359]                             invokeRestart(restart)
[10:34:01.359]                             muffled <- TRUE
[10:34:01.359]                             break
[10:34:01.359]                           }
[10:34:01.359]                         }
[10:34:01.359]                       }
[10:34:01.359]                       invisible(muffled)
[10:34:01.359]                     }
[10:34:01.359]                     muffleCondition(cond, pattern = "^muffle")
[10:34:01.359]                   }
[10:34:01.359]                 }
[10:34:01.359]             }
[10:34:01.359]         }))
[10:34:01.359]     }, error = function(ex) {
[10:34:01.359]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:01.359]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:01.359]                 ...future.rng), started = ...future.startTime, 
[10:34:01.359]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:01.359]             version = "1.8"), class = "FutureResult")
[10:34:01.359]     }, finally = {
[10:34:01.359]         if (!identical(...future.workdir, getwd())) 
[10:34:01.359]             setwd(...future.workdir)
[10:34:01.359]         {
[10:34:01.359]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:01.359]                 ...future.oldOptions$nwarnings <- NULL
[10:34:01.359]             }
[10:34:01.359]             base::options(...future.oldOptions)
[10:34:01.359]             if (.Platform$OS.type == "windows") {
[10:34:01.359]                 old_names <- names(...future.oldEnvVars)
[10:34:01.359]                 envs <- base::Sys.getenv()
[10:34:01.359]                 names <- names(envs)
[10:34:01.359]                 common <- intersect(names, old_names)
[10:34:01.359]                 added <- setdiff(names, old_names)
[10:34:01.359]                 removed <- setdiff(old_names, names)
[10:34:01.359]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:01.359]                   envs[common]]
[10:34:01.359]                 NAMES <- toupper(changed)
[10:34:01.359]                 args <- list()
[10:34:01.359]                 for (kk in seq_along(NAMES)) {
[10:34:01.359]                   name <- changed[[kk]]
[10:34:01.359]                   NAME <- NAMES[[kk]]
[10:34:01.359]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.359]                     next
[10:34:01.359]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:01.359]                 }
[10:34:01.359]                 NAMES <- toupper(added)
[10:34:01.359]                 for (kk in seq_along(NAMES)) {
[10:34:01.359]                   name <- added[[kk]]
[10:34:01.359]                   NAME <- NAMES[[kk]]
[10:34:01.359]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.359]                     next
[10:34:01.359]                   args[[name]] <- ""
[10:34:01.359]                 }
[10:34:01.359]                 NAMES <- toupper(removed)
[10:34:01.359]                 for (kk in seq_along(NAMES)) {
[10:34:01.359]                   name <- removed[[kk]]
[10:34:01.359]                   NAME <- NAMES[[kk]]
[10:34:01.359]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.359]                     next
[10:34:01.359]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:01.359]                 }
[10:34:01.359]                 if (length(args) > 0) 
[10:34:01.359]                   base::do.call(base::Sys.setenv, args = args)
[10:34:01.359]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:01.359]             }
[10:34:01.359]             else {
[10:34:01.359]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:01.359]             }
[10:34:01.359]             {
[10:34:01.359]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:01.359]                   0L) {
[10:34:01.359]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:01.359]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:01.359]                   base::options(opts)
[10:34:01.359]                 }
[10:34:01.359]                 {
[10:34:01.359]                   {
[10:34:01.359]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:01.359]                     NULL
[10:34:01.359]                   }
[10:34:01.359]                   options(future.plan = NULL)
[10:34:01.359]                   if (is.na(NA_character_)) 
[10:34:01.359]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:01.359]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:01.359]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:01.359]                     .init = FALSE)
[10:34:01.359]                 }
[10:34:01.359]             }
[10:34:01.359]         }
[10:34:01.359]     })
[10:34:01.359]     if (TRUE) {
[10:34:01.359]         base::sink(type = "output", split = FALSE)
[10:34:01.359]         if (TRUE) {
[10:34:01.359]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:01.359]         }
[10:34:01.359]         else {
[10:34:01.359]             ...future.result["stdout"] <- base::list(NULL)
[10:34:01.359]         }
[10:34:01.359]         base::close(...future.stdout)
[10:34:01.359]         ...future.stdout <- NULL
[10:34:01.359]     }
[10:34:01.359]     ...future.result$conditions <- ...future.conditions
[10:34:01.359]     ...future.result$finished <- base::Sys.time()
[10:34:01.359]     ...future.result
[10:34:01.359] }
[10:34:01.362] requestCore(): workers = 2
[10:34:01.363] Poll #1 (0): usedCores() = 2, workers = 2
[10:34:01.374] result() for MulticoreFuture ...
[10:34:01.374] result() for MulticoreFuture ...
[10:34:01.375] result() for MulticoreFuture ... done
[10:34:01.375] result() for MulticoreFuture ... done
[10:34:01.375] result() for MulticoreFuture ...
[10:34:01.375] result() for MulticoreFuture ... done
[10:34:01.377] MulticoreFuture started
[10:34:01.378] - Launch lazy future ... done
[10:34:01.378] run() for ‘MulticoreFuture’ ... done
[10:34:01.379] plan(): Setting new future strategy stack:
[10:34:01.379] getGlobalsAndPackages() ...
[10:34:01.380] Searching for globals...
[10:34:01.379] List of future strategies:
[10:34:01.379] 1. sequential:
[10:34:01.379]    - args: function (..., envir = parent.frame())
[10:34:01.379]    - tweaked: FALSE
[10:34:01.379]    - call: NULL
[10:34:01.380] plan(): nbrOfWorkers() = 1
[10:34:01.381] - globals found: [1] ‘{’
[10:34:01.382] Searching for globals ... DONE
[10:34:01.382] Resolving globals: FALSE
[10:34:01.382] 
[10:34:01.383] 
[10:34:01.383] getGlobalsAndPackages() ... DONE
[10:34:01.383] run() for ‘Future’ ...
[10:34:01.383] - state: ‘created’
[10:34:01.384] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:34:01.389] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:01.394] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:34:01.394]   - Field: ‘label’
[10:34:01.394]   - Field: ‘local’
[10:34:01.395]   - Field: ‘owner’
[10:34:01.395]   - Field: ‘envir’
[10:34:01.395]   - Field: ‘workers’
[10:34:01.396]   - Field: ‘packages’
[10:34:01.396]   - Field: ‘gc’
[10:34:01.396]   - Field: ‘job’
[10:34:01.397]   - Field: ‘conditions’
[10:34:01.397]   - Field: ‘expr’
[10:34:01.397]   - Field: ‘uuid’
[10:34:01.398]   - Field: ‘seed’
[10:34:01.398]   - Field: ‘version’
[10:34:01.398]   - Field: ‘result’
[10:34:01.398]   - Field: ‘asynchronous’
[10:34:01.399]   - Field: ‘calls’
[10:34:01.399]   - Field: ‘globals’
[10:34:01.399]   - Field: ‘stdout’
[10:34:01.399]   - Field: ‘earlySignal’
[10:34:01.399]   - Field: ‘lazy’
[10:34:01.399]   - Field: ‘state’
[10:34:01.400] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:34:01.400] - Launch lazy future ...
[10:34:01.400] Packages needed by the future expression (n = 0): <none>
[10:34:01.400] Packages needed by future strategies (n = 0): <none>
[10:34:01.401] {
[10:34:01.401]     {
[10:34:01.401]         {
[10:34:01.401]             ...future.startTime <- base::Sys.time()
[10:34:01.401]             {
[10:34:01.401]                 {
[10:34:01.401]                   {
[10:34:01.401]                     {
[10:34:01.401]                       base::local({
[10:34:01.401]                         has_future <- base::requireNamespace("future", 
[10:34:01.401]                           quietly = TRUE)
[10:34:01.401]                         if (has_future) {
[10:34:01.401]                           ns <- base::getNamespace("future")
[10:34:01.401]                           version <- ns[[".package"]][["version"]]
[10:34:01.401]                           if (is.null(version)) 
[10:34:01.401]                             version <- utils::packageVersion("future")
[10:34:01.401]                         }
[10:34:01.401]                         else {
[10:34:01.401]                           version <- NULL
[10:34:01.401]                         }
[10:34:01.401]                         if (!has_future || version < "1.8.0") {
[10:34:01.401]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:01.401]                             "", base::R.version$version.string), 
[10:34:01.401]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:01.401]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:01.401]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:01.401]                               "release", "version")], collapse = " "), 
[10:34:01.401]                             hostname = base::Sys.info()[["nodename"]])
[10:34:01.401]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:01.401]                             info)
[10:34:01.401]                           info <- base::paste(info, collapse = "; ")
[10:34:01.401]                           if (!has_future) {
[10:34:01.401]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:01.401]                               info)
[10:34:01.401]                           }
[10:34:01.401]                           else {
[10:34:01.401]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:01.401]                               info, version)
[10:34:01.401]                           }
[10:34:01.401]                           base::stop(msg)
[10:34:01.401]                         }
[10:34:01.401]                       })
[10:34:01.401]                     }
[10:34:01.401]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:01.401]                     base::options(mc.cores = 1L)
[10:34:01.401]                   }
[10:34:01.401]                   ...future.strategy.old <- future::plan("list")
[10:34:01.401]                   options(future.plan = NULL)
[10:34:01.401]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:01.401]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:01.401]                 }
[10:34:01.401]                 ...future.workdir <- getwd()
[10:34:01.401]             }
[10:34:01.401]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:01.401]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:01.401]         }
[10:34:01.401]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:01.401]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:01.401]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:01.401]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:01.401]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:01.401]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:01.401]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:01.401]             base::names(...future.oldOptions))
[10:34:01.401]     }
[10:34:01.401]     if (FALSE) {
[10:34:01.401]     }
[10:34:01.401]     else {
[10:34:01.401]         if (TRUE) {
[10:34:01.401]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:01.401]                 open = "w")
[10:34:01.401]         }
[10:34:01.401]         else {
[10:34:01.401]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:01.401]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:01.401]         }
[10:34:01.401]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:01.401]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:01.401]             base::sink(type = "output", split = FALSE)
[10:34:01.401]             base::close(...future.stdout)
[10:34:01.401]         }, add = TRUE)
[10:34:01.401]     }
[10:34:01.401]     ...future.frame <- base::sys.nframe()
[10:34:01.401]     ...future.conditions <- base::list()
[10:34:01.401]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:01.401]     if (FALSE) {
[10:34:01.401]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:01.401]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:01.401]     }
[10:34:01.401]     ...future.result <- base::tryCatch({
[10:34:01.401]         base::withCallingHandlers({
[10:34:01.401]             ...future.value <- base::withVisible(base::local({
[10:34:01.401]                 withCallingHandlers({
[10:34:01.401]                   {
[10:34:01.401]                     3
[10:34:01.401]                   }
[10:34:01.401]                 }, immediateCondition = function(cond) {
[10:34:01.401]                   save_rds <- function (object, pathname, ...) 
[10:34:01.401]                   {
[10:34:01.401]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:34:01.401]                     if (file_test("-f", pathname_tmp)) {
[10:34:01.401]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.401]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:34:01.401]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.401]                         fi_tmp[["mtime"]])
[10:34:01.401]                     }
[10:34:01.401]                     tryCatch({
[10:34:01.401]                       saveRDS(object, file = pathname_tmp, ...)
[10:34:01.401]                     }, error = function(ex) {
[10:34:01.401]                       msg <- conditionMessage(ex)
[10:34:01.401]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.401]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:34:01.401]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.401]                         fi_tmp[["mtime"]], msg)
[10:34:01.401]                       ex$message <- msg
[10:34:01.401]                       stop(ex)
[10:34:01.401]                     })
[10:34:01.401]                     stopifnot(file_test("-f", pathname_tmp))
[10:34:01.401]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:34:01.401]                     if (!res || file_test("-f", pathname_tmp)) {
[10:34:01.401]                       fi_tmp <- file.info(pathname_tmp)
[10:34:01.401]                       fi <- file.info(pathname)
[10:34:01.401]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:34:01.401]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:34:01.401]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:34:01.401]                         fi[["size"]], fi[["mtime"]])
[10:34:01.401]                       stop(msg)
[10:34:01.401]                     }
[10:34:01.401]                     invisible(pathname)
[10:34:01.401]                   }
[10:34:01.401]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:34:01.401]                     rootPath = tempdir()) 
[10:34:01.401]                   {
[10:34:01.401]                     obj <- list(time = Sys.time(), condition = cond)
[10:34:01.401]                     file <- tempfile(pattern = class(cond)[1], 
[10:34:01.401]                       tmpdir = path, fileext = ".rds")
[10:34:01.401]                     save_rds(obj, file)
[10:34:01.401]                   }
[10:34:01.401]                   saveImmediateCondition(cond, path = "/tmp/RtmpuZEzLw/.future/immediateConditions")
[10:34:01.401]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.401]                   {
[10:34:01.401]                     inherits <- base::inherits
[10:34:01.401]                     invokeRestart <- base::invokeRestart
[10:34:01.401]                     is.null <- base::is.null
[10:34:01.401]                     muffled <- FALSE
[10:34:01.401]                     if (inherits(cond, "message")) {
[10:34:01.401]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:01.401]                       if (muffled) 
[10:34:01.401]                         invokeRestart("muffleMessage")
[10:34:01.401]                     }
[10:34:01.401]                     else if (inherits(cond, "warning")) {
[10:34:01.401]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:01.401]                       if (muffled) 
[10:34:01.401]                         invokeRestart("muffleWarning")
[10:34:01.401]                     }
[10:34:01.401]                     else if (inherits(cond, "condition")) {
[10:34:01.401]                       if (!is.null(pattern)) {
[10:34:01.401]                         computeRestarts <- base::computeRestarts
[10:34:01.401]                         grepl <- base::grepl
[10:34:01.401]                         restarts <- computeRestarts(cond)
[10:34:01.401]                         for (restart in restarts) {
[10:34:01.401]                           name <- restart$name
[10:34:01.401]                           if (is.null(name)) 
[10:34:01.401]                             next
[10:34:01.401]                           if (!grepl(pattern, name)) 
[10:34:01.401]                             next
[10:34:01.401]                           invokeRestart(restart)
[10:34:01.401]                           muffled <- TRUE
[10:34:01.401]                           break
[10:34:01.401]                         }
[10:34:01.401]                       }
[10:34:01.401]                     }
[10:34:01.401]                     invisible(muffled)
[10:34:01.401]                   }
[10:34:01.401]                   muffleCondition(cond)
[10:34:01.401]                 })
[10:34:01.401]             }))
[10:34:01.401]             future::FutureResult(value = ...future.value$value, 
[10:34:01.401]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:01.401]                   ...future.rng), globalenv = if (FALSE) 
[10:34:01.401]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:01.401]                     ...future.globalenv.names))
[10:34:01.401]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:01.401]         }, condition = base::local({
[10:34:01.401]             c <- base::c
[10:34:01.401]             inherits <- base::inherits
[10:34:01.401]             invokeRestart <- base::invokeRestart
[10:34:01.401]             length <- base::length
[10:34:01.401]             list <- base::list
[10:34:01.401]             seq.int <- base::seq.int
[10:34:01.401]             signalCondition <- base::signalCondition
[10:34:01.401]             sys.calls <- base::sys.calls
[10:34:01.401]             `[[` <- base::`[[`
[10:34:01.401]             `+` <- base::`+`
[10:34:01.401]             `<<-` <- base::`<<-`
[10:34:01.401]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:01.401]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:01.401]                   3L)]
[10:34:01.401]             }
[10:34:01.401]             function(cond) {
[10:34:01.401]                 is_error <- inherits(cond, "error")
[10:34:01.401]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:01.401]                   NULL)
[10:34:01.401]                 if (is_error) {
[10:34:01.401]                   sessionInformation <- function() {
[10:34:01.401]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:01.401]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:01.401]                       search = base::search(), system = base::Sys.info())
[10:34:01.401]                   }
[10:34:01.401]                   ...future.conditions[[length(...future.conditions) + 
[10:34:01.401]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:01.401]                     cond$call), session = sessionInformation(), 
[10:34:01.401]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:01.401]                   signalCondition(cond)
[10:34:01.401]                 }
[10:34:01.401]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:01.401]                 "immediateCondition"))) {
[10:34:01.401]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:01.401]                   ...future.conditions[[length(...future.conditions) + 
[10:34:01.401]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:01.401]                   if (TRUE && !signal) {
[10:34:01.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.401]                     {
[10:34:01.401]                       inherits <- base::inherits
[10:34:01.401]                       invokeRestart <- base::invokeRestart
[10:34:01.401]                       is.null <- base::is.null
[10:34:01.401]                       muffled <- FALSE
[10:34:01.401]                       if (inherits(cond, "message")) {
[10:34:01.401]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:01.401]                         if (muffled) 
[10:34:01.401]                           invokeRestart("muffleMessage")
[10:34:01.401]                       }
[10:34:01.401]                       else if (inherits(cond, "warning")) {
[10:34:01.401]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:01.401]                         if (muffled) 
[10:34:01.401]                           invokeRestart("muffleWarning")
[10:34:01.401]                       }
[10:34:01.401]                       else if (inherits(cond, "condition")) {
[10:34:01.401]                         if (!is.null(pattern)) {
[10:34:01.401]                           computeRestarts <- base::computeRestarts
[10:34:01.401]                           grepl <- base::grepl
[10:34:01.401]                           restarts <- computeRestarts(cond)
[10:34:01.401]                           for (restart in restarts) {
[10:34:01.401]                             name <- restart$name
[10:34:01.401]                             if (is.null(name)) 
[10:34:01.401]                               next
[10:34:01.401]                             if (!grepl(pattern, name)) 
[10:34:01.401]                               next
[10:34:01.401]                             invokeRestart(restart)
[10:34:01.401]                             muffled <- TRUE
[10:34:01.401]                             break
[10:34:01.401]                           }
[10:34:01.401]                         }
[10:34:01.401]                       }
[10:34:01.401]                       invisible(muffled)
[10:34:01.401]                     }
[10:34:01.401]                     muffleCondition(cond, pattern = "^muffle")
[10:34:01.401]                   }
[10:34:01.401]                 }
[10:34:01.401]                 else {
[10:34:01.401]                   if (TRUE) {
[10:34:01.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:01.401]                     {
[10:34:01.401]                       inherits <- base::inherits
[10:34:01.401]                       invokeRestart <- base::invokeRestart
[10:34:01.401]                       is.null <- base::is.null
[10:34:01.401]                       muffled <- FALSE
[10:34:01.401]                       if (inherits(cond, "message")) {
[10:34:01.401]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:01.401]                         if (muffled) 
[10:34:01.401]                           invokeRestart("muffleMessage")
[10:34:01.401]                       }
[10:34:01.401]                       else if (inherits(cond, "warning")) {
[10:34:01.401]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:01.401]                         if (muffled) 
[10:34:01.401]                           invokeRestart("muffleWarning")
[10:34:01.401]                       }
[10:34:01.401]                       else if (inherits(cond, "condition")) {
[10:34:01.401]                         if (!is.null(pattern)) {
[10:34:01.401]                           computeRestarts <- base::computeRestarts
[10:34:01.401]                           grepl <- base::grepl
[10:34:01.401]                           restarts <- computeRestarts(cond)
[10:34:01.401]                           for (restart in restarts) {
[10:34:01.401]                             name <- restart$name
[10:34:01.401]                             if (is.null(name)) 
[10:34:01.401]                               next
[10:34:01.401]                             if (!grepl(pattern, name)) 
[10:34:01.401]                               next
[10:34:01.401]                             invokeRestart(restart)
[10:34:01.401]                             muffled <- TRUE
[10:34:01.401]                             break
[10:34:01.401]                           }
[10:34:01.401]                         }
[10:34:01.401]                       }
[10:34:01.401]                       invisible(muffled)
[10:34:01.401]                     }
[10:34:01.401]                     muffleCondition(cond, pattern = "^muffle")
[10:34:01.401]                   }
[10:34:01.401]                 }
[10:34:01.401]             }
[10:34:01.401]         }))
[10:34:01.401]     }, error = function(ex) {
[10:34:01.401]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:01.401]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:01.401]                 ...future.rng), started = ...future.startTime, 
[10:34:01.401]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:01.401]             version = "1.8"), class = "FutureResult")
[10:34:01.401]     }, finally = {
[10:34:01.401]         if (!identical(...future.workdir, getwd())) 
[10:34:01.401]             setwd(...future.workdir)
[10:34:01.401]         {
[10:34:01.401]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:01.401]                 ...future.oldOptions$nwarnings <- NULL
[10:34:01.401]             }
[10:34:01.401]             base::options(...future.oldOptions)
[10:34:01.401]             if (.Platform$OS.type == "windows") {
[10:34:01.401]                 old_names <- names(...future.oldEnvVars)
[10:34:01.401]                 envs <- base::Sys.getenv()
[10:34:01.401]                 names <- names(envs)
[10:34:01.401]                 common <- intersect(names, old_names)
[10:34:01.401]                 added <- setdiff(names, old_names)
[10:34:01.401]                 removed <- setdiff(old_names, names)
[10:34:01.401]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:01.401]                   envs[common]]
[10:34:01.401]                 NAMES <- toupper(changed)
[10:34:01.401]                 args <- list()
[10:34:01.401]                 for (kk in seq_along(NAMES)) {
[10:34:01.401]                   name <- changed[[kk]]
[10:34:01.401]                   NAME <- NAMES[[kk]]
[10:34:01.401]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.401]                     next
[10:34:01.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:01.401]                 }
[10:34:01.401]                 NAMES <- toupper(added)
[10:34:01.401]                 for (kk in seq_along(NAMES)) {
[10:34:01.401]                   name <- added[[kk]]
[10:34:01.401]                   NAME <- NAMES[[kk]]
[10:34:01.401]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.401]                     next
[10:34:01.401]                   args[[name]] <- ""
[10:34:01.401]                 }
[10:34:01.401]                 NAMES <- toupper(removed)
[10:34:01.401]                 for (kk in seq_along(NAMES)) {
[10:34:01.401]                   name <- removed[[kk]]
[10:34:01.401]                   NAME <- NAMES[[kk]]
[10:34:01.401]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:01.401]                     next
[10:34:01.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:01.401]                 }
[10:34:01.401]                 if (length(args) > 0) 
[10:34:01.401]                   base::do.call(base::Sys.setenv, args = args)
[10:34:01.401]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:01.401]             }
[10:34:01.401]             else {
[10:34:01.401]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:01.401]             }
[10:34:01.401]             {
[10:34:01.401]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:01.401]                   0L) {
[10:34:01.401]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:01.401]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:01.401]                   base::options(opts)
[10:34:01.401]                 }
[10:34:01.401]                 {
[10:34:01.401]                   {
[10:34:01.401]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:01.401]                     NULL
[10:34:01.401]                   }
[10:34:01.401]                   options(future.plan = NULL)
[10:34:01.401]                   if (is.na(NA_character_)) 
[10:34:01.401]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:01.401]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:01.401]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:01.401]                     .init = FALSE)
[10:34:01.401]                 }
[10:34:01.401]             }
[10:34:01.401]         }
[10:34:01.401]     })
[10:34:01.401]     if (TRUE) {
[10:34:01.401]         base::sink(type = "output", split = FALSE)
[10:34:01.401]         if (TRUE) {
[10:34:01.401]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:01.401]         }
[10:34:01.401]         else {
[10:34:01.401]             ...future.result["stdout"] <- base::list(NULL)
[10:34:01.401]         }
[10:34:01.401]         base::close(...future.stdout)
[10:34:01.401]         ...future.stdout <- NULL
[10:34:01.401]     }
[10:34:01.401]     ...future.result$conditions <- ...future.conditions
[10:34:01.401]     ...future.result$finished <- base::Sys.time()
[10:34:01.401]     ...future.result
[10:34:01.401] }
[10:34:01.404] requestCore(): workers = 2
[10:34:01.405] Poll #1 (0): usedCores() = 2, workers = 2
[10:34:01.415] result() for MulticoreFuture ...
[10:34:01.417] result() for MulticoreFuture ...
[10:34:01.417] result() for MulticoreFuture ... done
[10:34:01.417] result() for MulticoreFuture ... done
[10:34:01.417] result() for MulticoreFuture ...
[10:34:01.417] result() for MulticoreFuture ... done
[10:34:01.419] MulticoreFuture started
[10:34:01.420] - Launch lazy future ... done
[10:34:01.420] run() for ‘MulticoreFuture’ ... done
[10:34:01.421] plan(): Setting new future strategy stack:
[10:34:01.421] List of future strategies:
[10:34:01.421] 1. sequential:
[10:34:01.421]    - args: function (..., envir = parent.frame())
[10:34:01.421]    - tweaked: FALSE
[10:34:01.421]    - call: NULL
[10:34:01.422] plan(): nbrOfWorkers() = 1
[10:34:01.422] resolve() on list environment ...
[10:34:01.422]  recursive: 0
[10:34:01.423]  length: 4
[10:34:01.423]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:34:01.424] Future #1
[10:34:01.424] plan(): Setting new future strategy stack:
[10:34:01.424]  length: 3 (resolved future 1)
[10:34:01.424] List of future strategies:
[10:34:01.424] 1. multicore:
[10:34:01.424]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:34:01.424]    - tweaked: FALSE
[10:34:01.424]    - call: plan(strategy)
[10:34:01.429] plan(): nbrOfWorkers() = 2
[10:34:01.435] Future #3
[10:34:01.435]  length: 2 (resolved future 3)
[10:34:01.435]  length: 1 (resolved future 4)
[10:34:01.883] plan(): Setting new future strategy stack:
[10:34:01.883] List of future strategies:
[10:34:01.883] 1. multicore:
[10:34:01.883]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:34:01.883]    - tweaked: FALSE
[10:34:01.883]    - call: plan(strategy)
[10:34:01.888] plan(): nbrOfWorkers() = 2
[10:34:01.895] Future #2
[10:34:01.895]  length: 0 (resolved future 2)
[10:34:01.895] resolve() on list environment ... DONE
[10:34:01.896] resolve() on list environment ...
[10:34:01.896]  recursive: 0
[10:34:01.897]  length: 4
[10:34:01.897]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:34:01.897] Future #1
[10:34:01.898]  length: 3 (resolved future 1)
[10:34:01.898] Future #2
[10:34:01.898]  length: 2 (resolved future 2)
[10:34:01.898] Future #3
[10:34:01.899]  length: 1 (resolved future 3)
[10:34:01.899]  length: 0 (resolved future 4)
[10:34:01.899] resolve() on list environment ... DONE
[10:34:01.900] resolve() on list environment ...
[10:34:01.900]  recursive: 0
[10:34:01.901]  length: 4
[10:34:01.901]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:34:01.901] Future #1
[10:34:01.901]  length: 3 (resolved future 1)
[10:34:01.902] Future #2
[10:34:01.902]  length: 2 (resolved future 2)
[10:34:01.902] Future #3
[10:34:01.902]  length: 1 (resolved future 3)
[10:34:01.902]  length: 0 (resolved future 4)
[10:34:01.903] resolve() on list environment ... DONE
[10:34:01.903] resolve() on list environment ...
[10:34:01.903]  recursive: 0
[10:34:01.904]  length: 4
[10:34:01.904]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:34:01.905] Future #1
[10:34:01.905]  length: 3 (resolved future 1)
[10:34:01.905] Future #2
[10:34:01.905]  length: 2 (resolved future 2)
[10:34:01.906] Future #3
[10:34:01.906]  length: 1 (resolved future 3)
[10:34:01.906]  length: 0 (resolved future 4)
[10:34:01.906] resolve() on list environment ... DONE
[10:34:01.907] resolve() on list environment ...
[10:34:01.907]  recursive: 0
[10:34:01.908]  length: 4
[10:34:01.908]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:34:01.908] Future #1
[10:34:01.908] result() for MulticoreFuture ...
[10:34:01.908] result() for MulticoreFuture ... done
[10:34:01.909] result() for MulticoreFuture ...
[10:34:01.909] result() for MulticoreFuture ... done
[10:34:01.909]  length: 3 (resolved future 1)
[10:34:01.909] Future #2
[10:34:01.909] result() for MulticoreFuture ...
[10:34:01.910] result() for MulticoreFuture ...
[10:34:01.911] result() for MulticoreFuture ... done
[10:34:01.911] result() for MulticoreFuture ... done
[10:34:01.911] result() for MulticoreFuture ...
[10:34:01.911] result() for MulticoreFuture ... done
[10:34:01.911]  length: 2 (resolved future 2)
[10:34:01.912] Future #3
[10:34:01.912] result() for MulticoreFuture ...
[10:34:01.916] result() for MulticoreFuture ...
[10:34:01.916] result() for MulticoreFuture ... done
[10:34:01.917] result() for MulticoreFuture ... done
[10:34:01.917] result() for MulticoreFuture ...
[10:34:01.917] result() for MulticoreFuture ... done
[10:34:01.917]  length: 1 (resolved future 3)
[10:34:01.917]  length: 0 (resolved future 4)
[10:34:01.918] resolve() on list environment ... DONE
[10:34:01.918] resolve() on list environment ...
[10:34:01.919]  recursive: 99
[10:34:01.919]  length: 4
[10:34:01.920]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:34:01.920] Future #1
[10:34:01.920] result() for MulticoreFuture ...
[10:34:01.920] result() for MulticoreFuture ... done
[10:34:01.920] result() for MulticoreFuture ...
[10:34:01.920] result() for MulticoreFuture ... done
[10:34:01.920] A MulticoreFuture was resolved
[10:34:01.921]  length: 3 (resolved future 1)
[10:34:01.921] Future #2
[10:34:01.921] result() for MulticoreFuture ...
[10:34:01.921] result() for MulticoreFuture ... done
[10:34:01.921] result() for MulticoreFuture ...
[10:34:01.921] result() for MulticoreFuture ... done
[10:34:01.921] A MulticoreFuture was resolved
[10:34:01.922]  length: 2 (resolved future 2)
[10:34:01.922] Future #3
[10:34:01.922] result() for MulticoreFuture ...
[10:34:01.922] result() for MulticoreFuture ... done
[10:34:01.922] result() for MulticoreFuture ...
[10:34:01.922] result() for MulticoreFuture ... done
[10:34:01.922] A MulticoreFuture was resolved
[10:34:01.923]  length: 1 (resolved future 3)
[10:34:01.923]  length: 0 (resolved future 4)
[10:34:01.923] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multicore') ...
- plan('multisession') ...
[10:34:01.924] plan(): Setting new future strategy stack:
[10:34:01.924] List of future strategies:
[10:34:01.924] 1. multisession:
[10:34:01.924]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:34:01.924]    - tweaked: FALSE
[10:34:01.924]    - call: plan(strategy)
[10:34:01.924] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:34:01.924] multisession:
[10:34:01.924] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:34:01.924] - tweaked: FALSE
[10:34:01.924] - call: plan(strategy)
[10:34:01.931] getGlobalsAndPackages() ...
[10:34:01.931] Not searching for globals
[10:34:01.931] - globals: [0] <none>
[10:34:01.932] getGlobalsAndPackages() ... DONE
[10:34:01.932] [local output] makeClusterPSOCK() ...
[10:34:01.977] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:34:01.978] [local output] Base port: 11803
[10:34:01.978] [local output] Getting setup options for 2 cluster nodes ...
[10:34:01.978] [local output]  - Node 1 of 2 ...
[10:34:01.979] [local output] localMachine=TRUE => revtunnel=FALSE

[10:34:01.980] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpuZEzLw/worker.rank=1.parallelly.parent=88418.1596278605fa.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpuZEzLw/worker.rank=1.parallelly.parent=88418.1596278605fa.pid")'’
[10:34:02.171] - Possible to infer worker's PID: TRUE
[10:34:02.171] [local output] Rscript port: 11803

[10:34:02.171] [local output]  - Node 2 of 2 ...
[10:34:02.172] [local output] localMachine=TRUE => revtunnel=FALSE

[10:34:02.172] [local output] Rscript port: 11803

[10:34:02.173] [local output] Getting setup options for 2 cluster nodes ... done
[10:34:02.173] [local output]  - Parallel setup requested for some PSOCK nodes
[10:34:02.173] [local output] Setting up PSOCK nodes in parallel
[10:34:02.174] List of 36
[10:34:02.174]  $ worker          : chr "localhost"
[10:34:02.174]   ..- attr(*, "localhost")= logi TRUE
[10:34:02.174]  $ master          : chr "localhost"
[10:34:02.174]  $ port            : int 11803
[10:34:02.174]  $ connectTimeout  : num 120
[10:34:02.174]  $ timeout         : num 2592000
[10:34:02.174]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:34:02.174]  $ homogeneous     : logi TRUE
[10:34:02.174]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:34:02.174]  $ rscript_envs    : NULL
[10:34:02.174]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:34:02.174]  $ rscript_startup : NULL
[10:34:02.174]  $ rscript_sh      : chr "sh"
[10:34:02.174]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:34:02.174]  $ methods         : logi TRUE
[10:34:02.174]  $ socketOptions   : chr "no-delay"
[10:34:02.174]  $ useXDR          : logi FALSE
[10:34:02.174]  $ outfile         : chr "/dev/null"
[10:34:02.174]  $ renice          : int NA
[10:34:02.174]  $ rshcmd          : NULL
[10:34:02.174]  $ user            : chr(0) 
[10:34:02.174]  $ revtunnel       : logi FALSE
[10:34:02.174]  $ rshlogfile      : NULL
[10:34:02.174]  $ rshopts         : chr(0) 
[10:34:02.174]  $ rank            : int 1
[10:34:02.174]  $ manual          : logi FALSE
[10:34:02.174]  $ dryrun          : logi FALSE
[10:34:02.174]  $ quiet           : logi FALSE
[10:34:02.174]  $ setup_strategy  : chr "parallel"
[10:34:02.174]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:34:02.174]  $ pidfile         : chr "/tmp/RtmpuZEzLw/worker.rank=1.parallelly.parent=88418.1596278605fa.pid"
[10:34:02.174]  $ rshcmd_label    : NULL
[10:34:02.174]  $ rsh_call        : NULL
[10:34:02.174]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:34:02.174]  $ localMachine    : logi TRUE
[10:34:02.174]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:34:02.174]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:34:02.174]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:34:02.174]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:34:02.174]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:34:02.174]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:34:02.174]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:34:02.174]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:34:02.174]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:34:02.174]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:34:02.174]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:34:02.174]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:34:02.174]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:34:02.174]  $ arguments       :List of 28
[10:34:02.174]   ..$ worker          : chr "localhost"
[10:34:02.174]   ..$ master          : NULL
[10:34:02.174]   ..$ port            : int 11803
[10:34:02.174]   ..$ connectTimeout  : num 120
[10:34:02.174]   ..$ timeout         : num 2592000
[10:34:02.174]   ..$ rscript         : NULL
[10:34:02.174]   ..$ homogeneous     : NULL
[10:34:02.174]   ..$ rscript_args    : NULL
[10:34:02.174]   ..$ rscript_envs    : NULL
[10:34:02.174]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:34:02.174]   ..$ rscript_startup : NULL
[10:34:02.174]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:34:02.174]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:34:02.174]   ..$ methods         : logi TRUE
[10:34:02.174]   ..$ socketOptions   : chr "no-delay"
[10:34:02.174]   ..$ useXDR          : logi FALSE
[10:34:02.174]   ..$ outfile         : chr "/dev/null"
[10:34:02.174]   ..$ renice          : int NA
[10:34:02.174]   ..$ rshcmd          : NULL
[10:34:02.174]   ..$ user            : NULL
[10:34:02.174]   ..$ revtunnel       : logi NA
[10:34:02.174]   ..$ rshlogfile      : NULL
[10:34:02.174]   ..$ rshopts         : NULL
[10:34:02.174]   ..$ rank            : int 1
[10:34:02.174]   ..$ manual          : logi FALSE
[10:34:02.174]   ..$ dryrun          : logi FALSE
[10:34:02.174]   ..$ quiet           : logi FALSE
[10:34:02.174]   ..$ setup_strategy  : chr "parallel"
[10:34:02.174]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:34:02.190] [local output] System call to launch all workers:
[10:34:02.191] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpuZEzLw/worker.rank=1.parallelly.parent=88418.1596278605fa.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11803 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:34:02.191] [local output] Starting PSOCK main server
[10:34:02.197] [local output] Workers launched
[10:34:02.197] [local output] Waiting for workers to connect back
[10:34:02.197]  - [local output] 0 workers out of 2 ready
[10:34:02.459]  - [local output] 0 workers out of 2 ready
[10:34:02.459]  - [local output] 1 workers out of 2 ready
[10:34:02.466]  - [local output] 1 workers out of 2 ready
[10:34:02.466]  - [local output] 2 workers out of 2 ready
[10:34:02.466] [local output] Launching of workers completed
[10:34:02.466] [local output] Collecting session information from workers
[10:34:02.467] [local output]  - Worker #1 of 2
[10:34:02.468] [local output]  - Worker #2 of 2
[10:34:02.468] [local output] makeClusterPSOCK() ... done
[10:34:02.479] Packages needed by the future expression (n = 0): <none>
[10:34:02.479] Packages needed by future strategies (n = 0): <none>
[10:34:02.480] {
[10:34:02.480]     {
[10:34:02.480]         {
[10:34:02.480]             ...future.startTime <- base::Sys.time()
[10:34:02.480]             {
[10:34:02.480]                 {
[10:34:02.480]                   {
[10:34:02.480]                     {
[10:34:02.480]                       base::local({
[10:34:02.480]                         has_future <- base::requireNamespace("future", 
[10:34:02.480]                           quietly = TRUE)
[10:34:02.480]                         if (has_future) {
[10:34:02.480]                           ns <- base::getNamespace("future")
[10:34:02.480]                           version <- ns[[".package"]][["version"]]
[10:34:02.480]                           if (is.null(version)) 
[10:34:02.480]                             version <- utils::packageVersion("future")
[10:34:02.480]                         }
[10:34:02.480]                         else {
[10:34:02.480]                           version <- NULL
[10:34:02.480]                         }
[10:34:02.480]                         if (!has_future || version < "1.8.0") {
[10:34:02.480]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:02.480]                             "", base::R.version$version.string), 
[10:34:02.480]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:02.480]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:02.480]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:02.480]                               "release", "version")], collapse = " "), 
[10:34:02.480]                             hostname = base::Sys.info()[["nodename"]])
[10:34:02.480]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:02.480]                             info)
[10:34:02.480]                           info <- base::paste(info, collapse = "; ")
[10:34:02.480]                           if (!has_future) {
[10:34:02.480]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:02.480]                               info)
[10:34:02.480]                           }
[10:34:02.480]                           else {
[10:34:02.480]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:02.480]                               info, version)
[10:34:02.480]                           }
[10:34:02.480]                           base::stop(msg)
[10:34:02.480]                         }
[10:34:02.480]                       })
[10:34:02.480]                     }
[10:34:02.480]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:02.480]                     base::options(mc.cores = 1L)
[10:34:02.480]                   }
[10:34:02.480]                   ...future.strategy.old <- future::plan("list")
[10:34:02.480]                   options(future.plan = NULL)
[10:34:02.480]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:02.480]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:02.480]                 }
[10:34:02.480]                 ...future.workdir <- getwd()
[10:34:02.480]             }
[10:34:02.480]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:02.480]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:02.480]         }
[10:34:02.480]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:02.480]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:02.480]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:02.480]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:02.480]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:02.480]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:02.480]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:02.480]             base::names(...future.oldOptions))
[10:34:02.480]     }
[10:34:02.480]     if (FALSE) {
[10:34:02.480]     }
[10:34:02.480]     else {
[10:34:02.480]         if (TRUE) {
[10:34:02.480]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:02.480]                 open = "w")
[10:34:02.480]         }
[10:34:02.480]         else {
[10:34:02.480]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:02.480]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:02.480]         }
[10:34:02.480]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:02.480]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:02.480]             base::sink(type = "output", split = FALSE)
[10:34:02.480]             base::close(...future.stdout)
[10:34:02.480]         }, add = TRUE)
[10:34:02.480]     }
[10:34:02.480]     ...future.frame <- base::sys.nframe()
[10:34:02.480]     ...future.conditions <- base::list()
[10:34:02.480]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:02.480]     if (FALSE) {
[10:34:02.480]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:02.480]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:02.480]     }
[10:34:02.480]     ...future.result <- base::tryCatch({
[10:34:02.480]         base::withCallingHandlers({
[10:34:02.480]             ...future.value <- base::withVisible(base::local({
[10:34:02.480]                 ...future.makeSendCondition <- base::local({
[10:34:02.480]                   sendCondition <- NULL
[10:34:02.480]                   function(frame = 1L) {
[10:34:02.480]                     if (is.function(sendCondition)) 
[10:34:02.480]                       return(sendCondition)
[10:34:02.480]                     ns <- getNamespace("parallel")
[10:34:02.480]                     if (exists("sendData", mode = "function", 
[10:34:02.480]                       envir = ns)) {
[10:34:02.480]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:02.480]                         envir = ns)
[10:34:02.480]                       envir <- sys.frame(frame)
[10:34:02.480]                       master <- NULL
[10:34:02.480]                       while (!identical(envir, .GlobalEnv) && 
[10:34:02.480]                         !identical(envir, emptyenv())) {
[10:34:02.480]                         if (exists("master", mode = "list", envir = envir, 
[10:34:02.480]                           inherits = FALSE)) {
[10:34:02.480]                           master <- get("master", mode = "list", 
[10:34:02.480]                             envir = envir, inherits = FALSE)
[10:34:02.480]                           if (inherits(master, c("SOCKnode", 
[10:34:02.480]                             "SOCK0node"))) {
[10:34:02.480]                             sendCondition <<- function(cond) {
[10:34:02.480]                               data <- list(type = "VALUE", value = cond, 
[10:34:02.480]                                 success = TRUE)
[10:34:02.480]                               parallel_sendData(master, data)
[10:34:02.480]                             }
[10:34:02.480]                             return(sendCondition)
[10:34:02.480]                           }
[10:34:02.480]                         }
[10:34:02.480]                         frame <- frame + 1L
[10:34:02.480]                         envir <- sys.frame(frame)
[10:34:02.480]                       }
[10:34:02.480]                     }
[10:34:02.480]                     sendCondition <<- function(cond) NULL
[10:34:02.480]                   }
[10:34:02.480]                 })
[10:34:02.480]                 withCallingHandlers({
[10:34:02.480]                   NA
[10:34:02.480]                 }, immediateCondition = function(cond) {
[10:34:02.480]                   sendCondition <- ...future.makeSendCondition()
[10:34:02.480]                   sendCondition(cond)
[10:34:02.480]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:02.480]                   {
[10:34:02.480]                     inherits <- base::inherits
[10:34:02.480]                     invokeRestart <- base::invokeRestart
[10:34:02.480]                     is.null <- base::is.null
[10:34:02.480]                     muffled <- FALSE
[10:34:02.480]                     if (inherits(cond, "message")) {
[10:34:02.480]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:02.480]                       if (muffled) 
[10:34:02.480]                         invokeRestart("muffleMessage")
[10:34:02.480]                     }
[10:34:02.480]                     else if (inherits(cond, "warning")) {
[10:34:02.480]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:02.480]                       if (muffled) 
[10:34:02.480]                         invokeRestart("muffleWarning")
[10:34:02.480]                     }
[10:34:02.480]                     else if (inherits(cond, "condition")) {
[10:34:02.480]                       if (!is.null(pattern)) {
[10:34:02.480]                         computeRestarts <- base::computeRestarts
[10:34:02.480]                         grepl <- base::grepl
[10:34:02.480]                         restarts <- computeRestarts(cond)
[10:34:02.480]                         for (restart in restarts) {
[10:34:02.480]                           name <- restart$name
[10:34:02.480]                           if (is.null(name)) 
[10:34:02.480]                             next
[10:34:02.480]                           if (!grepl(pattern, name)) 
[10:34:02.480]                             next
[10:34:02.480]                           invokeRestart(restart)
[10:34:02.480]                           muffled <- TRUE
[10:34:02.480]                           break
[10:34:02.480]                         }
[10:34:02.480]                       }
[10:34:02.480]                     }
[10:34:02.480]                     invisible(muffled)
[10:34:02.480]                   }
[10:34:02.480]                   muffleCondition(cond)
[10:34:02.480]                 })
[10:34:02.480]             }))
[10:34:02.480]             future::FutureResult(value = ...future.value$value, 
[10:34:02.480]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:02.480]                   ...future.rng), globalenv = if (FALSE) 
[10:34:02.480]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:02.480]                     ...future.globalenv.names))
[10:34:02.480]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:02.480]         }, condition = base::local({
[10:34:02.480]             c <- base::c
[10:34:02.480]             inherits <- base::inherits
[10:34:02.480]             invokeRestart <- base::invokeRestart
[10:34:02.480]             length <- base::length
[10:34:02.480]             list <- base::list
[10:34:02.480]             seq.int <- base::seq.int
[10:34:02.480]             signalCondition <- base::signalCondition
[10:34:02.480]             sys.calls <- base::sys.calls
[10:34:02.480]             `[[` <- base::`[[`
[10:34:02.480]             `+` <- base::`+`
[10:34:02.480]             `<<-` <- base::`<<-`
[10:34:02.480]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:02.480]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:02.480]                   3L)]
[10:34:02.480]             }
[10:34:02.480]             function(cond) {
[10:34:02.480]                 is_error <- inherits(cond, "error")
[10:34:02.480]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:02.480]                   NULL)
[10:34:02.480]                 if (is_error) {
[10:34:02.480]                   sessionInformation <- function() {
[10:34:02.480]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:02.480]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:02.480]                       search = base::search(), system = base::Sys.info())
[10:34:02.480]                   }
[10:34:02.480]                   ...future.conditions[[length(...future.conditions) + 
[10:34:02.480]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:02.480]                     cond$call), session = sessionInformation(), 
[10:34:02.480]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:02.480]                   signalCondition(cond)
[10:34:02.480]                 }
[10:34:02.480]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:02.480]                 "immediateCondition"))) {
[10:34:02.480]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:02.480]                   ...future.conditions[[length(...future.conditions) + 
[10:34:02.480]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:02.480]                   if (TRUE && !signal) {
[10:34:02.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:02.480]                     {
[10:34:02.480]                       inherits <- base::inherits
[10:34:02.480]                       invokeRestart <- base::invokeRestart
[10:34:02.480]                       is.null <- base::is.null
[10:34:02.480]                       muffled <- FALSE
[10:34:02.480]                       if (inherits(cond, "message")) {
[10:34:02.480]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:02.480]                         if (muffled) 
[10:34:02.480]                           invokeRestart("muffleMessage")
[10:34:02.480]                       }
[10:34:02.480]                       else if (inherits(cond, "warning")) {
[10:34:02.480]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:02.480]                         if (muffled) 
[10:34:02.480]                           invokeRestart("muffleWarning")
[10:34:02.480]                       }
[10:34:02.480]                       else if (inherits(cond, "condition")) {
[10:34:02.480]                         if (!is.null(pattern)) {
[10:34:02.480]                           computeRestarts <- base::computeRestarts
[10:34:02.480]                           grepl <- base::grepl
[10:34:02.480]                           restarts <- computeRestarts(cond)
[10:34:02.480]                           for (restart in restarts) {
[10:34:02.480]                             name <- restart$name
[10:34:02.480]                             if (is.null(name)) 
[10:34:02.480]                               next
[10:34:02.480]                             if (!grepl(pattern, name)) 
[10:34:02.480]                               next
[10:34:02.480]                             invokeRestart(restart)
[10:34:02.480]                             muffled <- TRUE
[10:34:02.480]                             break
[10:34:02.480]                           }
[10:34:02.480]                         }
[10:34:02.480]                       }
[10:34:02.480]                       invisible(muffled)
[10:34:02.480]                     }
[10:34:02.480]                     muffleCondition(cond, pattern = "^muffle")
[10:34:02.480]                   }
[10:34:02.480]                 }
[10:34:02.480]                 else {
[10:34:02.480]                   if (TRUE) {
[10:34:02.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:02.480]                     {
[10:34:02.480]                       inherits <- base::inherits
[10:34:02.480]                       invokeRestart <- base::invokeRestart
[10:34:02.480]                       is.null <- base::is.null
[10:34:02.480]                       muffled <- FALSE
[10:34:02.480]                       if (inherits(cond, "message")) {
[10:34:02.480]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:02.480]                         if (muffled) 
[10:34:02.480]                           invokeRestart("muffleMessage")
[10:34:02.480]                       }
[10:34:02.480]                       else if (inherits(cond, "warning")) {
[10:34:02.480]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:02.480]                         if (muffled) 
[10:34:02.480]                           invokeRestart("muffleWarning")
[10:34:02.480]                       }
[10:34:02.480]                       else if (inherits(cond, "condition")) {
[10:34:02.480]                         if (!is.null(pattern)) {
[10:34:02.480]                           computeRestarts <- base::computeRestarts
[10:34:02.480]                           grepl <- base::grepl
[10:34:02.480]                           restarts <- computeRestarts(cond)
[10:34:02.480]                           for (restart in restarts) {
[10:34:02.480]                             name <- restart$name
[10:34:02.480]                             if (is.null(name)) 
[10:34:02.480]                               next
[10:34:02.480]                             if (!grepl(pattern, name)) 
[10:34:02.480]                               next
[10:34:02.480]                             invokeRestart(restart)
[10:34:02.480]                             muffled <- TRUE
[10:34:02.480]                             break
[10:34:02.480]                           }
[10:34:02.480]                         }
[10:34:02.480]                       }
[10:34:02.480]                       invisible(muffled)
[10:34:02.480]                     }
[10:34:02.480]                     muffleCondition(cond, pattern = "^muffle")
[10:34:02.480]                   }
[10:34:02.480]                 }
[10:34:02.480]             }
[10:34:02.480]         }))
[10:34:02.480]     }, error = function(ex) {
[10:34:02.480]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:02.480]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:02.480]                 ...future.rng), started = ...future.startTime, 
[10:34:02.480]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:02.480]             version = "1.8"), class = "FutureResult")
[10:34:02.480]     }, finally = {
[10:34:02.480]         if (!identical(...future.workdir, getwd())) 
[10:34:02.480]             setwd(...future.workdir)
[10:34:02.480]         {
[10:34:02.480]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:02.480]                 ...future.oldOptions$nwarnings <- NULL
[10:34:02.480]             }
[10:34:02.480]             base::options(...future.oldOptions)
[10:34:02.480]             if (.Platform$OS.type == "windows") {
[10:34:02.480]                 old_names <- names(...future.oldEnvVars)
[10:34:02.480]                 envs <- base::Sys.getenv()
[10:34:02.480]                 names <- names(envs)
[10:34:02.480]                 common <- intersect(names, old_names)
[10:34:02.480]                 added <- setdiff(names, old_names)
[10:34:02.480]                 removed <- setdiff(old_names, names)
[10:34:02.480]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:02.480]                   envs[common]]
[10:34:02.480]                 NAMES <- toupper(changed)
[10:34:02.480]                 args <- list()
[10:34:02.480]                 for (kk in seq_along(NAMES)) {
[10:34:02.480]                   name <- changed[[kk]]
[10:34:02.480]                   NAME <- NAMES[[kk]]
[10:34:02.480]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:02.480]                     next
[10:34:02.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:02.480]                 }
[10:34:02.480]                 NAMES <- toupper(added)
[10:34:02.480]                 for (kk in seq_along(NAMES)) {
[10:34:02.480]                   name <- added[[kk]]
[10:34:02.480]                   NAME <- NAMES[[kk]]
[10:34:02.480]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:02.480]                     next
[10:34:02.480]                   args[[name]] <- ""
[10:34:02.480]                 }
[10:34:02.480]                 NAMES <- toupper(removed)
[10:34:02.480]                 for (kk in seq_along(NAMES)) {
[10:34:02.480]                   name <- removed[[kk]]
[10:34:02.480]                   NAME <- NAMES[[kk]]
[10:34:02.480]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:02.480]                     next
[10:34:02.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:02.480]                 }
[10:34:02.480]                 if (length(args) > 0) 
[10:34:02.480]                   base::do.call(base::Sys.setenv, args = args)
[10:34:02.480]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:02.480]             }
[10:34:02.480]             else {
[10:34:02.480]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:02.480]             }
[10:34:02.480]             {
[10:34:02.480]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:02.480]                   0L) {
[10:34:02.480]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:02.480]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:02.480]                   base::options(opts)
[10:34:02.480]                 }
[10:34:02.480]                 {
[10:34:02.480]                   {
[10:34:02.480]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:02.480]                     NULL
[10:34:02.480]                   }
[10:34:02.480]                   options(future.plan = NULL)
[10:34:02.480]                   if (is.na(NA_character_)) 
[10:34:02.480]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:02.480]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:02.480]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:02.480]                     .init = FALSE)
[10:34:02.480]                 }
[10:34:02.480]             }
[10:34:02.480]         }
[10:34:02.480]     })
[10:34:02.480]     if (TRUE) {
[10:34:02.480]         base::sink(type = "output", split = FALSE)
[10:34:02.480]         if (TRUE) {
[10:34:02.480]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:02.480]         }
[10:34:02.480]         else {
[10:34:02.480]             ...future.result["stdout"] <- base::list(NULL)
[10:34:02.480]         }
[10:34:02.480]         base::close(...future.stdout)
[10:34:02.480]         ...future.stdout <- NULL
[10:34:02.480]     }
[10:34:02.480]     ...future.result$conditions <- ...future.conditions
[10:34:02.480]     ...future.result$finished <- base::Sys.time()
[10:34:02.480]     ...future.result
[10:34:02.480] }
[10:34:02.532] MultisessionFuture started
[10:34:02.533] result() for ClusterFuture ...
[10:34:02.533] receiveMessageFromWorker() for ClusterFuture ...
[10:34:02.534] - Validating connection of MultisessionFuture
[10:34:02.566] - received message: FutureResult
[10:34:02.567] - Received FutureResult
[10:34:02.567] - Erased future from FutureRegistry
[10:34:02.567] result() for ClusterFuture ...
[10:34:02.567] - result already collected: FutureResult
[10:34:02.567] result() for ClusterFuture ... done
[10:34:02.567] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:02.567] result() for ClusterFuture ... done
[10:34:02.567] result() for ClusterFuture ...
[10:34:02.568] - result already collected: FutureResult
[10:34:02.568] result() for ClusterFuture ... done
[10:34:02.568] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:34:02.572] plan(): nbrOfWorkers() = 2
*** resolve() for Future objects ...
- result = FALSE, recursive = FALSE ...
[10:34:02.575] getGlobalsAndPackages() ...
[10:34:02.575] Searching for globals...
[10:34:02.577] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:34:02.577] Searching for globals ... DONE
[10:34:02.577] Resolving globals: FALSE
[10:34:02.578] 
[10:34:02.578] 
[10:34:02.578] getGlobalsAndPackages() ... DONE
[10:34:02.578] run() for ‘Future’ ...
[10:34:02.578] - state: ‘created’
[10:34:02.578] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:02.593] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:02.593] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:02.593]   - Field: ‘node’
[10:34:02.593]   - Field: ‘label’
[10:34:02.593]   - Field: ‘local’
[10:34:02.593]   - Field: ‘owner’
[10:34:02.593]   - Field: ‘envir’
[10:34:02.593]   - Field: ‘workers’
[10:34:02.594]   - Field: ‘packages’
[10:34:02.594]   - Field: ‘gc’
[10:34:02.594]   - Field: ‘conditions’
[10:34:02.594]   - Field: ‘persistent’
[10:34:02.594]   - Field: ‘expr’
[10:34:02.594]   - Field: ‘uuid’
[10:34:02.594]   - Field: ‘seed’
[10:34:02.594]   - Field: ‘version’
[10:34:02.594]   - Field: ‘result’
[10:34:02.595]   - Field: ‘asynchronous’
[10:34:02.595]   - Field: ‘calls’
[10:34:02.595]   - Field: ‘globals’
[10:34:02.595]   - Field: ‘stdout’
[10:34:02.595]   - Field: ‘earlySignal’
[10:34:02.595]   - Field: ‘lazy’
[10:34:02.595]   - Field: ‘state’
[10:34:02.595] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:02.596] - Launch lazy future ...
[10:34:02.596] Packages needed by the future expression (n = 0): <none>
[10:34:02.596] Packages needed by future strategies (n = 0): <none>
[10:34:02.596] {
[10:34:02.596]     {
[10:34:02.596]         {
[10:34:02.596]             ...future.startTime <- base::Sys.time()
[10:34:02.596]             {
[10:34:02.596]                 {
[10:34:02.596]                   {
[10:34:02.596]                     {
[10:34:02.596]                       base::local({
[10:34:02.596]                         has_future <- base::requireNamespace("future", 
[10:34:02.596]                           quietly = TRUE)
[10:34:02.596]                         if (has_future) {
[10:34:02.596]                           ns <- base::getNamespace("future")
[10:34:02.596]                           version <- ns[[".package"]][["version"]]
[10:34:02.596]                           if (is.null(version)) 
[10:34:02.596]                             version <- utils::packageVersion("future")
[10:34:02.596]                         }
[10:34:02.596]                         else {
[10:34:02.596]                           version <- NULL
[10:34:02.596]                         }
[10:34:02.596]                         if (!has_future || version < "1.8.0") {
[10:34:02.596]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:02.596]                             "", base::R.version$version.string), 
[10:34:02.596]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:02.596]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:02.596]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:02.596]                               "release", "version")], collapse = " "), 
[10:34:02.596]                             hostname = base::Sys.info()[["nodename"]])
[10:34:02.596]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:02.596]                             info)
[10:34:02.596]                           info <- base::paste(info, collapse = "; ")
[10:34:02.596]                           if (!has_future) {
[10:34:02.596]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:02.596]                               info)
[10:34:02.596]                           }
[10:34:02.596]                           else {
[10:34:02.596]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:02.596]                               info, version)
[10:34:02.596]                           }
[10:34:02.596]                           base::stop(msg)
[10:34:02.596]                         }
[10:34:02.596]                       })
[10:34:02.596]                     }
[10:34:02.596]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:02.596]                     base::options(mc.cores = 1L)
[10:34:02.596]                   }
[10:34:02.596]                   ...future.strategy.old <- future::plan("list")
[10:34:02.596]                   options(future.plan = NULL)
[10:34:02.596]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:02.596]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:02.596]                 }
[10:34:02.596]                 ...future.workdir <- getwd()
[10:34:02.596]             }
[10:34:02.596]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:02.596]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:02.596]         }
[10:34:02.596]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:02.596]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:02.596]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:02.596]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:02.596]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:02.596]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:02.596]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:02.596]             base::names(...future.oldOptions))
[10:34:02.596]     }
[10:34:02.596]     if (FALSE) {
[10:34:02.596]     }
[10:34:02.596]     else {
[10:34:02.596]         if (TRUE) {
[10:34:02.596]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:02.596]                 open = "w")
[10:34:02.596]         }
[10:34:02.596]         else {
[10:34:02.596]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:02.596]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:02.596]         }
[10:34:02.596]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:02.596]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:02.596]             base::sink(type = "output", split = FALSE)
[10:34:02.596]             base::close(...future.stdout)
[10:34:02.596]         }, add = TRUE)
[10:34:02.596]     }
[10:34:02.596]     ...future.frame <- base::sys.nframe()
[10:34:02.596]     ...future.conditions <- base::list()
[10:34:02.596]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:02.596]     if (FALSE) {
[10:34:02.596]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:02.596]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:02.596]     }
[10:34:02.596]     ...future.result <- base::tryCatch({
[10:34:02.596]         base::withCallingHandlers({
[10:34:02.596]             ...future.value <- base::withVisible(base::local({
[10:34:02.596]                 ...future.makeSendCondition <- base::local({
[10:34:02.596]                   sendCondition <- NULL
[10:34:02.596]                   function(frame = 1L) {
[10:34:02.596]                     if (is.function(sendCondition)) 
[10:34:02.596]                       return(sendCondition)
[10:34:02.596]                     ns <- getNamespace("parallel")
[10:34:02.596]                     if (exists("sendData", mode = "function", 
[10:34:02.596]                       envir = ns)) {
[10:34:02.596]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:02.596]                         envir = ns)
[10:34:02.596]                       envir <- sys.frame(frame)
[10:34:02.596]                       master <- NULL
[10:34:02.596]                       while (!identical(envir, .GlobalEnv) && 
[10:34:02.596]                         !identical(envir, emptyenv())) {
[10:34:02.596]                         if (exists("master", mode = "list", envir = envir, 
[10:34:02.596]                           inherits = FALSE)) {
[10:34:02.596]                           master <- get("master", mode = "list", 
[10:34:02.596]                             envir = envir, inherits = FALSE)
[10:34:02.596]                           if (inherits(master, c("SOCKnode", 
[10:34:02.596]                             "SOCK0node"))) {
[10:34:02.596]                             sendCondition <<- function(cond) {
[10:34:02.596]                               data <- list(type = "VALUE", value = cond, 
[10:34:02.596]                                 success = TRUE)
[10:34:02.596]                               parallel_sendData(master, data)
[10:34:02.596]                             }
[10:34:02.596]                             return(sendCondition)
[10:34:02.596]                           }
[10:34:02.596]                         }
[10:34:02.596]                         frame <- frame + 1L
[10:34:02.596]                         envir <- sys.frame(frame)
[10:34:02.596]                       }
[10:34:02.596]                     }
[10:34:02.596]                     sendCondition <<- function(cond) NULL
[10:34:02.596]                   }
[10:34:02.596]                 })
[10:34:02.596]                 withCallingHandlers({
[10:34:02.596]                   {
[10:34:02.596]                     Sys.sleep(0.5)
[10:34:02.596]                     list(a = 1, b = 42L)
[10:34:02.596]                   }
[10:34:02.596]                 }, immediateCondition = function(cond) {
[10:34:02.596]                   sendCondition <- ...future.makeSendCondition()
[10:34:02.596]                   sendCondition(cond)
[10:34:02.596]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:02.596]                   {
[10:34:02.596]                     inherits <- base::inherits
[10:34:02.596]                     invokeRestart <- base::invokeRestart
[10:34:02.596]                     is.null <- base::is.null
[10:34:02.596]                     muffled <- FALSE
[10:34:02.596]                     if (inherits(cond, "message")) {
[10:34:02.596]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:02.596]                       if (muffled) 
[10:34:02.596]                         invokeRestart("muffleMessage")
[10:34:02.596]                     }
[10:34:02.596]                     else if (inherits(cond, "warning")) {
[10:34:02.596]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:02.596]                       if (muffled) 
[10:34:02.596]                         invokeRestart("muffleWarning")
[10:34:02.596]                     }
[10:34:02.596]                     else if (inherits(cond, "condition")) {
[10:34:02.596]                       if (!is.null(pattern)) {
[10:34:02.596]                         computeRestarts <- base::computeRestarts
[10:34:02.596]                         grepl <- base::grepl
[10:34:02.596]                         restarts <- computeRestarts(cond)
[10:34:02.596]                         for (restart in restarts) {
[10:34:02.596]                           name <- restart$name
[10:34:02.596]                           if (is.null(name)) 
[10:34:02.596]                             next
[10:34:02.596]                           if (!grepl(pattern, name)) 
[10:34:02.596]                             next
[10:34:02.596]                           invokeRestart(restart)
[10:34:02.596]                           muffled <- TRUE
[10:34:02.596]                           break
[10:34:02.596]                         }
[10:34:02.596]                       }
[10:34:02.596]                     }
[10:34:02.596]                     invisible(muffled)
[10:34:02.596]                   }
[10:34:02.596]                   muffleCondition(cond)
[10:34:02.596]                 })
[10:34:02.596]             }))
[10:34:02.596]             future::FutureResult(value = ...future.value$value, 
[10:34:02.596]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:02.596]                   ...future.rng), globalenv = if (FALSE) 
[10:34:02.596]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:02.596]                     ...future.globalenv.names))
[10:34:02.596]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:02.596]         }, condition = base::local({
[10:34:02.596]             c <- base::c
[10:34:02.596]             inherits <- base::inherits
[10:34:02.596]             invokeRestart <- base::invokeRestart
[10:34:02.596]             length <- base::length
[10:34:02.596]             list <- base::list
[10:34:02.596]             seq.int <- base::seq.int
[10:34:02.596]             signalCondition <- base::signalCondition
[10:34:02.596]             sys.calls <- base::sys.calls
[10:34:02.596]             `[[` <- base::`[[`
[10:34:02.596]             `+` <- base::`+`
[10:34:02.596]             `<<-` <- base::`<<-`
[10:34:02.596]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:02.596]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:02.596]                   3L)]
[10:34:02.596]             }
[10:34:02.596]             function(cond) {
[10:34:02.596]                 is_error <- inherits(cond, "error")
[10:34:02.596]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:02.596]                   NULL)
[10:34:02.596]                 if (is_error) {
[10:34:02.596]                   sessionInformation <- function() {
[10:34:02.596]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:02.596]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:02.596]                       search = base::search(), system = base::Sys.info())
[10:34:02.596]                   }
[10:34:02.596]                   ...future.conditions[[length(...future.conditions) + 
[10:34:02.596]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:02.596]                     cond$call), session = sessionInformation(), 
[10:34:02.596]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:02.596]                   signalCondition(cond)
[10:34:02.596]                 }
[10:34:02.596]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:02.596]                 "immediateCondition"))) {
[10:34:02.596]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:02.596]                   ...future.conditions[[length(...future.conditions) + 
[10:34:02.596]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:02.596]                   if (TRUE && !signal) {
[10:34:02.596]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:02.596]                     {
[10:34:02.596]                       inherits <- base::inherits
[10:34:02.596]                       invokeRestart <- base::invokeRestart
[10:34:02.596]                       is.null <- base::is.null
[10:34:02.596]                       muffled <- FALSE
[10:34:02.596]                       if (inherits(cond, "message")) {
[10:34:02.596]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:02.596]                         if (muffled) 
[10:34:02.596]                           invokeRestart("muffleMessage")
[10:34:02.596]                       }
[10:34:02.596]                       else if (inherits(cond, "warning")) {
[10:34:02.596]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:02.596]                         if (muffled) 
[10:34:02.596]                           invokeRestart("muffleWarning")
[10:34:02.596]                       }
[10:34:02.596]                       else if (inherits(cond, "condition")) {
[10:34:02.596]                         if (!is.null(pattern)) {
[10:34:02.596]                           computeRestarts <- base::computeRestarts
[10:34:02.596]                           grepl <- base::grepl
[10:34:02.596]                           restarts <- computeRestarts(cond)
[10:34:02.596]                           for (restart in restarts) {
[10:34:02.596]                             name <- restart$name
[10:34:02.596]                             if (is.null(name)) 
[10:34:02.596]                               next
[10:34:02.596]                             if (!grepl(pattern, name)) 
[10:34:02.596]                               next
[10:34:02.596]                             invokeRestart(restart)
[10:34:02.596]                             muffled <- TRUE
[10:34:02.596]                             break
[10:34:02.596]                           }
[10:34:02.596]                         }
[10:34:02.596]                       }
[10:34:02.596]                       invisible(muffled)
[10:34:02.596]                     }
[10:34:02.596]                     muffleCondition(cond, pattern = "^muffle")
[10:34:02.596]                   }
[10:34:02.596]                 }
[10:34:02.596]                 else {
[10:34:02.596]                   if (TRUE) {
[10:34:02.596]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:02.596]                     {
[10:34:02.596]                       inherits <- base::inherits
[10:34:02.596]                       invokeRestart <- base::invokeRestart
[10:34:02.596]                       is.null <- base::is.null
[10:34:02.596]                       muffled <- FALSE
[10:34:02.596]                       if (inherits(cond, "message")) {
[10:34:02.596]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:02.596]                         if (muffled) 
[10:34:02.596]                           invokeRestart("muffleMessage")
[10:34:02.596]                       }
[10:34:02.596]                       else if (inherits(cond, "warning")) {
[10:34:02.596]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:02.596]                         if (muffled) 
[10:34:02.596]                           invokeRestart("muffleWarning")
[10:34:02.596]                       }
[10:34:02.596]                       else if (inherits(cond, "condition")) {
[10:34:02.596]                         if (!is.null(pattern)) {
[10:34:02.596]                           computeRestarts <- base::computeRestarts
[10:34:02.596]                           grepl <- base::grepl
[10:34:02.596]                           restarts <- computeRestarts(cond)
[10:34:02.596]                           for (restart in restarts) {
[10:34:02.596]                             name <- restart$name
[10:34:02.596]                             if (is.null(name)) 
[10:34:02.596]                               next
[10:34:02.596]                             if (!grepl(pattern, name)) 
[10:34:02.596]                               next
[10:34:02.596]                             invokeRestart(restart)
[10:34:02.596]                             muffled <- TRUE
[10:34:02.596]                             break
[10:34:02.596]                           }
[10:34:02.596]                         }
[10:34:02.596]                       }
[10:34:02.596]                       invisible(muffled)
[10:34:02.596]                     }
[10:34:02.596]                     muffleCondition(cond, pattern = "^muffle")
[10:34:02.596]                   }
[10:34:02.596]                 }
[10:34:02.596]             }
[10:34:02.596]         }))
[10:34:02.596]     }, error = function(ex) {
[10:34:02.596]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:02.596]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:02.596]                 ...future.rng), started = ...future.startTime, 
[10:34:02.596]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:02.596]             version = "1.8"), class = "FutureResult")
[10:34:02.596]     }, finally = {
[10:34:02.596]         if (!identical(...future.workdir, getwd())) 
[10:34:02.596]             setwd(...future.workdir)
[10:34:02.596]         {
[10:34:02.596]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:02.596]                 ...future.oldOptions$nwarnings <- NULL
[10:34:02.596]             }
[10:34:02.596]             base::options(...future.oldOptions)
[10:34:02.596]             if (.Platform$OS.type == "windows") {
[10:34:02.596]                 old_names <- names(...future.oldEnvVars)
[10:34:02.596]                 envs <- base::Sys.getenv()
[10:34:02.596]                 names <- names(envs)
[10:34:02.596]                 common <- intersect(names, old_names)
[10:34:02.596]                 added <- setdiff(names, old_names)
[10:34:02.596]                 removed <- setdiff(old_names, names)
[10:34:02.596]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:02.596]                   envs[common]]
[10:34:02.596]                 NAMES <- toupper(changed)
[10:34:02.596]                 args <- list()
[10:34:02.596]                 for (kk in seq_along(NAMES)) {
[10:34:02.596]                   name <- changed[[kk]]
[10:34:02.596]                   NAME <- NAMES[[kk]]
[10:34:02.596]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:02.596]                     next
[10:34:02.596]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:02.596]                 }
[10:34:02.596]                 NAMES <- toupper(added)
[10:34:02.596]                 for (kk in seq_along(NAMES)) {
[10:34:02.596]                   name <- added[[kk]]
[10:34:02.596]                   NAME <- NAMES[[kk]]
[10:34:02.596]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:02.596]                     next
[10:34:02.596]                   args[[name]] <- ""
[10:34:02.596]                 }
[10:34:02.596]                 NAMES <- toupper(removed)
[10:34:02.596]                 for (kk in seq_along(NAMES)) {
[10:34:02.596]                   name <- removed[[kk]]
[10:34:02.596]                   NAME <- NAMES[[kk]]
[10:34:02.596]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:02.596]                     next
[10:34:02.596]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:02.596]                 }
[10:34:02.596]                 if (length(args) > 0) 
[10:34:02.596]                   base::do.call(base::Sys.setenv, args = args)
[10:34:02.596]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:02.596]             }
[10:34:02.596]             else {
[10:34:02.596]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:02.596]             }
[10:34:02.596]             {
[10:34:02.596]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:02.596]                   0L) {
[10:34:02.596]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:02.596]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:02.596]                   base::options(opts)
[10:34:02.596]                 }
[10:34:02.596]                 {
[10:34:02.596]                   {
[10:34:02.596]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:02.596]                     NULL
[10:34:02.596]                   }
[10:34:02.596]                   options(future.plan = NULL)
[10:34:02.596]                   if (is.na(NA_character_)) 
[10:34:02.596]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:02.596]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:02.596]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:02.596]                     .init = FALSE)
[10:34:02.596]                 }
[10:34:02.596]             }
[10:34:02.596]         }
[10:34:02.596]     })
[10:34:02.596]     if (TRUE) {
[10:34:02.596]         base::sink(type = "output", split = FALSE)
[10:34:02.596]         if (TRUE) {
[10:34:02.596]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:02.596]         }
[10:34:02.596]         else {
[10:34:02.596]             ...future.result["stdout"] <- base::list(NULL)
[10:34:02.596]         }
[10:34:02.596]         base::close(...future.stdout)
[10:34:02.596]         ...future.stdout <- NULL
[10:34:02.596]     }
[10:34:02.596]     ...future.result$conditions <- ...future.conditions
[10:34:02.596]     ...future.result$finished <- base::Sys.time()
[10:34:02.596]     ...future.result
[10:34:02.596] }
[10:34:02.600] MultisessionFuture started
[10:34:02.600] - Launch lazy future ... done
[10:34:02.600] run() for ‘MultisessionFuture’ ... done
[10:34:03.106] receiveMessageFromWorker() for ClusterFuture ...
[10:34:03.107] - Validating connection of MultisessionFuture
[10:34:03.107] - received message: FutureResult
[10:34:03.107] - Received FutureResult
[10:34:03.107] - Erased future from FutureRegistry
[10:34:03.107] result() for ClusterFuture ...
[10:34:03.108] - result already collected: FutureResult
[10:34:03.108] result() for ClusterFuture ... done
[10:34:03.108] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:03.108] A MultisessionFuture was resolved (result was not collected)
[10:34:03.108] getGlobalsAndPackages() ...
[10:34:03.108] Searching for globals...
[10:34:03.110] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:34:03.111] Searching for globals ... DONE
[10:34:03.111] Resolving globals: FALSE
[10:34:03.111] 
[10:34:03.112] 
[10:34:03.112] getGlobalsAndPackages() ... DONE
[10:34:03.112] run() for ‘Future’ ...
[10:34:03.112] - state: ‘created’
[10:34:03.113] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:03.128] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:03.128] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:03.128]   - Field: ‘node’
[10:34:03.128]   - Field: ‘label’
[10:34:03.128]   - Field: ‘local’
[10:34:03.128]   - Field: ‘owner’
[10:34:03.128]   - Field: ‘envir’
[10:34:03.129]   - Field: ‘workers’
[10:34:03.129]   - Field: ‘packages’
[10:34:03.129]   - Field: ‘gc’
[10:34:03.129]   - Field: ‘conditions’
[10:34:03.129]   - Field: ‘persistent’
[10:34:03.129]   - Field: ‘expr’
[10:34:03.129]   - Field: ‘uuid’
[10:34:03.129]   - Field: ‘seed’
[10:34:03.130]   - Field: ‘version’
[10:34:03.130]   - Field: ‘result’
[10:34:03.130]   - Field: ‘asynchronous’
[10:34:03.130]   - Field: ‘calls’
[10:34:03.130]   - Field: ‘globals’
[10:34:03.130]   - Field: ‘stdout’
[10:34:03.130]   - Field: ‘earlySignal’
[10:34:03.130]   - Field: ‘lazy’
[10:34:03.130]   - Field: ‘state’
[10:34:03.131] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:03.131] - Launch lazy future ...
[10:34:03.131] Packages needed by the future expression (n = 0): <none>
[10:34:03.131] Packages needed by future strategies (n = 0): <none>
[10:34:03.132] {
[10:34:03.132]     {
[10:34:03.132]         {
[10:34:03.132]             ...future.startTime <- base::Sys.time()
[10:34:03.132]             {
[10:34:03.132]                 {
[10:34:03.132]                   {
[10:34:03.132]                     {
[10:34:03.132]                       base::local({
[10:34:03.132]                         has_future <- base::requireNamespace("future", 
[10:34:03.132]                           quietly = TRUE)
[10:34:03.132]                         if (has_future) {
[10:34:03.132]                           ns <- base::getNamespace("future")
[10:34:03.132]                           version <- ns[[".package"]][["version"]]
[10:34:03.132]                           if (is.null(version)) 
[10:34:03.132]                             version <- utils::packageVersion("future")
[10:34:03.132]                         }
[10:34:03.132]                         else {
[10:34:03.132]                           version <- NULL
[10:34:03.132]                         }
[10:34:03.132]                         if (!has_future || version < "1.8.0") {
[10:34:03.132]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:03.132]                             "", base::R.version$version.string), 
[10:34:03.132]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:03.132]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:03.132]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:03.132]                               "release", "version")], collapse = " "), 
[10:34:03.132]                             hostname = base::Sys.info()[["nodename"]])
[10:34:03.132]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:03.132]                             info)
[10:34:03.132]                           info <- base::paste(info, collapse = "; ")
[10:34:03.132]                           if (!has_future) {
[10:34:03.132]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:03.132]                               info)
[10:34:03.132]                           }
[10:34:03.132]                           else {
[10:34:03.132]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:03.132]                               info, version)
[10:34:03.132]                           }
[10:34:03.132]                           base::stop(msg)
[10:34:03.132]                         }
[10:34:03.132]                       })
[10:34:03.132]                     }
[10:34:03.132]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:03.132]                     base::options(mc.cores = 1L)
[10:34:03.132]                   }
[10:34:03.132]                   ...future.strategy.old <- future::plan("list")
[10:34:03.132]                   options(future.plan = NULL)
[10:34:03.132]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:03.132]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:03.132]                 }
[10:34:03.132]                 ...future.workdir <- getwd()
[10:34:03.132]             }
[10:34:03.132]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:03.132]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:03.132]         }
[10:34:03.132]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:03.132]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:03.132]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:03.132]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:03.132]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:03.132]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:03.132]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:03.132]             base::names(...future.oldOptions))
[10:34:03.132]     }
[10:34:03.132]     if (FALSE) {
[10:34:03.132]     }
[10:34:03.132]     else {
[10:34:03.132]         if (TRUE) {
[10:34:03.132]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:03.132]                 open = "w")
[10:34:03.132]         }
[10:34:03.132]         else {
[10:34:03.132]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:03.132]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:03.132]         }
[10:34:03.132]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:03.132]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:03.132]             base::sink(type = "output", split = FALSE)
[10:34:03.132]             base::close(...future.stdout)
[10:34:03.132]         }, add = TRUE)
[10:34:03.132]     }
[10:34:03.132]     ...future.frame <- base::sys.nframe()
[10:34:03.132]     ...future.conditions <- base::list()
[10:34:03.132]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:03.132]     if (FALSE) {
[10:34:03.132]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:03.132]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:03.132]     }
[10:34:03.132]     ...future.result <- base::tryCatch({
[10:34:03.132]         base::withCallingHandlers({
[10:34:03.132]             ...future.value <- base::withVisible(base::local({
[10:34:03.132]                 ...future.makeSendCondition <- base::local({
[10:34:03.132]                   sendCondition <- NULL
[10:34:03.132]                   function(frame = 1L) {
[10:34:03.132]                     if (is.function(sendCondition)) 
[10:34:03.132]                       return(sendCondition)
[10:34:03.132]                     ns <- getNamespace("parallel")
[10:34:03.132]                     if (exists("sendData", mode = "function", 
[10:34:03.132]                       envir = ns)) {
[10:34:03.132]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:03.132]                         envir = ns)
[10:34:03.132]                       envir <- sys.frame(frame)
[10:34:03.132]                       master <- NULL
[10:34:03.132]                       while (!identical(envir, .GlobalEnv) && 
[10:34:03.132]                         !identical(envir, emptyenv())) {
[10:34:03.132]                         if (exists("master", mode = "list", envir = envir, 
[10:34:03.132]                           inherits = FALSE)) {
[10:34:03.132]                           master <- get("master", mode = "list", 
[10:34:03.132]                             envir = envir, inherits = FALSE)
[10:34:03.132]                           if (inherits(master, c("SOCKnode", 
[10:34:03.132]                             "SOCK0node"))) {
[10:34:03.132]                             sendCondition <<- function(cond) {
[10:34:03.132]                               data <- list(type = "VALUE", value = cond, 
[10:34:03.132]                                 success = TRUE)
[10:34:03.132]                               parallel_sendData(master, data)
[10:34:03.132]                             }
[10:34:03.132]                             return(sendCondition)
[10:34:03.132]                           }
[10:34:03.132]                         }
[10:34:03.132]                         frame <- frame + 1L
[10:34:03.132]                         envir <- sys.frame(frame)
[10:34:03.132]                       }
[10:34:03.132]                     }
[10:34:03.132]                     sendCondition <<- function(cond) NULL
[10:34:03.132]                   }
[10:34:03.132]                 })
[10:34:03.132]                 withCallingHandlers({
[10:34:03.132]                   {
[10:34:03.132]                     Sys.sleep(0.5)
[10:34:03.132]                     list(a = 1, b = 42L)
[10:34:03.132]                   }
[10:34:03.132]                 }, immediateCondition = function(cond) {
[10:34:03.132]                   sendCondition <- ...future.makeSendCondition()
[10:34:03.132]                   sendCondition(cond)
[10:34:03.132]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:03.132]                   {
[10:34:03.132]                     inherits <- base::inherits
[10:34:03.132]                     invokeRestart <- base::invokeRestart
[10:34:03.132]                     is.null <- base::is.null
[10:34:03.132]                     muffled <- FALSE
[10:34:03.132]                     if (inherits(cond, "message")) {
[10:34:03.132]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:03.132]                       if (muffled) 
[10:34:03.132]                         invokeRestart("muffleMessage")
[10:34:03.132]                     }
[10:34:03.132]                     else if (inherits(cond, "warning")) {
[10:34:03.132]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:03.132]                       if (muffled) 
[10:34:03.132]                         invokeRestart("muffleWarning")
[10:34:03.132]                     }
[10:34:03.132]                     else if (inherits(cond, "condition")) {
[10:34:03.132]                       if (!is.null(pattern)) {
[10:34:03.132]                         computeRestarts <- base::computeRestarts
[10:34:03.132]                         grepl <- base::grepl
[10:34:03.132]                         restarts <- computeRestarts(cond)
[10:34:03.132]                         for (restart in restarts) {
[10:34:03.132]                           name <- restart$name
[10:34:03.132]                           if (is.null(name)) 
[10:34:03.132]                             next
[10:34:03.132]                           if (!grepl(pattern, name)) 
[10:34:03.132]                             next
[10:34:03.132]                           invokeRestart(restart)
[10:34:03.132]                           muffled <- TRUE
[10:34:03.132]                           break
[10:34:03.132]                         }
[10:34:03.132]                       }
[10:34:03.132]                     }
[10:34:03.132]                     invisible(muffled)
[10:34:03.132]                   }
[10:34:03.132]                   muffleCondition(cond)
[10:34:03.132]                 })
[10:34:03.132]             }))
[10:34:03.132]             future::FutureResult(value = ...future.value$value, 
[10:34:03.132]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:03.132]                   ...future.rng), globalenv = if (FALSE) 
[10:34:03.132]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:03.132]                     ...future.globalenv.names))
[10:34:03.132]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:03.132]         }, condition = base::local({
[10:34:03.132]             c <- base::c
[10:34:03.132]             inherits <- base::inherits
[10:34:03.132]             invokeRestart <- base::invokeRestart
[10:34:03.132]             length <- base::length
[10:34:03.132]             list <- base::list
[10:34:03.132]             seq.int <- base::seq.int
[10:34:03.132]             signalCondition <- base::signalCondition
[10:34:03.132]             sys.calls <- base::sys.calls
[10:34:03.132]             `[[` <- base::`[[`
[10:34:03.132]             `+` <- base::`+`
[10:34:03.132]             `<<-` <- base::`<<-`
[10:34:03.132]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:03.132]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:03.132]                   3L)]
[10:34:03.132]             }
[10:34:03.132]             function(cond) {
[10:34:03.132]                 is_error <- inherits(cond, "error")
[10:34:03.132]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:03.132]                   NULL)
[10:34:03.132]                 if (is_error) {
[10:34:03.132]                   sessionInformation <- function() {
[10:34:03.132]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:03.132]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:03.132]                       search = base::search(), system = base::Sys.info())
[10:34:03.132]                   }
[10:34:03.132]                   ...future.conditions[[length(...future.conditions) + 
[10:34:03.132]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:03.132]                     cond$call), session = sessionInformation(), 
[10:34:03.132]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:03.132]                   signalCondition(cond)
[10:34:03.132]                 }
[10:34:03.132]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:03.132]                 "immediateCondition"))) {
[10:34:03.132]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:03.132]                   ...future.conditions[[length(...future.conditions) + 
[10:34:03.132]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:03.132]                   if (TRUE && !signal) {
[10:34:03.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:03.132]                     {
[10:34:03.132]                       inherits <- base::inherits
[10:34:03.132]                       invokeRestart <- base::invokeRestart
[10:34:03.132]                       is.null <- base::is.null
[10:34:03.132]                       muffled <- FALSE
[10:34:03.132]                       if (inherits(cond, "message")) {
[10:34:03.132]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:03.132]                         if (muffled) 
[10:34:03.132]                           invokeRestart("muffleMessage")
[10:34:03.132]                       }
[10:34:03.132]                       else if (inherits(cond, "warning")) {
[10:34:03.132]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:03.132]                         if (muffled) 
[10:34:03.132]                           invokeRestart("muffleWarning")
[10:34:03.132]                       }
[10:34:03.132]                       else if (inherits(cond, "condition")) {
[10:34:03.132]                         if (!is.null(pattern)) {
[10:34:03.132]                           computeRestarts <- base::computeRestarts
[10:34:03.132]                           grepl <- base::grepl
[10:34:03.132]                           restarts <- computeRestarts(cond)
[10:34:03.132]                           for (restart in restarts) {
[10:34:03.132]                             name <- restart$name
[10:34:03.132]                             if (is.null(name)) 
[10:34:03.132]                               next
[10:34:03.132]                             if (!grepl(pattern, name)) 
[10:34:03.132]                               next
[10:34:03.132]                             invokeRestart(restart)
[10:34:03.132]                             muffled <- TRUE
[10:34:03.132]                             break
[10:34:03.132]                           }
[10:34:03.132]                         }
[10:34:03.132]                       }
[10:34:03.132]                       invisible(muffled)
[10:34:03.132]                     }
[10:34:03.132]                     muffleCondition(cond, pattern = "^muffle")
[10:34:03.132]                   }
[10:34:03.132]                 }
[10:34:03.132]                 else {
[10:34:03.132]                   if (TRUE) {
[10:34:03.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:03.132]                     {
[10:34:03.132]                       inherits <- base::inherits
[10:34:03.132]                       invokeRestart <- base::invokeRestart
[10:34:03.132]                       is.null <- base::is.null
[10:34:03.132]                       muffled <- FALSE
[10:34:03.132]                       if (inherits(cond, "message")) {
[10:34:03.132]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:03.132]                         if (muffled) 
[10:34:03.132]                           invokeRestart("muffleMessage")
[10:34:03.132]                       }
[10:34:03.132]                       else if (inherits(cond, "warning")) {
[10:34:03.132]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:03.132]                         if (muffled) 
[10:34:03.132]                           invokeRestart("muffleWarning")
[10:34:03.132]                       }
[10:34:03.132]                       else if (inherits(cond, "condition")) {
[10:34:03.132]                         if (!is.null(pattern)) {
[10:34:03.132]                           computeRestarts <- base::computeRestarts
[10:34:03.132]                           grepl <- base::grepl
[10:34:03.132]                           restarts <- computeRestarts(cond)
[10:34:03.132]                           for (restart in restarts) {
[10:34:03.132]                             name <- restart$name
[10:34:03.132]                             if (is.null(name)) 
[10:34:03.132]                               next
[10:34:03.132]                             if (!grepl(pattern, name)) 
[10:34:03.132]                               next
[10:34:03.132]                             invokeRestart(restart)
[10:34:03.132]                             muffled <- TRUE
[10:34:03.132]                             break
[10:34:03.132]                           }
[10:34:03.132]                         }
[10:34:03.132]                       }
[10:34:03.132]                       invisible(muffled)
[10:34:03.132]                     }
[10:34:03.132]                     muffleCondition(cond, pattern = "^muffle")
[10:34:03.132]                   }
[10:34:03.132]                 }
[10:34:03.132]             }
[10:34:03.132]         }))
[10:34:03.132]     }, error = function(ex) {
[10:34:03.132]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:03.132]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:03.132]                 ...future.rng), started = ...future.startTime, 
[10:34:03.132]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:03.132]             version = "1.8"), class = "FutureResult")
[10:34:03.132]     }, finally = {
[10:34:03.132]         if (!identical(...future.workdir, getwd())) 
[10:34:03.132]             setwd(...future.workdir)
[10:34:03.132]         {
[10:34:03.132]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:03.132]                 ...future.oldOptions$nwarnings <- NULL
[10:34:03.132]             }
[10:34:03.132]             base::options(...future.oldOptions)
[10:34:03.132]             if (.Platform$OS.type == "windows") {
[10:34:03.132]                 old_names <- names(...future.oldEnvVars)
[10:34:03.132]                 envs <- base::Sys.getenv()
[10:34:03.132]                 names <- names(envs)
[10:34:03.132]                 common <- intersect(names, old_names)
[10:34:03.132]                 added <- setdiff(names, old_names)
[10:34:03.132]                 removed <- setdiff(old_names, names)
[10:34:03.132]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:03.132]                   envs[common]]
[10:34:03.132]                 NAMES <- toupper(changed)
[10:34:03.132]                 args <- list()
[10:34:03.132]                 for (kk in seq_along(NAMES)) {
[10:34:03.132]                   name <- changed[[kk]]
[10:34:03.132]                   NAME <- NAMES[[kk]]
[10:34:03.132]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:03.132]                     next
[10:34:03.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:03.132]                 }
[10:34:03.132]                 NAMES <- toupper(added)
[10:34:03.132]                 for (kk in seq_along(NAMES)) {
[10:34:03.132]                   name <- added[[kk]]
[10:34:03.132]                   NAME <- NAMES[[kk]]
[10:34:03.132]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:03.132]                     next
[10:34:03.132]                   args[[name]] <- ""
[10:34:03.132]                 }
[10:34:03.132]                 NAMES <- toupper(removed)
[10:34:03.132]                 for (kk in seq_along(NAMES)) {
[10:34:03.132]                   name <- removed[[kk]]
[10:34:03.132]                   NAME <- NAMES[[kk]]
[10:34:03.132]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:03.132]                     next
[10:34:03.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:03.132]                 }
[10:34:03.132]                 if (length(args) > 0) 
[10:34:03.132]                   base::do.call(base::Sys.setenv, args = args)
[10:34:03.132]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:03.132]             }
[10:34:03.132]             else {
[10:34:03.132]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:03.132]             }
[10:34:03.132]             {
[10:34:03.132]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:03.132]                   0L) {
[10:34:03.132]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:03.132]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:03.132]                   base::options(opts)
[10:34:03.132]                 }
[10:34:03.132]                 {
[10:34:03.132]                   {
[10:34:03.132]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:03.132]                     NULL
[10:34:03.132]                   }
[10:34:03.132]                   options(future.plan = NULL)
[10:34:03.132]                   if (is.na(NA_character_)) 
[10:34:03.132]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:03.132]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:03.132]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:03.132]                     .init = FALSE)
[10:34:03.132]                 }
[10:34:03.132]             }
[10:34:03.132]         }
[10:34:03.132]     })
[10:34:03.132]     if (TRUE) {
[10:34:03.132]         base::sink(type = "output", split = FALSE)
[10:34:03.132]         if (TRUE) {
[10:34:03.132]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:03.132]         }
[10:34:03.132]         else {
[10:34:03.132]             ...future.result["stdout"] <- base::list(NULL)
[10:34:03.132]         }
[10:34:03.132]         base::close(...future.stdout)
[10:34:03.132]         ...future.stdout <- NULL
[10:34:03.132]     }
[10:34:03.132]     ...future.result$conditions <- ...future.conditions
[10:34:03.132]     ...future.result$finished <- base::Sys.time()
[10:34:03.132]     ...future.result
[10:34:03.132] }
[10:34:03.135] MultisessionFuture started
[10:34:03.135] - Launch lazy future ... done
[10:34:03.135] run() for ‘MultisessionFuture’ ... done
[10:34:03.638] receiveMessageFromWorker() for ClusterFuture ...
[10:34:03.638] - Validating connection of MultisessionFuture
[10:34:03.638] - received message: FutureResult
[10:34:03.638] - Received FutureResult
[10:34:03.638] - Erased future from FutureRegistry
[10:34:03.639] result() for ClusterFuture ...
[10:34:03.639] - result already collected: FutureResult
[10:34:03.639] result() for ClusterFuture ... done
[10:34:03.639] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:03.639] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[10:34:03.639] getGlobalsAndPackages() ...
[10:34:03.639] Searching for globals...
[10:34:03.640] - globals found: [2] ‘list’, ‘stop’
[10:34:03.640] Searching for globals ... DONE
[10:34:03.640] Resolving globals: FALSE
[10:34:03.641] 
[10:34:03.641] 
[10:34:03.641] getGlobalsAndPackages() ... DONE
[10:34:03.641] run() for ‘Future’ ...
[10:34:03.642] - state: ‘created’
[10:34:03.642] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:03.658] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:03.658] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:03.658]   - Field: ‘node’
[10:34:03.658]   - Field: ‘label’
[10:34:03.659]   - Field: ‘local’
[10:34:03.659]   - Field: ‘owner’
[10:34:03.659]   - Field: ‘envir’
[10:34:03.659]   - Field: ‘workers’
[10:34:03.659]   - Field: ‘packages’
[10:34:03.659]   - Field: ‘gc’
[10:34:03.659]   - Field: ‘conditions’
[10:34:03.659]   - Field: ‘persistent’
[10:34:03.659]   - Field: ‘expr’
[10:34:03.659]   - Field: ‘uuid’
[10:34:03.659]   - Field: ‘seed’
[10:34:03.660]   - Field: ‘version’
[10:34:03.660]   - Field: ‘result’
[10:34:03.660]   - Field: ‘asynchronous’
[10:34:03.660]   - Field: ‘calls’
[10:34:03.660]   - Field: ‘globals’
[10:34:03.660]   - Field: ‘stdout’
[10:34:03.660]   - Field: ‘earlySignal’
[10:34:03.660]   - Field: ‘lazy’
[10:34:03.660]   - Field: ‘state’
[10:34:03.660] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:03.660] - Launch lazy future ...
[10:34:03.661] Packages needed by the future expression (n = 0): <none>
[10:34:03.661] Packages needed by future strategies (n = 0): <none>
[10:34:03.661] {
[10:34:03.661]     {
[10:34:03.661]         {
[10:34:03.661]             ...future.startTime <- base::Sys.time()
[10:34:03.661]             {
[10:34:03.661]                 {
[10:34:03.661]                   {
[10:34:03.661]                     {
[10:34:03.661]                       base::local({
[10:34:03.661]                         has_future <- base::requireNamespace("future", 
[10:34:03.661]                           quietly = TRUE)
[10:34:03.661]                         if (has_future) {
[10:34:03.661]                           ns <- base::getNamespace("future")
[10:34:03.661]                           version <- ns[[".package"]][["version"]]
[10:34:03.661]                           if (is.null(version)) 
[10:34:03.661]                             version <- utils::packageVersion("future")
[10:34:03.661]                         }
[10:34:03.661]                         else {
[10:34:03.661]                           version <- NULL
[10:34:03.661]                         }
[10:34:03.661]                         if (!has_future || version < "1.8.0") {
[10:34:03.661]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:03.661]                             "", base::R.version$version.string), 
[10:34:03.661]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:03.661]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:03.661]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:03.661]                               "release", "version")], collapse = " "), 
[10:34:03.661]                             hostname = base::Sys.info()[["nodename"]])
[10:34:03.661]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:03.661]                             info)
[10:34:03.661]                           info <- base::paste(info, collapse = "; ")
[10:34:03.661]                           if (!has_future) {
[10:34:03.661]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:03.661]                               info)
[10:34:03.661]                           }
[10:34:03.661]                           else {
[10:34:03.661]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:03.661]                               info, version)
[10:34:03.661]                           }
[10:34:03.661]                           base::stop(msg)
[10:34:03.661]                         }
[10:34:03.661]                       })
[10:34:03.661]                     }
[10:34:03.661]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:03.661]                     base::options(mc.cores = 1L)
[10:34:03.661]                   }
[10:34:03.661]                   ...future.strategy.old <- future::plan("list")
[10:34:03.661]                   options(future.plan = NULL)
[10:34:03.661]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:03.661]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:03.661]                 }
[10:34:03.661]                 ...future.workdir <- getwd()
[10:34:03.661]             }
[10:34:03.661]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:03.661]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:03.661]         }
[10:34:03.661]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:03.661]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:03.661]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:03.661]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:03.661]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:03.661]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:03.661]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:03.661]             base::names(...future.oldOptions))
[10:34:03.661]     }
[10:34:03.661]     if (FALSE) {
[10:34:03.661]     }
[10:34:03.661]     else {
[10:34:03.661]         if (TRUE) {
[10:34:03.661]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:03.661]                 open = "w")
[10:34:03.661]         }
[10:34:03.661]         else {
[10:34:03.661]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:03.661]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:03.661]         }
[10:34:03.661]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:03.661]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:03.661]             base::sink(type = "output", split = FALSE)
[10:34:03.661]             base::close(...future.stdout)
[10:34:03.661]         }, add = TRUE)
[10:34:03.661]     }
[10:34:03.661]     ...future.frame <- base::sys.nframe()
[10:34:03.661]     ...future.conditions <- base::list()
[10:34:03.661]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:03.661]     if (FALSE) {
[10:34:03.661]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:03.661]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:03.661]     }
[10:34:03.661]     ...future.result <- base::tryCatch({
[10:34:03.661]         base::withCallingHandlers({
[10:34:03.661]             ...future.value <- base::withVisible(base::local({
[10:34:03.661]                 ...future.makeSendCondition <- base::local({
[10:34:03.661]                   sendCondition <- NULL
[10:34:03.661]                   function(frame = 1L) {
[10:34:03.661]                     if (is.function(sendCondition)) 
[10:34:03.661]                       return(sendCondition)
[10:34:03.661]                     ns <- getNamespace("parallel")
[10:34:03.661]                     if (exists("sendData", mode = "function", 
[10:34:03.661]                       envir = ns)) {
[10:34:03.661]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:03.661]                         envir = ns)
[10:34:03.661]                       envir <- sys.frame(frame)
[10:34:03.661]                       master <- NULL
[10:34:03.661]                       while (!identical(envir, .GlobalEnv) && 
[10:34:03.661]                         !identical(envir, emptyenv())) {
[10:34:03.661]                         if (exists("master", mode = "list", envir = envir, 
[10:34:03.661]                           inherits = FALSE)) {
[10:34:03.661]                           master <- get("master", mode = "list", 
[10:34:03.661]                             envir = envir, inherits = FALSE)
[10:34:03.661]                           if (inherits(master, c("SOCKnode", 
[10:34:03.661]                             "SOCK0node"))) {
[10:34:03.661]                             sendCondition <<- function(cond) {
[10:34:03.661]                               data <- list(type = "VALUE", value = cond, 
[10:34:03.661]                                 success = TRUE)
[10:34:03.661]                               parallel_sendData(master, data)
[10:34:03.661]                             }
[10:34:03.661]                             return(sendCondition)
[10:34:03.661]                           }
[10:34:03.661]                         }
[10:34:03.661]                         frame <- frame + 1L
[10:34:03.661]                         envir <- sys.frame(frame)
[10:34:03.661]                       }
[10:34:03.661]                     }
[10:34:03.661]                     sendCondition <<- function(cond) NULL
[10:34:03.661]                   }
[10:34:03.661]                 })
[10:34:03.661]                 withCallingHandlers({
[10:34:03.661]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:34:03.661]                 }, immediateCondition = function(cond) {
[10:34:03.661]                   sendCondition <- ...future.makeSendCondition()
[10:34:03.661]                   sendCondition(cond)
[10:34:03.661]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:03.661]                   {
[10:34:03.661]                     inherits <- base::inherits
[10:34:03.661]                     invokeRestart <- base::invokeRestart
[10:34:03.661]                     is.null <- base::is.null
[10:34:03.661]                     muffled <- FALSE
[10:34:03.661]                     if (inherits(cond, "message")) {
[10:34:03.661]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:03.661]                       if (muffled) 
[10:34:03.661]                         invokeRestart("muffleMessage")
[10:34:03.661]                     }
[10:34:03.661]                     else if (inherits(cond, "warning")) {
[10:34:03.661]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:03.661]                       if (muffled) 
[10:34:03.661]                         invokeRestart("muffleWarning")
[10:34:03.661]                     }
[10:34:03.661]                     else if (inherits(cond, "condition")) {
[10:34:03.661]                       if (!is.null(pattern)) {
[10:34:03.661]                         computeRestarts <- base::computeRestarts
[10:34:03.661]                         grepl <- base::grepl
[10:34:03.661]                         restarts <- computeRestarts(cond)
[10:34:03.661]                         for (restart in restarts) {
[10:34:03.661]                           name <- restart$name
[10:34:03.661]                           if (is.null(name)) 
[10:34:03.661]                             next
[10:34:03.661]                           if (!grepl(pattern, name)) 
[10:34:03.661]                             next
[10:34:03.661]                           invokeRestart(restart)
[10:34:03.661]                           muffled <- TRUE
[10:34:03.661]                           break
[10:34:03.661]                         }
[10:34:03.661]                       }
[10:34:03.661]                     }
[10:34:03.661]                     invisible(muffled)
[10:34:03.661]                   }
[10:34:03.661]                   muffleCondition(cond)
[10:34:03.661]                 })
[10:34:03.661]             }))
[10:34:03.661]             future::FutureResult(value = ...future.value$value, 
[10:34:03.661]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:03.661]                   ...future.rng), globalenv = if (FALSE) 
[10:34:03.661]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:03.661]                     ...future.globalenv.names))
[10:34:03.661]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:03.661]         }, condition = base::local({
[10:34:03.661]             c <- base::c
[10:34:03.661]             inherits <- base::inherits
[10:34:03.661]             invokeRestart <- base::invokeRestart
[10:34:03.661]             length <- base::length
[10:34:03.661]             list <- base::list
[10:34:03.661]             seq.int <- base::seq.int
[10:34:03.661]             signalCondition <- base::signalCondition
[10:34:03.661]             sys.calls <- base::sys.calls
[10:34:03.661]             `[[` <- base::`[[`
[10:34:03.661]             `+` <- base::`+`
[10:34:03.661]             `<<-` <- base::`<<-`
[10:34:03.661]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:03.661]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:03.661]                   3L)]
[10:34:03.661]             }
[10:34:03.661]             function(cond) {
[10:34:03.661]                 is_error <- inherits(cond, "error")
[10:34:03.661]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:03.661]                   NULL)
[10:34:03.661]                 if (is_error) {
[10:34:03.661]                   sessionInformation <- function() {
[10:34:03.661]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:03.661]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:03.661]                       search = base::search(), system = base::Sys.info())
[10:34:03.661]                   }
[10:34:03.661]                   ...future.conditions[[length(...future.conditions) + 
[10:34:03.661]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:03.661]                     cond$call), session = sessionInformation(), 
[10:34:03.661]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:03.661]                   signalCondition(cond)
[10:34:03.661]                 }
[10:34:03.661]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:03.661]                 "immediateCondition"))) {
[10:34:03.661]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:03.661]                   ...future.conditions[[length(...future.conditions) + 
[10:34:03.661]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:03.661]                   if (TRUE && !signal) {
[10:34:03.661]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:03.661]                     {
[10:34:03.661]                       inherits <- base::inherits
[10:34:03.661]                       invokeRestart <- base::invokeRestart
[10:34:03.661]                       is.null <- base::is.null
[10:34:03.661]                       muffled <- FALSE
[10:34:03.661]                       if (inherits(cond, "message")) {
[10:34:03.661]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:03.661]                         if (muffled) 
[10:34:03.661]                           invokeRestart("muffleMessage")
[10:34:03.661]                       }
[10:34:03.661]                       else if (inherits(cond, "warning")) {
[10:34:03.661]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:03.661]                         if (muffled) 
[10:34:03.661]                           invokeRestart("muffleWarning")
[10:34:03.661]                       }
[10:34:03.661]                       else if (inherits(cond, "condition")) {
[10:34:03.661]                         if (!is.null(pattern)) {
[10:34:03.661]                           computeRestarts <- base::computeRestarts
[10:34:03.661]                           grepl <- base::grepl
[10:34:03.661]                           restarts <- computeRestarts(cond)
[10:34:03.661]                           for (restart in restarts) {
[10:34:03.661]                             name <- restart$name
[10:34:03.661]                             if (is.null(name)) 
[10:34:03.661]                               next
[10:34:03.661]                             if (!grepl(pattern, name)) 
[10:34:03.661]                               next
[10:34:03.661]                             invokeRestart(restart)
[10:34:03.661]                             muffled <- TRUE
[10:34:03.661]                             break
[10:34:03.661]                           }
[10:34:03.661]                         }
[10:34:03.661]                       }
[10:34:03.661]                       invisible(muffled)
[10:34:03.661]                     }
[10:34:03.661]                     muffleCondition(cond, pattern = "^muffle")
[10:34:03.661]                   }
[10:34:03.661]                 }
[10:34:03.661]                 else {
[10:34:03.661]                   if (TRUE) {
[10:34:03.661]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:03.661]                     {
[10:34:03.661]                       inherits <- base::inherits
[10:34:03.661]                       invokeRestart <- base::invokeRestart
[10:34:03.661]                       is.null <- base::is.null
[10:34:03.661]                       muffled <- FALSE
[10:34:03.661]                       if (inherits(cond, "message")) {
[10:34:03.661]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:03.661]                         if (muffled) 
[10:34:03.661]                           invokeRestart("muffleMessage")
[10:34:03.661]                       }
[10:34:03.661]                       else if (inherits(cond, "warning")) {
[10:34:03.661]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:03.661]                         if (muffled) 
[10:34:03.661]                           invokeRestart("muffleWarning")
[10:34:03.661]                       }
[10:34:03.661]                       else if (inherits(cond, "condition")) {
[10:34:03.661]                         if (!is.null(pattern)) {
[10:34:03.661]                           computeRestarts <- base::computeRestarts
[10:34:03.661]                           grepl <- base::grepl
[10:34:03.661]                           restarts <- computeRestarts(cond)
[10:34:03.661]                           for (restart in restarts) {
[10:34:03.661]                             name <- restart$name
[10:34:03.661]                             if (is.null(name)) 
[10:34:03.661]                               next
[10:34:03.661]                             if (!grepl(pattern, name)) 
[10:34:03.661]                               next
[10:34:03.661]                             invokeRestart(restart)
[10:34:03.661]                             muffled <- TRUE
[10:34:03.661]                             break
[10:34:03.661]                           }
[10:34:03.661]                         }
[10:34:03.661]                       }
[10:34:03.661]                       invisible(muffled)
[10:34:03.661]                     }
[10:34:03.661]                     muffleCondition(cond, pattern = "^muffle")
[10:34:03.661]                   }
[10:34:03.661]                 }
[10:34:03.661]             }
[10:34:03.661]         }))
[10:34:03.661]     }, error = function(ex) {
[10:34:03.661]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:03.661]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:03.661]                 ...future.rng), started = ...future.startTime, 
[10:34:03.661]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:03.661]             version = "1.8"), class = "FutureResult")
[10:34:03.661]     }, finally = {
[10:34:03.661]         if (!identical(...future.workdir, getwd())) 
[10:34:03.661]             setwd(...future.workdir)
[10:34:03.661]         {
[10:34:03.661]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:03.661]                 ...future.oldOptions$nwarnings <- NULL
[10:34:03.661]             }
[10:34:03.661]             base::options(...future.oldOptions)
[10:34:03.661]             if (.Platform$OS.type == "windows") {
[10:34:03.661]                 old_names <- names(...future.oldEnvVars)
[10:34:03.661]                 envs <- base::Sys.getenv()
[10:34:03.661]                 names <- names(envs)
[10:34:03.661]                 common <- intersect(names, old_names)
[10:34:03.661]                 added <- setdiff(names, old_names)
[10:34:03.661]                 removed <- setdiff(old_names, names)
[10:34:03.661]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:03.661]                   envs[common]]
[10:34:03.661]                 NAMES <- toupper(changed)
[10:34:03.661]                 args <- list()
[10:34:03.661]                 for (kk in seq_along(NAMES)) {
[10:34:03.661]                   name <- changed[[kk]]
[10:34:03.661]                   NAME <- NAMES[[kk]]
[10:34:03.661]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:03.661]                     next
[10:34:03.661]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:03.661]                 }
[10:34:03.661]                 NAMES <- toupper(added)
[10:34:03.661]                 for (kk in seq_along(NAMES)) {
[10:34:03.661]                   name <- added[[kk]]
[10:34:03.661]                   NAME <- NAMES[[kk]]
[10:34:03.661]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:03.661]                     next
[10:34:03.661]                   args[[name]] <- ""
[10:34:03.661]                 }
[10:34:03.661]                 NAMES <- toupper(removed)
[10:34:03.661]                 for (kk in seq_along(NAMES)) {
[10:34:03.661]                   name <- removed[[kk]]
[10:34:03.661]                   NAME <- NAMES[[kk]]
[10:34:03.661]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:03.661]                     next
[10:34:03.661]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:03.661]                 }
[10:34:03.661]                 if (length(args) > 0) 
[10:34:03.661]                   base::do.call(base::Sys.setenv, args = args)
[10:34:03.661]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:03.661]             }
[10:34:03.661]             else {
[10:34:03.661]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:03.661]             }
[10:34:03.661]             {
[10:34:03.661]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:03.661]                   0L) {
[10:34:03.661]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:03.661]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:03.661]                   base::options(opts)
[10:34:03.661]                 }
[10:34:03.661]                 {
[10:34:03.661]                   {
[10:34:03.661]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:03.661]                     NULL
[10:34:03.661]                   }
[10:34:03.661]                   options(future.plan = NULL)
[10:34:03.661]                   if (is.na(NA_character_)) 
[10:34:03.661]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:03.661]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:03.661]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:03.661]                     .init = FALSE)
[10:34:03.661]                 }
[10:34:03.661]             }
[10:34:03.661]         }
[10:34:03.661]     })
[10:34:03.661]     if (TRUE) {
[10:34:03.661]         base::sink(type = "output", split = FALSE)
[10:34:03.661]         if (TRUE) {
[10:34:03.661]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:03.661]         }
[10:34:03.661]         else {
[10:34:03.661]             ...future.result["stdout"] <- base::list(NULL)
[10:34:03.661]         }
[10:34:03.661]         base::close(...future.stdout)
[10:34:03.661]         ...future.stdout <- NULL
[10:34:03.661]     }
[10:34:03.661]     ...future.result$conditions <- ...future.conditions
[10:34:03.661]     ...future.result$finished <- base::Sys.time()
[10:34:03.661]     ...future.result
[10:34:03.661] }
[10:34:03.664] MultisessionFuture started
[10:34:03.664] - Launch lazy future ... done
[10:34:03.664] run() for ‘MultisessionFuture’ ... done
[10:34:03.666] receiveMessageFromWorker() for ClusterFuture ...
[10:34:03.666] - Validating connection of MultisessionFuture
[10:34:03.667] - received message: FutureResult
[10:34:03.667] - Received FutureResult
[10:34:03.667] - Erased future from FutureRegistry
[10:34:03.667] result() for ClusterFuture ...
[10:34:03.667] - result already collected: FutureResult
[10:34:03.667] result() for ClusterFuture ... done
[10:34:03.667] signalConditions() ...
[10:34:03.668]  - include = ‘immediateCondition’
[10:34:03.668]  - exclude = 
[10:34:03.668]  - resignal = FALSE
[10:34:03.668]  - Number of conditions: 1
[10:34:03.668] signalConditions() ... done
[10:34:03.668] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:03.668] A MultisessionFuture was resolved (result was not collected)
[10:34:03.668] getGlobalsAndPackages() ...
[10:34:03.668] Searching for globals...
[10:34:03.669] - globals found: [2] ‘list’, ‘stop’
[10:34:03.669] Searching for globals ... DONE
[10:34:03.669] Resolving globals: FALSE
[10:34:03.669] 
[10:34:03.670] 
[10:34:03.670] getGlobalsAndPackages() ... DONE
[10:34:03.670] run() for ‘Future’ ...
[10:34:03.670] - state: ‘created’
[10:34:03.670] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:03.683] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:03.683] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:03.683]   - Field: ‘node’
[10:34:03.684]   - Field: ‘label’
[10:34:03.684]   - Field: ‘local’
[10:34:03.684]   - Field: ‘owner’
[10:34:03.684]   - Field: ‘envir’
[10:34:03.684]   - Field: ‘workers’
[10:34:03.684]   - Field: ‘packages’
[10:34:03.684]   - Field: ‘gc’
[10:34:03.684]   - Field: ‘conditions’
[10:34:03.684]   - Field: ‘persistent’
[10:34:03.684]   - Field: ‘expr’
[10:34:03.684]   - Field: ‘uuid’
[10:34:03.685]   - Field: ‘seed’
[10:34:03.685]   - Field: ‘version’
[10:34:03.685]   - Field: ‘result’
[10:34:03.685]   - Field: ‘asynchronous’
[10:34:03.685]   - Field: ‘calls’
[10:34:03.685]   - Field: ‘globals’
[10:34:03.685]   - Field: ‘stdout’
[10:34:03.685]   - Field: ‘earlySignal’
[10:34:03.685]   - Field: ‘lazy’
[10:34:03.685]   - Field: ‘state’
[10:34:03.685] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:03.686] - Launch lazy future ...
[10:34:03.686] Packages needed by the future expression (n = 0): <none>
[10:34:03.686] Packages needed by future strategies (n = 0): <none>
[10:34:03.686] {
[10:34:03.686]     {
[10:34:03.686]         {
[10:34:03.686]             ...future.startTime <- base::Sys.time()
[10:34:03.686]             {
[10:34:03.686]                 {
[10:34:03.686]                   {
[10:34:03.686]                     {
[10:34:03.686]                       base::local({
[10:34:03.686]                         has_future <- base::requireNamespace("future", 
[10:34:03.686]                           quietly = TRUE)
[10:34:03.686]                         if (has_future) {
[10:34:03.686]                           ns <- base::getNamespace("future")
[10:34:03.686]                           version <- ns[[".package"]][["version"]]
[10:34:03.686]                           if (is.null(version)) 
[10:34:03.686]                             version <- utils::packageVersion("future")
[10:34:03.686]                         }
[10:34:03.686]                         else {
[10:34:03.686]                           version <- NULL
[10:34:03.686]                         }
[10:34:03.686]                         if (!has_future || version < "1.8.0") {
[10:34:03.686]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:03.686]                             "", base::R.version$version.string), 
[10:34:03.686]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:03.686]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:03.686]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:03.686]                               "release", "version")], collapse = " "), 
[10:34:03.686]                             hostname = base::Sys.info()[["nodename"]])
[10:34:03.686]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:03.686]                             info)
[10:34:03.686]                           info <- base::paste(info, collapse = "; ")
[10:34:03.686]                           if (!has_future) {
[10:34:03.686]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:03.686]                               info)
[10:34:03.686]                           }
[10:34:03.686]                           else {
[10:34:03.686]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:03.686]                               info, version)
[10:34:03.686]                           }
[10:34:03.686]                           base::stop(msg)
[10:34:03.686]                         }
[10:34:03.686]                       })
[10:34:03.686]                     }
[10:34:03.686]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:03.686]                     base::options(mc.cores = 1L)
[10:34:03.686]                   }
[10:34:03.686]                   ...future.strategy.old <- future::plan("list")
[10:34:03.686]                   options(future.plan = NULL)
[10:34:03.686]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:03.686]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:03.686]                 }
[10:34:03.686]                 ...future.workdir <- getwd()
[10:34:03.686]             }
[10:34:03.686]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:03.686]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:03.686]         }
[10:34:03.686]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:03.686]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:03.686]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:03.686]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:03.686]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:03.686]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:03.686]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:03.686]             base::names(...future.oldOptions))
[10:34:03.686]     }
[10:34:03.686]     if (FALSE) {
[10:34:03.686]     }
[10:34:03.686]     else {
[10:34:03.686]         if (TRUE) {
[10:34:03.686]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:03.686]                 open = "w")
[10:34:03.686]         }
[10:34:03.686]         else {
[10:34:03.686]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:03.686]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:03.686]         }
[10:34:03.686]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:03.686]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:03.686]             base::sink(type = "output", split = FALSE)
[10:34:03.686]             base::close(...future.stdout)
[10:34:03.686]         }, add = TRUE)
[10:34:03.686]     }
[10:34:03.686]     ...future.frame <- base::sys.nframe()
[10:34:03.686]     ...future.conditions <- base::list()
[10:34:03.686]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:03.686]     if (FALSE) {
[10:34:03.686]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:03.686]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:03.686]     }
[10:34:03.686]     ...future.result <- base::tryCatch({
[10:34:03.686]         base::withCallingHandlers({
[10:34:03.686]             ...future.value <- base::withVisible(base::local({
[10:34:03.686]                 ...future.makeSendCondition <- base::local({
[10:34:03.686]                   sendCondition <- NULL
[10:34:03.686]                   function(frame = 1L) {
[10:34:03.686]                     if (is.function(sendCondition)) 
[10:34:03.686]                       return(sendCondition)
[10:34:03.686]                     ns <- getNamespace("parallel")
[10:34:03.686]                     if (exists("sendData", mode = "function", 
[10:34:03.686]                       envir = ns)) {
[10:34:03.686]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:03.686]                         envir = ns)
[10:34:03.686]                       envir <- sys.frame(frame)
[10:34:03.686]                       master <- NULL
[10:34:03.686]                       while (!identical(envir, .GlobalEnv) && 
[10:34:03.686]                         !identical(envir, emptyenv())) {
[10:34:03.686]                         if (exists("master", mode = "list", envir = envir, 
[10:34:03.686]                           inherits = FALSE)) {
[10:34:03.686]                           master <- get("master", mode = "list", 
[10:34:03.686]                             envir = envir, inherits = FALSE)
[10:34:03.686]                           if (inherits(master, c("SOCKnode", 
[10:34:03.686]                             "SOCK0node"))) {
[10:34:03.686]                             sendCondition <<- function(cond) {
[10:34:03.686]                               data <- list(type = "VALUE", value = cond, 
[10:34:03.686]                                 success = TRUE)
[10:34:03.686]                               parallel_sendData(master, data)
[10:34:03.686]                             }
[10:34:03.686]                             return(sendCondition)
[10:34:03.686]                           }
[10:34:03.686]                         }
[10:34:03.686]                         frame <- frame + 1L
[10:34:03.686]                         envir <- sys.frame(frame)
[10:34:03.686]                       }
[10:34:03.686]                     }
[10:34:03.686]                     sendCondition <<- function(cond) NULL
[10:34:03.686]                   }
[10:34:03.686]                 })
[10:34:03.686]                 withCallingHandlers({
[10:34:03.686]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:34:03.686]                 }, immediateCondition = function(cond) {
[10:34:03.686]                   sendCondition <- ...future.makeSendCondition()
[10:34:03.686]                   sendCondition(cond)
[10:34:03.686]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:03.686]                   {
[10:34:03.686]                     inherits <- base::inherits
[10:34:03.686]                     invokeRestart <- base::invokeRestart
[10:34:03.686]                     is.null <- base::is.null
[10:34:03.686]                     muffled <- FALSE
[10:34:03.686]                     if (inherits(cond, "message")) {
[10:34:03.686]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:03.686]                       if (muffled) 
[10:34:03.686]                         invokeRestart("muffleMessage")
[10:34:03.686]                     }
[10:34:03.686]                     else if (inherits(cond, "warning")) {
[10:34:03.686]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:03.686]                       if (muffled) 
[10:34:03.686]                         invokeRestart("muffleWarning")
[10:34:03.686]                     }
[10:34:03.686]                     else if (inherits(cond, "condition")) {
[10:34:03.686]                       if (!is.null(pattern)) {
[10:34:03.686]                         computeRestarts <- base::computeRestarts
[10:34:03.686]                         grepl <- base::grepl
[10:34:03.686]                         restarts <- computeRestarts(cond)
[10:34:03.686]                         for (restart in restarts) {
[10:34:03.686]                           name <- restart$name
[10:34:03.686]                           if (is.null(name)) 
[10:34:03.686]                             next
[10:34:03.686]                           if (!grepl(pattern, name)) 
[10:34:03.686]                             next
[10:34:03.686]                           invokeRestart(restart)
[10:34:03.686]                           muffled <- TRUE
[10:34:03.686]                           break
[10:34:03.686]                         }
[10:34:03.686]                       }
[10:34:03.686]                     }
[10:34:03.686]                     invisible(muffled)
[10:34:03.686]                   }
[10:34:03.686]                   muffleCondition(cond)
[10:34:03.686]                 })
[10:34:03.686]             }))
[10:34:03.686]             future::FutureResult(value = ...future.value$value, 
[10:34:03.686]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:03.686]                   ...future.rng), globalenv = if (FALSE) 
[10:34:03.686]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:03.686]                     ...future.globalenv.names))
[10:34:03.686]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:03.686]         }, condition = base::local({
[10:34:03.686]             c <- base::c
[10:34:03.686]             inherits <- base::inherits
[10:34:03.686]             invokeRestart <- base::invokeRestart
[10:34:03.686]             length <- base::length
[10:34:03.686]             list <- base::list
[10:34:03.686]             seq.int <- base::seq.int
[10:34:03.686]             signalCondition <- base::signalCondition
[10:34:03.686]             sys.calls <- base::sys.calls
[10:34:03.686]             `[[` <- base::`[[`
[10:34:03.686]             `+` <- base::`+`
[10:34:03.686]             `<<-` <- base::`<<-`
[10:34:03.686]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:03.686]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:03.686]                   3L)]
[10:34:03.686]             }
[10:34:03.686]             function(cond) {
[10:34:03.686]                 is_error <- inherits(cond, "error")
[10:34:03.686]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:03.686]                   NULL)
[10:34:03.686]                 if (is_error) {
[10:34:03.686]                   sessionInformation <- function() {
[10:34:03.686]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:03.686]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:03.686]                       search = base::search(), system = base::Sys.info())
[10:34:03.686]                   }
[10:34:03.686]                   ...future.conditions[[length(...future.conditions) + 
[10:34:03.686]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:03.686]                     cond$call), session = sessionInformation(), 
[10:34:03.686]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:03.686]                   signalCondition(cond)
[10:34:03.686]                 }
[10:34:03.686]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:03.686]                 "immediateCondition"))) {
[10:34:03.686]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:03.686]                   ...future.conditions[[length(...future.conditions) + 
[10:34:03.686]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:03.686]                   if (TRUE && !signal) {
[10:34:03.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:03.686]                     {
[10:34:03.686]                       inherits <- base::inherits
[10:34:03.686]                       invokeRestart <- base::invokeRestart
[10:34:03.686]                       is.null <- base::is.null
[10:34:03.686]                       muffled <- FALSE
[10:34:03.686]                       if (inherits(cond, "message")) {
[10:34:03.686]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:03.686]                         if (muffled) 
[10:34:03.686]                           invokeRestart("muffleMessage")
[10:34:03.686]                       }
[10:34:03.686]                       else if (inherits(cond, "warning")) {
[10:34:03.686]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:03.686]                         if (muffled) 
[10:34:03.686]                           invokeRestart("muffleWarning")
[10:34:03.686]                       }
[10:34:03.686]                       else if (inherits(cond, "condition")) {
[10:34:03.686]                         if (!is.null(pattern)) {
[10:34:03.686]                           computeRestarts <- base::computeRestarts
[10:34:03.686]                           grepl <- base::grepl
[10:34:03.686]                           restarts <- computeRestarts(cond)
[10:34:03.686]                           for (restart in restarts) {
[10:34:03.686]                             name <- restart$name
[10:34:03.686]                             if (is.null(name)) 
[10:34:03.686]                               next
[10:34:03.686]                             if (!grepl(pattern, name)) 
[10:34:03.686]                               next
[10:34:03.686]                             invokeRestart(restart)
[10:34:03.686]                             muffled <- TRUE
[10:34:03.686]                             break
[10:34:03.686]                           }
[10:34:03.686]                         }
[10:34:03.686]                       }
[10:34:03.686]                       invisible(muffled)
[10:34:03.686]                     }
[10:34:03.686]                     muffleCondition(cond, pattern = "^muffle")
[10:34:03.686]                   }
[10:34:03.686]                 }
[10:34:03.686]                 else {
[10:34:03.686]                   if (TRUE) {
[10:34:03.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:03.686]                     {
[10:34:03.686]                       inherits <- base::inherits
[10:34:03.686]                       invokeRestart <- base::invokeRestart
[10:34:03.686]                       is.null <- base::is.null
[10:34:03.686]                       muffled <- FALSE
[10:34:03.686]                       if (inherits(cond, "message")) {
[10:34:03.686]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:03.686]                         if (muffled) 
[10:34:03.686]                           invokeRestart("muffleMessage")
[10:34:03.686]                       }
[10:34:03.686]                       else if (inherits(cond, "warning")) {
[10:34:03.686]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:03.686]                         if (muffled) 
[10:34:03.686]                           invokeRestart("muffleWarning")
[10:34:03.686]                       }
[10:34:03.686]                       else if (inherits(cond, "condition")) {
[10:34:03.686]                         if (!is.null(pattern)) {
[10:34:03.686]                           computeRestarts <- base::computeRestarts
[10:34:03.686]                           grepl <- base::grepl
[10:34:03.686]                           restarts <- computeRestarts(cond)
[10:34:03.686]                           for (restart in restarts) {
[10:34:03.686]                             name <- restart$name
[10:34:03.686]                             if (is.null(name)) 
[10:34:03.686]                               next
[10:34:03.686]                             if (!grepl(pattern, name)) 
[10:34:03.686]                               next
[10:34:03.686]                             invokeRestart(restart)
[10:34:03.686]                             muffled <- TRUE
[10:34:03.686]                             break
[10:34:03.686]                           }
[10:34:03.686]                         }
[10:34:03.686]                       }
[10:34:03.686]                       invisible(muffled)
[10:34:03.686]                     }
[10:34:03.686]                     muffleCondition(cond, pattern = "^muffle")
[10:34:03.686]                   }
[10:34:03.686]                 }
[10:34:03.686]             }
[10:34:03.686]         }))
[10:34:03.686]     }, error = function(ex) {
[10:34:03.686]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:03.686]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:03.686]                 ...future.rng), started = ...future.startTime, 
[10:34:03.686]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:03.686]             version = "1.8"), class = "FutureResult")
[10:34:03.686]     }, finally = {
[10:34:03.686]         if (!identical(...future.workdir, getwd())) 
[10:34:03.686]             setwd(...future.workdir)
[10:34:03.686]         {
[10:34:03.686]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:03.686]                 ...future.oldOptions$nwarnings <- NULL
[10:34:03.686]             }
[10:34:03.686]             base::options(...future.oldOptions)
[10:34:03.686]             if (.Platform$OS.type == "windows") {
[10:34:03.686]                 old_names <- names(...future.oldEnvVars)
[10:34:03.686]                 envs <- base::Sys.getenv()
[10:34:03.686]                 names <- names(envs)
[10:34:03.686]                 common <- intersect(names, old_names)
[10:34:03.686]                 added <- setdiff(names, old_names)
[10:34:03.686]                 removed <- setdiff(old_names, names)
[10:34:03.686]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:03.686]                   envs[common]]
[10:34:03.686]                 NAMES <- toupper(changed)
[10:34:03.686]                 args <- list()
[10:34:03.686]                 for (kk in seq_along(NAMES)) {
[10:34:03.686]                   name <- changed[[kk]]
[10:34:03.686]                   NAME <- NAMES[[kk]]
[10:34:03.686]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:03.686]                     next
[10:34:03.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:03.686]                 }
[10:34:03.686]                 NAMES <- toupper(added)
[10:34:03.686]                 for (kk in seq_along(NAMES)) {
[10:34:03.686]                   name <- added[[kk]]
[10:34:03.686]                   NAME <- NAMES[[kk]]
[10:34:03.686]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:03.686]                     next
[10:34:03.686]                   args[[name]] <- ""
[10:34:03.686]                 }
[10:34:03.686]                 NAMES <- toupper(removed)
[10:34:03.686]                 for (kk in seq_along(NAMES)) {
[10:34:03.686]                   name <- removed[[kk]]
[10:34:03.686]                   NAME <- NAMES[[kk]]
[10:34:03.686]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:03.686]                     next
[10:34:03.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:03.686]                 }
[10:34:03.686]                 if (length(args) > 0) 
[10:34:03.686]                   base::do.call(base::Sys.setenv, args = args)
[10:34:03.686]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:03.686]             }
[10:34:03.686]             else {
[10:34:03.686]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:03.686]             }
[10:34:03.686]             {
[10:34:03.686]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:03.686]                   0L) {
[10:34:03.686]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:03.686]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:03.686]                   base::options(opts)
[10:34:03.686]                 }
[10:34:03.686]                 {
[10:34:03.686]                   {
[10:34:03.686]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:03.686]                     NULL
[10:34:03.686]                   }
[10:34:03.686]                   options(future.plan = NULL)
[10:34:03.686]                   if (is.na(NA_character_)) 
[10:34:03.686]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:03.686]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:03.686]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:03.686]                     .init = FALSE)
[10:34:03.686]                 }
[10:34:03.686]             }
[10:34:03.686]         }
[10:34:03.686]     })
[10:34:03.686]     if (TRUE) {
[10:34:03.686]         base::sink(type = "output", split = FALSE)
[10:34:03.686]         if (TRUE) {
[10:34:03.686]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:03.686]         }
[10:34:03.686]         else {
[10:34:03.686]             ...future.result["stdout"] <- base::list(NULL)
[10:34:03.686]         }
[10:34:03.686]         base::close(...future.stdout)
[10:34:03.686]         ...future.stdout <- NULL
[10:34:03.686]     }
[10:34:03.686]     ...future.result$conditions <- ...future.conditions
[10:34:03.686]     ...future.result$finished <- base::Sys.time()
[10:34:03.686]     ...future.result
[10:34:03.686] }
[10:34:03.689] MultisessionFuture started
[10:34:03.689] - Launch lazy future ... done
[10:34:03.689] run() for ‘MultisessionFuture’ ... done
[10:34:03.690] receiveMessageFromWorker() for ClusterFuture ...
[10:34:03.691] - Validating connection of MultisessionFuture
[10:34:03.691] - received message: FutureResult
[10:34:03.691] - Received FutureResult
[10:34:03.691] - Erased future from FutureRegistry
[10:34:03.691] result() for ClusterFuture ...
[10:34:03.691] - result already collected: FutureResult
[10:34:03.691] result() for ClusterFuture ... done
[10:34:03.692] signalConditions() ...
[10:34:03.692]  - include = ‘immediateCondition’
[10:34:03.692]  - exclude = 
[10:34:03.692]  - resignal = FALSE
[10:34:03.692]  - Number of conditions: 1
[10:34:03.692] signalConditions() ... done
[10:34:03.692] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:03.692] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = FALSE ... DONE
- result = FALSE, recursive = TRUE ...
[10:34:03.692] getGlobalsAndPackages() ...
[10:34:03.692] Searching for globals...
[10:34:03.694] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:34:03.694] Searching for globals ... DONE
[10:34:03.694] Resolving globals: FALSE
[10:34:03.694] 
[10:34:03.694] 
[10:34:03.694] getGlobalsAndPackages() ... DONE
[10:34:03.694] run() for ‘Future’ ...
[10:34:03.695] - state: ‘created’
[10:34:03.695] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:03.710] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:03.710] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:03.711]   - Field: ‘node’
[10:34:03.711]   - Field: ‘label’
[10:34:03.711]   - Field: ‘local’
[10:34:03.711]   - Field: ‘owner’
[10:34:03.711]   - Field: ‘envir’
[10:34:03.711]   - Field: ‘workers’
[10:34:03.711]   - Field: ‘packages’
[10:34:03.711]   - Field: ‘gc’
[10:34:03.711]   - Field: ‘conditions’
[10:34:03.711]   - Field: ‘persistent’
[10:34:03.711]   - Field: ‘expr’
[10:34:03.712]   - Field: ‘uuid’
[10:34:03.712]   - Field: ‘seed’
[10:34:03.712]   - Field: ‘version’
[10:34:03.712]   - Field: ‘result’
[10:34:03.712]   - Field: ‘asynchronous’
[10:34:03.712]   - Field: ‘calls’
[10:34:03.712]   - Field: ‘globals’
[10:34:03.712]   - Field: ‘stdout’
[10:34:03.712]   - Field: ‘earlySignal’
[10:34:03.712]   - Field: ‘lazy’
[10:34:03.713]   - Field: ‘state’
[10:34:03.713] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:03.713] - Launch lazy future ...
[10:34:03.713] Packages needed by the future expression (n = 0): <none>
[10:34:03.713] Packages needed by future strategies (n = 0): <none>
[10:34:03.713] {
[10:34:03.713]     {
[10:34:03.713]         {
[10:34:03.713]             ...future.startTime <- base::Sys.time()
[10:34:03.713]             {
[10:34:03.713]                 {
[10:34:03.713]                   {
[10:34:03.713]                     {
[10:34:03.713]                       base::local({
[10:34:03.713]                         has_future <- base::requireNamespace("future", 
[10:34:03.713]                           quietly = TRUE)
[10:34:03.713]                         if (has_future) {
[10:34:03.713]                           ns <- base::getNamespace("future")
[10:34:03.713]                           version <- ns[[".package"]][["version"]]
[10:34:03.713]                           if (is.null(version)) 
[10:34:03.713]                             version <- utils::packageVersion("future")
[10:34:03.713]                         }
[10:34:03.713]                         else {
[10:34:03.713]                           version <- NULL
[10:34:03.713]                         }
[10:34:03.713]                         if (!has_future || version < "1.8.0") {
[10:34:03.713]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:03.713]                             "", base::R.version$version.string), 
[10:34:03.713]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:03.713]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:03.713]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:03.713]                               "release", "version")], collapse = " "), 
[10:34:03.713]                             hostname = base::Sys.info()[["nodename"]])
[10:34:03.713]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:03.713]                             info)
[10:34:03.713]                           info <- base::paste(info, collapse = "; ")
[10:34:03.713]                           if (!has_future) {
[10:34:03.713]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:03.713]                               info)
[10:34:03.713]                           }
[10:34:03.713]                           else {
[10:34:03.713]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:03.713]                               info, version)
[10:34:03.713]                           }
[10:34:03.713]                           base::stop(msg)
[10:34:03.713]                         }
[10:34:03.713]                       })
[10:34:03.713]                     }
[10:34:03.713]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:03.713]                     base::options(mc.cores = 1L)
[10:34:03.713]                   }
[10:34:03.713]                   ...future.strategy.old <- future::plan("list")
[10:34:03.713]                   options(future.plan = NULL)
[10:34:03.713]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:03.713]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:03.713]                 }
[10:34:03.713]                 ...future.workdir <- getwd()
[10:34:03.713]             }
[10:34:03.713]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:03.713]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:03.713]         }
[10:34:03.713]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:03.713]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:03.713]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:03.713]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:03.713]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:03.713]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:03.713]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:03.713]             base::names(...future.oldOptions))
[10:34:03.713]     }
[10:34:03.713]     if (FALSE) {
[10:34:03.713]     }
[10:34:03.713]     else {
[10:34:03.713]         if (TRUE) {
[10:34:03.713]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:03.713]                 open = "w")
[10:34:03.713]         }
[10:34:03.713]         else {
[10:34:03.713]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:03.713]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:03.713]         }
[10:34:03.713]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:03.713]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:03.713]             base::sink(type = "output", split = FALSE)
[10:34:03.713]             base::close(...future.stdout)
[10:34:03.713]         }, add = TRUE)
[10:34:03.713]     }
[10:34:03.713]     ...future.frame <- base::sys.nframe()
[10:34:03.713]     ...future.conditions <- base::list()
[10:34:03.713]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:03.713]     if (FALSE) {
[10:34:03.713]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:03.713]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:03.713]     }
[10:34:03.713]     ...future.result <- base::tryCatch({
[10:34:03.713]         base::withCallingHandlers({
[10:34:03.713]             ...future.value <- base::withVisible(base::local({
[10:34:03.713]                 ...future.makeSendCondition <- base::local({
[10:34:03.713]                   sendCondition <- NULL
[10:34:03.713]                   function(frame = 1L) {
[10:34:03.713]                     if (is.function(sendCondition)) 
[10:34:03.713]                       return(sendCondition)
[10:34:03.713]                     ns <- getNamespace("parallel")
[10:34:03.713]                     if (exists("sendData", mode = "function", 
[10:34:03.713]                       envir = ns)) {
[10:34:03.713]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:03.713]                         envir = ns)
[10:34:03.713]                       envir <- sys.frame(frame)
[10:34:03.713]                       master <- NULL
[10:34:03.713]                       while (!identical(envir, .GlobalEnv) && 
[10:34:03.713]                         !identical(envir, emptyenv())) {
[10:34:03.713]                         if (exists("master", mode = "list", envir = envir, 
[10:34:03.713]                           inherits = FALSE)) {
[10:34:03.713]                           master <- get("master", mode = "list", 
[10:34:03.713]                             envir = envir, inherits = FALSE)
[10:34:03.713]                           if (inherits(master, c("SOCKnode", 
[10:34:03.713]                             "SOCK0node"))) {
[10:34:03.713]                             sendCondition <<- function(cond) {
[10:34:03.713]                               data <- list(type = "VALUE", value = cond, 
[10:34:03.713]                                 success = TRUE)
[10:34:03.713]                               parallel_sendData(master, data)
[10:34:03.713]                             }
[10:34:03.713]                             return(sendCondition)
[10:34:03.713]                           }
[10:34:03.713]                         }
[10:34:03.713]                         frame <- frame + 1L
[10:34:03.713]                         envir <- sys.frame(frame)
[10:34:03.713]                       }
[10:34:03.713]                     }
[10:34:03.713]                     sendCondition <<- function(cond) NULL
[10:34:03.713]                   }
[10:34:03.713]                 })
[10:34:03.713]                 withCallingHandlers({
[10:34:03.713]                   {
[10:34:03.713]                     Sys.sleep(0.5)
[10:34:03.713]                     list(a = 1, b = 42L)
[10:34:03.713]                   }
[10:34:03.713]                 }, immediateCondition = function(cond) {
[10:34:03.713]                   sendCondition <- ...future.makeSendCondition()
[10:34:03.713]                   sendCondition(cond)
[10:34:03.713]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:03.713]                   {
[10:34:03.713]                     inherits <- base::inherits
[10:34:03.713]                     invokeRestart <- base::invokeRestart
[10:34:03.713]                     is.null <- base::is.null
[10:34:03.713]                     muffled <- FALSE
[10:34:03.713]                     if (inherits(cond, "message")) {
[10:34:03.713]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:03.713]                       if (muffled) 
[10:34:03.713]                         invokeRestart("muffleMessage")
[10:34:03.713]                     }
[10:34:03.713]                     else if (inherits(cond, "warning")) {
[10:34:03.713]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:03.713]                       if (muffled) 
[10:34:03.713]                         invokeRestart("muffleWarning")
[10:34:03.713]                     }
[10:34:03.713]                     else if (inherits(cond, "condition")) {
[10:34:03.713]                       if (!is.null(pattern)) {
[10:34:03.713]                         computeRestarts <- base::computeRestarts
[10:34:03.713]                         grepl <- base::grepl
[10:34:03.713]                         restarts <- computeRestarts(cond)
[10:34:03.713]                         for (restart in restarts) {
[10:34:03.713]                           name <- restart$name
[10:34:03.713]                           if (is.null(name)) 
[10:34:03.713]                             next
[10:34:03.713]                           if (!grepl(pattern, name)) 
[10:34:03.713]                             next
[10:34:03.713]                           invokeRestart(restart)
[10:34:03.713]                           muffled <- TRUE
[10:34:03.713]                           break
[10:34:03.713]                         }
[10:34:03.713]                       }
[10:34:03.713]                     }
[10:34:03.713]                     invisible(muffled)
[10:34:03.713]                   }
[10:34:03.713]                   muffleCondition(cond)
[10:34:03.713]                 })
[10:34:03.713]             }))
[10:34:03.713]             future::FutureResult(value = ...future.value$value, 
[10:34:03.713]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:03.713]                   ...future.rng), globalenv = if (FALSE) 
[10:34:03.713]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:03.713]                     ...future.globalenv.names))
[10:34:03.713]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:03.713]         }, condition = base::local({
[10:34:03.713]             c <- base::c
[10:34:03.713]             inherits <- base::inherits
[10:34:03.713]             invokeRestart <- base::invokeRestart
[10:34:03.713]             length <- base::length
[10:34:03.713]             list <- base::list
[10:34:03.713]             seq.int <- base::seq.int
[10:34:03.713]             signalCondition <- base::signalCondition
[10:34:03.713]             sys.calls <- base::sys.calls
[10:34:03.713]             `[[` <- base::`[[`
[10:34:03.713]             `+` <- base::`+`
[10:34:03.713]             `<<-` <- base::`<<-`
[10:34:03.713]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:03.713]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:03.713]                   3L)]
[10:34:03.713]             }
[10:34:03.713]             function(cond) {
[10:34:03.713]                 is_error <- inherits(cond, "error")
[10:34:03.713]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:03.713]                   NULL)
[10:34:03.713]                 if (is_error) {
[10:34:03.713]                   sessionInformation <- function() {
[10:34:03.713]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:03.713]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:03.713]                       search = base::search(), system = base::Sys.info())
[10:34:03.713]                   }
[10:34:03.713]                   ...future.conditions[[length(...future.conditions) + 
[10:34:03.713]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:03.713]                     cond$call), session = sessionInformation(), 
[10:34:03.713]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:03.713]                   signalCondition(cond)
[10:34:03.713]                 }
[10:34:03.713]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:03.713]                 "immediateCondition"))) {
[10:34:03.713]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:03.713]                   ...future.conditions[[length(...future.conditions) + 
[10:34:03.713]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:03.713]                   if (TRUE && !signal) {
[10:34:03.713]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:03.713]                     {
[10:34:03.713]                       inherits <- base::inherits
[10:34:03.713]                       invokeRestart <- base::invokeRestart
[10:34:03.713]                       is.null <- base::is.null
[10:34:03.713]                       muffled <- FALSE
[10:34:03.713]                       if (inherits(cond, "message")) {
[10:34:03.713]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:03.713]                         if (muffled) 
[10:34:03.713]                           invokeRestart("muffleMessage")
[10:34:03.713]                       }
[10:34:03.713]                       else if (inherits(cond, "warning")) {
[10:34:03.713]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:03.713]                         if (muffled) 
[10:34:03.713]                           invokeRestart("muffleWarning")
[10:34:03.713]                       }
[10:34:03.713]                       else if (inherits(cond, "condition")) {
[10:34:03.713]                         if (!is.null(pattern)) {
[10:34:03.713]                           computeRestarts <- base::computeRestarts
[10:34:03.713]                           grepl <- base::grepl
[10:34:03.713]                           restarts <- computeRestarts(cond)
[10:34:03.713]                           for (restart in restarts) {
[10:34:03.713]                             name <- restart$name
[10:34:03.713]                             if (is.null(name)) 
[10:34:03.713]                               next
[10:34:03.713]                             if (!grepl(pattern, name)) 
[10:34:03.713]                               next
[10:34:03.713]                             invokeRestart(restart)
[10:34:03.713]                             muffled <- TRUE
[10:34:03.713]                             break
[10:34:03.713]                           }
[10:34:03.713]                         }
[10:34:03.713]                       }
[10:34:03.713]                       invisible(muffled)
[10:34:03.713]                     }
[10:34:03.713]                     muffleCondition(cond, pattern = "^muffle")
[10:34:03.713]                   }
[10:34:03.713]                 }
[10:34:03.713]                 else {
[10:34:03.713]                   if (TRUE) {
[10:34:03.713]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:03.713]                     {
[10:34:03.713]                       inherits <- base::inherits
[10:34:03.713]                       invokeRestart <- base::invokeRestart
[10:34:03.713]                       is.null <- base::is.null
[10:34:03.713]                       muffled <- FALSE
[10:34:03.713]                       if (inherits(cond, "message")) {
[10:34:03.713]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:03.713]                         if (muffled) 
[10:34:03.713]                           invokeRestart("muffleMessage")
[10:34:03.713]                       }
[10:34:03.713]                       else if (inherits(cond, "warning")) {
[10:34:03.713]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:03.713]                         if (muffled) 
[10:34:03.713]                           invokeRestart("muffleWarning")
[10:34:03.713]                       }
[10:34:03.713]                       else if (inherits(cond, "condition")) {
[10:34:03.713]                         if (!is.null(pattern)) {
[10:34:03.713]                           computeRestarts <- base::computeRestarts
[10:34:03.713]                           grepl <- base::grepl
[10:34:03.713]                           restarts <- computeRestarts(cond)
[10:34:03.713]                           for (restart in restarts) {
[10:34:03.713]                             name <- restart$name
[10:34:03.713]                             if (is.null(name)) 
[10:34:03.713]                               next
[10:34:03.713]                             if (!grepl(pattern, name)) 
[10:34:03.713]                               next
[10:34:03.713]                             invokeRestart(restart)
[10:34:03.713]                             muffled <- TRUE
[10:34:03.713]                             break
[10:34:03.713]                           }
[10:34:03.713]                         }
[10:34:03.713]                       }
[10:34:03.713]                       invisible(muffled)
[10:34:03.713]                     }
[10:34:03.713]                     muffleCondition(cond, pattern = "^muffle")
[10:34:03.713]                   }
[10:34:03.713]                 }
[10:34:03.713]             }
[10:34:03.713]         }))
[10:34:03.713]     }, error = function(ex) {
[10:34:03.713]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:03.713]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:03.713]                 ...future.rng), started = ...future.startTime, 
[10:34:03.713]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:03.713]             version = "1.8"), class = "FutureResult")
[10:34:03.713]     }, finally = {
[10:34:03.713]         if (!identical(...future.workdir, getwd())) 
[10:34:03.713]             setwd(...future.workdir)
[10:34:03.713]         {
[10:34:03.713]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:03.713]                 ...future.oldOptions$nwarnings <- NULL
[10:34:03.713]             }
[10:34:03.713]             base::options(...future.oldOptions)
[10:34:03.713]             if (.Platform$OS.type == "windows") {
[10:34:03.713]                 old_names <- names(...future.oldEnvVars)
[10:34:03.713]                 envs <- base::Sys.getenv()
[10:34:03.713]                 names <- names(envs)
[10:34:03.713]                 common <- intersect(names, old_names)
[10:34:03.713]                 added <- setdiff(names, old_names)
[10:34:03.713]                 removed <- setdiff(old_names, names)
[10:34:03.713]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:03.713]                   envs[common]]
[10:34:03.713]                 NAMES <- toupper(changed)
[10:34:03.713]                 args <- list()
[10:34:03.713]                 for (kk in seq_along(NAMES)) {
[10:34:03.713]                   name <- changed[[kk]]
[10:34:03.713]                   NAME <- NAMES[[kk]]
[10:34:03.713]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:03.713]                     next
[10:34:03.713]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:03.713]                 }
[10:34:03.713]                 NAMES <- toupper(added)
[10:34:03.713]                 for (kk in seq_along(NAMES)) {
[10:34:03.713]                   name <- added[[kk]]
[10:34:03.713]                   NAME <- NAMES[[kk]]
[10:34:03.713]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:03.713]                     next
[10:34:03.713]                   args[[name]] <- ""
[10:34:03.713]                 }
[10:34:03.713]                 NAMES <- toupper(removed)
[10:34:03.713]                 for (kk in seq_along(NAMES)) {
[10:34:03.713]                   name <- removed[[kk]]
[10:34:03.713]                   NAME <- NAMES[[kk]]
[10:34:03.713]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:03.713]                     next
[10:34:03.713]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:03.713]                 }
[10:34:03.713]                 if (length(args) > 0) 
[10:34:03.713]                   base::do.call(base::Sys.setenv, args = args)
[10:34:03.713]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:03.713]             }
[10:34:03.713]             else {
[10:34:03.713]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:03.713]             }
[10:34:03.713]             {
[10:34:03.713]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:03.713]                   0L) {
[10:34:03.713]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:03.713]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:03.713]                   base::options(opts)
[10:34:03.713]                 }
[10:34:03.713]                 {
[10:34:03.713]                   {
[10:34:03.713]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:03.713]                     NULL
[10:34:03.713]                   }
[10:34:03.713]                   options(future.plan = NULL)
[10:34:03.713]                   if (is.na(NA_character_)) 
[10:34:03.713]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:03.713]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:03.713]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:03.713]                     .init = FALSE)
[10:34:03.713]                 }
[10:34:03.713]             }
[10:34:03.713]         }
[10:34:03.713]     })
[10:34:03.713]     if (TRUE) {
[10:34:03.713]         base::sink(type = "output", split = FALSE)
[10:34:03.713]         if (TRUE) {
[10:34:03.713]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:03.713]         }
[10:34:03.713]         else {
[10:34:03.713]             ...future.result["stdout"] <- base::list(NULL)
[10:34:03.713]         }
[10:34:03.713]         base::close(...future.stdout)
[10:34:03.713]         ...future.stdout <- NULL
[10:34:03.713]     }
[10:34:03.713]     ...future.result$conditions <- ...future.conditions
[10:34:03.713]     ...future.result$finished <- base::Sys.time()
[10:34:03.713]     ...future.result
[10:34:03.713] }
[10:34:03.716] MultisessionFuture started
[10:34:03.716] - Launch lazy future ... done
[10:34:03.716] run() for ‘MultisessionFuture’ ... done
[10:34:04.219] receiveMessageFromWorker() for ClusterFuture ...
[10:34:04.219] - Validating connection of MultisessionFuture
[10:34:04.219] - received message: FutureResult
[10:34:04.219] - Received FutureResult
[10:34:04.219] - Erased future from FutureRegistry
[10:34:04.219] result() for ClusterFuture ...
[10:34:04.219] - result already collected: FutureResult
[10:34:04.220] result() for ClusterFuture ... done
[10:34:04.220] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:04.220] A MultisessionFuture was resolved (result was not collected)
[10:34:04.220] getGlobalsAndPackages() ...
[10:34:04.220] Searching for globals...
[10:34:04.221] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:34:04.221] Searching for globals ... DONE
[10:34:04.221] Resolving globals: FALSE
[10:34:04.222] 
[10:34:04.222] 
[10:34:04.222] getGlobalsAndPackages() ... DONE
[10:34:04.222] run() for ‘Future’ ...
[10:34:04.222] - state: ‘created’
[10:34:04.222] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:04.236] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:04.236] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:04.237]   - Field: ‘node’
[10:34:04.237]   - Field: ‘label’
[10:34:04.237]   - Field: ‘local’
[10:34:04.237]   - Field: ‘owner’
[10:34:04.237]   - Field: ‘envir’
[10:34:04.237]   - Field: ‘workers’
[10:34:04.237]   - Field: ‘packages’
[10:34:04.237]   - Field: ‘gc’
[10:34:04.237]   - Field: ‘conditions’
[10:34:04.237]   - Field: ‘persistent’
[10:34:04.238]   - Field: ‘expr’
[10:34:04.238]   - Field: ‘uuid’
[10:34:04.238]   - Field: ‘seed’
[10:34:04.238]   - Field: ‘version’
[10:34:04.238]   - Field: ‘result’
[10:34:04.238]   - Field: ‘asynchronous’
[10:34:04.238]   - Field: ‘calls’
[10:34:04.238]   - Field: ‘globals’
[10:34:04.238]   - Field: ‘stdout’
[10:34:04.238]   - Field: ‘earlySignal’
[10:34:04.238]   - Field: ‘lazy’
[10:34:04.239]   - Field: ‘state’
[10:34:04.239] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:04.239] - Launch lazy future ...
[10:34:04.239] Packages needed by the future expression (n = 0): <none>
[10:34:04.239] Packages needed by future strategies (n = 0): <none>
[10:34:04.240] {
[10:34:04.240]     {
[10:34:04.240]         {
[10:34:04.240]             ...future.startTime <- base::Sys.time()
[10:34:04.240]             {
[10:34:04.240]                 {
[10:34:04.240]                   {
[10:34:04.240]                     {
[10:34:04.240]                       base::local({
[10:34:04.240]                         has_future <- base::requireNamespace("future", 
[10:34:04.240]                           quietly = TRUE)
[10:34:04.240]                         if (has_future) {
[10:34:04.240]                           ns <- base::getNamespace("future")
[10:34:04.240]                           version <- ns[[".package"]][["version"]]
[10:34:04.240]                           if (is.null(version)) 
[10:34:04.240]                             version <- utils::packageVersion("future")
[10:34:04.240]                         }
[10:34:04.240]                         else {
[10:34:04.240]                           version <- NULL
[10:34:04.240]                         }
[10:34:04.240]                         if (!has_future || version < "1.8.0") {
[10:34:04.240]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:04.240]                             "", base::R.version$version.string), 
[10:34:04.240]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:04.240]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:04.240]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:04.240]                               "release", "version")], collapse = " "), 
[10:34:04.240]                             hostname = base::Sys.info()[["nodename"]])
[10:34:04.240]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:04.240]                             info)
[10:34:04.240]                           info <- base::paste(info, collapse = "; ")
[10:34:04.240]                           if (!has_future) {
[10:34:04.240]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:04.240]                               info)
[10:34:04.240]                           }
[10:34:04.240]                           else {
[10:34:04.240]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:04.240]                               info, version)
[10:34:04.240]                           }
[10:34:04.240]                           base::stop(msg)
[10:34:04.240]                         }
[10:34:04.240]                       })
[10:34:04.240]                     }
[10:34:04.240]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:04.240]                     base::options(mc.cores = 1L)
[10:34:04.240]                   }
[10:34:04.240]                   ...future.strategy.old <- future::plan("list")
[10:34:04.240]                   options(future.plan = NULL)
[10:34:04.240]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:04.240]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:04.240]                 }
[10:34:04.240]                 ...future.workdir <- getwd()
[10:34:04.240]             }
[10:34:04.240]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:04.240]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:04.240]         }
[10:34:04.240]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:04.240]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:04.240]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:04.240]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:04.240]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:04.240]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:04.240]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:04.240]             base::names(...future.oldOptions))
[10:34:04.240]     }
[10:34:04.240]     if (FALSE) {
[10:34:04.240]     }
[10:34:04.240]     else {
[10:34:04.240]         if (TRUE) {
[10:34:04.240]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:04.240]                 open = "w")
[10:34:04.240]         }
[10:34:04.240]         else {
[10:34:04.240]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:04.240]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:04.240]         }
[10:34:04.240]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:04.240]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:04.240]             base::sink(type = "output", split = FALSE)
[10:34:04.240]             base::close(...future.stdout)
[10:34:04.240]         }, add = TRUE)
[10:34:04.240]     }
[10:34:04.240]     ...future.frame <- base::sys.nframe()
[10:34:04.240]     ...future.conditions <- base::list()
[10:34:04.240]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:04.240]     if (FALSE) {
[10:34:04.240]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:04.240]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:04.240]     }
[10:34:04.240]     ...future.result <- base::tryCatch({
[10:34:04.240]         base::withCallingHandlers({
[10:34:04.240]             ...future.value <- base::withVisible(base::local({
[10:34:04.240]                 ...future.makeSendCondition <- base::local({
[10:34:04.240]                   sendCondition <- NULL
[10:34:04.240]                   function(frame = 1L) {
[10:34:04.240]                     if (is.function(sendCondition)) 
[10:34:04.240]                       return(sendCondition)
[10:34:04.240]                     ns <- getNamespace("parallel")
[10:34:04.240]                     if (exists("sendData", mode = "function", 
[10:34:04.240]                       envir = ns)) {
[10:34:04.240]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:04.240]                         envir = ns)
[10:34:04.240]                       envir <- sys.frame(frame)
[10:34:04.240]                       master <- NULL
[10:34:04.240]                       while (!identical(envir, .GlobalEnv) && 
[10:34:04.240]                         !identical(envir, emptyenv())) {
[10:34:04.240]                         if (exists("master", mode = "list", envir = envir, 
[10:34:04.240]                           inherits = FALSE)) {
[10:34:04.240]                           master <- get("master", mode = "list", 
[10:34:04.240]                             envir = envir, inherits = FALSE)
[10:34:04.240]                           if (inherits(master, c("SOCKnode", 
[10:34:04.240]                             "SOCK0node"))) {
[10:34:04.240]                             sendCondition <<- function(cond) {
[10:34:04.240]                               data <- list(type = "VALUE", value = cond, 
[10:34:04.240]                                 success = TRUE)
[10:34:04.240]                               parallel_sendData(master, data)
[10:34:04.240]                             }
[10:34:04.240]                             return(sendCondition)
[10:34:04.240]                           }
[10:34:04.240]                         }
[10:34:04.240]                         frame <- frame + 1L
[10:34:04.240]                         envir <- sys.frame(frame)
[10:34:04.240]                       }
[10:34:04.240]                     }
[10:34:04.240]                     sendCondition <<- function(cond) NULL
[10:34:04.240]                   }
[10:34:04.240]                 })
[10:34:04.240]                 withCallingHandlers({
[10:34:04.240]                   {
[10:34:04.240]                     Sys.sleep(0.5)
[10:34:04.240]                     list(a = 1, b = 42L)
[10:34:04.240]                   }
[10:34:04.240]                 }, immediateCondition = function(cond) {
[10:34:04.240]                   sendCondition <- ...future.makeSendCondition()
[10:34:04.240]                   sendCondition(cond)
[10:34:04.240]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:04.240]                   {
[10:34:04.240]                     inherits <- base::inherits
[10:34:04.240]                     invokeRestart <- base::invokeRestart
[10:34:04.240]                     is.null <- base::is.null
[10:34:04.240]                     muffled <- FALSE
[10:34:04.240]                     if (inherits(cond, "message")) {
[10:34:04.240]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:04.240]                       if (muffled) 
[10:34:04.240]                         invokeRestart("muffleMessage")
[10:34:04.240]                     }
[10:34:04.240]                     else if (inherits(cond, "warning")) {
[10:34:04.240]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:04.240]                       if (muffled) 
[10:34:04.240]                         invokeRestart("muffleWarning")
[10:34:04.240]                     }
[10:34:04.240]                     else if (inherits(cond, "condition")) {
[10:34:04.240]                       if (!is.null(pattern)) {
[10:34:04.240]                         computeRestarts <- base::computeRestarts
[10:34:04.240]                         grepl <- base::grepl
[10:34:04.240]                         restarts <- computeRestarts(cond)
[10:34:04.240]                         for (restart in restarts) {
[10:34:04.240]                           name <- restart$name
[10:34:04.240]                           if (is.null(name)) 
[10:34:04.240]                             next
[10:34:04.240]                           if (!grepl(pattern, name)) 
[10:34:04.240]                             next
[10:34:04.240]                           invokeRestart(restart)
[10:34:04.240]                           muffled <- TRUE
[10:34:04.240]                           break
[10:34:04.240]                         }
[10:34:04.240]                       }
[10:34:04.240]                     }
[10:34:04.240]                     invisible(muffled)
[10:34:04.240]                   }
[10:34:04.240]                   muffleCondition(cond)
[10:34:04.240]                 })
[10:34:04.240]             }))
[10:34:04.240]             future::FutureResult(value = ...future.value$value, 
[10:34:04.240]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:04.240]                   ...future.rng), globalenv = if (FALSE) 
[10:34:04.240]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:04.240]                     ...future.globalenv.names))
[10:34:04.240]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:04.240]         }, condition = base::local({
[10:34:04.240]             c <- base::c
[10:34:04.240]             inherits <- base::inherits
[10:34:04.240]             invokeRestart <- base::invokeRestart
[10:34:04.240]             length <- base::length
[10:34:04.240]             list <- base::list
[10:34:04.240]             seq.int <- base::seq.int
[10:34:04.240]             signalCondition <- base::signalCondition
[10:34:04.240]             sys.calls <- base::sys.calls
[10:34:04.240]             `[[` <- base::`[[`
[10:34:04.240]             `+` <- base::`+`
[10:34:04.240]             `<<-` <- base::`<<-`
[10:34:04.240]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:04.240]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:04.240]                   3L)]
[10:34:04.240]             }
[10:34:04.240]             function(cond) {
[10:34:04.240]                 is_error <- inherits(cond, "error")
[10:34:04.240]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:04.240]                   NULL)
[10:34:04.240]                 if (is_error) {
[10:34:04.240]                   sessionInformation <- function() {
[10:34:04.240]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:04.240]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:04.240]                       search = base::search(), system = base::Sys.info())
[10:34:04.240]                   }
[10:34:04.240]                   ...future.conditions[[length(...future.conditions) + 
[10:34:04.240]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:04.240]                     cond$call), session = sessionInformation(), 
[10:34:04.240]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:04.240]                   signalCondition(cond)
[10:34:04.240]                 }
[10:34:04.240]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:04.240]                 "immediateCondition"))) {
[10:34:04.240]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:04.240]                   ...future.conditions[[length(...future.conditions) + 
[10:34:04.240]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:04.240]                   if (TRUE && !signal) {
[10:34:04.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:04.240]                     {
[10:34:04.240]                       inherits <- base::inherits
[10:34:04.240]                       invokeRestart <- base::invokeRestart
[10:34:04.240]                       is.null <- base::is.null
[10:34:04.240]                       muffled <- FALSE
[10:34:04.240]                       if (inherits(cond, "message")) {
[10:34:04.240]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:04.240]                         if (muffled) 
[10:34:04.240]                           invokeRestart("muffleMessage")
[10:34:04.240]                       }
[10:34:04.240]                       else if (inherits(cond, "warning")) {
[10:34:04.240]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:04.240]                         if (muffled) 
[10:34:04.240]                           invokeRestart("muffleWarning")
[10:34:04.240]                       }
[10:34:04.240]                       else if (inherits(cond, "condition")) {
[10:34:04.240]                         if (!is.null(pattern)) {
[10:34:04.240]                           computeRestarts <- base::computeRestarts
[10:34:04.240]                           grepl <- base::grepl
[10:34:04.240]                           restarts <- computeRestarts(cond)
[10:34:04.240]                           for (restart in restarts) {
[10:34:04.240]                             name <- restart$name
[10:34:04.240]                             if (is.null(name)) 
[10:34:04.240]                               next
[10:34:04.240]                             if (!grepl(pattern, name)) 
[10:34:04.240]                               next
[10:34:04.240]                             invokeRestart(restart)
[10:34:04.240]                             muffled <- TRUE
[10:34:04.240]                             break
[10:34:04.240]                           }
[10:34:04.240]                         }
[10:34:04.240]                       }
[10:34:04.240]                       invisible(muffled)
[10:34:04.240]                     }
[10:34:04.240]                     muffleCondition(cond, pattern = "^muffle")
[10:34:04.240]                   }
[10:34:04.240]                 }
[10:34:04.240]                 else {
[10:34:04.240]                   if (TRUE) {
[10:34:04.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:04.240]                     {
[10:34:04.240]                       inherits <- base::inherits
[10:34:04.240]                       invokeRestart <- base::invokeRestart
[10:34:04.240]                       is.null <- base::is.null
[10:34:04.240]                       muffled <- FALSE
[10:34:04.240]                       if (inherits(cond, "message")) {
[10:34:04.240]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:04.240]                         if (muffled) 
[10:34:04.240]                           invokeRestart("muffleMessage")
[10:34:04.240]                       }
[10:34:04.240]                       else if (inherits(cond, "warning")) {
[10:34:04.240]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:04.240]                         if (muffled) 
[10:34:04.240]                           invokeRestart("muffleWarning")
[10:34:04.240]                       }
[10:34:04.240]                       else if (inherits(cond, "condition")) {
[10:34:04.240]                         if (!is.null(pattern)) {
[10:34:04.240]                           computeRestarts <- base::computeRestarts
[10:34:04.240]                           grepl <- base::grepl
[10:34:04.240]                           restarts <- computeRestarts(cond)
[10:34:04.240]                           for (restart in restarts) {
[10:34:04.240]                             name <- restart$name
[10:34:04.240]                             if (is.null(name)) 
[10:34:04.240]                               next
[10:34:04.240]                             if (!grepl(pattern, name)) 
[10:34:04.240]                               next
[10:34:04.240]                             invokeRestart(restart)
[10:34:04.240]                             muffled <- TRUE
[10:34:04.240]                             break
[10:34:04.240]                           }
[10:34:04.240]                         }
[10:34:04.240]                       }
[10:34:04.240]                       invisible(muffled)
[10:34:04.240]                     }
[10:34:04.240]                     muffleCondition(cond, pattern = "^muffle")
[10:34:04.240]                   }
[10:34:04.240]                 }
[10:34:04.240]             }
[10:34:04.240]         }))
[10:34:04.240]     }, error = function(ex) {
[10:34:04.240]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:04.240]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:04.240]                 ...future.rng), started = ...future.startTime, 
[10:34:04.240]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:04.240]             version = "1.8"), class = "FutureResult")
[10:34:04.240]     }, finally = {
[10:34:04.240]         if (!identical(...future.workdir, getwd())) 
[10:34:04.240]             setwd(...future.workdir)
[10:34:04.240]         {
[10:34:04.240]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:04.240]                 ...future.oldOptions$nwarnings <- NULL
[10:34:04.240]             }
[10:34:04.240]             base::options(...future.oldOptions)
[10:34:04.240]             if (.Platform$OS.type == "windows") {
[10:34:04.240]                 old_names <- names(...future.oldEnvVars)
[10:34:04.240]                 envs <- base::Sys.getenv()
[10:34:04.240]                 names <- names(envs)
[10:34:04.240]                 common <- intersect(names, old_names)
[10:34:04.240]                 added <- setdiff(names, old_names)
[10:34:04.240]                 removed <- setdiff(old_names, names)
[10:34:04.240]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:04.240]                   envs[common]]
[10:34:04.240]                 NAMES <- toupper(changed)
[10:34:04.240]                 args <- list()
[10:34:04.240]                 for (kk in seq_along(NAMES)) {
[10:34:04.240]                   name <- changed[[kk]]
[10:34:04.240]                   NAME <- NAMES[[kk]]
[10:34:04.240]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:04.240]                     next
[10:34:04.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:04.240]                 }
[10:34:04.240]                 NAMES <- toupper(added)
[10:34:04.240]                 for (kk in seq_along(NAMES)) {
[10:34:04.240]                   name <- added[[kk]]
[10:34:04.240]                   NAME <- NAMES[[kk]]
[10:34:04.240]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:04.240]                     next
[10:34:04.240]                   args[[name]] <- ""
[10:34:04.240]                 }
[10:34:04.240]                 NAMES <- toupper(removed)
[10:34:04.240]                 for (kk in seq_along(NAMES)) {
[10:34:04.240]                   name <- removed[[kk]]
[10:34:04.240]                   NAME <- NAMES[[kk]]
[10:34:04.240]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:04.240]                     next
[10:34:04.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:04.240]                 }
[10:34:04.240]                 if (length(args) > 0) 
[10:34:04.240]                   base::do.call(base::Sys.setenv, args = args)
[10:34:04.240]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:04.240]             }
[10:34:04.240]             else {
[10:34:04.240]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:04.240]             }
[10:34:04.240]             {
[10:34:04.240]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:04.240]                   0L) {
[10:34:04.240]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:04.240]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:04.240]                   base::options(opts)
[10:34:04.240]                 }
[10:34:04.240]                 {
[10:34:04.240]                   {
[10:34:04.240]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:04.240]                     NULL
[10:34:04.240]                   }
[10:34:04.240]                   options(future.plan = NULL)
[10:34:04.240]                   if (is.na(NA_character_)) 
[10:34:04.240]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:04.240]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:04.240]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:04.240]                     .init = FALSE)
[10:34:04.240]                 }
[10:34:04.240]             }
[10:34:04.240]         }
[10:34:04.240]     })
[10:34:04.240]     if (TRUE) {
[10:34:04.240]         base::sink(type = "output", split = FALSE)
[10:34:04.240]         if (TRUE) {
[10:34:04.240]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:04.240]         }
[10:34:04.240]         else {
[10:34:04.240]             ...future.result["stdout"] <- base::list(NULL)
[10:34:04.240]         }
[10:34:04.240]         base::close(...future.stdout)
[10:34:04.240]         ...future.stdout <- NULL
[10:34:04.240]     }
[10:34:04.240]     ...future.result$conditions <- ...future.conditions
[10:34:04.240]     ...future.result$finished <- base::Sys.time()
[10:34:04.240]     ...future.result
[10:34:04.240] }
[10:34:04.242] MultisessionFuture started
[10:34:04.243] - Launch lazy future ... done
[10:34:04.243] run() for ‘MultisessionFuture’ ... done
[10:34:04.745] receiveMessageFromWorker() for ClusterFuture ...
[10:34:04.745] - Validating connection of MultisessionFuture
[10:34:04.745] - received message: FutureResult
[10:34:04.746] - Received FutureResult
[10:34:04.746] - Erased future from FutureRegistry
[10:34:04.746] result() for ClusterFuture ...
[10:34:04.746] - result already collected: FutureResult
[10:34:04.746] result() for ClusterFuture ... done
[10:34:04.746] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:04.746] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[10:34:04.746] getGlobalsAndPackages() ...
[10:34:04.747] Searching for globals...
[10:34:04.747] - globals found: [2] ‘list’, ‘stop’
[10:34:04.747] Searching for globals ... DONE
[10:34:04.747] Resolving globals: FALSE
[10:34:04.748] 
[10:34:04.748] 
[10:34:04.748] getGlobalsAndPackages() ... DONE
[10:34:04.748] run() for ‘Future’ ...
[10:34:04.748] - state: ‘created’
[10:34:04.748] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:04.762] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:04.763] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:04.763]   - Field: ‘node’
[10:34:04.763]   - Field: ‘label’
[10:34:04.763]   - Field: ‘local’
[10:34:04.763]   - Field: ‘owner’
[10:34:04.763]   - Field: ‘envir’
[10:34:04.763]   - Field: ‘workers’
[10:34:04.763]   - Field: ‘packages’
[10:34:04.763]   - Field: ‘gc’
[10:34:04.763]   - Field: ‘conditions’
[10:34:04.764]   - Field: ‘persistent’
[10:34:04.764]   - Field: ‘expr’
[10:34:04.764]   - Field: ‘uuid’
[10:34:04.764]   - Field: ‘seed’
[10:34:04.764]   - Field: ‘version’
[10:34:04.764]   - Field: ‘result’
[10:34:04.764]   - Field: ‘asynchronous’
[10:34:04.764]   - Field: ‘calls’
[10:34:04.764]   - Field: ‘globals’
[10:34:04.764]   - Field: ‘stdout’
[10:34:04.764]   - Field: ‘earlySignal’
[10:34:04.765]   - Field: ‘lazy’
[10:34:04.765]   - Field: ‘state’
[10:34:04.765] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:04.765] - Launch lazy future ...
[10:34:04.765] Packages needed by the future expression (n = 0): <none>
[10:34:04.765] Packages needed by future strategies (n = 0): <none>
[10:34:04.766] {
[10:34:04.766]     {
[10:34:04.766]         {
[10:34:04.766]             ...future.startTime <- base::Sys.time()
[10:34:04.766]             {
[10:34:04.766]                 {
[10:34:04.766]                   {
[10:34:04.766]                     {
[10:34:04.766]                       base::local({
[10:34:04.766]                         has_future <- base::requireNamespace("future", 
[10:34:04.766]                           quietly = TRUE)
[10:34:04.766]                         if (has_future) {
[10:34:04.766]                           ns <- base::getNamespace("future")
[10:34:04.766]                           version <- ns[[".package"]][["version"]]
[10:34:04.766]                           if (is.null(version)) 
[10:34:04.766]                             version <- utils::packageVersion("future")
[10:34:04.766]                         }
[10:34:04.766]                         else {
[10:34:04.766]                           version <- NULL
[10:34:04.766]                         }
[10:34:04.766]                         if (!has_future || version < "1.8.0") {
[10:34:04.766]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:04.766]                             "", base::R.version$version.string), 
[10:34:04.766]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:04.766]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:04.766]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:04.766]                               "release", "version")], collapse = " "), 
[10:34:04.766]                             hostname = base::Sys.info()[["nodename"]])
[10:34:04.766]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:04.766]                             info)
[10:34:04.766]                           info <- base::paste(info, collapse = "; ")
[10:34:04.766]                           if (!has_future) {
[10:34:04.766]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:04.766]                               info)
[10:34:04.766]                           }
[10:34:04.766]                           else {
[10:34:04.766]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:04.766]                               info, version)
[10:34:04.766]                           }
[10:34:04.766]                           base::stop(msg)
[10:34:04.766]                         }
[10:34:04.766]                       })
[10:34:04.766]                     }
[10:34:04.766]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:04.766]                     base::options(mc.cores = 1L)
[10:34:04.766]                   }
[10:34:04.766]                   ...future.strategy.old <- future::plan("list")
[10:34:04.766]                   options(future.plan = NULL)
[10:34:04.766]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:04.766]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:04.766]                 }
[10:34:04.766]                 ...future.workdir <- getwd()
[10:34:04.766]             }
[10:34:04.766]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:04.766]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:04.766]         }
[10:34:04.766]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:04.766]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:04.766]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:04.766]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:04.766]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:04.766]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:04.766]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:04.766]             base::names(...future.oldOptions))
[10:34:04.766]     }
[10:34:04.766]     if (FALSE) {
[10:34:04.766]     }
[10:34:04.766]     else {
[10:34:04.766]         if (TRUE) {
[10:34:04.766]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:04.766]                 open = "w")
[10:34:04.766]         }
[10:34:04.766]         else {
[10:34:04.766]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:04.766]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:04.766]         }
[10:34:04.766]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:04.766]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:04.766]             base::sink(type = "output", split = FALSE)
[10:34:04.766]             base::close(...future.stdout)
[10:34:04.766]         }, add = TRUE)
[10:34:04.766]     }
[10:34:04.766]     ...future.frame <- base::sys.nframe()
[10:34:04.766]     ...future.conditions <- base::list()
[10:34:04.766]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:04.766]     if (FALSE) {
[10:34:04.766]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:04.766]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:04.766]     }
[10:34:04.766]     ...future.result <- base::tryCatch({
[10:34:04.766]         base::withCallingHandlers({
[10:34:04.766]             ...future.value <- base::withVisible(base::local({
[10:34:04.766]                 ...future.makeSendCondition <- base::local({
[10:34:04.766]                   sendCondition <- NULL
[10:34:04.766]                   function(frame = 1L) {
[10:34:04.766]                     if (is.function(sendCondition)) 
[10:34:04.766]                       return(sendCondition)
[10:34:04.766]                     ns <- getNamespace("parallel")
[10:34:04.766]                     if (exists("sendData", mode = "function", 
[10:34:04.766]                       envir = ns)) {
[10:34:04.766]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:04.766]                         envir = ns)
[10:34:04.766]                       envir <- sys.frame(frame)
[10:34:04.766]                       master <- NULL
[10:34:04.766]                       while (!identical(envir, .GlobalEnv) && 
[10:34:04.766]                         !identical(envir, emptyenv())) {
[10:34:04.766]                         if (exists("master", mode = "list", envir = envir, 
[10:34:04.766]                           inherits = FALSE)) {
[10:34:04.766]                           master <- get("master", mode = "list", 
[10:34:04.766]                             envir = envir, inherits = FALSE)
[10:34:04.766]                           if (inherits(master, c("SOCKnode", 
[10:34:04.766]                             "SOCK0node"))) {
[10:34:04.766]                             sendCondition <<- function(cond) {
[10:34:04.766]                               data <- list(type = "VALUE", value = cond, 
[10:34:04.766]                                 success = TRUE)
[10:34:04.766]                               parallel_sendData(master, data)
[10:34:04.766]                             }
[10:34:04.766]                             return(sendCondition)
[10:34:04.766]                           }
[10:34:04.766]                         }
[10:34:04.766]                         frame <- frame + 1L
[10:34:04.766]                         envir <- sys.frame(frame)
[10:34:04.766]                       }
[10:34:04.766]                     }
[10:34:04.766]                     sendCondition <<- function(cond) NULL
[10:34:04.766]                   }
[10:34:04.766]                 })
[10:34:04.766]                 withCallingHandlers({
[10:34:04.766]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:34:04.766]                 }, immediateCondition = function(cond) {
[10:34:04.766]                   sendCondition <- ...future.makeSendCondition()
[10:34:04.766]                   sendCondition(cond)
[10:34:04.766]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:04.766]                   {
[10:34:04.766]                     inherits <- base::inherits
[10:34:04.766]                     invokeRestart <- base::invokeRestart
[10:34:04.766]                     is.null <- base::is.null
[10:34:04.766]                     muffled <- FALSE
[10:34:04.766]                     if (inherits(cond, "message")) {
[10:34:04.766]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:04.766]                       if (muffled) 
[10:34:04.766]                         invokeRestart("muffleMessage")
[10:34:04.766]                     }
[10:34:04.766]                     else if (inherits(cond, "warning")) {
[10:34:04.766]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:04.766]                       if (muffled) 
[10:34:04.766]                         invokeRestart("muffleWarning")
[10:34:04.766]                     }
[10:34:04.766]                     else if (inherits(cond, "condition")) {
[10:34:04.766]                       if (!is.null(pattern)) {
[10:34:04.766]                         computeRestarts <- base::computeRestarts
[10:34:04.766]                         grepl <- base::grepl
[10:34:04.766]                         restarts <- computeRestarts(cond)
[10:34:04.766]                         for (restart in restarts) {
[10:34:04.766]                           name <- restart$name
[10:34:04.766]                           if (is.null(name)) 
[10:34:04.766]                             next
[10:34:04.766]                           if (!grepl(pattern, name)) 
[10:34:04.766]                             next
[10:34:04.766]                           invokeRestart(restart)
[10:34:04.766]                           muffled <- TRUE
[10:34:04.766]                           break
[10:34:04.766]                         }
[10:34:04.766]                       }
[10:34:04.766]                     }
[10:34:04.766]                     invisible(muffled)
[10:34:04.766]                   }
[10:34:04.766]                   muffleCondition(cond)
[10:34:04.766]                 })
[10:34:04.766]             }))
[10:34:04.766]             future::FutureResult(value = ...future.value$value, 
[10:34:04.766]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:04.766]                   ...future.rng), globalenv = if (FALSE) 
[10:34:04.766]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:04.766]                     ...future.globalenv.names))
[10:34:04.766]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:04.766]         }, condition = base::local({
[10:34:04.766]             c <- base::c
[10:34:04.766]             inherits <- base::inherits
[10:34:04.766]             invokeRestart <- base::invokeRestart
[10:34:04.766]             length <- base::length
[10:34:04.766]             list <- base::list
[10:34:04.766]             seq.int <- base::seq.int
[10:34:04.766]             signalCondition <- base::signalCondition
[10:34:04.766]             sys.calls <- base::sys.calls
[10:34:04.766]             `[[` <- base::`[[`
[10:34:04.766]             `+` <- base::`+`
[10:34:04.766]             `<<-` <- base::`<<-`
[10:34:04.766]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:04.766]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:04.766]                   3L)]
[10:34:04.766]             }
[10:34:04.766]             function(cond) {
[10:34:04.766]                 is_error <- inherits(cond, "error")
[10:34:04.766]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:04.766]                   NULL)
[10:34:04.766]                 if (is_error) {
[10:34:04.766]                   sessionInformation <- function() {
[10:34:04.766]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:04.766]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:04.766]                       search = base::search(), system = base::Sys.info())
[10:34:04.766]                   }
[10:34:04.766]                   ...future.conditions[[length(...future.conditions) + 
[10:34:04.766]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:04.766]                     cond$call), session = sessionInformation(), 
[10:34:04.766]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:04.766]                   signalCondition(cond)
[10:34:04.766]                 }
[10:34:04.766]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:04.766]                 "immediateCondition"))) {
[10:34:04.766]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:04.766]                   ...future.conditions[[length(...future.conditions) + 
[10:34:04.766]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:04.766]                   if (TRUE && !signal) {
[10:34:04.766]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:04.766]                     {
[10:34:04.766]                       inherits <- base::inherits
[10:34:04.766]                       invokeRestart <- base::invokeRestart
[10:34:04.766]                       is.null <- base::is.null
[10:34:04.766]                       muffled <- FALSE
[10:34:04.766]                       if (inherits(cond, "message")) {
[10:34:04.766]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:04.766]                         if (muffled) 
[10:34:04.766]                           invokeRestart("muffleMessage")
[10:34:04.766]                       }
[10:34:04.766]                       else if (inherits(cond, "warning")) {
[10:34:04.766]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:04.766]                         if (muffled) 
[10:34:04.766]                           invokeRestart("muffleWarning")
[10:34:04.766]                       }
[10:34:04.766]                       else if (inherits(cond, "condition")) {
[10:34:04.766]                         if (!is.null(pattern)) {
[10:34:04.766]                           computeRestarts <- base::computeRestarts
[10:34:04.766]                           grepl <- base::grepl
[10:34:04.766]                           restarts <- computeRestarts(cond)
[10:34:04.766]                           for (restart in restarts) {
[10:34:04.766]                             name <- restart$name
[10:34:04.766]                             if (is.null(name)) 
[10:34:04.766]                               next
[10:34:04.766]                             if (!grepl(pattern, name)) 
[10:34:04.766]                               next
[10:34:04.766]                             invokeRestart(restart)
[10:34:04.766]                             muffled <- TRUE
[10:34:04.766]                             break
[10:34:04.766]                           }
[10:34:04.766]                         }
[10:34:04.766]                       }
[10:34:04.766]                       invisible(muffled)
[10:34:04.766]                     }
[10:34:04.766]                     muffleCondition(cond, pattern = "^muffle")
[10:34:04.766]                   }
[10:34:04.766]                 }
[10:34:04.766]                 else {
[10:34:04.766]                   if (TRUE) {
[10:34:04.766]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:04.766]                     {
[10:34:04.766]                       inherits <- base::inherits
[10:34:04.766]                       invokeRestart <- base::invokeRestart
[10:34:04.766]                       is.null <- base::is.null
[10:34:04.766]                       muffled <- FALSE
[10:34:04.766]                       if (inherits(cond, "message")) {
[10:34:04.766]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:04.766]                         if (muffled) 
[10:34:04.766]                           invokeRestart("muffleMessage")
[10:34:04.766]                       }
[10:34:04.766]                       else if (inherits(cond, "warning")) {
[10:34:04.766]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:04.766]                         if (muffled) 
[10:34:04.766]                           invokeRestart("muffleWarning")
[10:34:04.766]                       }
[10:34:04.766]                       else if (inherits(cond, "condition")) {
[10:34:04.766]                         if (!is.null(pattern)) {
[10:34:04.766]                           computeRestarts <- base::computeRestarts
[10:34:04.766]                           grepl <- base::grepl
[10:34:04.766]                           restarts <- computeRestarts(cond)
[10:34:04.766]                           for (restart in restarts) {
[10:34:04.766]                             name <- restart$name
[10:34:04.766]                             if (is.null(name)) 
[10:34:04.766]                               next
[10:34:04.766]                             if (!grepl(pattern, name)) 
[10:34:04.766]                               next
[10:34:04.766]                             invokeRestart(restart)
[10:34:04.766]                             muffled <- TRUE
[10:34:04.766]                             break
[10:34:04.766]                           }
[10:34:04.766]                         }
[10:34:04.766]                       }
[10:34:04.766]                       invisible(muffled)
[10:34:04.766]                     }
[10:34:04.766]                     muffleCondition(cond, pattern = "^muffle")
[10:34:04.766]                   }
[10:34:04.766]                 }
[10:34:04.766]             }
[10:34:04.766]         }))
[10:34:04.766]     }, error = function(ex) {
[10:34:04.766]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:04.766]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:04.766]                 ...future.rng), started = ...future.startTime, 
[10:34:04.766]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:04.766]             version = "1.8"), class = "FutureResult")
[10:34:04.766]     }, finally = {
[10:34:04.766]         if (!identical(...future.workdir, getwd())) 
[10:34:04.766]             setwd(...future.workdir)
[10:34:04.766]         {
[10:34:04.766]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:04.766]                 ...future.oldOptions$nwarnings <- NULL
[10:34:04.766]             }
[10:34:04.766]             base::options(...future.oldOptions)
[10:34:04.766]             if (.Platform$OS.type == "windows") {
[10:34:04.766]                 old_names <- names(...future.oldEnvVars)
[10:34:04.766]                 envs <- base::Sys.getenv()
[10:34:04.766]                 names <- names(envs)
[10:34:04.766]                 common <- intersect(names, old_names)
[10:34:04.766]                 added <- setdiff(names, old_names)
[10:34:04.766]                 removed <- setdiff(old_names, names)
[10:34:04.766]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:04.766]                   envs[common]]
[10:34:04.766]                 NAMES <- toupper(changed)
[10:34:04.766]                 args <- list()
[10:34:04.766]                 for (kk in seq_along(NAMES)) {
[10:34:04.766]                   name <- changed[[kk]]
[10:34:04.766]                   NAME <- NAMES[[kk]]
[10:34:04.766]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:04.766]                     next
[10:34:04.766]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:04.766]                 }
[10:34:04.766]                 NAMES <- toupper(added)
[10:34:04.766]                 for (kk in seq_along(NAMES)) {
[10:34:04.766]                   name <- added[[kk]]
[10:34:04.766]                   NAME <- NAMES[[kk]]
[10:34:04.766]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:04.766]                     next
[10:34:04.766]                   args[[name]] <- ""
[10:34:04.766]                 }
[10:34:04.766]                 NAMES <- toupper(removed)
[10:34:04.766]                 for (kk in seq_along(NAMES)) {
[10:34:04.766]                   name <- removed[[kk]]
[10:34:04.766]                   NAME <- NAMES[[kk]]
[10:34:04.766]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:04.766]                     next
[10:34:04.766]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:04.766]                 }
[10:34:04.766]                 if (length(args) > 0) 
[10:34:04.766]                   base::do.call(base::Sys.setenv, args = args)
[10:34:04.766]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:04.766]             }
[10:34:04.766]             else {
[10:34:04.766]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:04.766]             }
[10:34:04.766]             {
[10:34:04.766]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:04.766]                   0L) {
[10:34:04.766]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:04.766]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:04.766]                   base::options(opts)
[10:34:04.766]                 }
[10:34:04.766]                 {
[10:34:04.766]                   {
[10:34:04.766]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:04.766]                     NULL
[10:34:04.766]                   }
[10:34:04.766]                   options(future.plan = NULL)
[10:34:04.766]                   if (is.na(NA_character_)) 
[10:34:04.766]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:04.766]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:04.766]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:04.766]                     .init = FALSE)
[10:34:04.766]                 }
[10:34:04.766]             }
[10:34:04.766]         }
[10:34:04.766]     })
[10:34:04.766]     if (TRUE) {
[10:34:04.766]         base::sink(type = "output", split = FALSE)
[10:34:04.766]         if (TRUE) {
[10:34:04.766]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:04.766]         }
[10:34:04.766]         else {
[10:34:04.766]             ...future.result["stdout"] <- base::list(NULL)
[10:34:04.766]         }
[10:34:04.766]         base::close(...future.stdout)
[10:34:04.766]         ...future.stdout <- NULL
[10:34:04.766]     }
[10:34:04.766]     ...future.result$conditions <- ...future.conditions
[10:34:04.766]     ...future.result$finished <- base::Sys.time()
[10:34:04.766]     ...future.result
[10:34:04.766] }
[10:34:04.769] MultisessionFuture started
[10:34:04.769] - Launch lazy future ... done
[10:34:04.769] run() for ‘MultisessionFuture’ ... done
[10:34:04.770] receiveMessageFromWorker() for ClusterFuture ...
[10:34:04.771] - Validating connection of MultisessionFuture
[10:34:04.771] - received message: FutureResult
[10:34:04.771] - Received FutureResult
[10:34:04.771] - Erased future from FutureRegistry
[10:34:04.771] result() for ClusterFuture ...
[10:34:04.771] - result already collected: FutureResult
[10:34:04.772] result() for ClusterFuture ... done
[10:34:04.772] signalConditions() ...
[10:34:04.772]  - include = ‘immediateCondition’
[10:34:04.772]  - exclude = 
[10:34:04.772]  - resignal = FALSE
[10:34:04.772]  - Number of conditions: 1
[10:34:04.772] signalConditions() ... done
[10:34:04.772] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:04.772] A MultisessionFuture was resolved (result was not collected)
[10:34:04.772] getGlobalsAndPackages() ...
[10:34:04.772] Searching for globals...
[10:34:04.773] - globals found: [2] ‘list’, ‘stop’
[10:34:04.773] Searching for globals ... DONE
[10:34:04.773] Resolving globals: FALSE
[10:34:04.774] 
[10:34:04.774] 
[10:34:04.774] getGlobalsAndPackages() ... DONE
[10:34:04.774] run() for ‘Future’ ...
[10:34:04.774] - state: ‘created’
[10:34:04.774] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:04.788] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:04.788] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:04.788]   - Field: ‘node’
[10:34:04.788]   - Field: ‘label’
[10:34:04.789]   - Field: ‘local’
[10:34:04.789]   - Field: ‘owner’
[10:34:04.789]   - Field: ‘envir’
[10:34:04.789]   - Field: ‘workers’
[10:34:04.789]   - Field: ‘packages’
[10:34:04.789]   - Field: ‘gc’
[10:34:04.789]   - Field: ‘conditions’
[10:34:04.789]   - Field: ‘persistent’
[10:34:04.789]   - Field: ‘expr’
[10:34:04.789]   - Field: ‘uuid’
[10:34:04.789]   - Field: ‘seed’
[10:34:04.790]   - Field: ‘version’
[10:34:04.790]   - Field: ‘result’
[10:34:04.790]   - Field: ‘asynchronous’
[10:34:04.790]   - Field: ‘calls’
[10:34:04.790]   - Field: ‘globals’
[10:34:04.790]   - Field: ‘stdout’
[10:34:04.790]   - Field: ‘earlySignal’
[10:34:04.790]   - Field: ‘lazy’
[10:34:04.790]   - Field: ‘state’
[10:34:04.790] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:04.790] - Launch lazy future ...
[10:34:04.791] Packages needed by the future expression (n = 0): <none>
[10:34:04.791] Packages needed by future strategies (n = 0): <none>
[10:34:04.791] {
[10:34:04.791]     {
[10:34:04.791]         {
[10:34:04.791]             ...future.startTime <- base::Sys.time()
[10:34:04.791]             {
[10:34:04.791]                 {
[10:34:04.791]                   {
[10:34:04.791]                     {
[10:34:04.791]                       base::local({
[10:34:04.791]                         has_future <- base::requireNamespace("future", 
[10:34:04.791]                           quietly = TRUE)
[10:34:04.791]                         if (has_future) {
[10:34:04.791]                           ns <- base::getNamespace("future")
[10:34:04.791]                           version <- ns[[".package"]][["version"]]
[10:34:04.791]                           if (is.null(version)) 
[10:34:04.791]                             version <- utils::packageVersion("future")
[10:34:04.791]                         }
[10:34:04.791]                         else {
[10:34:04.791]                           version <- NULL
[10:34:04.791]                         }
[10:34:04.791]                         if (!has_future || version < "1.8.0") {
[10:34:04.791]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:04.791]                             "", base::R.version$version.string), 
[10:34:04.791]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:04.791]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:04.791]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:04.791]                               "release", "version")], collapse = " "), 
[10:34:04.791]                             hostname = base::Sys.info()[["nodename"]])
[10:34:04.791]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:04.791]                             info)
[10:34:04.791]                           info <- base::paste(info, collapse = "; ")
[10:34:04.791]                           if (!has_future) {
[10:34:04.791]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:04.791]                               info)
[10:34:04.791]                           }
[10:34:04.791]                           else {
[10:34:04.791]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:04.791]                               info, version)
[10:34:04.791]                           }
[10:34:04.791]                           base::stop(msg)
[10:34:04.791]                         }
[10:34:04.791]                       })
[10:34:04.791]                     }
[10:34:04.791]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:04.791]                     base::options(mc.cores = 1L)
[10:34:04.791]                   }
[10:34:04.791]                   ...future.strategy.old <- future::plan("list")
[10:34:04.791]                   options(future.plan = NULL)
[10:34:04.791]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:04.791]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:04.791]                 }
[10:34:04.791]                 ...future.workdir <- getwd()
[10:34:04.791]             }
[10:34:04.791]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:04.791]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:04.791]         }
[10:34:04.791]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:04.791]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:04.791]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:04.791]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:04.791]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:04.791]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:04.791]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:04.791]             base::names(...future.oldOptions))
[10:34:04.791]     }
[10:34:04.791]     if (FALSE) {
[10:34:04.791]     }
[10:34:04.791]     else {
[10:34:04.791]         if (TRUE) {
[10:34:04.791]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:04.791]                 open = "w")
[10:34:04.791]         }
[10:34:04.791]         else {
[10:34:04.791]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:04.791]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:04.791]         }
[10:34:04.791]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:04.791]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:04.791]             base::sink(type = "output", split = FALSE)
[10:34:04.791]             base::close(...future.stdout)
[10:34:04.791]         }, add = TRUE)
[10:34:04.791]     }
[10:34:04.791]     ...future.frame <- base::sys.nframe()
[10:34:04.791]     ...future.conditions <- base::list()
[10:34:04.791]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:04.791]     if (FALSE) {
[10:34:04.791]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:04.791]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:04.791]     }
[10:34:04.791]     ...future.result <- base::tryCatch({
[10:34:04.791]         base::withCallingHandlers({
[10:34:04.791]             ...future.value <- base::withVisible(base::local({
[10:34:04.791]                 ...future.makeSendCondition <- base::local({
[10:34:04.791]                   sendCondition <- NULL
[10:34:04.791]                   function(frame = 1L) {
[10:34:04.791]                     if (is.function(sendCondition)) 
[10:34:04.791]                       return(sendCondition)
[10:34:04.791]                     ns <- getNamespace("parallel")
[10:34:04.791]                     if (exists("sendData", mode = "function", 
[10:34:04.791]                       envir = ns)) {
[10:34:04.791]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:04.791]                         envir = ns)
[10:34:04.791]                       envir <- sys.frame(frame)
[10:34:04.791]                       master <- NULL
[10:34:04.791]                       while (!identical(envir, .GlobalEnv) && 
[10:34:04.791]                         !identical(envir, emptyenv())) {
[10:34:04.791]                         if (exists("master", mode = "list", envir = envir, 
[10:34:04.791]                           inherits = FALSE)) {
[10:34:04.791]                           master <- get("master", mode = "list", 
[10:34:04.791]                             envir = envir, inherits = FALSE)
[10:34:04.791]                           if (inherits(master, c("SOCKnode", 
[10:34:04.791]                             "SOCK0node"))) {
[10:34:04.791]                             sendCondition <<- function(cond) {
[10:34:04.791]                               data <- list(type = "VALUE", value = cond, 
[10:34:04.791]                                 success = TRUE)
[10:34:04.791]                               parallel_sendData(master, data)
[10:34:04.791]                             }
[10:34:04.791]                             return(sendCondition)
[10:34:04.791]                           }
[10:34:04.791]                         }
[10:34:04.791]                         frame <- frame + 1L
[10:34:04.791]                         envir <- sys.frame(frame)
[10:34:04.791]                       }
[10:34:04.791]                     }
[10:34:04.791]                     sendCondition <<- function(cond) NULL
[10:34:04.791]                   }
[10:34:04.791]                 })
[10:34:04.791]                 withCallingHandlers({
[10:34:04.791]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:34:04.791]                 }, immediateCondition = function(cond) {
[10:34:04.791]                   sendCondition <- ...future.makeSendCondition()
[10:34:04.791]                   sendCondition(cond)
[10:34:04.791]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:04.791]                   {
[10:34:04.791]                     inherits <- base::inherits
[10:34:04.791]                     invokeRestart <- base::invokeRestart
[10:34:04.791]                     is.null <- base::is.null
[10:34:04.791]                     muffled <- FALSE
[10:34:04.791]                     if (inherits(cond, "message")) {
[10:34:04.791]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:04.791]                       if (muffled) 
[10:34:04.791]                         invokeRestart("muffleMessage")
[10:34:04.791]                     }
[10:34:04.791]                     else if (inherits(cond, "warning")) {
[10:34:04.791]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:04.791]                       if (muffled) 
[10:34:04.791]                         invokeRestart("muffleWarning")
[10:34:04.791]                     }
[10:34:04.791]                     else if (inherits(cond, "condition")) {
[10:34:04.791]                       if (!is.null(pattern)) {
[10:34:04.791]                         computeRestarts <- base::computeRestarts
[10:34:04.791]                         grepl <- base::grepl
[10:34:04.791]                         restarts <- computeRestarts(cond)
[10:34:04.791]                         for (restart in restarts) {
[10:34:04.791]                           name <- restart$name
[10:34:04.791]                           if (is.null(name)) 
[10:34:04.791]                             next
[10:34:04.791]                           if (!grepl(pattern, name)) 
[10:34:04.791]                             next
[10:34:04.791]                           invokeRestart(restart)
[10:34:04.791]                           muffled <- TRUE
[10:34:04.791]                           break
[10:34:04.791]                         }
[10:34:04.791]                       }
[10:34:04.791]                     }
[10:34:04.791]                     invisible(muffled)
[10:34:04.791]                   }
[10:34:04.791]                   muffleCondition(cond)
[10:34:04.791]                 })
[10:34:04.791]             }))
[10:34:04.791]             future::FutureResult(value = ...future.value$value, 
[10:34:04.791]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:04.791]                   ...future.rng), globalenv = if (FALSE) 
[10:34:04.791]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:04.791]                     ...future.globalenv.names))
[10:34:04.791]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:04.791]         }, condition = base::local({
[10:34:04.791]             c <- base::c
[10:34:04.791]             inherits <- base::inherits
[10:34:04.791]             invokeRestart <- base::invokeRestart
[10:34:04.791]             length <- base::length
[10:34:04.791]             list <- base::list
[10:34:04.791]             seq.int <- base::seq.int
[10:34:04.791]             signalCondition <- base::signalCondition
[10:34:04.791]             sys.calls <- base::sys.calls
[10:34:04.791]             `[[` <- base::`[[`
[10:34:04.791]             `+` <- base::`+`
[10:34:04.791]             `<<-` <- base::`<<-`
[10:34:04.791]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:04.791]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:04.791]                   3L)]
[10:34:04.791]             }
[10:34:04.791]             function(cond) {
[10:34:04.791]                 is_error <- inherits(cond, "error")
[10:34:04.791]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:04.791]                   NULL)
[10:34:04.791]                 if (is_error) {
[10:34:04.791]                   sessionInformation <- function() {
[10:34:04.791]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:04.791]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:04.791]                       search = base::search(), system = base::Sys.info())
[10:34:04.791]                   }
[10:34:04.791]                   ...future.conditions[[length(...future.conditions) + 
[10:34:04.791]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:04.791]                     cond$call), session = sessionInformation(), 
[10:34:04.791]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:04.791]                   signalCondition(cond)
[10:34:04.791]                 }
[10:34:04.791]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:04.791]                 "immediateCondition"))) {
[10:34:04.791]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:04.791]                   ...future.conditions[[length(...future.conditions) + 
[10:34:04.791]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:04.791]                   if (TRUE && !signal) {
[10:34:04.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:04.791]                     {
[10:34:04.791]                       inherits <- base::inherits
[10:34:04.791]                       invokeRestart <- base::invokeRestart
[10:34:04.791]                       is.null <- base::is.null
[10:34:04.791]                       muffled <- FALSE
[10:34:04.791]                       if (inherits(cond, "message")) {
[10:34:04.791]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:04.791]                         if (muffled) 
[10:34:04.791]                           invokeRestart("muffleMessage")
[10:34:04.791]                       }
[10:34:04.791]                       else if (inherits(cond, "warning")) {
[10:34:04.791]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:04.791]                         if (muffled) 
[10:34:04.791]                           invokeRestart("muffleWarning")
[10:34:04.791]                       }
[10:34:04.791]                       else if (inherits(cond, "condition")) {
[10:34:04.791]                         if (!is.null(pattern)) {
[10:34:04.791]                           computeRestarts <- base::computeRestarts
[10:34:04.791]                           grepl <- base::grepl
[10:34:04.791]                           restarts <- computeRestarts(cond)
[10:34:04.791]                           for (restart in restarts) {
[10:34:04.791]                             name <- restart$name
[10:34:04.791]                             if (is.null(name)) 
[10:34:04.791]                               next
[10:34:04.791]                             if (!grepl(pattern, name)) 
[10:34:04.791]                               next
[10:34:04.791]                             invokeRestart(restart)
[10:34:04.791]                             muffled <- TRUE
[10:34:04.791]                             break
[10:34:04.791]                           }
[10:34:04.791]                         }
[10:34:04.791]                       }
[10:34:04.791]                       invisible(muffled)
[10:34:04.791]                     }
[10:34:04.791]                     muffleCondition(cond, pattern = "^muffle")
[10:34:04.791]                   }
[10:34:04.791]                 }
[10:34:04.791]                 else {
[10:34:04.791]                   if (TRUE) {
[10:34:04.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:04.791]                     {
[10:34:04.791]                       inherits <- base::inherits
[10:34:04.791]                       invokeRestart <- base::invokeRestart
[10:34:04.791]                       is.null <- base::is.null
[10:34:04.791]                       muffled <- FALSE
[10:34:04.791]                       if (inherits(cond, "message")) {
[10:34:04.791]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:04.791]                         if (muffled) 
[10:34:04.791]                           invokeRestart("muffleMessage")
[10:34:04.791]                       }
[10:34:04.791]                       else if (inherits(cond, "warning")) {
[10:34:04.791]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:04.791]                         if (muffled) 
[10:34:04.791]                           invokeRestart("muffleWarning")
[10:34:04.791]                       }
[10:34:04.791]                       else if (inherits(cond, "condition")) {
[10:34:04.791]                         if (!is.null(pattern)) {
[10:34:04.791]                           computeRestarts <- base::computeRestarts
[10:34:04.791]                           grepl <- base::grepl
[10:34:04.791]                           restarts <- computeRestarts(cond)
[10:34:04.791]                           for (restart in restarts) {
[10:34:04.791]                             name <- restart$name
[10:34:04.791]                             if (is.null(name)) 
[10:34:04.791]                               next
[10:34:04.791]                             if (!grepl(pattern, name)) 
[10:34:04.791]                               next
[10:34:04.791]                             invokeRestart(restart)
[10:34:04.791]                             muffled <- TRUE
[10:34:04.791]                             break
[10:34:04.791]                           }
[10:34:04.791]                         }
[10:34:04.791]                       }
[10:34:04.791]                       invisible(muffled)
[10:34:04.791]                     }
[10:34:04.791]                     muffleCondition(cond, pattern = "^muffle")
[10:34:04.791]                   }
[10:34:04.791]                 }
[10:34:04.791]             }
[10:34:04.791]         }))
[10:34:04.791]     }, error = function(ex) {
[10:34:04.791]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:04.791]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:04.791]                 ...future.rng), started = ...future.startTime, 
[10:34:04.791]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:04.791]             version = "1.8"), class = "FutureResult")
[10:34:04.791]     }, finally = {
[10:34:04.791]         if (!identical(...future.workdir, getwd())) 
[10:34:04.791]             setwd(...future.workdir)
[10:34:04.791]         {
[10:34:04.791]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:04.791]                 ...future.oldOptions$nwarnings <- NULL
[10:34:04.791]             }
[10:34:04.791]             base::options(...future.oldOptions)
[10:34:04.791]             if (.Platform$OS.type == "windows") {
[10:34:04.791]                 old_names <- names(...future.oldEnvVars)
[10:34:04.791]                 envs <- base::Sys.getenv()
[10:34:04.791]                 names <- names(envs)
[10:34:04.791]                 common <- intersect(names, old_names)
[10:34:04.791]                 added <- setdiff(names, old_names)
[10:34:04.791]                 removed <- setdiff(old_names, names)
[10:34:04.791]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:04.791]                   envs[common]]
[10:34:04.791]                 NAMES <- toupper(changed)
[10:34:04.791]                 args <- list()
[10:34:04.791]                 for (kk in seq_along(NAMES)) {
[10:34:04.791]                   name <- changed[[kk]]
[10:34:04.791]                   NAME <- NAMES[[kk]]
[10:34:04.791]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:04.791]                     next
[10:34:04.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:04.791]                 }
[10:34:04.791]                 NAMES <- toupper(added)
[10:34:04.791]                 for (kk in seq_along(NAMES)) {
[10:34:04.791]                   name <- added[[kk]]
[10:34:04.791]                   NAME <- NAMES[[kk]]
[10:34:04.791]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:04.791]                     next
[10:34:04.791]                   args[[name]] <- ""
[10:34:04.791]                 }
[10:34:04.791]                 NAMES <- toupper(removed)
[10:34:04.791]                 for (kk in seq_along(NAMES)) {
[10:34:04.791]                   name <- removed[[kk]]
[10:34:04.791]                   NAME <- NAMES[[kk]]
[10:34:04.791]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:04.791]                     next
[10:34:04.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:04.791]                 }
[10:34:04.791]                 if (length(args) > 0) 
[10:34:04.791]                   base::do.call(base::Sys.setenv, args = args)
[10:34:04.791]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:04.791]             }
[10:34:04.791]             else {
[10:34:04.791]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:04.791]             }
[10:34:04.791]             {
[10:34:04.791]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:04.791]                   0L) {
[10:34:04.791]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:04.791]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:04.791]                   base::options(opts)
[10:34:04.791]                 }
[10:34:04.791]                 {
[10:34:04.791]                   {
[10:34:04.791]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:04.791]                     NULL
[10:34:04.791]                   }
[10:34:04.791]                   options(future.plan = NULL)
[10:34:04.791]                   if (is.na(NA_character_)) 
[10:34:04.791]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:04.791]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:04.791]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:04.791]                     .init = FALSE)
[10:34:04.791]                 }
[10:34:04.791]             }
[10:34:04.791]         }
[10:34:04.791]     })
[10:34:04.791]     if (TRUE) {
[10:34:04.791]         base::sink(type = "output", split = FALSE)
[10:34:04.791]         if (TRUE) {
[10:34:04.791]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:04.791]         }
[10:34:04.791]         else {
[10:34:04.791]             ...future.result["stdout"] <- base::list(NULL)
[10:34:04.791]         }
[10:34:04.791]         base::close(...future.stdout)
[10:34:04.791]         ...future.stdout <- NULL
[10:34:04.791]     }
[10:34:04.791]     ...future.result$conditions <- ...future.conditions
[10:34:04.791]     ...future.result$finished <- base::Sys.time()
[10:34:04.791]     ...future.result
[10:34:04.791] }
[10:34:04.794] MultisessionFuture started
[10:34:04.796] - Launch lazy future ... done
[10:34:04.796] run() for ‘MultisessionFuture’ ... done
[10:34:04.797] receiveMessageFromWorker() for ClusterFuture ...
[10:34:04.797] - Validating connection of MultisessionFuture
[10:34:04.797] - received message: FutureResult
[10:34:04.797] - Received FutureResult
[10:34:04.797] - Erased future from FutureRegistry
[10:34:04.798] result() for ClusterFuture ...
[10:34:04.798] - result already collected: FutureResult
[10:34:04.798] result() for ClusterFuture ... done
[10:34:04.798] signalConditions() ...
[10:34:04.798]  - include = ‘immediateCondition’
[10:34:04.798]  - exclude = 
[10:34:04.798]  - resignal = FALSE
[10:34:04.798]  - Number of conditions: 1
[10:34:04.798] signalConditions() ... done
[10:34:04.798] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:04.798] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = TRUE ... DONE
- result = FALSE, recursive = -1 ...
[10:34:04.799] getGlobalsAndPackages() ...
[10:34:04.799] Searching for globals...
[10:34:04.800] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:34:04.800] Searching for globals ... DONE
[10:34:04.800] Resolving globals: FALSE
[10:34:04.800] 
[10:34:04.800] 
[10:34:04.800] getGlobalsAndPackages() ... DONE
[10:34:04.801] run() for ‘Future’ ...
[10:34:04.801] - state: ‘created’
[10:34:04.801] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:04.814] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:04.814] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:04.814]   - Field: ‘node’
[10:34:04.814]   - Field: ‘label’
[10:34:04.815]   - Field: ‘local’
[10:34:04.815]   - Field: ‘owner’
[10:34:04.815]   - Field: ‘envir’
[10:34:04.815]   - Field: ‘workers’
[10:34:04.815]   - Field: ‘packages’
[10:34:04.815]   - Field: ‘gc’
[10:34:04.815]   - Field: ‘conditions’
[10:34:04.815]   - Field: ‘persistent’
[10:34:04.815]   - Field: ‘expr’
[10:34:04.815]   - Field: ‘uuid’
[10:34:04.815]   - Field: ‘seed’
[10:34:04.816]   - Field: ‘version’
[10:34:04.816]   - Field: ‘result’
[10:34:04.816]   - Field: ‘asynchronous’
[10:34:04.816]   - Field: ‘calls’
[10:34:04.816]   - Field: ‘globals’
[10:34:04.816]   - Field: ‘stdout’
[10:34:04.816]   - Field: ‘earlySignal’
[10:34:04.816]   - Field: ‘lazy’
[10:34:04.816]   - Field: ‘state’
[10:34:04.816] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:04.816] - Launch lazy future ...
[10:34:04.817] Packages needed by the future expression (n = 0): <none>
[10:34:04.817] Packages needed by future strategies (n = 0): <none>
[10:34:04.817] {
[10:34:04.817]     {
[10:34:04.817]         {
[10:34:04.817]             ...future.startTime <- base::Sys.time()
[10:34:04.817]             {
[10:34:04.817]                 {
[10:34:04.817]                   {
[10:34:04.817]                     {
[10:34:04.817]                       base::local({
[10:34:04.817]                         has_future <- base::requireNamespace("future", 
[10:34:04.817]                           quietly = TRUE)
[10:34:04.817]                         if (has_future) {
[10:34:04.817]                           ns <- base::getNamespace("future")
[10:34:04.817]                           version <- ns[[".package"]][["version"]]
[10:34:04.817]                           if (is.null(version)) 
[10:34:04.817]                             version <- utils::packageVersion("future")
[10:34:04.817]                         }
[10:34:04.817]                         else {
[10:34:04.817]                           version <- NULL
[10:34:04.817]                         }
[10:34:04.817]                         if (!has_future || version < "1.8.0") {
[10:34:04.817]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:04.817]                             "", base::R.version$version.string), 
[10:34:04.817]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:04.817]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:04.817]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:04.817]                               "release", "version")], collapse = " "), 
[10:34:04.817]                             hostname = base::Sys.info()[["nodename"]])
[10:34:04.817]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:04.817]                             info)
[10:34:04.817]                           info <- base::paste(info, collapse = "; ")
[10:34:04.817]                           if (!has_future) {
[10:34:04.817]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:04.817]                               info)
[10:34:04.817]                           }
[10:34:04.817]                           else {
[10:34:04.817]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:04.817]                               info, version)
[10:34:04.817]                           }
[10:34:04.817]                           base::stop(msg)
[10:34:04.817]                         }
[10:34:04.817]                       })
[10:34:04.817]                     }
[10:34:04.817]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:04.817]                     base::options(mc.cores = 1L)
[10:34:04.817]                   }
[10:34:04.817]                   ...future.strategy.old <- future::plan("list")
[10:34:04.817]                   options(future.plan = NULL)
[10:34:04.817]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:04.817]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:04.817]                 }
[10:34:04.817]                 ...future.workdir <- getwd()
[10:34:04.817]             }
[10:34:04.817]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:04.817]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:04.817]         }
[10:34:04.817]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:04.817]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:04.817]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:04.817]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:04.817]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:04.817]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:04.817]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:04.817]             base::names(...future.oldOptions))
[10:34:04.817]     }
[10:34:04.817]     if (FALSE) {
[10:34:04.817]     }
[10:34:04.817]     else {
[10:34:04.817]         if (TRUE) {
[10:34:04.817]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:04.817]                 open = "w")
[10:34:04.817]         }
[10:34:04.817]         else {
[10:34:04.817]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:04.817]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:04.817]         }
[10:34:04.817]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:04.817]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:04.817]             base::sink(type = "output", split = FALSE)
[10:34:04.817]             base::close(...future.stdout)
[10:34:04.817]         }, add = TRUE)
[10:34:04.817]     }
[10:34:04.817]     ...future.frame <- base::sys.nframe()
[10:34:04.817]     ...future.conditions <- base::list()
[10:34:04.817]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:04.817]     if (FALSE) {
[10:34:04.817]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:04.817]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:04.817]     }
[10:34:04.817]     ...future.result <- base::tryCatch({
[10:34:04.817]         base::withCallingHandlers({
[10:34:04.817]             ...future.value <- base::withVisible(base::local({
[10:34:04.817]                 ...future.makeSendCondition <- base::local({
[10:34:04.817]                   sendCondition <- NULL
[10:34:04.817]                   function(frame = 1L) {
[10:34:04.817]                     if (is.function(sendCondition)) 
[10:34:04.817]                       return(sendCondition)
[10:34:04.817]                     ns <- getNamespace("parallel")
[10:34:04.817]                     if (exists("sendData", mode = "function", 
[10:34:04.817]                       envir = ns)) {
[10:34:04.817]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:04.817]                         envir = ns)
[10:34:04.817]                       envir <- sys.frame(frame)
[10:34:04.817]                       master <- NULL
[10:34:04.817]                       while (!identical(envir, .GlobalEnv) && 
[10:34:04.817]                         !identical(envir, emptyenv())) {
[10:34:04.817]                         if (exists("master", mode = "list", envir = envir, 
[10:34:04.817]                           inherits = FALSE)) {
[10:34:04.817]                           master <- get("master", mode = "list", 
[10:34:04.817]                             envir = envir, inherits = FALSE)
[10:34:04.817]                           if (inherits(master, c("SOCKnode", 
[10:34:04.817]                             "SOCK0node"))) {
[10:34:04.817]                             sendCondition <<- function(cond) {
[10:34:04.817]                               data <- list(type = "VALUE", value = cond, 
[10:34:04.817]                                 success = TRUE)
[10:34:04.817]                               parallel_sendData(master, data)
[10:34:04.817]                             }
[10:34:04.817]                             return(sendCondition)
[10:34:04.817]                           }
[10:34:04.817]                         }
[10:34:04.817]                         frame <- frame + 1L
[10:34:04.817]                         envir <- sys.frame(frame)
[10:34:04.817]                       }
[10:34:04.817]                     }
[10:34:04.817]                     sendCondition <<- function(cond) NULL
[10:34:04.817]                   }
[10:34:04.817]                 })
[10:34:04.817]                 withCallingHandlers({
[10:34:04.817]                   {
[10:34:04.817]                     Sys.sleep(0.5)
[10:34:04.817]                     list(a = 1, b = 42L)
[10:34:04.817]                   }
[10:34:04.817]                 }, immediateCondition = function(cond) {
[10:34:04.817]                   sendCondition <- ...future.makeSendCondition()
[10:34:04.817]                   sendCondition(cond)
[10:34:04.817]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:04.817]                   {
[10:34:04.817]                     inherits <- base::inherits
[10:34:04.817]                     invokeRestart <- base::invokeRestart
[10:34:04.817]                     is.null <- base::is.null
[10:34:04.817]                     muffled <- FALSE
[10:34:04.817]                     if (inherits(cond, "message")) {
[10:34:04.817]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:04.817]                       if (muffled) 
[10:34:04.817]                         invokeRestart("muffleMessage")
[10:34:04.817]                     }
[10:34:04.817]                     else if (inherits(cond, "warning")) {
[10:34:04.817]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:04.817]                       if (muffled) 
[10:34:04.817]                         invokeRestart("muffleWarning")
[10:34:04.817]                     }
[10:34:04.817]                     else if (inherits(cond, "condition")) {
[10:34:04.817]                       if (!is.null(pattern)) {
[10:34:04.817]                         computeRestarts <- base::computeRestarts
[10:34:04.817]                         grepl <- base::grepl
[10:34:04.817]                         restarts <- computeRestarts(cond)
[10:34:04.817]                         for (restart in restarts) {
[10:34:04.817]                           name <- restart$name
[10:34:04.817]                           if (is.null(name)) 
[10:34:04.817]                             next
[10:34:04.817]                           if (!grepl(pattern, name)) 
[10:34:04.817]                             next
[10:34:04.817]                           invokeRestart(restart)
[10:34:04.817]                           muffled <- TRUE
[10:34:04.817]                           break
[10:34:04.817]                         }
[10:34:04.817]                       }
[10:34:04.817]                     }
[10:34:04.817]                     invisible(muffled)
[10:34:04.817]                   }
[10:34:04.817]                   muffleCondition(cond)
[10:34:04.817]                 })
[10:34:04.817]             }))
[10:34:04.817]             future::FutureResult(value = ...future.value$value, 
[10:34:04.817]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:04.817]                   ...future.rng), globalenv = if (FALSE) 
[10:34:04.817]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:04.817]                     ...future.globalenv.names))
[10:34:04.817]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:04.817]         }, condition = base::local({
[10:34:04.817]             c <- base::c
[10:34:04.817]             inherits <- base::inherits
[10:34:04.817]             invokeRestart <- base::invokeRestart
[10:34:04.817]             length <- base::length
[10:34:04.817]             list <- base::list
[10:34:04.817]             seq.int <- base::seq.int
[10:34:04.817]             signalCondition <- base::signalCondition
[10:34:04.817]             sys.calls <- base::sys.calls
[10:34:04.817]             `[[` <- base::`[[`
[10:34:04.817]             `+` <- base::`+`
[10:34:04.817]             `<<-` <- base::`<<-`
[10:34:04.817]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:04.817]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:04.817]                   3L)]
[10:34:04.817]             }
[10:34:04.817]             function(cond) {
[10:34:04.817]                 is_error <- inherits(cond, "error")
[10:34:04.817]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:04.817]                   NULL)
[10:34:04.817]                 if (is_error) {
[10:34:04.817]                   sessionInformation <- function() {
[10:34:04.817]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:04.817]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:04.817]                       search = base::search(), system = base::Sys.info())
[10:34:04.817]                   }
[10:34:04.817]                   ...future.conditions[[length(...future.conditions) + 
[10:34:04.817]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:04.817]                     cond$call), session = sessionInformation(), 
[10:34:04.817]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:04.817]                   signalCondition(cond)
[10:34:04.817]                 }
[10:34:04.817]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:04.817]                 "immediateCondition"))) {
[10:34:04.817]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:04.817]                   ...future.conditions[[length(...future.conditions) + 
[10:34:04.817]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:04.817]                   if (TRUE && !signal) {
[10:34:04.817]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:04.817]                     {
[10:34:04.817]                       inherits <- base::inherits
[10:34:04.817]                       invokeRestart <- base::invokeRestart
[10:34:04.817]                       is.null <- base::is.null
[10:34:04.817]                       muffled <- FALSE
[10:34:04.817]                       if (inherits(cond, "message")) {
[10:34:04.817]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:04.817]                         if (muffled) 
[10:34:04.817]                           invokeRestart("muffleMessage")
[10:34:04.817]                       }
[10:34:04.817]                       else if (inherits(cond, "warning")) {
[10:34:04.817]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:04.817]                         if (muffled) 
[10:34:04.817]                           invokeRestart("muffleWarning")
[10:34:04.817]                       }
[10:34:04.817]                       else if (inherits(cond, "condition")) {
[10:34:04.817]                         if (!is.null(pattern)) {
[10:34:04.817]                           computeRestarts <- base::computeRestarts
[10:34:04.817]                           grepl <- base::grepl
[10:34:04.817]                           restarts <- computeRestarts(cond)
[10:34:04.817]                           for (restart in restarts) {
[10:34:04.817]                             name <- restart$name
[10:34:04.817]                             if (is.null(name)) 
[10:34:04.817]                               next
[10:34:04.817]                             if (!grepl(pattern, name)) 
[10:34:04.817]                               next
[10:34:04.817]                             invokeRestart(restart)
[10:34:04.817]                             muffled <- TRUE
[10:34:04.817]                             break
[10:34:04.817]                           }
[10:34:04.817]                         }
[10:34:04.817]                       }
[10:34:04.817]                       invisible(muffled)
[10:34:04.817]                     }
[10:34:04.817]                     muffleCondition(cond, pattern = "^muffle")
[10:34:04.817]                   }
[10:34:04.817]                 }
[10:34:04.817]                 else {
[10:34:04.817]                   if (TRUE) {
[10:34:04.817]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:04.817]                     {
[10:34:04.817]                       inherits <- base::inherits
[10:34:04.817]                       invokeRestart <- base::invokeRestart
[10:34:04.817]                       is.null <- base::is.null
[10:34:04.817]                       muffled <- FALSE
[10:34:04.817]                       if (inherits(cond, "message")) {
[10:34:04.817]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:04.817]                         if (muffled) 
[10:34:04.817]                           invokeRestart("muffleMessage")
[10:34:04.817]                       }
[10:34:04.817]                       else if (inherits(cond, "warning")) {
[10:34:04.817]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:04.817]                         if (muffled) 
[10:34:04.817]                           invokeRestart("muffleWarning")
[10:34:04.817]                       }
[10:34:04.817]                       else if (inherits(cond, "condition")) {
[10:34:04.817]                         if (!is.null(pattern)) {
[10:34:04.817]                           computeRestarts <- base::computeRestarts
[10:34:04.817]                           grepl <- base::grepl
[10:34:04.817]                           restarts <- computeRestarts(cond)
[10:34:04.817]                           for (restart in restarts) {
[10:34:04.817]                             name <- restart$name
[10:34:04.817]                             if (is.null(name)) 
[10:34:04.817]                               next
[10:34:04.817]                             if (!grepl(pattern, name)) 
[10:34:04.817]                               next
[10:34:04.817]                             invokeRestart(restart)
[10:34:04.817]                             muffled <- TRUE
[10:34:04.817]                             break
[10:34:04.817]                           }
[10:34:04.817]                         }
[10:34:04.817]                       }
[10:34:04.817]                       invisible(muffled)
[10:34:04.817]                     }
[10:34:04.817]                     muffleCondition(cond, pattern = "^muffle")
[10:34:04.817]                   }
[10:34:04.817]                 }
[10:34:04.817]             }
[10:34:04.817]         }))
[10:34:04.817]     }, error = function(ex) {
[10:34:04.817]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:04.817]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:04.817]                 ...future.rng), started = ...future.startTime, 
[10:34:04.817]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:04.817]             version = "1.8"), class = "FutureResult")
[10:34:04.817]     }, finally = {
[10:34:04.817]         if (!identical(...future.workdir, getwd())) 
[10:34:04.817]             setwd(...future.workdir)
[10:34:04.817]         {
[10:34:04.817]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:04.817]                 ...future.oldOptions$nwarnings <- NULL
[10:34:04.817]             }
[10:34:04.817]             base::options(...future.oldOptions)
[10:34:04.817]             if (.Platform$OS.type == "windows") {
[10:34:04.817]                 old_names <- names(...future.oldEnvVars)
[10:34:04.817]                 envs <- base::Sys.getenv()
[10:34:04.817]                 names <- names(envs)
[10:34:04.817]                 common <- intersect(names, old_names)
[10:34:04.817]                 added <- setdiff(names, old_names)
[10:34:04.817]                 removed <- setdiff(old_names, names)
[10:34:04.817]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:04.817]                   envs[common]]
[10:34:04.817]                 NAMES <- toupper(changed)
[10:34:04.817]                 args <- list()
[10:34:04.817]                 for (kk in seq_along(NAMES)) {
[10:34:04.817]                   name <- changed[[kk]]
[10:34:04.817]                   NAME <- NAMES[[kk]]
[10:34:04.817]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:04.817]                     next
[10:34:04.817]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:04.817]                 }
[10:34:04.817]                 NAMES <- toupper(added)
[10:34:04.817]                 for (kk in seq_along(NAMES)) {
[10:34:04.817]                   name <- added[[kk]]
[10:34:04.817]                   NAME <- NAMES[[kk]]
[10:34:04.817]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:04.817]                     next
[10:34:04.817]                   args[[name]] <- ""
[10:34:04.817]                 }
[10:34:04.817]                 NAMES <- toupper(removed)
[10:34:04.817]                 for (kk in seq_along(NAMES)) {
[10:34:04.817]                   name <- removed[[kk]]
[10:34:04.817]                   NAME <- NAMES[[kk]]
[10:34:04.817]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:04.817]                     next
[10:34:04.817]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:04.817]                 }
[10:34:04.817]                 if (length(args) > 0) 
[10:34:04.817]                   base::do.call(base::Sys.setenv, args = args)
[10:34:04.817]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:04.817]             }
[10:34:04.817]             else {
[10:34:04.817]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:04.817]             }
[10:34:04.817]             {
[10:34:04.817]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:04.817]                   0L) {
[10:34:04.817]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:04.817]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:04.817]                   base::options(opts)
[10:34:04.817]                 }
[10:34:04.817]                 {
[10:34:04.817]                   {
[10:34:04.817]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:04.817]                     NULL
[10:34:04.817]                   }
[10:34:04.817]                   options(future.plan = NULL)
[10:34:04.817]                   if (is.na(NA_character_)) 
[10:34:04.817]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:04.817]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:04.817]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:04.817]                     .init = FALSE)
[10:34:04.817]                 }
[10:34:04.817]             }
[10:34:04.817]         }
[10:34:04.817]     })
[10:34:04.817]     if (TRUE) {
[10:34:04.817]         base::sink(type = "output", split = FALSE)
[10:34:04.817]         if (TRUE) {
[10:34:04.817]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:04.817]         }
[10:34:04.817]         else {
[10:34:04.817]             ...future.result["stdout"] <- base::list(NULL)
[10:34:04.817]         }
[10:34:04.817]         base::close(...future.stdout)
[10:34:04.817]         ...future.stdout <- NULL
[10:34:04.817]     }
[10:34:04.817]     ...future.result$conditions <- ...future.conditions
[10:34:04.817]     ...future.result$finished <- base::Sys.time()
[10:34:04.817]     ...future.result
[10:34:04.817] }
[10:34:04.820] MultisessionFuture started
[10:34:04.820] - Launch lazy future ... done
[10:34:04.820] run() for ‘MultisessionFuture’ ... done
[10:34:04.820] getGlobalsAndPackages() ...
[10:34:04.820] Searching for globals...
[10:34:04.821] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:34:04.821] Searching for globals ... DONE
[10:34:04.822] Resolving globals: FALSE
[10:34:04.822] 
[10:34:04.822] 
[10:34:04.822] getGlobalsAndPackages() ... DONE
- w/ exception ...
[10:34:04.822] getGlobalsAndPackages() ...
[10:34:04.822] Searching for globals...
[10:34:04.823] - globals found: [2] ‘list’, ‘stop’
[10:34:04.823] Searching for globals ... DONE
[10:34:04.823] Resolving globals: FALSE
[10:34:04.823] 
[10:34:04.823] 
[10:34:04.824] getGlobalsAndPackages() ... DONE
[10:34:04.824] run() for ‘Future’ ...
[10:34:04.824] - state: ‘created’
[10:34:04.824] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:04.837] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:04.838] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:04.838]   - Field: ‘node’
[10:34:04.838]   - Field: ‘label’
[10:34:04.838]   - Field: ‘local’
[10:34:04.838]   - Field: ‘owner’
[10:34:04.838]   - Field: ‘envir’
[10:34:04.838]   - Field: ‘workers’
[10:34:04.838]   - Field: ‘packages’
[10:34:04.838]   - Field: ‘gc’
[10:34:04.838]   - Field: ‘conditions’
[10:34:04.838]   - Field: ‘persistent’
[10:34:04.839]   - Field: ‘expr’
[10:34:04.839]   - Field: ‘uuid’
[10:34:04.839]   - Field: ‘seed’
[10:34:04.839]   - Field: ‘version’
[10:34:04.839]   - Field: ‘result’
[10:34:04.839]   - Field: ‘asynchronous’
[10:34:04.839]   - Field: ‘calls’
[10:34:04.839]   - Field: ‘globals’
[10:34:04.839]   - Field: ‘stdout’
[10:34:04.839]   - Field: ‘earlySignal’
[10:34:04.839]   - Field: ‘lazy’
[10:34:04.840]   - Field: ‘state’
[10:34:04.840] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:04.840] - Launch lazy future ...
[10:34:04.840] Packages needed by the future expression (n = 0): <none>
[10:34:04.840] Packages needed by future strategies (n = 0): <none>
[10:34:04.840] {
[10:34:04.840]     {
[10:34:04.840]         {
[10:34:04.840]             ...future.startTime <- base::Sys.time()
[10:34:04.840]             {
[10:34:04.840]                 {
[10:34:04.840]                   {
[10:34:04.840]                     {
[10:34:04.840]                       base::local({
[10:34:04.840]                         has_future <- base::requireNamespace("future", 
[10:34:04.840]                           quietly = TRUE)
[10:34:04.840]                         if (has_future) {
[10:34:04.840]                           ns <- base::getNamespace("future")
[10:34:04.840]                           version <- ns[[".package"]][["version"]]
[10:34:04.840]                           if (is.null(version)) 
[10:34:04.840]                             version <- utils::packageVersion("future")
[10:34:04.840]                         }
[10:34:04.840]                         else {
[10:34:04.840]                           version <- NULL
[10:34:04.840]                         }
[10:34:04.840]                         if (!has_future || version < "1.8.0") {
[10:34:04.840]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:04.840]                             "", base::R.version$version.string), 
[10:34:04.840]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:04.840]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:04.840]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:04.840]                               "release", "version")], collapse = " "), 
[10:34:04.840]                             hostname = base::Sys.info()[["nodename"]])
[10:34:04.840]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:04.840]                             info)
[10:34:04.840]                           info <- base::paste(info, collapse = "; ")
[10:34:04.840]                           if (!has_future) {
[10:34:04.840]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:04.840]                               info)
[10:34:04.840]                           }
[10:34:04.840]                           else {
[10:34:04.840]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:04.840]                               info, version)
[10:34:04.840]                           }
[10:34:04.840]                           base::stop(msg)
[10:34:04.840]                         }
[10:34:04.840]                       })
[10:34:04.840]                     }
[10:34:04.840]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:04.840]                     base::options(mc.cores = 1L)
[10:34:04.840]                   }
[10:34:04.840]                   ...future.strategy.old <- future::plan("list")
[10:34:04.840]                   options(future.plan = NULL)
[10:34:04.840]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:04.840]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:04.840]                 }
[10:34:04.840]                 ...future.workdir <- getwd()
[10:34:04.840]             }
[10:34:04.840]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:04.840]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:04.840]         }
[10:34:04.840]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:04.840]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:04.840]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:04.840]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:04.840]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:04.840]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:04.840]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:04.840]             base::names(...future.oldOptions))
[10:34:04.840]     }
[10:34:04.840]     if (FALSE) {
[10:34:04.840]     }
[10:34:04.840]     else {
[10:34:04.840]         if (TRUE) {
[10:34:04.840]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:04.840]                 open = "w")
[10:34:04.840]         }
[10:34:04.840]         else {
[10:34:04.840]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:04.840]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:04.840]         }
[10:34:04.840]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:04.840]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:04.840]             base::sink(type = "output", split = FALSE)
[10:34:04.840]             base::close(...future.stdout)
[10:34:04.840]         }, add = TRUE)
[10:34:04.840]     }
[10:34:04.840]     ...future.frame <- base::sys.nframe()
[10:34:04.840]     ...future.conditions <- base::list()
[10:34:04.840]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:04.840]     if (FALSE) {
[10:34:04.840]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:04.840]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:04.840]     }
[10:34:04.840]     ...future.result <- base::tryCatch({
[10:34:04.840]         base::withCallingHandlers({
[10:34:04.840]             ...future.value <- base::withVisible(base::local({
[10:34:04.840]                 ...future.makeSendCondition <- base::local({
[10:34:04.840]                   sendCondition <- NULL
[10:34:04.840]                   function(frame = 1L) {
[10:34:04.840]                     if (is.function(sendCondition)) 
[10:34:04.840]                       return(sendCondition)
[10:34:04.840]                     ns <- getNamespace("parallel")
[10:34:04.840]                     if (exists("sendData", mode = "function", 
[10:34:04.840]                       envir = ns)) {
[10:34:04.840]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:04.840]                         envir = ns)
[10:34:04.840]                       envir <- sys.frame(frame)
[10:34:04.840]                       master <- NULL
[10:34:04.840]                       while (!identical(envir, .GlobalEnv) && 
[10:34:04.840]                         !identical(envir, emptyenv())) {
[10:34:04.840]                         if (exists("master", mode = "list", envir = envir, 
[10:34:04.840]                           inherits = FALSE)) {
[10:34:04.840]                           master <- get("master", mode = "list", 
[10:34:04.840]                             envir = envir, inherits = FALSE)
[10:34:04.840]                           if (inherits(master, c("SOCKnode", 
[10:34:04.840]                             "SOCK0node"))) {
[10:34:04.840]                             sendCondition <<- function(cond) {
[10:34:04.840]                               data <- list(type = "VALUE", value = cond, 
[10:34:04.840]                                 success = TRUE)
[10:34:04.840]                               parallel_sendData(master, data)
[10:34:04.840]                             }
[10:34:04.840]                             return(sendCondition)
[10:34:04.840]                           }
[10:34:04.840]                         }
[10:34:04.840]                         frame <- frame + 1L
[10:34:04.840]                         envir <- sys.frame(frame)
[10:34:04.840]                       }
[10:34:04.840]                     }
[10:34:04.840]                     sendCondition <<- function(cond) NULL
[10:34:04.840]                   }
[10:34:04.840]                 })
[10:34:04.840]                 withCallingHandlers({
[10:34:04.840]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:34:04.840]                 }, immediateCondition = function(cond) {
[10:34:04.840]                   sendCondition <- ...future.makeSendCondition()
[10:34:04.840]                   sendCondition(cond)
[10:34:04.840]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:04.840]                   {
[10:34:04.840]                     inherits <- base::inherits
[10:34:04.840]                     invokeRestart <- base::invokeRestart
[10:34:04.840]                     is.null <- base::is.null
[10:34:04.840]                     muffled <- FALSE
[10:34:04.840]                     if (inherits(cond, "message")) {
[10:34:04.840]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:04.840]                       if (muffled) 
[10:34:04.840]                         invokeRestart("muffleMessage")
[10:34:04.840]                     }
[10:34:04.840]                     else if (inherits(cond, "warning")) {
[10:34:04.840]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:04.840]                       if (muffled) 
[10:34:04.840]                         invokeRestart("muffleWarning")
[10:34:04.840]                     }
[10:34:04.840]                     else if (inherits(cond, "condition")) {
[10:34:04.840]                       if (!is.null(pattern)) {
[10:34:04.840]                         computeRestarts <- base::computeRestarts
[10:34:04.840]                         grepl <- base::grepl
[10:34:04.840]                         restarts <- computeRestarts(cond)
[10:34:04.840]                         for (restart in restarts) {
[10:34:04.840]                           name <- restart$name
[10:34:04.840]                           if (is.null(name)) 
[10:34:04.840]                             next
[10:34:04.840]                           if (!grepl(pattern, name)) 
[10:34:04.840]                             next
[10:34:04.840]                           invokeRestart(restart)
[10:34:04.840]                           muffled <- TRUE
[10:34:04.840]                           break
[10:34:04.840]                         }
[10:34:04.840]                       }
[10:34:04.840]                     }
[10:34:04.840]                     invisible(muffled)
[10:34:04.840]                   }
[10:34:04.840]                   muffleCondition(cond)
[10:34:04.840]                 })
[10:34:04.840]             }))
[10:34:04.840]             future::FutureResult(value = ...future.value$value, 
[10:34:04.840]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:04.840]                   ...future.rng), globalenv = if (FALSE) 
[10:34:04.840]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:04.840]                     ...future.globalenv.names))
[10:34:04.840]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:04.840]         }, condition = base::local({
[10:34:04.840]             c <- base::c
[10:34:04.840]             inherits <- base::inherits
[10:34:04.840]             invokeRestart <- base::invokeRestart
[10:34:04.840]             length <- base::length
[10:34:04.840]             list <- base::list
[10:34:04.840]             seq.int <- base::seq.int
[10:34:04.840]             signalCondition <- base::signalCondition
[10:34:04.840]             sys.calls <- base::sys.calls
[10:34:04.840]             `[[` <- base::`[[`
[10:34:04.840]             `+` <- base::`+`
[10:34:04.840]             `<<-` <- base::`<<-`
[10:34:04.840]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:04.840]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:04.840]                   3L)]
[10:34:04.840]             }
[10:34:04.840]             function(cond) {
[10:34:04.840]                 is_error <- inherits(cond, "error")
[10:34:04.840]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:04.840]                   NULL)
[10:34:04.840]                 if (is_error) {
[10:34:04.840]                   sessionInformation <- function() {
[10:34:04.840]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:04.840]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:04.840]                       search = base::search(), system = base::Sys.info())
[10:34:04.840]                   }
[10:34:04.840]                   ...future.conditions[[length(...future.conditions) + 
[10:34:04.840]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:04.840]                     cond$call), session = sessionInformation(), 
[10:34:04.840]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:04.840]                   signalCondition(cond)
[10:34:04.840]                 }
[10:34:04.840]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:04.840]                 "immediateCondition"))) {
[10:34:04.840]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:04.840]                   ...future.conditions[[length(...future.conditions) + 
[10:34:04.840]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:04.840]                   if (TRUE && !signal) {
[10:34:04.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:04.840]                     {
[10:34:04.840]                       inherits <- base::inherits
[10:34:04.840]                       invokeRestart <- base::invokeRestart
[10:34:04.840]                       is.null <- base::is.null
[10:34:04.840]                       muffled <- FALSE
[10:34:04.840]                       if (inherits(cond, "message")) {
[10:34:04.840]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:04.840]                         if (muffled) 
[10:34:04.840]                           invokeRestart("muffleMessage")
[10:34:04.840]                       }
[10:34:04.840]                       else if (inherits(cond, "warning")) {
[10:34:04.840]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:04.840]                         if (muffled) 
[10:34:04.840]                           invokeRestart("muffleWarning")
[10:34:04.840]                       }
[10:34:04.840]                       else if (inherits(cond, "condition")) {
[10:34:04.840]                         if (!is.null(pattern)) {
[10:34:04.840]                           computeRestarts <- base::computeRestarts
[10:34:04.840]                           grepl <- base::grepl
[10:34:04.840]                           restarts <- computeRestarts(cond)
[10:34:04.840]                           for (restart in restarts) {
[10:34:04.840]                             name <- restart$name
[10:34:04.840]                             if (is.null(name)) 
[10:34:04.840]                               next
[10:34:04.840]                             if (!grepl(pattern, name)) 
[10:34:04.840]                               next
[10:34:04.840]                             invokeRestart(restart)
[10:34:04.840]                             muffled <- TRUE
[10:34:04.840]                             break
[10:34:04.840]                           }
[10:34:04.840]                         }
[10:34:04.840]                       }
[10:34:04.840]                       invisible(muffled)
[10:34:04.840]                     }
[10:34:04.840]                     muffleCondition(cond, pattern = "^muffle")
[10:34:04.840]                   }
[10:34:04.840]                 }
[10:34:04.840]                 else {
[10:34:04.840]                   if (TRUE) {
[10:34:04.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:04.840]                     {
[10:34:04.840]                       inherits <- base::inherits
[10:34:04.840]                       invokeRestart <- base::invokeRestart
[10:34:04.840]                       is.null <- base::is.null
[10:34:04.840]                       muffled <- FALSE
[10:34:04.840]                       if (inherits(cond, "message")) {
[10:34:04.840]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:04.840]                         if (muffled) 
[10:34:04.840]                           invokeRestart("muffleMessage")
[10:34:04.840]                       }
[10:34:04.840]                       else if (inherits(cond, "warning")) {
[10:34:04.840]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:04.840]                         if (muffled) 
[10:34:04.840]                           invokeRestart("muffleWarning")
[10:34:04.840]                       }
[10:34:04.840]                       else if (inherits(cond, "condition")) {
[10:34:04.840]                         if (!is.null(pattern)) {
[10:34:04.840]                           computeRestarts <- base::computeRestarts
[10:34:04.840]                           grepl <- base::grepl
[10:34:04.840]                           restarts <- computeRestarts(cond)
[10:34:04.840]                           for (restart in restarts) {
[10:34:04.840]                             name <- restart$name
[10:34:04.840]                             if (is.null(name)) 
[10:34:04.840]                               next
[10:34:04.840]                             if (!grepl(pattern, name)) 
[10:34:04.840]                               next
[10:34:04.840]                             invokeRestart(restart)
[10:34:04.840]                             muffled <- TRUE
[10:34:04.840]                             break
[10:34:04.840]                           }
[10:34:04.840]                         }
[10:34:04.840]                       }
[10:34:04.840]                       invisible(muffled)
[10:34:04.840]                     }
[10:34:04.840]                     muffleCondition(cond, pattern = "^muffle")
[10:34:04.840]                   }
[10:34:04.840]                 }
[10:34:04.840]             }
[10:34:04.840]         }))
[10:34:04.840]     }, error = function(ex) {
[10:34:04.840]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:04.840]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:04.840]                 ...future.rng), started = ...future.startTime, 
[10:34:04.840]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:04.840]             version = "1.8"), class = "FutureResult")
[10:34:04.840]     }, finally = {
[10:34:04.840]         if (!identical(...future.workdir, getwd())) 
[10:34:04.840]             setwd(...future.workdir)
[10:34:04.840]         {
[10:34:04.840]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:04.840]                 ...future.oldOptions$nwarnings <- NULL
[10:34:04.840]             }
[10:34:04.840]             base::options(...future.oldOptions)
[10:34:04.840]             if (.Platform$OS.type == "windows") {
[10:34:04.840]                 old_names <- names(...future.oldEnvVars)
[10:34:04.840]                 envs <- base::Sys.getenv()
[10:34:04.840]                 names <- names(envs)
[10:34:04.840]                 common <- intersect(names, old_names)
[10:34:04.840]                 added <- setdiff(names, old_names)
[10:34:04.840]                 removed <- setdiff(old_names, names)
[10:34:04.840]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:04.840]                   envs[common]]
[10:34:04.840]                 NAMES <- toupper(changed)
[10:34:04.840]                 args <- list()
[10:34:04.840]                 for (kk in seq_along(NAMES)) {
[10:34:04.840]                   name <- changed[[kk]]
[10:34:04.840]                   NAME <- NAMES[[kk]]
[10:34:04.840]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:04.840]                     next
[10:34:04.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:04.840]                 }
[10:34:04.840]                 NAMES <- toupper(added)
[10:34:04.840]                 for (kk in seq_along(NAMES)) {
[10:34:04.840]                   name <- added[[kk]]
[10:34:04.840]                   NAME <- NAMES[[kk]]
[10:34:04.840]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:04.840]                     next
[10:34:04.840]                   args[[name]] <- ""
[10:34:04.840]                 }
[10:34:04.840]                 NAMES <- toupper(removed)
[10:34:04.840]                 for (kk in seq_along(NAMES)) {
[10:34:04.840]                   name <- removed[[kk]]
[10:34:04.840]                   NAME <- NAMES[[kk]]
[10:34:04.840]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:04.840]                     next
[10:34:04.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:04.840]                 }
[10:34:04.840]                 if (length(args) > 0) 
[10:34:04.840]                   base::do.call(base::Sys.setenv, args = args)
[10:34:04.840]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:04.840]             }
[10:34:04.840]             else {
[10:34:04.840]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:04.840]             }
[10:34:04.840]             {
[10:34:04.840]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:04.840]                   0L) {
[10:34:04.840]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:04.840]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:04.840]                   base::options(opts)
[10:34:04.840]                 }
[10:34:04.840]                 {
[10:34:04.840]                   {
[10:34:04.840]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:04.840]                     NULL
[10:34:04.840]                   }
[10:34:04.840]                   options(future.plan = NULL)
[10:34:04.840]                   if (is.na(NA_character_)) 
[10:34:04.840]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:04.840]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:04.840]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:04.840]                     .init = FALSE)
[10:34:04.840]                 }
[10:34:04.840]             }
[10:34:04.840]         }
[10:34:04.840]     })
[10:34:04.840]     if (TRUE) {
[10:34:04.840]         base::sink(type = "output", split = FALSE)
[10:34:04.840]         if (TRUE) {
[10:34:04.840]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:04.840]         }
[10:34:04.840]         else {
[10:34:04.840]             ...future.result["stdout"] <- base::list(NULL)
[10:34:04.840]         }
[10:34:04.840]         base::close(...future.stdout)
[10:34:04.840]         ...future.stdout <- NULL
[10:34:04.840]     }
[10:34:04.840]     ...future.result$conditions <- ...future.conditions
[10:34:04.840]     ...future.result$finished <- base::Sys.time()
[10:34:04.840]     ...future.result
[10:34:04.840] }
[10:34:04.893] MultisessionFuture started
[10:34:04.893] - Launch lazy future ... done
[10:34:04.893] run() for ‘MultisessionFuture’ ... done
[10:34:04.893] getGlobalsAndPackages() ...
[10:34:04.893] Searching for globals...
[10:34:04.894] - globals found: [2] ‘list’, ‘stop’
[10:34:04.894] Searching for globals ... DONE
[10:34:04.894] Resolving globals: FALSE
[10:34:04.895] 
[10:34:04.895] 
[10:34:04.895] getGlobalsAndPackages() ... DONE
- result = FALSE, recursive = -1 ... DONE
- result = FALSE, recursive = 0 ...
[10:34:04.895] getGlobalsAndPackages() ...
[10:34:04.895] Searching for globals...
[10:34:04.896] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:34:04.897] Searching for globals ... DONE
[10:34:04.897] Resolving globals: FALSE
[10:34:04.897] 
[10:34:04.897] 
[10:34:04.897] getGlobalsAndPackages() ... DONE
[10:34:04.897] run() for ‘Future’ ...
[10:34:04.897] - state: ‘created’
[10:34:04.898] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:04.911] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:04.912] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:04.912]   - Field: ‘node’
[10:34:04.912]   - Field: ‘label’
[10:34:04.912]   - Field: ‘local’
[10:34:04.912]   - Field: ‘owner’
[10:34:04.912]   - Field: ‘envir’
[10:34:04.912]   - Field: ‘workers’
[10:34:04.912]   - Field: ‘packages’
[10:34:04.912]   - Field: ‘gc’
[10:34:04.912]   - Field: ‘conditions’
[10:34:04.913]   - Field: ‘persistent’
[10:34:04.913]   - Field: ‘expr’
[10:34:04.913]   - Field: ‘uuid’
[10:34:04.913]   - Field: ‘seed’
[10:34:04.913]   - Field: ‘version’
[10:34:04.913]   - Field: ‘result’
[10:34:04.913]   - Field: ‘asynchronous’
[10:34:04.913]   - Field: ‘calls’
[10:34:04.913]   - Field: ‘globals’
[10:34:04.913]   - Field: ‘stdout’
[10:34:04.913]   - Field: ‘earlySignal’
[10:34:04.914]   - Field: ‘lazy’
[10:34:04.914]   - Field: ‘state’
[10:34:04.914] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:04.914] - Launch lazy future ...
[10:34:04.914] Packages needed by the future expression (n = 0): <none>
[10:34:04.914] Packages needed by future strategies (n = 0): <none>
[10:34:04.915] {
[10:34:04.915]     {
[10:34:04.915]         {
[10:34:04.915]             ...future.startTime <- base::Sys.time()
[10:34:04.915]             {
[10:34:04.915]                 {
[10:34:04.915]                   {
[10:34:04.915]                     {
[10:34:04.915]                       base::local({
[10:34:04.915]                         has_future <- base::requireNamespace("future", 
[10:34:04.915]                           quietly = TRUE)
[10:34:04.915]                         if (has_future) {
[10:34:04.915]                           ns <- base::getNamespace("future")
[10:34:04.915]                           version <- ns[[".package"]][["version"]]
[10:34:04.915]                           if (is.null(version)) 
[10:34:04.915]                             version <- utils::packageVersion("future")
[10:34:04.915]                         }
[10:34:04.915]                         else {
[10:34:04.915]                           version <- NULL
[10:34:04.915]                         }
[10:34:04.915]                         if (!has_future || version < "1.8.0") {
[10:34:04.915]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:04.915]                             "", base::R.version$version.string), 
[10:34:04.915]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:04.915]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:04.915]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:04.915]                               "release", "version")], collapse = " "), 
[10:34:04.915]                             hostname = base::Sys.info()[["nodename"]])
[10:34:04.915]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:04.915]                             info)
[10:34:04.915]                           info <- base::paste(info, collapse = "; ")
[10:34:04.915]                           if (!has_future) {
[10:34:04.915]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:04.915]                               info)
[10:34:04.915]                           }
[10:34:04.915]                           else {
[10:34:04.915]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:04.915]                               info, version)
[10:34:04.915]                           }
[10:34:04.915]                           base::stop(msg)
[10:34:04.915]                         }
[10:34:04.915]                       })
[10:34:04.915]                     }
[10:34:04.915]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:04.915]                     base::options(mc.cores = 1L)
[10:34:04.915]                   }
[10:34:04.915]                   ...future.strategy.old <- future::plan("list")
[10:34:04.915]                   options(future.plan = NULL)
[10:34:04.915]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:04.915]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:04.915]                 }
[10:34:04.915]                 ...future.workdir <- getwd()
[10:34:04.915]             }
[10:34:04.915]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:04.915]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:04.915]         }
[10:34:04.915]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:04.915]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:04.915]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:04.915]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:04.915]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:04.915]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:04.915]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:04.915]             base::names(...future.oldOptions))
[10:34:04.915]     }
[10:34:04.915]     if (FALSE) {
[10:34:04.915]     }
[10:34:04.915]     else {
[10:34:04.915]         if (TRUE) {
[10:34:04.915]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:04.915]                 open = "w")
[10:34:04.915]         }
[10:34:04.915]         else {
[10:34:04.915]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:04.915]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:04.915]         }
[10:34:04.915]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:04.915]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:04.915]             base::sink(type = "output", split = FALSE)
[10:34:04.915]             base::close(...future.stdout)
[10:34:04.915]         }, add = TRUE)
[10:34:04.915]     }
[10:34:04.915]     ...future.frame <- base::sys.nframe()
[10:34:04.915]     ...future.conditions <- base::list()
[10:34:04.915]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:04.915]     if (FALSE) {
[10:34:04.915]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:04.915]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:04.915]     }
[10:34:04.915]     ...future.result <- base::tryCatch({
[10:34:04.915]         base::withCallingHandlers({
[10:34:04.915]             ...future.value <- base::withVisible(base::local({
[10:34:04.915]                 ...future.makeSendCondition <- base::local({
[10:34:04.915]                   sendCondition <- NULL
[10:34:04.915]                   function(frame = 1L) {
[10:34:04.915]                     if (is.function(sendCondition)) 
[10:34:04.915]                       return(sendCondition)
[10:34:04.915]                     ns <- getNamespace("parallel")
[10:34:04.915]                     if (exists("sendData", mode = "function", 
[10:34:04.915]                       envir = ns)) {
[10:34:04.915]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:04.915]                         envir = ns)
[10:34:04.915]                       envir <- sys.frame(frame)
[10:34:04.915]                       master <- NULL
[10:34:04.915]                       while (!identical(envir, .GlobalEnv) && 
[10:34:04.915]                         !identical(envir, emptyenv())) {
[10:34:04.915]                         if (exists("master", mode = "list", envir = envir, 
[10:34:04.915]                           inherits = FALSE)) {
[10:34:04.915]                           master <- get("master", mode = "list", 
[10:34:04.915]                             envir = envir, inherits = FALSE)
[10:34:04.915]                           if (inherits(master, c("SOCKnode", 
[10:34:04.915]                             "SOCK0node"))) {
[10:34:04.915]                             sendCondition <<- function(cond) {
[10:34:04.915]                               data <- list(type = "VALUE", value = cond, 
[10:34:04.915]                                 success = TRUE)
[10:34:04.915]                               parallel_sendData(master, data)
[10:34:04.915]                             }
[10:34:04.915]                             return(sendCondition)
[10:34:04.915]                           }
[10:34:04.915]                         }
[10:34:04.915]                         frame <- frame + 1L
[10:34:04.915]                         envir <- sys.frame(frame)
[10:34:04.915]                       }
[10:34:04.915]                     }
[10:34:04.915]                     sendCondition <<- function(cond) NULL
[10:34:04.915]                   }
[10:34:04.915]                 })
[10:34:04.915]                 withCallingHandlers({
[10:34:04.915]                   {
[10:34:04.915]                     Sys.sleep(0.5)
[10:34:04.915]                     list(a = 1, b = 42L)
[10:34:04.915]                   }
[10:34:04.915]                 }, immediateCondition = function(cond) {
[10:34:04.915]                   sendCondition <- ...future.makeSendCondition()
[10:34:04.915]                   sendCondition(cond)
[10:34:04.915]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:04.915]                   {
[10:34:04.915]                     inherits <- base::inherits
[10:34:04.915]                     invokeRestart <- base::invokeRestart
[10:34:04.915]                     is.null <- base::is.null
[10:34:04.915]                     muffled <- FALSE
[10:34:04.915]                     if (inherits(cond, "message")) {
[10:34:04.915]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:04.915]                       if (muffled) 
[10:34:04.915]                         invokeRestart("muffleMessage")
[10:34:04.915]                     }
[10:34:04.915]                     else if (inherits(cond, "warning")) {
[10:34:04.915]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:04.915]                       if (muffled) 
[10:34:04.915]                         invokeRestart("muffleWarning")
[10:34:04.915]                     }
[10:34:04.915]                     else if (inherits(cond, "condition")) {
[10:34:04.915]                       if (!is.null(pattern)) {
[10:34:04.915]                         computeRestarts <- base::computeRestarts
[10:34:04.915]                         grepl <- base::grepl
[10:34:04.915]                         restarts <- computeRestarts(cond)
[10:34:04.915]                         for (restart in restarts) {
[10:34:04.915]                           name <- restart$name
[10:34:04.915]                           if (is.null(name)) 
[10:34:04.915]                             next
[10:34:04.915]                           if (!grepl(pattern, name)) 
[10:34:04.915]                             next
[10:34:04.915]                           invokeRestart(restart)
[10:34:04.915]                           muffled <- TRUE
[10:34:04.915]                           break
[10:34:04.915]                         }
[10:34:04.915]                       }
[10:34:04.915]                     }
[10:34:04.915]                     invisible(muffled)
[10:34:04.915]                   }
[10:34:04.915]                   muffleCondition(cond)
[10:34:04.915]                 })
[10:34:04.915]             }))
[10:34:04.915]             future::FutureResult(value = ...future.value$value, 
[10:34:04.915]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:04.915]                   ...future.rng), globalenv = if (FALSE) 
[10:34:04.915]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:04.915]                     ...future.globalenv.names))
[10:34:04.915]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:04.915]         }, condition = base::local({
[10:34:04.915]             c <- base::c
[10:34:04.915]             inherits <- base::inherits
[10:34:04.915]             invokeRestart <- base::invokeRestart
[10:34:04.915]             length <- base::length
[10:34:04.915]             list <- base::list
[10:34:04.915]             seq.int <- base::seq.int
[10:34:04.915]             signalCondition <- base::signalCondition
[10:34:04.915]             sys.calls <- base::sys.calls
[10:34:04.915]             `[[` <- base::`[[`
[10:34:04.915]             `+` <- base::`+`
[10:34:04.915]             `<<-` <- base::`<<-`
[10:34:04.915]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:04.915]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:04.915]                   3L)]
[10:34:04.915]             }
[10:34:04.915]             function(cond) {
[10:34:04.915]                 is_error <- inherits(cond, "error")
[10:34:04.915]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:04.915]                   NULL)
[10:34:04.915]                 if (is_error) {
[10:34:04.915]                   sessionInformation <- function() {
[10:34:04.915]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:04.915]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:04.915]                       search = base::search(), system = base::Sys.info())
[10:34:04.915]                   }
[10:34:04.915]                   ...future.conditions[[length(...future.conditions) + 
[10:34:04.915]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:04.915]                     cond$call), session = sessionInformation(), 
[10:34:04.915]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:04.915]                   signalCondition(cond)
[10:34:04.915]                 }
[10:34:04.915]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:04.915]                 "immediateCondition"))) {
[10:34:04.915]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:04.915]                   ...future.conditions[[length(...future.conditions) + 
[10:34:04.915]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:04.915]                   if (TRUE && !signal) {
[10:34:04.915]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:04.915]                     {
[10:34:04.915]                       inherits <- base::inherits
[10:34:04.915]                       invokeRestart <- base::invokeRestart
[10:34:04.915]                       is.null <- base::is.null
[10:34:04.915]                       muffled <- FALSE
[10:34:04.915]                       if (inherits(cond, "message")) {
[10:34:04.915]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:04.915]                         if (muffled) 
[10:34:04.915]                           invokeRestart("muffleMessage")
[10:34:04.915]                       }
[10:34:04.915]                       else if (inherits(cond, "warning")) {
[10:34:04.915]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:04.915]                         if (muffled) 
[10:34:04.915]                           invokeRestart("muffleWarning")
[10:34:04.915]                       }
[10:34:04.915]                       else if (inherits(cond, "condition")) {
[10:34:04.915]                         if (!is.null(pattern)) {
[10:34:04.915]                           computeRestarts <- base::computeRestarts
[10:34:04.915]                           grepl <- base::grepl
[10:34:04.915]                           restarts <- computeRestarts(cond)
[10:34:04.915]                           for (restart in restarts) {
[10:34:04.915]                             name <- restart$name
[10:34:04.915]                             if (is.null(name)) 
[10:34:04.915]                               next
[10:34:04.915]                             if (!grepl(pattern, name)) 
[10:34:04.915]                               next
[10:34:04.915]                             invokeRestart(restart)
[10:34:04.915]                             muffled <- TRUE
[10:34:04.915]                             break
[10:34:04.915]                           }
[10:34:04.915]                         }
[10:34:04.915]                       }
[10:34:04.915]                       invisible(muffled)
[10:34:04.915]                     }
[10:34:04.915]                     muffleCondition(cond, pattern = "^muffle")
[10:34:04.915]                   }
[10:34:04.915]                 }
[10:34:04.915]                 else {
[10:34:04.915]                   if (TRUE) {
[10:34:04.915]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:04.915]                     {
[10:34:04.915]                       inherits <- base::inherits
[10:34:04.915]                       invokeRestart <- base::invokeRestart
[10:34:04.915]                       is.null <- base::is.null
[10:34:04.915]                       muffled <- FALSE
[10:34:04.915]                       if (inherits(cond, "message")) {
[10:34:04.915]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:04.915]                         if (muffled) 
[10:34:04.915]                           invokeRestart("muffleMessage")
[10:34:04.915]                       }
[10:34:04.915]                       else if (inherits(cond, "warning")) {
[10:34:04.915]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:04.915]                         if (muffled) 
[10:34:04.915]                           invokeRestart("muffleWarning")
[10:34:04.915]                       }
[10:34:04.915]                       else if (inherits(cond, "condition")) {
[10:34:04.915]                         if (!is.null(pattern)) {
[10:34:04.915]                           computeRestarts <- base::computeRestarts
[10:34:04.915]                           grepl <- base::grepl
[10:34:04.915]                           restarts <- computeRestarts(cond)
[10:34:04.915]                           for (restart in restarts) {
[10:34:04.915]                             name <- restart$name
[10:34:04.915]                             if (is.null(name)) 
[10:34:04.915]                               next
[10:34:04.915]                             if (!grepl(pattern, name)) 
[10:34:04.915]                               next
[10:34:04.915]                             invokeRestart(restart)
[10:34:04.915]                             muffled <- TRUE
[10:34:04.915]                             break
[10:34:04.915]                           }
[10:34:04.915]                         }
[10:34:04.915]                       }
[10:34:04.915]                       invisible(muffled)
[10:34:04.915]                     }
[10:34:04.915]                     muffleCondition(cond, pattern = "^muffle")
[10:34:04.915]                   }
[10:34:04.915]                 }
[10:34:04.915]             }
[10:34:04.915]         }))
[10:34:04.915]     }, error = function(ex) {
[10:34:04.915]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:04.915]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:04.915]                 ...future.rng), started = ...future.startTime, 
[10:34:04.915]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:04.915]             version = "1.8"), class = "FutureResult")
[10:34:04.915]     }, finally = {
[10:34:04.915]         if (!identical(...future.workdir, getwd())) 
[10:34:04.915]             setwd(...future.workdir)
[10:34:04.915]         {
[10:34:04.915]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:04.915]                 ...future.oldOptions$nwarnings <- NULL
[10:34:04.915]             }
[10:34:04.915]             base::options(...future.oldOptions)
[10:34:04.915]             if (.Platform$OS.type == "windows") {
[10:34:04.915]                 old_names <- names(...future.oldEnvVars)
[10:34:04.915]                 envs <- base::Sys.getenv()
[10:34:04.915]                 names <- names(envs)
[10:34:04.915]                 common <- intersect(names, old_names)
[10:34:04.915]                 added <- setdiff(names, old_names)
[10:34:04.915]                 removed <- setdiff(old_names, names)
[10:34:04.915]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:04.915]                   envs[common]]
[10:34:04.915]                 NAMES <- toupper(changed)
[10:34:04.915]                 args <- list()
[10:34:04.915]                 for (kk in seq_along(NAMES)) {
[10:34:04.915]                   name <- changed[[kk]]
[10:34:04.915]                   NAME <- NAMES[[kk]]
[10:34:04.915]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:04.915]                     next
[10:34:04.915]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:04.915]                 }
[10:34:04.915]                 NAMES <- toupper(added)
[10:34:04.915]                 for (kk in seq_along(NAMES)) {
[10:34:04.915]                   name <- added[[kk]]
[10:34:04.915]                   NAME <- NAMES[[kk]]
[10:34:04.915]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:04.915]                     next
[10:34:04.915]                   args[[name]] <- ""
[10:34:04.915]                 }
[10:34:04.915]                 NAMES <- toupper(removed)
[10:34:04.915]                 for (kk in seq_along(NAMES)) {
[10:34:04.915]                   name <- removed[[kk]]
[10:34:04.915]                   NAME <- NAMES[[kk]]
[10:34:04.915]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:04.915]                     next
[10:34:04.915]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:04.915]                 }
[10:34:04.915]                 if (length(args) > 0) 
[10:34:04.915]                   base::do.call(base::Sys.setenv, args = args)
[10:34:04.915]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:04.915]             }
[10:34:04.915]             else {
[10:34:04.915]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:04.915]             }
[10:34:04.915]             {
[10:34:04.915]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:04.915]                   0L) {
[10:34:04.915]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:04.915]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:04.915]                   base::options(opts)
[10:34:04.915]                 }
[10:34:04.915]                 {
[10:34:04.915]                   {
[10:34:04.915]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:04.915]                     NULL
[10:34:04.915]                   }
[10:34:04.915]                   options(future.plan = NULL)
[10:34:04.915]                   if (is.na(NA_character_)) 
[10:34:04.915]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:04.915]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:04.915]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:04.915]                     .init = FALSE)
[10:34:04.915]                 }
[10:34:04.915]             }
[10:34:04.915]         }
[10:34:04.915]     })
[10:34:04.915]     if (TRUE) {
[10:34:04.915]         base::sink(type = "output", split = FALSE)
[10:34:04.915]         if (TRUE) {
[10:34:04.915]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:04.915]         }
[10:34:04.915]         else {
[10:34:04.915]             ...future.result["stdout"] <- base::list(NULL)
[10:34:04.915]         }
[10:34:04.915]         base::close(...future.stdout)
[10:34:04.915]         ...future.stdout <- NULL
[10:34:04.915]     }
[10:34:04.915]     ...future.result$conditions <- ...future.conditions
[10:34:04.915]     ...future.result$finished <- base::Sys.time()
[10:34:04.915]     ...future.result
[10:34:04.915] }
[10:34:04.917] Poll #1 (0): usedNodes() = 2, workers = 2
[10:34:04.938] receiveMessageFromWorker() for ClusterFuture ...
[10:34:04.938] - Validating connection of MultisessionFuture
[10:34:04.939] - received message: FutureResult
[10:34:04.939] - Received FutureResult
[10:34:04.939] - Erased future from FutureRegistry
[10:34:04.939] result() for ClusterFuture ...
[10:34:04.939] - result already collected: FutureResult
[10:34:04.939] result() for ClusterFuture ... done
[10:34:04.939] signalConditions() ...
[10:34:04.939]  - include = ‘immediateCondition’
[10:34:04.939]  - exclude = 
[10:34:04.939]  - resignal = FALSE
[10:34:04.940]  - Number of conditions: 1
[10:34:04.940] signalConditions() ... done
[10:34:04.940] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:04.940] result() for ClusterFuture ...
[10:34:04.940] - result already collected: FutureResult
[10:34:04.940] result() for ClusterFuture ... done
[10:34:04.940] result() for ClusterFuture ...
[10:34:04.940] - result already collected: FutureResult
[10:34:04.940] result() for ClusterFuture ... done
[10:34:04.940] signalConditions() ...
[10:34:04.940]  - include = ‘immediateCondition’
[10:34:04.941]  - exclude = 
[10:34:04.941]  - resignal = FALSE
[10:34:04.941]  - Number of conditions: 1
[10:34:04.941] signalConditions() ... done
[10:34:04.942] MultisessionFuture started
[10:34:04.942] - Launch lazy future ... done
[10:34:04.942] run() for ‘MultisessionFuture’ ... done
[10:34:05.457] receiveMessageFromWorker() for ClusterFuture ...
[10:34:05.458] - Validating connection of MultisessionFuture
[10:34:05.458] - received message: FutureResult
[10:34:05.458] - Received FutureResult
[10:34:05.458] - Erased future from FutureRegistry
[10:34:05.458] result() for ClusterFuture ...
[10:34:05.458] - result already collected: FutureResult
[10:34:05.458] result() for ClusterFuture ... done
[10:34:05.458] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:05.458] A MultisessionFuture was resolved (result was not collected)
[10:34:05.459] getGlobalsAndPackages() ...
[10:34:05.459] Searching for globals...
[10:34:05.460] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:34:05.460] Searching for globals ... DONE
[10:34:05.460] Resolving globals: FALSE
[10:34:05.460] 
[10:34:05.460] 
[10:34:05.461] getGlobalsAndPackages() ... DONE
[10:34:05.461] run() for ‘Future’ ...
[10:34:05.461] - state: ‘created’
[10:34:05.461] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:05.475] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:05.475] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:05.475]   - Field: ‘node’
[10:34:05.475]   - Field: ‘label’
[10:34:05.475]   - Field: ‘local’
[10:34:05.475]   - Field: ‘owner’
[10:34:05.475]   - Field: ‘envir’
[10:34:05.475]   - Field: ‘workers’
[10:34:05.475]   - Field: ‘packages’
[10:34:05.476]   - Field: ‘gc’
[10:34:05.476]   - Field: ‘conditions’
[10:34:05.476]   - Field: ‘persistent’
[10:34:05.476]   - Field: ‘expr’
[10:34:05.476]   - Field: ‘uuid’
[10:34:05.476]   - Field: ‘seed’
[10:34:05.476]   - Field: ‘version’
[10:34:05.476]   - Field: ‘result’
[10:34:05.476]   - Field: ‘asynchronous’
[10:34:05.476]   - Field: ‘calls’
[10:34:05.476]   - Field: ‘globals’
[10:34:05.477]   - Field: ‘stdout’
[10:34:05.477]   - Field: ‘earlySignal’
[10:34:05.477]   - Field: ‘lazy’
[10:34:05.477]   - Field: ‘state’
[10:34:05.477] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:05.477] - Launch lazy future ...
[10:34:05.477] Packages needed by the future expression (n = 0): <none>
[10:34:05.477] Packages needed by future strategies (n = 0): <none>
[10:34:05.478] {
[10:34:05.478]     {
[10:34:05.478]         {
[10:34:05.478]             ...future.startTime <- base::Sys.time()
[10:34:05.478]             {
[10:34:05.478]                 {
[10:34:05.478]                   {
[10:34:05.478]                     {
[10:34:05.478]                       base::local({
[10:34:05.478]                         has_future <- base::requireNamespace("future", 
[10:34:05.478]                           quietly = TRUE)
[10:34:05.478]                         if (has_future) {
[10:34:05.478]                           ns <- base::getNamespace("future")
[10:34:05.478]                           version <- ns[[".package"]][["version"]]
[10:34:05.478]                           if (is.null(version)) 
[10:34:05.478]                             version <- utils::packageVersion("future")
[10:34:05.478]                         }
[10:34:05.478]                         else {
[10:34:05.478]                           version <- NULL
[10:34:05.478]                         }
[10:34:05.478]                         if (!has_future || version < "1.8.0") {
[10:34:05.478]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:05.478]                             "", base::R.version$version.string), 
[10:34:05.478]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:05.478]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:05.478]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:05.478]                               "release", "version")], collapse = " "), 
[10:34:05.478]                             hostname = base::Sys.info()[["nodename"]])
[10:34:05.478]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:05.478]                             info)
[10:34:05.478]                           info <- base::paste(info, collapse = "; ")
[10:34:05.478]                           if (!has_future) {
[10:34:05.478]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:05.478]                               info)
[10:34:05.478]                           }
[10:34:05.478]                           else {
[10:34:05.478]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:05.478]                               info, version)
[10:34:05.478]                           }
[10:34:05.478]                           base::stop(msg)
[10:34:05.478]                         }
[10:34:05.478]                       })
[10:34:05.478]                     }
[10:34:05.478]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:05.478]                     base::options(mc.cores = 1L)
[10:34:05.478]                   }
[10:34:05.478]                   ...future.strategy.old <- future::plan("list")
[10:34:05.478]                   options(future.plan = NULL)
[10:34:05.478]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:05.478]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:05.478]                 }
[10:34:05.478]                 ...future.workdir <- getwd()
[10:34:05.478]             }
[10:34:05.478]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:05.478]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:05.478]         }
[10:34:05.478]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:05.478]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:05.478]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:05.478]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:05.478]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:05.478]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:05.478]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:05.478]             base::names(...future.oldOptions))
[10:34:05.478]     }
[10:34:05.478]     if (FALSE) {
[10:34:05.478]     }
[10:34:05.478]     else {
[10:34:05.478]         if (TRUE) {
[10:34:05.478]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:05.478]                 open = "w")
[10:34:05.478]         }
[10:34:05.478]         else {
[10:34:05.478]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:05.478]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:05.478]         }
[10:34:05.478]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:05.478]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:05.478]             base::sink(type = "output", split = FALSE)
[10:34:05.478]             base::close(...future.stdout)
[10:34:05.478]         }, add = TRUE)
[10:34:05.478]     }
[10:34:05.478]     ...future.frame <- base::sys.nframe()
[10:34:05.478]     ...future.conditions <- base::list()
[10:34:05.478]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:05.478]     if (FALSE) {
[10:34:05.478]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:05.478]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:05.478]     }
[10:34:05.478]     ...future.result <- base::tryCatch({
[10:34:05.478]         base::withCallingHandlers({
[10:34:05.478]             ...future.value <- base::withVisible(base::local({
[10:34:05.478]                 ...future.makeSendCondition <- base::local({
[10:34:05.478]                   sendCondition <- NULL
[10:34:05.478]                   function(frame = 1L) {
[10:34:05.478]                     if (is.function(sendCondition)) 
[10:34:05.478]                       return(sendCondition)
[10:34:05.478]                     ns <- getNamespace("parallel")
[10:34:05.478]                     if (exists("sendData", mode = "function", 
[10:34:05.478]                       envir = ns)) {
[10:34:05.478]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:05.478]                         envir = ns)
[10:34:05.478]                       envir <- sys.frame(frame)
[10:34:05.478]                       master <- NULL
[10:34:05.478]                       while (!identical(envir, .GlobalEnv) && 
[10:34:05.478]                         !identical(envir, emptyenv())) {
[10:34:05.478]                         if (exists("master", mode = "list", envir = envir, 
[10:34:05.478]                           inherits = FALSE)) {
[10:34:05.478]                           master <- get("master", mode = "list", 
[10:34:05.478]                             envir = envir, inherits = FALSE)
[10:34:05.478]                           if (inherits(master, c("SOCKnode", 
[10:34:05.478]                             "SOCK0node"))) {
[10:34:05.478]                             sendCondition <<- function(cond) {
[10:34:05.478]                               data <- list(type = "VALUE", value = cond, 
[10:34:05.478]                                 success = TRUE)
[10:34:05.478]                               parallel_sendData(master, data)
[10:34:05.478]                             }
[10:34:05.478]                             return(sendCondition)
[10:34:05.478]                           }
[10:34:05.478]                         }
[10:34:05.478]                         frame <- frame + 1L
[10:34:05.478]                         envir <- sys.frame(frame)
[10:34:05.478]                       }
[10:34:05.478]                     }
[10:34:05.478]                     sendCondition <<- function(cond) NULL
[10:34:05.478]                   }
[10:34:05.478]                 })
[10:34:05.478]                 withCallingHandlers({
[10:34:05.478]                   {
[10:34:05.478]                     Sys.sleep(0.5)
[10:34:05.478]                     list(a = 1, b = 42L)
[10:34:05.478]                   }
[10:34:05.478]                 }, immediateCondition = function(cond) {
[10:34:05.478]                   sendCondition <- ...future.makeSendCondition()
[10:34:05.478]                   sendCondition(cond)
[10:34:05.478]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:05.478]                   {
[10:34:05.478]                     inherits <- base::inherits
[10:34:05.478]                     invokeRestart <- base::invokeRestart
[10:34:05.478]                     is.null <- base::is.null
[10:34:05.478]                     muffled <- FALSE
[10:34:05.478]                     if (inherits(cond, "message")) {
[10:34:05.478]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:05.478]                       if (muffled) 
[10:34:05.478]                         invokeRestart("muffleMessage")
[10:34:05.478]                     }
[10:34:05.478]                     else if (inherits(cond, "warning")) {
[10:34:05.478]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:05.478]                       if (muffled) 
[10:34:05.478]                         invokeRestart("muffleWarning")
[10:34:05.478]                     }
[10:34:05.478]                     else if (inherits(cond, "condition")) {
[10:34:05.478]                       if (!is.null(pattern)) {
[10:34:05.478]                         computeRestarts <- base::computeRestarts
[10:34:05.478]                         grepl <- base::grepl
[10:34:05.478]                         restarts <- computeRestarts(cond)
[10:34:05.478]                         for (restart in restarts) {
[10:34:05.478]                           name <- restart$name
[10:34:05.478]                           if (is.null(name)) 
[10:34:05.478]                             next
[10:34:05.478]                           if (!grepl(pattern, name)) 
[10:34:05.478]                             next
[10:34:05.478]                           invokeRestart(restart)
[10:34:05.478]                           muffled <- TRUE
[10:34:05.478]                           break
[10:34:05.478]                         }
[10:34:05.478]                       }
[10:34:05.478]                     }
[10:34:05.478]                     invisible(muffled)
[10:34:05.478]                   }
[10:34:05.478]                   muffleCondition(cond)
[10:34:05.478]                 })
[10:34:05.478]             }))
[10:34:05.478]             future::FutureResult(value = ...future.value$value, 
[10:34:05.478]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:05.478]                   ...future.rng), globalenv = if (FALSE) 
[10:34:05.478]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:05.478]                     ...future.globalenv.names))
[10:34:05.478]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:05.478]         }, condition = base::local({
[10:34:05.478]             c <- base::c
[10:34:05.478]             inherits <- base::inherits
[10:34:05.478]             invokeRestart <- base::invokeRestart
[10:34:05.478]             length <- base::length
[10:34:05.478]             list <- base::list
[10:34:05.478]             seq.int <- base::seq.int
[10:34:05.478]             signalCondition <- base::signalCondition
[10:34:05.478]             sys.calls <- base::sys.calls
[10:34:05.478]             `[[` <- base::`[[`
[10:34:05.478]             `+` <- base::`+`
[10:34:05.478]             `<<-` <- base::`<<-`
[10:34:05.478]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:05.478]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:05.478]                   3L)]
[10:34:05.478]             }
[10:34:05.478]             function(cond) {
[10:34:05.478]                 is_error <- inherits(cond, "error")
[10:34:05.478]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:05.478]                   NULL)
[10:34:05.478]                 if (is_error) {
[10:34:05.478]                   sessionInformation <- function() {
[10:34:05.478]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:05.478]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:05.478]                       search = base::search(), system = base::Sys.info())
[10:34:05.478]                   }
[10:34:05.478]                   ...future.conditions[[length(...future.conditions) + 
[10:34:05.478]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:05.478]                     cond$call), session = sessionInformation(), 
[10:34:05.478]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:05.478]                   signalCondition(cond)
[10:34:05.478]                 }
[10:34:05.478]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:05.478]                 "immediateCondition"))) {
[10:34:05.478]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:05.478]                   ...future.conditions[[length(...future.conditions) + 
[10:34:05.478]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:05.478]                   if (TRUE && !signal) {
[10:34:05.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:05.478]                     {
[10:34:05.478]                       inherits <- base::inherits
[10:34:05.478]                       invokeRestart <- base::invokeRestart
[10:34:05.478]                       is.null <- base::is.null
[10:34:05.478]                       muffled <- FALSE
[10:34:05.478]                       if (inherits(cond, "message")) {
[10:34:05.478]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:05.478]                         if (muffled) 
[10:34:05.478]                           invokeRestart("muffleMessage")
[10:34:05.478]                       }
[10:34:05.478]                       else if (inherits(cond, "warning")) {
[10:34:05.478]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:05.478]                         if (muffled) 
[10:34:05.478]                           invokeRestart("muffleWarning")
[10:34:05.478]                       }
[10:34:05.478]                       else if (inherits(cond, "condition")) {
[10:34:05.478]                         if (!is.null(pattern)) {
[10:34:05.478]                           computeRestarts <- base::computeRestarts
[10:34:05.478]                           grepl <- base::grepl
[10:34:05.478]                           restarts <- computeRestarts(cond)
[10:34:05.478]                           for (restart in restarts) {
[10:34:05.478]                             name <- restart$name
[10:34:05.478]                             if (is.null(name)) 
[10:34:05.478]                               next
[10:34:05.478]                             if (!grepl(pattern, name)) 
[10:34:05.478]                               next
[10:34:05.478]                             invokeRestart(restart)
[10:34:05.478]                             muffled <- TRUE
[10:34:05.478]                             break
[10:34:05.478]                           }
[10:34:05.478]                         }
[10:34:05.478]                       }
[10:34:05.478]                       invisible(muffled)
[10:34:05.478]                     }
[10:34:05.478]                     muffleCondition(cond, pattern = "^muffle")
[10:34:05.478]                   }
[10:34:05.478]                 }
[10:34:05.478]                 else {
[10:34:05.478]                   if (TRUE) {
[10:34:05.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:05.478]                     {
[10:34:05.478]                       inherits <- base::inherits
[10:34:05.478]                       invokeRestart <- base::invokeRestart
[10:34:05.478]                       is.null <- base::is.null
[10:34:05.478]                       muffled <- FALSE
[10:34:05.478]                       if (inherits(cond, "message")) {
[10:34:05.478]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:05.478]                         if (muffled) 
[10:34:05.478]                           invokeRestart("muffleMessage")
[10:34:05.478]                       }
[10:34:05.478]                       else if (inherits(cond, "warning")) {
[10:34:05.478]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:05.478]                         if (muffled) 
[10:34:05.478]                           invokeRestart("muffleWarning")
[10:34:05.478]                       }
[10:34:05.478]                       else if (inherits(cond, "condition")) {
[10:34:05.478]                         if (!is.null(pattern)) {
[10:34:05.478]                           computeRestarts <- base::computeRestarts
[10:34:05.478]                           grepl <- base::grepl
[10:34:05.478]                           restarts <- computeRestarts(cond)
[10:34:05.478]                           for (restart in restarts) {
[10:34:05.478]                             name <- restart$name
[10:34:05.478]                             if (is.null(name)) 
[10:34:05.478]                               next
[10:34:05.478]                             if (!grepl(pattern, name)) 
[10:34:05.478]                               next
[10:34:05.478]                             invokeRestart(restart)
[10:34:05.478]                             muffled <- TRUE
[10:34:05.478]                             break
[10:34:05.478]                           }
[10:34:05.478]                         }
[10:34:05.478]                       }
[10:34:05.478]                       invisible(muffled)
[10:34:05.478]                     }
[10:34:05.478]                     muffleCondition(cond, pattern = "^muffle")
[10:34:05.478]                   }
[10:34:05.478]                 }
[10:34:05.478]             }
[10:34:05.478]         }))
[10:34:05.478]     }, error = function(ex) {
[10:34:05.478]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:05.478]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:05.478]                 ...future.rng), started = ...future.startTime, 
[10:34:05.478]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:05.478]             version = "1.8"), class = "FutureResult")
[10:34:05.478]     }, finally = {
[10:34:05.478]         if (!identical(...future.workdir, getwd())) 
[10:34:05.478]             setwd(...future.workdir)
[10:34:05.478]         {
[10:34:05.478]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:05.478]                 ...future.oldOptions$nwarnings <- NULL
[10:34:05.478]             }
[10:34:05.478]             base::options(...future.oldOptions)
[10:34:05.478]             if (.Platform$OS.type == "windows") {
[10:34:05.478]                 old_names <- names(...future.oldEnvVars)
[10:34:05.478]                 envs <- base::Sys.getenv()
[10:34:05.478]                 names <- names(envs)
[10:34:05.478]                 common <- intersect(names, old_names)
[10:34:05.478]                 added <- setdiff(names, old_names)
[10:34:05.478]                 removed <- setdiff(old_names, names)
[10:34:05.478]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:05.478]                   envs[common]]
[10:34:05.478]                 NAMES <- toupper(changed)
[10:34:05.478]                 args <- list()
[10:34:05.478]                 for (kk in seq_along(NAMES)) {
[10:34:05.478]                   name <- changed[[kk]]
[10:34:05.478]                   NAME <- NAMES[[kk]]
[10:34:05.478]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:05.478]                     next
[10:34:05.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:05.478]                 }
[10:34:05.478]                 NAMES <- toupper(added)
[10:34:05.478]                 for (kk in seq_along(NAMES)) {
[10:34:05.478]                   name <- added[[kk]]
[10:34:05.478]                   NAME <- NAMES[[kk]]
[10:34:05.478]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:05.478]                     next
[10:34:05.478]                   args[[name]] <- ""
[10:34:05.478]                 }
[10:34:05.478]                 NAMES <- toupper(removed)
[10:34:05.478]                 for (kk in seq_along(NAMES)) {
[10:34:05.478]                   name <- removed[[kk]]
[10:34:05.478]                   NAME <- NAMES[[kk]]
[10:34:05.478]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:05.478]                     next
[10:34:05.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:05.478]                 }
[10:34:05.478]                 if (length(args) > 0) 
[10:34:05.478]                   base::do.call(base::Sys.setenv, args = args)
[10:34:05.478]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:05.478]             }
[10:34:05.478]             else {
[10:34:05.478]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:05.478]             }
[10:34:05.478]             {
[10:34:05.478]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:05.478]                   0L) {
[10:34:05.478]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:05.478]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:05.478]                   base::options(opts)
[10:34:05.478]                 }
[10:34:05.478]                 {
[10:34:05.478]                   {
[10:34:05.478]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:05.478]                     NULL
[10:34:05.478]                   }
[10:34:05.478]                   options(future.plan = NULL)
[10:34:05.478]                   if (is.na(NA_character_)) 
[10:34:05.478]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:05.478]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:05.478]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:05.478]                     .init = FALSE)
[10:34:05.478]                 }
[10:34:05.478]             }
[10:34:05.478]         }
[10:34:05.478]     })
[10:34:05.478]     if (TRUE) {
[10:34:05.478]         base::sink(type = "output", split = FALSE)
[10:34:05.478]         if (TRUE) {
[10:34:05.478]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:05.478]         }
[10:34:05.478]         else {
[10:34:05.478]             ...future.result["stdout"] <- base::list(NULL)
[10:34:05.478]         }
[10:34:05.478]         base::close(...future.stdout)
[10:34:05.478]         ...future.stdout <- NULL
[10:34:05.478]     }
[10:34:05.478]     ...future.result$conditions <- ...future.conditions
[10:34:05.478]     ...future.result$finished <- base::Sys.time()
[10:34:05.478]     ...future.result
[10:34:05.478] }
[10:34:05.481] MultisessionFuture started
[10:34:05.481] - Launch lazy future ... done
[10:34:05.481] run() for ‘MultisessionFuture’ ... done
[10:34:05.983] receiveMessageFromWorker() for ClusterFuture ...
[10:34:05.983] - Validating connection of MultisessionFuture
[10:34:05.984] - received message: FutureResult
[10:34:05.984] - Received FutureResult
[10:34:05.984] - Erased future from FutureRegistry
[10:34:05.984] result() for ClusterFuture ...
[10:34:05.984] - result already collected: FutureResult
[10:34:05.984] result() for ClusterFuture ... done
[10:34:05.984] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:05.984] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[10:34:05.985] getGlobalsAndPackages() ...
[10:34:05.985] Searching for globals...
[10:34:05.985] - globals found: [2] ‘list’, ‘stop’
[10:34:05.986] Searching for globals ... DONE
[10:34:05.986] Resolving globals: FALSE
[10:34:05.986] 
[10:34:05.986] 
[10:34:05.986] getGlobalsAndPackages() ... DONE
[10:34:05.986] run() for ‘Future’ ...
[10:34:05.986] - state: ‘created’
[10:34:05.987] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:06.000] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:06.000] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:06.001]   - Field: ‘node’
[10:34:06.001]   - Field: ‘label’
[10:34:06.001]   - Field: ‘local’
[10:34:06.001]   - Field: ‘owner’
[10:34:06.001]   - Field: ‘envir’
[10:34:06.001]   - Field: ‘workers’
[10:34:06.001]   - Field: ‘packages’
[10:34:06.001]   - Field: ‘gc’
[10:34:06.001]   - Field: ‘conditions’
[10:34:06.001]   - Field: ‘persistent’
[10:34:06.002]   - Field: ‘expr’
[10:34:06.002]   - Field: ‘uuid’
[10:34:06.002]   - Field: ‘seed’
[10:34:06.002]   - Field: ‘version’
[10:34:06.002]   - Field: ‘result’
[10:34:06.002]   - Field: ‘asynchronous’
[10:34:06.002]   - Field: ‘calls’
[10:34:06.002]   - Field: ‘globals’
[10:34:06.002]   - Field: ‘stdout’
[10:34:06.002]   - Field: ‘earlySignal’
[10:34:06.002]   - Field: ‘lazy’
[10:34:06.003]   - Field: ‘state’
[10:34:06.003] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:06.003] - Launch lazy future ...
[10:34:06.003] Packages needed by the future expression (n = 0): <none>
[10:34:06.005] Packages needed by future strategies (n = 0): <none>
[10:34:06.005] {
[10:34:06.005]     {
[10:34:06.005]         {
[10:34:06.005]             ...future.startTime <- base::Sys.time()
[10:34:06.005]             {
[10:34:06.005]                 {
[10:34:06.005]                   {
[10:34:06.005]                     {
[10:34:06.005]                       base::local({
[10:34:06.005]                         has_future <- base::requireNamespace("future", 
[10:34:06.005]                           quietly = TRUE)
[10:34:06.005]                         if (has_future) {
[10:34:06.005]                           ns <- base::getNamespace("future")
[10:34:06.005]                           version <- ns[[".package"]][["version"]]
[10:34:06.005]                           if (is.null(version)) 
[10:34:06.005]                             version <- utils::packageVersion("future")
[10:34:06.005]                         }
[10:34:06.005]                         else {
[10:34:06.005]                           version <- NULL
[10:34:06.005]                         }
[10:34:06.005]                         if (!has_future || version < "1.8.0") {
[10:34:06.005]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:06.005]                             "", base::R.version$version.string), 
[10:34:06.005]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:06.005]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:06.005]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:06.005]                               "release", "version")], collapse = " "), 
[10:34:06.005]                             hostname = base::Sys.info()[["nodename"]])
[10:34:06.005]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:06.005]                             info)
[10:34:06.005]                           info <- base::paste(info, collapse = "; ")
[10:34:06.005]                           if (!has_future) {
[10:34:06.005]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:06.005]                               info)
[10:34:06.005]                           }
[10:34:06.005]                           else {
[10:34:06.005]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:06.005]                               info, version)
[10:34:06.005]                           }
[10:34:06.005]                           base::stop(msg)
[10:34:06.005]                         }
[10:34:06.005]                       })
[10:34:06.005]                     }
[10:34:06.005]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:06.005]                     base::options(mc.cores = 1L)
[10:34:06.005]                   }
[10:34:06.005]                   ...future.strategy.old <- future::plan("list")
[10:34:06.005]                   options(future.plan = NULL)
[10:34:06.005]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:06.005]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:06.005]                 }
[10:34:06.005]                 ...future.workdir <- getwd()
[10:34:06.005]             }
[10:34:06.005]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:06.005]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:06.005]         }
[10:34:06.005]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:06.005]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:06.005]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:06.005]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:06.005]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:06.005]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:06.005]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:06.005]             base::names(...future.oldOptions))
[10:34:06.005]     }
[10:34:06.005]     if (FALSE) {
[10:34:06.005]     }
[10:34:06.005]     else {
[10:34:06.005]         if (TRUE) {
[10:34:06.005]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:06.005]                 open = "w")
[10:34:06.005]         }
[10:34:06.005]         else {
[10:34:06.005]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:06.005]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:06.005]         }
[10:34:06.005]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:06.005]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:06.005]             base::sink(type = "output", split = FALSE)
[10:34:06.005]             base::close(...future.stdout)
[10:34:06.005]         }, add = TRUE)
[10:34:06.005]     }
[10:34:06.005]     ...future.frame <- base::sys.nframe()
[10:34:06.005]     ...future.conditions <- base::list()
[10:34:06.005]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:06.005]     if (FALSE) {
[10:34:06.005]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:06.005]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:06.005]     }
[10:34:06.005]     ...future.result <- base::tryCatch({
[10:34:06.005]         base::withCallingHandlers({
[10:34:06.005]             ...future.value <- base::withVisible(base::local({
[10:34:06.005]                 ...future.makeSendCondition <- base::local({
[10:34:06.005]                   sendCondition <- NULL
[10:34:06.005]                   function(frame = 1L) {
[10:34:06.005]                     if (is.function(sendCondition)) 
[10:34:06.005]                       return(sendCondition)
[10:34:06.005]                     ns <- getNamespace("parallel")
[10:34:06.005]                     if (exists("sendData", mode = "function", 
[10:34:06.005]                       envir = ns)) {
[10:34:06.005]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:06.005]                         envir = ns)
[10:34:06.005]                       envir <- sys.frame(frame)
[10:34:06.005]                       master <- NULL
[10:34:06.005]                       while (!identical(envir, .GlobalEnv) && 
[10:34:06.005]                         !identical(envir, emptyenv())) {
[10:34:06.005]                         if (exists("master", mode = "list", envir = envir, 
[10:34:06.005]                           inherits = FALSE)) {
[10:34:06.005]                           master <- get("master", mode = "list", 
[10:34:06.005]                             envir = envir, inherits = FALSE)
[10:34:06.005]                           if (inherits(master, c("SOCKnode", 
[10:34:06.005]                             "SOCK0node"))) {
[10:34:06.005]                             sendCondition <<- function(cond) {
[10:34:06.005]                               data <- list(type = "VALUE", value = cond, 
[10:34:06.005]                                 success = TRUE)
[10:34:06.005]                               parallel_sendData(master, data)
[10:34:06.005]                             }
[10:34:06.005]                             return(sendCondition)
[10:34:06.005]                           }
[10:34:06.005]                         }
[10:34:06.005]                         frame <- frame + 1L
[10:34:06.005]                         envir <- sys.frame(frame)
[10:34:06.005]                       }
[10:34:06.005]                     }
[10:34:06.005]                     sendCondition <<- function(cond) NULL
[10:34:06.005]                   }
[10:34:06.005]                 })
[10:34:06.005]                 withCallingHandlers({
[10:34:06.005]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:34:06.005]                 }, immediateCondition = function(cond) {
[10:34:06.005]                   sendCondition <- ...future.makeSendCondition()
[10:34:06.005]                   sendCondition(cond)
[10:34:06.005]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:06.005]                   {
[10:34:06.005]                     inherits <- base::inherits
[10:34:06.005]                     invokeRestart <- base::invokeRestart
[10:34:06.005]                     is.null <- base::is.null
[10:34:06.005]                     muffled <- FALSE
[10:34:06.005]                     if (inherits(cond, "message")) {
[10:34:06.005]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:06.005]                       if (muffled) 
[10:34:06.005]                         invokeRestart("muffleMessage")
[10:34:06.005]                     }
[10:34:06.005]                     else if (inherits(cond, "warning")) {
[10:34:06.005]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:06.005]                       if (muffled) 
[10:34:06.005]                         invokeRestart("muffleWarning")
[10:34:06.005]                     }
[10:34:06.005]                     else if (inherits(cond, "condition")) {
[10:34:06.005]                       if (!is.null(pattern)) {
[10:34:06.005]                         computeRestarts <- base::computeRestarts
[10:34:06.005]                         grepl <- base::grepl
[10:34:06.005]                         restarts <- computeRestarts(cond)
[10:34:06.005]                         for (restart in restarts) {
[10:34:06.005]                           name <- restart$name
[10:34:06.005]                           if (is.null(name)) 
[10:34:06.005]                             next
[10:34:06.005]                           if (!grepl(pattern, name)) 
[10:34:06.005]                             next
[10:34:06.005]                           invokeRestart(restart)
[10:34:06.005]                           muffled <- TRUE
[10:34:06.005]                           break
[10:34:06.005]                         }
[10:34:06.005]                       }
[10:34:06.005]                     }
[10:34:06.005]                     invisible(muffled)
[10:34:06.005]                   }
[10:34:06.005]                   muffleCondition(cond)
[10:34:06.005]                 })
[10:34:06.005]             }))
[10:34:06.005]             future::FutureResult(value = ...future.value$value, 
[10:34:06.005]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:06.005]                   ...future.rng), globalenv = if (FALSE) 
[10:34:06.005]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:06.005]                     ...future.globalenv.names))
[10:34:06.005]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:06.005]         }, condition = base::local({
[10:34:06.005]             c <- base::c
[10:34:06.005]             inherits <- base::inherits
[10:34:06.005]             invokeRestart <- base::invokeRestart
[10:34:06.005]             length <- base::length
[10:34:06.005]             list <- base::list
[10:34:06.005]             seq.int <- base::seq.int
[10:34:06.005]             signalCondition <- base::signalCondition
[10:34:06.005]             sys.calls <- base::sys.calls
[10:34:06.005]             `[[` <- base::`[[`
[10:34:06.005]             `+` <- base::`+`
[10:34:06.005]             `<<-` <- base::`<<-`
[10:34:06.005]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:06.005]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:06.005]                   3L)]
[10:34:06.005]             }
[10:34:06.005]             function(cond) {
[10:34:06.005]                 is_error <- inherits(cond, "error")
[10:34:06.005]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:06.005]                   NULL)
[10:34:06.005]                 if (is_error) {
[10:34:06.005]                   sessionInformation <- function() {
[10:34:06.005]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:06.005]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:06.005]                       search = base::search(), system = base::Sys.info())
[10:34:06.005]                   }
[10:34:06.005]                   ...future.conditions[[length(...future.conditions) + 
[10:34:06.005]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:06.005]                     cond$call), session = sessionInformation(), 
[10:34:06.005]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:06.005]                   signalCondition(cond)
[10:34:06.005]                 }
[10:34:06.005]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:06.005]                 "immediateCondition"))) {
[10:34:06.005]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:06.005]                   ...future.conditions[[length(...future.conditions) + 
[10:34:06.005]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:06.005]                   if (TRUE && !signal) {
[10:34:06.005]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:06.005]                     {
[10:34:06.005]                       inherits <- base::inherits
[10:34:06.005]                       invokeRestart <- base::invokeRestart
[10:34:06.005]                       is.null <- base::is.null
[10:34:06.005]                       muffled <- FALSE
[10:34:06.005]                       if (inherits(cond, "message")) {
[10:34:06.005]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:06.005]                         if (muffled) 
[10:34:06.005]                           invokeRestart("muffleMessage")
[10:34:06.005]                       }
[10:34:06.005]                       else if (inherits(cond, "warning")) {
[10:34:06.005]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:06.005]                         if (muffled) 
[10:34:06.005]                           invokeRestart("muffleWarning")
[10:34:06.005]                       }
[10:34:06.005]                       else if (inherits(cond, "condition")) {
[10:34:06.005]                         if (!is.null(pattern)) {
[10:34:06.005]                           computeRestarts <- base::computeRestarts
[10:34:06.005]                           grepl <- base::grepl
[10:34:06.005]                           restarts <- computeRestarts(cond)
[10:34:06.005]                           for (restart in restarts) {
[10:34:06.005]                             name <- restart$name
[10:34:06.005]                             if (is.null(name)) 
[10:34:06.005]                               next
[10:34:06.005]                             if (!grepl(pattern, name)) 
[10:34:06.005]                               next
[10:34:06.005]                             invokeRestart(restart)
[10:34:06.005]                             muffled <- TRUE
[10:34:06.005]                             break
[10:34:06.005]                           }
[10:34:06.005]                         }
[10:34:06.005]                       }
[10:34:06.005]                       invisible(muffled)
[10:34:06.005]                     }
[10:34:06.005]                     muffleCondition(cond, pattern = "^muffle")
[10:34:06.005]                   }
[10:34:06.005]                 }
[10:34:06.005]                 else {
[10:34:06.005]                   if (TRUE) {
[10:34:06.005]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:06.005]                     {
[10:34:06.005]                       inherits <- base::inherits
[10:34:06.005]                       invokeRestart <- base::invokeRestart
[10:34:06.005]                       is.null <- base::is.null
[10:34:06.005]                       muffled <- FALSE
[10:34:06.005]                       if (inherits(cond, "message")) {
[10:34:06.005]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:06.005]                         if (muffled) 
[10:34:06.005]                           invokeRestart("muffleMessage")
[10:34:06.005]                       }
[10:34:06.005]                       else if (inherits(cond, "warning")) {
[10:34:06.005]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:06.005]                         if (muffled) 
[10:34:06.005]                           invokeRestart("muffleWarning")
[10:34:06.005]                       }
[10:34:06.005]                       else if (inherits(cond, "condition")) {
[10:34:06.005]                         if (!is.null(pattern)) {
[10:34:06.005]                           computeRestarts <- base::computeRestarts
[10:34:06.005]                           grepl <- base::grepl
[10:34:06.005]                           restarts <- computeRestarts(cond)
[10:34:06.005]                           for (restart in restarts) {
[10:34:06.005]                             name <- restart$name
[10:34:06.005]                             if (is.null(name)) 
[10:34:06.005]                               next
[10:34:06.005]                             if (!grepl(pattern, name)) 
[10:34:06.005]                               next
[10:34:06.005]                             invokeRestart(restart)
[10:34:06.005]                             muffled <- TRUE
[10:34:06.005]                             break
[10:34:06.005]                           }
[10:34:06.005]                         }
[10:34:06.005]                       }
[10:34:06.005]                       invisible(muffled)
[10:34:06.005]                     }
[10:34:06.005]                     muffleCondition(cond, pattern = "^muffle")
[10:34:06.005]                   }
[10:34:06.005]                 }
[10:34:06.005]             }
[10:34:06.005]         }))
[10:34:06.005]     }, error = function(ex) {
[10:34:06.005]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:06.005]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:06.005]                 ...future.rng), started = ...future.startTime, 
[10:34:06.005]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:06.005]             version = "1.8"), class = "FutureResult")
[10:34:06.005]     }, finally = {
[10:34:06.005]         if (!identical(...future.workdir, getwd())) 
[10:34:06.005]             setwd(...future.workdir)
[10:34:06.005]         {
[10:34:06.005]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:06.005]                 ...future.oldOptions$nwarnings <- NULL
[10:34:06.005]             }
[10:34:06.005]             base::options(...future.oldOptions)
[10:34:06.005]             if (.Platform$OS.type == "windows") {
[10:34:06.005]                 old_names <- names(...future.oldEnvVars)
[10:34:06.005]                 envs <- base::Sys.getenv()
[10:34:06.005]                 names <- names(envs)
[10:34:06.005]                 common <- intersect(names, old_names)
[10:34:06.005]                 added <- setdiff(names, old_names)
[10:34:06.005]                 removed <- setdiff(old_names, names)
[10:34:06.005]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:06.005]                   envs[common]]
[10:34:06.005]                 NAMES <- toupper(changed)
[10:34:06.005]                 args <- list()
[10:34:06.005]                 for (kk in seq_along(NAMES)) {
[10:34:06.005]                   name <- changed[[kk]]
[10:34:06.005]                   NAME <- NAMES[[kk]]
[10:34:06.005]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:06.005]                     next
[10:34:06.005]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:06.005]                 }
[10:34:06.005]                 NAMES <- toupper(added)
[10:34:06.005]                 for (kk in seq_along(NAMES)) {
[10:34:06.005]                   name <- added[[kk]]
[10:34:06.005]                   NAME <- NAMES[[kk]]
[10:34:06.005]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:06.005]                     next
[10:34:06.005]                   args[[name]] <- ""
[10:34:06.005]                 }
[10:34:06.005]                 NAMES <- toupper(removed)
[10:34:06.005]                 for (kk in seq_along(NAMES)) {
[10:34:06.005]                   name <- removed[[kk]]
[10:34:06.005]                   NAME <- NAMES[[kk]]
[10:34:06.005]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:06.005]                     next
[10:34:06.005]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:06.005]                 }
[10:34:06.005]                 if (length(args) > 0) 
[10:34:06.005]                   base::do.call(base::Sys.setenv, args = args)
[10:34:06.005]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:06.005]             }
[10:34:06.005]             else {
[10:34:06.005]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:06.005]             }
[10:34:06.005]             {
[10:34:06.005]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:06.005]                   0L) {
[10:34:06.005]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:06.005]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:06.005]                   base::options(opts)
[10:34:06.005]                 }
[10:34:06.005]                 {
[10:34:06.005]                   {
[10:34:06.005]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:06.005]                     NULL
[10:34:06.005]                   }
[10:34:06.005]                   options(future.plan = NULL)
[10:34:06.005]                   if (is.na(NA_character_)) 
[10:34:06.005]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:06.005]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:06.005]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:06.005]                     .init = FALSE)
[10:34:06.005]                 }
[10:34:06.005]             }
[10:34:06.005]         }
[10:34:06.005]     })
[10:34:06.005]     if (TRUE) {
[10:34:06.005]         base::sink(type = "output", split = FALSE)
[10:34:06.005]         if (TRUE) {
[10:34:06.005]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:06.005]         }
[10:34:06.005]         else {
[10:34:06.005]             ...future.result["stdout"] <- base::list(NULL)
[10:34:06.005]         }
[10:34:06.005]         base::close(...future.stdout)
[10:34:06.005]         ...future.stdout <- NULL
[10:34:06.005]     }
[10:34:06.005]     ...future.result$conditions <- ...future.conditions
[10:34:06.005]     ...future.result$finished <- base::Sys.time()
[10:34:06.005]     ...future.result
[10:34:06.005] }
[10:34:06.008] MultisessionFuture started
[10:34:06.008] - Launch lazy future ... done
[10:34:06.009] run() for ‘MultisessionFuture’ ... done
[10:34:06.010] receiveMessageFromWorker() for ClusterFuture ...
[10:34:06.010] - Validating connection of MultisessionFuture
[10:34:06.011] - received message: FutureResult
[10:34:06.011] - Received FutureResult
[10:34:06.011] - Erased future from FutureRegistry
[10:34:06.011] result() for ClusterFuture ...
[10:34:06.011] - result already collected: FutureResult
[10:34:06.011] result() for ClusterFuture ... done
[10:34:06.011] signalConditions() ...
[10:34:06.011]  - include = ‘immediateCondition’
[10:34:06.011]  - exclude = 
[10:34:06.012]  - resignal = FALSE
[10:34:06.012]  - Number of conditions: 1
[10:34:06.012] signalConditions() ... done
[10:34:06.012] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:06.012] A MultisessionFuture was resolved (result was not collected)
[10:34:06.012] getGlobalsAndPackages() ...
[10:34:06.012] Searching for globals...
[10:34:06.013] - globals found: [2] ‘list’, ‘stop’
[10:34:06.013] Searching for globals ... DONE
[10:34:06.013] Resolving globals: FALSE
[10:34:06.013] 
[10:34:06.013] 
[10:34:06.014] getGlobalsAndPackages() ... DONE
[10:34:06.014] run() for ‘Future’ ...
[10:34:06.014] - state: ‘created’
[10:34:06.014] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:06.028] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:06.028] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:06.028]   - Field: ‘node’
[10:34:06.028]   - Field: ‘label’
[10:34:06.028]   - Field: ‘local’
[10:34:06.028]   - Field: ‘owner’
[10:34:06.028]   - Field: ‘envir’
[10:34:06.028]   - Field: ‘workers’
[10:34:06.028]   - Field: ‘packages’
[10:34:06.028]   - Field: ‘gc’
[10:34:06.029]   - Field: ‘conditions’
[10:34:06.029]   - Field: ‘persistent’
[10:34:06.029]   - Field: ‘expr’
[10:34:06.029]   - Field: ‘uuid’
[10:34:06.029]   - Field: ‘seed’
[10:34:06.029]   - Field: ‘version’
[10:34:06.029]   - Field: ‘result’
[10:34:06.029]   - Field: ‘asynchronous’
[10:34:06.029]   - Field: ‘calls’
[10:34:06.029]   - Field: ‘globals’
[10:34:06.029]   - Field: ‘stdout’
[10:34:06.030]   - Field: ‘earlySignal’
[10:34:06.030]   - Field: ‘lazy’
[10:34:06.030]   - Field: ‘state’
[10:34:06.030] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:06.030] - Launch lazy future ...
[10:34:06.030] Packages needed by the future expression (n = 0): <none>
[10:34:06.030] Packages needed by future strategies (n = 0): <none>
[10:34:06.031] {
[10:34:06.031]     {
[10:34:06.031]         {
[10:34:06.031]             ...future.startTime <- base::Sys.time()
[10:34:06.031]             {
[10:34:06.031]                 {
[10:34:06.031]                   {
[10:34:06.031]                     {
[10:34:06.031]                       base::local({
[10:34:06.031]                         has_future <- base::requireNamespace("future", 
[10:34:06.031]                           quietly = TRUE)
[10:34:06.031]                         if (has_future) {
[10:34:06.031]                           ns <- base::getNamespace("future")
[10:34:06.031]                           version <- ns[[".package"]][["version"]]
[10:34:06.031]                           if (is.null(version)) 
[10:34:06.031]                             version <- utils::packageVersion("future")
[10:34:06.031]                         }
[10:34:06.031]                         else {
[10:34:06.031]                           version <- NULL
[10:34:06.031]                         }
[10:34:06.031]                         if (!has_future || version < "1.8.0") {
[10:34:06.031]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:06.031]                             "", base::R.version$version.string), 
[10:34:06.031]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:06.031]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:06.031]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:06.031]                               "release", "version")], collapse = " "), 
[10:34:06.031]                             hostname = base::Sys.info()[["nodename"]])
[10:34:06.031]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:06.031]                             info)
[10:34:06.031]                           info <- base::paste(info, collapse = "; ")
[10:34:06.031]                           if (!has_future) {
[10:34:06.031]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:06.031]                               info)
[10:34:06.031]                           }
[10:34:06.031]                           else {
[10:34:06.031]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:06.031]                               info, version)
[10:34:06.031]                           }
[10:34:06.031]                           base::stop(msg)
[10:34:06.031]                         }
[10:34:06.031]                       })
[10:34:06.031]                     }
[10:34:06.031]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:06.031]                     base::options(mc.cores = 1L)
[10:34:06.031]                   }
[10:34:06.031]                   ...future.strategy.old <- future::plan("list")
[10:34:06.031]                   options(future.plan = NULL)
[10:34:06.031]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:06.031]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:06.031]                 }
[10:34:06.031]                 ...future.workdir <- getwd()
[10:34:06.031]             }
[10:34:06.031]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:06.031]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:06.031]         }
[10:34:06.031]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:06.031]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:06.031]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:06.031]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:06.031]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:06.031]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:06.031]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:06.031]             base::names(...future.oldOptions))
[10:34:06.031]     }
[10:34:06.031]     if (FALSE) {
[10:34:06.031]     }
[10:34:06.031]     else {
[10:34:06.031]         if (TRUE) {
[10:34:06.031]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:06.031]                 open = "w")
[10:34:06.031]         }
[10:34:06.031]         else {
[10:34:06.031]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:06.031]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:06.031]         }
[10:34:06.031]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:06.031]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:06.031]             base::sink(type = "output", split = FALSE)
[10:34:06.031]             base::close(...future.stdout)
[10:34:06.031]         }, add = TRUE)
[10:34:06.031]     }
[10:34:06.031]     ...future.frame <- base::sys.nframe()
[10:34:06.031]     ...future.conditions <- base::list()
[10:34:06.031]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:06.031]     if (FALSE) {
[10:34:06.031]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:06.031]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:06.031]     }
[10:34:06.031]     ...future.result <- base::tryCatch({
[10:34:06.031]         base::withCallingHandlers({
[10:34:06.031]             ...future.value <- base::withVisible(base::local({
[10:34:06.031]                 ...future.makeSendCondition <- base::local({
[10:34:06.031]                   sendCondition <- NULL
[10:34:06.031]                   function(frame = 1L) {
[10:34:06.031]                     if (is.function(sendCondition)) 
[10:34:06.031]                       return(sendCondition)
[10:34:06.031]                     ns <- getNamespace("parallel")
[10:34:06.031]                     if (exists("sendData", mode = "function", 
[10:34:06.031]                       envir = ns)) {
[10:34:06.031]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:06.031]                         envir = ns)
[10:34:06.031]                       envir <- sys.frame(frame)
[10:34:06.031]                       master <- NULL
[10:34:06.031]                       while (!identical(envir, .GlobalEnv) && 
[10:34:06.031]                         !identical(envir, emptyenv())) {
[10:34:06.031]                         if (exists("master", mode = "list", envir = envir, 
[10:34:06.031]                           inherits = FALSE)) {
[10:34:06.031]                           master <- get("master", mode = "list", 
[10:34:06.031]                             envir = envir, inherits = FALSE)
[10:34:06.031]                           if (inherits(master, c("SOCKnode", 
[10:34:06.031]                             "SOCK0node"))) {
[10:34:06.031]                             sendCondition <<- function(cond) {
[10:34:06.031]                               data <- list(type = "VALUE", value = cond, 
[10:34:06.031]                                 success = TRUE)
[10:34:06.031]                               parallel_sendData(master, data)
[10:34:06.031]                             }
[10:34:06.031]                             return(sendCondition)
[10:34:06.031]                           }
[10:34:06.031]                         }
[10:34:06.031]                         frame <- frame + 1L
[10:34:06.031]                         envir <- sys.frame(frame)
[10:34:06.031]                       }
[10:34:06.031]                     }
[10:34:06.031]                     sendCondition <<- function(cond) NULL
[10:34:06.031]                   }
[10:34:06.031]                 })
[10:34:06.031]                 withCallingHandlers({
[10:34:06.031]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:34:06.031]                 }, immediateCondition = function(cond) {
[10:34:06.031]                   sendCondition <- ...future.makeSendCondition()
[10:34:06.031]                   sendCondition(cond)
[10:34:06.031]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:06.031]                   {
[10:34:06.031]                     inherits <- base::inherits
[10:34:06.031]                     invokeRestart <- base::invokeRestart
[10:34:06.031]                     is.null <- base::is.null
[10:34:06.031]                     muffled <- FALSE
[10:34:06.031]                     if (inherits(cond, "message")) {
[10:34:06.031]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:06.031]                       if (muffled) 
[10:34:06.031]                         invokeRestart("muffleMessage")
[10:34:06.031]                     }
[10:34:06.031]                     else if (inherits(cond, "warning")) {
[10:34:06.031]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:06.031]                       if (muffled) 
[10:34:06.031]                         invokeRestart("muffleWarning")
[10:34:06.031]                     }
[10:34:06.031]                     else if (inherits(cond, "condition")) {
[10:34:06.031]                       if (!is.null(pattern)) {
[10:34:06.031]                         computeRestarts <- base::computeRestarts
[10:34:06.031]                         grepl <- base::grepl
[10:34:06.031]                         restarts <- computeRestarts(cond)
[10:34:06.031]                         for (restart in restarts) {
[10:34:06.031]                           name <- restart$name
[10:34:06.031]                           if (is.null(name)) 
[10:34:06.031]                             next
[10:34:06.031]                           if (!grepl(pattern, name)) 
[10:34:06.031]                             next
[10:34:06.031]                           invokeRestart(restart)
[10:34:06.031]                           muffled <- TRUE
[10:34:06.031]                           break
[10:34:06.031]                         }
[10:34:06.031]                       }
[10:34:06.031]                     }
[10:34:06.031]                     invisible(muffled)
[10:34:06.031]                   }
[10:34:06.031]                   muffleCondition(cond)
[10:34:06.031]                 })
[10:34:06.031]             }))
[10:34:06.031]             future::FutureResult(value = ...future.value$value, 
[10:34:06.031]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:06.031]                   ...future.rng), globalenv = if (FALSE) 
[10:34:06.031]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:06.031]                     ...future.globalenv.names))
[10:34:06.031]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:06.031]         }, condition = base::local({
[10:34:06.031]             c <- base::c
[10:34:06.031]             inherits <- base::inherits
[10:34:06.031]             invokeRestart <- base::invokeRestart
[10:34:06.031]             length <- base::length
[10:34:06.031]             list <- base::list
[10:34:06.031]             seq.int <- base::seq.int
[10:34:06.031]             signalCondition <- base::signalCondition
[10:34:06.031]             sys.calls <- base::sys.calls
[10:34:06.031]             `[[` <- base::`[[`
[10:34:06.031]             `+` <- base::`+`
[10:34:06.031]             `<<-` <- base::`<<-`
[10:34:06.031]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:06.031]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:06.031]                   3L)]
[10:34:06.031]             }
[10:34:06.031]             function(cond) {
[10:34:06.031]                 is_error <- inherits(cond, "error")
[10:34:06.031]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:06.031]                   NULL)
[10:34:06.031]                 if (is_error) {
[10:34:06.031]                   sessionInformation <- function() {
[10:34:06.031]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:06.031]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:06.031]                       search = base::search(), system = base::Sys.info())
[10:34:06.031]                   }
[10:34:06.031]                   ...future.conditions[[length(...future.conditions) + 
[10:34:06.031]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:06.031]                     cond$call), session = sessionInformation(), 
[10:34:06.031]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:06.031]                   signalCondition(cond)
[10:34:06.031]                 }
[10:34:06.031]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:06.031]                 "immediateCondition"))) {
[10:34:06.031]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:06.031]                   ...future.conditions[[length(...future.conditions) + 
[10:34:06.031]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:06.031]                   if (TRUE && !signal) {
[10:34:06.031]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:06.031]                     {
[10:34:06.031]                       inherits <- base::inherits
[10:34:06.031]                       invokeRestart <- base::invokeRestart
[10:34:06.031]                       is.null <- base::is.null
[10:34:06.031]                       muffled <- FALSE
[10:34:06.031]                       if (inherits(cond, "message")) {
[10:34:06.031]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:06.031]                         if (muffled) 
[10:34:06.031]                           invokeRestart("muffleMessage")
[10:34:06.031]                       }
[10:34:06.031]                       else if (inherits(cond, "warning")) {
[10:34:06.031]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:06.031]                         if (muffled) 
[10:34:06.031]                           invokeRestart("muffleWarning")
[10:34:06.031]                       }
[10:34:06.031]                       else if (inherits(cond, "condition")) {
[10:34:06.031]                         if (!is.null(pattern)) {
[10:34:06.031]                           computeRestarts <- base::computeRestarts
[10:34:06.031]                           grepl <- base::grepl
[10:34:06.031]                           restarts <- computeRestarts(cond)
[10:34:06.031]                           for (restart in restarts) {
[10:34:06.031]                             name <- restart$name
[10:34:06.031]                             if (is.null(name)) 
[10:34:06.031]                               next
[10:34:06.031]                             if (!grepl(pattern, name)) 
[10:34:06.031]                               next
[10:34:06.031]                             invokeRestart(restart)
[10:34:06.031]                             muffled <- TRUE
[10:34:06.031]                             break
[10:34:06.031]                           }
[10:34:06.031]                         }
[10:34:06.031]                       }
[10:34:06.031]                       invisible(muffled)
[10:34:06.031]                     }
[10:34:06.031]                     muffleCondition(cond, pattern = "^muffle")
[10:34:06.031]                   }
[10:34:06.031]                 }
[10:34:06.031]                 else {
[10:34:06.031]                   if (TRUE) {
[10:34:06.031]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:06.031]                     {
[10:34:06.031]                       inherits <- base::inherits
[10:34:06.031]                       invokeRestart <- base::invokeRestart
[10:34:06.031]                       is.null <- base::is.null
[10:34:06.031]                       muffled <- FALSE
[10:34:06.031]                       if (inherits(cond, "message")) {
[10:34:06.031]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:06.031]                         if (muffled) 
[10:34:06.031]                           invokeRestart("muffleMessage")
[10:34:06.031]                       }
[10:34:06.031]                       else if (inherits(cond, "warning")) {
[10:34:06.031]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:06.031]                         if (muffled) 
[10:34:06.031]                           invokeRestart("muffleWarning")
[10:34:06.031]                       }
[10:34:06.031]                       else if (inherits(cond, "condition")) {
[10:34:06.031]                         if (!is.null(pattern)) {
[10:34:06.031]                           computeRestarts <- base::computeRestarts
[10:34:06.031]                           grepl <- base::grepl
[10:34:06.031]                           restarts <- computeRestarts(cond)
[10:34:06.031]                           for (restart in restarts) {
[10:34:06.031]                             name <- restart$name
[10:34:06.031]                             if (is.null(name)) 
[10:34:06.031]                               next
[10:34:06.031]                             if (!grepl(pattern, name)) 
[10:34:06.031]                               next
[10:34:06.031]                             invokeRestart(restart)
[10:34:06.031]                             muffled <- TRUE
[10:34:06.031]                             break
[10:34:06.031]                           }
[10:34:06.031]                         }
[10:34:06.031]                       }
[10:34:06.031]                       invisible(muffled)
[10:34:06.031]                     }
[10:34:06.031]                     muffleCondition(cond, pattern = "^muffle")
[10:34:06.031]                   }
[10:34:06.031]                 }
[10:34:06.031]             }
[10:34:06.031]         }))
[10:34:06.031]     }, error = function(ex) {
[10:34:06.031]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:06.031]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:06.031]                 ...future.rng), started = ...future.startTime, 
[10:34:06.031]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:06.031]             version = "1.8"), class = "FutureResult")
[10:34:06.031]     }, finally = {
[10:34:06.031]         if (!identical(...future.workdir, getwd())) 
[10:34:06.031]             setwd(...future.workdir)
[10:34:06.031]         {
[10:34:06.031]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:06.031]                 ...future.oldOptions$nwarnings <- NULL
[10:34:06.031]             }
[10:34:06.031]             base::options(...future.oldOptions)
[10:34:06.031]             if (.Platform$OS.type == "windows") {
[10:34:06.031]                 old_names <- names(...future.oldEnvVars)
[10:34:06.031]                 envs <- base::Sys.getenv()
[10:34:06.031]                 names <- names(envs)
[10:34:06.031]                 common <- intersect(names, old_names)
[10:34:06.031]                 added <- setdiff(names, old_names)
[10:34:06.031]                 removed <- setdiff(old_names, names)
[10:34:06.031]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:06.031]                   envs[common]]
[10:34:06.031]                 NAMES <- toupper(changed)
[10:34:06.031]                 args <- list()
[10:34:06.031]                 for (kk in seq_along(NAMES)) {
[10:34:06.031]                   name <- changed[[kk]]
[10:34:06.031]                   NAME <- NAMES[[kk]]
[10:34:06.031]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:06.031]                     next
[10:34:06.031]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:06.031]                 }
[10:34:06.031]                 NAMES <- toupper(added)
[10:34:06.031]                 for (kk in seq_along(NAMES)) {
[10:34:06.031]                   name <- added[[kk]]
[10:34:06.031]                   NAME <- NAMES[[kk]]
[10:34:06.031]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:06.031]                     next
[10:34:06.031]                   args[[name]] <- ""
[10:34:06.031]                 }
[10:34:06.031]                 NAMES <- toupper(removed)
[10:34:06.031]                 for (kk in seq_along(NAMES)) {
[10:34:06.031]                   name <- removed[[kk]]
[10:34:06.031]                   NAME <- NAMES[[kk]]
[10:34:06.031]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:06.031]                     next
[10:34:06.031]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:06.031]                 }
[10:34:06.031]                 if (length(args) > 0) 
[10:34:06.031]                   base::do.call(base::Sys.setenv, args = args)
[10:34:06.031]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:06.031]             }
[10:34:06.031]             else {
[10:34:06.031]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:06.031]             }
[10:34:06.031]             {
[10:34:06.031]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:06.031]                   0L) {
[10:34:06.031]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:06.031]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:06.031]                   base::options(opts)
[10:34:06.031]                 }
[10:34:06.031]                 {
[10:34:06.031]                   {
[10:34:06.031]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:06.031]                     NULL
[10:34:06.031]                   }
[10:34:06.031]                   options(future.plan = NULL)
[10:34:06.031]                   if (is.na(NA_character_)) 
[10:34:06.031]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:06.031]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:06.031]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:06.031]                     .init = FALSE)
[10:34:06.031]                 }
[10:34:06.031]             }
[10:34:06.031]         }
[10:34:06.031]     })
[10:34:06.031]     if (TRUE) {
[10:34:06.031]         base::sink(type = "output", split = FALSE)
[10:34:06.031]         if (TRUE) {
[10:34:06.031]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:06.031]         }
[10:34:06.031]         else {
[10:34:06.031]             ...future.result["stdout"] <- base::list(NULL)
[10:34:06.031]         }
[10:34:06.031]         base::close(...future.stdout)
[10:34:06.031]         ...future.stdout <- NULL
[10:34:06.031]     }
[10:34:06.031]     ...future.result$conditions <- ...future.conditions
[10:34:06.031]     ...future.result$finished <- base::Sys.time()
[10:34:06.031]     ...future.result
[10:34:06.031] }
[10:34:06.033] MultisessionFuture started
[10:34:06.033] - Launch lazy future ... done
[10:34:06.034] run() for ‘MultisessionFuture’ ... done
[10:34:06.035] receiveMessageFromWorker() for ClusterFuture ...
[10:34:06.035] - Validating connection of MultisessionFuture
[10:34:06.035] - received message: FutureResult
[10:34:06.036] - Received FutureResult
[10:34:06.036] - Erased future from FutureRegistry
[10:34:06.036] result() for ClusterFuture ...
[10:34:06.036] - result already collected: FutureResult
[10:34:06.036] result() for ClusterFuture ... done
[10:34:06.036] signalConditions() ...
[10:34:06.036]  - include = ‘immediateCondition’
[10:34:06.036]  - exclude = 
[10:34:06.036]  - resignal = FALSE
[10:34:06.036]  - Number of conditions: 1
[10:34:06.036] signalConditions() ... done
[10:34:06.036] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:06.037] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 0 ... DONE
- result = FALSE, recursive = 1 ...
[10:34:06.037] getGlobalsAndPackages() ...
[10:34:06.037] Searching for globals...
[10:34:06.038] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:34:06.038] Searching for globals ... DONE
[10:34:06.038] Resolving globals: FALSE
[10:34:06.039] 
[10:34:06.039] 
[10:34:06.039] getGlobalsAndPackages() ... DONE
[10:34:06.039] run() for ‘Future’ ...
[10:34:06.039] - state: ‘created’
[10:34:06.039] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:06.054] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:06.055] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:06.055]   - Field: ‘node’
[10:34:06.055]   - Field: ‘label’
[10:34:06.055]   - Field: ‘local’
[10:34:06.055]   - Field: ‘owner’
[10:34:06.055]   - Field: ‘envir’
[10:34:06.055]   - Field: ‘workers’
[10:34:06.055]   - Field: ‘packages’
[10:34:06.055]   - Field: ‘gc’
[10:34:06.055]   - Field: ‘conditions’
[10:34:06.056]   - Field: ‘persistent’
[10:34:06.056]   - Field: ‘expr’
[10:34:06.056]   - Field: ‘uuid’
[10:34:06.056]   - Field: ‘seed’
[10:34:06.056]   - Field: ‘version’
[10:34:06.056]   - Field: ‘result’
[10:34:06.056]   - Field: ‘asynchronous’
[10:34:06.056]   - Field: ‘calls’
[10:34:06.056]   - Field: ‘globals’
[10:34:06.056]   - Field: ‘stdout’
[10:34:06.056]   - Field: ‘earlySignal’
[10:34:06.057]   - Field: ‘lazy’
[10:34:06.057]   - Field: ‘state’
[10:34:06.057] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:06.057] - Launch lazy future ...
[10:34:06.057] Packages needed by the future expression (n = 0): <none>
[10:34:06.057] Packages needed by future strategies (n = 0): <none>
[10:34:06.058] {
[10:34:06.058]     {
[10:34:06.058]         {
[10:34:06.058]             ...future.startTime <- base::Sys.time()
[10:34:06.058]             {
[10:34:06.058]                 {
[10:34:06.058]                   {
[10:34:06.058]                     {
[10:34:06.058]                       base::local({
[10:34:06.058]                         has_future <- base::requireNamespace("future", 
[10:34:06.058]                           quietly = TRUE)
[10:34:06.058]                         if (has_future) {
[10:34:06.058]                           ns <- base::getNamespace("future")
[10:34:06.058]                           version <- ns[[".package"]][["version"]]
[10:34:06.058]                           if (is.null(version)) 
[10:34:06.058]                             version <- utils::packageVersion("future")
[10:34:06.058]                         }
[10:34:06.058]                         else {
[10:34:06.058]                           version <- NULL
[10:34:06.058]                         }
[10:34:06.058]                         if (!has_future || version < "1.8.0") {
[10:34:06.058]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:06.058]                             "", base::R.version$version.string), 
[10:34:06.058]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:06.058]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:06.058]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:06.058]                               "release", "version")], collapse = " "), 
[10:34:06.058]                             hostname = base::Sys.info()[["nodename"]])
[10:34:06.058]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:06.058]                             info)
[10:34:06.058]                           info <- base::paste(info, collapse = "; ")
[10:34:06.058]                           if (!has_future) {
[10:34:06.058]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:06.058]                               info)
[10:34:06.058]                           }
[10:34:06.058]                           else {
[10:34:06.058]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:06.058]                               info, version)
[10:34:06.058]                           }
[10:34:06.058]                           base::stop(msg)
[10:34:06.058]                         }
[10:34:06.058]                       })
[10:34:06.058]                     }
[10:34:06.058]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:06.058]                     base::options(mc.cores = 1L)
[10:34:06.058]                   }
[10:34:06.058]                   ...future.strategy.old <- future::plan("list")
[10:34:06.058]                   options(future.plan = NULL)
[10:34:06.058]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:06.058]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:06.058]                 }
[10:34:06.058]                 ...future.workdir <- getwd()
[10:34:06.058]             }
[10:34:06.058]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:06.058]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:06.058]         }
[10:34:06.058]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:06.058]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:06.058]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:06.058]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:06.058]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:06.058]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:06.058]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:06.058]             base::names(...future.oldOptions))
[10:34:06.058]     }
[10:34:06.058]     if (FALSE) {
[10:34:06.058]     }
[10:34:06.058]     else {
[10:34:06.058]         if (TRUE) {
[10:34:06.058]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:06.058]                 open = "w")
[10:34:06.058]         }
[10:34:06.058]         else {
[10:34:06.058]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:06.058]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:06.058]         }
[10:34:06.058]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:06.058]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:06.058]             base::sink(type = "output", split = FALSE)
[10:34:06.058]             base::close(...future.stdout)
[10:34:06.058]         }, add = TRUE)
[10:34:06.058]     }
[10:34:06.058]     ...future.frame <- base::sys.nframe()
[10:34:06.058]     ...future.conditions <- base::list()
[10:34:06.058]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:06.058]     if (FALSE) {
[10:34:06.058]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:06.058]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:06.058]     }
[10:34:06.058]     ...future.result <- base::tryCatch({
[10:34:06.058]         base::withCallingHandlers({
[10:34:06.058]             ...future.value <- base::withVisible(base::local({
[10:34:06.058]                 ...future.makeSendCondition <- base::local({
[10:34:06.058]                   sendCondition <- NULL
[10:34:06.058]                   function(frame = 1L) {
[10:34:06.058]                     if (is.function(sendCondition)) 
[10:34:06.058]                       return(sendCondition)
[10:34:06.058]                     ns <- getNamespace("parallel")
[10:34:06.058]                     if (exists("sendData", mode = "function", 
[10:34:06.058]                       envir = ns)) {
[10:34:06.058]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:06.058]                         envir = ns)
[10:34:06.058]                       envir <- sys.frame(frame)
[10:34:06.058]                       master <- NULL
[10:34:06.058]                       while (!identical(envir, .GlobalEnv) && 
[10:34:06.058]                         !identical(envir, emptyenv())) {
[10:34:06.058]                         if (exists("master", mode = "list", envir = envir, 
[10:34:06.058]                           inherits = FALSE)) {
[10:34:06.058]                           master <- get("master", mode = "list", 
[10:34:06.058]                             envir = envir, inherits = FALSE)
[10:34:06.058]                           if (inherits(master, c("SOCKnode", 
[10:34:06.058]                             "SOCK0node"))) {
[10:34:06.058]                             sendCondition <<- function(cond) {
[10:34:06.058]                               data <- list(type = "VALUE", value = cond, 
[10:34:06.058]                                 success = TRUE)
[10:34:06.058]                               parallel_sendData(master, data)
[10:34:06.058]                             }
[10:34:06.058]                             return(sendCondition)
[10:34:06.058]                           }
[10:34:06.058]                         }
[10:34:06.058]                         frame <- frame + 1L
[10:34:06.058]                         envir <- sys.frame(frame)
[10:34:06.058]                       }
[10:34:06.058]                     }
[10:34:06.058]                     sendCondition <<- function(cond) NULL
[10:34:06.058]                   }
[10:34:06.058]                 })
[10:34:06.058]                 withCallingHandlers({
[10:34:06.058]                   {
[10:34:06.058]                     Sys.sleep(0.5)
[10:34:06.058]                     list(a = 1, b = 42L)
[10:34:06.058]                   }
[10:34:06.058]                 }, immediateCondition = function(cond) {
[10:34:06.058]                   sendCondition <- ...future.makeSendCondition()
[10:34:06.058]                   sendCondition(cond)
[10:34:06.058]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:06.058]                   {
[10:34:06.058]                     inherits <- base::inherits
[10:34:06.058]                     invokeRestart <- base::invokeRestart
[10:34:06.058]                     is.null <- base::is.null
[10:34:06.058]                     muffled <- FALSE
[10:34:06.058]                     if (inherits(cond, "message")) {
[10:34:06.058]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:06.058]                       if (muffled) 
[10:34:06.058]                         invokeRestart("muffleMessage")
[10:34:06.058]                     }
[10:34:06.058]                     else if (inherits(cond, "warning")) {
[10:34:06.058]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:06.058]                       if (muffled) 
[10:34:06.058]                         invokeRestart("muffleWarning")
[10:34:06.058]                     }
[10:34:06.058]                     else if (inherits(cond, "condition")) {
[10:34:06.058]                       if (!is.null(pattern)) {
[10:34:06.058]                         computeRestarts <- base::computeRestarts
[10:34:06.058]                         grepl <- base::grepl
[10:34:06.058]                         restarts <- computeRestarts(cond)
[10:34:06.058]                         for (restart in restarts) {
[10:34:06.058]                           name <- restart$name
[10:34:06.058]                           if (is.null(name)) 
[10:34:06.058]                             next
[10:34:06.058]                           if (!grepl(pattern, name)) 
[10:34:06.058]                             next
[10:34:06.058]                           invokeRestart(restart)
[10:34:06.058]                           muffled <- TRUE
[10:34:06.058]                           break
[10:34:06.058]                         }
[10:34:06.058]                       }
[10:34:06.058]                     }
[10:34:06.058]                     invisible(muffled)
[10:34:06.058]                   }
[10:34:06.058]                   muffleCondition(cond)
[10:34:06.058]                 })
[10:34:06.058]             }))
[10:34:06.058]             future::FutureResult(value = ...future.value$value, 
[10:34:06.058]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:06.058]                   ...future.rng), globalenv = if (FALSE) 
[10:34:06.058]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:06.058]                     ...future.globalenv.names))
[10:34:06.058]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:06.058]         }, condition = base::local({
[10:34:06.058]             c <- base::c
[10:34:06.058]             inherits <- base::inherits
[10:34:06.058]             invokeRestart <- base::invokeRestart
[10:34:06.058]             length <- base::length
[10:34:06.058]             list <- base::list
[10:34:06.058]             seq.int <- base::seq.int
[10:34:06.058]             signalCondition <- base::signalCondition
[10:34:06.058]             sys.calls <- base::sys.calls
[10:34:06.058]             `[[` <- base::`[[`
[10:34:06.058]             `+` <- base::`+`
[10:34:06.058]             `<<-` <- base::`<<-`
[10:34:06.058]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:06.058]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:06.058]                   3L)]
[10:34:06.058]             }
[10:34:06.058]             function(cond) {
[10:34:06.058]                 is_error <- inherits(cond, "error")
[10:34:06.058]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:06.058]                   NULL)
[10:34:06.058]                 if (is_error) {
[10:34:06.058]                   sessionInformation <- function() {
[10:34:06.058]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:06.058]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:06.058]                       search = base::search(), system = base::Sys.info())
[10:34:06.058]                   }
[10:34:06.058]                   ...future.conditions[[length(...future.conditions) + 
[10:34:06.058]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:06.058]                     cond$call), session = sessionInformation(), 
[10:34:06.058]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:06.058]                   signalCondition(cond)
[10:34:06.058]                 }
[10:34:06.058]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:06.058]                 "immediateCondition"))) {
[10:34:06.058]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:06.058]                   ...future.conditions[[length(...future.conditions) + 
[10:34:06.058]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:06.058]                   if (TRUE && !signal) {
[10:34:06.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:06.058]                     {
[10:34:06.058]                       inherits <- base::inherits
[10:34:06.058]                       invokeRestart <- base::invokeRestart
[10:34:06.058]                       is.null <- base::is.null
[10:34:06.058]                       muffled <- FALSE
[10:34:06.058]                       if (inherits(cond, "message")) {
[10:34:06.058]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:06.058]                         if (muffled) 
[10:34:06.058]                           invokeRestart("muffleMessage")
[10:34:06.058]                       }
[10:34:06.058]                       else if (inherits(cond, "warning")) {
[10:34:06.058]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:06.058]                         if (muffled) 
[10:34:06.058]                           invokeRestart("muffleWarning")
[10:34:06.058]                       }
[10:34:06.058]                       else if (inherits(cond, "condition")) {
[10:34:06.058]                         if (!is.null(pattern)) {
[10:34:06.058]                           computeRestarts <- base::computeRestarts
[10:34:06.058]                           grepl <- base::grepl
[10:34:06.058]                           restarts <- computeRestarts(cond)
[10:34:06.058]                           for (restart in restarts) {
[10:34:06.058]                             name <- restart$name
[10:34:06.058]                             if (is.null(name)) 
[10:34:06.058]                               next
[10:34:06.058]                             if (!grepl(pattern, name)) 
[10:34:06.058]                               next
[10:34:06.058]                             invokeRestart(restart)
[10:34:06.058]                             muffled <- TRUE
[10:34:06.058]                             break
[10:34:06.058]                           }
[10:34:06.058]                         }
[10:34:06.058]                       }
[10:34:06.058]                       invisible(muffled)
[10:34:06.058]                     }
[10:34:06.058]                     muffleCondition(cond, pattern = "^muffle")
[10:34:06.058]                   }
[10:34:06.058]                 }
[10:34:06.058]                 else {
[10:34:06.058]                   if (TRUE) {
[10:34:06.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:06.058]                     {
[10:34:06.058]                       inherits <- base::inherits
[10:34:06.058]                       invokeRestart <- base::invokeRestart
[10:34:06.058]                       is.null <- base::is.null
[10:34:06.058]                       muffled <- FALSE
[10:34:06.058]                       if (inherits(cond, "message")) {
[10:34:06.058]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:06.058]                         if (muffled) 
[10:34:06.058]                           invokeRestart("muffleMessage")
[10:34:06.058]                       }
[10:34:06.058]                       else if (inherits(cond, "warning")) {
[10:34:06.058]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:06.058]                         if (muffled) 
[10:34:06.058]                           invokeRestart("muffleWarning")
[10:34:06.058]                       }
[10:34:06.058]                       else if (inherits(cond, "condition")) {
[10:34:06.058]                         if (!is.null(pattern)) {
[10:34:06.058]                           computeRestarts <- base::computeRestarts
[10:34:06.058]                           grepl <- base::grepl
[10:34:06.058]                           restarts <- computeRestarts(cond)
[10:34:06.058]                           for (restart in restarts) {
[10:34:06.058]                             name <- restart$name
[10:34:06.058]                             if (is.null(name)) 
[10:34:06.058]                               next
[10:34:06.058]                             if (!grepl(pattern, name)) 
[10:34:06.058]                               next
[10:34:06.058]                             invokeRestart(restart)
[10:34:06.058]                             muffled <- TRUE
[10:34:06.058]                             break
[10:34:06.058]                           }
[10:34:06.058]                         }
[10:34:06.058]                       }
[10:34:06.058]                       invisible(muffled)
[10:34:06.058]                     }
[10:34:06.058]                     muffleCondition(cond, pattern = "^muffle")
[10:34:06.058]                   }
[10:34:06.058]                 }
[10:34:06.058]             }
[10:34:06.058]         }))
[10:34:06.058]     }, error = function(ex) {
[10:34:06.058]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:06.058]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:06.058]                 ...future.rng), started = ...future.startTime, 
[10:34:06.058]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:06.058]             version = "1.8"), class = "FutureResult")
[10:34:06.058]     }, finally = {
[10:34:06.058]         if (!identical(...future.workdir, getwd())) 
[10:34:06.058]             setwd(...future.workdir)
[10:34:06.058]         {
[10:34:06.058]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:06.058]                 ...future.oldOptions$nwarnings <- NULL
[10:34:06.058]             }
[10:34:06.058]             base::options(...future.oldOptions)
[10:34:06.058]             if (.Platform$OS.type == "windows") {
[10:34:06.058]                 old_names <- names(...future.oldEnvVars)
[10:34:06.058]                 envs <- base::Sys.getenv()
[10:34:06.058]                 names <- names(envs)
[10:34:06.058]                 common <- intersect(names, old_names)
[10:34:06.058]                 added <- setdiff(names, old_names)
[10:34:06.058]                 removed <- setdiff(old_names, names)
[10:34:06.058]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:06.058]                   envs[common]]
[10:34:06.058]                 NAMES <- toupper(changed)
[10:34:06.058]                 args <- list()
[10:34:06.058]                 for (kk in seq_along(NAMES)) {
[10:34:06.058]                   name <- changed[[kk]]
[10:34:06.058]                   NAME <- NAMES[[kk]]
[10:34:06.058]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:06.058]                     next
[10:34:06.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:06.058]                 }
[10:34:06.058]                 NAMES <- toupper(added)
[10:34:06.058]                 for (kk in seq_along(NAMES)) {
[10:34:06.058]                   name <- added[[kk]]
[10:34:06.058]                   NAME <- NAMES[[kk]]
[10:34:06.058]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:06.058]                     next
[10:34:06.058]                   args[[name]] <- ""
[10:34:06.058]                 }
[10:34:06.058]                 NAMES <- toupper(removed)
[10:34:06.058]                 for (kk in seq_along(NAMES)) {
[10:34:06.058]                   name <- removed[[kk]]
[10:34:06.058]                   NAME <- NAMES[[kk]]
[10:34:06.058]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:06.058]                     next
[10:34:06.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:06.058]                 }
[10:34:06.058]                 if (length(args) > 0) 
[10:34:06.058]                   base::do.call(base::Sys.setenv, args = args)
[10:34:06.058]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:06.058]             }
[10:34:06.058]             else {
[10:34:06.058]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:06.058]             }
[10:34:06.058]             {
[10:34:06.058]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:06.058]                   0L) {
[10:34:06.058]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:06.058]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:06.058]                   base::options(opts)
[10:34:06.058]                 }
[10:34:06.058]                 {
[10:34:06.058]                   {
[10:34:06.058]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:06.058]                     NULL
[10:34:06.058]                   }
[10:34:06.058]                   options(future.plan = NULL)
[10:34:06.058]                   if (is.na(NA_character_)) 
[10:34:06.058]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:06.058]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:06.058]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:06.058]                     .init = FALSE)
[10:34:06.058]                 }
[10:34:06.058]             }
[10:34:06.058]         }
[10:34:06.058]     })
[10:34:06.058]     if (TRUE) {
[10:34:06.058]         base::sink(type = "output", split = FALSE)
[10:34:06.058]         if (TRUE) {
[10:34:06.058]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:06.058]         }
[10:34:06.058]         else {
[10:34:06.058]             ...future.result["stdout"] <- base::list(NULL)
[10:34:06.058]         }
[10:34:06.058]         base::close(...future.stdout)
[10:34:06.058]         ...future.stdout <- NULL
[10:34:06.058]     }
[10:34:06.058]     ...future.result$conditions <- ...future.conditions
[10:34:06.058]     ...future.result$finished <- base::Sys.time()
[10:34:06.058]     ...future.result
[10:34:06.058] }
[10:34:06.060] MultisessionFuture started
[10:34:06.061] - Launch lazy future ... done
[10:34:06.061] run() for ‘MultisessionFuture’ ... done
[10:34:06.563] receiveMessageFromWorker() for ClusterFuture ...
[10:34:06.563] - Validating connection of MultisessionFuture
[10:34:06.563] - received message: FutureResult
[10:34:06.564] - Received FutureResult
[10:34:06.564] - Erased future from FutureRegistry
[10:34:06.564] result() for ClusterFuture ...
[10:34:06.564] - result already collected: FutureResult
[10:34:06.564] result() for ClusterFuture ... done
[10:34:06.564] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:06.564] A MultisessionFuture was resolved (result was not collected)
[10:34:06.564] getGlobalsAndPackages() ...
[10:34:06.564] Searching for globals...
[10:34:06.566] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:34:06.566] Searching for globals ... DONE
[10:34:06.566] Resolving globals: FALSE
[10:34:06.566] 
[10:34:06.566] 
[10:34:06.566] getGlobalsAndPackages() ... DONE
[10:34:06.567] run() for ‘Future’ ...
[10:34:06.567] - state: ‘created’
[10:34:06.567] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:06.581] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:06.581] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:06.581]   - Field: ‘node’
[10:34:06.581]   - Field: ‘label’
[10:34:06.581]   - Field: ‘local’
[10:34:06.581]   - Field: ‘owner’
[10:34:06.581]   - Field: ‘envir’
[10:34:06.582]   - Field: ‘workers’
[10:34:06.582]   - Field: ‘packages’
[10:34:06.582]   - Field: ‘gc’
[10:34:06.582]   - Field: ‘conditions’
[10:34:06.582]   - Field: ‘persistent’
[10:34:06.582]   - Field: ‘expr’
[10:34:06.582]   - Field: ‘uuid’
[10:34:06.582]   - Field: ‘seed’
[10:34:06.582]   - Field: ‘version’
[10:34:06.582]   - Field: ‘result’
[10:34:06.582]   - Field: ‘asynchronous’
[10:34:06.583]   - Field: ‘calls’
[10:34:06.583]   - Field: ‘globals’
[10:34:06.583]   - Field: ‘stdout’
[10:34:06.583]   - Field: ‘earlySignal’
[10:34:06.583]   - Field: ‘lazy’
[10:34:06.583]   - Field: ‘state’
[10:34:06.583] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:06.583] - Launch lazy future ...
[10:34:06.583] Packages needed by the future expression (n = 0): <none>
[10:34:06.584] Packages needed by future strategies (n = 0): <none>
[10:34:06.584] {
[10:34:06.584]     {
[10:34:06.584]         {
[10:34:06.584]             ...future.startTime <- base::Sys.time()
[10:34:06.584]             {
[10:34:06.584]                 {
[10:34:06.584]                   {
[10:34:06.584]                     {
[10:34:06.584]                       base::local({
[10:34:06.584]                         has_future <- base::requireNamespace("future", 
[10:34:06.584]                           quietly = TRUE)
[10:34:06.584]                         if (has_future) {
[10:34:06.584]                           ns <- base::getNamespace("future")
[10:34:06.584]                           version <- ns[[".package"]][["version"]]
[10:34:06.584]                           if (is.null(version)) 
[10:34:06.584]                             version <- utils::packageVersion("future")
[10:34:06.584]                         }
[10:34:06.584]                         else {
[10:34:06.584]                           version <- NULL
[10:34:06.584]                         }
[10:34:06.584]                         if (!has_future || version < "1.8.0") {
[10:34:06.584]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:06.584]                             "", base::R.version$version.string), 
[10:34:06.584]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:06.584]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:06.584]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:06.584]                               "release", "version")], collapse = " "), 
[10:34:06.584]                             hostname = base::Sys.info()[["nodename"]])
[10:34:06.584]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:06.584]                             info)
[10:34:06.584]                           info <- base::paste(info, collapse = "; ")
[10:34:06.584]                           if (!has_future) {
[10:34:06.584]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:06.584]                               info)
[10:34:06.584]                           }
[10:34:06.584]                           else {
[10:34:06.584]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:06.584]                               info, version)
[10:34:06.584]                           }
[10:34:06.584]                           base::stop(msg)
[10:34:06.584]                         }
[10:34:06.584]                       })
[10:34:06.584]                     }
[10:34:06.584]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:06.584]                     base::options(mc.cores = 1L)
[10:34:06.584]                   }
[10:34:06.584]                   ...future.strategy.old <- future::plan("list")
[10:34:06.584]                   options(future.plan = NULL)
[10:34:06.584]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:06.584]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:06.584]                 }
[10:34:06.584]                 ...future.workdir <- getwd()
[10:34:06.584]             }
[10:34:06.584]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:06.584]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:06.584]         }
[10:34:06.584]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:06.584]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:06.584]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:06.584]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:06.584]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:06.584]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:06.584]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:06.584]             base::names(...future.oldOptions))
[10:34:06.584]     }
[10:34:06.584]     if (FALSE) {
[10:34:06.584]     }
[10:34:06.584]     else {
[10:34:06.584]         if (TRUE) {
[10:34:06.584]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:06.584]                 open = "w")
[10:34:06.584]         }
[10:34:06.584]         else {
[10:34:06.584]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:06.584]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:06.584]         }
[10:34:06.584]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:06.584]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:06.584]             base::sink(type = "output", split = FALSE)
[10:34:06.584]             base::close(...future.stdout)
[10:34:06.584]         }, add = TRUE)
[10:34:06.584]     }
[10:34:06.584]     ...future.frame <- base::sys.nframe()
[10:34:06.584]     ...future.conditions <- base::list()
[10:34:06.584]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:06.584]     if (FALSE) {
[10:34:06.584]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:06.584]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:06.584]     }
[10:34:06.584]     ...future.result <- base::tryCatch({
[10:34:06.584]         base::withCallingHandlers({
[10:34:06.584]             ...future.value <- base::withVisible(base::local({
[10:34:06.584]                 ...future.makeSendCondition <- base::local({
[10:34:06.584]                   sendCondition <- NULL
[10:34:06.584]                   function(frame = 1L) {
[10:34:06.584]                     if (is.function(sendCondition)) 
[10:34:06.584]                       return(sendCondition)
[10:34:06.584]                     ns <- getNamespace("parallel")
[10:34:06.584]                     if (exists("sendData", mode = "function", 
[10:34:06.584]                       envir = ns)) {
[10:34:06.584]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:06.584]                         envir = ns)
[10:34:06.584]                       envir <- sys.frame(frame)
[10:34:06.584]                       master <- NULL
[10:34:06.584]                       while (!identical(envir, .GlobalEnv) && 
[10:34:06.584]                         !identical(envir, emptyenv())) {
[10:34:06.584]                         if (exists("master", mode = "list", envir = envir, 
[10:34:06.584]                           inherits = FALSE)) {
[10:34:06.584]                           master <- get("master", mode = "list", 
[10:34:06.584]                             envir = envir, inherits = FALSE)
[10:34:06.584]                           if (inherits(master, c("SOCKnode", 
[10:34:06.584]                             "SOCK0node"))) {
[10:34:06.584]                             sendCondition <<- function(cond) {
[10:34:06.584]                               data <- list(type = "VALUE", value = cond, 
[10:34:06.584]                                 success = TRUE)
[10:34:06.584]                               parallel_sendData(master, data)
[10:34:06.584]                             }
[10:34:06.584]                             return(sendCondition)
[10:34:06.584]                           }
[10:34:06.584]                         }
[10:34:06.584]                         frame <- frame + 1L
[10:34:06.584]                         envir <- sys.frame(frame)
[10:34:06.584]                       }
[10:34:06.584]                     }
[10:34:06.584]                     sendCondition <<- function(cond) NULL
[10:34:06.584]                   }
[10:34:06.584]                 })
[10:34:06.584]                 withCallingHandlers({
[10:34:06.584]                   {
[10:34:06.584]                     Sys.sleep(0.5)
[10:34:06.584]                     list(a = 1, b = 42L)
[10:34:06.584]                   }
[10:34:06.584]                 }, immediateCondition = function(cond) {
[10:34:06.584]                   sendCondition <- ...future.makeSendCondition()
[10:34:06.584]                   sendCondition(cond)
[10:34:06.584]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:06.584]                   {
[10:34:06.584]                     inherits <- base::inherits
[10:34:06.584]                     invokeRestart <- base::invokeRestart
[10:34:06.584]                     is.null <- base::is.null
[10:34:06.584]                     muffled <- FALSE
[10:34:06.584]                     if (inherits(cond, "message")) {
[10:34:06.584]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:06.584]                       if (muffled) 
[10:34:06.584]                         invokeRestart("muffleMessage")
[10:34:06.584]                     }
[10:34:06.584]                     else if (inherits(cond, "warning")) {
[10:34:06.584]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:06.584]                       if (muffled) 
[10:34:06.584]                         invokeRestart("muffleWarning")
[10:34:06.584]                     }
[10:34:06.584]                     else if (inherits(cond, "condition")) {
[10:34:06.584]                       if (!is.null(pattern)) {
[10:34:06.584]                         computeRestarts <- base::computeRestarts
[10:34:06.584]                         grepl <- base::grepl
[10:34:06.584]                         restarts <- computeRestarts(cond)
[10:34:06.584]                         for (restart in restarts) {
[10:34:06.584]                           name <- restart$name
[10:34:06.584]                           if (is.null(name)) 
[10:34:06.584]                             next
[10:34:06.584]                           if (!grepl(pattern, name)) 
[10:34:06.584]                             next
[10:34:06.584]                           invokeRestart(restart)
[10:34:06.584]                           muffled <- TRUE
[10:34:06.584]                           break
[10:34:06.584]                         }
[10:34:06.584]                       }
[10:34:06.584]                     }
[10:34:06.584]                     invisible(muffled)
[10:34:06.584]                   }
[10:34:06.584]                   muffleCondition(cond)
[10:34:06.584]                 })
[10:34:06.584]             }))
[10:34:06.584]             future::FutureResult(value = ...future.value$value, 
[10:34:06.584]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:06.584]                   ...future.rng), globalenv = if (FALSE) 
[10:34:06.584]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:06.584]                     ...future.globalenv.names))
[10:34:06.584]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:06.584]         }, condition = base::local({
[10:34:06.584]             c <- base::c
[10:34:06.584]             inherits <- base::inherits
[10:34:06.584]             invokeRestart <- base::invokeRestart
[10:34:06.584]             length <- base::length
[10:34:06.584]             list <- base::list
[10:34:06.584]             seq.int <- base::seq.int
[10:34:06.584]             signalCondition <- base::signalCondition
[10:34:06.584]             sys.calls <- base::sys.calls
[10:34:06.584]             `[[` <- base::`[[`
[10:34:06.584]             `+` <- base::`+`
[10:34:06.584]             `<<-` <- base::`<<-`
[10:34:06.584]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:06.584]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:06.584]                   3L)]
[10:34:06.584]             }
[10:34:06.584]             function(cond) {
[10:34:06.584]                 is_error <- inherits(cond, "error")
[10:34:06.584]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:06.584]                   NULL)
[10:34:06.584]                 if (is_error) {
[10:34:06.584]                   sessionInformation <- function() {
[10:34:06.584]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:06.584]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:06.584]                       search = base::search(), system = base::Sys.info())
[10:34:06.584]                   }
[10:34:06.584]                   ...future.conditions[[length(...future.conditions) + 
[10:34:06.584]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:06.584]                     cond$call), session = sessionInformation(), 
[10:34:06.584]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:06.584]                   signalCondition(cond)
[10:34:06.584]                 }
[10:34:06.584]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:06.584]                 "immediateCondition"))) {
[10:34:06.584]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:06.584]                   ...future.conditions[[length(...future.conditions) + 
[10:34:06.584]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:06.584]                   if (TRUE && !signal) {
[10:34:06.584]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:06.584]                     {
[10:34:06.584]                       inherits <- base::inherits
[10:34:06.584]                       invokeRestart <- base::invokeRestart
[10:34:06.584]                       is.null <- base::is.null
[10:34:06.584]                       muffled <- FALSE
[10:34:06.584]                       if (inherits(cond, "message")) {
[10:34:06.584]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:06.584]                         if (muffled) 
[10:34:06.584]                           invokeRestart("muffleMessage")
[10:34:06.584]                       }
[10:34:06.584]                       else if (inherits(cond, "warning")) {
[10:34:06.584]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:06.584]                         if (muffled) 
[10:34:06.584]                           invokeRestart("muffleWarning")
[10:34:06.584]                       }
[10:34:06.584]                       else if (inherits(cond, "condition")) {
[10:34:06.584]                         if (!is.null(pattern)) {
[10:34:06.584]                           computeRestarts <- base::computeRestarts
[10:34:06.584]                           grepl <- base::grepl
[10:34:06.584]                           restarts <- computeRestarts(cond)
[10:34:06.584]                           for (restart in restarts) {
[10:34:06.584]                             name <- restart$name
[10:34:06.584]                             if (is.null(name)) 
[10:34:06.584]                               next
[10:34:06.584]                             if (!grepl(pattern, name)) 
[10:34:06.584]                               next
[10:34:06.584]                             invokeRestart(restart)
[10:34:06.584]                             muffled <- TRUE
[10:34:06.584]                             break
[10:34:06.584]                           }
[10:34:06.584]                         }
[10:34:06.584]                       }
[10:34:06.584]                       invisible(muffled)
[10:34:06.584]                     }
[10:34:06.584]                     muffleCondition(cond, pattern = "^muffle")
[10:34:06.584]                   }
[10:34:06.584]                 }
[10:34:06.584]                 else {
[10:34:06.584]                   if (TRUE) {
[10:34:06.584]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:06.584]                     {
[10:34:06.584]                       inherits <- base::inherits
[10:34:06.584]                       invokeRestart <- base::invokeRestart
[10:34:06.584]                       is.null <- base::is.null
[10:34:06.584]                       muffled <- FALSE
[10:34:06.584]                       if (inherits(cond, "message")) {
[10:34:06.584]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:06.584]                         if (muffled) 
[10:34:06.584]                           invokeRestart("muffleMessage")
[10:34:06.584]                       }
[10:34:06.584]                       else if (inherits(cond, "warning")) {
[10:34:06.584]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:06.584]                         if (muffled) 
[10:34:06.584]                           invokeRestart("muffleWarning")
[10:34:06.584]                       }
[10:34:06.584]                       else if (inherits(cond, "condition")) {
[10:34:06.584]                         if (!is.null(pattern)) {
[10:34:06.584]                           computeRestarts <- base::computeRestarts
[10:34:06.584]                           grepl <- base::grepl
[10:34:06.584]                           restarts <- computeRestarts(cond)
[10:34:06.584]                           for (restart in restarts) {
[10:34:06.584]                             name <- restart$name
[10:34:06.584]                             if (is.null(name)) 
[10:34:06.584]                               next
[10:34:06.584]                             if (!grepl(pattern, name)) 
[10:34:06.584]                               next
[10:34:06.584]                             invokeRestart(restart)
[10:34:06.584]                             muffled <- TRUE
[10:34:06.584]                             break
[10:34:06.584]                           }
[10:34:06.584]                         }
[10:34:06.584]                       }
[10:34:06.584]                       invisible(muffled)
[10:34:06.584]                     }
[10:34:06.584]                     muffleCondition(cond, pattern = "^muffle")
[10:34:06.584]                   }
[10:34:06.584]                 }
[10:34:06.584]             }
[10:34:06.584]         }))
[10:34:06.584]     }, error = function(ex) {
[10:34:06.584]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:06.584]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:06.584]                 ...future.rng), started = ...future.startTime, 
[10:34:06.584]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:06.584]             version = "1.8"), class = "FutureResult")
[10:34:06.584]     }, finally = {
[10:34:06.584]         if (!identical(...future.workdir, getwd())) 
[10:34:06.584]             setwd(...future.workdir)
[10:34:06.584]         {
[10:34:06.584]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:06.584]                 ...future.oldOptions$nwarnings <- NULL
[10:34:06.584]             }
[10:34:06.584]             base::options(...future.oldOptions)
[10:34:06.584]             if (.Platform$OS.type == "windows") {
[10:34:06.584]                 old_names <- names(...future.oldEnvVars)
[10:34:06.584]                 envs <- base::Sys.getenv()
[10:34:06.584]                 names <- names(envs)
[10:34:06.584]                 common <- intersect(names, old_names)
[10:34:06.584]                 added <- setdiff(names, old_names)
[10:34:06.584]                 removed <- setdiff(old_names, names)
[10:34:06.584]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:06.584]                   envs[common]]
[10:34:06.584]                 NAMES <- toupper(changed)
[10:34:06.584]                 args <- list()
[10:34:06.584]                 for (kk in seq_along(NAMES)) {
[10:34:06.584]                   name <- changed[[kk]]
[10:34:06.584]                   NAME <- NAMES[[kk]]
[10:34:06.584]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:06.584]                     next
[10:34:06.584]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:06.584]                 }
[10:34:06.584]                 NAMES <- toupper(added)
[10:34:06.584]                 for (kk in seq_along(NAMES)) {
[10:34:06.584]                   name <- added[[kk]]
[10:34:06.584]                   NAME <- NAMES[[kk]]
[10:34:06.584]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:06.584]                     next
[10:34:06.584]                   args[[name]] <- ""
[10:34:06.584]                 }
[10:34:06.584]                 NAMES <- toupper(removed)
[10:34:06.584]                 for (kk in seq_along(NAMES)) {
[10:34:06.584]                   name <- removed[[kk]]
[10:34:06.584]                   NAME <- NAMES[[kk]]
[10:34:06.584]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:06.584]                     next
[10:34:06.584]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:06.584]                 }
[10:34:06.584]                 if (length(args) > 0) 
[10:34:06.584]                   base::do.call(base::Sys.setenv, args = args)
[10:34:06.584]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:06.584]             }
[10:34:06.584]             else {
[10:34:06.584]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:06.584]             }
[10:34:06.584]             {
[10:34:06.584]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:06.584]                   0L) {
[10:34:06.584]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:06.584]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:06.584]                   base::options(opts)
[10:34:06.584]                 }
[10:34:06.584]                 {
[10:34:06.584]                   {
[10:34:06.584]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:06.584]                     NULL
[10:34:06.584]                   }
[10:34:06.584]                   options(future.plan = NULL)
[10:34:06.584]                   if (is.na(NA_character_)) 
[10:34:06.584]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:06.584]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:06.584]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:06.584]                     .init = FALSE)
[10:34:06.584]                 }
[10:34:06.584]             }
[10:34:06.584]         }
[10:34:06.584]     })
[10:34:06.584]     if (TRUE) {
[10:34:06.584]         base::sink(type = "output", split = FALSE)
[10:34:06.584]         if (TRUE) {
[10:34:06.584]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:06.584]         }
[10:34:06.584]         else {
[10:34:06.584]             ...future.result["stdout"] <- base::list(NULL)
[10:34:06.584]         }
[10:34:06.584]         base::close(...future.stdout)
[10:34:06.584]         ...future.stdout <- NULL
[10:34:06.584]     }
[10:34:06.584]     ...future.result$conditions <- ...future.conditions
[10:34:06.584]     ...future.result$finished <- base::Sys.time()
[10:34:06.584]     ...future.result
[10:34:06.584] }
[10:34:06.587] MultisessionFuture started
[10:34:06.587] - Launch lazy future ... done
[10:34:06.587] run() for ‘MultisessionFuture’ ... done
[10:34:07.089] receiveMessageFromWorker() for ClusterFuture ...
[10:34:07.090] - Validating connection of MultisessionFuture
[10:34:07.090] - received message: FutureResult
[10:34:07.090] - Received FutureResult
[10:34:07.090] - Erased future from FutureRegistry
[10:34:07.090] result() for ClusterFuture ...
[10:34:07.091] - result already collected: FutureResult
[10:34:07.091] result() for ClusterFuture ... done
[10:34:07.091] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:07.091] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[10:34:07.091] getGlobalsAndPackages() ...
[10:34:07.091] Searching for globals...
[10:34:07.092] - globals found: [2] ‘list’, ‘stop’
[10:34:07.092] Searching for globals ... DONE
[10:34:07.092] Resolving globals: FALSE
[10:34:07.092] 
[10:34:07.092] 
[10:34:07.093] getGlobalsAndPackages() ... DONE
[10:34:07.093] run() for ‘Future’ ...
[10:34:07.093] - state: ‘created’
[10:34:07.093] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:07.107] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:07.107] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:07.107]   - Field: ‘node’
[10:34:07.107]   - Field: ‘label’
[10:34:07.107]   - Field: ‘local’
[10:34:07.107]   - Field: ‘owner’
[10:34:07.108]   - Field: ‘envir’
[10:34:07.108]   - Field: ‘workers’
[10:34:07.108]   - Field: ‘packages’
[10:34:07.108]   - Field: ‘gc’
[10:34:07.108]   - Field: ‘conditions’
[10:34:07.108]   - Field: ‘persistent’
[10:34:07.108]   - Field: ‘expr’
[10:34:07.108]   - Field: ‘uuid’
[10:34:07.108]   - Field: ‘seed’
[10:34:07.108]   - Field: ‘version’
[10:34:07.108]   - Field: ‘result’
[10:34:07.109]   - Field: ‘asynchronous’
[10:34:07.109]   - Field: ‘calls’
[10:34:07.109]   - Field: ‘globals’
[10:34:07.109]   - Field: ‘stdout’
[10:34:07.109]   - Field: ‘earlySignal’
[10:34:07.109]   - Field: ‘lazy’
[10:34:07.109]   - Field: ‘state’
[10:34:07.109] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:07.109] - Launch lazy future ...
[10:34:07.110] Packages needed by the future expression (n = 0): <none>
[10:34:07.110] Packages needed by future strategies (n = 0): <none>
[10:34:07.110] {
[10:34:07.110]     {
[10:34:07.110]         {
[10:34:07.110]             ...future.startTime <- base::Sys.time()
[10:34:07.110]             {
[10:34:07.110]                 {
[10:34:07.110]                   {
[10:34:07.110]                     {
[10:34:07.110]                       base::local({
[10:34:07.110]                         has_future <- base::requireNamespace("future", 
[10:34:07.110]                           quietly = TRUE)
[10:34:07.110]                         if (has_future) {
[10:34:07.110]                           ns <- base::getNamespace("future")
[10:34:07.110]                           version <- ns[[".package"]][["version"]]
[10:34:07.110]                           if (is.null(version)) 
[10:34:07.110]                             version <- utils::packageVersion("future")
[10:34:07.110]                         }
[10:34:07.110]                         else {
[10:34:07.110]                           version <- NULL
[10:34:07.110]                         }
[10:34:07.110]                         if (!has_future || version < "1.8.0") {
[10:34:07.110]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:07.110]                             "", base::R.version$version.string), 
[10:34:07.110]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:07.110]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:07.110]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:07.110]                               "release", "version")], collapse = " "), 
[10:34:07.110]                             hostname = base::Sys.info()[["nodename"]])
[10:34:07.110]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:07.110]                             info)
[10:34:07.110]                           info <- base::paste(info, collapse = "; ")
[10:34:07.110]                           if (!has_future) {
[10:34:07.110]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:07.110]                               info)
[10:34:07.110]                           }
[10:34:07.110]                           else {
[10:34:07.110]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:07.110]                               info, version)
[10:34:07.110]                           }
[10:34:07.110]                           base::stop(msg)
[10:34:07.110]                         }
[10:34:07.110]                       })
[10:34:07.110]                     }
[10:34:07.110]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:07.110]                     base::options(mc.cores = 1L)
[10:34:07.110]                   }
[10:34:07.110]                   ...future.strategy.old <- future::plan("list")
[10:34:07.110]                   options(future.plan = NULL)
[10:34:07.110]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:07.110]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:07.110]                 }
[10:34:07.110]                 ...future.workdir <- getwd()
[10:34:07.110]             }
[10:34:07.110]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:07.110]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:07.110]         }
[10:34:07.110]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:07.110]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:07.110]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:07.110]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:07.110]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:07.110]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:07.110]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:07.110]             base::names(...future.oldOptions))
[10:34:07.110]     }
[10:34:07.110]     if (FALSE) {
[10:34:07.110]     }
[10:34:07.110]     else {
[10:34:07.110]         if (TRUE) {
[10:34:07.110]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:07.110]                 open = "w")
[10:34:07.110]         }
[10:34:07.110]         else {
[10:34:07.110]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:07.110]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:07.110]         }
[10:34:07.110]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:07.110]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:07.110]             base::sink(type = "output", split = FALSE)
[10:34:07.110]             base::close(...future.stdout)
[10:34:07.110]         }, add = TRUE)
[10:34:07.110]     }
[10:34:07.110]     ...future.frame <- base::sys.nframe()
[10:34:07.110]     ...future.conditions <- base::list()
[10:34:07.110]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:07.110]     if (FALSE) {
[10:34:07.110]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:07.110]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:07.110]     }
[10:34:07.110]     ...future.result <- base::tryCatch({
[10:34:07.110]         base::withCallingHandlers({
[10:34:07.110]             ...future.value <- base::withVisible(base::local({
[10:34:07.110]                 ...future.makeSendCondition <- base::local({
[10:34:07.110]                   sendCondition <- NULL
[10:34:07.110]                   function(frame = 1L) {
[10:34:07.110]                     if (is.function(sendCondition)) 
[10:34:07.110]                       return(sendCondition)
[10:34:07.110]                     ns <- getNamespace("parallel")
[10:34:07.110]                     if (exists("sendData", mode = "function", 
[10:34:07.110]                       envir = ns)) {
[10:34:07.110]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:07.110]                         envir = ns)
[10:34:07.110]                       envir <- sys.frame(frame)
[10:34:07.110]                       master <- NULL
[10:34:07.110]                       while (!identical(envir, .GlobalEnv) && 
[10:34:07.110]                         !identical(envir, emptyenv())) {
[10:34:07.110]                         if (exists("master", mode = "list", envir = envir, 
[10:34:07.110]                           inherits = FALSE)) {
[10:34:07.110]                           master <- get("master", mode = "list", 
[10:34:07.110]                             envir = envir, inherits = FALSE)
[10:34:07.110]                           if (inherits(master, c("SOCKnode", 
[10:34:07.110]                             "SOCK0node"))) {
[10:34:07.110]                             sendCondition <<- function(cond) {
[10:34:07.110]                               data <- list(type = "VALUE", value = cond, 
[10:34:07.110]                                 success = TRUE)
[10:34:07.110]                               parallel_sendData(master, data)
[10:34:07.110]                             }
[10:34:07.110]                             return(sendCondition)
[10:34:07.110]                           }
[10:34:07.110]                         }
[10:34:07.110]                         frame <- frame + 1L
[10:34:07.110]                         envir <- sys.frame(frame)
[10:34:07.110]                       }
[10:34:07.110]                     }
[10:34:07.110]                     sendCondition <<- function(cond) NULL
[10:34:07.110]                   }
[10:34:07.110]                 })
[10:34:07.110]                 withCallingHandlers({
[10:34:07.110]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:34:07.110]                 }, immediateCondition = function(cond) {
[10:34:07.110]                   sendCondition <- ...future.makeSendCondition()
[10:34:07.110]                   sendCondition(cond)
[10:34:07.110]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:07.110]                   {
[10:34:07.110]                     inherits <- base::inherits
[10:34:07.110]                     invokeRestart <- base::invokeRestart
[10:34:07.110]                     is.null <- base::is.null
[10:34:07.110]                     muffled <- FALSE
[10:34:07.110]                     if (inherits(cond, "message")) {
[10:34:07.110]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:07.110]                       if (muffled) 
[10:34:07.110]                         invokeRestart("muffleMessage")
[10:34:07.110]                     }
[10:34:07.110]                     else if (inherits(cond, "warning")) {
[10:34:07.110]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:07.110]                       if (muffled) 
[10:34:07.110]                         invokeRestart("muffleWarning")
[10:34:07.110]                     }
[10:34:07.110]                     else if (inherits(cond, "condition")) {
[10:34:07.110]                       if (!is.null(pattern)) {
[10:34:07.110]                         computeRestarts <- base::computeRestarts
[10:34:07.110]                         grepl <- base::grepl
[10:34:07.110]                         restarts <- computeRestarts(cond)
[10:34:07.110]                         for (restart in restarts) {
[10:34:07.110]                           name <- restart$name
[10:34:07.110]                           if (is.null(name)) 
[10:34:07.110]                             next
[10:34:07.110]                           if (!grepl(pattern, name)) 
[10:34:07.110]                             next
[10:34:07.110]                           invokeRestart(restart)
[10:34:07.110]                           muffled <- TRUE
[10:34:07.110]                           break
[10:34:07.110]                         }
[10:34:07.110]                       }
[10:34:07.110]                     }
[10:34:07.110]                     invisible(muffled)
[10:34:07.110]                   }
[10:34:07.110]                   muffleCondition(cond)
[10:34:07.110]                 })
[10:34:07.110]             }))
[10:34:07.110]             future::FutureResult(value = ...future.value$value, 
[10:34:07.110]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:07.110]                   ...future.rng), globalenv = if (FALSE) 
[10:34:07.110]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:07.110]                     ...future.globalenv.names))
[10:34:07.110]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:07.110]         }, condition = base::local({
[10:34:07.110]             c <- base::c
[10:34:07.110]             inherits <- base::inherits
[10:34:07.110]             invokeRestart <- base::invokeRestart
[10:34:07.110]             length <- base::length
[10:34:07.110]             list <- base::list
[10:34:07.110]             seq.int <- base::seq.int
[10:34:07.110]             signalCondition <- base::signalCondition
[10:34:07.110]             sys.calls <- base::sys.calls
[10:34:07.110]             `[[` <- base::`[[`
[10:34:07.110]             `+` <- base::`+`
[10:34:07.110]             `<<-` <- base::`<<-`
[10:34:07.110]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:07.110]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:07.110]                   3L)]
[10:34:07.110]             }
[10:34:07.110]             function(cond) {
[10:34:07.110]                 is_error <- inherits(cond, "error")
[10:34:07.110]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:07.110]                   NULL)
[10:34:07.110]                 if (is_error) {
[10:34:07.110]                   sessionInformation <- function() {
[10:34:07.110]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:07.110]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:07.110]                       search = base::search(), system = base::Sys.info())
[10:34:07.110]                   }
[10:34:07.110]                   ...future.conditions[[length(...future.conditions) + 
[10:34:07.110]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:07.110]                     cond$call), session = sessionInformation(), 
[10:34:07.110]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:07.110]                   signalCondition(cond)
[10:34:07.110]                 }
[10:34:07.110]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:07.110]                 "immediateCondition"))) {
[10:34:07.110]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:07.110]                   ...future.conditions[[length(...future.conditions) + 
[10:34:07.110]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:07.110]                   if (TRUE && !signal) {
[10:34:07.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:07.110]                     {
[10:34:07.110]                       inherits <- base::inherits
[10:34:07.110]                       invokeRestart <- base::invokeRestart
[10:34:07.110]                       is.null <- base::is.null
[10:34:07.110]                       muffled <- FALSE
[10:34:07.110]                       if (inherits(cond, "message")) {
[10:34:07.110]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:07.110]                         if (muffled) 
[10:34:07.110]                           invokeRestart("muffleMessage")
[10:34:07.110]                       }
[10:34:07.110]                       else if (inherits(cond, "warning")) {
[10:34:07.110]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:07.110]                         if (muffled) 
[10:34:07.110]                           invokeRestart("muffleWarning")
[10:34:07.110]                       }
[10:34:07.110]                       else if (inherits(cond, "condition")) {
[10:34:07.110]                         if (!is.null(pattern)) {
[10:34:07.110]                           computeRestarts <- base::computeRestarts
[10:34:07.110]                           grepl <- base::grepl
[10:34:07.110]                           restarts <- computeRestarts(cond)
[10:34:07.110]                           for (restart in restarts) {
[10:34:07.110]                             name <- restart$name
[10:34:07.110]                             if (is.null(name)) 
[10:34:07.110]                               next
[10:34:07.110]                             if (!grepl(pattern, name)) 
[10:34:07.110]                               next
[10:34:07.110]                             invokeRestart(restart)
[10:34:07.110]                             muffled <- TRUE
[10:34:07.110]                             break
[10:34:07.110]                           }
[10:34:07.110]                         }
[10:34:07.110]                       }
[10:34:07.110]                       invisible(muffled)
[10:34:07.110]                     }
[10:34:07.110]                     muffleCondition(cond, pattern = "^muffle")
[10:34:07.110]                   }
[10:34:07.110]                 }
[10:34:07.110]                 else {
[10:34:07.110]                   if (TRUE) {
[10:34:07.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:07.110]                     {
[10:34:07.110]                       inherits <- base::inherits
[10:34:07.110]                       invokeRestart <- base::invokeRestart
[10:34:07.110]                       is.null <- base::is.null
[10:34:07.110]                       muffled <- FALSE
[10:34:07.110]                       if (inherits(cond, "message")) {
[10:34:07.110]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:07.110]                         if (muffled) 
[10:34:07.110]                           invokeRestart("muffleMessage")
[10:34:07.110]                       }
[10:34:07.110]                       else if (inherits(cond, "warning")) {
[10:34:07.110]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:07.110]                         if (muffled) 
[10:34:07.110]                           invokeRestart("muffleWarning")
[10:34:07.110]                       }
[10:34:07.110]                       else if (inherits(cond, "condition")) {
[10:34:07.110]                         if (!is.null(pattern)) {
[10:34:07.110]                           computeRestarts <- base::computeRestarts
[10:34:07.110]                           grepl <- base::grepl
[10:34:07.110]                           restarts <- computeRestarts(cond)
[10:34:07.110]                           for (restart in restarts) {
[10:34:07.110]                             name <- restart$name
[10:34:07.110]                             if (is.null(name)) 
[10:34:07.110]                               next
[10:34:07.110]                             if (!grepl(pattern, name)) 
[10:34:07.110]                               next
[10:34:07.110]                             invokeRestart(restart)
[10:34:07.110]                             muffled <- TRUE
[10:34:07.110]                             break
[10:34:07.110]                           }
[10:34:07.110]                         }
[10:34:07.110]                       }
[10:34:07.110]                       invisible(muffled)
[10:34:07.110]                     }
[10:34:07.110]                     muffleCondition(cond, pattern = "^muffle")
[10:34:07.110]                   }
[10:34:07.110]                 }
[10:34:07.110]             }
[10:34:07.110]         }))
[10:34:07.110]     }, error = function(ex) {
[10:34:07.110]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:07.110]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:07.110]                 ...future.rng), started = ...future.startTime, 
[10:34:07.110]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:07.110]             version = "1.8"), class = "FutureResult")
[10:34:07.110]     }, finally = {
[10:34:07.110]         if (!identical(...future.workdir, getwd())) 
[10:34:07.110]             setwd(...future.workdir)
[10:34:07.110]         {
[10:34:07.110]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:07.110]                 ...future.oldOptions$nwarnings <- NULL
[10:34:07.110]             }
[10:34:07.110]             base::options(...future.oldOptions)
[10:34:07.110]             if (.Platform$OS.type == "windows") {
[10:34:07.110]                 old_names <- names(...future.oldEnvVars)
[10:34:07.110]                 envs <- base::Sys.getenv()
[10:34:07.110]                 names <- names(envs)
[10:34:07.110]                 common <- intersect(names, old_names)
[10:34:07.110]                 added <- setdiff(names, old_names)
[10:34:07.110]                 removed <- setdiff(old_names, names)
[10:34:07.110]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:07.110]                   envs[common]]
[10:34:07.110]                 NAMES <- toupper(changed)
[10:34:07.110]                 args <- list()
[10:34:07.110]                 for (kk in seq_along(NAMES)) {
[10:34:07.110]                   name <- changed[[kk]]
[10:34:07.110]                   NAME <- NAMES[[kk]]
[10:34:07.110]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:07.110]                     next
[10:34:07.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:07.110]                 }
[10:34:07.110]                 NAMES <- toupper(added)
[10:34:07.110]                 for (kk in seq_along(NAMES)) {
[10:34:07.110]                   name <- added[[kk]]
[10:34:07.110]                   NAME <- NAMES[[kk]]
[10:34:07.110]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:07.110]                     next
[10:34:07.110]                   args[[name]] <- ""
[10:34:07.110]                 }
[10:34:07.110]                 NAMES <- toupper(removed)
[10:34:07.110]                 for (kk in seq_along(NAMES)) {
[10:34:07.110]                   name <- removed[[kk]]
[10:34:07.110]                   NAME <- NAMES[[kk]]
[10:34:07.110]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:07.110]                     next
[10:34:07.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:07.110]                 }
[10:34:07.110]                 if (length(args) > 0) 
[10:34:07.110]                   base::do.call(base::Sys.setenv, args = args)
[10:34:07.110]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:07.110]             }
[10:34:07.110]             else {
[10:34:07.110]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:07.110]             }
[10:34:07.110]             {
[10:34:07.110]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:07.110]                   0L) {
[10:34:07.110]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:07.110]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:07.110]                   base::options(opts)
[10:34:07.110]                 }
[10:34:07.110]                 {
[10:34:07.110]                   {
[10:34:07.110]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:07.110]                     NULL
[10:34:07.110]                   }
[10:34:07.110]                   options(future.plan = NULL)
[10:34:07.110]                   if (is.na(NA_character_)) 
[10:34:07.110]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:07.110]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:07.110]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:07.110]                     .init = FALSE)
[10:34:07.110]                 }
[10:34:07.110]             }
[10:34:07.110]         }
[10:34:07.110]     })
[10:34:07.110]     if (TRUE) {
[10:34:07.110]         base::sink(type = "output", split = FALSE)
[10:34:07.110]         if (TRUE) {
[10:34:07.110]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:07.110]         }
[10:34:07.110]         else {
[10:34:07.110]             ...future.result["stdout"] <- base::list(NULL)
[10:34:07.110]         }
[10:34:07.110]         base::close(...future.stdout)
[10:34:07.110]         ...future.stdout <- NULL
[10:34:07.110]     }
[10:34:07.110]     ...future.result$conditions <- ...future.conditions
[10:34:07.110]     ...future.result$finished <- base::Sys.time()
[10:34:07.110]     ...future.result
[10:34:07.110] }
[10:34:07.113] MultisessionFuture started
[10:34:07.113] - Launch lazy future ... done
[10:34:07.113] run() for ‘MultisessionFuture’ ... done
[10:34:07.115] receiveMessageFromWorker() for ClusterFuture ...
[10:34:07.115] - Validating connection of MultisessionFuture
[10:34:07.115] - received message: FutureResult
[10:34:07.116] - Received FutureResult
[10:34:07.116] - Erased future from FutureRegistry
[10:34:07.116] result() for ClusterFuture ...
[10:34:07.116] - result already collected: FutureResult
[10:34:07.116] result() for ClusterFuture ... done
[10:34:07.116] signalConditions() ...
[10:34:07.116]  - include = ‘immediateCondition’
[10:34:07.116]  - exclude = 
[10:34:07.116]  - resignal = FALSE
[10:34:07.116]  - Number of conditions: 1
[10:34:07.116] signalConditions() ... done
[10:34:07.117] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:07.117] A MultisessionFuture was resolved (result was not collected)
[10:34:07.117] getGlobalsAndPackages() ...
[10:34:07.117] Searching for globals...
[10:34:07.117] - globals found: [2] ‘list’, ‘stop’
[10:34:07.118] Searching for globals ... DONE
[10:34:07.118] Resolving globals: FALSE
[10:34:07.118] 
[10:34:07.118] 
[10:34:07.118] getGlobalsAndPackages() ... DONE
[10:34:07.118] run() for ‘Future’ ...
[10:34:07.118] - state: ‘created’
[10:34:07.119] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:07.132] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:07.133] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:07.133]   - Field: ‘node’
[10:34:07.133]   - Field: ‘label’
[10:34:07.133]   - Field: ‘local’
[10:34:07.133]   - Field: ‘owner’
[10:34:07.133]   - Field: ‘envir’
[10:34:07.133]   - Field: ‘workers’
[10:34:07.133]   - Field: ‘packages’
[10:34:07.133]   - Field: ‘gc’
[10:34:07.133]   - Field: ‘conditions’
[10:34:07.134]   - Field: ‘persistent’
[10:34:07.134]   - Field: ‘expr’
[10:34:07.134]   - Field: ‘uuid’
[10:34:07.134]   - Field: ‘seed’
[10:34:07.134]   - Field: ‘version’
[10:34:07.134]   - Field: ‘result’
[10:34:07.134]   - Field: ‘asynchronous’
[10:34:07.134]   - Field: ‘calls’
[10:34:07.134]   - Field: ‘globals’
[10:34:07.134]   - Field: ‘stdout’
[10:34:07.134]   - Field: ‘earlySignal’
[10:34:07.134]   - Field: ‘lazy’
[10:34:07.135]   - Field: ‘state’
[10:34:07.135] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:07.135] - Launch lazy future ...
[10:34:07.135] Packages needed by the future expression (n = 0): <none>
[10:34:07.135] Packages needed by future strategies (n = 0): <none>
[10:34:07.136] {
[10:34:07.136]     {
[10:34:07.136]         {
[10:34:07.136]             ...future.startTime <- base::Sys.time()
[10:34:07.136]             {
[10:34:07.136]                 {
[10:34:07.136]                   {
[10:34:07.136]                     {
[10:34:07.136]                       base::local({
[10:34:07.136]                         has_future <- base::requireNamespace("future", 
[10:34:07.136]                           quietly = TRUE)
[10:34:07.136]                         if (has_future) {
[10:34:07.136]                           ns <- base::getNamespace("future")
[10:34:07.136]                           version <- ns[[".package"]][["version"]]
[10:34:07.136]                           if (is.null(version)) 
[10:34:07.136]                             version <- utils::packageVersion("future")
[10:34:07.136]                         }
[10:34:07.136]                         else {
[10:34:07.136]                           version <- NULL
[10:34:07.136]                         }
[10:34:07.136]                         if (!has_future || version < "1.8.0") {
[10:34:07.136]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:07.136]                             "", base::R.version$version.string), 
[10:34:07.136]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:07.136]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:07.136]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:07.136]                               "release", "version")], collapse = " "), 
[10:34:07.136]                             hostname = base::Sys.info()[["nodename"]])
[10:34:07.136]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:07.136]                             info)
[10:34:07.136]                           info <- base::paste(info, collapse = "; ")
[10:34:07.136]                           if (!has_future) {
[10:34:07.136]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:07.136]                               info)
[10:34:07.136]                           }
[10:34:07.136]                           else {
[10:34:07.136]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:07.136]                               info, version)
[10:34:07.136]                           }
[10:34:07.136]                           base::stop(msg)
[10:34:07.136]                         }
[10:34:07.136]                       })
[10:34:07.136]                     }
[10:34:07.136]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:07.136]                     base::options(mc.cores = 1L)
[10:34:07.136]                   }
[10:34:07.136]                   ...future.strategy.old <- future::plan("list")
[10:34:07.136]                   options(future.plan = NULL)
[10:34:07.136]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:07.136]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:07.136]                 }
[10:34:07.136]                 ...future.workdir <- getwd()
[10:34:07.136]             }
[10:34:07.136]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:07.136]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:07.136]         }
[10:34:07.136]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:07.136]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:07.136]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:07.136]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:07.136]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:07.136]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:07.136]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:07.136]             base::names(...future.oldOptions))
[10:34:07.136]     }
[10:34:07.136]     if (FALSE) {
[10:34:07.136]     }
[10:34:07.136]     else {
[10:34:07.136]         if (TRUE) {
[10:34:07.136]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:07.136]                 open = "w")
[10:34:07.136]         }
[10:34:07.136]         else {
[10:34:07.136]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:07.136]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:07.136]         }
[10:34:07.136]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:07.136]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:07.136]             base::sink(type = "output", split = FALSE)
[10:34:07.136]             base::close(...future.stdout)
[10:34:07.136]         }, add = TRUE)
[10:34:07.136]     }
[10:34:07.136]     ...future.frame <- base::sys.nframe()
[10:34:07.136]     ...future.conditions <- base::list()
[10:34:07.136]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:07.136]     if (FALSE) {
[10:34:07.136]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:07.136]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:07.136]     }
[10:34:07.136]     ...future.result <- base::tryCatch({
[10:34:07.136]         base::withCallingHandlers({
[10:34:07.136]             ...future.value <- base::withVisible(base::local({
[10:34:07.136]                 ...future.makeSendCondition <- base::local({
[10:34:07.136]                   sendCondition <- NULL
[10:34:07.136]                   function(frame = 1L) {
[10:34:07.136]                     if (is.function(sendCondition)) 
[10:34:07.136]                       return(sendCondition)
[10:34:07.136]                     ns <- getNamespace("parallel")
[10:34:07.136]                     if (exists("sendData", mode = "function", 
[10:34:07.136]                       envir = ns)) {
[10:34:07.136]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:07.136]                         envir = ns)
[10:34:07.136]                       envir <- sys.frame(frame)
[10:34:07.136]                       master <- NULL
[10:34:07.136]                       while (!identical(envir, .GlobalEnv) && 
[10:34:07.136]                         !identical(envir, emptyenv())) {
[10:34:07.136]                         if (exists("master", mode = "list", envir = envir, 
[10:34:07.136]                           inherits = FALSE)) {
[10:34:07.136]                           master <- get("master", mode = "list", 
[10:34:07.136]                             envir = envir, inherits = FALSE)
[10:34:07.136]                           if (inherits(master, c("SOCKnode", 
[10:34:07.136]                             "SOCK0node"))) {
[10:34:07.136]                             sendCondition <<- function(cond) {
[10:34:07.136]                               data <- list(type = "VALUE", value = cond, 
[10:34:07.136]                                 success = TRUE)
[10:34:07.136]                               parallel_sendData(master, data)
[10:34:07.136]                             }
[10:34:07.136]                             return(sendCondition)
[10:34:07.136]                           }
[10:34:07.136]                         }
[10:34:07.136]                         frame <- frame + 1L
[10:34:07.136]                         envir <- sys.frame(frame)
[10:34:07.136]                       }
[10:34:07.136]                     }
[10:34:07.136]                     sendCondition <<- function(cond) NULL
[10:34:07.136]                   }
[10:34:07.136]                 })
[10:34:07.136]                 withCallingHandlers({
[10:34:07.136]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:34:07.136]                 }, immediateCondition = function(cond) {
[10:34:07.136]                   sendCondition <- ...future.makeSendCondition()
[10:34:07.136]                   sendCondition(cond)
[10:34:07.136]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:07.136]                   {
[10:34:07.136]                     inherits <- base::inherits
[10:34:07.136]                     invokeRestart <- base::invokeRestart
[10:34:07.136]                     is.null <- base::is.null
[10:34:07.136]                     muffled <- FALSE
[10:34:07.136]                     if (inherits(cond, "message")) {
[10:34:07.136]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:07.136]                       if (muffled) 
[10:34:07.136]                         invokeRestart("muffleMessage")
[10:34:07.136]                     }
[10:34:07.136]                     else if (inherits(cond, "warning")) {
[10:34:07.136]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:07.136]                       if (muffled) 
[10:34:07.136]                         invokeRestart("muffleWarning")
[10:34:07.136]                     }
[10:34:07.136]                     else if (inherits(cond, "condition")) {
[10:34:07.136]                       if (!is.null(pattern)) {
[10:34:07.136]                         computeRestarts <- base::computeRestarts
[10:34:07.136]                         grepl <- base::grepl
[10:34:07.136]                         restarts <- computeRestarts(cond)
[10:34:07.136]                         for (restart in restarts) {
[10:34:07.136]                           name <- restart$name
[10:34:07.136]                           if (is.null(name)) 
[10:34:07.136]                             next
[10:34:07.136]                           if (!grepl(pattern, name)) 
[10:34:07.136]                             next
[10:34:07.136]                           invokeRestart(restart)
[10:34:07.136]                           muffled <- TRUE
[10:34:07.136]                           break
[10:34:07.136]                         }
[10:34:07.136]                       }
[10:34:07.136]                     }
[10:34:07.136]                     invisible(muffled)
[10:34:07.136]                   }
[10:34:07.136]                   muffleCondition(cond)
[10:34:07.136]                 })
[10:34:07.136]             }))
[10:34:07.136]             future::FutureResult(value = ...future.value$value, 
[10:34:07.136]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:07.136]                   ...future.rng), globalenv = if (FALSE) 
[10:34:07.136]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:07.136]                     ...future.globalenv.names))
[10:34:07.136]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:07.136]         }, condition = base::local({
[10:34:07.136]             c <- base::c
[10:34:07.136]             inherits <- base::inherits
[10:34:07.136]             invokeRestart <- base::invokeRestart
[10:34:07.136]             length <- base::length
[10:34:07.136]             list <- base::list
[10:34:07.136]             seq.int <- base::seq.int
[10:34:07.136]             signalCondition <- base::signalCondition
[10:34:07.136]             sys.calls <- base::sys.calls
[10:34:07.136]             `[[` <- base::`[[`
[10:34:07.136]             `+` <- base::`+`
[10:34:07.136]             `<<-` <- base::`<<-`
[10:34:07.136]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:07.136]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:07.136]                   3L)]
[10:34:07.136]             }
[10:34:07.136]             function(cond) {
[10:34:07.136]                 is_error <- inherits(cond, "error")
[10:34:07.136]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:07.136]                   NULL)
[10:34:07.136]                 if (is_error) {
[10:34:07.136]                   sessionInformation <- function() {
[10:34:07.136]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:07.136]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:07.136]                       search = base::search(), system = base::Sys.info())
[10:34:07.136]                   }
[10:34:07.136]                   ...future.conditions[[length(...future.conditions) + 
[10:34:07.136]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:07.136]                     cond$call), session = sessionInformation(), 
[10:34:07.136]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:07.136]                   signalCondition(cond)
[10:34:07.136]                 }
[10:34:07.136]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:07.136]                 "immediateCondition"))) {
[10:34:07.136]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:07.136]                   ...future.conditions[[length(...future.conditions) + 
[10:34:07.136]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:07.136]                   if (TRUE && !signal) {
[10:34:07.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:07.136]                     {
[10:34:07.136]                       inherits <- base::inherits
[10:34:07.136]                       invokeRestart <- base::invokeRestart
[10:34:07.136]                       is.null <- base::is.null
[10:34:07.136]                       muffled <- FALSE
[10:34:07.136]                       if (inherits(cond, "message")) {
[10:34:07.136]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:07.136]                         if (muffled) 
[10:34:07.136]                           invokeRestart("muffleMessage")
[10:34:07.136]                       }
[10:34:07.136]                       else if (inherits(cond, "warning")) {
[10:34:07.136]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:07.136]                         if (muffled) 
[10:34:07.136]                           invokeRestart("muffleWarning")
[10:34:07.136]                       }
[10:34:07.136]                       else if (inherits(cond, "condition")) {
[10:34:07.136]                         if (!is.null(pattern)) {
[10:34:07.136]                           computeRestarts <- base::computeRestarts
[10:34:07.136]                           grepl <- base::grepl
[10:34:07.136]                           restarts <- computeRestarts(cond)
[10:34:07.136]                           for (restart in restarts) {
[10:34:07.136]                             name <- restart$name
[10:34:07.136]                             if (is.null(name)) 
[10:34:07.136]                               next
[10:34:07.136]                             if (!grepl(pattern, name)) 
[10:34:07.136]                               next
[10:34:07.136]                             invokeRestart(restart)
[10:34:07.136]                             muffled <- TRUE
[10:34:07.136]                             break
[10:34:07.136]                           }
[10:34:07.136]                         }
[10:34:07.136]                       }
[10:34:07.136]                       invisible(muffled)
[10:34:07.136]                     }
[10:34:07.136]                     muffleCondition(cond, pattern = "^muffle")
[10:34:07.136]                   }
[10:34:07.136]                 }
[10:34:07.136]                 else {
[10:34:07.136]                   if (TRUE) {
[10:34:07.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:07.136]                     {
[10:34:07.136]                       inherits <- base::inherits
[10:34:07.136]                       invokeRestart <- base::invokeRestart
[10:34:07.136]                       is.null <- base::is.null
[10:34:07.136]                       muffled <- FALSE
[10:34:07.136]                       if (inherits(cond, "message")) {
[10:34:07.136]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:07.136]                         if (muffled) 
[10:34:07.136]                           invokeRestart("muffleMessage")
[10:34:07.136]                       }
[10:34:07.136]                       else if (inherits(cond, "warning")) {
[10:34:07.136]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:07.136]                         if (muffled) 
[10:34:07.136]                           invokeRestart("muffleWarning")
[10:34:07.136]                       }
[10:34:07.136]                       else if (inherits(cond, "condition")) {
[10:34:07.136]                         if (!is.null(pattern)) {
[10:34:07.136]                           computeRestarts <- base::computeRestarts
[10:34:07.136]                           grepl <- base::grepl
[10:34:07.136]                           restarts <- computeRestarts(cond)
[10:34:07.136]                           for (restart in restarts) {
[10:34:07.136]                             name <- restart$name
[10:34:07.136]                             if (is.null(name)) 
[10:34:07.136]                               next
[10:34:07.136]                             if (!grepl(pattern, name)) 
[10:34:07.136]                               next
[10:34:07.136]                             invokeRestart(restart)
[10:34:07.136]                             muffled <- TRUE
[10:34:07.136]                             break
[10:34:07.136]                           }
[10:34:07.136]                         }
[10:34:07.136]                       }
[10:34:07.136]                       invisible(muffled)
[10:34:07.136]                     }
[10:34:07.136]                     muffleCondition(cond, pattern = "^muffle")
[10:34:07.136]                   }
[10:34:07.136]                 }
[10:34:07.136]             }
[10:34:07.136]         }))
[10:34:07.136]     }, error = function(ex) {
[10:34:07.136]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:07.136]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:07.136]                 ...future.rng), started = ...future.startTime, 
[10:34:07.136]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:07.136]             version = "1.8"), class = "FutureResult")
[10:34:07.136]     }, finally = {
[10:34:07.136]         if (!identical(...future.workdir, getwd())) 
[10:34:07.136]             setwd(...future.workdir)
[10:34:07.136]         {
[10:34:07.136]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:07.136]                 ...future.oldOptions$nwarnings <- NULL
[10:34:07.136]             }
[10:34:07.136]             base::options(...future.oldOptions)
[10:34:07.136]             if (.Platform$OS.type == "windows") {
[10:34:07.136]                 old_names <- names(...future.oldEnvVars)
[10:34:07.136]                 envs <- base::Sys.getenv()
[10:34:07.136]                 names <- names(envs)
[10:34:07.136]                 common <- intersect(names, old_names)
[10:34:07.136]                 added <- setdiff(names, old_names)
[10:34:07.136]                 removed <- setdiff(old_names, names)
[10:34:07.136]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:07.136]                   envs[common]]
[10:34:07.136]                 NAMES <- toupper(changed)
[10:34:07.136]                 args <- list()
[10:34:07.136]                 for (kk in seq_along(NAMES)) {
[10:34:07.136]                   name <- changed[[kk]]
[10:34:07.136]                   NAME <- NAMES[[kk]]
[10:34:07.136]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:07.136]                     next
[10:34:07.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:07.136]                 }
[10:34:07.136]                 NAMES <- toupper(added)
[10:34:07.136]                 for (kk in seq_along(NAMES)) {
[10:34:07.136]                   name <- added[[kk]]
[10:34:07.136]                   NAME <- NAMES[[kk]]
[10:34:07.136]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:07.136]                     next
[10:34:07.136]                   args[[name]] <- ""
[10:34:07.136]                 }
[10:34:07.136]                 NAMES <- toupper(removed)
[10:34:07.136]                 for (kk in seq_along(NAMES)) {
[10:34:07.136]                   name <- removed[[kk]]
[10:34:07.136]                   NAME <- NAMES[[kk]]
[10:34:07.136]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:07.136]                     next
[10:34:07.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:07.136]                 }
[10:34:07.136]                 if (length(args) > 0) 
[10:34:07.136]                   base::do.call(base::Sys.setenv, args = args)
[10:34:07.136]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:07.136]             }
[10:34:07.136]             else {
[10:34:07.136]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:07.136]             }
[10:34:07.136]             {
[10:34:07.136]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:07.136]                   0L) {
[10:34:07.136]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:07.136]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:07.136]                   base::options(opts)
[10:34:07.136]                 }
[10:34:07.136]                 {
[10:34:07.136]                   {
[10:34:07.136]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:07.136]                     NULL
[10:34:07.136]                   }
[10:34:07.136]                   options(future.plan = NULL)
[10:34:07.136]                   if (is.na(NA_character_)) 
[10:34:07.136]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:07.136]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:07.136]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:07.136]                     .init = FALSE)
[10:34:07.136]                 }
[10:34:07.136]             }
[10:34:07.136]         }
[10:34:07.136]     })
[10:34:07.136]     if (TRUE) {
[10:34:07.136]         base::sink(type = "output", split = FALSE)
[10:34:07.136]         if (TRUE) {
[10:34:07.136]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:07.136]         }
[10:34:07.136]         else {
[10:34:07.136]             ...future.result["stdout"] <- base::list(NULL)
[10:34:07.136]         }
[10:34:07.136]         base::close(...future.stdout)
[10:34:07.136]         ...future.stdout <- NULL
[10:34:07.136]     }
[10:34:07.136]     ...future.result$conditions <- ...future.conditions
[10:34:07.136]     ...future.result$finished <- base::Sys.time()
[10:34:07.136]     ...future.result
[10:34:07.136] }
[10:34:07.138] MultisessionFuture started
[10:34:07.139] - Launch lazy future ... done
[10:34:07.139] run() for ‘MultisessionFuture’ ... done
[10:34:07.140] receiveMessageFromWorker() for ClusterFuture ...
[10:34:07.140] - Validating connection of MultisessionFuture
[10:34:07.141] - received message: FutureResult
[10:34:07.141] - Received FutureResult
[10:34:07.141] - Erased future from FutureRegistry
[10:34:07.141] result() for ClusterFuture ...
[10:34:07.141] - result already collected: FutureResult
[10:34:07.141] result() for ClusterFuture ... done
[10:34:07.141] signalConditions() ...
[10:34:07.141]  - include = ‘immediateCondition’
[10:34:07.144]  - exclude = 
[10:34:07.144]  - resignal = FALSE
[10:34:07.144]  - Number of conditions: 1
[10:34:07.144] signalConditions() ... done
[10:34:07.144] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:07.144] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 1 ... DONE
- result = FALSE, recursive = 2 ...
[10:34:07.144] getGlobalsAndPackages() ...
[10:34:07.144] Searching for globals...
[10:34:07.146] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:34:07.146] Searching for globals ... DONE
[10:34:07.146] Resolving globals: FALSE
[10:34:07.146] 
[10:34:07.146] 
[10:34:07.146] getGlobalsAndPackages() ... DONE
[10:34:07.147] run() for ‘Future’ ...
[10:34:07.147] - state: ‘created’
[10:34:07.147] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:07.161] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:07.161] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:07.161]   - Field: ‘node’
[10:34:07.161]   - Field: ‘label’
[10:34:07.161]   - Field: ‘local’
[10:34:07.161]   - Field: ‘owner’
[10:34:07.162]   - Field: ‘envir’
[10:34:07.162]   - Field: ‘workers’
[10:34:07.162]   - Field: ‘packages’
[10:34:07.162]   - Field: ‘gc’
[10:34:07.162]   - Field: ‘conditions’
[10:34:07.162]   - Field: ‘persistent’
[10:34:07.162]   - Field: ‘expr’
[10:34:07.162]   - Field: ‘uuid’
[10:34:07.162]   - Field: ‘seed’
[10:34:07.162]   - Field: ‘version’
[10:34:07.162]   - Field: ‘result’
[10:34:07.162]   - Field: ‘asynchronous’
[10:34:07.163]   - Field: ‘calls’
[10:34:07.163]   - Field: ‘globals’
[10:34:07.163]   - Field: ‘stdout’
[10:34:07.163]   - Field: ‘earlySignal’
[10:34:07.163]   - Field: ‘lazy’
[10:34:07.163]   - Field: ‘state’
[10:34:07.163] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:07.163] - Launch lazy future ...
[10:34:07.163] Packages needed by the future expression (n = 0): <none>
[10:34:07.164] Packages needed by future strategies (n = 0): <none>
[10:34:07.164] {
[10:34:07.164]     {
[10:34:07.164]         {
[10:34:07.164]             ...future.startTime <- base::Sys.time()
[10:34:07.164]             {
[10:34:07.164]                 {
[10:34:07.164]                   {
[10:34:07.164]                     {
[10:34:07.164]                       base::local({
[10:34:07.164]                         has_future <- base::requireNamespace("future", 
[10:34:07.164]                           quietly = TRUE)
[10:34:07.164]                         if (has_future) {
[10:34:07.164]                           ns <- base::getNamespace("future")
[10:34:07.164]                           version <- ns[[".package"]][["version"]]
[10:34:07.164]                           if (is.null(version)) 
[10:34:07.164]                             version <- utils::packageVersion("future")
[10:34:07.164]                         }
[10:34:07.164]                         else {
[10:34:07.164]                           version <- NULL
[10:34:07.164]                         }
[10:34:07.164]                         if (!has_future || version < "1.8.0") {
[10:34:07.164]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:07.164]                             "", base::R.version$version.string), 
[10:34:07.164]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:07.164]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:07.164]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:07.164]                               "release", "version")], collapse = " "), 
[10:34:07.164]                             hostname = base::Sys.info()[["nodename"]])
[10:34:07.164]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:07.164]                             info)
[10:34:07.164]                           info <- base::paste(info, collapse = "; ")
[10:34:07.164]                           if (!has_future) {
[10:34:07.164]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:07.164]                               info)
[10:34:07.164]                           }
[10:34:07.164]                           else {
[10:34:07.164]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:07.164]                               info, version)
[10:34:07.164]                           }
[10:34:07.164]                           base::stop(msg)
[10:34:07.164]                         }
[10:34:07.164]                       })
[10:34:07.164]                     }
[10:34:07.164]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:07.164]                     base::options(mc.cores = 1L)
[10:34:07.164]                   }
[10:34:07.164]                   ...future.strategy.old <- future::plan("list")
[10:34:07.164]                   options(future.plan = NULL)
[10:34:07.164]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:07.164]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:07.164]                 }
[10:34:07.164]                 ...future.workdir <- getwd()
[10:34:07.164]             }
[10:34:07.164]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:07.164]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:07.164]         }
[10:34:07.164]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:07.164]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:07.164]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:07.164]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:07.164]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:07.164]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:07.164]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:07.164]             base::names(...future.oldOptions))
[10:34:07.164]     }
[10:34:07.164]     if (FALSE) {
[10:34:07.164]     }
[10:34:07.164]     else {
[10:34:07.164]         if (TRUE) {
[10:34:07.164]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:07.164]                 open = "w")
[10:34:07.164]         }
[10:34:07.164]         else {
[10:34:07.164]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:07.164]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:07.164]         }
[10:34:07.164]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:07.164]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:07.164]             base::sink(type = "output", split = FALSE)
[10:34:07.164]             base::close(...future.stdout)
[10:34:07.164]         }, add = TRUE)
[10:34:07.164]     }
[10:34:07.164]     ...future.frame <- base::sys.nframe()
[10:34:07.164]     ...future.conditions <- base::list()
[10:34:07.164]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:07.164]     if (FALSE) {
[10:34:07.164]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:07.164]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:07.164]     }
[10:34:07.164]     ...future.result <- base::tryCatch({
[10:34:07.164]         base::withCallingHandlers({
[10:34:07.164]             ...future.value <- base::withVisible(base::local({
[10:34:07.164]                 ...future.makeSendCondition <- base::local({
[10:34:07.164]                   sendCondition <- NULL
[10:34:07.164]                   function(frame = 1L) {
[10:34:07.164]                     if (is.function(sendCondition)) 
[10:34:07.164]                       return(sendCondition)
[10:34:07.164]                     ns <- getNamespace("parallel")
[10:34:07.164]                     if (exists("sendData", mode = "function", 
[10:34:07.164]                       envir = ns)) {
[10:34:07.164]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:07.164]                         envir = ns)
[10:34:07.164]                       envir <- sys.frame(frame)
[10:34:07.164]                       master <- NULL
[10:34:07.164]                       while (!identical(envir, .GlobalEnv) && 
[10:34:07.164]                         !identical(envir, emptyenv())) {
[10:34:07.164]                         if (exists("master", mode = "list", envir = envir, 
[10:34:07.164]                           inherits = FALSE)) {
[10:34:07.164]                           master <- get("master", mode = "list", 
[10:34:07.164]                             envir = envir, inherits = FALSE)
[10:34:07.164]                           if (inherits(master, c("SOCKnode", 
[10:34:07.164]                             "SOCK0node"))) {
[10:34:07.164]                             sendCondition <<- function(cond) {
[10:34:07.164]                               data <- list(type = "VALUE", value = cond, 
[10:34:07.164]                                 success = TRUE)
[10:34:07.164]                               parallel_sendData(master, data)
[10:34:07.164]                             }
[10:34:07.164]                             return(sendCondition)
[10:34:07.164]                           }
[10:34:07.164]                         }
[10:34:07.164]                         frame <- frame + 1L
[10:34:07.164]                         envir <- sys.frame(frame)
[10:34:07.164]                       }
[10:34:07.164]                     }
[10:34:07.164]                     sendCondition <<- function(cond) NULL
[10:34:07.164]                   }
[10:34:07.164]                 })
[10:34:07.164]                 withCallingHandlers({
[10:34:07.164]                   {
[10:34:07.164]                     Sys.sleep(0.5)
[10:34:07.164]                     list(a = 1, b = 42L)
[10:34:07.164]                   }
[10:34:07.164]                 }, immediateCondition = function(cond) {
[10:34:07.164]                   sendCondition <- ...future.makeSendCondition()
[10:34:07.164]                   sendCondition(cond)
[10:34:07.164]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:07.164]                   {
[10:34:07.164]                     inherits <- base::inherits
[10:34:07.164]                     invokeRestart <- base::invokeRestart
[10:34:07.164]                     is.null <- base::is.null
[10:34:07.164]                     muffled <- FALSE
[10:34:07.164]                     if (inherits(cond, "message")) {
[10:34:07.164]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:07.164]                       if (muffled) 
[10:34:07.164]                         invokeRestart("muffleMessage")
[10:34:07.164]                     }
[10:34:07.164]                     else if (inherits(cond, "warning")) {
[10:34:07.164]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:07.164]                       if (muffled) 
[10:34:07.164]                         invokeRestart("muffleWarning")
[10:34:07.164]                     }
[10:34:07.164]                     else if (inherits(cond, "condition")) {
[10:34:07.164]                       if (!is.null(pattern)) {
[10:34:07.164]                         computeRestarts <- base::computeRestarts
[10:34:07.164]                         grepl <- base::grepl
[10:34:07.164]                         restarts <- computeRestarts(cond)
[10:34:07.164]                         for (restart in restarts) {
[10:34:07.164]                           name <- restart$name
[10:34:07.164]                           if (is.null(name)) 
[10:34:07.164]                             next
[10:34:07.164]                           if (!grepl(pattern, name)) 
[10:34:07.164]                             next
[10:34:07.164]                           invokeRestart(restart)
[10:34:07.164]                           muffled <- TRUE
[10:34:07.164]                           break
[10:34:07.164]                         }
[10:34:07.164]                       }
[10:34:07.164]                     }
[10:34:07.164]                     invisible(muffled)
[10:34:07.164]                   }
[10:34:07.164]                   muffleCondition(cond)
[10:34:07.164]                 })
[10:34:07.164]             }))
[10:34:07.164]             future::FutureResult(value = ...future.value$value, 
[10:34:07.164]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:07.164]                   ...future.rng), globalenv = if (FALSE) 
[10:34:07.164]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:07.164]                     ...future.globalenv.names))
[10:34:07.164]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:07.164]         }, condition = base::local({
[10:34:07.164]             c <- base::c
[10:34:07.164]             inherits <- base::inherits
[10:34:07.164]             invokeRestart <- base::invokeRestart
[10:34:07.164]             length <- base::length
[10:34:07.164]             list <- base::list
[10:34:07.164]             seq.int <- base::seq.int
[10:34:07.164]             signalCondition <- base::signalCondition
[10:34:07.164]             sys.calls <- base::sys.calls
[10:34:07.164]             `[[` <- base::`[[`
[10:34:07.164]             `+` <- base::`+`
[10:34:07.164]             `<<-` <- base::`<<-`
[10:34:07.164]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:07.164]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:07.164]                   3L)]
[10:34:07.164]             }
[10:34:07.164]             function(cond) {
[10:34:07.164]                 is_error <- inherits(cond, "error")
[10:34:07.164]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:07.164]                   NULL)
[10:34:07.164]                 if (is_error) {
[10:34:07.164]                   sessionInformation <- function() {
[10:34:07.164]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:07.164]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:07.164]                       search = base::search(), system = base::Sys.info())
[10:34:07.164]                   }
[10:34:07.164]                   ...future.conditions[[length(...future.conditions) + 
[10:34:07.164]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:07.164]                     cond$call), session = sessionInformation(), 
[10:34:07.164]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:07.164]                   signalCondition(cond)
[10:34:07.164]                 }
[10:34:07.164]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:07.164]                 "immediateCondition"))) {
[10:34:07.164]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:07.164]                   ...future.conditions[[length(...future.conditions) + 
[10:34:07.164]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:07.164]                   if (TRUE && !signal) {
[10:34:07.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:07.164]                     {
[10:34:07.164]                       inherits <- base::inherits
[10:34:07.164]                       invokeRestart <- base::invokeRestart
[10:34:07.164]                       is.null <- base::is.null
[10:34:07.164]                       muffled <- FALSE
[10:34:07.164]                       if (inherits(cond, "message")) {
[10:34:07.164]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:07.164]                         if (muffled) 
[10:34:07.164]                           invokeRestart("muffleMessage")
[10:34:07.164]                       }
[10:34:07.164]                       else if (inherits(cond, "warning")) {
[10:34:07.164]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:07.164]                         if (muffled) 
[10:34:07.164]                           invokeRestart("muffleWarning")
[10:34:07.164]                       }
[10:34:07.164]                       else if (inherits(cond, "condition")) {
[10:34:07.164]                         if (!is.null(pattern)) {
[10:34:07.164]                           computeRestarts <- base::computeRestarts
[10:34:07.164]                           grepl <- base::grepl
[10:34:07.164]                           restarts <- computeRestarts(cond)
[10:34:07.164]                           for (restart in restarts) {
[10:34:07.164]                             name <- restart$name
[10:34:07.164]                             if (is.null(name)) 
[10:34:07.164]                               next
[10:34:07.164]                             if (!grepl(pattern, name)) 
[10:34:07.164]                               next
[10:34:07.164]                             invokeRestart(restart)
[10:34:07.164]                             muffled <- TRUE
[10:34:07.164]                             break
[10:34:07.164]                           }
[10:34:07.164]                         }
[10:34:07.164]                       }
[10:34:07.164]                       invisible(muffled)
[10:34:07.164]                     }
[10:34:07.164]                     muffleCondition(cond, pattern = "^muffle")
[10:34:07.164]                   }
[10:34:07.164]                 }
[10:34:07.164]                 else {
[10:34:07.164]                   if (TRUE) {
[10:34:07.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:07.164]                     {
[10:34:07.164]                       inherits <- base::inherits
[10:34:07.164]                       invokeRestart <- base::invokeRestart
[10:34:07.164]                       is.null <- base::is.null
[10:34:07.164]                       muffled <- FALSE
[10:34:07.164]                       if (inherits(cond, "message")) {
[10:34:07.164]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:07.164]                         if (muffled) 
[10:34:07.164]                           invokeRestart("muffleMessage")
[10:34:07.164]                       }
[10:34:07.164]                       else if (inherits(cond, "warning")) {
[10:34:07.164]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:07.164]                         if (muffled) 
[10:34:07.164]                           invokeRestart("muffleWarning")
[10:34:07.164]                       }
[10:34:07.164]                       else if (inherits(cond, "condition")) {
[10:34:07.164]                         if (!is.null(pattern)) {
[10:34:07.164]                           computeRestarts <- base::computeRestarts
[10:34:07.164]                           grepl <- base::grepl
[10:34:07.164]                           restarts <- computeRestarts(cond)
[10:34:07.164]                           for (restart in restarts) {
[10:34:07.164]                             name <- restart$name
[10:34:07.164]                             if (is.null(name)) 
[10:34:07.164]                               next
[10:34:07.164]                             if (!grepl(pattern, name)) 
[10:34:07.164]                               next
[10:34:07.164]                             invokeRestart(restart)
[10:34:07.164]                             muffled <- TRUE
[10:34:07.164]                             break
[10:34:07.164]                           }
[10:34:07.164]                         }
[10:34:07.164]                       }
[10:34:07.164]                       invisible(muffled)
[10:34:07.164]                     }
[10:34:07.164]                     muffleCondition(cond, pattern = "^muffle")
[10:34:07.164]                   }
[10:34:07.164]                 }
[10:34:07.164]             }
[10:34:07.164]         }))
[10:34:07.164]     }, error = function(ex) {
[10:34:07.164]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:07.164]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:07.164]                 ...future.rng), started = ...future.startTime, 
[10:34:07.164]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:07.164]             version = "1.8"), class = "FutureResult")
[10:34:07.164]     }, finally = {
[10:34:07.164]         if (!identical(...future.workdir, getwd())) 
[10:34:07.164]             setwd(...future.workdir)
[10:34:07.164]         {
[10:34:07.164]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:07.164]                 ...future.oldOptions$nwarnings <- NULL
[10:34:07.164]             }
[10:34:07.164]             base::options(...future.oldOptions)
[10:34:07.164]             if (.Platform$OS.type == "windows") {
[10:34:07.164]                 old_names <- names(...future.oldEnvVars)
[10:34:07.164]                 envs <- base::Sys.getenv()
[10:34:07.164]                 names <- names(envs)
[10:34:07.164]                 common <- intersect(names, old_names)
[10:34:07.164]                 added <- setdiff(names, old_names)
[10:34:07.164]                 removed <- setdiff(old_names, names)
[10:34:07.164]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:07.164]                   envs[common]]
[10:34:07.164]                 NAMES <- toupper(changed)
[10:34:07.164]                 args <- list()
[10:34:07.164]                 for (kk in seq_along(NAMES)) {
[10:34:07.164]                   name <- changed[[kk]]
[10:34:07.164]                   NAME <- NAMES[[kk]]
[10:34:07.164]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:07.164]                     next
[10:34:07.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:07.164]                 }
[10:34:07.164]                 NAMES <- toupper(added)
[10:34:07.164]                 for (kk in seq_along(NAMES)) {
[10:34:07.164]                   name <- added[[kk]]
[10:34:07.164]                   NAME <- NAMES[[kk]]
[10:34:07.164]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:07.164]                     next
[10:34:07.164]                   args[[name]] <- ""
[10:34:07.164]                 }
[10:34:07.164]                 NAMES <- toupper(removed)
[10:34:07.164]                 for (kk in seq_along(NAMES)) {
[10:34:07.164]                   name <- removed[[kk]]
[10:34:07.164]                   NAME <- NAMES[[kk]]
[10:34:07.164]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:07.164]                     next
[10:34:07.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:07.164]                 }
[10:34:07.164]                 if (length(args) > 0) 
[10:34:07.164]                   base::do.call(base::Sys.setenv, args = args)
[10:34:07.164]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:07.164]             }
[10:34:07.164]             else {
[10:34:07.164]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:07.164]             }
[10:34:07.164]             {
[10:34:07.164]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:07.164]                   0L) {
[10:34:07.164]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:07.164]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:07.164]                   base::options(opts)
[10:34:07.164]                 }
[10:34:07.164]                 {
[10:34:07.164]                   {
[10:34:07.164]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:07.164]                     NULL
[10:34:07.164]                   }
[10:34:07.164]                   options(future.plan = NULL)
[10:34:07.164]                   if (is.na(NA_character_)) 
[10:34:07.164]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:07.164]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:07.164]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:07.164]                     .init = FALSE)
[10:34:07.164]                 }
[10:34:07.164]             }
[10:34:07.164]         }
[10:34:07.164]     })
[10:34:07.164]     if (TRUE) {
[10:34:07.164]         base::sink(type = "output", split = FALSE)
[10:34:07.164]         if (TRUE) {
[10:34:07.164]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:07.164]         }
[10:34:07.164]         else {
[10:34:07.164]             ...future.result["stdout"] <- base::list(NULL)
[10:34:07.164]         }
[10:34:07.164]         base::close(...future.stdout)
[10:34:07.164]         ...future.stdout <- NULL
[10:34:07.164]     }
[10:34:07.164]     ...future.result$conditions <- ...future.conditions
[10:34:07.164]     ...future.result$finished <- base::Sys.time()
[10:34:07.164]     ...future.result
[10:34:07.164] }
[10:34:07.167] MultisessionFuture started
[10:34:07.167] - Launch lazy future ... done
[10:34:07.167] run() for ‘MultisessionFuture’ ... done
[10:34:07.669] receiveMessageFromWorker() for ClusterFuture ...
[10:34:07.669] - Validating connection of MultisessionFuture
[10:34:07.670] - received message: FutureResult
[10:34:07.670] - Received FutureResult
[10:34:07.670] - Erased future from FutureRegistry
[10:34:07.670] result() for ClusterFuture ...
[10:34:07.670] - result already collected: FutureResult
[10:34:07.670] result() for ClusterFuture ... done
[10:34:07.670] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:07.670] A MultisessionFuture was resolved (result was not collected)
[10:34:07.671] getGlobalsAndPackages() ...
[10:34:07.671] Searching for globals...
[10:34:07.672] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:34:07.672] Searching for globals ... DONE
[10:34:07.672] Resolving globals: FALSE
[10:34:07.672] 
[10:34:07.672] 
[10:34:07.672] getGlobalsAndPackages() ... DONE
[10:34:07.673] run() for ‘Future’ ...
[10:34:07.673] - state: ‘created’
[10:34:07.673] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:07.688] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:07.688] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:07.688]   - Field: ‘node’
[10:34:07.688]   - Field: ‘label’
[10:34:07.688]   - Field: ‘local’
[10:34:07.689]   - Field: ‘owner’
[10:34:07.689]   - Field: ‘envir’
[10:34:07.689]   - Field: ‘workers’
[10:34:07.689]   - Field: ‘packages’
[10:34:07.689]   - Field: ‘gc’
[10:34:07.689]   - Field: ‘conditions’
[10:34:07.689]   - Field: ‘persistent’
[10:34:07.689]   - Field: ‘expr’
[10:34:07.689]   - Field: ‘uuid’
[10:34:07.689]   - Field: ‘seed’
[10:34:07.690]   - Field: ‘version’
[10:34:07.690]   - Field: ‘result’
[10:34:07.690]   - Field: ‘asynchronous’
[10:34:07.690]   - Field: ‘calls’
[10:34:07.690]   - Field: ‘globals’
[10:34:07.690]   - Field: ‘stdout’
[10:34:07.690]   - Field: ‘earlySignal’
[10:34:07.690]   - Field: ‘lazy’
[10:34:07.690]   - Field: ‘state’
[10:34:07.690] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:07.690] - Launch lazy future ...
[10:34:07.691] Packages needed by the future expression (n = 0): <none>
[10:34:07.691] Packages needed by future strategies (n = 0): <none>
[10:34:07.691] {
[10:34:07.691]     {
[10:34:07.691]         {
[10:34:07.691]             ...future.startTime <- base::Sys.time()
[10:34:07.691]             {
[10:34:07.691]                 {
[10:34:07.691]                   {
[10:34:07.691]                     {
[10:34:07.691]                       base::local({
[10:34:07.691]                         has_future <- base::requireNamespace("future", 
[10:34:07.691]                           quietly = TRUE)
[10:34:07.691]                         if (has_future) {
[10:34:07.691]                           ns <- base::getNamespace("future")
[10:34:07.691]                           version <- ns[[".package"]][["version"]]
[10:34:07.691]                           if (is.null(version)) 
[10:34:07.691]                             version <- utils::packageVersion("future")
[10:34:07.691]                         }
[10:34:07.691]                         else {
[10:34:07.691]                           version <- NULL
[10:34:07.691]                         }
[10:34:07.691]                         if (!has_future || version < "1.8.0") {
[10:34:07.691]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:07.691]                             "", base::R.version$version.string), 
[10:34:07.691]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:07.691]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:07.691]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:07.691]                               "release", "version")], collapse = " "), 
[10:34:07.691]                             hostname = base::Sys.info()[["nodename"]])
[10:34:07.691]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:07.691]                             info)
[10:34:07.691]                           info <- base::paste(info, collapse = "; ")
[10:34:07.691]                           if (!has_future) {
[10:34:07.691]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:07.691]                               info)
[10:34:07.691]                           }
[10:34:07.691]                           else {
[10:34:07.691]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:07.691]                               info, version)
[10:34:07.691]                           }
[10:34:07.691]                           base::stop(msg)
[10:34:07.691]                         }
[10:34:07.691]                       })
[10:34:07.691]                     }
[10:34:07.691]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:07.691]                     base::options(mc.cores = 1L)
[10:34:07.691]                   }
[10:34:07.691]                   ...future.strategy.old <- future::plan("list")
[10:34:07.691]                   options(future.plan = NULL)
[10:34:07.691]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:07.691]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:07.691]                 }
[10:34:07.691]                 ...future.workdir <- getwd()
[10:34:07.691]             }
[10:34:07.691]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:07.691]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:07.691]         }
[10:34:07.691]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:07.691]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:07.691]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:07.691]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:07.691]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:07.691]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:07.691]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:07.691]             base::names(...future.oldOptions))
[10:34:07.691]     }
[10:34:07.691]     if (FALSE) {
[10:34:07.691]     }
[10:34:07.691]     else {
[10:34:07.691]         if (TRUE) {
[10:34:07.691]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:07.691]                 open = "w")
[10:34:07.691]         }
[10:34:07.691]         else {
[10:34:07.691]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:07.691]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:07.691]         }
[10:34:07.691]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:07.691]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:07.691]             base::sink(type = "output", split = FALSE)
[10:34:07.691]             base::close(...future.stdout)
[10:34:07.691]         }, add = TRUE)
[10:34:07.691]     }
[10:34:07.691]     ...future.frame <- base::sys.nframe()
[10:34:07.691]     ...future.conditions <- base::list()
[10:34:07.691]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:07.691]     if (FALSE) {
[10:34:07.691]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:07.691]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:07.691]     }
[10:34:07.691]     ...future.result <- base::tryCatch({
[10:34:07.691]         base::withCallingHandlers({
[10:34:07.691]             ...future.value <- base::withVisible(base::local({
[10:34:07.691]                 ...future.makeSendCondition <- base::local({
[10:34:07.691]                   sendCondition <- NULL
[10:34:07.691]                   function(frame = 1L) {
[10:34:07.691]                     if (is.function(sendCondition)) 
[10:34:07.691]                       return(sendCondition)
[10:34:07.691]                     ns <- getNamespace("parallel")
[10:34:07.691]                     if (exists("sendData", mode = "function", 
[10:34:07.691]                       envir = ns)) {
[10:34:07.691]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:07.691]                         envir = ns)
[10:34:07.691]                       envir <- sys.frame(frame)
[10:34:07.691]                       master <- NULL
[10:34:07.691]                       while (!identical(envir, .GlobalEnv) && 
[10:34:07.691]                         !identical(envir, emptyenv())) {
[10:34:07.691]                         if (exists("master", mode = "list", envir = envir, 
[10:34:07.691]                           inherits = FALSE)) {
[10:34:07.691]                           master <- get("master", mode = "list", 
[10:34:07.691]                             envir = envir, inherits = FALSE)
[10:34:07.691]                           if (inherits(master, c("SOCKnode", 
[10:34:07.691]                             "SOCK0node"))) {
[10:34:07.691]                             sendCondition <<- function(cond) {
[10:34:07.691]                               data <- list(type = "VALUE", value = cond, 
[10:34:07.691]                                 success = TRUE)
[10:34:07.691]                               parallel_sendData(master, data)
[10:34:07.691]                             }
[10:34:07.691]                             return(sendCondition)
[10:34:07.691]                           }
[10:34:07.691]                         }
[10:34:07.691]                         frame <- frame + 1L
[10:34:07.691]                         envir <- sys.frame(frame)
[10:34:07.691]                       }
[10:34:07.691]                     }
[10:34:07.691]                     sendCondition <<- function(cond) NULL
[10:34:07.691]                   }
[10:34:07.691]                 })
[10:34:07.691]                 withCallingHandlers({
[10:34:07.691]                   {
[10:34:07.691]                     Sys.sleep(0.5)
[10:34:07.691]                     list(a = 1, b = 42L)
[10:34:07.691]                   }
[10:34:07.691]                 }, immediateCondition = function(cond) {
[10:34:07.691]                   sendCondition <- ...future.makeSendCondition()
[10:34:07.691]                   sendCondition(cond)
[10:34:07.691]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:07.691]                   {
[10:34:07.691]                     inherits <- base::inherits
[10:34:07.691]                     invokeRestart <- base::invokeRestart
[10:34:07.691]                     is.null <- base::is.null
[10:34:07.691]                     muffled <- FALSE
[10:34:07.691]                     if (inherits(cond, "message")) {
[10:34:07.691]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:07.691]                       if (muffled) 
[10:34:07.691]                         invokeRestart("muffleMessage")
[10:34:07.691]                     }
[10:34:07.691]                     else if (inherits(cond, "warning")) {
[10:34:07.691]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:07.691]                       if (muffled) 
[10:34:07.691]                         invokeRestart("muffleWarning")
[10:34:07.691]                     }
[10:34:07.691]                     else if (inherits(cond, "condition")) {
[10:34:07.691]                       if (!is.null(pattern)) {
[10:34:07.691]                         computeRestarts <- base::computeRestarts
[10:34:07.691]                         grepl <- base::grepl
[10:34:07.691]                         restarts <- computeRestarts(cond)
[10:34:07.691]                         for (restart in restarts) {
[10:34:07.691]                           name <- restart$name
[10:34:07.691]                           if (is.null(name)) 
[10:34:07.691]                             next
[10:34:07.691]                           if (!grepl(pattern, name)) 
[10:34:07.691]                             next
[10:34:07.691]                           invokeRestart(restart)
[10:34:07.691]                           muffled <- TRUE
[10:34:07.691]                           break
[10:34:07.691]                         }
[10:34:07.691]                       }
[10:34:07.691]                     }
[10:34:07.691]                     invisible(muffled)
[10:34:07.691]                   }
[10:34:07.691]                   muffleCondition(cond)
[10:34:07.691]                 })
[10:34:07.691]             }))
[10:34:07.691]             future::FutureResult(value = ...future.value$value, 
[10:34:07.691]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:07.691]                   ...future.rng), globalenv = if (FALSE) 
[10:34:07.691]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:07.691]                     ...future.globalenv.names))
[10:34:07.691]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:07.691]         }, condition = base::local({
[10:34:07.691]             c <- base::c
[10:34:07.691]             inherits <- base::inherits
[10:34:07.691]             invokeRestart <- base::invokeRestart
[10:34:07.691]             length <- base::length
[10:34:07.691]             list <- base::list
[10:34:07.691]             seq.int <- base::seq.int
[10:34:07.691]             signalCondition <- base::signalCondition
[10:34:07.691]             sys.calls <- base::sys.calls
[10:34:07.691]             `[[` <- base::`[[`
[10:34:07.691]             `+` <- base::`+`
[10:34:07.691]             `<<-` <- base::`<<-`
[10:34:07.691]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:07.691]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:07.691]                   3L)]
[10:34:07.691]             }
[10:34:07.691]             function(cond) {
[10:34:07.691]                 is_error <- inherits(cond, "error")
[10:34:07.691]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:07.691]                   NULL)
[10:34:07.691]                 if (is_error) {
[10:34:07.691]                   sessionInformation <- function() {
[10:34:07.691]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:07.691]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:07.691]                       search = base::search(), system = base::Sys.info())
[10:34:07.691]                   }
[10:34:07.691]                   ...future.conditions[[length(...future.conditions) + 
[10:34:07.691]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:07.691]                     cond$call), session = sessionInformation(), 
[10:34:07.691]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:07.691]                   signalCondition(cond)
[10:34:07.691]                 }
[10:34:07.691]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:07.691]                 "immediateCondition"))) {
[10:34:07.691]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:07.691]                   ...future.conditions[[length(...future.conditions) + 
[10:34:07.691]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:07.691]                   if (TRUE && !signal) {
[10:34:07.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:07.691]                     {
[10:34:07.691]                       inherits <- base::inherits
[10:34:07.691]                       invokeRestart <- base::invokeRestart
[10:34:07.691]                       is.null <- base::is.null
[10:34:07.691]                       muffled <- FALSE
[10:34:07.691]                       if (inherits(cond, "message")) {
[10:34:07.691]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:07.691]                         if (muffled) 
[10:34:07.691]                           invokeRestart("muffleMessage")
[10:34:07.691]                       }
[10:34:07.691]                       else if (inherits(cond, "warning")) {
[10:34:07.691]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:07.691]                         if (muffled) 
[10:34:07.691]                           invokeRestart("muffleWarning")
[10:34:07.691]                       }
[10:34:07.691]                       else if (inherits(cond, "condition")) {
[10:34:07.691]                         if (!is.null(pattern)) {
[10:34:07.691]                           computeRestarts <- base::computeRestarts
[10:34:07.691]                           grepl <- base::grepl
[10:34:07.691]                           restarts <- computeRestarts(cond)
[10:34:07.691]                           for (restart in restarts) {
[10:34:07.691]                             name <- restart$name
[10:34:07.691]                             if (is.null(name)) 
[10:34:07.691]                               next
[10:34:07.691]                             if (!grepl(pattern, name)) 
[10:34:07.691]                               next
[10:34:07.691]                             invokeRestart(restart)
[10:34:07.691]                             muffled <- TRUE
[10:34:07.691]                             break
[10:34:07.691]                           }
[10:34:07.691]                         }
[10:34:07.691]                       }
[10:34:07.691]                       invisible(muffled)
[10:34:07.691]                     }
[10:34:07.691]                     muffleCondition(cond, pattern = "^muffle")
[10:34:07.691]                   }
[10:34:07.691]                 }
[10:34:07.691]                 else {
[10:34:07.691]                   if (TRUE) {
[10:34:07.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:07.691]                     {
[10:34:07.691]                       inherits <- base::inherits
[10:34:07.691]                       invokeRestart <- base::invokeRestart
[10:34:07.691]                       is.null <- base::is.null
[10:34:07.691]                       muffled <- FALSE
[10:34:07.691]                       if (inherits(cond, "message")) {
[10:34:07.691]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:07.691]                         if (muffled) 
[10:34:07.691]                           invokeRestart("muffleMessage")
[10:34:07.691]                       }
[10:34:07.691]                       else if (inherits(cond, "warning")) {
[10:34:07.691]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:07.691]                         if (muffled) 
[10:34:07.691]                           invokeRestart("muffleWarning")
[10:34:07.691]                       }
[10:34:07.691]                       else if (inherits(cond, "condition")) {
[10:34:07.691]                         if (!is.null(pattern)) {
[10:34:07.691]                           computeRestarts <- base::computeRestarts
[10:34:07.691]                           grepl <- base::grepl
[10:34:07.691]                           restarts <- computeRestarts(cond)
[10:34:07.691]                           for (restart in restarts) {
[10:34:07.691]                             name <- restart$name
[10:34:07.691]                             if (is.null(name)) 
[10:34:07.691]                               next
[10:34:07.691]                             if (!grepl(pattern, name)) 
[10:34:07.691]                               next
[10:34:07.691]                             invokeRestart(restart)
[10:34:07.691]                             muffled <- TRUE
[10:34:07.691]                             break
[10:34:07.691]                           }
[10:34:07.691]                         }
[10:34:07.691]                       }
[10:34:07.691]                       invisible(muffled)
[10:34:07.691]                     }
[10:34:07.691]                     muffleCondition(cond, pattern = "^muffle")
[10:34:07.691]                   }
[10:34:07.691]                 }
[10:34:07.691]             }
[10:34:07.691]         }))
[10:34:07.691]     }, error = function(ex) {
[10:34:07.691]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:07.691]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:07.691]                 ...future.rng), started = ...future.startTime, 
[10:34:07.691]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:07.691]             version = "1.8"), class = "FutureResult")
[10:34:07.691]     }, finally = {
[10:34:07.691]         if (!identical(...future.workdir, getwd())) 
[10:34:07.691]             setwd(...future.workdir)
[10:34:07.691]         {
[10:34:07.691]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:07.691]                 ...future.oldOptions$nwarnings <- NULL
[10:34:07.691]             }
[10:34:07.691]             base::options(...future.oldOptions)
[10:34:07.691]             if (.Platform$OS.type == "windows") {
[10:34:07.691]                 old_names <- names(...future.oldEnvVars)
[10:34:07.691]                 envs <- base::Sys.getenv()
[10:34:07.691]                 names <- names(envs)
[10:34:07.691]                 common <- intersect(names, old_names)
[10:34:07.691]                 added <- setdiff(names, old_names)
[10:34:07.691]                 removed <- setdiff(old_names, names)
[10:34:07.691]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:07.691]                   envs[common]]
[10:34:07.691]                 NAMES <- toupper(changed)
[10:34:07.691]                 args <- list()
[10:34:07.691]                 for (kk in seq_along(NAMES)) {
[10:34:07.691]                   name <- changed[[kk]]
[10:34:07.691]                   NAME <- NAMES[[kk]]
[10:34:07.691]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:07.691]                     next
[10:34:07.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:07.691]                 }
[10:34:07.691]                 NAMES <- toupper(added)
[10:34:07.691]                 for (kk in seq_along(NAMES)) {
[10:34:07.691]                   name <- added[[kk]]
[10:34:07.691]                   NAME <- NAMES[[kk]]
[10:34:07.691]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:07.691]                     next
[10:34:07.691]                   args[[name]] <- ""
[10:34:07.691]                 }
[10:34:07.691]                 NAMES <- toupper(removed)
[10:34:07.691]                 for (kk in seq_along(NAMES)) {
[10:34:07.691]                   name <- removed[[kk]]
[10:34:07.691]                   NAME <- NAMES[[kk]]
[10:34:07.691]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:07.691]                     next
[10:34:07.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:07.691]                 }
[10:34:07.691]                 if (length(args) > 0) 
[10:34:07.691]                   base::do.call(base::Sys.setenv, args = args)
[10:34:07.691]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:07.691]             }
[10:34:07.691]             else {
[10:34:07.691]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:07.691]             }
[10:34:07.691]             {
[10:34:07.691]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:07.691]                   0L) {
[10:34:07.691]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:07.691]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:07.691]                   base::options(opts)
[10:34:07.691]                 }
[10:34:07.691]                 {
[10:34:07.691]                   {
[10:34:07.691]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:07.691]                     NULL
[10:34:07.691]                   }
[10:34:07.691]                   options(future.plan = NULL)
[10:34:07.691]                   if (is.na(NA_character_)) 
[10:34:07.691]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:07.691]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:07.691]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:07.691]                     .init = FALSE)
[10:34:07.691]                 }
[10:34:07.691]             }
[10:34:07.691]         }
[10:34:07.691]     })
[10:34:07.691]     if (TRUE) {
[10:34:07.691]         base::sink(type = "output", split = FALSE)
[10:34:07.691]         if (TRUE) {
[10:34:07.691]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:07.691]         }
[10:34:07.691]         else {
[10:34:07.691]             ...future.result["stdout"] <- base::list(NULL)
[10:34:07.691]         }
[10:34:07.691]         base::close(...future.stdout)
[10:34:07.691]         ...future.stdout <- NULL
[10:34:07.691]     }
[10:34:07.691]     ...future.result$conditions <- ...future.conditions
[10:34:07.691]     ...future.result$finished <- base::Sys.time()
[10:34:07.691]     ...future.result
[10:34:07.691] }
[10:34:07.694] MultisessionFuture started
[10:34:07.694] - Launch lazy future ... done
[10:34:07.694] run() for ‘MultisessionFuture’ ... done
[10:34:08.196] receiveMessageFromWorker() for ClusterFuture ...
[10:34:08.197] - Validating connection of MultisessionFuture
[10:34:08.197] - received message: FutureResult
[10:34:08.197] - Received FutureResult
[10:34:08.197] - Erased future from FutureRegistry
[10:34:08.197] result() for ClusterFuture ...
[10:34:08.197] - result already collected: FutureResult
[10:34:08.198] result() for ClusterFuture ... done
[10:34:08.198] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:08.198] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[10:34:08.198] getGlobalsAndPackages() ...
[10:34:08.198] Searching for globals...
[10:34:08.199] - globals found: [2] ‘list’, ‘stop’
[10:34:08.199] Searching for globals ... DONE
[10:34:08.199] Resolving globals: FALSE
[10:34:08.199] 
[10:34:08.199] 
[10:34:08.199] getGlobalsAndPackages() ... DONE
[10:34:08.200] run() for ‘Future’ ...
[10:34:08.200] - state: ‘created’
[10:34:08.200] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:08.214] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:08.214] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:08.214]   - Field: ‘node’
[10:34:08.214]   - Field: ‘label’
[10:34:08.214]   - Field: ‘local’
[10:34:08.214]   - Field: ‘owner’
[10:34:08.214]   - Field: ‘envir’
[10:34:08.215]   - Field: ‘workers’
[10:34:08.215]   - Field: ‘packages’
[10:34:08.215]   - Field: ‘gc’
[10:34:08.215]   - Field: ‘conditions’
[10:34:08.215]   - Field: ‘persistent’
[10:34:08.215]   - Field: ‘expr’
[10:34:08.215]   - Field: ‘uuid’
[10:34:08.215]   - Field: ‘seed’
[10:34:08.215]   - Field: ‘version’
[10:34:08.215]   - Field: ‘result’
[10:34:08.215]   - Field: ‘asynchronous’
[10:34:08.216]   - Field: ‘calls’
[10:34:08.216]   - Field: ‘globals’
[10:34:08.216]   - Field: ‘stdout’
[10:34:08.216]   - Field: ‘earlySignal’
[10:34:08.216]   - Field: ‘lazy’
[10:34:08.216]   - Field: ‘state’
[10:34:08.216] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:08.216] - Launch lazy future ...
[10:34:08.216] Packages needed by the future expression (n = 0): <none>
[10:34:08.217] Packages needed by future strategies (n = 0): <none>
[10:34:08.217] {
[10:34:08.217]     {
[10:34:08.217]         {
[10:34:08.217]             ...future.startTime <- base::Sys.time()
[10:34:08.217]             {
[10:34:08.217]                 {
[10:34:08.217]                   {
[10:34:08.217]                     {
[10:34:08.217]                       base::local({
[10:34:08.217]                         has_future <- base::requireNamespace("future", 
[10:34:08.217]                           quietly = TRUE)
[10:34:08.217]                         if (has_future) {
[10:34:08.217]                           ns <- base::getNamespace("future")
[10:34:08.217]                           version <- ns[[".package"]][["version"]]
[10:34:08.217]                           if (is.null(version)) 
[10:34:08.217]                             version <- utils::packageVersion("future")
[10:34:08.217]                         }
[10:34:08.217]                         else {
[10:34:08.217]                           version <- NULL
[10:34:08.217]                         }
[10:34:08.217]                         if (!has_future || version < "1.8.0") {
[10:34:08.217]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:08.217]                             "", base::R.version$version.string), 
[10:34:08.217]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:08.217]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:08.217]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:08.217]                               "release", "version")], collapse = " "), 
[10:34:08.217]                             hostname = base::Sys.info()[["nodename"]])
[10:34:08.217]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:08.217]                             info)
[10:34:08.217]                           info <- base::paste(info, collapse = "; ")
[10:34:08.217]                           if (!has_future) {
[10:34:08.217]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:08.217]                               info)
[10:34:08.217]                           }
[10:34:08.217]                           else {
[10:34:08.217]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:08.217]                               info, version)
[10:34:08.217]                           }
[10:34:08.217]                           base::stop(msg)
[10:34:08.217]                         }
[10:34:08.217]                       })
[10:34:08.217]                     }
[10:34:08.217]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:08.217]                     base::options(mc.cores = 1L)
[10:34:08.217]                   }
[10:34:08.217]                   ...future.strategy.old <- future::plan("list")
[10:34:08.217]                   options(future.plan = NULL)
[10:34:08.217]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:08.217]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:08.217]                 }
[10:34:08.217]                 ...future.workdir <- getwd()
[10:34:08.217]             }
[10:34:08.217]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:08.217]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:08.217]         }
[10:34:08.217]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:08.217]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:08.217]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:08.217]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:08.217]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:08.217]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:08.217]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:08.217]             base::names(...future.oldOptions))
[10:34:08.217]     }
[10:34:08.217]     if (FALSE) {
[10:34:08.217]     }
[10:34:08.217]     else {
[10:34:08.217]         if (TRUE) {
[10:34:08.217]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:08.217]                 open = "w")
[10:34:08.217]         }
[10:34:08.217]         else {
[10:34:08.217]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:08.217]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:08.217]         }
[10:34:08.217]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:08.217]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:08.217]             base::sink(type = "output", split = FALSE)
[10:34:08.217]             base::close(...future.stdout)
[10:34:08.217]         }, add = TRUE)
[10:34:08.217]     }
[10:34:08.217]     ...future.frame <- base::sys.nframe()
[10:34:08.217]     ...future.conditions <- base::list()
[10:34:08.217]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:08.217]     if (FALSE) {
[10:34:08.217]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:08.217]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:08.217]     }
[10:34:08.217]     ...future.result <- base::tryCatch({
[10:34:08.217]         base::withCallingHandlers({
[10:34:08.217]             ...future.value <- base::withVisible(base::local({
[10:34:08.217]                 ...future.makeSendCondition <- base::local({
[10:34:08.217]                   sendCondition <- NULL
[10:34:08.217]                   function(frame = 1L) {
[10:34:08.217]                     if (is.function(sendCondition)) 
[10:34:08.217]                       return(sendCondition)
[10:34:08.217]                     ns <- getNamespace("parallel")
[10:34:08.217]                     if (exists("sendData", mode = "function", 
[10:34:08.217]                       envir = ns)) {
[10:34:08.217]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:08.217]                         envir = ns)
[10:34:08.217]                       envir <- sys.frame(frame)
[10:34:08.217]                       master <- NULL
[10:34:08.217]                       while (!identical(envir, .GlobalEnv) && 
[10:34:08.217]                         !identical(envir, emptyenv())) {
[10:34:08.217]                         if (exists("master", mode = "list", envir = envir, 
[10:34:08.217]                           inherits = FALSE)) {
[10:34:08.217]                           master <- get("master", mode = "list", 
[10:34:08.217]                             envir = envir, inherits = FALSE)
[10:34:08.217]                           if (inherits(master, c("SOCKnode", 
[10:34:08.217]                             "SOCK0node"))) {
[10:34:08.217]                             sendCondition <<- function(cond) {
[10:34:08.217]                               data <- list(type = "VALUE", value = cond, 
[10:34:08.217]                                 success = TRUE)
[10:34:08.217]                               parallel_sendData(master, data)
[10:34:08.217]                             }
[10:34:08.217]                             return(sendCondition)
[10:34:08.217]                           }
[10:34:08.217]                         }
[10:34:08.217]                         frame <- frame + 1L
[10:34:08.217]                         envir <- sys.frame(frame)
[10:34:08.217]                       }
[10:34:08.217]                     }
[10:34:08.217]                     sendCondition <<- function(cond) NULL
[10:34:08.217]                   }
[10:34:08.217]                 })
[10:34:08.217]                 withCallingHandlers({
[10:34:08.217]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:34:08.217]                 }, immediateCondition = function(cond) {
[10:34:08.217]                   sendCondition <- ...future.makeSendCondition()
[10:34:08.217]                   sendCondition(cond)
[10:34:08.217]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:08.217]                   {
[10:34:08.217]                     inherits <- base::inherits
[10:34:08.217]                     invokeRestart <- base::invokeRestart
[10:34:08.217]                     is.null <- base::is.null
[10:34:08.217]                     muffled <- FALSE
[10:34:08.217]                     if (inherits(cond, "message")) {
[10:34:08.217]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:08.217]                       if (muffled) 
[10:34:08.217]                         invokeRestart("muffleMessage")
[10:34:08.217]                     }
[10:34:08.217]                     else if (inherits(cond, "warning")) {
[10:34:08.217]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:08.217]                       if (muffled) 
[10:34:08.217]                         invokeRestart("muffleWarning")
[10:34:08.217]                     }
[10:34:08.217]                     else if (inherits(cond, "condition")) {
[10:34:08.217]                       if (!is.null(pattern)) {
[10:34:08.217]                         computeRestarts <- base::computeRestarts
[10:34:08.217]                         grepl <- base::grepl
[10:34:08.217]                         restarts <- computeRestarts(cond)
[10:34:08.217]                         for (restart in restarts) {
[10:34:08.217]                           name <- restart$name
[10:34:08.217]                           if (is.null(name)) 
[10:34:08.217]                             next
[10:34:08.217]                           if (!grepl(pattern, name)) 
[10:34:08.217]                             next
[10:34:08.217]                           invokeRestart(restart)
[10:34:08.217]                           muffled <- TRUE
[10:34:08.217]                           break
[10:34:08.217]                         }
[10:34:08.217]                       }
[10:34:08.217]                     }
[10:34:08.217]                     invisible(muffled)
[10:34:08.217]                   }
[10:34:08.217]                   muffleCondition(cond)
[10:34:08.217]                 })
[10:34:08.217]             }))
[10:34:08.217]             future::FutureResult(value = ...future.value$value, 
[10:34:08.217]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:08.217]                   ...future.rng), globalenv = if (FALSE) 
[10:34:08.217]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:08.217]                     ...future.globalenv.names))
[10:34:08.217]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:08.217]         }, condition = base::local({
[10:34:08.217]             c <- base::c
[10:34:08.217]             inherits <- base::inherits
[10:34:08.217]             invokeRestart <- base::invokeRestart
[10:34:08.217]             length <- base::length
[10:34:08.217]             list <- base::list
[10:34:08.217]             seq.int <- base::seq.int
[10:34:08.217]             signalCondition <- base::signalCondition
[10:34:08.217]             sys.calls <- base::sys.calls
[10:34:08.217]             `[[` <- base::`[[`
[10:34:08.217]             `+` <- base::`+`
[10:34:08.217]             `<<-` <- base::`<<-`
[10:34:08.217]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:08.217]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:08.217]                   3L)]
[10:34:08.217]             }
[10:34:08.217]             function(cond) {
[10:34:08.217]                 is_error <- inherits(cond, "error")
[10:34:08.217]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:08.217]                   NULL)
[10:34:08.217]                 if (is_error) {
[10:34:08.217]                   sessionInformation <- function() {
[10:34:08.217]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:08.217]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:08.217]                       search = base::search(), system = base::Sys.info())
[10:34:08.217]                   }
[10:34:08.217]                   ...future.conditions[[length(...future.conditions) + 
[10:34:08.217]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:08.217]                     cond$call), session = sessionInformation(), 
[10:34:08.217]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:08.217]                   signalCondition(cond)
[10:34:08.217]                 }
[10:34:08.217]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:08.217]                 "immediateCondition"))) {
[10:34:08.217]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:08.217]                   ...future.conditions[[length(...future.conditions) + 
[10:34:08.217]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:08.217]                   if (TRUE && !signal) {
[10:34:08.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:08.217]                     {
[10:34:08.217]                       inherits <- base::inherits
[10:34:08.217]                       invokeRestart <- base::invokeRestart
[10:34:08.217]                       is.null <- base::is.null
[10:34:08.217]                       muffled <- FALSE
[10:34:08.217]                       if (inherits(cond, "message")) {
[10:34:08.217]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:08.217]                         if (muffled) 
[10:34:08.217]                           invokeRestart("muffleMessage")
[10:34:08.217]                       }
[10:34:08.217]                       else if (inherits(cond, "warning")) {
[10:34:08.217]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:08.217]                         if (muffled) 
[10:34:08.217]                           invokeRestart("muffleWarning")
[10:34:08.217]                       }
[10:34:08.217]                       else if (inherits(cond, "condition")) {
[10:34:08.217]                         if (!is.null(pattern)) {
[10:34:08.217]                           computeRestarts <- base::computeRestarts
[10:34:08.217]                           grepl <- base::grepl
[10:34:08.217]                           restarts <- computeRestarts(cond)
[10:34:08.217]                           for (restart in restarts) {
[10:34:08.217]                             name <- restart$name
[10:34:08.217]                             if (is.null(name)) 
[10:34:08.217]                               next
[10:34:08.217]                             if (!grepl(pattern, name)) 
[10:34:08.217]                               next
[10:34:08.217]                             invokeRestart(restart)
[10:34:08.217]                             muffled <- TRUE
[10:34:08.217]                             break
[10:34:08.217]                           }
[10:34:08.217]                         }
[10:34:08.217]                       }
[10:34:08.217]                       invisible(muffled)
[10:34:08.217]                     }
[10:34:08.217]                     muffleCondition(cond, pattern = "^muffle")
[10:34:08.217]                   }
[10:34:08.217]                 }
[10:34:08.217]                 else {
[10:34:08.217]                   if (TRUE) {
[10:34:08.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:08.217]                     {
[10:34:08.217]                       inherits <- base::inherits
[10:34:08.217]                       invokeRestart <- base::invokeRestart
[10:34:08.217]                       is.null <- base::is.null
[10:34:08.217]                       muffled <- FALSE
[10:34:08.217]                       if (inherits(cond, "message")) {
[10:34:08.217]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:08.217]                         if (muffled) 
[10:34:08.217]                           invokeRestart("muffleMessage")
[10:34:08.217]                       }
[10:34:08.217]                       else if (inherits(cond, "warning")) {
[10:34:08.217]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:08.217]                         if (muffled) 
[10:34:08.217]                           invokeRestart("muffleWarning")
[10:34:08.217]                       }
[10:34:08.217]                       else if (inherits(cond, "condition")) {
[10:34:08.217]                         if (!is.null(pattern)) {
[10:34:08.217]                           computeRestarts <- base::computeRestarts
[10:34:08.217]                           grepl <- base::grepl
[10:34:08.217]                           restarts <- computeRestarts(cond)
[10:34:08.217]                           for (restart in restarts) {
[10:34:08.217]                             name <- restart$name
[10:34:08.217]                             if (is.null(name)) 
[10:34:08.217]                               next
[10:34:08.217]                             if (!grepl(pattern, name)) 
[10:34:08.217]                               next
[10:34:08.217]                             invokeRestart(restart)
[10:34:08.217]                             muffled <- TRUE
[10:34:08.217]                             break
[10:34:08.217]                           }
[10:34:08.217]                         }
[10:34:08.217]                       }
[10:34:08.217]                       invisible(muffled)
[10:34:08.217]                     }
[10:34:08.217]                     muffleCondition(cond, pattern = "^muffle")
[10:34:08.217]                   }
[10:34:08.217]                 }
[10:34:08.217]             }
[10:34:08.217]         }))
[10:34:08.217]     }, error = function(ex) {
[10:34:08.217]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:08.217]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:08.217]                 ...future.rng), started = ...future.startTime, 
[10:34:08.217]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:08.217]             version = "1.8"), class = "FutureResult")
[10:34:08.217]     }, finally = {
[10:34:08.217]         if (!identical(...future.workdir, getwd())) 
[10:34:08.217]             setwd(...future.workdir)
[10:34:08.217]         {
[10:34:08.217]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:08.217]                 ...future.oldOptions$nwarnings <- NULL
[10:34:08.217]             }
[10:34:08.217]             base::options(...future.oldOptions)
[10:34:08.217]             if (.Platform$OS.type == "windows") {
[10:34:08.217]                 old_names <- names(...future.oldEnvVars)
[10:34:08.217]                 envs <- base::Sys.getenv()
[10:34:08.217]                 names <- names(envs)
[10:34:08.217]                 common <- intersect(names, old_names)
[10:34:08.217]                 added <- setdiff(names, old_names)
[10:34:08.217]                 removed <- setdiff(old_names, names)
[10:34:08.217]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:08.217]                   envs[common]]
[10:34:08.217]                 NAMES <- toupper(changed)
[10:34:08.217]                 args <- list()
[10:34:08.217]                 for (kk in seq_along(NAMES)) {
[10:34:08.217]                   name <- changed[[kk]]
[10:34:08.217]                   NAME <- NAMES[[kk]]
[10:34:08.217]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:08.217]                     next
[10:34:08.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:08.217]                 }
[10:34:08.217]                 NAMES <- toupper(added)
[10:34:08.217]                 for (kk in seq_along(NAMES)) {
[10:34:08.217]                   name <- added[[kk]]
[10:34:08.217]                   NAME <- NAMES[[kk]]
[10:34:08.217]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:08.217]                     next
[10:34:08.217]                   args[[name]] <- ""
[10:34:08.217]                 }
[10:34:08.217]                 NAMES <- toupper(removed)
[10:34:08.217]                 for (kk in seq_along(NAMES)) {
[10:34:08.217]                   name <- removed[[kk]]
[10:34:08.217]                   NAME <- NAMES[[kk]]
[10:34:08.217]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:08.217]                     next
[10:34:08.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:08.217]                 }
[10:34:08.217]                 if (length(args) > 0) 
[10:34:08.217]                   base::do.call(base::Sys.setenv, args = args)
[10:34:08.217]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:08.217]             }
[10:34:08.217]             else {
[10:34:08.217]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:08.217]             }
[10:34:08.217]             {
[10:34:08.217]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:08.217]                   0L) {
[10:34:08.217]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:08.217]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:08.217]                   base::options(opts)
[10:34:08.217]                 }
[10:34:08.217]                 {
[10:34:08.217]                   {
[10:34:08.217]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:08.217]                     NULL
[10:34:08.217]                   }
[10:34:08.217]                   options(future.plan = NULL)
[10:34:08.217]                   if (is.na(NA_character_)) 
[10:34:08.217]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:08.217]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:08.217]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:08.217]                     .init = FALSE)
[10:34:08.217]                 }
[10:34:08.217]             }
[10:34:08.217]         }
[10:34:08.217]     })
[10:34:08.217]     if (TRUE) {
[10:34:08.217]         base::sink(type = "output", split = FALSE)
[10:34:08.217]         if (TRUE) {
[10:34:08.217]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:08.217]         }
[10:34:08.217]         else {
[10:34:08.217]             ...future.result["stdout"] <- base::list(NULL)
[10:34:08.217]         }
[10:34:08.217]         base::close(...future.stdout)
[10:34:08.217]         ...future.stdout <- NULL
[10:34:08.217]     }
[10:34:08.217]     ...future.result$conditions <- ...future.conditions
[10:34:08.217]     ...future.result$finished <- base::Sys.time()
[10:34:08.217]     ...future.result
[10:34:08.217] }
[10:34:08.220] MultisessionFuture started
[10:34:08.220] - Launch lazy future ... done
[10:34:08.220] run() for ‘MultisessionFuture’ ... done
[10:34:08.222] receiveMessageFromWorker() for ClusterFuture ...
[10:34:08.222] - Validating connection of MultisessionFuture
[10:34:08.222] - received message: FutureResult
[10:34:08.222] - Received FutureResult
[10:34:08.222] - Erased future from FutureRegistry
[10:34:08.223] result() for ClusterFuture ...
[10:34:08.223] - result already collected: FutureResult
[10:34:08.223] result() for ClusterFuture ... done
[10:34:08.223] signalConditions() ...
[10:34:08.223]  - include = ‘immediateCondition’
[10:34:08.223]  - exclude = 
[10:34:08.223]  - resignal = FALSE
[10:34:08.223]  - Number of conditions: 1
[10:34:08.223] signalConditions() ... done
[10:34:08.223] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:08.223] A MultisessionFuture was resolved (result was not collected)
[10:34:08.224] getGlobalsAndPackages() ...
[10:34:08.224] Searching for globals...
[10:34:08.224] - globals found: [2] ‘list’, ‘stop’
[10:34:08.224] Searching for globals ... DONE
[10:34:08.224] Resolving globals: FALSE
[10:34:08.225] 
[10:34:08.225] 
[10:34:08.225] getGlobalsAndPackages() ... DONE
[10:34:08.225] run() for ‘Future’ ...
[10:34:08.225] - state: ‘created’
[10:34:08.225] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:08.239] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:08.239] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:08.239]   - Field: ‘node’
[10:34:08.239]   - Field: ‘label’
[10:34:08.239]   - Field: ‘local’
[10:34:08.239]   - Field: ‘owner’
[10:34:08.239]   - Field: ‘envir’
[10:34:08.240]   - Field: ‘workers’
[10:34:08.240]   - Field: ‘packages’
[10:34:08.240]   - Field: ‘gc’
[10:34:08.240]   - Field: ‘conditions’
[10:34:08.240]   - Field: ‘persistent’
[10:34:08.240]   - Field: ‘expr’
[10:34:08.240]   - Field: ‘uuid’
[10:34:08.240]   - Field: ‘seed’
[10:34:08.240]   - Field: ‘version’
[10:34:08.240]   - Field: ‘result’
[10:34:08.240]   - Field: ‘asynchronous’
[10:34:08.240]   - Field: ‘calls’
[10:34:08.241]   - Field: ‘globals’
[10:34:08.241]   - Field: ‘stdout’
[10:34:08.241]   - Field: ‘earlySignal’
[10:34:08.241]   - Field: ‘lazy’
[10:34:08.241]   - Field: ‘state’
[10:34:08.241] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:08.241] - Launch lazy future ...
[10:34:08.241] Packages needed by the future expression (n = 0): <none>
[10:34:08.242] Packages needed by future strategies (n = 0): <none>
[10:34:08.242] {
[10:34:08.242]     {
[10:34:08.242]         {
[10:34:08.242]             ...future.startTime <- base::Sys.time()
[10:34:08.242]             {
[10:34:08.242]                 {
[10:34:08.242]                   {
[10:34:08.242]                     {
[10:34:08.242]                       base::local({
[10:34:08.242]                         has_future <- base::requireNamespace("future", 
[10:34:08.242]                           quietly = TRUE)
[10:34:08.242]                         if (has_future) {
[10:34:08.242]                           ns <- base::getNamespace("future")
[10:34:08.242]                           version <- ns[[".package"]][["version"]]
[10:34:08.242]                           if (is.null(version)) 
[10:34:08.242]                             version <- utils::packageVersion("future")
[10:34:08.242]                         }
[10:34:08.242]                         else {
[10:34:08.242]                           version <- NULL
[10:34:08.242]                         }
[10:34:08.242]                         if (!has_future || version < "1.8.0") {
[10:34:08.242]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:08.242]                             "", base::R.version$version.string), 
[10:34:08.242]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:08.242]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:08.242]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:08.242]                               "release", "version")], collapse = " "), 
[10:34:08.242]                             hostname = base::Sys.info()[["nodename"]])
[10:34:08.242]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:08.242]                             info)
[10:34:08.242]                           info <- base::paste(info, collapse = "; ")
[10:34:08.242]                           if (!has_future) {
[10:34:08.242]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:08.242]                               info)
[10:34:08.242]                           }
[10:34:08.242]                           else {
[10:34:08.242]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:08.242]                               info, version)
[10:34:08.242]                           }
[10:34:08.242]                           base::stop(msg)
[10:34:08.242]                         }
[10:34:08.242]                       })
[10:34:08.242]                     }
[10:34:08.242]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:08.242]                     base::options(mc.cores = 1L)
[10:34:08.242]                   }
[10:34:08.242]                   ...future.strategy.old <- future::plan("list")
[10:34:08.242]                   options(future.plan = NULL)
[10:34:08.242]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:08.242]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:08.242]                 }
[10:34:08.242]                 ...future.workdir <- getwd()
[10:34:08.242]             }
[10:34:08.242]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:08.242]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:08.242]         }
[10:34:08.242]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:08.242]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:08.242]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:08.242]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:08.242]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:08.242]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:08.242]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:08.242]             base::names(...future.oldOptions))
[10:34:08.242]     }
[10:34:08.242]     if (FALSE) {
[10:34:08.242]     }
[10:34:08.242]     else {
[10:34:08.242]         if (TRUE) {
[10:34:08.242]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:08.242]                 open = "w")
[10:34:08.242]         }
[10:34:08.242]         else {
[10:34:08.242]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:08.242]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:08.242]         }
[10:34:08.242]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:08.242]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:08.242]             base::sink(type = "output", split = FALSE)
[10:34:08.242]             base::close(...future.stdout)
[10:34:08.242]         }, add = TRUE)
[10:34:08.242]     }
[10:34:08.242]     ...future.frame <- base::sys.nframe()
[10:34:08.242]     ...future.conditions <- base::list()
[10:34:08.242]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:08.242]     if (FALSE) {
[10:34:08.242]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:08.242]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:08.242]     }
[10:34:08.242]     ...future.result <- base::tryCatch({
[10:34:08.242]         base::withCallingHandlers({
[10:34:08.242]             ...future.value <- base::withVisible(base::local({
[10:34:08.242]                 ...future.makeSendCondition <- base::local({
[10:34:08.242]                   sendCondition <- NULL
[10:34:08.242]                   function(frame = 1L) {
[10:34:08.242]                     if (is.function(sendCondition)) 
[10:34:08.242]                       return(sendCondition)
[10:34:08.242]                     ns <- getNamespace("parallel")
[10:34:08.242]                     if (exists("sendData", mode = "function", 
[10:34:08.242]                       envir = ns)) {
[10:34:08.242]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:08.242]                         envir = ns)
[10:34:08.242]                       envir <- sys.frame(frame)
[10:34:08.242]                       master <- NULL
[10:34:08.242]                       while (!identical(envir, .GlobalEnv) && 
[10:34:08.242]                         !identical(envir, emptyenv())) {
[10:34:08.242]                         if (exists("master", mode = "list", envir = envir, 
[10:34:08.242]                           inherits = FALSE)) {
[10:34:08.242]                           master <- get("master", mode = "list", 
[10:34:08.242]                             envir = envir, inherits = FALSE)
[10:34:08.242]                           if (inherits(master, c("SOCKnode", 
[10:34:08.242]                             "SOCK0node"))) {
[10:34:08.242]                             sendCondition <<- function(cond) {
[10:34:08.242]                               data <- list(type = "VALUE", value = cond, 
[10:34:08.242]                                 success = TRUE)
[10:34:08.242]                               parallel_sendData(master, data)
[10:34:08.242]                             }
[10:34:08.242]                             return(sendCondition)
[10:34:08.242]                           }
[10:34:08.242]                         }
[10:34:08.242]                         frame <- frame + 1L
[10:34:08.242]                         envir <- sys.frame(frame)
[10:34:08.242]                       }
[10:34:08.242]                     }
[10:34:08.242]                     sendCondition <<- function(cond) NULL
[10:34:08.242]                   }
[10:34:08.242]                 })
[10:34:08.242]                 withCallingHandlers({
[10:34:08.242]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:34:08.242]                 }, immediateCondition = function(cond) {
[10:34:08.242]                   sendCondition <- ...future.makeSendCondition()
[10:34:08.242]                   sendCondition(cond)
[10:34:08.242]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:08.242]                   {
[10:34:08.242]                     inherits <- base::inherits
[10:34:08.242]                     invokeRestart <- base::invokeRestart
[10:34:08.242]                     is.null <- base::is.null
[10:34:08.242]                     muffled <- FALSE
[10:34:08.242]                     if (inherits(cond, "message")) {
[10:34:08.242]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:08.242]                       if (muffled) 
[10:34:08.242]                         invokeRestart("muffleMessage")
[10:34:08.242]                     }
[10:34:08.242]                     else if (inherits(cond, "warning")) {
[10:34:08.242]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:08.242]                       if (muffled) 
[10:34:08.242]                         invokeRestart("muffleWarning")
[10:34:08.242]                     }
[10:34:08.242]                     else if (inherits(cond, "condition")) {
[10:34:08.242]                       if (!is.null(pattern)) {
[10:34:08.242]                         computeRestarts <- base::computeRestarts
[10:34:08.242]                         grepl <- base::grepl
[10:34:08.242]                         restarts <- computeRestarts(cond)
[10:34:08.242]                         for (restart in restarts) {
[10:34:08.242]                           name <- restart$name
[10:34:08.242]                           if (is.null(name)) 
[10:34:08.242]                             next
[10:34:08.242]                           if (!grepl(pattern, name)) 
[10:34:08.242]                             next
[10:34:08.242]                           invokeRestart(restart)
[10:34:08.242]                           muffled <- TRUE
[10:34:08.242]                           break
[10:34:08.242]                         }
[10:34:08.242]                       }
[10:34:08.242]                     }
[10:34:08.242]                     invisible(muffled)
[10:34:08.242]                   }
[10:34:08.242]                   muffleCondition(cond)
[10:34:08.242]                 })
[10:34:08.242]             }))
[10:34:08.242]             future::FutureResult(value = ...future.value$value, 
[10:34:08.242]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:08.242]                   ...future.rng), globalenv = if (FALSE) 
[10:34:08.242]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:08.242]                     ...future.globalenv.names))
[10:34:08.242]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:08.242]         }, condition = base::local({
[10:34:08.242]             c <- base::c
[10:34:08.242]             inherits <- base::inherits
[10:34:08.242]             invokeRestart <- base::invokeRestart
[10:34:08.242]             length <- base::length
[10:34:08.242]             list <- base::list
[10:34:08.242]             seq.int <- base::seq.int
[10:34:08.242]             signalCondition <- base::signalCondition
[10:34:08.242]             sys.calls <- base::sys.calls
[10:34:08.242]             `[[` <- base::`[[`
[10:34:08.242]             `+` <- base::`+`
[10:34:08.242]             `<<-` <- base::`<<-`
[10:34:08.242]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:08.242]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:08.242]                   3L)]
[10:34:08.242]             }
[10:34:08.242]             function(cond) {
[10:34:08.242]                 is_error <- inherits(cond, "error")
[10:34:08.242]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:08.242]                   NULL)
[10:34:08.242]                 if (is_error) {
[10:34:08.242]                   sessionInformation <- function() {
[10:34:08.242]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:08.242]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:08.242]                       search = base::search(), system = base::Sys.info())
[10:34:08.242]                   }
[10:34:08.242]                   ...future.conditions[[length(...future.conditions) + 
[10:34:08.242]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:08.242]                     cond$call), session = sessionInformation(), 
[10:34:08.242]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:08.242]                   signalCondition(cond)
[10:34:08.242]                 }
[10:34:08.242]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:08.242]                 "immediateCondition"))) {
[10:34:08.242]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:08.242]                   ...future.conditions[[length(...future.conditions) + 
[10:34:08.242]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:08.242]                   if (TRUE && !signal) {
[10:34:08.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:08.242]                     {
[10:34:08.242]                       inherits <- base::inherits
[10:34:08.242]                       invokeRestart <- base::invokeRestart
[10:34:08.242]                       is.null <- base::is.null
[10:34:08.242]                       muffled <- FALSE
[10:34:08.242]                       if (inherits(cond, "message")) {
[10:34:08.242]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:08.242]                         if (muffled) 
[10:34:08.242]                           invokeRestart("muffleMessage")
[10:34:08.242]                       }
[10:34:08.242]                       else if (inherits(cond, "warning")) {
[10:34:08.242]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:08.242]                         if (muffled) 
[10:34:08.242]                           invokeRestart("muffleWarning")
[10:34:08.242]                       }
[10:34:08.242]                       else if (inherits(cond, "condition")) {
[10:34:08.242]                         if (!is.null(pattern)) {
[10:34:08.242]                           computeRestarts <- base::computeRestarts
[10:34:08.242]                           grepl <- base::grepl
[10:34:08.242]                           restarts <- computeRestarts(cond)
[10:34:08.242]                           for (restart in restarts) {
[10:34:08.242]                             name <- restart$name
[10:34:08.242]                             if (is.null(name)) 
[10:34:08.242]                               next
[10:34:08.242]                             if (!grepl(pattern, name)) 
[10:34:08.242]                               next
[10:34:08.242]                             invokeRestart(restart)
[10:34:08.242]                             muffled <- TRUE
[10:34:08.242]                             break
[10:34:08.242]                           }
[10:34:08.242]                         }
[10:34:08.242]                       }
[10:34:08.242]                       invisible(muffled)
[10:34:08.242]                     }
[10:34:08.242]                     muffleCondition(cond, pattern = "^muffle")
[10:34:08.242]                   }
[10:34:08.242]                 }
[10:34:08.242]                 else {
[10:34:08.242]                   if (TRUE) {
[10:34:08.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:08.242]                     {
[10:34:08.242]                       inherits <- base::inherits
[10:34:08.242]                       invokeRestart <- base::invokeRestart
[10:34:08.242]                       is.null <- base::is.null
[10:34:08.242]                       muffled <- FALSE
[10:34:08.242]                       if (inherits(cond, "message")) {
[10:34:08.242]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:08.242]                         if (muffled) 
[10:34:08.242]                           invokeRestart("muffleMessage")
[10:34:08.242]                       }
[10:34:08.242]                       else if (inherits(cond, "warning")) {
[10:34:08.242]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:08.242]                         if (muffled) 
[10:34:08.242]                           invokeRestart("muffleWarning")
[10:34:08.242]                       }
[10:34:08.242]                       else if (inherits(cond, "condition")) {
[10:34:08.242]                         if (!is.null(pattern)) {
[10:34:08.242]                           computeRestarts <- base::computeRestarts
[10:34:08.242]                           grepl <- base::grepl
[10:34:08.242]                           restarts <- computeRestarts(cond)
[10:34:08.242]                           for (restart in restarts) {
[10:34:08.242]                             name <- restart$name
[10:34:08.242]                             if (is.null(name)) 
[10:34:08.242]                               next
[10:34:08.242]                             if (!grepl(pattern, name)) 
[10:34:08.242]                               next
[10:34:08.242]                             invokeRestart(restart)
[10:34:08.242]                             muffled <- TRUE
[10:34:08.242]                             break
[10:34:08.242]                           }
[10:34:08.242]                         }
[10:34:08.242]                       }
[10:34:08.242]                       invisible(muffled)
[10:34:08.242]                     }
[10:34:08.242]                     muffleCondition(cond, pattern = "^muffle")
[10:34:08.242]                   }
[10:34:08.242]                 }
[10:34:08.242]             }
[10:34:08.242]         }))
[10:34:08.242]     }, error = function(ex) {
[10:34:08.242]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:08.242]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:08.242]                 ...future.rng), started = ...future.startTime, 
[10:34:08.242]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:08.242]             version = "1.8"), class = "FutureResult")
[10:34:08.242]     }, finally = {
[10:34:08.242]         if (!identical(...future.workdir, getwd())) 
[10:34:08.242]             setwd(...future.workdir)
[10:34:08.242]         {
[10:34:08.242]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:08.242]                 ...future.oldOptions$nwarnings <- NULL
[10:34:08.242]             }
[10:34:08.242]             base::options(...future.oldOptions)
[10:34:08.242]             if (.Platform$OS.type == "windows") {
[10:34:08.242]                 old_names <- names(...future.oldEnvVars)
[10:34:08.242]                 envs <- base::Sys.getenv()
[10:34:08.242]                 names <- names(envs)
[10:34:08.242]                 common <- intersect(names, old_names)
[10:34:08.242]                 added <- setdiff(names, old_names)
[10:34:08.242]                 removed <- setdiff(old_names, names)
[10:34:08.242]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:08.242]                   envs[common]]
[10:34:08.242]                 NAMES <- toupper(changed)
[10:34:08.242]                 args <- list()
[10:34:08.242]                 for (kk in seq_along(NAMES)) {
[10:34:08.242]                   name <- changed[[kk]]
[10:34:08.242]                   NAME <- NAMES[[kk]]
[10:34:08.242]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:08.242]                     next
[10:34:08.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:08.242]                 }
[10:34:08.242]                 NAMES <- toupper(added)
[10:34:08.242]                 for (kk in seq_along(NAMES)) {
[10:34:08.242]                   name <- added[[kk]]
[10:34:08.242]                   NAME <- NAMES[[kk]]
[10:34:08.242]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:08.242]                     next
[10:34:08.242]                   args[[name]] <- ""
[10:34:08.242]                 }
[10:34:08.242]                 NAMES <- toupper(removed)
[10:34:08.242]                 for (kk in seq_along(NAMES)) {
[10:34:08.242]                   name <- removed[[kk]]
[10:34:08.242]                   NAME <- NAMES[[kk]]
[10:34:08.242]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:08.242]                     next
[10:34:08.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:08.242]                 }
[10:34:08.242]                 if (length(args) > 0) 
[10:34:08.242]                   base::do.call(base::Sys.setenv, args = args)
[10:34:08.242]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:08.242]             }
[10:34:08.242]             else {
[10:34:08.242]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:08.242]             }
[10:34:08.242]             {
[10:34:08.242]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:08.242]                   0L) {
[10:34:08.242]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:08.242]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:08.242]                   base::options(opts)
[10:34:08.242]                 }
[10:34:08.242]                 {
[10:34:08.242]                   {
[10:34:08.242]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:08.242]                     NULL
[10:34:08.242]                   }
[10:34:08.242]                   options(future.plan = NULL)
[10:34:08.242]                   if (is.na(NA_character_)) 
[10:34:08.242]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:08.242]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:08.242]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:08.242]                     .init = FALSE)
[10:34:08.242]                 }
[10:34:08.242]             }
[10:34:08.242]         }
[10:34:08.242]     })
[10:34:08.242]     if (TRUE) {
[10:34:08.242]         base::sink(type = "output", split = FALSE)
[10:34:08.242]         if (TRUE) {
[10:34:08.242]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:08.242]         }
[10:34:08.242]         else {
[10:34:08.242]             ...future.result["stdout"] <- base::list(NULL)
[10:34:08.242]         }
[10:34:08.242]         base::close(...future.stdout)
[10:34:08.242]         ...future.stdout <- NULL
[10:34:08.242]     }
[10:34:08.242]     ...future.result$conditions <- ...future.conditions
[10:34:08.242]     ...future.result$finished <- base::Sys.time()
[10:34:08.242]     ...future.result
[10:34:08.242] }
[10:34:08.245] MultisessionFuture started
[10:34:08.245] - Launch lazy future ... done
[10:34:08.245] run() for ‘MultisessionFuture’ ... done
[10:34:08.246] receiveMessageFromWorker() for ClusterFuture ...
[10:34:08.247] - Validating connection of MultisessionFuture
[10:34:08.247] - received message: FutureResult
[10:34:08.247] - Received FutureResult
[10:34:08.247] - Erased future from FutureRegistry
[10:34:08.247] result() for ClusterFuture ...
[10:34:08.247] - result already collected: FutureResult
[10:34:08.247] result() for ClusterFuture ... done
[10:34:08.247] signalConditions() ...
[10:34:08.248]  - include = ‘immediateCondition’
[10:34:08.248]  - exclude = 
[10:34:08.248]  - resignal = FALSE
[10:34:08.248]  - Number of conditions: 1
[10:34:08.248] signalConditions() ... done
[10:34:08.248] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:08.248] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 2 ... DONE
- result = FALSE, recursive = Inf ...
[10:34:08.248] getGlobalsAndPackages() ...
[10:34:08.248] Searching for globals...
[10:34:08.250] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:34:08.250] Searching for globals ... DONE
[10:34:08.250] Resolving globals: FALSE
[10:34:08.250] 
[10:34:08.250] 
[10:34:08.250] getGlobalsAndPackages() ... DONE
[10:34:08.250] run() for ‘Future’ ...
[10:34:08.251] - state: ‘created’
[10:34:08.251] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:08.264] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:08.264] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:08.264]   - Field: ‘node’
[10:34:08.264]   - Field: ‘label’
[10:34:08.264]   - Field: ‘local’
[10:34:08.265]   - Field: ‘owner’
[10:34:08.265]   - Field: ‘envir’
[10:34:08.265]   - Field: ‘workers’
[10:34:08.265]   - Field: ‘packages’
[10:34:08.265]   - Field: ‘gc’
[10:34:08.265]   - Field: ‘conditions’
[10:34:08.265]   - Field: ‘persistent’
[10:34:08.265]   - Field: ‘expr’
[10:34:08.265]   - Field: ‘uuid’
[10:34:08.265]   - Field: ‘seed’
[10:34:08.266]   - Field: ‘version’
[10:34:08.266]   - Field: ‘result’
[10:34:08.266]   - Field: ‘asynchronous’
[10:34:08.266]   - Field: ‘calls’
[10:34:08.266]   - Field: ‘globals’
[10:34:08.266]   - Field: ‘stdout’
[10:34:08.266]   - Field: ‘earlySignal’
[10:34:08.266]   - Field: ‘lazy’
[10:34:08.266]   - Field: ‘state’
[10:34:08.266] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:08.266] - Launch lazy future ...
[10:34:08.267] Packages needed by the future expression (n = 0): <none>
[10:34:08.267] Packages needed by future strategies (n = 0): <none>
[10:34:08.267] {
[10:34:08.267]     {
[10:34:08.267]         {
[10:34:08.267]             ...future.startTime <- base::Sys.time()
[10:34:08.267]             {
[10:34:08.267]                 {
[10:34:08.267]                   {
[10:34:08.267]                     {
[10:34:08.267]                       base::local({
[10:34:08.267]                         has_future <- base::requireNamespace("future", 
[10:34:08.267]                           quietly = TRUE)
[10:34:08.267]                         if (has_future) {
[10:34:08.267]                           ns <- base::getNamespace("future")
[10:34:08.267]                           version <- ns[[".package"]][["version"]]
[10:34:08.267]                           if (is.null(version)) 
[10:34:08.267]                             version <- utils::packageVersion("future")
[10:34:08.267]                         }
[10:34:08.267]                         else {
[10:34:08.267]                           version <- NULL
[10:34:08.267]                         }
[10:34:08.267]                         if (!has_future || version < "1.8.0") {
[10:34:08.267]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:08.267]                             "", base::R.version$version.string), 
[10:34:08.267]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:08.267]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:08.267]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:08.267]                               "release", "version")], collapse = " "), 
[10:34:08.267]                             hostname = base::Sys.info()[["nodename"]])
[10:34:08.267]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:08.267]                             info)
[10:34:08.267]                           info <- base::paste(info, collapse = "; ")
[10:34:08.267]                           if (!has_future) {
[10:34:08.267]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:08.267]                               info)
[10:34:08.267]                           }
[10:34:08.267]                           else {
[10:34:08.267]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:08.267]                               info, version)
[10:34:08.267]                           }
[10:34:08.267]                           base::stop(msg)
[10:34:08.267]                         }
[10:34:08.267]                       })
[10:34:08.267]                     }
[10:34:08.267]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:08.267]                     base::options(mc.cores = 1L)
[10:34:08.267]                   }
[10:34:08.267]                   ...future.strategy.old <- future::plan("list")
[10:34:08.267]                   options(future.plan = NULL)
[10:34:08.267]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:08.267]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:08.267]                 }
[10:34:08.267]                 ...future.workdir <- getwd()
[10:34:08.267]             }
[10:34:08.267]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:08.267]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:08.267]         }
[10:34:08.267]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:08.267]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:08.267]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:08.267]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:08.267]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:08.267]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:08.267]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:08.267]             base::names(...future.oldOptions))
[10:34:08.267]     }
[10:34:08.267]     if (FALSE) {
[10:34:08.267]     }
[10:34:08.267]     else {
[10:34:08.267]         if (TRUE) {
[10:34:08.267]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:08.267]                 open = "w")
[10:34:08.267]         }
[10:34:08.267]         else {
[10:34:08.267]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:08.267]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:08.267]         }
[10:34:08.267]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:08.267]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:08.267]             base::sink(type = "output", split = FALSE)
[10:34:08.267]             base::close(...future.stdout)
[10:34:08.267]         }, add = TRUE)
[10:34:08.267]     }
[10:34:08.267]     ...future.frame <- base::sys.nframe()
[10:34:08.267]     ...future.conditions <- base::list()
[10:34:08.267]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:08.267]     if (FALSE) {
[10:34:08.267]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:08.267]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:08.267]     }
[10:34:08.267]     ...future.result <- base::tryCatch({
[10:34:08.267]         base::withCallingHandlers({
[10:34:08.267]             ...future.value <- base::withVisible(base::local({
[10:34:08.267]                 ...future.makeSendCondition <- base::local({
[10:34:08.267]                   sendCondition <- NULL
[10:34:08.267]                   function(frame = 1L) {
[10:34:08.267]                     if (is.function(sendCondition)) 
[10:34:08.267]                       return(sendCondition)
[10:34:08.267]                     ns <- getNamespace("parallel")
[10:34:08.267]                     if (exists("sendData", mode = "function", 
[10:34:08.267]                       envir = ns)) {
[10:34:08.267]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:08.267]                         envir = ns)
[10:34:08.267]                       envir <- sys.frame(frame)
[10:34:08.267]                       master <- NULL
[10:34:08.267]                       while (!identical(envir, .GlobalEnv) && 
[10:34:08.267]                         !identical(envir, emptyenv())) {
[10:34:08.267]                         if (exists("master", mode = "list", envir = envir, 
[10:34:08.267]                           inherits = FALSE)) {
[10:34:08.267]                           master <- get("master", mode = "list", 
[10:34:08.267]                             envir = envir, inherits = FALSE)
[10:34:08.267]                           if (inherits(master, c("SOCKnode", 
[10:34:08.267]                             "SOCK0node"))) {
[10:34:08.267]                             sendCondition <<- function(cond) {
[10:34:08.267]                               data <- list(type = "VALUE", value = cond, 
[10:34:08.267]                                 success = TRUE)
[10:34:08.267]                               parallel_sendData(master, data)
[10:34:08.267]                             }
[10:34:08.267]                             return(sendCondition)
[10:34:08.267]                           }
[10:34:08.267]                         }
[10:34:08.267]                         frame <- frame + 1L
[10:34:08.267]                         envir <- sys.frame(frame)
[10:34:08.267]                       }
[10:34:08.267]                     }
[10:34:08.267]                     sendCondition <<- function(cond) NULL
[10:34:08.267]                   }
[10:34:08.267]                 })
[10:34:08.267]                 withCallingHandlers({
[10:34:08.267]                   {
[10:34:08.267]                     Sys.sleep(0.5)
[10:34:08.267]                     list(a = 1, b = 42L)
[10:34:08.267]                   }
[10:34:08.267]                 }, immediateCondition = function(cond) {
[10:34:08.267]                   sendCondition <- ...future.makeSendCondition()
[10:34:08.267]                   sendCondition(cond)
[10:34:08.267]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:08.267]                   {
[10:34:08.267]                     inherits <- base::inherits
[10:34:08.267]                     invokeRestart <- base::invokeRestart
[10:34:08.267]                     is.null <- base::is.null
[10:34:08.267]                     muffled <- FALSE
[10:34:08.267]                     if (inherits(cond, "message")) {
[10:34:08.267]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:08.267]                       if (muffled) 
[10:34:08.267]                         invokeRestart("muffleMessage")
[10:34:08.267]                     }
[10:34:08.267]                     else if (inherits(cond, "warning")) {
[10:34:08.267]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:08.267]                       if (muffled) 
[10:34:08.267]                         invokeRestart("muffleWarning")
[10:34:08.267]                     }
[10:34:08.267]                     else if (inherits(cond, "condition")) {
[10:34:08.267]                       if (!is.null(pattern)) {
[10:34:08.267]                         computeRestarts <- base::computeRestarts
[10:34:08.267]                         grepl <- base::grepl
[10:34:08.267]                         restarts <- computeRestarts(cond)
[10:34:08.267]                         for (restart in restarts) {
[10:34:08.267]                           name <- restart$name
[10:34:08.267]                           if (is.null(name)) 
[10:34:08.267]                             next
[10:34:08.267]                           if (!grepl(pattern, name)) 
[10:34:08.267]                             next
[10:34:08.267]                           invokeRestart(restart)
[10:34:08.267]                           muffled <- TRUE
[10:34:08.267]                           break
[10:34:08.267]                         }
[10:34:08.267]                       }
[10:34:08.267]                     }
[10:34:08.267]                     invisible(muffled)
[10:34:08.267]                   }
[10:34:08.267]                   muffleCondition(cond)
[10:34:08.267]                 })
[10:34:08.267]             }))
[10:34:08.267]             future::FutureResult(value = ...future.value$value, 
[10:34:08.267]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:08.267]                   ...future.rng), globalenv = if (FALSE) 
[10:34:08.267]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:08.267]                     ...future.globalenv.names))
[10:34:08.267]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:08.267]         }, condition = base::local({
[10:34:08.267]             c <- base::c
[10:34:08.267]             inherits <- base::inherits
[10:34:08.267]             invokeRestart <- base::invokeRestart
[10:34:08.267]             length <- base::length
[10:34:08.267]             list <- base::list
[10:34:08.267]             seq.int <- base::seq.int
[10:34:08.267]             signalCondition <- base::signalCondition
[10:34:08.267]             sys.calls <- base::sys.calls
[10:34:08.267]             `[[` <- base::`[[`
[10:34:08.267]             `+` <- base::`+`
[10:34:08.267]             `<<-` <- base::`<<-`
[10:34:08.267]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:08.267]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:08.267]                   3L)]
[10:34:08.267]             }
[10:34:08.267]             function(cond) {
[10:34:08.267]                 is_error <- inherits(cond, "error")
[10:34:08.267]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:08.267]                   NULL)
[10:34:08.267]                 if (is_error) {
[10:34:08.267]                   sessionInformation <- function() {
[10:34:08.267]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:08.267]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:08.267]                       search = base::search(), system = base::Sys.info())
[10:34:08.267]                   }
[10:34:08.267]                   ...future.conditions[[length(...future.conditions) + 
[10:34:08.267]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:08.267]                     cond$call), session = sessionInformation(), 
[10:34:08.267]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:08.267]                   signalCondition(cond)
[10:34:08.267]                 }
[10:34:08.267]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:08.267]                 "immediateCondition"))) {
[10:34:08.267]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:08.267]                   ...future.conditions[[length(...future.conditions) + 
[10:34:08.267]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:08.267]                   if (TRUE && !signal) {
[10:34:08.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:08.267]                     {
[10:34:08.267]                       inherits <- base::inherits
[10:34:08.267]                       invokeRestart <- base::invokeRestart
[10:34:08.267]                       is.null <- base::is.null
[10:34:08.267]                       muffled <- FALSE
[10:34:08.267]                       if (inherits(cond, "message")) {
[10:34:08.267]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:08.267]                         if (muffled) 
[10:34:08.267]                           invokeRestart("muffleMessage")
[10:34:08.267]                       }
[10:34:08.267]                       else if (inherits(cond, "warning")) {
[10:34:08.267]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:08.267]                         if (muffled) 
[10:34:08.267]                           invokeRestart("muffleWarning")
[10:34:08.267]                       }
[10:34:08.267]                       else if (inherits(cond, "condition")) {
[10:34:08.267]                         if (!is.null(pattern)) {
[10:34:08.267]                           computeRestarts <- base::computeRestarts
[10:34:08.267]                           grepl <- base::grepl
[10:34:08.267]                           restarts <- computeRestarts(cond)
[10:34:08.267]                           for (restart in restarts) {
[10:34:08.267]                             name <- restart$name
[10:34:08.267]                             if (is.null(name)) 
[10:34:08.267]                               next
[10:34:08.267]                             if (!grepl(pattern, name)) 
[10:34:08.267]                               next
[10:34:08.267]                             invokeRestart(restart)
[10:34:08.267]                             muffled <- TRUE
[10:34:08.267]                             break
[10:34:08.267]                           }
[10:34:08.267]                         }
[10:34:08.267]                       }
[10:34:08.267]                       invisible(muffled)
[10:34:08.267]                     }
[10:34:08.267]                     muffleCondition(cond, pattern = "^muffle")
[10:34:08.267]                   }
[10:34:08.267]                 }
[10:34:08.267]                 else {
[10:34:08.267]                   if (TRUE) {
[10:34:08.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:08.267]                     {
[10:34:08.267]                       inherits <- base::inherits
[10:34:08.267]                       invokeRestart <- base::invokeRestart
[10:34:08.267]                       is.null <- base::is.null
[10:34:08.267]                       muffled <- FALSE
[10:34:08.267]                       if (inherits(cond, "message")) {
[10:34:08.267]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:08.267]                         if (muffled) 
[10:34:08.267]                           invokeRestart("muffleMessage")
[10:34:08.267]                       }
[10:34:08.267]                       else if (inherits(cond, "warning")) {
[10:34:08.267]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:08.267]                         if (muffled) 
[10:34:08.267]                           invokeRestart("muffleWarning")
[10:34:08.267]                       }
[10:34:08.267]                       else if (inherits(cond, "condition")) {
[10:34:08.267]                         if (!is.null(pattern)) {
[10:34:08.267]                           computeRestarts <- base::computeRestarts
[10:34:08.267]                           grepl <- base::grepl
[10:34:08.267]                           restarts <- computeRestarts(cond)
[10:34:08.267]                           for (restart in restarts) {
[10:34:08.267]                             name <- restart$name
[10:34:08.267]                             if (is.null(name)) 
[10:34:08.267]                               next
[10:34:08.267]                             if (!grepl(pattern, name)) 
[10:34:08.267]                               next
[10:34:08.267]                             invokeRestart(restart)
[10:34:08.267]                             muffled <- TRUE
[10:34:08.267]                             break
[10:34:08.267]                           }
[10:34:08.267]                         }
[10:34:08.267]                       }
[10:34:08.267]                       invisible(muffled)
[10:34:08.267]                     }
[10:34:08.267]                     muffleCondition(cond, pattern = "^muffle")
[10:34:08.267]                   }
[10:34:08.267]                 }
[10:34:08.267]             }
[10:34:08.267]         }))
[10:34:08.267]     }, error = function(ex) {
[10:34:08.267]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:08.267]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:08.267]                 ...future.rng), started = ...future.startTime, 
[10:34:08.267]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:08.267]             version = "1.8"), class = "FutureResult")
[10:34:08.267]     }, finally = {
[10:34:08.267]         if (!identical(...future.workdir, getwd())) 
[10:34:08.267]             setwd(...future.workdir)
[10:34:08.267]         {
[10:34:08.267]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:08.267]                 ...future.oldOptions$nwarnings <- NULL
[10:34:08.267]             }
[10:34:08.267]             base::options(...future.oldOptions)
[10:34:08.267]             if (.Platform$OS.type == "windows") {
[10:34:08.267]                 old_names <- names(...future.oldEnvVars)
[10:34:08.267]                 envs <- base::Sys.getenv()
[10:34:08.267]                 names <- names(envs)
[10:34:08.267]                 common <- intersect(names, old_names)
[10:34:08.267]                 added <- setdiff(names, old_names)
[10:34:08.267]                 removed <- setdiff(old_names, names)
[10:34:08.267]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:08.267]                   envs[common]]
[10:34:08.267]                 NAMES <- toupper(changed)
[10:34:08.267]                 args <- list()
[10:34:08.267]                 for (kk in seq_along(NAMES)) {
[10:34:08.267]                   name <- changed[[kk]]
[10:34:08.267]                   NAME <- NAMES[[kk]]
[10:34:08.267]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:08.267]                     next
[10:34:08.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:08.267]                 }
[10:34:08.267]                 NAMES <- toupper(added)
[10:34:08.267]                 for (kk in seq_along(NAMES)) {
[10:34:08.267]                   name <- added[[kk]]
[10:34:08.267]                   NAME <- NAMES[[kk]]
[10:34:08.267]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:08.267]                     next
[10:34:08.267]                   args[[name]] <- ""
[10:34:08.267]                 }
[10:34:08.267]                 NAMES <- toupper(removed)
[10:34:08.267]                 for (kk in seq_along(NAMES)) {
[10:34:08.267]                   name <- removed[[kk]]
[10:34:08.267]                   NAME <- NAMES[[kk]]
[10:34:08.267]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:08.267]                     next
[10:34:08.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:08.267]                 }
[10:34:08.267]                 if (length(args) > 0) 
[10:34:08.267]                   base::do.call(base::Sys.setenv, args = args)
[10:34:08.267]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:08.267]             }
[10:34:08.267]             else {
[10:34:08.267]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:08.267]             }
[10:34:08.267]             {
[10:34:08.267]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:08.267]                   0L) {
[10:34:08.267]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:08.267]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:08.267]                   base::options(opts)
[10:34:08.267]                 }
[10:34:08.267]                 {
[10:34:08.267]                   {
[10:34:08.267]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:08.267]                     NULL
[10:34:08.267]                   }
[10:34:08.267]                   options(future.plan = NULL)
[10:34:08.267]                   if (is.na(NA_character_)) 
[10:34:08.267]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:08.267]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:08.267]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:08.267]                     .init = FALSE)
[10:34:08.267]                 }
[10:34:08.267]             }
[10:34:08.267]         }
[10:34:08.267]     })
[10:34:08.267]     if (TRUE) {
[10:34:08.267]         base::sink(type = "output", split = FALSE)
[10:34:08.267]         if (TRUE) {
[10:34:08.267]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:08.267]         }
[10:34:08.267]         else {
[10:34:08.267]             ...future.result["stdout"] <- base::list(NULL)
[10:34:08.267]         }
[10:34:08.267]         base::close(...future.stdout)
[10:34:08.267]         ...future.stdout <- NULL
[10:34:08.267]     }
[10:34:08.267]     ...future.result$conditions <- ...future.conditions
[10:34:08.267]     ...future.result$finished <- base::Sys.time()
[10:34:08.267]     ...future.result
[10:34:08.267] }
[10:34:08.270] MultisessionFuture started
[10:34:08.270] - Launch lazy future ... done
[10:34:08.270] run() for ‘MultisessionFuture’ ... done
[10:34:08.772] receiveMessageFromWorker() for ClusterFuture ...
[10:34:08.772] - Validating connection of MultisessionFuture
[10:34:08.773] - received message: FutureResult
[10:34:08.773] - Received FutureResult
[10:34:08.773] - Erased future from FutureRegistry
[10:34:08.773] result() for ClusterFuture ...
[10:34:08.773] - result already collected: FutureResult
[10:34:08.773] result() for ClusterFuture ... done
[10:34:08.773] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:08.773] A MultisessionFuture was resolved (result was not collected)
[10:34:08.774] getGlobalsAndPackages() ...
[10:34:08.774] Searching for globals...
[10:34:08.775] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:34:08.775] Searching for globals ... DONE
[10:34:08.775] Resolving globals: FALSE
[10:34:08.775] 
[10:34:08.775] 
[10:34:08.776] getGlobalsAndPackages() ... DONE
[10:34:08.776] run() for ‘Future’ ...
[10:34:08.776] - state: ‘created’
[10:34:08.776] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:08.790] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:08.790] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:08.790]   - Field: ‘node’
[10:34:08.790]   - Field: ‘label’
[10:34:08.790]   - Field: ‘local’
[10:34:08.790]   - Field: ‘owner’
[10:34:08.791]   - Field: ‘envir’
[10:34:08.791]   - Field: ‘workers’
[10:34:08.791]   - Field: ‘packages’
[10:34:08.791]   - Field: ‘gc’
[10:34:08.791]   - Field: ‘conditions’
[10:34:08.791]   - Field: ‘persistent’
[10:34:08.791]   - Field: ‘expr’
[10:34:08.791]   - Field: ‘uuid’
[10:34:08.791]   - Field: ‘seed’
[10:34:08.791]   - Field: ‘version’
[10:34:08.791]   - Field: ‘result’
[10:34:08.792]   - Field: ‘asynchronous’
[10:34:08.792]   - Field: ‘calls’
[10:34:08.792]   - Field: ‘globals’
[10:34:08.792]   - Field: ‘stdout’
[10:34:08.792]   - Field: ‘earlySignal’
[10:34:08.792]   - Field: ‘lazy’
[10:34:08.792]   - Field: ‘state’
[10:34:08.792] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:08.792] - Launch lazy future ...
[10:34:08.792] Packages needed by the future expression (n = 0): <none>
[10:34:08.793] Packages needed by future strategies (n = 0): <none>
[10:34:08.793] {
[10:34:08.793]     {
[10:34:08.793]         {
[10:34:08.793]             ...future.startTime <- base::Sys.time()
[10:34:08.793]             {
[10:34:08.793]                 {
[10:34:08.793]                   {
[10:34:08.793]                     {
[10:34:08.793]                       base::local({
[10:34:08.793]                         has_future <- base::requireNamespace("future", 
[10:34:08.793]                           quietly = TRUE)
[10:34:08.793]                         if (has_future) {
[10:34:08.793]                           ns <- base::getNamespace("future")
[10:34:08.793]                           version <- ns[[".package"]][["version"]]
[10:34:08.793]                           if (is.null(version)) 
[10:34:08.793]                             version <- utils::packageVersion("future")
[10:34:08.793]                         }
[10:34:08.793]                         else {
[10:34:08.793]                           version <- NULL
[10:34:08.793]                         }
[10:34:08.793]                         if (!has_future || version < "1.8.0") {
[10:34:08.793]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:08.793]                             "", base::R.version$version.string), 
[10:34:08.793]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:08.793]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:08.793]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:08.793]                               "release", "version")], collapse = " "), 
[10:34:08.793]                             hostname = base::Sys.info()[["nodename"]])
[10:34:08.793]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:08.793]                             info)
[10:34:08.793]                           info <- base::paste(info, collapse = "; ")
[10:34:08.793]                           if (!has_future) {
[10:34:08.793]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:08.793]                               info)
[10:34:08.793]                           }
[10:34:08.793]                           else {
[10:34:08.793]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:08.793]                               info, version)
[10:34:08.793]                           }
[10:34:08.793]                           base::stop(msg)
[10:34:08.793]                         }
[10:34:08.793]                       })
[10:34:08.793]                     }
[10:34:08.793]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:08.793]                     base::options(mc.cores = 1L)
[10:34:08.793]                   }
[10:34:08.793]                   ...future.strategy.old <- future::plan("list")
[10:34:08.793]                   options(future.plan = NULL)
[10:34:08.793]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:08.793]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:08.793]                 }
[10:34:08.793]                 ...future.workdir <- getwd()
[10:34:08.793]             }
[10:34:08.793]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:08.793]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:08.793]         }
[10:34:08.793]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:08.793]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:08.793]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:08.793]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:08.793]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:08.793]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:08.793]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:08.793]             base::names(...future.oldOptions))
[10:34:08.793]     }
[10:34:08.793]     if (FALSE) {
[10:34:08.793]     }
[10:34:08.793]     else {
[10:34:08.793]         if (TRUE) {
[10:34:08.793]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:08.793]                 open = "w")
[10:34:08.793]         }
[10:34:08.793]         else {
[10:34:08.793]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:08.793]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:08.793]         }
[10:34:08.793]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:08.793]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:08.793]             base::sink(type = "output", split = FALSE)
[10:34:08.793]             base::close(...future.stdout)
[10:34:08.793]         }, add = TRUE)
[10:34:08.793]     }
[10:34:08.793]     ...future.frame <- base::sys.nframe()
[10:34:08.793]     ...future.conditions <- base::list()
[10:34:08.793]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:08.793]     if (FALSE) {
[10:34:08.793]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:08.793]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:08.793]     }
[10:34:08.793]     ...future.result <- base::tryCatch({
[10:34:08.793]         base::withCallingHandlers({
[10:34:08.793]             ...future.value <- base::withVisible(base::local({
[10:34:08.793]                 ...future.makeSendCondition <- base::local({
[10:34:08.793]                   sendCondition <- NULL
[10:34:08.793]                   function(frame = 1L) {
[10:34:08.793]                     if (is.function(sendCondition)) 
[10:34:08.793]                       return(sendCondition)
[10:34:08.793]                     ns <- getNamespace("parallel")
[10:34:08.793]                     if (exists("sendData", mode = "function", 
[10:34:08.793]                       envir = ns)) {
[10:34:08.793]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:08.793]                         envir = ns)
[10:34:08.793]                       envir <- sys.frame(frame)
[10:34:08.793]                       master <- NULL
[10:34:08.793]                       while (!identical(envir, .GlobalEnv) && 
[10:34:08.793]                         !identical(envir, emptyenv())) {
[10:34:08.793]                         if (exists("master", mode = "list", envir = envir, 
[10:34:08.793]                           inherits = FALSE)) {
[10:34:08.793]                           master <- get("master", mode = "list", 
[10:34:08.793]                             envir = envir, inherits = FALSE)
[10:34:08.793]                           if (inherits(master, c("SOCKnode", 
[10:34:08.793]                             "SOCK0node"))) {
[10:34:08.793]                             sendCondition <<- function(cond) {
[10:34:08.793]                               data <- list(type = "VALUE", value = cond, 
[10:34:08.793]                                 success = TRUE)
[10:34:08.793]                               parallel_sendData(master, data)
[10:34:08.793]                             }
[10:34:08.793]                             return(sendCondition)
[10:34:08.793]                           }
[10:34:08.793]                         }
[10:34:08.793]                         frame <- frame + 1L
[10:34:08.793]                         envir <- sys.frame(frame)
[10:34:08.793]                       }
[10:34:08.793]                     }
[10:34:08.793]                     sendCondition <<- function(cond) NULL
[10:34:08.793]                   }
[10:34:08.793]                 })
[10:34:08.793]                 withCallingHandlers({
[10:34:08.793]                   {
[10:34:08.793]                     Sys.sleep(0.5)
[10:34:08.793]                     list(a = 1, b = 42L)
[10:34:08.793]                   }
[10:34:08.793]                 }, immediateCondition = function(cond) {
[10:34:08.793]                   sendCondition <- ...future.makeSendCondition()
[10:34:08.793]                   sendCondition(cond)
[10:34:08.793]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:08.793]                   {
[10:34:08.793]                     inherits <- base::inherits
[10:34:08.793]                     invokeRestart <- base::invokeRestart
[10:34:08.793]                     is.null <- base::is.null
[10:34:08.793]                     muffled <- FALSE
[10:34:08.793]                     if (inherits(cond, "message")) {
[10:34:08.793]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:08.793]                       if (muffled) 
[10:34:08.793]                         invokeRestart("muffleMessage")
[10:34:08.793]                     }
[10:34:08.793]                     else if (inherits(cond, "warning")) {
[10:34:08.793]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:08.793]                       if (muffled) 
[10:34:08.793]                         invokeRestart("muffleWarning")
[10:34:08.793]                     }
[10:34:08.793]                     else if (inherits(cond, "condition")) {
[10:34:08.793]                       if (!is.null(pattern)) {
[10:34:08.793]                         computeRestarts <- base::computeRestarts
[10:34:08.793]                         grepl <- base::grepl
[10:34:08.793]                         restarts <- computeRestarts(cond)
[10:34:08.793]                         for (restart in restarts) {
[10:34:08.793]                           name <- restart$name
[10:34:08.793]                           if (is.null(name)) 
[10:34:08.793]                             next
[10:34:08.793]                           if (!grepl(pattern, name)) 
[10:34:08.793]                             next
[10:34:08.793]                           invokeRestart(restart)
[10:34:08.793]                           muffled <- TRUE
[10:34:08.793]                           break
[10:34:08.793]                         }
[10:34:08.793]                       }
[10:34:08.793]                     }
[10:34:08.793]                     invisible(muffled)
[10:34:08.793]                   }
[10:34:08.793]                   muffleCondition(cond)
[10:34:08.793]                 })
[10:34:08.793]             }))
[10:34:08.793]             future::FutureResult(value = ...future.value$value, 
[10:34:08.793]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:08.793]                   ...future.rng), globalenv = if (FALSE) 
[10:34:08.793]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:08.793]                     ...future.globalenv.names))
[10:34:08.793]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:08.793]         }, condition = base::local({
[10:34:08.793]             c <- base::c
[10:34:08.793]             inherits <- base::inherits
[10:34:08.793]             invokeRestart <- base::invokeRestart
[10:34:08.793]             length <- base::length
[10:34:08.793]             list <- base::list
[10:34:08.793]             seq.int <- base::seq.int
[10:34:08.793]             signalCondition <- base::signalCondition
[10:34:08.793]             sys.calls <- base::sys.calls
[10:34:08.793]             `[[` <- base::`[[`
[10:34:08.793]             `+` <- base::`+`
[10:34:08.793]             `<<-` <- base::`<<-`
[10:34:08.793]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:08.793]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:08.793]                   3L)]
[10:34:08.793]             }
[10:34:08.793]             function(cond) {
[10:34:08.793]                 is_error <- inherits(cond, "error")
[10:34:08.793]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:08.793]                   NULL)
[10:34:08.793]                 if (is_error) {
[10:34:08.793]                   sessionInformation <- function() {
[10:34:08.793]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:08.793]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:08.793]                       search = base::search(), system = base::Sys.info())
[10:34:08.793]                   }
[10:34:08.793]                   ...future.conditions[[length(...future.conditions) + 
[10:34:08.793]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:08.793]                     cond$call), session = sessionInformation(), 
[10:34:08.793]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:08.793]                   signalCondition(cond)
[10:34:08.793]                 }
[10:34:08.793]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:08.793]                 "immediateCondition"))) {
[10:34:08.793]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:08.793]                   ...future.conditions[[length(...future.conditions) + 
[10:34:08.793]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:08.793]                   if (TRUE && !signal) {
[10:34:08.793]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:08.793]                     {
[10:34:08.793]                       inherits <- base::inherits
[10:34:08.793]                       invokeRestart <- base::invokeRestart
[10:34:08.793]                       is.null <- base::is.null
[10:34:08.793]                       muffled <- FALSE
[10:34:08.793]                       if (inherits(cond, "message")) {
[10:34:08.793]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:08.793]                         if (muffled) 
[10:34:08.793]                           invokeRestart("muffleMessage")
[10:34:08.793]                       }
[10:34:08.793]                       else if (inherits(cond, "warning")) {
[10:34:08.793]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:08.793]                         if (muffled) 
[10:34:08.793]                           invokeRestart("muffleWarning")
[10:34:08.793]                       }
[10:34:08.793]                       else if (inherits(cond, "condition")) {
[10:34:08.793]                         if (!is.null(pattern)) {
[10:34:08.793]                           computeRestarts <- base::computeRestarts
[10:34:08.793]                           grepl <- base::grepl
[10:34:08.793]                           restarts <- computeRestarts(cond)
[10:34:08.793]                           for (restart in restarts) {
[10:34:08.793]                             name <- restart$name
[10:34:08.793]                             if (is.null(name)) 
[10:34:08.793]                               next
[10:34:08.793]                             if (!grepl(pattern, name)) 
[10:34:08.793]                               next
[10:34:08.793]                             invokeRestart(restart)
[10:34:08.793]                             muffled <- TRUE
[10:34:08.793]                             break
[10:34:08.793]                           }
[10:34:08.793]                         }
[10:34:08.793]                       }
[10:34:08.793]                       invisible(muffled)
[10:34:08.793]                     }
[10:34:08.793]                     muffleCondition(cond, pattern = "^muffle")
[10:34:08.793]                   }
[10:34:08.793]                 }
[10:34:08.793]                 else {
[10:34:08.793]                   if (TRUE) {
[10:34:08.793]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:08.793]                     {
[10:34:08.793]                       inherits <- base::inherits
[10:34:08.793]                       invokeRestart <- base::invokeRestart
[10:34:08.793]                       is.null <- base::is.null
[10:34:08.793]                       muffled <- FALSE
[10:34:08.793]                       if (inherits(cond, "message")) {
[10:34:08.793]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:08.793]                         if (muffled) 
[10:34:08.793]                           invokeRestart("muffleMessage")
[10:34:08.793]                       }
[10:34:08.793]                       else if (inherits(cond, "warning")) {
[10:34:08.793]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:08.793]                         if (muffled) 
[10:34:08.793]                           invokeRestart("muffleWarning")
[10:34:08.793]                       }
[10:34:08.793]                       else if (inherits(cond, "condition")) {
[10:34:08.793]                         if (!is.null(pattern)) {
[10:34:08.793]                           computeRestarts <- base::computeRestarts
[10:34:08.793]                           grepl <- base::grepl
[10:34:08.793]                           restarts <- computeRestarts(cond)
[10:34:08.793]                           for (restart in restarts) {
[10:34:08.793]                             name <- restart$name
[10:34:08.793]                             if (is.null(name)) 
[10:34:08.793]                               next
[10:34:08.793]                             if (!grepl(pattern, name)) 
[10:34:08.793]                               next
[10:34:08.793]                             invokeRestart(restart)
[10:34:08.793]                             muffled <- TRUE
[10:34:08.793]                             break
[10:34:08.793]                           }
[10:34:08.793]                         }
[10:34:08.793]                       }
[10:34:08.793]                       invisible(muffled)
[10:34:08.793]                     }
[10:34:08.793]                     muffleCondition(cond, pattern = "^muffle")
[10:34:08.793]                   }
[10:34:08.793]                 }
[10:34:08.793]             }
[10:34:08.793]         }))
[10:34:08.793]     }, error = function(ex) {
[10:34:08.793]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:08.793]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:08.793]                 ...future.rng), started = ...future.startTime, 
[10:34:08.793]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:08.793]             version = "1.8"), class = "FutureResult")
[10:34:08.793]     }, finally = {
[10:34:08.793]         if (!identical(...future.workdir, getwd())) 
[10:34:08.793]             setwd(...future.workdir)
[10:34:08.793]         {
[10:34:08.793]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:08.793]                 ...future.oldOptions$nwarnings <- NULL
[10:34:08.793]             }
[10:34:08.793]             base::options(...future.oldOptions)
[10:34:08.793]             if (.Platform$OS.type == "windows") {
[10:34:08.793]                 old_names <- names(...future.oldEnvVars)
[10:34:08.793]                 envs <- base::Sys.getenv()
[10:34:08.793]                 names <- names(envs)
[10:34:08.793]                 common <- intersect(names, old_names)
[10:34:08.793]                 added <- setdiff(names, old_names)
[10:34:08.793]                 removed <- setdiff(old_names, names)
[10:34:08.793]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:08.793]                   envs[common]]
[10:34:08.793]                 NAMES <- toupper(changed)
[10:34:08.793]                 args <- list()
[10:34:08.793]                 for (kk in seq_along(NAMES)) {
[10:34:08.793]                   name <- changed[[kk]]
[10:34:08.793]                   NAME <- NAMES[[kk]]
[10:34:08.793]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:08.793]                     next
[10:34:08.793]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:08.793]                 }
[10:34:08.793]                 NAMES <- toupper(added)
[10:34:08.793]                 for (kk in seq_along(NAMES)) {
[10:34:08.793]                   name <- added[[kk]]
[10:34:08.793]                   NAME <- NAMES[[kk]]
[10:34:08.793]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:08.793]                     next
[10:34:08.793]                   args[[name]] <- ""
[10:34:08.793]                 }
[10:34:08.793]                 NAMES <- toupper(removed)
[10:34:08.793]                 for (kk in seq_along(NAMES)) {
[10:34:08.793]                   name <- removed[[kk]]
[10:34:08.793]                   NAME <- NAMES[[kk]]
[10:34:08.793]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:08.793]                     next
[10:34:08.793]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:08.793]                 }
[10:34:08.793]                 if (length(args) > 0) 
[10:34:08.793]                   base::do.call(base::Sys.setenv, args = args)
[10:34:08.793]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:08.793]             }
[10:34:08.793]             else {
[10:34:08.793]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:08.793]             }
[10:34:08.793]             {
[10:34:08.793]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:08.793]                   0L) {
[10:34:08.793]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:08.793]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:08.793]                   base::options(opts)
[10:34:08.793]                 }
[10:34:08.793]                 {
[10:34:08.793]                   {
[10:34:08.793]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:08.793]                     NULL
[10:34:08.793]                   }
[10:34:08.793]                   options(future.plan = NULL)
[10:34:08.793]                   if (is.na(NA_character_)) 
[10:34:08.793]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:08.793]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:08.793]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:08.793]                     .init = FALSE)
[10:34:08.793]                 }
[10:34:08.793]             }
[10:34:08.793]         }
[10:34:08.793]     })
[10:34:08.793]     if (TRUE) {
[10:34:08.793]         base::sink(type = "output", split = FALSE)
[10:34:08.793]         if (TRUE) {
[10:34:08.793]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:08.793]         }
[10:34:08.793]         else {
[10:34:08.793]             ...future.result["stdout"] <- base::list(NULL)
[10:34:08.793]         }
[10:34:08.793]         base::close(...future.stdout)
[10:34:08.793]         ...future.stdout <- NULL
[10:34:08.793]     }
[10:34:08.793]     ...future.result$conditions <- ...future.conditions
[10:34:08.793]     ...future.result$finished <- base::Sys.time()
[10:34:08.793]     ...future.result
[10:34:08.793] }
[10:34:08.796] MultisessionFuture started
[10:34:08.796] - Launch lazy future ... done
[10:34:08.796] run() for ‘MultisessionFuture’ ... done
[10:34:09.298] receiveMessageFromWorker() for ClusterFuture ...
[10:34:09.299] - Validating connection of MultisessionFuture
[10:34:09.299] - received message: FutureResult
[10:34:09.299] - Received FutureResult
[10:34:09.299] - Erased future from FutureRegistry
[10:34:09.299] result() for ClusterFuture ...
[10:34:09.299] - result already collected: FutureResult
[10:34:09.299] result() for ClusterFuture ... done
[10:34:09.300] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:09.300] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[10:34:09.300] getGlobalsAndPackages() ...
[10:34:09.300] Searching for globals...
[10:34:09.301] - globals found: [2] ‘list’, ‘stop’
[10:34:09.301] Searching for globals ... DONE
[10:34:09.301] Resolving globals: FALSE
[10:34:09.301] 
[10:34:09.301] 
[10:34:09.301] getGlobalsAndPackages() ... DONE
[10:34:09.302] run() for ‘Future’ ...
[10:34:09.302] - state: ‘created’
[10:34:09.302] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:09.316] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:09.316] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:09.316]   - Field: ‘node’
[10:34:09.316]   - Field: ‘label’
[10:34:09.316]   - Field: ‘local’
[10:34:09.317]   - Field: ‘owner’
[10:34:09.317]   - Field: ‘envir’
[10:34:09.317]   - Field: ‘workers’
[10:34:09.317]   - Field: ‘packages’
[10:34:09.317]   - Field: ‘gc’
[10:34:09.317]   - Field: ‘conditions’
[10:34:09.317]   - Field: ‘persistent’
[10:34:09.317]   - Field: ‘expr’
[10:34:09.317]   - Field: ‘uuid’
[10:34:09.317]   - Field: ‘seed’
[10:34:09.318]   - Field: ‘version’
[10:34:09.318]   - Field: ‘result’
[10:34:09.318]   - Field: ‘asynchronous’
[10:34:09.318]   - Field: ‘calls’
[10:34:09.318]   - Field: ‘globals’
[10:34:09.318]   - Field: ‘stdout’
[10:34:09.318]   - Field: ‘earlySignal’
[10:34:09.318]   - Field: ‘lazy’
[10:34:09.318]   - Field: ‘state’
[10:34:09.318] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:09.318] - Launch lazy future ...
[10:34:09.319] Packages needed by the future expression (n = 0): <none>
[10:34:09.319] Packages needed by future strategies (n = 0): <none>
[10:34:09.319] {
[10:34:09.319]     {
[10:34:09.319]         {
[10:34:09.319]             ...future.startTime <- base::Sys.time()
[10:34:09.319]             {
[10:34:09.319]                 {
[10:34:09.319]                   {
[10:34:09.319]                     {
[10:34:09.319]                       base::local({
[10:34:09.319]                         has_future <- base::requireNamespace("future", 
[10:34:09.319]                           quietly = TRUE)
[10:34:09.319]                         if (has_future) {
[10:34:09.319]                           ns <- base::getNamespace("future")
[10:34:09.319]                           version <- ns[[".package"]][["version"]]
[10:34:09.319]                           if (is.null(version)) 
[10:34:09.319]                             version <- utils::packageVersion("future")
[10:34:09.319]                         }
[10:34:09.319]                         else {
[10:34:09.319]                           version <- NULL
[10:34:09.319]                         }
[10:34:09.319]                         if (!has_future || version < "1.8.0") {
[10:34:09.319]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:09.319]                             "", base::R.version$version.string), 
[10:34:09.319]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:09.319]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:09.319]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:09.319]                               "release", "version")], collapse = " "), 
[10:34:09.319]                             hostname = base::Sys.info()[["nodename"]])
[10:34:09.319]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:09.319]                             info)
[10:34:09.319]                           info <- base::paste(info, collapse = "; ")
[10:34:09.319]                           if (!has_future) {
[10:34:09.319]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:09.319]                               info)
[10:34:09.319]                           }
[10:34:09.319]                           else {
[10:34:09.319]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:09.319]                               info, version)
[10:34:09.319]                           }
[10:34:09.319]                           base::stop(msg)
[10:34:09.319]                         }
[10:34:09.319]                       })
[10:34:09.319]                     }
[10:34:09.319]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:09.319]                     base::options(mc.cores = 1L)
[10:34:09.319]                   }
[10:34:09.319]                   ...future.strategy.old <- future::plan("list")
[10:34:09.319]                   options(future.plan = NULL)
[10:34:09.319]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:09.319]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:09.319]                 }
[10:34:09.319]                 ...future.workdir <- getwd()
[10:34:09.319]             }
[10:34:09.319]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:09.319]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:09.319]         }
[10:34:09.319]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:09.319]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:09.319]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:09.319]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:09.319]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:09.319]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:09.319]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:09.319]             base::names(...future.oldOptions))
[10:34:09.319]     }
[10:34:09.319]     if (FALSE) {
[10:34:09.319]     }
[10:34:09.319]     else {
[10:34:09.319]         if (TRUE) {
[10:34:09.319]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:09.319]                 open = "w")
[10:34:09.319]         }
[10:34:09.319]         else {
[10:34:09.319]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:09.319]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:09.319]         }
[10:34:09.319]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:09.319]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:09.319]             base::sink(type = "output", split = FALSE)
[10:34:09.319]             base::close(...future.stdout)
[10:34:09.319]         }, add = TRUE)
[10:34:09.319]     }
[10:34:09.319]     ...future.frame <- base::sys.nframe()
[10:34:09.319]     ...future.conditions <- base::list()
[10:34:09.319]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:09.319]     if (FALSE) {
[10:34:09.319]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:09.319]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:09.319]     }
[10:34:09.319]     ...future.result <- base::tryCatch({
[10:34:09.319]         base::withCallingHandlers({
[10:34:09.319]             ...future.value <- base::withVisible(base::local({
[10:34:09.319]                 ...future.makeSendCondition <- base::local({
[10:34:09.319]                   sendCondition <- NULL
[10:34:09.319]                   function(frame = 1L) {
[10:34:09.319]                     if (is.function(sendCondition)) 
[10:34:09.319]                       return(sendCondition)
[10:34:09.319]                     ns <- getNamespace("parallel")
[10:34:09.319]                     if (exists("sendData", mode = "function", 
[10:34:09.319]                       envir = ns)) {
[10:34:09.319]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:09.319]                         envir = ns)
[10:34:09.319]                       envir <- sys.frame(frame)
[10:34:09.319]                       master <- NULL
[10:34:09.319]                       while (!identical(envir, .GlobalEnv) && 
[10:34:09.319]                         !identical(envir, emptyenv())) {
[10:34:09.319]                         if (exists("master", mode = "list", envir = envir, 
[10:34:09.319]                           inherits = FALSE)) {
[10:34:09.319]                           master <- get("master", mode = "list", 
[10:34:09.319]                             envir = envir, inherits = FALSE)
[10:34:09.319]                           if (inherits(master, c("SOCKnode", 
[10:34:09.319]                             "SOCK0node"))) {
[10:34:09.319]                             sendCondition <<- function(cond) {
[10:34:09.319]                               data <- list(type = "VALUE", value = cond, 
[10:34:09.319]                                 success = TRUE)
[10:34:09.319]                               parallel_sendData(master, data)
[10:34:09.319]                             }
[10:34:09.319]                             return(sendCondition)
[10:34:09.319]                           }
[10:34:09.319]                         }
[10:34:09.319]                         frame <- frame + 1L
[10:34:09.319]                         envir <- sys.frame(frame)
[10:34:09.319]                       }
[10:34:09.319]                     }
[10:34:09.319]                     sendCondition <<- function(cond) NULL
[10:34:09.319]                   }
[10:34:09.319]                 })
[10:34:09.319]                 withCallingHandlers({
[10:34:09.319]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:34:09.319]                 }, immediateCondition = function(cond) {
[10:34:09.319]                   sendCondition <- ...future.makeSendCondition()
[10:34:09.319]                   sendCondition(cond)
[10:34:09.319]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:09.319]                   {
[10:34:09.319]                     inherits <- base::inherits
[10:34:09.319]                     invokeRestart <- base::invokeRestart
[10:34:09.319]                     is.null <- base::is.null
[10:34:09.319]                     muffled <- FALSE
[10:34:09.319]                     if (inherits(cond, "message")) {
[10:34:09.319]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:09.319]                       if (muffled) 
[10:34:09.319]                         invokeRestart("muffleMessage")
[10:34:09.319]                     }
[10:34:09.319]                     else if (inherits(cond, "warning")) {
[10:34:09.319]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:09.319]                       if (muffled) 
[10:34:09.319]                         invokeRestart("muffleWarning")
[10:34:09.319]                     }
[10:34:09.319]                     else if (inherits(cond, "condition")) {
[10:34:09.319]                       if (!is.null(pattern)) {
[10:34:09.319]                         computeRestarts <- base::computeRestarts
[10:34:09.319]                         grepl <- base::grepl
[10:34:09.319]                         restarts <- computeRestarts(cond)
[10:34:09.319]                         for (restart in restarts) {
[10:34:09.319]                           name <- restart$name
[10:34:09.319]                           if (is.null(name)) 
[10:34:09.319]                             next
[10:34:09.319]                           if (!grepl(pattern, name)) 
[10:34:09.319]                             next
[10:34:09.319]                           invokeRestart(restart)
[10:34:09.319]                           muffled <- TRUE
[10:34:09.319]                           break
[10:34:09.319]                         }
[10:34:09.319]                       }
[10:34:09.319]                     }
[10:34:09.319]                     invisible(muffled)
[10:34:09.319]                   }
[10:34:09.319]                   muffleCondition(cond)
[10:34:09.319]                 })
[10:34:09.319]             }))
[10:34:09.319]             future::FutureResult(value = ...future.value$value, 
[10:34:09.319]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:09.319]                   ...future.rng), globalenv = if (FALSE) 
[10:34:09.319]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:09.319]                     ...future.globalenv.names))
[10:34:09.319]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:09.319]         }, condition = base::local({
[10:34:09.319]             c <- base::c
[10:34:09.319]             inherits <- base::inherits
[10:34:09.319]             invokeRestart <- base::invokeRestart
[10:34:09.319]             length <- base::length
[10:34:09.319]             list <- base::list
[10:34:09.319]             seq.int <- base::seq.int
[10:34:09.319]             signalCondition <- base::signalCondition
[10:34:09.319]             sys.calls <- base::sys.calls
[10:34:09.319]             `[[` <- base::`[[`
[10:34:09.319]             `+` <- base::`+`
[10:34:09.319]             `<<-` <- base::`<<-`
[10:34:09.319]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:09.319]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:09.319]                   3L)]
[10:34:09.319]             }
[10:34:09.319]             function(cond) {
[10:34:09.319]                 is_error <- inherits(cond, "error")
[10:34:09.319]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:09.319]                   NULL)
[10:34:09.319]                 if (is_error) {
[10:34:09.319]                   sessionInformation <- function() {
[10:34:09.319]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:09.319]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:09.319]                       search = base::search(), system = base::Sys.info())
[10:34:09.319]                   }
[10:34:09.319]                   ...future.conditions[[length(...future.conditions) + 
[10:34:09.319]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:09.319]                     cond$call), session = sessionInformation(), 
[10:34:09.319]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:09.319]                   signalCondition(cond)
[10:34:09.319]                 }
[10:34:09.319]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:09.319]                 "immediateCondition"))) {
[10:34:09.319]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:09.319]                   ...future.conditions[[length(...future.conditions) + 
[10:34:09.319]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:09.319]                   if (TRUE && !signal) {
[10:34:09.319]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:09.319]                     {
[10:34:09.319]                       inherits <- base::inherits
[10:34:09.319]                       invokeRestart <- base::invokeRestart
[10:34:09.319]                       is.null <- base::is.null
[10:34:09.319]                       muffled <- FALSE
[10:34:09.319]                       if (inherits(cond, "message")) {
[10:34:09.319]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:09.319]                         if (muffled) 
[10:34:09.319]                           invokeRestart("muffleMessage")
[10:34:09.319]                       }
[10:34:09.319]                       else if (inherits(cond, "warning")) {
[10:34:09.319]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:09.319]                         if (muffled) 
[10:34:09.319]                           invokeRestart("muffleWarning")
[10:34:09.319]                       }
[10:34:09.319]                       else if (inherits(cond, "condition")) {
[10:34:09.319]                         if (!is.null(pattern)) {
[10:34:09.319]                           computeRestarts <- base::computeRestarts
[10:34:09.319]                           grepl <- base::grepl
[10:34:09.319]                           restarts <- computeRestarts(cond)
[10:34:09.319]                           for (restart in restarts) {
[10:34:09.319]                             name <- restart$name
[10:34:09.319]                             if (is.null(name)) 
[10:34:09.319]                               next
[10:34:09.319]                             if (!grepl(pattern, name)) 
[10:34:09.319]                               next
[10:34:09.319]                             invokeRestart(restart)
[10:34:09.319]                             muffled <- TRUE
[10:34:09.319]                             break
[10:34:09.319]                           }
[10:34:09.319]                         }
[10:34:09.319]                       }
[10:34:09.319]                       invisible(muffled)
[10:34:09.319]                     }
[10:34:09.319]                     muffleCondition(cond, pattern = "^muffle")
[10:34:09.319]                   }
[10:34:09.319]                 }
[10:34:09.319]                 else {
[10:34:09.319]                   if (TRUE) {
[10:34:09.319]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:09.319]                     {
[10:34:09.319]                       inherits <- base::inherits
[10:34:09.319]                       invokeRestart <- base::invokeRestart
[10:34:09.319]                       is.null <- base::is.null
[10:34:09.319]                       muffled <- FALSE
[10:34:09.319]                       if (inherits(cond, "message")) {
[10:34:09.319]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:09.319]                         if (muffled) 
[10:34:09.319]                           invokeRestart("muffleMessage")
[10:34:09.319]                       }
[10:34:09.319]                       else if (inherits(cond, "warning")) {
[10:34:09.319]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:09.319]                         if (muffled) 
[10:34:09.319]                           invokeRestart("muffleWarning")
[10:34:09.319]                       }
[10:34:09.319]                       else if (inherits(cond, "condition")) {
[10:34:09.319]                         if (!is.null(pattern)) {
[10:34:09.319]                           computeRestarts <- base::computeRestarts
[10:34:09.319]                           grepl <- base::grepl
[10:34:09.319]                           restarts <- computeRestarts(cond)
[10:34:09.319]                           for (restart in restarts) {
[10:34:09.319]                             name <- restart$name
[10:34:09.319]                             if (is.null(name)) 
[10:34:09.319]                               next
[10:34:09.319]                             if (!grepl(pattern, name)) 
[10:34:09.319]                               next
[10:34:09.319]                             invokeRestart(restart)
[10:34:09.319]                             muffled <- TRUE
[10:34:09.319]                             break
[10:34:09.319]                           }
[10:34:09.319]                         }
[10:34:09.319]                       }
[10:34:09.319]                       invisible(muffled)
[10:34:09.319]                     }
[10:34:09.319]                     muffleCondition(cond, pattern = "^muffle")
[10:34:09.319]                   }
[10:34:09.319]                 }
[10:34:09.319]             }
[10:34:09.319]         }))
[10:34:09.319]     }, error = function(ex) {
[10:34:09.319]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:09.319]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:09.319]                 ...future.rng), started = ...future.startTime, 
[10:34:09.319]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:09.319]             version = "1.8"), class = "FutureResult")
[10:34:09.319]     }, finally = {
[10:34:09.319]         if (!identical(...future.workdir, getwd())) 
[10:34:09.319]             setwd(...future.workdir)
[10:34:09.319]         {
[10:34:09.319]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:09.319]                 ...future.oldOptions$nwarnings <- NULL
[10:34:09.319]             }
[10:34:09.319]             base::options(...future.oldOptions)
[10:34:09.319]             if (.Platform$OS.type == "windows") {
[10:34:09.319]                 old_names <- names(...future.oldEnvVars)
[10:34:09.319]                 envs <- base::Sys.getenv()
[10:34:09.319]                 names <- names(envs)
[10:34:09.319]                 common <- intersect(names, old_names)
[10:34:09.319]                 added <- setdiff(names, old_names)
[10:34:09.319]                 removed <- setdiff(old_names, names)
[10:34:09.319]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:09.319]                   envs[common]]
[10:34:09.319]                 NAMES <- toupper(changed)
[10:34:09.319]                 args <- list()
[10:34:09.319]                 for (kk in seq_along(NAMES)) {
[10:34:09.319]                   name <- changed[[kk]]
[10:34:09.319]                   NAME <- NAMES[[kk]]
[10:34:09.319]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:09.319]                     next
[10:34:09.319]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:09.319]                 }
[10:34:09.319]                 NAMES <- toupper(added)
[10:34:09.319]                 for (kk in seq_along(NAMES)) {
[10:34:09.319]                   name <- added[[kk]]
[10:34:09.319]                   NAME <- NAMES[[kk]]
[10:34:09.319]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:09.319]                     next
[10:34:09.319]                   args[[name]] <- ""
[10:34:09.319]                 }
[10:34:09.319]                 NAMES <- toupper(removed)
[10:34:09.319]                 for (kk in seq_along(NAMES)) {
[10:34:09.319]                   name <- removed[[kk]]
[10:34:09.319]                   NAME <- NAMES[[kk]]
[10:34:09.319]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:09.319]                     next
[10:34:09.319]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:09.319]                 }
[10:34:09.319]                 if (length(args) > 0) 
[10:34:09.319]                   base::do.call(base::Sys.setenv, args = args)
[10:34:09.319]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:09.319]             }
[10:34:09.319]             else {
[10:34:09.319]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:09.319]             }
[10:34:09.319]             {
[10:34:09.319]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:09.319]                   0L) {
[10:34:09.319]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:09.319]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:09.319]                   base::options(opts)
[10:34:09.319]                 }
[10:34:09.319]                 {
[10:34:09.319]                   {
[10:34:09.319]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:09.319]                     NULL
[10:34:09.319]                   }
[10:34:09.319]                   options(future.plan = NULL)
[10:34:09.319]                   if (is.na(NA_character_)) 
[10:34:09.319]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:09.319]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:09.319]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:09.319]                     .init = FALSE)
[10:34:09.319]                 }
[10:34:09.319]             }
[10:34:09.319]         }
[10:34:09.319]     })
[10:34:09.319]     if (TRUE) {
[10:34:09.319]         base::sink(type = "output", split = FALSE)
[10:34:09.319]         if (TRUE) {
[10:34:09.319]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:09.319]         }
[10:34:09.319]         else {
[10:34:09.319]             ...future.result["stdout"] <- base::list(NULL)
[10:34:09.319]         }
[10:34:09.319]         base::close(...future.stdout)
[10:34:09.319]         ...future.stdout <- NULL
[10:34:09.319]     }
[10:34:09.319]     ...future.result$conditions <- ...future.conditions
[10:34:09.319]     ...future.result$finished <- base::Sys.time()
[10:34:09.319]     ...future.result
[10:34:09.319] }
[10:34:09.322] MultisessionFuture started
[10:34:09.322] - Launch lazy future ... done
[10:34:09.322] run() for ‘MultisessionFuture’ ... done
[10:34:09.324] receiveMessageFromWorker() for ClusterFuture ...
[10:34:09.324] - Validating connection of MultisessionFuture
[10:34:09.324] - received message: FutureResult
[10:34:09.324] - Received FutureResult
[10:34:09.325] - Erased future from FutureRegistry
[10:34:09.325] result() for ClusterFuture ...
[10:34:09.325] - result already collected: FutureResult
[10:34:09.325] result() for ClusterFuture ... done
[10:34:09.325] signalConditions() ...
[10:34:09.325]  - include = ‘immediateCondition’
[10:34:09.325]  - exclude = 
[10:34:09.325]  - resignal = FALSE
[10:34:09.325]  - Number of conditions: 1
[10:34:09.325] signalConditions() ... done
[10:34:09.325] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:09.326] A MultisessionFuture was resolved (result was not collected)
[10:34:09.326] getGlobalsAndPackages() ...
[10:34:09.326] Searching for globals...
[10:34:09.326] - globals found: [2] ‘list’, ‘stop’
[10:34:09.326] Searching for globals ... DONE
[10:34:09.327] Resolving globals: FALSE
[10:34:09.327] 
[10:34:09.327] 
[10:34:09.327] getGlobalsAndPackages() ... DONE
[10:34:09.327] run() for ‘Future’ ...
[10:34:09.327] - state: ‘created’
[10:34:09.328] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:09.341] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:09.341] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:09.341]   - Field: ‘node’
[10:34:09.341]   - Field: ‘label’
[10:34:09.341]   - Field: ‘local’
[10:34:09.341]   - Field: ‘owner’
[10:34:09.342]   - Field: ‘envir’
[10:34:09.342]   - Field: ‘workers’
[10:34:09.342]   - Field: ‘packages’
[10:34:09.342]   - Field: ‘gc’
[10:34:09.342]   - Field: ‘conditions’
[10:34:09.342]   - Field: ‘persistent’
[10:34:09.342]   - Field: ‘expr’
[10:34:09.342]   - Field: ‘uuid’
[10:34:09.342]   - Field: ‘seed’
[10:34:09.342]   - Field: ‘version’
[10:34:09.342]   - Field: ‘result’
[10:34:09.343]   - Field: ‘asynchronous’
[10:34:09.343]   - Field: ‘calls’
[10:34:09.343]   - Field: ‘globals’
[10:34:09.343]   - Field: ‘stdout’
[10:34:09.343]   - Field: ‘earlySignal’
[10:34:09.343]   - Field: ‘lazy’
[10:34:09.343]   - Field: ‘state’
[10:34:09.343] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:09.343] - Launch lazy future ...
[10:34:09.344] Packages needed by the future expression (n = 0): <none>
[10:34:09.344] Packages needed by future strategies (n = 0): <none>
[10:34:09.344] {
[10:34:09.344]     {
[10:34:09.344]         {
[10:34:09.344]             ...future.startTime <- base::Sys.time()
[10:34:09.344]             {
[10:34:09.344]                 {
[10:34:09.344]                   {
[10:34:09.344]                     {
[10:34:09.344]                       base::local({
[10:34:09.344]                         has_future <- base::requireNamespace("future", 
[10:34:09.344]                           quietly = TRUE)
[10:34:09.344]                         if (has_future) {
[10:34:09.344]                           ns <- base::getNamespace("future")
[10:34:09.344]                           version <- ns[[".package"]][["version"]]
[10:34:09.344]                           if (is.null(version)) 
[10:34:09.344]                             version <- utils::packageVersion("future")
[10:34:09.344]                         }
[10:34:09.344]                         else {
[10:34:09.344]                           version <- NULL
[10:34:09.344]                         }
[10:34:09.344]                         if (!has_future || version < "1.8.0") {
[10:34:09.344]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:09.344]                             "", base::R.version$version.string), 
[10:34:09.344]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:09.344]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:09.344]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:09.344]                               "release", "version")], collapse = " "), 
[10:34:09.344]                             hostname = base::Sys.info()[["nodename"]])
[10:34:09.344]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:09.344]                             info)
[10:34:09.344]                           info <- base::paste(info, collapse = "; ")
[10:34:09.344]                           if (!has_future) {
[10:34:09.344]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:09.344]                               info)
[10:34:09.344]                           }
[10:34:09.344]                           else {
[10:34:09.344]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:09.344]                               info, version)
[10:34:09.344]                           }
[10:34:09.344]                           base::stop(msg)
[10:34:09.344]                         }
[10:34:09.344]                       })
[10:34:09.344]                     }
[10:34:09.344]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:09.344]                     base::options(mc.cores = 1L)
[10:34:09.344]                   }
[10:34:09.344]                   ...future.strategy.old <- future::plan("list")
[10:34:09.344]                   options(future.plan = NULL)
[10:34:09.344]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:09.344]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:09.344]                 }
[10:34:09.344]                 ...future.workdir <- getwd()
[10:34:09.344]             }
[10:34:09.344]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:09.344]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:09.344]         }
[10:34:09.344]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:09.344]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:09.344]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:09.344]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:09.344]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:09.344]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:09.344]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:09.344]             base::names(...future.oldOptions))
[10:34:09.344]     }
[10:34:09.344]     if (FALSE) {
[10:34:09.344]     }
[10:34:09.344]     else {
[10:34:09.344]         if (TRUE) {
[10:34:09.344]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:09.344]                 open = "w")
[10:34:09.344]         }
[10:34:09.344]         else {
[10:34:09.344]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:09.344]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:09.344]         }
[10:34:09.344]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:09.344]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:09.344]             base::sink(type = "output", split = FALSE)
[10:34:09.344]             base::close(...future.stdout)
[10:34:09.344]         }, add = TRUE)
[10:34:09.344]     }
[10:34:09.344]     ...future.frame <- base::sys.nframe()
[10:34:09.344]     ...future.conditions <- base::list()
[10:34:09.344]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:09.344]     if (FALSE) {
[10:34:09.344]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:09.344]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:09.344]     }
[10:34:09.344]     ...future.result <- base::tryCatch({
[10:34:09.344]         base::withCallingHandlers({
[10:34:09.344]             ...future.value <- base::withVisible(base::local({
[10:34:09.344]                 ...future.makeSendCondition <- base::local({
[10:34:09.344]                   sendCondition <- NULL
[10:34:09.344]                   function(frame = 1L) {
[10:34:09.344]                     if (is.function(sendCondition)) 
[10:34:09.344]                       return(sendCondition)
[10:34:09.344]                     ns <- getNamespace("parallel")
[10:34:09.344]                     if (exists("sendData", mode = "function", 
[10:34:09.344]                       envir = ns)) {
[10:34:09.344]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:09.344]                         envir = ns)
[10:34:09.344]                       envir <- sys.frame(frame)
[10:34:09.344]                       master <- NULL
[10:34:09.344]                       while (!identical(envir, .GlobalEnv) && 
[10:34:09.344]                         !identical(envir, emptyenv())) {
[10:34:09.344]                         if (exists("master", mode = "list", envir = envir, 
[10:34:09.344]                           inherits = FALSE)) {
[10:34:09.344]                           master <- get("master", mode = "list", 
[10:34:09.344]                             envir = envir, inherits = FALSE)
[10:34:09.344]                           if (inherits(master, c("SOCKnode", 
[10:34:09.344]                             "SOCK0node"))) {
[10:34:09.344]                             sendCondition <<- function(cond) {
[10:34:09.344]                               data <- list(type = "VALUE", value = cond, 
[10:34:09.344]                                 success = TRUE)
[10:34:09.344]                               parallel_sendData(master, data)
[10:34:09.344]                             }
[10:34:09.344]                             return(sendCondition)
[10:34:09.344]                           }
[10:34:09.344]                         }
[10:34:09.344]                         frame <- frame + 1L
[10:34:09.344]                         envir <- sys.frame(frame)
[10:34:09.344]                       }
[10:34:09.344]                     }
[10:34:09.344]                     sendCondition <<- function(cond) NULL
[10:34:09.344]                   }
[10:34:09.344]                 })
[10:34:09.344]                 withCallingHandlers({
[10:34:09.344]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:34:09.344]                 }, immediateCondition = function(cond) {
[10:34:09.344]                   sendCondition <- ...future.makeSendCondition()
[10:34:09.344]                   sendCondition(cond)
[10:34:09.344]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:09.344]                   {
[10:34:09.344]                     inherits <- base::inherits
[10:34:09.344]                     invokeRestart <- base::invokeRestart
[10:34:09.344]                     is.null <- base::is.null
[10:34:09.344]                     muffled <- FALSE
[10:34:09.344]                     if (inherits(cond, "message")) {
[10:34:09.344]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:09.344]                       if (muffled) 
[10:34:09.344]                         invokeRestart("muffleMessage")
[10:34:09.344]                     }
[10:34:09.344]                     else if (inherits(cond, "warning")) {
[10:34:09.344]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:09.344]                       if (muffled) 
[10:34:09.344]                         invokeRestart("muffleWarning")
[10:34:09.344]                     }
[10:34:09.344]                     else if (inherits(cond, "condition")) {
[10:34:09.344]                       if (!is.null(pattern)) {
[10:34:09.344]                         computeRestarts <- base::computeRestarts
[10:34:09.344]                         grepl <- base::grepl
[10:34:09.344]                         restarts <- computeRestarts(cond)
[10:34:09.344]                         for (restart in restarts) {
[10:34:09.344]                           name <- restart$name
[10:34:09.344]                           if (is.null(name)) 
[10:34:09.344]                             next
[10:34:09.344]                           if (!grepl(pattern, name)) 
[10:34:09.344]                             next
[10:34:09.344]                           invokeRestart(restart)
[10:34:09.344]                           muffled <- TRUE
[10:34:09.344]                           break
[10:34:09.344]                         }
[10:34:09.344]                       }
[10:34:09.344]                     }
[10:34:09.344]                     invisible(muffled)
[10:34:09.344]                   }
[10:34:09.344]                   muffleCondition(cond)
[10:34:09.344]                 })
[10:34:09.344]             }))
[10:34:09.344]             future::FutureResult(value = ...future.value$value, 
[10:34:09.344]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:09.344]                   ...future.rng), globalenv = if (FALSE) 
[10:34:09.344]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:09.344]                     ...future.globalenv.names))
[10:34:09.344]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:09.344]         }, condition = base::local({
[10:34:09.344]             c <- base::c
[10:34:09.344]             inherits <- base::inherits
[10:34:09.344]             invokeRestart <- base::invokeRestart
[10:34:09.344]             length <- base::length
[10:34:09.344]             list <- base::list
[10:34:09.344]             seq.int <- base::seq.int
[10:34:09.344]             signalCondition <- base::signalCondition
[10:34:09.344]             sys.calls <- base::sys.calls
[10:34:09.344]             `[[` <- base::`[[`
[10:34:09.344]             `+` <- base::`+`
[10:34:09.344]             `<<-` <- base::`<<-`
[10:34:09.344]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:09.344]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:09.344]                   3L)]
[10:34:09.344]             }
[10:34:09.344]             function(cond) {
[10:34:09.344]                 is_error <- inherits(cond, "error")
[10:34:09.344]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:09.344]                   NULL)
[10:34:09.344]                 if (is_error) {
[10:34:09.344]                   sessionInformation <- function() {
[10:34:09.344]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:09.344]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:09.344]                       search = base::search(), system = base::Sys.info())
[10:34:09.344]                   }
[10:34:09.344]                   ...future.conditions[[length(...future.conditions) + 
[10:34:09.344]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:09.344]                     cond$call), session = sessionInformation(), 
[10:34:09.344]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:09.344]                   signalCondition(cond)
[10:34:09.344]                 }
[10:34:09.344]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:09.344]                 "immediateCondition"))) {
[10:34:09.344]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:09.344]                   ...future.conditions[[length(...future.conditions) + 
[10:34:09.344]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:09.344]                   if (TRUE && !signal) {
[10:34:09.344]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:09.344]                     {
[10:34:09.344]                       inherits <- base::inherits
[10:34:09.344]                       invokeRestart <- base::invokeRestart
[10:34:09.344]                       is.null <- base::is.null
[10:34:09.344]                       muffled <- FALSE
[10:34:09.344]                       if (inherits(cond, "message")) {
[10:34:09.344]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:09.344]                         if (muffled) 
[10:34:09.344]                           invokeRestart("muffleMessage")
[10:34:09.344]                       }
[10:34:09.344]                       else if (inherits(cond, "warning")) {
[10:34:09.344]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:09.344]                         if (muffled) 
[10:34:09.344]                           invokeRestart("muffleWarning")
[10:34:09.344]                       }
[10:34:09.344]                       else if (inherits(cond, "condition")) {
[10:34:09.344]                         if (!is.null(pattern)) {
[10:34:09.344]                           computeRestarts <- base::computeRestarts
[10:34:09.344]                           grepl <- base::grepl
[10:34:09.344]                           restarts <- computeRestarts(cond)
[10:34:09.344]                           for (restart in restarts) {
[10:34:09.344]                             name <- restart$name
[10:34:09.344]                             if (is.null(name)) 
[10:34:09.344]                               next
[10:34:09.344]                             if (!grepl(pattern, name)) 
[10:34:09.344]                               next
[10:34:09.344]                             invokeRestart(restart)
[10:34:09.344]                             muffled <- TRUE
[10:34:09.344]                             break
[10:34:09.344]                           }
[10:34:09.344]                         }
[10:34:09.344]                       }
[10:34:09.344]                       invisible(muffled)
[10:34:09.344]                     }
[10:34:09.344]                     muffleCondition(cond, pattern = "^muffle")
[10:34:09.344]                   }
[10:34:09.344]                 }
[10:34:09.344]                 else {
[10:34:09.344]                   if (TRUE) {
[10:34:09.344]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:09.344]                     {
[10:34:09.344]                       inherits <- base::inherits
[10:34:09.344]                       invokeRestart <- base::invokeRestart
[10:34:09.344]                       is.null <- base::is.null
[10:34:09.344]                       muffled <- FALSE
[10:34:09.344]                       if (inherits(cond, "message")) {
[10:34:09.344]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:09.344]                         if (muffled) 
[10:34:09.344]                           invokeRestart("muffleMessage")
[10:34:09.344]                       }
[10:34:09.344]                       else if (inherits(cond, "warning")) {
[10:34:09.344]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:09.344]                         if (muffled) 
[10:34:09.344]                           invokeRestart("muffleWarning")
[10:34:09.344]                       }
[10:34:09.344]                       else if (inherits(cond, "condition")) {
[10:34:09.344]                         if (!is.null(pattern)) {
[10:34:09.344]                           computeRestarts <- base::computeRestarts
[10:34:09.344]                           grepl <- base::grepl
[10:34:09.344]                           restarts <- computeRestarts(cond)
[10:34:09.344]                           for (restart in restarts) {
[10:34:09.344]                             name <- restart$name
[10:34:09.344]                             if (is.null(name)) 
[10:34:09.344]                               next
[10:34:09.344]                             if (!grepl(pattern, name)) 
[10:34:09.344]                               next
[10:34:09.344]                             invokeRestart(restart)
[10:34:09.344]                             muffled <- TRUE
[10:34:09.344]                             break
[10:34:09.344]                           }
[10:34:09.344]                         }
[10:34:09.344]                       }
[10:34:09.344]                       invisible(muffled)
[10:34:09.344]                     }
[10:34:09.344]                     muffleCondition(cond, pattern = "^muffle")
[10:34:09.344]                   }
[10:34:09.344]                 }
[10:34:09.344]             }
[10:34:09.344]         }))
[10:34:09.344]     }, error = function(ex) {
[10:34:09.344]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:09.344]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:09.344]                 ...future.rng), started = ...future.startTime, 
[10:34:09.344]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:09.344]             version = "1.8"), class = "FutureResult")
[10:34:09.344]     }, finally = {
[10:34:09.344]         if (!identical(...future.workdir, getwd())) 
[10:34:09.344]             setwd(...future.workdir)
[10:34:09.344]         {
[10:34:09.344]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:09.344]                 ...future.oldOptions$nwarnings <- NULL
[10:34:09.344]             }
[10:34:09.344]             base::options(...future.oldOptions)
[10:34:09.344]             if (.Platform$OS.type == "windows") {
[10:34:09.344]                 old_names <- names(...future.oldEnvVars)
[10:34:09.344]                 envs <- base::Sys.getenv()
[10:34:09.344]                 names <- names(envs)
[10:34:09.344]                 common <- intersect(names, old_names)
[10:34:09.344]                 added <- setdiff(names, old_names)
[10:34:09.344]                 removed <- setdiff(old_names, names)
[10:34:09.344]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:09.344]                   envs[common]]
[10:34:09.344]                 NAMES <- toupper(changed)
[10:34:09.344]                 args <- list()
[10:34:09.344]                 for (kk in seq_along(NAMES)) {
[10:34:09.344]                   name <- changed[[kk]]
[10:34:09.344]                   NAME <- NAMES[[kk]]
[10:34:09.344]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:09.344]                     next
[10:34:09.344]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:09.344]                 }
[10:34:09.344]                 NAMES <- toupper(added)
[10:34:09.344]                 for (kk in seq_along(NAMES)) {
[10:34:09.344]                   name <- added[[kk]]
[10:34:09.344]                   NAME <- NAMES[[kk]]
[10:34:09.344]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:09.344]                     next
[10:34:09.344]                   args[[name]] <- ""
[10:34:09.344]                 }
[10:34:09.344]                 NAMES <- toupper(removed)
[10:34:09.344]                 for (kk in seq_along(NAMES)) {
[10:34:09.344]                   name <- removed[[kk]]
[10:34:09.344]                   NAME <- NAMES[[kk]]
[10:34:09.344]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:09.344]                     next
[10:34:09.344]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:09.344]                 }
[10:34:09.344]                 if (length(args) > 0) 
[10:34:09.344]                   base::do.call(base::Sys.setenv, args = args)
[10:34:09.344]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:09.344]             }
[10:34:09.344]             else {
[10:34:09.344]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:09.344]             }
[10:34:09.344]             {
[10:34:09.344]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:09.344]                   0L) {
[10:34:09.344]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:09.344]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:09.344]                   base::options(opts)
[10:34:09.344]                 }
[10:34:09.344]                 {
[10:34:09.344]                   {
[10:34:09.344]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:09.344]                     NULL
[10:34:09.344]                   }
[10:34:09.344]                   options(future.plan = NULL)
[10:34:09.344]                   if (is.na(NA_character_)) 
[10:34:09.344]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:09.344]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:09.344]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:09.344]                     .init = FALSE)
[10:34:09.344]                 }
[10:34:09.344]             }
[10:34:09.344]         }
[10:34:09.344]     })
[10:34:09.344]     if (TRUE) {
[10:34:09.344]         base::sink(type = "output", split = FALSE)
[10:34:09.344]         if (TRUE) {
[10:34:09.344]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:09.344]         }
[10:34:09.344]         else {
[10:34:09.344]             ...future.result["stdout"] <- base::list(NULL)
[10:34:09.344]         }
[10:34:09.344]         base::close(...future.stdout)
[10:34:09.344]         ...future.stdout <- NULL
[10:34:09.344]     }
[10:34:09.344]     ...future.result$conditions <- ...future.conditions
[10:34:09.344]     ...future.result$finished <- base::Sys.time()
[10:34:09.344]     ...future.result
[10:34:09.344] }
[10:34:09.347] MultisessionFuture started
[10:34:09.347] - Launch lazy future ... done
[10:34:09.347] run() for ‘MultisessionFuture’ ... done
[10:34:09.348] receiveMessageFromWorker() for ClusterFuture ...
[10:34:09.349] - Validating connection of MultisessionFuture
[10:34:09.349] - received message: FutureResult
[10:34:09.349] - Received FutureResult
[10:34:09.349] - Erased future from FutureRegistry
[10:34:09.349] result() for ClusterFuture ...
[10:34:09.349] - result already collected: FutureResult
[10:34:09.349] result() for ClusterFuture ... done
[10:34:09.350] signalConditions() ...
[10:34:09.350]  - include = ‘immediateCondition’
[10:34:09.350]  - exclude = 
[10:34:09.350]  - resignal = FALSE
[10:34:09.350]  - Number of conditions: 1
[10:34:09.350] signalConditions() ... done
[10:34:09.350] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:09.350] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = Inf ... DONE
- result = TRUE, recursive = FALSE ...
[10:34:09.350] getGlobalsAndPackages() ...
[10:34:09.350] Searching for globals...
[10:34:09.352] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:34:09.352] Searching for globals ... DONE
[10:34:09.352] Resolving globals: FALSE
[10:34:09.352] 
[10:34:09.352] 
[10:34:09.352] getGlobalsAndPackages() ... DONE
[10:34:09.352] run() for ‘Future’ ...
[10:34:09.353] - state: ‘created’
[10:34:09.353] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:09.366] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:09.366] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:09.366]   - Field: ‘node’
[10:34:09.366]   - Field: ‘label’
[10:34:09.367]   - Field: ‘local’
[10:34:09.367]   - Field: ‘owner’
[10:34:09.367]   - Field: ‘envir’
[10:34:09.367]   - Field: ‘workers’
[10:34:09.367]   - Field: ‘packages’
[10:34:09.367]   - Field: ‘gc’
[10:34:09.367]   - Field: ‘conditions’
[10:34:09.367]   - Field: ‘persistent’
[10:34:09.367]   - Field: ‘expr’
[10:34:09.367]   - Field: ‘uuid’
[10:34:09.367]   - Field: ‘seed’
[10:34:09.368]   - Field: ‘version’
[10:34:09.368]   - Field: ‘result’
[10:34:09.368]   - Field: ‘asynchronous’
[10:34:09.368]   - Field: ‘calls’
[10:34:09.368]   - Field: ‘globals’
[10:34:09.368]   - Field: ‘stdout’
[10:34:09.368]   - Field: ‘earlySignal’
[10:34:09.368]   - Field: ‘lazy’
[10:34:09.368]   - Field: ‘state’
[10:34:09.368] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:09.368] - Launch lazy future ...
[10:34:09.369] Packages needed by the future expression (n = 0): <none>
[10:34:09.369] Packages needed by future strategies (n = 0): <none>
[10:34:09.369] {
[10:34:09.369]     {
[10:34:09.369]         {
[10:34:09.369]             ...future.startTime <- base::Sys.time()
[10:34:09.369]             {
[10:34:09.369]                 {
[10:34:09.369]                   {
[10:34:09.369]                     {
[10:34:09.369]                       base::local({
[10:34:09.369]                         has_future <- base::requireNamespace("future", 
[10:34:09.369]                           quietly = TRUE)
[10:34:09.369]                         if (has_future) {
[10:34:09.369]                           ns <- base::getNamespace("future")
[10:34:09.369]                           version <- ns[[".package"]][["version"]]
[10:34:09.369]                           if (is.null(version)) 
[10:34:09.369]                             version <- utils::packageVersion("future")
[10:34:09.369]                         }
[10:34:09.369]                         else {
[10:34:09.369]                           version <- NULL
[10:34:09.369]                         }
[10:34:09.369]                         if (!has_future || version < "1.8.0") {
[10:34:09.369]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:09.369]                             "", base::R.version$version.string), 
[10:34:09.369]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:09.369]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:09.369]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:09.369]                               "release", "version")], collapse = " "), 
[10:34:09.369]                             hostname = base::Sys.info()[["nodename"]])
[10:34:09.369]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:09.369]                             info)
[10:34:09.369]                           info <- base::paste(info, collapse = "; ")
[10:34:09.369]                           if (!has_future) {
[10:34:09.369]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:09.369]                               info)
[10:34:09.369]                           }
[10:34:09.369]                           else {
[10:34:09.369]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:09.369]                               info, version)
[10:34:09.369]                           }
[10:34:09.369]                           base::stop(msg)
[10:34:09.369]                         }
[10:34:09.369]                       })
[10:34:09.369]                     }
[10:34:09.369]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:09.369]                     base::options(mc.cores = 1L)
[10:34:09.369]                   }
[10:34:09.369]                   ...future.strategy.old <- future::plan("list")
[10:34:09.369]                   options(future.plan = NULL)
[10:34:09.369]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:09.369]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:09.369]                 }
[10:34:09.369]                 ...future.workdir <- getwd()
[10:34:09.369]             }
[10:34:09.369]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:09.369]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:09.369]         }
[10:34:09.369]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:09.369]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:09.369]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:09.369]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:09.369]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:09.369]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:09.369]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:09.369]             base::names(...future.oldOptions))
[10:34:09.369]     }
[10:34:09.369]     if (FALSE) {
[10:34:09.369]     }
[10:34:09.369]     else {
[10:34:09.369]         if (TRUE) {
[10:34:09.369]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:09.369]                 open = "w")
[10:34:09.369]         }
[10:34:09.369]         else {
[10:34:09.369]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:09.369]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:09.369]         }
[10:34:09.369]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:09.369]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:09.369]             base::sink(type = "output", split = FALSE)
[10:34:09.369]             base::close(...future.stdout)
[10:34:09.369]         }, add = TRUE)
[10:34:09.369]     }
[10:34:09.369]     ...future.frame <- base::sys.nframe()
[10:34:09.369]     ...future.conditions <- base::list()
[10:34:09.369]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:09.369]     if (FALSE) {
[10:34:09.369]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:09.369]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:09.369]     }
[10:34:09.369]     ...future.result <- base::tryCatch({
[10:34:09.369]         base::withCallingHandlers({
[10:34:09.369]             ...future.value <- base::withVisible(base::local({
[10:34:09.369]                 ...future.makeSendCondition <- base::local({
[10:34:09.369]                   sendCondition <- NULL
[10:34:09.369]                   function(frame = 1L) {
[10:34:09.369]                     if (is.function(sendCondition)) 
[10:34:09.369]                       return(sendCondition)
[10:34:09.369]                     ns <- getNamespace("parallel")
[10:34:09.369]                     if (exists("sendData", mode = "function", 
[10:34:09.369]                       envir = ns)) {
[10:34:09.369]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:09.369]                         envir = ns)
[10:34:09.369]                       envir <- sys.frame(frame)
[10:34:09.369]                       master <- NULL
[10:34:09.369]                       while (!identical(envir, .GlobalEnv) && 
[10:34:09.369]                         !identical(envir, emptyenv())) {
[10:34:09.369]                         if (exists("master", mode = "list", envir = envir, 
[10:34:09.369]                           inherits = FALSE)) {
[10:34:09.369]                           master <- get("master", mode = "list", 
[10:34:09.369]                             envir = envir, inherits = FALSE)
[10:34:09.369]                           if (inherits(master, c("SOCKnode", 
[10:34:09.369]                             "SOCK0node"))) {
[10:34:09.369]                             sendCondition <<- function(cond) {
[10:34:09.369]                               data <- list(type = "VALUE", value = cond, 
[10:34:09.369]                                 success = TRUE)
[10:34:09.369]                               parallel_sendData(master, data)
[10:34:09.369]                             }
[10:34:09.369]                             return(sendCondition)
[10:34:09.369]                           }
[10:34:09.369]                         }
[10:34:09.369]                         frame <- frame + 1L
[10:34:09.369]                         envir <- sys.frame(frame)
[10:34:09.369]                       }
[10:34:09.369]                     }
[10:34:09.369]                     sendCondition <<- function(cond) NULL
[10:34:09.369]                   }
[10:34:09.369]                 })
[10:34:09.369]                 withCallingHandlers({
[10:34:09.369]                   {
[10:34:09.369]                     Sys.sleep(0.5)
[10:34:09.369]                     list(a = 1, b = 42L)
[10:34:09.369]                   }
[10:34:09.369]                 }, immediateCondition = function(cond) {
[10:34:09.369]                   sendCondition <- ...future.makeSendCondition()
[10:34:09.369]                   sendCondition(cond)
[10:34:09.369]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:09.369]                   {
[10:34:09.369]                     inherits <- base::inherits
[10:34:09.369]                     invokeRestart <- base::invokeRestart
[10:34:09.369]                     is.null <- base::is.null
[10:34:09.369]                     muffled <- FALSE
[10:34:09.369]                     if (inherits(cond, "message")) {
[10:34:09.369]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:09.369]                       if (muffled) 
[10:34:09.369]                         invokeRestart("muffleMessage")
[10:34:09.369]                     }
[10:34:09.369]                     else if (inherits(cond, "warning")) {
[10:34:09.369]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:09.369]                       if (muffled) 
[10:34:09.369]                         invokeRestart("muffleWarning")
[10:34:09.369]                     }
[10:34:09.369]                     else if (inherits(cond, "condition")) {
[10:34:09.369]                       if (!is.null(pattern)) {
[10:34:09.369]                         computeRestarts <- base::computeRestarts
[10:34:09.369]                         grepl <- base::grepl
[10:34:09.369]                         restarts <- computeRestarts(cond)
[10:34:09.369]                         for (restart in restarts) {
[10:34:09.369]                           name <- restart$name
[10:34:09.369]                           if (is.null(name)) 
[10:34:09.369]                             next
[10:34:09.369]                           if (!grepl(pattern, name)) 
[10:34:09.369]                             next
[10:34:09.369]                           invokeRestart(restart)
[10:34:09.369]                           muffled <- TRUE
[10:34:09.369]                           break
[10:34:09.369]                         }
[10:34:09.369]                       }
[10:34:09.369]                     }
[10:34:09.369]                     invisible(muffled)
[10:34:09.369]                   }
[10:34:09.369]                   muffleCondition(cond)
[10:34:09.369]                 })
[10:34:09.369]             }))
[10:34:09.369]             future::FutureResult(value = ...future.value$value, 
[10:34:09.369]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:09.369]                   ...future.rng), globalenv = if (FALSE) 
[10:34:09.369]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:09.369]                     ...future.globalenv.names))
[10:34:09.369]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:09.369]         }, condition = base::local({
[10:34:09.369]             c <- base::c
[10:34:09.369]             inherits <- base::inherits
[10:34:09.369]             invokeRestart <- base::invokeRestart
[10:34:09.369]             length <- base::length
[10:34:09.369]             list <- base::list
[10:34:09.369]             seq.int <- base::seq.int
[10:34:09.369]             signalCondition <- base::signalCondition
[10:34:09.369]             sys.calls <- base::sys.calls
[10:34:09.369]             `[[` <- base::`[[`
[10:34:09.369]             `+` <- base::`+`
[10:34:09.369]             `<<-` <- base::`<<-`
[10:34:09.369]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:09.369]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:09.369]                   3L)]
[10:34:09.369]             }
[10:34:09.369]             function(cond) {
[10:34:09.369]                 is_error <- inherits(cond, "error")
[10:34:09.369]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:09.369]                   NULL)
[10:34:09.369]                 if (is_error) {
[10:34:09.369]                   sessionInformation <- function() {
[10:34:09.369]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:09.369]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:09.369]                       search = base::search(), system = base::Sys.info())
[10:34:09.369]                   }
[10:34:09.369]                   ...future.conditions[[length(...future.conditions) + 
[10:34:09.369]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:09.369]                     cond$call), session = sessionInformation(), 
[10:34:09.369]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:09.369]                   signalCondition(cond)
[10:34:09.369]                 }
[10:34:09.369]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:09.369]                 "immediateCondition"))) {
[10:34:09.369]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:09.369]                   ...future.conditions[[length(...future.conditions) + 
[10:34:09.369]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:09.369]                   if (TRUE && !signal) {
[10:34:09.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:09.369]                     {
[10:34:09.369]                       inherits <- base::inherits
[10:34:09.369]                       invokeRestart <- base::invokeRestart
[10:34:09.369]                       is.null <- base::is.null
[10:34:09.369]                       muffled <- FALSE
[10:34:09.369]                       if (inherits(cond, "message")) {
[10:34:09.369]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:09.369]                         if (muffled) 
[10:34:09.369]                           invokeRestart("muffleMessage")
[10:34:09.369]                       }
[10:34:09.369]                       else if (inherits(cond, "warning")) {
[10:34:09.369]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:09.369]                         if (muffled) 
[10:34:09.369]                           invokeRestart("muffleWarning")
[10:34:09.369]                       }
[10:34:09.369]                       else if (inherits(cond, "condition")) {
[10:34:09.369]                         if (!is.null(pattern)) {
[10:34:09.369]                           computeRestarts <- base::computeRestarts
[10:34:09.369]                           grepl <- base::grepl
[10:34:09.369]                           restarts <- computeRestarts(cond)
[10:34:09.369]                           for (restart in restarts) {
[10:34:09.369]                             name <- restart$name
[10:34:09.369]                             if (is.null(name)) 
[10:34:09.369]                               next
[10:34:09.369]                             if (!grepl(pattern, name)) 
[10:34:09.369]                               next
[10:34:09.369]                             invokeRestart(restart)
[10:34:09.369]                             muffled <- TRUE
[10:34:09.369]                             break
[10:34:09.369]                           }
[10:34:09.369]                         }
[10:34:09.369]                       }
[10:34:09.369]                       invisible(muffled)
[10:34:09.369]                     }
[10:34:09.369]                     muffleCondition(cond, pattern = "^muffle")
[10:34:09.369]                   }
[10:34:09.369]                 }
[10:34:09.369]                 else {
[10:34:09.369]                   if (TRUE) {
[10:34:09.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:09.369]                     {
[10:34:09.369]                       inherits <- base::inherits
[10:34:09.369]                       invokeRestart <- base::invokeRestart
[10:34:09.369]                       is.null <- base::is.null
[10:34:09.369]                       muffled <- FALSE
[10:34:09.369]                       if (inherits(cond, "message")) {
[10:34:09.369]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:09.369]                         if (muffled) 
[10:34:09.369]                           invokeRestart("muffleMessage")
[10:34:09.369]                       }
[10:34:09.369]                       else if (inherits(cond, "warning")) {
[10:34:09.369]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:09.369]                         if (muffled) 
[10:34:09.369]                           invokeRestart("muffleWarning")
[10:34:09.369]                       }
[10:34:09.369]                       else if (inherits(cond, "condition")) {
[10:34:09.369]                         if (!is.null(pattern)) {
[10:34:09.369]                           computeRestarts <- base::computeRestarts
[10:34:09.369]                           grepl <- base::grepl
[10:34:09.369]                           restarts <- computeRestarts(cond)
[10:34:09.369]                           for (restart in restarts) {
[10:34:09.369]                             name <- restart$name
[10:34:09.369]                             if (is.null(name)) 
[10:34:09.369]                               next
[10:34:09.369]                             if (!grepl(pattern, name)) 
[10:34:09.369]                               next
[10:34:09.369]                             invokeRestart(restart)
[10:34:09.369]                             muffled <- TRUE
[10:34:09.369]                             break
[10:34:09.369]                           }
[10:34:09.369]                         }
[10:34:09.369]                       }
[10:34:09.369]                       invisible(muffled)
[10:34:09.369]                     }
[10:34:09.369]                     muffleCondition(cond, pattern = "^muffle")
[10:34:09.369]                   }
[10:34:09.369]                 }
[10:34:09.369]             }
[10:34:09.369]         }))
[10:34:09.369]     }, error = function(ex) {
[10:34:09.369]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:09.369]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:09.369]                 ...future.rng), started = ...future.startTime, 
[10:34:09.369]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:09.369]             version = "1.8"), class = "FutureResult")
[10:34:09.369]     }, finally = {
[10:34:09.369]         if (!identical(...future.workdir, getwd())) 
[10:34:09.369]             setwd(...future.workdir)
[10:34:09.369]         {
[10:34:09.369]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:09.369]                 ...future.oldOptions$nwarnings <- NULL
[10:34:09.369]             }
[10:34:09.369]             base::options(...future.oldOptions)
[10:34:09.369]             if (.Platform$OS.type == "windows") {
[10:34:09.369]                 old_names <- names(...future.oldEnvVars)
[10:34:09.369]                 envs <- base::Sys.getenv()
[10:34:09.369]                 names <- names(envs)
[10:34:09.369]                 common <- intersect(names, old_names)
[10:34:09.369]                 added <- setdiff(names, old_names)
[10:34:09.369]                 removed <- setdiff(old_names, names)
[10:34:09.369]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:09.369]                   envs[common]]
[10:34:09.369]                 NAMES <- toupper(changed)
[10:34:09.369]                 args <- list()
[10:34:09.369]                 for (kk in seq_along(NAMES)) {
[10:34:09.369]                   name <- changed[[kk]]
[10:34:09.369]                   NAME <- NAMES[[kk]]
[10:34:09.369]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:09.369]                     next
[10:34:09.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:09.369]                 }
[10:34:09.369]                 NAMES <- toupper(added)
[10:34:09.369]                 for (kk in seq_along(NAMES)) {
[10:34:09.369]                   name <- added[[kk]]
[10:34:09.369]                   NAME <- NAMES[[kk]]
[10:34:09.369]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:09.369]                     next
[10:34:09.369]                   args[[name]] <- ""
[10:34:09.369]                 }
[10:34:09.369]                 NAMES <- toupper(removed)
[10:34:09.369]                 for (kk in seq_along(NAMES)) {
[10:34:09.369]                   name <- removed[[kk]]
[10:34:09.369]                   NAME <- NAMES[[kk]]
[10:34:09.369]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:09.369]                     next
[10:34:09.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:09.369]                 }
[10:34:09.369]                 if (length(args) > 0) 
[10:34:09.369]                   base::do.call(base::Sys.setenv, args = args)
[10:34:09.369]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:09.369]             }
[10:34:09.369]             else {
[10:34:09.369]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:09.369]             }
[10:34:09.369]             {
[10:34:09.369]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:09.369]                   0L) {
[10:34:09.369]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:09.369]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:09.369]                   base::options(opts)
[10:34:09.369]                 }
[10:34:09.369]                 {
[10:34:09.369]                   {
[10:34:09.369]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:09.369]                     NULL
[10:34:09.369]                   }
[10:34:09.369]                   options(future.plan = NULL)
[10:34:09.369]                   if (is.na(NA_character_)) 
[10:34:09.369]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:09.369]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:09.369]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:09.369]                     .init = FALSE)
[10:34:09.369]                 }
[10:34:09.369]             }
[10:34:09.369]         }
[10:34:09.369]     })
[10:34:09.369]     if (TRUE) {
[10:34:09.369]         base::sink(type = "output", split = FALSE)
[10:34:09.369]         if (TRUE) {
[10:34:09.369]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:09.369]         }
[10:34:09.369]         else {
[10:34:09.369]             ...future.result["stdout"] <- base::list(NULL)
[10:34:09.369]         }
[10:34:09.369]         base::close(...future.stdout)
[10:34:09.369]         ...future.stdout <- NULL
[10:34:09.369]     }
[10:34:09.369]     ...future.result$conditions <- ...future.conditions
[10:34:09.369]     ...future.result$finished <- base::Sys.time()
[10:34:09.369]     ...future.result
[10:34:09.369] }
[10:34:09.372] MultisessionFuture started
[10:34:09.372] - Launch lazy future ... done
[10:34:09.372] run() for ‘MultisessionFuture’ ... done
[10:34:09.874] receiveMessageFromWorker() for ClusterFuture ...
[10:34:09.875] - Validating connection of MultisessionFuture
[10:34:09.875] - received message: FutureResult
[10:34:09.875] - Received FutureResult
[10:34:09.875] - Erased future from FutureRegistry
[10:34:09.875] result() for ClusterFuture ...
[10:34:09.875] - result already collected: FutureResult
[10:34:09.876] result() for ClusterFuture ... done
[10:34:09.876] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:09.876] A MultisessionFuture was resolved
[10:34:09.876] getGlobalsAndPackages() ...
[10:34:09.876] Searching for globals...
[10:34:09.877] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:34:09.877] Searching for globals ... DONE
[10:34:09.877] Resolving globals: FALSE
[10:34:09.878] 
[10:34:09.878] 
[10:34:09.878] getGlobalsAndPackages() ... DONE
[10:34:09.878] run() for ‘Future’ ...
[10:34:09.878] - state: ‘created’
[10:34:09.878] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:09.892] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:09.893] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:09.893]   - Field: ‘node’
[10:34:09.893]   - Field: ‘label’
[10:34:09.893]   - Field: ‘local’
[10:34:09.893]   - Field: ‘owner’
[10:34:09.893]   - Field: ‘envir’
[10:34:09.893]   - Field: ‘workers’
[10:34:09.893]   - Field: ‘packages’
[10:34:09.893]   - Field: ‘gc’
[10:34:09.894]   - Field: ‘conditions’
[10:34:09.894]   - Field: ‘persistent’
[10:34:09.894]   - Field: ‘expr’
[10:34:09.894]   - Field: ‘uuid’
[10:34:09.894]   - Field: ‘seed’
[10:34:09.894]   - Field: ‘version’
[10:34:09.894]   - Field: ‘result’
[10:34:09.894]   - Field: ‘asynchronous’
[10:34:09.894]   - Field: ‘calls’
[10:34:09.894]   - Field: ‘globals’
[10:34:09.894]   - Field: ‘stdout’
[10:34:09.894]   - Field: ‘earlySignal’
[10:34:09.895]   - Field: ‘lazy’
[10:34:09.895]   - Field: ‘state’
[10:34:09.895] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:09.895] - Launch lazy future ...
[10:34:09.897] Packages needed by the future expression (n = 0): <none>
[10:34:09.897] Packages needed by future strategies (n = 0): <none>
[10:34:09.898] {
[10:34:09.898]     {
[10:34:09.898]         {
[10:34:09.898]             ...future.startTime <- base::Sys.time()
[10:34:09.898]             {
[10:34:09.898]                 {
[10:34:09.898]                   {
[10:34:09.898]                     {
[10:34:09.898]                       base::local({
[10:34:09.898]                         has_future <- base::requireNamespace("future", 
[10:34:09.898]                           quietly = TRUE)
[10:34:09.898]                         if (has_future) {
[10:34:09.898]                           ns <- base::getNamespace("future")
[10:34:09.898]                           version <- ns[[".package"]][["version"]]
[10:34:09.898]                           if (is.null(version)) 
[10:34:09.898]                             version <- utils::packageVersion("future")
[10:34:09.898]                         }
[10:34:09.898]                         else {
[10:34:09.898]                           version <- NULL
[10:34:09.898]                         }
[10:34:09.898]                         if (!has_future || version < "1.8.0") {
[10:34:09.898]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:09.898]                             "", base::R.version$version.string), 
[10:34:09.898]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:09.898]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:09.898]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:09.898]                               "release", "version")], collapse = " "), 
[10:34:09.898]                             hostname = base::Sys.info()[["nodename"]])
[10:34:09.898]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:09.898]                             info)
[10:34:09.898]                           info <- base::paste(info, collapse = "; ")
[10:34:09.898]                           if (!has_future) {
[10:34:09.898]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:09.898]                               info)
[10:34:09.898]                           }
[10:34:09.898]                           else {
[10:34:09.898]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:09.898]                               info, version)
[10:34:09.898]                           }
[10:34:09.898]                           base::stop(msg)
[10:34:09.898]                         }
[10:34:09.898]                       })
[10:34:09.898]                     }
[10:34:09.898]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:09.898]                     base::options(mc.cores = 1L)
[10:34:09.898]                   }
[10:34:09.898]                   ...future.strategy.old <- future::plan("list")
[10:34:09.898]                   options(future.plan = NULL)
[10:34:09.898]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:09.898]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:09.898]                 }
[10:34:09.898]                 ...future.workdir <- getwd()
[10:34:09.898]             }
[10:34:09.898]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:09.898]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:09.898]         }
[10:34:09.898]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:09.898]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:09.898]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:09.898]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:09.898]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:09.898]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:09.898]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:09.898]             base::names(...future.oldOptions))
[10:34:09.898]     }
[10:34:09.898]     if (FALSE) {
[10:34:09.898]     }
[10:34:09.898]     else {
[10:34:09.898]         if (TRUE) {
[10:34:09.898]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:09.898]                 open = "w")
[10:34:09.898]         }
[10:34:09.898]         else {
[10:34:09.898]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:09.898]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:09.898]         }
[10:34:09.898]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:09.898]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:09.898]             base::sink(type = "output", split = FALSE)
[10:34:09.898]             base::close(...future.stdout)
[10:34:09.898]         }, add = TRUE)
[10:34:09.898]     }
[10:34:09.898]     ...future.frame <- base::sys.nframe()
[10:34:09.898]     ...future.conditions <- base::list()
[10:34:09.898]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:09.898]     if (FALSE) {
[10:34:09.898]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:09.898]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:09.898]     }
[10:34:09.898]     ...future.result <- base::tryCatch({
[10:34:09.898]         base::withCallingHandlers({
[10:34:09.898]             ...future.value <- base::withVisible(base::local({
[10:34:09.898]                 ...future.makeSendCondition <- base::local({
[10:34:09.898]                   sendCondition <- NULL
[10:34:09.898]                   function(frame = 1L) {
[10:34:09.898]                     if (is.function(sendCondition)) 
[10:34:09.898]                       return(sendCondition)
[10:34:09.898]                     ns <- getNamespace("parallel")
[10:34:09.898]                     if (exists("sendData", mode = "function", 
[10:34:09.898]                       envir = ns)) {
[10:34:09.898]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:09.898]                         envir = ns)
[10:34:09.898]                       envir <- sys.frame(frame)
[10:34:09.898]                       master <- NULL
[10:34:09.898]                       while (!identical(envir, .GlobalEnv) && 
[10:34:09.898]                         !identical(envir, emptyenv())) {
[10:34:09.898]                         if (exists("master", mode = "list", envir = envir, 
[10:34:09.898]                           inherits = FALSE)) {
[10:34:09.898]                           master <- get("master", mode = "list", 
[10:34:09.898]                             envir = envir, inherits = FALSE)
[10:34:09.898]                           if (inherits(master, c("SOCKnode", 
[10:34:09.898]                             "SOCK0node"))) {
[10:34:09.898]                             sendCondition <<- function(cond) {
[10:34:09.898]                               data <- list(type = "VALUE", value = cond, 
[10:34:09.898]                                 success = TRUE)
[10:34:09.898]                               parallel_sendData(master, data)
[10:34:09.898]                             }
[10:34:09.898]                             return(sendCondition)
[10:34:09.898]                           }
[10:34:09.898]                         }
[10:34:09.898]                         frame <- frame + 1L
[10:34:09.898]                         envir <- sys.frame(frame)
[10:34:09.898]                       }
[10:34:09.898]                     }
[10:34:09.898]                     sendCondition <<- function(cond) NULL
[10:34:09.898]                   }
[10:34:09.898]                 })
[10:34:09.898]                 withCallingHandlers({
[10:34:09.898]                   {
[10:34:09.898]                     Sys.sleep(0.5)
[10:34:09.898]                     list(a = 1, b = 42L)
[10:34:09.898]                   }
[10:34:09.898]                 }, immediateCondition = function(cond) {
[10:34:09.898]                   sendCondition <- ...future.makeSendCondition()
[10:34:09.898]                   sendCondition(cond)
[10:34:09.898]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:09.898]                   {
[10:34:09.898]                     inherits <- base::inherits
[10:34:09.898]                     invokeRestart <- base::invokeRestart
[10:34:09.898]                     is.null <- base::is.null
[10:34:09.898]                     muffled <- FALSE
[10:34:09.898]                     if (inherits(cond, "message")) {
[10:34:09.898]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:09.898]                       if (muffled) 
[10:34:09.898]                         invokeRestart("muffleMessage")
[10:34:09.898]                     }
[10:34:09.898]                     else if (inherits(cond, "warning")) {
[10:34:09.898]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:09.898]                       if (muffled) 
[10:34:09.898]                         invokeRestart("muffleWarning")
[10:34:09.898]                     }
[10:34:09.898]                     else if (inherits(cond, "condition")) {
[10:34:09.898]                       if (!is.null(pattern)) {
[10:34:09.898]                         computeRestarts <- base::computeRestarts
[10:34:09.898]                         grepl <- base::grepl
[10:34:09.898]                         restarts <- computeRestarts(cond)
[10:34:09.898]                         for (restart in restarts) {
[10:34:09.898]                           name <- restart$name
[10:34:09.898]                           if (is.null(name)) 
[10:34:09.898]                             next
[10:34:09.898]                           if (!grepl(pattern, name)) 
[10:34:09.898]                             next
[10:34:09.898]                           invokeRestart(restart)
[10:34:09.898]                           muffled <- TRUE
[10:34:09.898]                           break
[10:34:09.898]                         }
[10:34:09.898]                       }
[10:34:09.898]                     }
[10:34:09.898]                     invisible(muffled)
[10:34:09.898]                   }
[10:34:09.898]                   muffleCondition(cond)
[10:34:09.898]                 })
[10:34:09.898]             }))
[10:34:09.898]             future::FutureResult(value = ...future.value$value, 
[10:34:09.898]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:09.898]                   ...future.rng), globalenv = if (FALSE) 
[10:34:09.898]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:09.898]                     ...future.globalenv.names))
[10:34:09.898]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:09.898]         }, condition = base::local({
[10:34:09.898]             c <- base::c
[10:34:09.898]             inherits <- base::inherits
[10:34:09.898]             invokeRestart <- base::invokeRestart
[10:34:09.898]             length <- base::length
[10:34:09.898]             list <- base::list
[10:34:09.898]             seq.int <- base::seq.int
[10:34:09.898]             signalCondition <- base::signalCondition
[10:34:09.898]             sys.calls <- base::sys.calls
[10:34:09.898]             `[[` <- base::`[[`
[10:34:09.898]             `+` <- base::`+`
[10:34:09.898]             `<<-` <- base::`<<-`
[10:34:09.898]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:09.898]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:09.898]                   3L)]
[10:34:09.898]             }
[10:34:09.898]             function(cond) {
[10:34:09.898]                 is_error <- inherits(cond, "error")
[10:34:09.898]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:09.898]                   NULL)
[10:34:09.898]                 if (is_error) {
[10:34:09.898]                   sessionInformation <- function() {
[10:34:09.898]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:09.898]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:09.898]                       search = base::search(), system = base::Sys.info())
[10:34:09.898]                   }
[10:34:09.898]                   ...future.conditions[[length(...future.conditions) + 
[10:34:09.898]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:09.898]                     cond$call), session = sessionInformation(), 
[10:34:09.898]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:09.898]                   signalCondition(cond)
[10:34:09.898]                 }
[10:34:09.898]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:09.898]                 "immediateCondition"))) {
[10:34:09.898]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:09.898]                   ...future.conditions[[length(...future.conditions) + 
[10:34:09.898]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:09.898]                   if (TRUE && !signal) {
[10:34:09.898]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:09.898]                     {
[10:34:09.898]                       inherits <- base::inherits
[10:34:09.898]                       invokeRestart <- base::invokeRestart
[10:34:09.898]                       is.null <- base::is.null
[10:34:09.898]                       muffled <- FALSE
[10:34:09.898]                       if (inherits(cond, "message")) {
[10:34:09.898]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:09.898]                         if (muffled) 
[10:34:09.898]                           invokeRestart("muffleMessage")
[10:34:09.898]                       }
[10:34:09.898]                       else if (inherits(cond, "warning")) {
[10:34:09.898]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:09.898]                         if (muffled) 
[10:34:09.898]                           invokeRestart("muffleWarning")
[10:34:09.898]                       }
[10:34:09.898]                       else if (inherits(cond, "condition")) {
[10:34:09.898]                         if (!is.null(pattern)) {
[10:34:09.898]                           computeRestarts <- base::computeRestarts
[10:34:09.898]                           grepl <- base::grepl
[10:34:09.898]                           restarts <- computeRestarts(cond)
[10:34:09.898]                           for (restart in restarts) {
[10:34:09.898]                             name <- restart$name
[10:34:09.898]                             if (is.null(name)) 
[10:34:09.898]                               next
[10:34:09.898]                             if (!grepl(pattern, name)) 
[10:34:09.898]                               next
[10:34:09.898]                             invokeRestart(restart)
[10:34:09.898]                             muffled <- TRUE
[10:34:09.898]                             break
[10:34:09.898]                           }
[10:34:09.898]                         }
[10:34:09.898]                       }
[10:34:09.898]                       invisible(muffled)
[10:34:09.898]                     }
[10:34:09.898]                     muffleCondition(cond, pattern = "^muffle")
[10:34:09.898]                   }
[10:34:09.898]                 }
[10:34:09.898]                 else {
[10:34:09.898]                   if (TRUE) {
[10:34:09.898]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:09.898]                     {
[10:34:09.898]                       inherits <- base::inherits
[10:34:09.898]                       invokeRestart <- base::invokeRestart
[10:34:09.898]                       is.null <- base::is.null
[10:34:09.898]                       muffled <- FALSE
[10:34:09.898]                       if (inherits(cond, "message")) {
[10:34:09.898]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:09.898]                         if (muffled) 
[10:34:09.898]                           invokeRestart("muffleMessage")
[10:34:09.898]                       }
[10:34:09.898]                       else if (inherits(cond, "warning")) {
[10:34:09.898]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:09.898]                         if (muffled) 
[10:34:09.898]                           invokeRestart("muffleWarning")
[10:34:09.898]                       }
[10:34:09.898]                       else if (inherits(cond, "condition")) {
[10:34:09.898]                         if (!is.null(pattern)) {
[10:34:09.898]                           computeRestarts <- base::computeRestarts
[10:34:09.898]                           grepl <- base::grepl
[10:34:09.898]                           restarts <- computeRestarts(cond)
[10:34:09.898]                           for (restart in restarts) {
[10:34:09.898]                             name <- restart$name
[10:34:09.898]                             if (is.null(name)) 
[10:34:09.898]                               next
[10:34:09.898]                             if (!grepl(pattern, name)) 
[10:34:09.898]                               next
[10:34:09.898]                             invokeRestart(restart)
[10:34:09.898]                             muffled <- TRUE
[10:34:09.898]                             break
[10:34:09.898]                           }
[10:34:09.898]                         }
[10:34:09.898]                       }
[10:34:09.898]                       invisible(muffled)
[10:34:09.898]                     }
[10:34:09.898]                     muffleCondition(cond, pattern = "^muffle")
[10:34:09.898]                   }
[10:34:09.898]                 }
[10:34:09.898]             }
[10:34:09.898]         }))
[10:34:09.898]     }, error = function(ex) {
[10:34:09.898]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:09.898]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:09.898]                 ...future.rng), started = ...future.startTime, 
[10:34:09.898]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:09.898]             version = "1.8"), class = "FutureResult")
[10:34:09.898]     }, finally = {
[10:34:09.898]         if (!identical(...future.workdir, getwd())) 
[10:34:09.898]             setwd(...future.workdir)
[10:34:09.898]         {
[10:34:09.898]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:09.898]                 ...future.oldOptions$nwarnings <- NULL
[10:34:09.898]             }
[10:34:09.898]             base::options(...future.oldOptions)
[10:34:09.898]             if (.Platform$OS.type == "windows") {
[10:34:09.898]                 old_names <- names(...future.oldEnvVars)
[10:34:09.898]                 envs <- base::Sys.getenv()
[10:34:09.898]                 names <- names(envs)
[10:34:09.898]                 common <- intersect(names, old_names)
[10:34:09.898]                 added <- setdiff(names, old_names)
[10:34:09.898]                 removed <- setdiff(old_names, names)
[10:34:09.898]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:09.898]                   envs[common]]
[10:34:09.898]                 NAMES <- toupper(changed)
[10:34:09.898]                 args <- list()
[10:34:09.898]                 for (kk in seq_along(NAMES)) {
[10:34:09.898]                   name <- changed[[kk]]
[10:34:09.898]                   NAME <- NAMES[[kk]]
[10:34:09.898]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:09.898]                     next
[10:34:09.898]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:09.898]                 }
[10:34:09.898]                 NAMES <- toupper(added)
[10:34:09.898]                 for (kk in seq_along(NAMES)) {
[10:34:09.898]                   name <- added[[kk]]
[10:34:09.898]                   NAME <- NAMES[[kk]]
[10:34:09.898]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:09.898]                     next
[10:34:09.898]                   args[[name]] <- ""
[10:34:09.898]                 }
[10:34:09.898]                 NAMES <- toupper(removed)
[10:34:09.898]                 for (kk in seq_along(NAMES)) {
[10:34:09.898]                   name <- removed[[kk]]
[10:34:09.898]                   NAME <- NAMES[[kk]]
[10:34:09.898]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:09.898]                     next
[10:34:09.898]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:09.898]                 }
[10:34:09.898]                 if (length(args) > 0) 
[10:34:09.898]                   base::do.call(base::Sys.setenv, args = args)
[10:34:09.898]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:09.898]             }
[10:34:09.898]             else {
[10:34:09.898]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:09.898]             }
[10:34:09.898]             {
[10:34:09.898]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:09.898]                   0L) {
[10:34:09.898]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:09.898]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:09.898]                   base::options(opts)
[10:34:09.898]                 }
[10:34:09.898]                 {
[10:34:09.898]                   {
[10:34:09.898]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:09.898]                     NULL
[10:34:09.898]                   }
[10:34:09.898]                   options(future.plan = NULL)
[10:34:09.898]                   if (is.na(NA_character_)) 
[10:34:09.898]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:09.898]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:09.898]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:09.898]                     .init = FALSE)
[10:34:09.898]                 }
[10:34:09.898]             }
[10:34:09.898]         }
[10:34:09.898]     })
[10:34:09.898]     if (TRUE) {
[10:34:09.898]         base::sink(type = "output", split = FALSE)
[10:34:09.898]         if (TRUE) {
[10:34:09.898]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:09.898]         }
[10:34:09.898]         else {
[10:34:09.898]             ...future.result["stdout"] <- base::list(NULL)
[10:34:09.898]         }
[10:34:09.898]         base::close(...future.stdout)
[10:34:09.898]         ...future.stdout <- NULL
[10:34:09.898]     }
[10:34:09.898]     ...future.result$conditions <- ...future.conditions
[10:34:09.898]     ...future.result$finished <- base::Sys.time()
[10:34:09.898]     ...future.result
[10:34:09.898] }
[10:34:09.901] MultisessionFuture started
[10:34:09.901] - Launch lazy future ... done
[10:34:09.901] run() for ‘MultisessionFuture’ ... done
[10:34:10.403] receiveMessageFromWorker() for ClusterFuture ...
[10:34:10.403] - Validating connection of MultisessionFuture
[10:34:10.404] - received message: FutureResult
[10:34:10.404] - Received FutureResult
[10:34:10.404] - Erased future from FutureRegistry
[10:34:10.404] result() for ClusterFuture ...
[10:34:10.404] - result already collected: FutureResult
[10:34:10.404] result() for ClusterFuture ... done
[10:34:10.404] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:10.405] A MultisessionFuture was resolved
- w/ exception ...
[10:34:10.405] getGlobalsAndPackages() ...
[10:34:10.405] Searching for globals...
[10:34:10.406] - globals found: [2] ‘list’, ‘stop’
[10:34:10.406] Searching for globals ... DONE
[10:34:10.406] Resolving globals: FALSE
[10:34:10.406] 
[10:34:10.407] 
[10:34:10.407] getGlobalsAndPackages() ... DONE
[10:34:10.407] run() for ‘Future’ ...
[10:34:10.407] - state: ‘created’
[10:34:10.407] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:10.423] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:10.423] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:10.423]   - Field: ‘node’
[10:34:10.423]   - Field: ‘label’
[10:34:10.423]   - Field: ‘local’
[10:34:10.424]   - Field: ‘owner’
[10:34:10.424]   - Field: ‘envir’
[10:34:10.424]   - Field: ‘workers’
[10:34:10.424]   - Field: ‘packages’
[10:34:10.424]   - Field: ‘gc’
[10:34:10.424]   - Field: ‘conditions’
[10:34:10.424]   - Field: ‘persistent’
[10:34:10.424]   - Field: ‘expr’
[10:34:10.424]   - Field: ‘uuid’
[10:34:10.424]   - Field: ‘seed’
[10:34:10.425]   - Field: ‘version’
[10:34:10.425]   - Field: ‘result’
[10:34:10.425]   - Field: ‘asynchronous’
[10:34:10.425]   - Field: ‘calls’
[10:34:10.425]   - Field: ‘globals’
[10:34:10.425]   - Field: ‘stdout’
[10:34:10.425]   - Field: ‘earlySignal’
[10:34:10.425]   - Field: ‘lazy’
[10:34:10.426]   - Field: ‘state’
[10:34:10.426] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:10.426] - Launch lazy future ...
[10:34:10.426] Packages needed by the future expression (n = 0): <none>
[10:34:10.426] Packages needed by future strategies (n = 0): <none>
[10:34:10.427] {
[10:34:10.427]     {
[10:34:10.427]         {
[10:34:10.427]             ...future.startTime <- base::Sys.time()
[10:34:10.427]             {
[10:34:10.427]                 {
[10:34:10.427]                   {
[10:34:10.427]                     {
[10:34:10.427]                       base::local({
[10:34:10.427]                         has_future <- base::requireNamespace("future", 
[10:34:10.427]                           quietly = TRUE)
[10:34:10.427]                         if (has_future) {
[10:34:10.427]                           ns <- base::getNamespace("future")
[10:34:10.427]                           version <- ns[[".package"]][["version"]]
[10:34:10.427]                           if (is.null(version)) 
[10:34:10.427]                             version <- utils::packageVersion("future")
[10:34:10.427]                         }
[10:34:10.427]                         else {
[10:34:10.427]                           version <- NULL
[10:34:10.427]                         }
[10:34:10.427]                         if (!has_future || version < "1.8.0") {
[10:34:10.427]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:10.427]                             "", base::R.version$version.string), 
[10:34:10.427]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:10.427]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:10.427]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:10.427]                               "release", "version")], collapse = " "), 
[10:34:10.427]                             hostname = base::Sys.info()[["nodename"]])
[10:34:10.427]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:10.427]                             info)
[10:34:10.427]                           info <- base::paste(info, collapse = "; ")
[10:34:10.427]                           if (!has_future) {
[10:34:10.427]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:10.427]                               info)
[10:34:10.427]                           }
[10:34:10.427]                           else {
[10:34:10.427]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:10.427]                               info, version)
[10:34:10.427]                           }
[10:34:10.427]                           base::stop(msg)
[10:34:10.427]                         }
[10:34:10.427]                       })
[10:34:10.427]                     }
[10:34:10.427]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:10.427]                     base::options(mc.cores = 1L)
[10:34:10.427]                   }
[10:34:10.427]                   ...future.strategy.old <- future::plan("list")
[10:34:10.427]                   options(future.plan = NULL)
[10:34:10.427]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:10.427]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:10.427]                 }
[10:34:10.427]                 ...future.workdir <- getwd()
[10:34:10.427]             }
[10:34:10.427]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:10.427]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:10.427]         }
[10:34:10.427]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:10.427]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:10.427]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:10.427]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:10.427]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:10.427]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:10.427]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:10.427]             base::names(...future.oldOptions))
[10:34:10.427]     }
[10:34:10.427]     if (FALSE) {
[10:34:10.427]     }
[10:34:10.427]     else {
[10:34:10.427]         if (TRUE) {
[10:34:10.427]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:10.427]                 open = "w")
[10:34:10.427]         }
[10:34:10.427]         else {
[10:34:10.427]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:10.427]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:10.427]         }
[10:34:10.427]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:10.427]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:10.427]             base::sink(type = "output", split = FALSE)
[10:34:10.427]             base::close(...future.stdout)
[10:34:10.427]         }, add = TRUE)
[10:34:10.427]     }
[10:34:10.427]     ...future.frame <- base::sys.nframe()
[10:34:10.427]     ...future.conditions <- base::list()
[10:34:10.427]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:10.427]     if (FALSE) {
[10:34:10.427]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:10.427]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:10.427]     }
[10:34:10.427]     ...future.result <- base::tryCatch({
[10:34:10.427]         base::withCallingHandlers({
[10:34:10.427]             ...future.value <- base::withVisible(base::local({
[10:34:10.427]                 ...future.makeSendCondition <- base::local({
[10:34:10.427]                   sendCondition <- NULL
[10:34:10.427]                   function(frame = 1L) {
[10:34:10.427]                     if (is.function(sendCondition)) 
[10:34:10.427]                       return(sendCondition)
[10:34:10.427]                     ns <- getNamespace("parallel")
[10:34:10.427]                     if (exists("sendData", mode = "function", 
[10:34:10.427]                       envir = ns)) {
[10:34:10.427]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:10.427]                         envir = ns)
[10:34:10.427]                       envir <- sys.frame(frame)
[10:34:10.427]                       master <- NULL
[10:34:10.427]                       while (!identical(envir, .GlobalEnv) && 
[10:34:10.427]                         !identical(envir, emptyenv())) {
[10:34:10.427]                         if (exists("master", mode = "list", envir = envir, 
[10:34:10.427]                           inherits = FALSE)) {
[10:34:10.427]                           master <- get("master", mode = "list", 
[10:34:10.427]                             envir = envir, inherits = FALSE)
[10:34:10.427]                           if (inherits(master, c("SOCKnode", 
[10:34:10.427]                             "SOCK0node"))) {
[10:34:10.427]                             sendCondition <<- function(cond) {
[10:34:10.427]                               data <- list(type = "VALUE", value = cond, 
[10:34:10.427]                                 success = TRUE)
[10:34:10.427]                               parallel_sendData(master, data)
[10:34:10.427]                             }
[10:34:10.427]                             return(sendCondition)
[10:34:10.427]                           }
[10:34:10.427]                         }
[10:34:10.427]                         frame <- frame + 1L
[10:34:10.427]                         envir <- sys.frame(frame)
[10:34:10.427]                       }
[10:34:10.427]                     }
[10:34:10.427]                     sendCondition <<- function(cond) NULL
[10:34:10.427]                   }
[10:34:10.427]                 })
[10:34:10.427]                 withCallingHandlers({
[10:34:10.427]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:34:10.427]                 }, immediateCondition = function(cond) {
[10:34:10.427]                   sendCondition <- ...future.makeSendCondition()
[10:34:10.427]                   sendCondition(cond)
[10:34:10.427]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:10.427]                   {
[10:34:10.427]                     inherits <- base::inherits
[10:34:10.427]                     invokeRestart <- base::invokeRestart
[10:34:10.427]                     is.null <- base::is.null
[10:34:10.427]                     muffled <- FALSE
[10:34:10.427]                     if (inherits(cond, "message")) {
[10:34:10.427]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:10.427]                       if (muffled) 
[10:34:10.427]                         invokeRestart("muffleMessage")
[10:34:10.427]                     }
[10:34:10.427]                     else if (inherits(cond, "warning")) {
[10:34:10.427]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:10.427]                       if (muffled) 
[10:34:10.427]                         invokeRestart("muffleWarning")
[10:34:10.427]                     }
[10:34:10.427]                     else if (inherits(cond, "condition")) {
[10:34:10.427]                       if (!is.null(pattern)) {
[10:34:10.427]                         computeRestarts <- base::computeRestarts
[10:34:10.427]                         grepl <- base::grepl
[10:34:10.427]                         restarts <- computeRestarts(cond)
[10:34:10.427]                         for (restart in restarts) {
[10:34:10.427]                           name <- restart$name
[10:34:10.427]                           if (is.null(name)) 
[10:34:10.427]                             next
[10:34:10.427]                           if (!grepl(pattern, name)) 
[10:34:10.427]                             next
[10:34:10.427]                           invokeRestart(restart)
[10:34:10.427]                           muffled <- TRUE
[10:34:10.427]                           break
[10:34:10.427]                         }
[10:34:10.427]                       }
[10:34:10.427]                     }
[10:34:10.427]                     invisible(muffled)
[10:34:10.427]                   }
[10:34:10.427]                   muffleCondition(cond)
[10:34:10.427]                 })
[10:34:10.427]             }))
[10:34:10.427]             future::FutureResult(value = ...future.value$value, 
[10:34:10.427]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:10.427]                   ...future.rng), globalenv = if (FALSE) 
[10:34:10.427]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:10.427]                     ...future.globalenv.names))
[10:34:10.427]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:10.427]         }, condition = base::local({
[10:34:10.427]             c <- base::c
[10:34:10.427]             inherits <- base::inherits
[10:34:10.427]             invokeRestart <- base::invokeRestart
[10:34:10.427]             length <- base::length
[10:34:10.427]             list <- base::list
[10:34:10.427]             seq.int <- base::seq.int
[10:34:10.427]             signalCondition <- base::signalCondition
[10:34:10.427]             sys.calls <- base::sys.calls
[10:34:10.427]             `[[` <- base::`[[`
[10:34:10.427]             `+` <- base::`+`
[10:34:10.427]             `<<-` <- base::`<<-`
[10:34:10.427]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:10.427]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:10.427]                   3L)]
[10:34:10.427]             }
[10:34:10.427]             function(cond) {
[10:34:10.427]                 is_error <- inherits(cond, "error")
[10:34:10.427]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:10.427]                   NULL)
[10:34:10.427]                 if (is_error) {
[10:34:10.427]                   sessionInformation <- function() {
[10:34:10.427]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:10.427]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:10.427]                       search = base::search(), system = base::Sys.info())
[10:34:10.427]                   }
[10:34:10.427]                   ...future.conditions[[length(...future.conditions) + 
[10:34:10.427]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:10.427]                     cond$call), session = sessionInformation(), 
[10:34:10.427]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:10.427]                   signalCondition(cond)
[10:34:10.427]                 }
[10:34:10.427]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:10.427]                 "immediateCondition"))) {
[10:34:10.427]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:10.427]                   ...future.conditions[[length(...future.conditions) + 
[10:34:10.427]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:10.427]                   if (TRUE && !signal) {
[10:34:10.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:10.427]                     {
[10:34:10.427]                       inherits <- base::inherits
[10:34:10.427]                       invokeRestart <- base::invokeRestart
[10:34:10.427]                       is.null <- base::is.null
[10:34:10.427]                       muffled <- FALSE
[10:34:10.427]                       if (inherits(cond, "message")) {
[10:34:10.427]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:10.427]                         if (muffled) 
[10:34:10.427]                           invokeRestart("muffleMessage")
[10:34:10.427]                       }
[10:34:10.427]                       else if (inherits(cond, "warning")) {
[10:34:10.427]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:10.427]                         if (muffled) 
[10:34:10.427]                           invokeRestart("muffleWarning")
[10:34:10.427]                       }
[10:34:10.427]                       else if (inherits(cond, "condition")) {
[10:34:10.427]                         if (!is.null(pattern)) {
[10:34:10.427]                           computeRestarts <- base::computeRestarts
[10:34:10.427]                           grepl <- base::grepl
[10:34:10.427]                           restarts <- computeRestarts(cond)
[10:34:10.427]                           for (restart in restarts) {
[10:34:10.427]                             name <- restart$name
[10:34:10.427]                             if (is.null(name)) 
[10:34:10.427]                               next
[10:34:10.427]                             if (!grepl(pattern, name)) 
[10:34:10.427]                               next
[10:34:10.427]                             invokeRestart(restart)
[10:34:10.427]                             muffled <- TRUE
[10:34:10.427]                             break
[10:34:10.427]                           }
[10:34:10.427]                         }
[10:34:10.427]                       }
[10:34:10.427]                       invisible(muffled)
[10:34:10.427]                     }
[10:34:10.427]                     muffleCondition(cond, pattern = "^muffle")
[10:34:10.427]                   }
[10:34:10.427]                 }
[10:34:10.427]                 else {
[10:34:10.427]                   if (TRUE) {
[10:34:10.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:10.427]                     {
[10:34:10.427]                       inherits <- base::inherits
[10:34:10.427]                       invokeRestart <- base::invokeRestart
[10:34:10.427]                       is.null <- base::is.null
[10:34:10.427]                       muffled <- FALSE
[10:34:10.427]                       if (inherits(cond, "message")) {
[10:34:10.427]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:10.427]                         if (muffled) 
[10:34:10.427]                           invokeRestart("muffleMessage")
[10:34:10.427]                       }
[10:34:10.427]                       else if (inherits(cond, "warning")) {
[10:34:10.427]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:10.427]                         if (muffled) 
[10:34:10.427]                           invokeRestart("muffleWarning")
[10:34:10.427]                       }
[10:34:10.427]                       else if (inherits(cond, "condition")) {
[10:34:10.427]                         if (!is.null(pattern)) {
[10:34:10.427]                           computeRestarts <- base::computeRestarts
[10:34:10.427]                           grepl <- base::grepl
[10:34:10.427]                           restarts <- computeRestarts(cond)
[10:34:10.427]                           for (restart in restarts) {
[10:34:10.427]                             name <- restart$name
[10:34:10.427]                             if (is.null(name)) 
[10:34:10.427]                               next
[10:34:10.427]                             if (!grepl(pattern, name)) 
[10:34:10.427]                               next
[10:34:10.427]                             invokeRestart(restart)
[10:34:10.427]                             muffled <- TRUE
[10:34:10.427]                             break
[10:34:10.427]                           }
[10:34:10.427]                         }
[10:34:10.427]                       }
[10:34:10.427]                       invisible(muffled)
[10:34:10.427]                     }
[10:34:10.427]                     muffleCondition(cond, pattern = "^muffle")
[10:34:10.427]                   }
[10:34:10.427]                 }
[10:34:10.427]             }
[10:34:10.427]         }))
[10:34:10.427]     }, error = function(ex) {
[10:34:10.427]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:10.427]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:10.427]                 ...future.rng), started = ...future.startTime, 
[10:34:10.427]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:10.427]             version = "1.8"), class = "FutureResult")
[10:34:10.427]     }, finally = {
[10:34:10.427]         if (!identical(...future.workdir, getwd())) 
[10:34:10.427]             setwd(...future.workdir)
[10:34:10.427]         {
[10:34:10.427]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:10.427]                 ...future.oldOptions$nwarnings <- NULL
[10:34:10.427]             }
[10:34:10.427]             base::options(...future.oldOptions)
[10:34:10.427]             if (.Platform$OS.type == "windows") {
[10:34:10.427]                 old_names <- names(...future.oldEnvVars)
[10:34:10.427]                 envs <- base::Sys.getenv()
[10:34:10.427]                 names <- names(envs)
[10:34:10.427]                 common <- intersect(names, old_names)
[10:34:10.427]                 added <- setdiff(names, old_names)
[10:34:10.427]                 removed <- setdiff(old_names, names)
[10:34:10.427]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:10.427]                   envs[common]]
[10:34:10.427]                 NAMES <- toupper(changed)
[10:34:10.427]                 args <- list()
[10:34:10.427]                 for (kk in seq_along(NAMES)) {
[10:34:10.427]                   name <- changed[[kk]]
[10:34:10.427]                   NAME <- NAMES[[kk]]
[10:34:10.427]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:10.427]                     next
[10:34:10.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:10.427]                 }
[10:34:10.427]                 NAMES <- toupper(added)
[10:34:10.427]                 for (kk in seq_along(NAMES)) {
[10:34:10.427]                   name <- added[[kk]]
[10:34:10.427]                   NAME <- NAMES[[kk]]
[10:34:10.427]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:10.427]                     next
[10:34:10.427]                   args[[name]] <- ""
[10:34:10.427]                 }
[10:34:10.427]                 NAMES <- toupper(removed)
[10:34:10.427]                 for (kk in seq_along(NAMES)) {
[10:34:10.427]                   name <- removed[[kk]]
[10:34:10.427]                   NAME <- NAMES[[kk]]
[10:34:10.427]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:10.427]                     next
[10:34:10.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:10.427]                 }
[10:34:10.427]                 if (length(args) > 0) 
[10:34:10.427]                   base::do.call(base::Sys.setenv, args = args)
[10:34:10.427]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:10.427]             }
[10:34:10.427]             else {
[10:34:10.427]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:10.427]             }
[10:34:10.427]             {
[10:34:10.427]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:10.427]                   0L) {
[10:34:10.427]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:10.427]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:10.427]                   base::options(opts)
[10:34:10.427]                 }
[10:34:10.427]                 {
[10:34:10.427]                   {
[10:34:10.427]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:10.427]                     NULL
[10:34:10.427]                   }
[10:34:10.427]                   options(future.plan = NULL)
[10:34:10.427]                   if (is.na(NA_character_)) 
[10:34:10.427]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:10.427]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:10.427]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:10.427]                     .init = FALSE)
[10:34:10.427]                 }
[10:34:10.427]             }
[10:34:10.427]         }
[10:34:10.427]     })
[10:34:10.427]     if (TRUE) {
[10:34:10.427]         base::sink(type = "output", split = FALSE)
[10:34:10.427]         if (TRUE) {
[10:34:10.427]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:10.427]         }
[10:34:10.427]         else {
[10:34:10.427]             ...future.result["stdout"] <- base::list(NULL)
[10:34:10.427]         }
[10:34:10.427]         base::close(...future.stdout)
[10:34:10.427]         ...future.stdout <- NULL
[10:34:10.427]     }
[10:34:10.427]     ...future.result$conditions <- ...future.conditions
[10:34:10.427]     ...future.result$finished <- base::Sys.time()
[10:34:10.427]     ...future.result
[10:34:10.427] }
[10:34:10.430] MultisessionFuture started
[10:34:10.430] - Launch lazy future ... done
[10:34:10.430] run() for ‘MultisessionFuture’ ... done
[10:34:10.432] receiveMessageFromWorker() for ClusterFuture ...
[10:34:10.432] - Validating connection of MultisessionFuture
[10:34:10.433] - received message: FutureResult
[10:34:10.433] - Received FutureResult
[10:34:10.433] - Erased future from FutureRegistry
[10:34:10.433] result() for ClusterFuture ...
[10:34:10.433] - result already collected: FutureResult
[10:34:10.433] result() for ClusterFuture ... done
[10:34:10.433] signalConditions() ...
[10:34:10.433]  - include = ‘immediateCondition’
[10:34:10.434]  - exclude = 
[10:34:10.434]  - resignal = FALSE
[10:34:10.434]  - Number of conditions: 1
[10:34:10.434] signalConditions() ... done
[10:34:10.434] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:10.434] A MultisessionFuture was resolved
[10:34:10.434] getGlobalsAndPackages() ...
[10:34:10.434] Searching for globals...
[10:34:10.435] - globals found: [2] ‘list’, ‘stop’
[10:34:10.435] Searching for globals ... DONE
[10:34:10.435] Resolving globals: FALSE
[10:34:10.436] 
[10:34:10.436] 
[10:34:10.436] getGlobalsAndPackages() ... DONE
[10:34:10.436] run() for ‘Future’ ...
[10:34:10.436] - state: ‘created’
[10:34:10.436] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:10.454] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:10.454] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:10.454]   - Field: ‘node’
[10:34:10.454]   - Field: ‘label’
[10:34:10.455]   - Field: ‘local’
[10:34:10.455]   - Field: ‘owner’
[10:34:10.455]   - Field: ‘envir’
[10:34:10.455]   - Field: ‘workers’
[10:34:10.455]   - Field: ‘packages’
[10:34:10.455]   - Field: ‘gc’
[10:34:10.455]   - Field: ‘conditions’
[10:34:10.455]   - Field: ‘persistent’
[10:34:10.455]   - Field: ‘expr’
[10:34:10.455]   - Field: ‘uuid’
[10:34:10.455]   - Field: ‘seed’
[10:34:10.456]   - Field: ‘version’
[10:34:10.456]   - Field: ‘result’
[10:34:10.456]   - Field: ‘asynchronous’
[10:34:10.456]   - Field: ‘calls’
[10:34:10.456]   - Field: ‘globals’
[10:34:10.456]   - Field: ‘stdout’
[10:34:10.456]   - Field: ‘earlySignal’
[10:34:10.456]   - Field: ‘lazy’
[10:34:10.456]   - Field: ‘state’
[10:34:10.456] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:10.456] - Launch lazy future ...
[10:34:10.457] Packages needed by the future expression (n = 0): <none>
[10:34:10.457] Packages needed by future strategies (n = 0): <none>
[10:34:10.457] {
[10:34:10.457]     {
[10:34:10.457]         {
[10:34:10.457]             ...future.startTime <- base::Sys.time()
[10:34:10.457]             {
[10:34:10.457]                 {
[10:34:10.457]                   {
[10:34:10.457]                     {
[10:34:10.457]                       base::local({
[10:34:10.457]                         has_future <- base::requireNamespace("future", 
[10:34:10.457]                           quietly = TRUE)
[10:34:10.457]                         if (has_future) {
[10:34:10.457]                           ns <- base::getNamespace("future")
[10:34:10.457]                           version <- ns[[".package"]][["version"]]
[10:34:10.457]                           if (is.null(version)) 
[10:34:10.457]                             version <- utils::packageVersion("future")
[10:34:10.457]                         }
[10:34:10.457]                         else {
[10:34:10.457]                           version <- NULL
[10:34:10.457]                         }
[10:34:10.457]                         if (!has_future || version < "1.8.0") {
[10:34:10.457]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:10.457]                             "", base::R.version$version.string), 
[10:34:10.457]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:10.457]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:10.457]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:10.457]                               "release", "version")], collapse = " "), 
[10:34:10.457]                             hostname = base::Sys.info()[["nodename"]])
[10:34:10.457]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:10.457]                             info)
[10:34:10.457]                           info <- base::paste(info, collapse = "; ")
[10:34:10.457]                           if (!has_future) {
[10:34:10.457]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:10.457]                               info)
[10:34:10.457]                           }
[10:34:10.457]                           else {
[10:34:10.457]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:10.457]                               info, version)
[10:34:10.457]                           }
[10:34:10.457]                           base::stop(msg)
[10:34:10.457]                         }
[10:34:10.457]                       })
[10:34:10.457]                     }
[10:34:10.457]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:10.457]                     base::options(mc.cores = 1L)
[10:34:10.457]                   }
[10:34:10.457]                   ...future.strategy.old <- future::plan("list")
[10:34:10.457]                   options(future.plan = NULL)
[10:34:10.457]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:10.457]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:10.457]                 }
[10:34:10.457]                 ...future.workdir <- getwd()
[10:34:10.457]             }
[10:34:10.457]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:10.457]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:10.457]         }
[10:34:10.457]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:10.457]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:10.457]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:10.457]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:10.457]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:10.457]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:10.457]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:10.457]             base::names(...future.oldOptions))
[10:34:10.457]     }
[10:34:10.457]     if (FALSE) {
[10:34:10.457]     }
[10:34:10.457]     else {
[10:34:10.457]         if (TRUE) {
[10:34:10.457]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:10.457]                 open = "w")
[10:34:10.457]         }
[10:34:10.457]         else {
[10:34:10.457]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:10.457]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:10.457]         }
[10:34:10.457]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:10.457]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:10.457]             base::sink(type = "output", split = FALSE)
[10:34:10.457]             base::close(...future.stdout)
[10:34:10.457]         }, add = TRUE)
[10:34:10.457]     }
[10:34:10.457]     ...future.frame <- base::sys.nframe()
[10:34:10.457]     ...future.conditions <- base::list()
[10:34:10.457]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:10.457]     if (FALSE) {
[10:34:10.457]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:10.457]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:10.457]     }
[10:34:10.457]     ...future.result <- base::tryCatch({
[10:34:10.457]         base::withCallingHandlers({
[10:34:10.457]             ...future.value <- base::withVisible(base::local({
[10:34:10.457]                 ...future.makeSendCondition <- base::local({
[10:34:10.457]                   sendCondition <- NULL
[10:34:10.457]                   function(frame = 1L) {
[10:34:10.457]                     if (is.function(sendCondition)) 
[10:34:10.457]                       return(sendCondition)
[10:34:10.457]                     ns <- getNamespace("parallel")
[10:34:10.457]                     if (exists("sendData", mode = "function", 
[10:34:10.457]                       envir = ns)) {
[10:34:10.457]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:10.457]                         envir = ns)
[10:34:10.457]                       envir <- sys.frame(frame)
[10:34:10.457]                       master <- NULL
[10:34:10.457]                       while (!identical(envir, .GlobalEnv) && 
[10:34:10.457]                         !identical(envir, emptyenv())) {
[10:34:10.457]                         if (exists("master", mode = "list", envir = envir, 
[10:34:10.457]                           inherits = FALSE)) {
[10:34:10.457]                           master <- get("master", mode = "list", 
[10:34:10.457]                             envir = envir, inherits = FALSE)
[10:34:10.457]                           if (inherits(master, c("SOCKnode", 
[10:34:10.457]                             "SOCK0node"))) {
[10:34:10.457]                             sendCondition <<- function(cond) {
[10:34:10.457]                               data <- list(type = "VALUE", value = cond, 
[10:34:10.457]                                 success = TRUE)
[10:34:10.457]                               parallel_sendData(master, data)
[10:34:10.457]                             }
[10:34:10.457]                             return(sendCondition)
[10:34:10.457]                           }
[10:34:10.457]                         }
[10:34:10.457]                         frame <- frame + 1L
[10:34:10.457]                         envir <- sys.frame(frame)
[10:34:10.457]                       }
[10:34:10.457]                     }
[10:34:10.457]                     sendCondition <<- function(cond) NULL
[10:34:10.457]                   }
[10:34:10.457]                 })
[10:34:10.457]                 withCallingHandlers({
[10:34:10.457]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:34:10.457]                 }, immediateCondition = function(cond) {
[10:34:10.457]                   sendCondition <- ...future.makeSendCondition()
[10:34:10.457]                   sendCondition(cond)
[10:34:10.457]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:10.457]                   {
[10:34:10.457]                     inherits <- base::inherits
[10:34:10.457]                     invokeRestart <- base::invokeRestart
[10:34:10.457]                     is.null <- base::is.null
[10:34:10.457]                     muffled <- FALSE
[10:34:10.457]                     if (inherits(cond, "message")) {
[10:34:10.457]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:10.457]                       if (muffled) 
[10:34:10.457]                         invokeRestart("muffleMessage")
[10:34:10.457]                     }
[10:34:10.457]                     else if (inherits(cond, "warning")) {
[10:34:10.457]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:10.457]                       if (muffled) 
[10:34:10.457]                         invokeRestart("muffleWarning")
[10:34:10.457]                     }
[10:34:10.457]                     else if (inherits(cond, "condition")) {
[10:34:10.457]                       if (!is.null(pattern)) {
[10:34:10.457]                         computeRestarts <- base::computeRestarts
[10:34:10.457]                         grepl <- base::grepl
[10:34:10.457]                         restarts <- computeRestarts(cond)
[10:34:10.457]                         for (restart in restarts) {
[10:34:10.457]                           name <- restart$name
[10:34:10.457]                           if (is.null(name)) 
[10:34:10.457]                             next
[10:34:10.457]                           if (!grepl(pattern, name)) 
[10:34:10.457]                             next
[10:34:10.457]                           invokeRestart(restart)
[10:34:10.457]                           muffled <- TRUE
[10:34:10.457]                           break
[10:34:10.457]                         }
[10:34:10.457]                       }
[10:34:10.457]                     }
[10:34:10.457]                     invisible(muffled)
[10:34:10.457]                   }
[10:34:10.457]                   muffleCondition(cond)
[10:34:10.457]                 })
[10:34:10.457]             }))
[10:34:10.457]             future::FutureResult(value = ...future.value$value, 
[10:34:10.457]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:10.457]                   ...future.rng), globalenv = if (FALSE) 
[10:34:10.457]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:10.457]                     ...future.globalenv.names))
[10:34:10.457]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:10.457]         }, condition = base::local({
[10:34:10.457]             c <- base::c
[10:34:10.457]             inherits <- base::inherits
[10:34:10.457]             invokeRestart <- base::invokeRestart
[10:34:10.457]             length <- base::length
[10:34:10.457]             list <- base::list
[10:34:10.457]             seq.int <- base::seq.int
[10:34:10.457]             signalCondition <- base::signalCondition
[10:34:10.457]             sys.calls <- base::sys.calls
[10:34:10.457]             `[[` <- base::`[[`
[10:34:10.457]             `+` <- base::`+`
[10:34:10.457]             `<<-` <- base::`<<-`
[10:34:10.457]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:10.457]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:10.457]                   3L)]
[10:34:10.457]             }
[10:34:10.457]             function(cond) {
[10:34:10.457]                 is_error <- inherits(cond, "error")
[10:34:10.457]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:10.457]                   NULL)
[10:34:10.457]                 if (is_error) {
[10:34:10.457]                   sessionInformation <- function() {
[10:34:10.457]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:10.457]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:10.457]                       search = base::search(), system = base::Sys.info())
[10:34:10.457]                   }
[10:34:10.457]                   ...future.conditions[[length(...future.conditions) + 
[10:34:10.457]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:10.457]                     cond$call), session = sessionInformation(), 
[10:34:10.457]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:10.457]                   signalCondition(cond)
[10:34:10.457]                 }
[10:34:10.457]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:10.457]                 "immediateCondition"))) {
[10:34:10.457]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:10.457]                   ...future.conditions[[length(...future.conditions) + 
[10:34:10.457]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:10.457]                   if (TRUE && !signal) {
[10:34:10.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:10.457]                     {
[10:34:10.457]                       inherits <- base::inherits
[10:34:10.457]                       invokeRestart <- base::invokeRestart
[10:34:10.457]                       is.null <- base::is.null
[10:34:10.457]                       muffled <- FALSE
[10:34:10.457]                       if (inherits(cond, "message")) {
[10:34:10.457]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:10.457]                         if (muffled) 
[10:34:10.457]                           invokeRestart("muffleMessage")
[10:34:10.457]                       }
[10:34:10.457]                       else if (inherits(cond, "warning")) {
[10:34:10.457]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:10.457]                         if (muffled) 
[10:34:10.457]                           invokeRestart("muffleWarning")
[10:34:10.457]                       }
[10:34:10.457]                       else if (inherits(cond, "condition")) {
[10:34:10.457]                         if (!is.null(pattern)) {
[10:34:10.457]                           computeRestarts <- base::computeRestarts
[10:34:10.457]                           grepl <- base::grepl
[10:34:10.457]                           restarts <- computeRestarts(cond)
[10:34:10.457]                           for (restart in restarts) {
[10:34:10.457]                             name <- restart$name
[10:34:10.457]                             if (is.null(name)) 
[10:34:10.457]                               next
[10:34:10.457]                             if (!grepl(pattern, name)) 
[10:34:10.457]                               next
[10:34:10.457]                             invokeRestart(restart)
[10:34:10.457]                             muffled <- TRUE
[10:34:10.457]                             break
[10:34:10.457]                           }
[10:34:10.457]                         }
[10:34:10.457]                       }
[10:34:10.457]                       invisible(muffled)
[10:34:10.457]                     }
[10:34:10.457]                     muffleCondition(cond, pattern = "^muffle")
[10:34:10.457]                   }
[10:34:10.457]                 }
[10:34:10.457]                 else {
[10:34:10.457]                   if (TRUE) {
[10:34:10.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:10.457]                     {
[10:34:10.457]                       inherits <- base::inherits
[10:34:10.457]                       invokeRestart <- base::invokeRestart
[10:34:10.457]                       is.null <- base::is.null
[10:34:10.457]                       muffled <- FALSE
[10:34:10.457]                       if (inherits(cond, "message")) {
[10:34:10.457]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:10.457]                         if (muffled) 
[10:34:10.457]                           invokeRestart("muffleMessage")
[10:34:10.457]                       }
[10:34:10.457]                       else if (inherits(cond, "warning")) {
[10:34:10.457]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:10.457]                         if (muffled) 
[10:34:10.457]                           invokeRestart("muffleWarning")
[10:34:10.457]                       }
[10:34:10.457]                       else if (inherits(cond, "condition")) {
[10:34:10.457]                         if (!is.null(pattern)) {
[10:34:10.457]                           computeRestarts <- base::computeRestarts
[10:34:10.457]                           grepl <- base::grepl
[10:34:10.457]                           restarts <- computeRestarts(cond)
[10:34:10.457]                           for (restart in restarts) {
[10:34:10.457]                             name <- restart$name
[10:34:10.457]                             if (is.null(name)) 
[10:34:10.457]                               next
[10:34:10.457]                             if (!grepl(pattern, name)) 
[10:34:10.457]                               next
[10:34:10.457]                             invokeRestart(restart)
[10:34:10.457]                             muffled <- TRUE
[10:34:10.457]                             break
[10:34:10.457]                           }
[10:34:10.457]                         }
[10:34:10.457]                       }
[10:34:10.457]                       invisible(muffled)
[10:34:10.457]                     }
[10:34:10.457]                     muffleCondition(cond, pattern = "^muffle")
[10:34:10.457]                   }
[10:34:10.457]                 }
[10:34:10.457]             }
[10:34:10.457]         }))
[10:34:10.457]     }, error = function(ex) {
[10:34:10.457]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:10.457]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:10.457]                 ...future.rng), started = ...future.startTime, 
[10:34:10.457]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:10.457]             version = "1.8"), class = "FutureResult")
[10:34:10.457]     }, finally = {
[10:34:10.457]         if (!identical(...future.workdir, getwd())) 
[10:34:10.457]             setwd(...future.workdir)
[10:34:10.457]         {
[10:34:10.457]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:10.457]                 ...future.oldOptions$nwarnings <- NULL
[10:34:10.457]             }
[10:34:10.457]             base::options(...future.oldOptions)
[10:34:10.457]             if (.Platform$OS.type == "windows") {
[10:34:10.457]                 old_names <- names(...future.oldEnvVars)
[10:34:10.457]                 envs <- base::Sys.getenv()
[10:34:10.457]                 names <- names(envs)
[10:34:10.457]                 common <- intersect(names, old_names)
[10:34:10.457]                 added <- setdiff(names, old_names)
[10:34:10.457]                 removed <- setdiff(old_names, names)
[10:34:10.457]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:10.457]                   envs[common]]
[10:34:10.457]                 NAMES <- toupper(changed)
[10:34:10.457]                 args <- list()
[10:34:10.457]                 for (kk in seq_along(NAMES)) {
[10:34:10.457]                   name <- changed[[kk]]
[10:34:10.457]                   NAME <- NAMES[[kk]]
[10:34:10.457]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:10.457]                     next
[10:34:10.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:10.457]                 }
[10:34:10.457]                 NAMES <- toupper(added)
[10:34:10.457]                 for (kk in seq_along(NAMES)) {
[10:34:10.457]                   name <- added[[kk]]
[10:34:10.457]                   NAME <- NAMES[[kk]]
[10:34:10.457]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:10.457]                     next
[10:34:10.457]                   args[[name]] <- ""
[10:34:10.457]                 }
[10:34:10.457]                 NAMES <- toupper(removed)
[10:34:10.457]                 for (kk in seq_along(NAMES)) {
[10:34:10.457]                   name <- removed[[kk]]
[10:34:10.457]                   NAME <- NAMES[[kk]]
[10:34:10.457]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:10.457]                     next
[10:34:10.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:10.457]                 }
[10:34:10.457]                 if (length(args) > 0) 
[10:34:10.457]                   base::do.call(base::Sys.setenv, args = args)
[10:34:10.457]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:10.457]             }
[10:34:10.457]             else {
[10:34:10.457]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:10.457]             }
[10:34:10.457]             {
[10:34:10.457]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:10.457]                   0L) {
[10:34:10.457]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:10.457]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:10.457]                   base::options(opts)
[10:34:10.457]                 }
[10:34:10.457]                 {
[10:34:10.457]                   {
[10:34:10.457]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:10.457]                     NULL
[10:34:10.457]                   }
[10:34:10.457]                   options(future.plan = NULL)
[10:34:10.457]                   if (is.na(NA_character_)) 
[10:34:10.457]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:10.457]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:10.457]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:10.457]                     .init = FALSE)
[10:34:10.457]                 }
[10:34:10.457]             }
[10:34:10.457]         }
[10:34:10.457]     })
[10:34:10.457]     if (TRUE) {
[10:34:10.457]         base::sink(type = "output", split = FALSE)
[10:34:10.457]         if (TRUE) {
[10:34:10.457]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:10.457]         }
[10:34:10.457]         else {
[10:34:10.457]             ...future.result["stdout"] <- base::list(NULL)
[10:34:10.457]         }
[10:34:10.457]         base::close(...future.stdout)
[10:34:10.457]         ...future.stdout <- NULL
[10:34:10.457]     }
[10:34:10.457]     ...future.result$conditions <- ...future.conditions
[10:34:10.457]     ...future.result$finished <- base::Sys.time()
[10:34:10.457]     ...future.result
[10:34:10.457] }
[10:34:10.460] MultisessionFuture started
[10:34:10.460] - Launch lazy future ... done
[10:34:10.460] run() for ‘MultisessionFuture’ ... done
[10:34:10.461] receiveMessageFromWorker() for ClusterFuture ...
[10:34:10.462] - Validating connection of MultisessionFuture
[10:34:10.462] - received message: FutureResult
[10:34:10.462] - Received FutureResult
[10:34:10.462] - Erased future from FutureRegistry
[10:34:10.462] result() for ClusterFuture ...
[10:34:10.462] - result already collected: FutureResult
[10:34:10.463] result() for ClusterFuture ... done
[10:34:10.463] signalConditions() ...
[10:34:10.463]  - include = ‘immediateCondition’
[10:34:10.463]  - exclude = 
[10:34:10.463]  - resignal = FALSE
[10:34:10.463]  - Number of conditions: 1
[10:34:10.463] signalConditions() ... done
[10:34:10.463] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:10.463] A MultisessionFuture was resolved
- result = TRUE, recursive = FALSE ... DONE
- result = TRUE, recursive = TRUE ...
[10:34:10.463] getGlobalsAndPackages() ...
[10:34:10.464] Searching for globals...
[10:34:10.465] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:34:10.465] Searching for globals ... DONE
[10:34:10.465] Resolving globals: FALSE
[10:34:10.465] 
[10:34:10.465] 
[10:34:10.465] getGlobalsAndPackages() ... DONE
[10:34:10.466] run() for ‘Future’ ...
[10:34:10.466] - state: ‘created’
[10:34:10.466] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:10.479] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:10.479] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:10.479]   - Field: ‘node’
[10:34:10.479]   - Field: ‘label’
[10:34:10.479]   - Field: ‘local’
[10:34:10.479]   - Field: ‘owner’
[10:34:10.480]   - Field: ‘envir’
[10:34:10.480]   - Field: ‘workers’
[10:34:10.480]   - Field: ‘packages’
[10:34:10.480]   - Field: ‘gc’
[10:34:10.480]   - Field: ‘conditions’
[10:34:10.480]   - Field: ‘persistent’
[10:34:10.480]   - Field: ‘expr’
[10:34:10.480]   - Field: ‘uuid’
[10:34:10.480]   - Field: ‘seed’
[10:34:10.480]   - Field: ‘version’
[10:34:10.480]   - Field: ‘result’
[10:34:10.481]   - Field: ‘asynchronous’
[10:34:10.481]   - Field: ‘calls’
[10:34:10.481]   - Field: ‘globals’
[10:34:10.481]   - Field: ‘stdout’
[10:34:10.481]   - Field: ‘earlySignal’
[10:34:10.481]   - Field: ‘lazy’
[10:34:10.481]   - Field: ‘state’
[10:34:10.481] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:10.481] - Launch lazy future ...
[10:34:10.482] Packages needed by the future expression (n = 0): <none>
[10:34:10.482] Packages needed by future strategies (n = 0): <none>
[10:34:10.482] {
[10:34:10.482]     {
[10:34:10.482]         {
[10:34:10.482]             ...future.startTime <- base::Sys.time()
[10:34:10.482]             {
[10:34:10.482]                 {
[10:34:10.482]                   {
[10:34:10.482]                     {
[10:34:10.482]                       base::local({
[10:34:10.482]                         has_future <- base::requireNamespace("future", 
[10:34:10.482]                           quietly = TRUE)
[10:34:10.482]                         if (has_future) {
[10:34:10.482]                           ns <- base::getNamespace("future")
[10:34:10.482]                           version <- ns[[".package"]][["version"]]
[10:34:10.482]                           if (is.null(version)) 
[10:34:10.482]                             version <- utils::packageVersion("future")
[10:34:10.482]                         }
[10:34:10.482]                         else {
[10:34:10.482]                           version <- NULL
[10:34:10.482]                         }
[10:34:10.482]                         if (!has_future || version < "1.8.0") {
[10:34:10.482]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:10.482]                             "", base::R.version$version.string), 
[10:34:10.482]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:10.482]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:10.482]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:10.482]                               "release", "version")], collapse = " "), 
[10:34:10.482]                             hostname = base::Sys.info()[["nodename"]])
[10:34:10.482]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:10.482]                             info)
[10:34:10.482]                           info <- base::paste(info, collapse = "; ")
[10:34:10.482]                           if (!has_future) {
[10:34:10.482]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:10.482]                               info)
[10:34:10.482]                           }
[10:34:10.482]                           else {
[10:34:10.482]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:10.482]                               info, version)
[10:34:10.482]                           }
[10:34:10.482]                           base::stop(msg)
[10:34:10.482]                         }
[10:34:10.482]                       })
[10:34:10.482]                     }
[10:34:10.482]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:10.482]                     base::options(mc.cores = 1L)
[10:34:10.482]                   }
[10:34:10.482]                   ...future.strategy.old <- future::plan("list")
[10:34:10.482]                   options(future.plan = NULL)
[10:34:10.482]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:10.482]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:10.482]                 }
[10:34:10.482]                 ...future.workdir <- getwd()
[10:34:10.482]             }
[10:34:10.482]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:10.482]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:10.482]         }
[10:34:10.482]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:10.482]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:10.482]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:10.482]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:10.482]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:10.482]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:10.482]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:10.482]             base::names(...future.oldOptions))
[10:34:10.482]     }
[10:34:10.482]     if (FALSE) {
[10:34:10.482]     }
[10:34:10.482]     else {
[10:34:10.482]         if (TRUE) {
[10:34:10.482]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:10.482]                 open = "w")
[10:34:10.482]         }
[10:34:10.482]         else {
[10:34:10.482]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:10.482]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:10.482]         }
[10:34:10.482]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:10.482]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:10.482]             base::sink(type = "output", split = FALSE)
[10:34:10.482]             base::close(...future.stdout)
[10:34:10.482]         }, add = TRUE)
[10:34:10.482]     }
[10:34:10.482]     ...future.frame <- base::sys.nframe()
[10:34:10.482]     ...future.conditions <- base::list()
[10:34:10.482]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:10.482]     if (FALSE) {
[10:34:10.482]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:10.482]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:10.482]     }
[10:34:10.482]     ...future.result <- base::tryCatch({
[10:34:10.482]         base::withCallingHandlers({
[10:34:10.482]             ...future.value <- base::withVisible(base::local({
[10:34:10.482]                 ...future.makeSendCondition <- base::local({
[10:34:10.482]                   sendCondition <- NULL
[10:34:10.482]                   function(frame = 1L) {
[10:34:10.482]                     if (is.function(sendCondition)) 
[10:34:10.482]                       return(sendCondition)
[10:34:10.482]                     ns <- getNamespace("parallel")
[10:34:10.482]                     if (exists("sendData", mode = "function", 
[10:34:10.482]                       envir = ns)) {
[10:34:10.482]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:10.482]                         envir = ns)
[10:34:10.482]                       envir <- sys.frame(frame)
[10:34:10.482]                       master <- NULL
[10:34:10.482]                       while (!identical(envir, .GlobalEnv) && 
[10:34:10.482]                         !identical(envir, emptyenv())) {
[10:34:10.482]                         if (exists("master", mode = "list", envir = envir, 
[10:34:10.482]                           inherits = FALSE)) {
[10:34:10.482]                           master <- get("master", mode = "list", 
[10:34:10.482]                             envir = envir, inherits = FALSE)
[10:34:10.482]                           if (inherits(master, c("SOCKnode", 
[10:34:10.482]                             "SOCK0node"))) {
[10:34:10.482]                             sendCondition <<- function(cond) {
[10:34:10.482]                               data <- list(type = "VALUE", value = cond, 
[10:34:10.482]                                 success = TRUE)
[10:34:10.482]                               parallel_sendData(master, data)
[10:34:10.482]                             }
[10:34:10.482]                             return(sendCondition)
[10:34:10.482]                           }
[10:34:10.482]                         }
[10:34:10.482]                         frame <- frame + 1L
[10:34:10.482]                         envir <- sys.frame(frame)
[10:34:10.482]                       }
[10:34:10.482]                     }
[10:34:10.482]                     sendCondition <<- function(cond) NULL
[10:34:10.482]                   }
[10:34:10.482]                 })
[10:34:10.482]                 withCallingHandlers({
[10:34:10.482]                   {
[10:34:10.482]                     Sys.sleep(0.5)
[10:34:10.482]                     list(a = 1, b = 42L)
[10:34:10.482]                   }
[10:34:10.482]                 }, immediateCondition = function(cond) {
[10:34:10.482]                   sendCondition <- ...future.makeSendCondition()
[10:34:10.482]                   sendCondition(cond)
[10:34:10.482]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:10.482]                   {
[10:34:10.482]                     inherits <- base::inherits
[10:34:10.482]                     invokeRestart <- base::invokeRestart
[10:34:10.482]                     is.null <- base::is.null
[10:34:10.482]                     muffled <- FALSE
[10:34:10.482]                     if (inherits(cond, "message")) {
[10:34:10.482]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:10.482]                       if (muffled) 
[10:34:10.482]                         invokeRestart("muffleMessage")
[10:34:10.482]                     }
[10:34:10.482]                     else if (inherits(cond, "warning")) {
[10:34:10.482]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:10.482]                       if (muffled) 
[10:34:10.482]                         invokeRestart("muffleWarning")
[10:34:10.482]                     }
[10:34:10.482]                     else if (inherits(cond, "condition")) {
[10:34:10.482]                       if (!is.null(pattern)) {
[10:34:10.482]                         computeRestarts <- base::computeRestarts
[10:34:10.482]                         grepl <- base::grepl
[10:34:10.482]                         restarts <- computeRestarts(cond)
[10:34:10.482]                         for (restart in restarts) {
[10:34:10.482]                           name <- restart$name
[10:34:10.482]                           if (is.null(name)) 
[10:34:10.482]                             next
[10:34:10.482]                           if (!grepl(pattern, name)) 
[10:34:10.482]                             next
[10:34:10.482]                           invokeRestart(restart)
[10:34:10.482]                           muffled <- TRUE
[10:34:10.482]                           break
[10:34:10.482]                         }
[10:34:10.482]                       }
[10:34:10.482]                     }
[10:34:10.482]                     invisible(muffled)
[10:34:10.482]                   }
[10:34:10.482]                   muffleCondition(cond)
[10:34:10.482]                 })
[10:34:10.482]             }))
[10:34:10.482]             future::FutureResult(value = ...future.value$value, 
[10:34:10.482]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:10.482]                   ...future.rng), globalenv = if (FALSE) 
[10:34:10.482]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:10.482]                     ...future.globalenv.names))
[10:34:10.482]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:10.482]         }, condition = base::local({
[10:34:10.482]             c <- base::c
[10:34:10.482]             inherits <- base::inherits
[10:34:10.482]             invokeRestart <- base::invokeRestart
[10:34:10.482]             length <- base::length
[10:34:10.482]             list <- base::list
[10:34:10.482]             seq.int <- base::seq.int
[10:34:10.482]             signalCondition <- base::signalCondition
[10:34:10.482]             sys.calls <- base::sys.calls
[10:34:10.482]             `[[` <- base::`[[`
[10:34:10.482]             `+` <- base::`+`
[10:34:10.482]             `<<-` <- base::`<<-`
[10:34:10.482]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:10.482]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:10.482]                   3L)]
[10:34:10.482]             }
[10:34:10.482]             function(cond) {
[10:34:10.482]                 is_error <- inherits(cond, "error")
[10:34:10.482]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:10.482]                   NULL)
[10:34:10.482]                 if (is_error) {
[10:34:10.482]                   sessionInformation <- function() {
[10:34:10.482]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:10.482]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:10.482]                       search = base::search(), system = base::Sys.info())
[10:34:10.482]                   }
[10:34:10.482]                   ...future.conditions[[length(...future.conditions) + 
[10:34:10.482]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:10.482]                     cond$call), session = sessionInformation(), 
[10:34:10.482]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:10.482]                   signalCondition(cond)
[10:34:10.482]                 }
[10:34:10.482]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:10.482]                 "immediateCondition"))) {
[10:34:10.482]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:10.482]                   ...future.conditions[[length(...future.conditions) + 
[10:34:10.482]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:10.482]                   if (TRUE && !signal) {
[10:34:10.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:10.482]                     {
[10:34:10.482]                       inherits <- base::inherits
[10:34:10.482]                       invokeRestart <- base::invokeRestart
[10:34:10.482]                       is.null <- base::is.null
[10:34:10.482]                       muffled <- FALSE
[10:34:10.482]                       if (inherits(cond, "message")) {
[10:34:10.482]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:10.482]                         if (muffled) 
[10:34:10.482]                           invokeRestart("muffleMessage")
[10:34:10.482]                       }
[10:34:10.482]                       else if (inherits(cond, "warning")) {
[10:34:10.482]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:10.482]                         if (muffled) 
[10:34:10.482]                           invokeRestart("muffleWarning")
[10:34:10.482]                       }
[10:34:10.482]                       else if (inherits(cond, "condition")) {
[10:34:10.482]                         if (!is.null(pattern)) {
[10:34:10.482]                           computeRestarts <- base::computeRestarts
[10:34:10.482]                           grepl <- base::grepl
[10:34:10.482]                           restarts <- computeRestarts(cond)
[10:34:10.482]                           for (restart in restarts) {
[10:34:10.482]                             name <- restart$name
[10:34:10.482]                             if (is.null(name)) 
[10:34:10.482]                               next
[10:34:10.482]                             if (!grepl(pattern, name)) 
[10:34:10.482]                               next
[10:34:10.482]                             invokeRestart(restart)
[10:34:10.482]                             muffled <- TRUE
[10:34:10.482]                             break
[10:34:10.482]                           }
[10:34:10.482]                         }
[10:34:10.482]                       }
[10:34:10.482]                       invisible(muffled)
[10:34:10.482]                     }
[10:34:10.482]                     muffleCondition(cond, pattern = "^muffle")
[10:34:10.482]                   }
[10:34:10.482]                 }
[10:34:10.482]                 else {
[10:34:10.482]                   if (TRUE) {
[10:34:10.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:10.482]                     {
[10:34:10.482]                       inherits <- base::inherits
[10:34:10.482]                       invokeRestart <- base::invokeRestart
[10:34:10.482]                       is.null <- base::is.null
[10:34:10.482]                       muffled <- FALSE
[10:34:10.482]                       if (inherits(cond, "message")) {
[10:34:10.482]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:10.482]                         if (muffled) 
[10:34:10.482]                           invokeRestart("muffleMessage")
[10:34:10.482]                       }
[10:34:10.482]                       else if (inherits(cond, "warning")) {
[10:34:10.482]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:10.482]                         if (muffled) 
[10:34:10.482]                           invokeRestart("muffleWarning")
[10:34:10.482]                       }
[10:34:10.482]                       else if (inherits(cond, "condition")) {
[10:34:10.482]                         if (!is.null(pattern)) {
[10:34:10.482]                           computeRestarts <- base::computeRestarts
[10:34:10.482]                           grepl <- base::grepl
[10:34:10.482]                           restarts <- computeRestarts(cond)
[10:34:10.482]                           for (restart in restarts) {
[10:34:10.482]                             name <- restart$name
[10:34:10.482]                             if (is.null(name)) 
[10:34:10.482]                               next
[10:34:10.482]                             if (!grepl(pattern, name)) 
[10:34:10.482]                               next
[10:34:10.482]                             invokeRestart(restart)
[10:34:10.482]                             muffled <- TRUE
[10:34:10.482]                             break
[10:34:10.482]                           }
[10:34:10.482]                         }
[10:34:10.482]                       }
[10:34:10.482]                       invisible(muffled)
[10:34:10.482]                     }
[10:34:10.482]                     muffleCondition(cond, pattern = "^muffle")
[10:34:10.482]                   }
[10:34:10.482]                 }
[10:34:10.482]             }
[10:34:10.482]         }))
[10:34:10.482]     }, error = function(ex) {
[10:34:10.482]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:10.482]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:10.482]                 ...future.rng), started = ...future.startTime, 
[10:34:10.482]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:10.482]             version = "1.8"), class = "FutureResult")
[10:34:10.482]     }, finally = {
[10:34:10.482]         if (!identical(...future.workdir, getwd())) 
[10:34:10.482]             setwd(...future.workdir)
[10:34:10.482]         {
[10:34:10.482]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:10.482]                 ...future.oldOptions$nwarnings <- NULL
[10:34:10.482]             }
[10:34:10.482]             base::options(...future.oldOptions)
[10:34:10.482]             if (.Platform$OS.type == "windows") {
[10:34:10.482]                 old_names <- names(...future.oldEnvVars)
[10:34:10.482]                 envs <- base::Sys.getenv()
[10:34:10.482]                 names <- names(envs)
[10:34:10.482]                 common <- intersect(names, old_names)
[10:34:10.482]                 added <- setdiff(names, old_names)
[10:34:10.482]                 removed <- setdiff(old_names, names)
[10:34:10.482]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:10.482]                   envs[common]]
[10:34:10.482]                 NAMES <- toupper(changed)
[10:34:10.482]                 args <- list()
[10:34:10.482]                 for (kk in seq_along(NAMES)) {
[10:34:10.482]                   name <- changed[[kk]]
[10:34:10.482]                   NAME <- NAMES[[kk]]
[10:34:10.482]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:10.482]                     next
[10:34:10.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:10.482]                 }
[10:34:10.482]                 NAMES <- toupper(added)
[10:34:10.482]                 for (kk in seq_along(NAMES)) {
[10:34:10.482]                   name <- added[[kk]]
[10:34:10.482]                   NAME <- NAMES[[kk]]
[10:34:10.482]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:10.482]                     next
[10:34:10.482]                   args[[name]] <- ""
[10:34:10.482]                 }
[10:34:10.482]                 NAMES <- toupper(removed)
[10:34:10.482]                 for (kk in seq_along(NAMES)) {
[10:34:10.482]                   name <- removed[[kk]]
[10:34:10.482]                   NAME <- NAMES[[kk]]
[10:34:10.482]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:10.482]                     next
[10:34:10.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:10.482]                 }
[10:34:10.482]                 if (length(args) > 0) 
[10:34:10.482]                   base::do.call(base::Sys.setenv, args = args)
[10:34:10.482]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:10.482]             }
[10:34:10.482]             else {
[10:34:10.482]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:10.482]             }
[10:34:10.482]             {
[10:34:10.482]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:10.482]                   0L) {
[10:34:10.482]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:10.482]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:10.482]                   base::options(opts)
[10:34:10.482]                 }
[10:34:10.482]                 {
[10:34:10.482]                   {
[10:34:10.482]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:10.482]                     NULL
[10:34:10.482]                   }
[10:34:10.482]                   options(future.plan = NULL)
[10:34:10.482]                   if (is.na(NA_character_)) 
[10:34:10.482]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:10.482]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:10.482]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:10.482]                     .init = FALSE)
[10:34:10.482]                 }
[10:34:10.482]             }
[10:34:10.482]         }
[10:34:10.482]     })
[10:34:10.482]     if (TRUE) {
[10:34:10.482]         base::sink(type = "output", split = FALSE)
[10:34:10.482]         if (TRUE) {
[10:34:10.482]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:10.482]         }
[10:34:10.482]         else {
[10:34:10.482]             ...future.result["stdout"] <- base::list(NULL)
[10:34:10.482]         }
[10:34:10.482]         base::close(...future.stdout)
[10:34:10.482]         ...future.stdout <- NULL
[10:34:10.482]     }
[10:34:10.482]     ...future.result$conditions <- ...future.conditions
[10:34:10.482]     ...future.result$finished <- base::Sys.time()
[10:34:10.482]     ...future.result
[10:34:10.482] }
[10:34:10.485] MultisessionFuture started
[10:34:10.485] - Launch lazy future ... done
[10:34:10.485] run() for ‘MultisessionFuture’ ... done
[10:34:10.987] receiveMessageFromWorker() for ClusterFuture ...
[10:34:10.987] - Validating connection of MultisessionFuture
[10:34:10.988] - received message: FutureResult
[10:34:10.988] - Received FutureResult
[10:34:10.988] - Erased future from FutureRegistry
[10:34:10.988] result() for ClusterFuture ...
[10:34:10.988] - result already collected: FutureResult
[10:34:10.988] result() for ClusterFuture ... done
[10:34:10.988] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:10.988] resolve() on list ...
[10:34:10.989]  recursive: 98
[10:34:10.989]  length: 2
[10:34:10.989]  elements: ‘a’, ‘b’
[10:34:10.989]  length: 1 (resolved future 1)
[10:34:10.989]  length: 0 (resolved future 2)
[10:34:10.989] resolve() on list ... DONE
[10:34:10.989] A MultisessionFuture was resolved (and resolved itself)
[10:34:10.989] getGlobalsAndPackages() ...
[10:34:10.989] Searching for globals...
[10:34:10.990] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:34:10.991] Searching for globals ... DONE
[10:34:10.991] Resolving globals: FALSE
[10:34:10.991] 
[10:34:10.991] 
[10:34:10.991] getGlobalsAndPackages() ... DONE
[10:34:10.991] run() for ‘Future’ ...
[10:34:10.992] - state: ‘created’
[10:34:10.992] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:11.005] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:11.006] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:11.006]   - Field: ‘node’
[10:34:11.006]   - Field: ‘label’
[10:34:11.006]   - Field: ‘local’
[10:34:11.006]   - Field: ‘owner’
[10:34:11.006]   - Field: ‘envir’
[10:34:11.006]   - Field: ‘workers’
[10:34:11.006]   - Field: ‘packages’
[10:34:11.006]   - Field: ‘gc’
[10:34:11.006]   - Field: ‘conditions’
[10:34:11.007]   - Field: ‘persistent’
[10:34:11.007]   - Field: ‘expr’
[10:34:11.007]   - Field: ‘uuid’
[10:34:11.007]   - Field: ‘seed’
[10:34:11.007]   - Field: ‘version’
[10:34:11.007]   - Field: ‘result’
[10:34:11.007]   - Field: ‘asynchronous’
[10:34:11.007]   - Field: ‘calls’
[10:34:11.007]   - Field: ‘globals’
[10:34:11.007]   - Field: ‘stdout’
[10:34:11.007]   - Field: ‘earlySignal’
[10:34:11.008]   - Field: ‘lazy’
[10:34:11.008]   - Field: ‘state’
[10:34:11.008] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:11.008] - Launch lazy future ...
[10:34:11.008] Packages needed by the future expression (n = 0): <none>
[10:34:11.008] Packages needed by future strategies (n = 0): <none>
[10:34:11.009] {
[10:34:11.009]     {
[10:34:11.009]         {
[10:34:11.009]             ...future.startTime <- base::Sys.time()
[10:34:11.009]             {
[10:34:11.009]                 {
[10:34:11.009]                   {
[10:34:11.009]                     {
[10:34:11.009]                       base::local({
[10:34:11.009]                         has_future <- base::requireNamespace("future", 
[10:34:11.009]                           quietly = TRUE)
[10:34:11.009]                         if (has_future) {
[10:34:11.009]                           ns <- base::getNamespace("future")
[10:34:11.009]                           version <- ns[[".package"]][["version"]]
[10:34:11.009]                           if (is.null(version)) 
[10:34:11.009]                             version <- utils::packageVersion("future")
[10:34:11.009]                         }
[10:34:11.009]                         else {
[10:34:11.009]                           version <- NULL
[10:34:11.009]                         }
[10:34:11.009]                         if (!has_future || version < "1.8.0") {
[10:34:11.009]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:11.009]                             "", base::R.version$version.string), 
[10:34:11.009]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:11.009]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:11.009]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:11.009]                               "release", "version")], collapse = " "), 
[10:34:11.009]                             hostname = base::Sys.info()[["nodename"]])
[10:34:11.009]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:11.009]                             info)
[10:34:11.009]                           info <- base::paste(info, collapse = "; ")
[10:34:11.009]                           if (!has_future) {
[10:34:11.009]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:11.009]                               info)
[10:34:11.009]                           }
[10:34:11.009]                           else {
[10:34:11.009]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:11.009]                               info, version)
[10:34:11.009]                           }
[10:34:11.009]                           base::stop(msg)
[10:34:11.009]                         }
[10:34:11.009]                       })
[10:34:11.009]                     }
[10:34:11.009]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:11.009]                     base::options(mc.cores = 1L)
[10:34:11.009]                   }
[10:34:11.009]                   ...future.strategy.old <- future::plan("list")
[10:34:11.009]                   options(future.plan = NULL)
[10:34:11.009]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:11.009]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:11.009]                 }
[10:34:11.009]                 ...future.workdir <- getwd()
[10:34:11.009]             }
[10:34:11.009]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:11.009]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:11.009]         }
[10:34:11.009]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:11.009]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:11.009]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:11.009]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:11.009]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:11.009]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:11.009]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:11.009]             base::names(...future.oldOptions))
[10:34:11.009]     }
[10:34:11.009]     if (FALSE) {
[10:34:11.009]     }
[10:34:11.009]     else {
[10:34:11.009]         if (TRUE) {
[10:34:11.009]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:11.009]                 open = "w")
[10:34:11.009]         }
[10:34:11.009]         else {
[10:34:11.009]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:11.009]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:11.009]         }
[10:34:11.009]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:11.009]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:11.009]             base::sink(type = "output", split = FALSE)
[10:34:11.009]             base::close(...future.stdout)
[10:34:11.009]         }, add = TRUE)
[10:34:11.009]     }
[10:34:11.009]     ...future.frame <- base::sys.nframe()
[10:34:11.009]     ...future.conditions <- base::list()
[10:34:11.009]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:11.009]     if (FALSE) {
[10:34:11.009]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:11.009]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:11.009]     }
[10:34:11.009]     ...future.result <- base::tryCatch({
[10:34:11.009]         base::withCallingHandlers({
[10:34:11.009]             ...future.value <- base::withVisible(base::local({
[10:34:11.009]                 ...future.makeSendCondition <- base::local({
[10:34:11.009]                   sendCondition <- NULL
[10:34:11.009]                   function(frame = 1L) {
[10:34:11.009]                     if (is.function(sendCondition)) 
[10:34:11.009]                       return(sendCondition)
[10:34:11.009]                     ns <- getNamespace("parallel")
[10:34:11.009]                     if (exists("sendData", mode = "function", 
[10:34:11.009]                       envir = ns)) {
[10:34:11.009]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:11.009]                         envir = ns)
[10:34:11.009]                       envir <- sys.frame(frame)
[10:34:11.009]                       master <- NULL
[10:34:11.009]                       while (!identical(envir, .GlobalEnv) && 
[10:34:11.009]                         !identical(envir, emptyenv())) {
[10:34:11.009]                         if (exists("master", mode = "list", envir = envir, 
[10:34:11.009]                           inherits = FALSE)) {
[10:34:11.009]                           master <- get("master", mode = "list", 
[10:34:11.009]                             envir = envir, inherits = FALSE)
[10:34:11.009]                           if (inherits(master, c("SOCKnode", 
[10:34:11.009]                             "SOCK0node"))) {
[10:34:11.009]                             sendCondition <<- function(cond) {
[10:34:11.009]                               data <- list(type = "VALUE", value = cond, 
[10:34:11.009]                                 success = TRUE)
[10:34:11.009]                               parallel_sendData(master, data)
[10:34:11.009]                             }
[10:34:11.009]                             return(sendCondition)
[10:34:11.009]                           }
[10:34:11.009]                         }
[10:34:11.009]                         frame <- frame + 1L
[10:34:11.009]                         envir <- sys.frame(frame)
[10:34:11.009]                       }
[10:34:11.009]                     }
[10:34:11.009]                     sendCondition <<- function(cond) NULL
[10:34:11.009]                   }
[10:34:11.009]                 })
[10:34:11.009]                 withCallingHandlers({
[10:34:11.009]                   {
[10:34:11.009]                     Sys.sleep(0.5)
[10:34:11.009]                     list(a = 1, b = 42L)
[10:34:11.009]                   }
[10:34:11.009]                 }, immediateCondition = function(cond) {
[10:34:11.009]                   sendCondition <- ...future.makeSendCondition()
[10:34:11.009]                   sendCondition(cond)
[10:34:11.009]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:11.009]                   {
[10:34:11.009]                     inherits <- base::inherits
[10:34:11.009]                     invokeRestart <- base::invokeRestart
[10:34:11.009]                     is.null <- base::is.null
[10:34:11.009]                     muffled <- FALSE
[10:34:11.009]                     if (inherits(cond, "message")) {
[10:34:11.009]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:11.009]                       if (muffled) 
[10:34:11.009]                         invokeRestart("muffleMessage")
[10:34:11.009]                     }
[10:34:11.009]                     else if (inherits(cond, "warning")) {
[10:34:11.009]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:11.009]                       if (muffled) 
[10:34:11.009]                         invokeRestart("muffleWarning")
[10:34:11.009]                     }
[10:34:11.009]                     else if (inherits(cond, "condition")) {
[10:34:11.009]                       if (!is.null(pattern)) {
[10:34:11.009]                         computeRestarts <- base::computeRestarts
[10:34:11.009]                         grepl <- base::grepl
[10:34:11.009]                         restarts <- computeRestarts(cond)
[10:34:11.009]                         for (restart in restarts) {
[10:34:11.009]                           name <- restart$name
[10:34:11.009]                           if (is.null(name)) 
[10:34:11.009]                             next
[10:34:11.009]                           if (!grepl(pattern, name)) 
[10:34:11.009]                             next
[10:34:11.009]                           invokeRestart(restart)
[10:34:11.009]                           muffled <- TRUE
[10:34:11.009]                           break
[10:34:11.009]                         }
[10:34:11.009]                       }
[10:34:11.009]                     }
[10:34:11.009]                     invisible(muffled)
[10:34:11.009]                   }
[10:34:11.009]                   muffleCondition(cond)
[10:34:11.009]                 })
[10:34:11.009]             }))
[10:34:11.009]             future::FutureResult(value = ...future.value$value, 
[10:34:11.009]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:11.009]                   ...future.rng), globalenv = if (FALSE) 
[10:34:11.009]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:11.009]                     ...future.globalenv.names))
[10:34:11.009]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:11.009]         }, condition = base::local({
[10:34:11.009]             c <- base::c
[10:34:11.009]             inherits <- base::inherits
[10:34:11.009]             invokeRestart <- base::invokeRestart
[10:34:11.009]             length <- base::length
[10:34:11.009]             list <- base::list
[10:34:11.009]             seq.int <- base::seq.int
[10:34:11.009]             signalCondition <- base::signalCondition
[10:34:11.009]             sys.calls <- base::sys.calls
[10:34:11.009]             `[[` <- base::`[[`
[10:34:11.009]             `+` <- base::`+`
[10:34:11.009]             `<<-` <- base::`<<-`
[10:34:11.009]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:11.009]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:11.009]                   3L)]
[10:34:11.009]             }
[10:34:11.009]             function(cond) {
[10:34:11.009]                 is_error <- inherits(cond, "error")
[10:34:11.009]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:11.009]                   NULL)
[10:34:11.009]                 if (is_error) {
[10:34:11.009]                   sessionInformation <- function() {
[10:34:11.009]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:11.009]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:11.009]                       search = base::search(), system = base::Sys.info())
[10:34:11.009]                   }
[10:34:11.009]                   ...future.conditions[[length(...future.conditions) + 
[10:34:11.009]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:11.009]                     cond$call), session = sessionInformation(), 
[10:34:11.009]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:11.009]                   signalCondition(cond)
[10:34:11.009]                 }
[10:34:11.009]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:11.009]                 "immediateCondition"))) {
[10:34:11.009]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:11.009]                   ...future.conditions[[length(...future.conditions) + 
[10:34:11.009]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:11.009]                   if (TRUE && !signal) {
[10:34:11.009]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:11.009]                     {
[10:34:11.009]                       inherits <- base::inherits
[10:34:11.009]                       invokeRestart <- base::invokeRestart
[10:34:11.009]                       is.null <- base::is.null
[10:34:11.009]                       muffled <- FALSE
[10:34:11.009]                       if (inherits(cond, "message")) {
[10:34:11.009]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:11.009]                         if (muffled) 
[10:34:11.009]                           invokeRestart("muffleMessage")
[10:34:11.009]                       }
[10:34:11.009]                       else if (inherits(cond, "warning")) {
[10:34:11.009]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:11.009]                         if (muffled) 
[10:34:11.009]                           invokeRestart("muffleWarning")
[10:34:11.009]                       }
[10:34:11.009]                       else if (inherits(cond, "condition")) {
[10:34:11.009]                         if (!is.null(pattern)) {
[10:34:11.009]                           computeRestarts <- base::computeRestarts
[10:34:11.009]                           grepl <- base::grepl
[10:34:11.009]                           restarts <- computeRestarts(cond)
[10:34:11.009]                           for (restart in restarts) {
[10:34:11.009]                             name <- restart$name
[10:34:11.009]                             if (is.null(name)) 
[10:34:11.009]                               next
[10:34:11.009]                             if (!grepl(pattern, name)) 
[10:34:11.009]                               next
[10:34:11.009]                             invokeRestart(restart)
[10:34:11.009]                             muffled <- TRUE
[10:34:11.009]                             break
[10:34:11.009]                           }
[10:34:11.009]                         }
[10:34:11.009]                       }
[10:34:11.009]                       invisible(muffled)
[10:34:11.009]                     }
[10:34:11.009]                     muffleCondition(cond, pattern = "^muffle")
[10:34:11.009]                   }
[10:34:11.009]                 }
[10:34:11.009]                 else {
[10:34:11.009]                   if (TRUE) {
[10:34:11.009]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:11.009]                     {
[10:34:11.009]                       inherits <- base::inherits
[10:34:11.009]                       invokeRestart <- base::invokeRestart
[10:34:11.009]                       is.null <- base::is.null
[10:34:11.009]                       muffled <- FALSE
[10:34:11.009]                       if (inherits(cond, "message")) {
[10:34:11.009]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:11.009]                         if (muffled) 
[10:34:11.009]                           invokeRestart("muffleMessage")
[10:34:11.009]                       }
[10:34:11.009]                       else if (inherits(cond, "warning")) {
[10:34:11.009]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:11.009]                         if (muffled) 
[10:34:11.009]                           invokeRestart("muffleWarning")
[10:34:11.009]                       }
[10:34:11.009]                       else if (inherits(cond, "condition")) {
[10:34:11.009]                         if (!is.null(pattern)) {
[10:34:11.009]                           computeRestarts <- base::computeRestarts
[10:34:11.009]                           grepl <- base::grepl
[10:34:11.009]                           restarts <- computeRestarts(cond)
[10:34:11.009]                           for (restart in restarts) {
[10:34:11.009]                             name <- restart$name
[10:34:11.009]                             if (is.null(name)) 
[10:34:11.009]                               next
[10:34:11.009]                             if (!grepl(pattern, name)) 
[10:34:11.009]                               next
[10:34:11.009]                             invokeRestart(restart)
[10:34:11.009]                             muffled <- TRUE
[10:34:11.009]                             break
[10:34:11.009]                           }
[10:34:11.009]                         }
[10:34:11.009]                       }
[10:34:11.009]                       invisible(muffled)
[10:34:11.009]                     }
[10:34:11.009]                     muffleCondition(cond, pattern = "^muffle")
[10:34:11.009]                   }
[10:34:11.009]                 }
[10:34:11.009]             }
[10:34:11.009]         }))
[10:34:11.009]     }, error = function(ex) {
[10:34:11.009]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:11.009]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:11.009]                 ...future.rng), started = ...future.startTime, 
[10:34:11.009]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:11.009]             version = "1.8"), class = "FutureResult")
[10:34:11.009]     }, finally = {
[10:34:11.009]         if (!identical(...future.workdir, getwd())) 
[10:34:11.009]             setwd(...future.workdir)
[10:34:11.009]         {
[10:34:11.009]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:11.009]                 ...future.oldOptions$nwarnings <- NULL
[10:34:11.009]             }
[10:34:11.009]             base::options(...future.oldOptions)
[10:34:11.009]             if (.Platform$OS.type == "windows") {
[10:34:11.009]                 old_names <- names(...future.oldEnvVars)
[10:34:11.009]                 envs <- base::Sys.getenv()
[10:34:11.009]                 names <- names(envs)
[10:34:11.009]                 common <- intersect(names, old_names)
[10:34:11.009]                 added <- setdiff(names, old_names)
[10:34:11.009]                 removed <- setdiff(old_names, names)
[10:34:11.009]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:11.009]                   envs[common]]
[10:34:11.009]                 NAMES <- toupper(changed)
[10:34:11.009]                 args <- list()
[10:34:11.009]                 for (kk in seq_along(NAMES)) {
[10:34:11.009]                   name <- changed[[kk]]
[10:34:11.009]                   NAME <- NAMES[[kk]]
[10:34:11.009]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:11.009]                     next
[10:34:11.009]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:11.009]                 }
[10:34:11.009]                 NAMES <- toupper(added)
[10:34:11.009]                 for (kk in seq_along(NAMES)) {
[10:34:11.009]                   name <- added[[kk]]
[10:34:11.009]                   NAME <- NAMES[[kk]]
[10:34:11.009]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:11.009]                     next
[10:34:11.009]                   args[[name]] <- ""
[10:34:11.009]                 }
[10:34:11.009]                 NAMES <- toupper(removed)
[10:34:11.009]                 for (kk in seq_along(NAMES)) {
[10:34:11.009]                   name <- removed[[kk]]
[10:34:11.009]                   NAME <- NAMES[[kk]]
[10:34:11.009]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:11.009]                     next
[10:34:11.009]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:11.009]                 }
[10:34:11.009]                 if (length(args) > 0) 
[10:34:11.009]                   base::do.call(base::Sys.setenv, args = args)
[10:34:11.009]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:11.009]             }
[10:34:11.009]             else {
[10:34:11.009]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:11.009]             }
[10:34:11.009]             {
[10:34:11.009]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:11.009]                   0L) {
[10:34:11.009]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:11.009]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:11.009]                   base::options(opts)
[10:34:11.009]                 }
[10:34:11.009]                 {
[10:34:11.009]                   {
[10:34:11.009]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:11.009]                     NULL
[10:34:11.009]                   }
[10:34:11.009]                   options(future.plan = NULL)
[10:34:11.009]                   if (is.na(NA_character_)) 
[10:34:11.009]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:11.009]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:11.009]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:11.009]                     .init = FALSE)
[10:34:11.009]                 }
[10:34:11.009]             }
[10:34:11.009]         }
[10:34:11.009]     })
[10:34:11.009]     if (TRUE) {
[10:34:11.009]         base::sink(type = "output", split = FALSE)
[10:34:11.009]         if (TRUE) {
[10:34:11.009]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:11.009]         }
[10:34:11.009]         else {
[10:34:11.009]             ...future.result["stdout"] <- base::list(NULL)
[10:34:11.009]         }
[10:34:11.009]         base::close(...future.stdout)
[10:34:11.009]         ...future.stdout <- NULL
[10:34:11.009]     }
[10:34:11.009]     ...future.result$conditions <- ...future.conditions
[10:34:11.009]     ...future.result$finished <- base::Sys.time()
[10:34:11.009]     ...future.result
[10:34:11.009] }
[10:34:11.011] MultisessionFuture started
[10:34:11.012] - Launch lazy future ... done
[10:34:11.012] run() for ‘MultisessionFuture’ ... done
[10:34:11.514] receiveMessageFromWorker() for ClusterFuture ...
[10:34:11.514] - Validating connection of MultisessionFuture
[10:34:11.514] - received message: FutureResult
[10:34:11.515] - Received FutureResult
[10:34:11.515] - Erased future from FutureRegistry
[10:34:11.515] result() for ClusterFuture ...
[10:34:11.515] - result already collected: FutureResult
[10:34:11.515] result() for ClusterFuture ... done
[10:34:11.515] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:11.515] resolve() on list ...
[10:34:11.515]  recursive: 98
[10:34:11.515]  length: 2
[10:34:11.516]  elements: ‘a’, ‘b’
[10:34:11.516]  length: 1 (resolved future 1)
[10:34:11.516]  length: 0 (resolved future 2)
[10:34:11.516] resolve() on list ... DONE
[10:34:11.516] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[10:34:11.516] getGlobalsAndPackages() ...
[10:34:11.516] Searching for globals...
[10:34:11.517] - globals found: [2] ‘list’, ‘stop’
[10:34:11.517] Searching for globals ... DONE
[10:34:11.517] Resolving globals: FALSE
[10:34:11.518] 
[10:34:11.518] 
[10:34:11.518] getGlobalsAndPackages() ... DONE
[10:34:11.518] run() for ‘Future’ ...
[10:34:11.523] - state: ‘created’
[10:34:11.523] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:11.540] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:11.540] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:11.540]   - Field: ‘node’
[10:34:11.541]   - Field: ‘label’
[10:34:11.541]   - Field: ‘local’
[10:34:11.541]   - Field: ‘owner’
[10:34:11.541]   - Field: ‘envir’
[10:34:11.541]   - Field: ‘workers’
[10:34:11.541]   - Field: ‘packages’
[10:34:11.541]   - Field: ‘gc’
[10:34:11.541]   - Field: ‘conditions’
[10:34:11.541]   - Field: ‘persistent’
[10:34:11.541]   - Field: ‘expr’
[10:34:11.542]   - Field: ‘uuid’
[10:34:11.542]   - Field: ‘seed’
[10:34:11.542]   - Field: ‘version’
[10:34:11.542]   - Field: ‘result’
[10:34:11.542]   - Field: ‘asynchronous’
[10:34:11.542]   - Field: ‘calls’
[10:34:11.542]   - Field: ‘globals’
[10:34:11.542]   - Field: ‘stdout’
[10:34:11.542]   - Field: ‘earlySignal’
[10:34:11.542]   - Field: ‘lazy’
[10:34:11.542]   - Field: ‘state’
[10:34:11.542] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:11.543] - Launch lazy future ...
[10:34:11.543] Packages needed by the future expression (n = 0): <none>
[10:34:11.543] Packages needed by future strategies (n = 0): <none>
[10:34:11.543] {
[10:34:11.543]     {
[10:34:11.543]         {
[10:34:11.543]             ...future.startTime <- base::Sys.time()
[10:34:11.543]             {
[10:34:11.543]                 {
[10:34:11.543]                   {
[10:34:11.543]                     {
[10:34:11.543]                       base::local({
[10:34:11.543]                         has_future <- base::requireNamespace("future", 
[10:34:11.543]                           quietly = TRUE)
[10:34:11.543]                         if (has_future) {
[10:34:11.543]                           ns <- base::getNamespace("future")
[10:34:11.543]                           version <- ns[[".package"]][["version"]]
[10:34:11.543]                           if (is.null(version)) 
[10:34:11.543]                             version <- utils::packageVersion("future")
[10:34:11.543]                         }
[10:34:11.543]                         else {
[10:34:11.543]                           version <- NULL
[10:34:11.543]                         }
[10:34:11.543]                         if (!has_future || version < "1.8.0") {
[10:34:11.543]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:11.543]                             "", base::R.version$version.string), 
[10:34:11.543]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:11.543]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:11.543]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:11.543]                               "release", "version")], collapse = " "), 
[10:34:11.543]                             hostname = base::Sys.info()[["nodename"]])
[10:34:11.543]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:11.543]                             info)
[10:34:11.543]                           info <- base::paste(info, collapse = "; ")
[10:34:11.543]                           if (!has_future) {
[10:34:11.543]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:11.543]                               info)
[10:34:11.543]                           }
[10:34:11.543]                           else {
[10:34:11.543]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:11.543]                               info, version)
[10:34:11.543]                           }
[10:34:11.543]                           base::stop(msg)
[10:34:11.543]                         }
[10:34:11.543]                       })
[10:34:11.543]                     }
[10:34:11.543]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:11.543]                     base::options(mc.cores = 1L)
[10:34:11.543]                   }
[10:34:11.543]                   ...future.strategy.old <- future::plan("list")
[10:34:11.543]                   options(future.plan = NULL)
[10:34:11.543]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:11.543]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:11.543]                 }
[10:34:11.543]                 ...future.workdir <- getwd()
[10:34:11.543]             }
[10:34:11.543]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:11.543]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:11.543]         }
[10:34:11.543]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:11.543]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:11.543]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:11.543]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:11.543]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:11.543]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:11.543]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:11.543]             base::names(...future.oldOptions))
[10:34:11.543]     }
[10:34:11.543]     if (FALSE) {
[10:34:11.543]     }
[10:34:11.543]     else {
[10:34:11.543]         if (TRUE) {
[10:34:11.543]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:11.543]                 open = "w")
[10:34:11.543]         }
[10:34:11.543]         else {
[10:34:11.543]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:11.543]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:11.543]         }
[10:34:11.543]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:11.543]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:11.543]             base::sink(type = "output", split = FALSE)
[10:34:11.543]             base::close(...future.stdout)
[10:34:11.543]         }, add = TRUE)
[10:34:11.543]     }
[10:34:11.543]     ...future.frame <- base::sys.nframe()
[10:34:11.543]     ...future.conditions <- base::list()
[10:34:11.543]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:11.543]     if (FALSE) {
[10:34:11.543]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:11.543]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:11.543]     }
[10:34:11.543]     ...future.result <- base::tryCatch({
[10:34:11.543]         base::withCallingHandlers({
[10:34:11.543]             ...future.value <- base::withVisible(base::local({
[10:34:11.543]                 ...future.makeSendCondition <- base::local({
[10:34:11.543]                   sendCondition <- NULL
[10:34:11.543]                   function(frame = 1L) {
[10:34:11.543]                     if (is.function(sendCondition)) 
[10:34:11.543]                       return(sendCondition)
[10:34:11.543]                     ns <- getNamespace("parallel")
[10:34:11.543]                     if (exists("sendData", mode = "function", 
[10:34:11.543]                       envir = ns)) {
[10:34:11.543]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:11.543]                         envir = ns)
[10:34:11.543]                       envir <- sys.frame(frame)
[10:34:11.543]                       master <- NULL
[10:34:11.543]                       while (!identical(envir, .GlobalEnv) && 
[10:34:11.543]                         !identical(envir, emptyenv())) {
[10:34:11.543]                         if (exists("master", mode = "list", envir = envir, 
[10:34:11.543]                           inherits = FALSE)) {
[10:34:11.543]                           master <- get("master", mode = "list", 
[10:34:11.543]                             envir = envir, inherits = FALSE)
[10:34:11.543]                           if (inherits(master, c("SOCKnode", 
[10:34:11.543]                             "SOCK0node"))) {
[10:34:11.543]                             sendCondition <<- function(cond) {
[10:34:11.543]                               data <- list(type = "VALUE", value = cond, 
[10:34:11.543]                                 success = TRUE)
[10:34:11.543]                               parallel_sendData(master, data)
[10:34:11.543]                             }
[10:34:11.543]                             return(sendCondition)
[10:34:11.543]                           }
[10:34:11.543]                         }
[10:34:11.543]                         frame <- frame + 1L
[10:34:11.543]                         envir <- sys.frame(frame)
[10:34:11.543]                       }
[10:34:11.543]                     }
[10:34:11.543]                     sendCondition <<- function(cond) NULL
[10:34:11.543]                   }
[10:34:11.543]                 })
[10:34:11.543]                 withCallingHandlers({
[10:34:11.543]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:34:11.543]                 }, immediateCondition = function(cond) {
[10:34:11.543]                   sendCondition <- ...future.makeSendCondition()
[10:34:11.543]                   sendCondition(cond)
[10:34:11.543]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:11.543]                   {
[10:34:11.543]                     inherits <- base::inherits
[10:34:11.543]                     invokeRestart <- base::invokeRestart
[10:34:11.543]                     is.null <- base::is.null
[10:34:11.543]                     muffled <- FALSE
[10:34:11.543]                     if (inherits(cond, "message")) {
[10:34:11.543]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:11.543]                       if (muffled) 
[10:34:11.543]                         invokeRestart("muffleMessage")
[10:34:11.543]                     }
[10:34:11.543]                     else if (inherits(cond, "warning")) {
[10:34:11.543]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:11.543]                       if (muffled) 
[10:34:11.543]                         invokeRestart("muffleWarning")
[10:34:11.543]                     }
[10:34:11.543]                     else if (inherits(cond, "condition")) {
[10:34:11.543]                       if (!is.null(pattern)) {
[10:34:11.543]                         computeRestarts <- base::computeRestarts
[10:34:11.543]                         grepl <- base::grepl
[10:34:11.543]                         restarts <- computeRestarts(cond)
[10:34:11.543]                         for (restart in restarts) {
[10:34:11.543]                           name <- restart$name
[10:34:11.543]                           if (is.null(name)) 
[10:34:11.543]                             next
[10:34:11.543]                           if (!grepl(pattern, name)) 
[10:34:11.543]                             next
[10:34:11.543]                           invokeRestart(restart)
[10:34:11.543]                           muffled <- TRUE
[10:34:11.543]                           break
[10:34:11.543]                         }
[10:34:11.543]                       }
[10:34:11.543]                     }
[10:34:11.543]                     invisible(muffled)
[10:34:11.543]                   }
[10:34:11.543]                   muffleCondition(cond)
[10:34:11.543]                 })
[10:34:11.543]             }))
[10:34:11.543]             future::FutureResult(value = ...future.value$value, 
[10:34:11.543]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:11.543]                   ...future.rng), globalenv = if (FALSE) 
[10:34:11.543]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:11.543]                     ...future.globalenv.names))
[10:34:11.543]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:11.543]         }, condition = base::local({
[10:34:11.543]             c <- base::c
[10:34:11.543]             inherits <- base::inherits
[10:34:11.543]             invokeRestart <- base::invokeRestart
[10:34:11.543]             length <- base::length
[10:34:11.543]             list <- base::list
[10:34:11.543]             seq.int <- base::seq.int
[10:34:11.543]             signalCondition <- base::signalCondition
[10:34:11.543]             sys.calls <- base::sys.calls
[10:34:11.543]             `[[` <- base::`[[`
[10:34:11.543]             `+` <- base::`+`
[10:34:11.543]             `<<-` <- base::`<<-`
[10:34:11.543]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:11.543]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:11.543]                   3L)]
[10:34:11.543]             }
[10:34:11.543]             function(cond) {
[10:34:11.543]                 is_error <- inherits(cond, "error")
[10:34:11.543]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:11.543]                   NULL)
[10:34:11.543]                 if (is_error) {
[10:34:11.543]                   sessionInformation <- function() {
[10:34:11.543]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:11.543]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:11.543]                       search = base::search(), system = base::Sys.info())
[10:34:11.543]                   }
[10:34:11.543]                   ...future.conditions[[length(...future.conditions) + 
[10:34:11.543]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:11.543]                     cond$call), session = sessionInformation(), 
[10:34:11.543]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:11.543]                   signalCondition(cond)
[10:34:11.543]                 }
[10:34:11.543]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:11.543]                 "immediateCondition"))) {
[10:34:11.543]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:11.543]                   ...future.conditions[[length(...future.conditions) + 
[10:34:11.543]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:11.543]                   if (TRUE && !signal) {
[10:34:11.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:11.543]                     {
[10:34:11.543]                       inherits <- base::inherits
[10:34:11.543]                       invokeRestart <- base::invokeRestart
[10:34:11.543]                       is.null <- base::is.null
[10:34:11.543]                       muffled <- FALSE
[10:34:11.543]                       if (inherits(cond, "message")) {
[10:34:11.543]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:11.543]                         if (muffled) 
[10:34:11.543]                           invokeRestart("muffleMessage")
[10:34:11.543]                       }
[10:34:11.543]                       else if (inherits(cond, "warning")) {
[10:34:11.543]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:11.543]                         if (muffled) 
[10:34:11.543]                           invokeRestart("muffleWarning")
[10:34:11.543]                       }
[10:34:11.543]                       else if (inherits(cond, "condition")) {
[10:34:11.543]                         if (!is.null(pattern)) {
[10:34:11.543]                           computeRestarts <- base::computeRestarts
[10:34:11.543]                           grepl <- base::grepl
[10:34:11.543]                           restarts <- computeRestarts(cond)
[10:34:11.543]                           for (restart in restarts) {
[10:34:11.543]                             name <- restart$name
[10:34:11.543]                             if (is.null(name)) 
[10:34:11.543]                               next
[10:34:11.543]                             if (!grepl(pattern, name)) 
[10:34:11.543]                               next
[10:34:11.543]                             invokeRestart(restart)
[10:34:11.543]                             muffled <- TRUE
[10:34:11.543]                             break
[10:34:11.543]                           }
[10:34:11.543]                         }
[10:34:11.543]                       }
[10:34:11.543]                       invisible(muffled)
[10:34:11.543]                     }
[10:34:11.543]                     muffleCondition(cond, pattern = "^muffle")
[10:34:11.543]                   }
[10:34:11.543]                 }
[10:34:11.543]                 else {
[10:34:11.543]                   if (TRUE) {
[10:34:11.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:11.543]                     {
[10:34:11.543]                       inherits <- base::inherits
[10:34:11.543]                       invokeRestart <- base::invokeRestart
[10:34:11.543]                       is.null <- base::is.null
[10:34:11.543]                       muffled <- FALSE
[10:34:11.543]                       if (inherits(cond, "message")) {
[10:34:11.543]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:11.543]                         if (muffled) 
[10:34:11.543]                           invokeRestart("muffleMessage")
[10:34:11.543]                       }
[10:34:11.543]                       else if (inherits(cond, "warning")) {
[10:34:11.543]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:11.543]                         if (muffled) 
[10:34:11.543]                           invokeRestart("muffleWarning")
[10:34:11.543]                       }
[10:34:11.543]                       else if (inherits(cond, "condition")) {
[10:34:11.543]                         if (!is.null(pattern)) {
[10:34:11.543]                           computeRestarts <- base::computeRestarts
[10:34:11.543]                           grepl <- base::grepl
[10:34:11.543]                           restarts <- computeRestarts(cond)
[10:34:11.543]                           for (restart in restarts) {
[10:34:11.543]                             name <- restart$name
[10:34:11.543]                             if (is.null(name)) 
[10:34:11.543]                               next
[10:34:11.543]                             if (!grepl(pattern, name)) 
[10:34:11.543]                               next
[10:34:11.543]                             invokeRestart(restart)
[10:34:11.543]                             muffled <- TRUE
[10:34:11.543]                             break
[10:34:11.543]                           }
[10:34:11.543]                         }
[10:34:11.543]                       }
[10:34:11.543]                       invisible(muffled)
[10:34:11.543]                     }
[10:34:11.543]                     muffleCondition(cond, pattern = "^muffle")
[10:34:11.543]                   }
[10:34:11.543]                 }
[10:34:11.543]             }
[10:34:11.543]         }))
[10:34:11.543]     }, error = function(ex) {
[10:34:11.543]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:11.543]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:11.543]                 ...future.rng), started = ...future.startTime, 
[10:34:11.543]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:11.543]             version = "1.8"), class = "FutureResult")
[10:34:11.543]     }, finally = {
[10:34:11.543]         if (!identical(...future.workdir, getwd())) 
[10:34:11.543]             setwd(...future.workdir)
[10:34:11.543]         {
[10:34:11.543]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:11.543]                 ...future.oldOptions$nwarnings <- NULL
[10:34:11.543]             }
[10:34:11.543]             base::options(...future.oldOptions)
[10:34:11.543]             if (.Platform$OS.type == "windows") {
[10:34:11.543]                 old_names <- names(...future.oldEnvVars)
[10:34:11.543]                 envs <- base::Sys.getenv()
[10:34:11.543]                 names <- names(envs)
[10:34:11.543]                 common <- intersect(names, old_names)
[10:34:11.543]                 added <- setdiff(names, old_names)
[10:34:11.543]                 removed <- setdiff(old_names, names)
[10:34:11.543]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:11.543]                   envs[common]]
[10:34:11.543]                 NAMES <- toupper(changed)
[10:34:11.543]                 args <- list()
[10:34:11.543]                 for (kk in seq_along(NAMES)) {
[10:34:11.543]                   name <- changed[[kk]]
[10:34:11.543]                   NAME <- NAMES[[kk]]
[10:34:11.543]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:11.543]                     next
[10:34:11.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:11.543]                 }
[10:34:11.543]                 NAMES <- toupper(added)
[10:34:11.543]                 for (kk in seq_along(NAMES)) {
[10:34:11.543]                   name <- added[[kk]]
[10:34:11.543]                   NAME <- NAMES[[kk]]
[10:34:11.543]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:11.543]                     next
[10:34:11.543]                   args[[name]] <- ""
[10:34:11.543]                 }
[10:34:11.543]                 NAMES <- toupper(removed)
[10:34:11.543]                 for (kk in seq_along(NAMES)) {
[10:34:11.543]                   name <- removed[[kk]]
[10:34:11.543]                   NAME <- NAMES[[kk]]
[10:34:11.543]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:11.543]                     next
[10:34:11.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:11.543]                 }
[10:34:11.543]                 if (length(args) > 0) 
[10:34:11.543]                   base::do.call(base::Sys.setenv, args = args)
[10:34:11.543]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:11.543]             }
[10:34:11.543]             else {
[10:34:11.543]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:11.543]             }
[10:34:11.543]             {
[10:34:11.543]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:11.543]                   0L) {
[10:34:11.543]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:11.543]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:11.543]                   base::options(opts)
[10:34:11.543]                 }
[10:34:11.543]                 {
[10:34:11.543]                   {
[10:34:11.543]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:11.543]                     NULL
[10:34:11.543]                   }
[10:34:11.543]                   options(future.plan = NULL)
[10:34:11.543]                   if (is.na(NA_character_)) 
[10:34:11.543]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:11.543]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:11.543]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:11.543]                     .init = FALSE)
[10:34:11.543]                 }
[10:34:11.543]             }
[10:34:11.543]         }
[10:34:11.543]     })
[10:34:11.543]     if (TRUE) {
[10:34:11.543]         base::sink(type = "output", split = FALSE)
[10:34:11.543]         if (TRUE) {
[10:34:11.543]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:11.543]         }
[10:34:11.543]         else {
[10:34:11.543]             ...future.result["stdout"] <- base::list(NULL)
[10:34:11.543]         }
[10:34:11.543]         base::close(...future.stdout)
[10:34:11.543]         ...future.stdout <- NULL
[10:34:11.543]     }
[10:34:11.543]     ...future.result$conditions <- ...future.conditions
[10:34:11.543]     ...future.result$finished <- base::Sys.time()
[10:34:11.543]     ...future.result
[10:34:11.543] }
[10:34:11.546] MultisessionFuture started
[10:34:11.546] - Launch lazy future ... done
[10:34:11.546] run() for ‘MultisessionFuture’ ... done
[10:34:11.548] receiveMessageFromWorker() for ClusterFuture ...
[10:34:11.548] - Validating connection of MultisessionFuture
[10:34:11.549] - received message: FutureResult
[10:34:11.549] - Received FutureResult
[10:34:11.549] - Erased future from FutureRegistry
[10:34:11.549] result() for ClusterFuture ...
[10:34:11.549] - result already collected: FutureResult
[10:34:11.549] result() for ClusterFuture ... done
[10:34:11.549] signalConditions() ...
[10:34:11.549]  - include = ‘immediateCondition’
[10:34:11.549]  - exclude = 
[10:34:11.549]  - resignal = FALSE
[10:34:11.549]  - Number of conditions: 1
[10:34:11.550] signalConditions() ... done
[10:34:11.550] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:11.550] A MultisessionFuture was resolved
[10:34:11.550] getGlobalsAndPackages() ...
[10:34:11.550] Searching for globals...
[10:34:11.551] - globals found: [2] ‘list’, ‘stop’
[10:34:11.551] Searching for globals ... DONE
[10:34:11.551] Resolving globals: FALSE
[10:34:11.551] 
[10:34:11.551] 
[10:34:11.551] getGlobalsAndPackages() ... DONE
[10:34:11.551] run() for ‘Future’ ...
[10:34:11.552] - state: ‘created’
[10:34:11.552] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:11.565] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:11.565] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:11.565]   - Field: ‘node’
[10:34:11.565]   - Field: ‘label’
[10:34:11.566]   - Field: ‘local’
[10:34:11.566]   - Field: ‘owner’
[10:34:11.566]   - Field: ‘envir’
[10:34:11.566]   - Field: ‘workers’
[10:34:11.566]   - Field: ‘packages’
[10:34:11.566]   - Field: ‘gc’
[10:34:11.566]   - Field: ‘conditions’
[10:34:11.566]   - Field: ‘persistent’
[10:34:11.566]   - Field: ‘expr’
[10:34:11.566]   - Field: ‘uuid’
[10:34:11.566]   - Field: ‘seed’
[10:34:11.566]   - Field: ‘version’
[10:34:11.567]   - Field: ‘result’
[10:34:11.567]   - Field: ‘asynchronous’
[10:34:11.567]   - Field: ‘calls’
[10:34:11.567]   - Field: ‘globals’
[10:34:11.567]   - Field: ‘stdout’
[10:34:11.567]   - Field: ‘earlySignal’
[10:34:11.567]   - Field: ‘lazy’
[10:34:11.567]   - Field: ‘state’
[10:34:11.567] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:11.567] - Launch lazy future ...
[10:34:11.568] Packages needed by the future expression (n = 0): <none>
[10:34:11.568] Packages needed by future strategies (n = 0): <none>
[10:34:11.568] {
[10:34:11.568]     {
[10:34:11.568]         {
[10:34:11.568]             ...future.startTime <- base::Sys.time()
[10:34:11.568]             {
[10:34:11.568]                 {
[10:34:11.568]                   {
[10:34:11.568]                     {
[10:34:11.568]                       base::local({
[10:34:11.568]                         has_future <- base::requireNamespace("future", 
[10:34:11.568]                           quietly = TRUE)
[10:34:11.568]                         if (has_future) {
[10:34:11.568]                           ns <- base::getNamespace("future")
[10:34:11.568]                           version <- ns[[".package"]][["version"]]
[10:34:11.568]                           if (is.null(version)) 
[10:34:11.568]                             version <- utils::packageVersion("future")
[10:34:11.568]                         }
[10:34:11.568]                         else {
[10:34:11.568]                           version <- NULL
[10:34:11.568]                         }
[10:34:11.568]                         if (!has_future || version < "1.8.0") {
[10:34:11.568]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:11.568]                             "", base::R.version$version.string), 
[10:34:11.568]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:11.568]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:11.568]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:11.568]                               "release", "version")], collapse = " "), 
[10:34:11.568]                             hostname = base::Sys.info()[["nodename"]])
[10:34:11.568]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:11.568]                             info)
[10:34:11.568]                           info <- base::paste(info, collapse = "; ")
[10:34:11.568]                           if (!has_future) {
[10:34:11.568]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:11.568]                               info)
[10:34:11.568]                           }
[10:34:11.568]                           else {
[10:34:11.568]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:11.568]                               info, version)
[10:34:11.568]                           }
[10:34:11.568]                           base::stop(msg)
[10:34:11.568]                         }
[10:34:11.568]                       })
[10:34:11.568]                     }
[10:34:11.568]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:11.568]                     base::options(mc.cores = 1L)
[10:34:11.568]                   }
[10:34:11.568]                   ...future.strategy.old <- future::plan("list")
[10:34:11.568]                   options(future.plan = NULL)
[10:34:11.568]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:11.568]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:11.568]                 }
[10:34:11.568]                 ...future.workdir <- getwd()
[10:34:11.568]             }
[10:34:11.568]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:11.568]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:11.568]         }
[10:34:11.568]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:11.568]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:11.568]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:11.568]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:11.568]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:11.568]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:11.568]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:11.568]             base::names(...future.oldOptions))
[10:34:11.568]     }
[10:34:11.568]     if (FALSE) {
[10:34:11.568]     }
[10:34:11.568]     else {
[10:34:11.568]         if (TRUE) {
[10:34:11.568]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:11.568]                 open = "w")
[10:34:11.568]         }
[10:34:11.568]         else {
[10:34:11.568]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:11.568]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:11.568]         }
[10:34:11.568]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:11.568]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:11.568]             base::sink(type = "output", split = FALSE)
[10:34:11.568]             base::close(...future.stdout)
[10:34:11.568]         }, add = TRUE)
[10:34:11.568]     }
[10:34:11.568]     ...future.frame <- base::sys.nframe()
[10:34:11.568]     ...future.conditions <- base::list()
[10:34:11.568]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:11.568]     if (FALSE) {
[10:34:11.568]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:11.568]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:11.568]     }
[10:34:11.568]     ...future.result <- base::tryCatch({
[10:34:11.568]         base::withCallingHandlers({
[10:34:11.568]             ...future.value <- base::withVisible(base::local({
[10:34:11.568]                 ...future.makeSendCondition <- base::local({
[10:34:11.568]                   sendCondition <- NULL
[10:34:11.568]                   function(frame = 1L) {
[10:34:11.568]                     if (is.function(sendCondition)) 
[10:34:11.568]                       return(sendCondition)
[10:34:11.568]                     ns <- getNamespace("parallel")
[10:34:11.568]                     if (exists("sendData", mode = "function", 
[10:34:11.568]                       envir = ns)) {
[10:34:11.568]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:11.568]                         envir = ns)
[10:34:11.568]                       envir <- sys.frame(frame)
[10:34:11.568]                       master <- NULL
[10:34:11.568]                       while (!identical(envir, .GlobalEnv) && 
[10:34:11.568]                         !identical(envir, emptyenv())) {
[10:34:11.568]                         if (exists("master", mode = "list", envir = envir, 
[10:34:11.568]                           inherits = FALSE)) {
[10:34:11.568]                           master <- get("master", mode = "list", 
[10:34:11.568]                             envir = envir, inherits = FALSE)
[10:34:11.568]                           if (inherits(master, c("SOCKnode", 
[10:34:11.568]                             "SOCK0node"))) {
[10:34:11.568]                             sendCondition <<- function(cond) {
[10:34:11.568]                               data <- list(type = "VALUE", value = cond, 
[10:34:11.568]                                 success = TRUE)
[10:34:11.568]                               parallel_sendData(master, data)
[10:34:11.568]                             }
[10:34:11.568]                             return(sendCondition)
[10:34:11.568]                           }
[10:34:11.568]                         }
[10:34:11.568]                         frame <- frame + 1L
[10:34:11.568]                         envir <- sys.frame(frame)
[10:34:11.568]                       }
[10:34:11.568]                     }
[10:34:11.568]                     sendCondition <<- function(cond) NULL
[10:34:11.568]                   }
[10:34:11.568]                 })
[10:34:11.568]                 withCallingHandlers({
[10:34:11.568]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:34:11.568]                 }, immediateCondition = function(cond) {
[10:34:11.568]                   sendCondition <- ...future.makeSendCondition()
[10:34:11.568]                   sendCondition(cond)
[10:34:11.568]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:11.568]                   {
[10:34:11.568]                     inherits <- base::inherits
[10:34:11.568]                     invokeRestart <- base::invokeRestart
[10:34:11.568]                     is.null <- base::is.null
[10:34:11.568]                     muffled <- FALSE
[10:34:11.568]                     if (inherits(cond, "message")) {
[10:34:11.568]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:11.568]                       if (muffled) 
[10:34:11.568]                         invokeRestart("muffleMessage")
[10:34:11.568]                     }
[10:34:11.568]                     else if (inherits(cond, "warning")) {
[10:34:11.568]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:11.568]                       if (muffled) 
[10:34:11.568]                         invokeRestart("muffleWarning")
[10:34:11.568]                     }
[10:34:11.568]                     else if (inherits(cond, "condition")) {
[10:34:11.568]                       if (!is.null(pattern)) {
[10:34:11.568]                         computeRestarts <- base::computeRestarts
[10:34:11.568]                         grepl <- base::grepl
[10:34:11.568]                         restarts <- computeRestarts(cond)
[10:34:11.568]                         for (restart in restarts) {
[10:34:11.568]                           name <- restart$name
[10:34:11.568]                           if (is.null(name)) 
[10:34:11.568]                             next
[10:34:11.568]                           if (!grepl(pattern, name)) 
[10:34:11.568]                             next
[10:34:11.568]                           invokeRestart(restart)
[10:34:11.568]                           muffled <- TRUE
[10:34:11.568]                           break
[10:34:11.568]                         }
[10:34:11.568]                       }
[10:34:11.568]                     }
[10:34:11.568]                     invisible(muffled)
[10:34:11.568]                   }
[10:34:11.568]                   muffleCondition(cond)
[10:34:11.568]                 })
[10:34:11.568]             }))
[10:34:11.568]             future::FutureResult(value = ...future.value$value, 
[10:34:11.568]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:11.568]                   ...future.rng), globalenv = if (FALSE) 
[10:34:11.568]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:11.568]                     ...future.globalenv.names))
[10:34:11.568]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:11.568]         }, condition = base::local({
[10:34:11.568]             c <- base::c
[10:34:11.568]             inherits <- base::inherits
[10:34:11.568]             invokeRestart <- base::invokeRestart
[10:34:11.568]             length <- base::length
[10:34:11.568]             list <- base::list
[10:34:11.568]             seq.int <- base::seq.int
[10:34:11.568]             signalCondition <- base::signalCondition
[10:34:11.568]             sys.calls <- base::sys.calls
[10:34:11.568]             `[[` <- base::`[[`
[10:34:11.568]             `+` <- base::`+`
[10:34:11.568]             `<<-` <- base::`<<-`
[10:34:11.568]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:11.568]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:11.568]                   3L)]
[10:34:11.568]             }
[10:34:11.568]             function(cond) {
[10:34:11.568]                 is_error <- inherits(cond, "error")
[10:34:11.568]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:11.568]                   NULL)
[10:34:11.568]                 if (is_error) {
[10:34:11.568]                   sessionInformation <- function() {
[10:34:11.568]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:11.568]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:11.568]                       search = base::search(), system = base::Sys.info())
[10:34:11.568]                   }
[10:34:11.568]                   ...future.conditions[[length(...future.conditions) + 
[10:34:11.568]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:11.568]                     cond$call), session = sessionInformation(), 
[10:34:11.568]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:11.568]                   signalCondition(cond)
[10:34:11.568]                 }
[10:34:11.568]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:11.568]                 "immediateCondition"))) {
[10:34:11.568]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:11.568]                   ...future.conditions[[length(...future.conditions) + 
[10:34:11.568]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:11.568]                   if (TRUE && !signal) {
[10:34:11.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:11.568]                     {
[10:34:11.568]                       inherits <- base::inherits
[10:34:11.568]                       invokeRestart <- base::invokeRestart
[10:34:11.568]                       is.null <- base::is.null
[10:34:11.568]                       muffled <- FALSE
[10:34:11.568]                       if (inherits(cond, "message")) {
[10:34:11.568]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:11.568]                         if (muffled) 
[10:34:11.568]                           invokeRestart("muffleMessage")
[10:34:11.568]                       }
[10:34:11.568]                       else if (inherits(cond, "warning")) {
[10:34:11.568]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:11.568]                         if (muffled) 
[10:34:11.568]                           invokeRestart("muffleWarning")
[10:34:11.568]                       }
[10:34:11.568]                       else if (inherits(cond, "condition")) {
[10:34:11.568]                         if (!is.null(pattern)) {
[10:34:11.568]                           computeRestarts <- base::computeRestarts
[10:34:11.568]                           grepl <- base::grepl
[10:34:11.568]                           restarts <- computeRestarts(cond)
[10:34:11.568]                           for (restart in restarts) {
[10:34:11.568]                             name <- restart$name
[10:34:11.568]                             if (is.null(name)) 
[10:34:11.568]                               next
[10:34:11.568]                             if (!grepl(pattern, name)) 
[10:34:11.568]                               next
[10:34:11.568]                             invokeRestart(restart)
[10:34:11.568]                             muffled <- TRUE
[10:34:11.568]                             break
[10:34:11.568]                           }
[10:34:11.568]                         }
[10:34:11.568]                       }
[10:34:11.568]                       invisible(muffled)
[10:34:11.568]                     }
[10:34:11.568]                     muffleCondition(cond, pattern = "^muffle")
[10:34:11.568]                   }
[10:34:11.568]                 }
[10:34:11.568]                 else {
[10:34:11.568]                   if (TRUE) {
[10:34:11.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:11.568]                     {
[10:34:11.568]                       inherits <- base::inherits
[10:34:11.568]                       invokeRestart <- base::invokeRestart
[10:34:11.568]                       is.null <- base::is.null
[10:34:11.568]                       muffled <- FALSE
[10:34:11.568]                       if (inherits(cond, "message")) {
[10:34:11.568]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:11.568]                         if (muffled) 
[10:34:11.568]                           invokeRestart("muffleMessage")
[10:34:11.568]                       }
[10:34:11.568]                       else if (inherits(cond, "warning")) {
[10:34:11.568]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:11.568]                         if (muffled) 
[10:34:11.568]                           invokeRestart("muffleWarning")
[10:34:11.568]                       }
[10:34:11.568]                       else if (inherits(cond, "condition")) {
[10:34:11.568]                         if (!is.null(pattern)) {
[10:34:11.568]                           computeRestarts <- base::computeRestarts
[10:34:11.568]                           grepl <- base::grepl
[10:34:11.568]                           restarts <- computeRestarts(cond)
[10:34:11.568]                           for (restart in restarts) {
[10:34:11.568]                             name <- restart$name
[10:34:11.568]                             if (is.null(name)) 
[10:34:11.568]                               next
[10:34:11.568]                             if (!grepl(pattern, name)) 
[10:34:11.568]                               next
[10:34:11.568]                             invokeRestart(restart)
[10:34:11.568]                             muffled <- TRUE
[10:34:11.568]                             break
[10:34:11.568]                           }
[10:34:11.568]                         }
[10:34:11.568]                       }
[10:34:11.568]                       invisible(muffled)
[10:34:11.568]                     }
[10:34:11.568]                     muffleCondition(cond, pattern = "^muffle")
[10:34:11.568]                   }
[10:34:11.568]                 }
[10:34:11.568]             }
[10:34:11.568]         }))
[10:34:11.568]     }, error = function(ex) {
[10:34:11.568]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:11.568]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:11.568]                 ...future.rng), started = ...future.startTime, 
[10:34:11.568]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:11.568]             version = "1.8"), class = "FutureResult")
[10:34:11.568]     }, finally = {
[10:34:11.568]         if (!identical(...future.workdir, getwd())) 
[10:34:11.568]             setwd(...future.workdir)
[10:34:11.568]         {
[10:34:11.568]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:11.568]                 ...future.oldOptions$nwarnings <- NULL
[10:34:11.568]             }
[10:34:11.568]             base::options(...future.oldOptions)
[10:34:11.568]             if (.Platform$OS.type == "windows") {
[10:34:11.568]                 old_names <- names(...future.oldEnvVars)
[10:34:11.568]                 envs <- base::Sys.getenv()
[10:34:11.568]                 names <- names(envs)
[10:34:11.568]                 common <- intersect(names, old_names)
[10:34:11.568]                 added <- setdiff(names, old_names)
[10:34:11.568]                 removed <- setdiff(old_names, names)
[10:34:11.568]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:11.568]                   envs[common]]
[10:34:11.568]                 NAMES <- toupper(changed)
[10:34:11.568]                 args <- list()
[10:34:11.568]                 for (kk in seq_along(NAMES)) {
[10:34:11.568]                   name <- changed[[kk]]
[10:34:11.568]                   NAME <- NAMES[[kk]]
[10:34:11.568]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:11.568]                     next
[10:34:11.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:11.568]                 }
[10:34:11.568]                 NAMES <- toupper(added)
[10:34:11.568]                 for (kk in seq_along(NAMES)) {
[10:34:11.568]                   name <- added[[kk]]
[10:34:11.568]                   NAME <- NAMES[[kk]]
[10:34:11.568]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:11.568]                     next
[10:34:11.568]                   args[[name]] <- ""
[10:34:11.568]                 }
[10:34:11.568]                 NAMES <- toupper(removed)
[10:34:11.568]                 for (kk in seq_along(NAMES)) {
[10:34:11.568]                   name <- removed[[kk]]
[10:34:11.568]                   NAME <- NAMES[[kk]]
[10:34:11.568]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:11.568]                     next
[10:34:11.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:11.568]                 }
[10:34:11.568]                 if (length(args) > 0) 
[10:34:11.568]                   base::do.call(base::Sys.setenv, args = args)
[10:34:11.568]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:11.568]             }
[10:34:11.568]             else {
[10:34:11.568]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:11.568]             }
[10:34:11.568]             {
[10:34:11.568]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:11.568]                   0L) {
[10:34:11.568]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:11.568]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:11.568]                   base::options(opts)
[10:34:11.568]                 }
[10:34:11.568]                 {
[10:34:11.568]                   {
[10:34:11.568]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:11.568]                     NULL
[10:34:11.568]                   }
[10:34:11.568]                   options(future.plan = NULL)
[10:34:11.568]                   if (is.na(NA_character_)) 
[10:34:11.568]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:11.568]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:11.568]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:11.568]                     .init = FALSE)
[10:34:11.568]                 }
[10:34:11.568]             }
[10:34:11.568]         }
[10:34:11.568]     })
[10:34:11.568]     if (TRUE) {
[10:34:11.568]         base::sink(type = "output", split = FALSE)
[10:34:11.568]         if (TRUE) {
[10:34:11.568]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:11.568]         }
[10:34:11.568]         else {
[10:34:11.568]             ...future.result["stdout"] <- base::list(NULL)
[10:34:11.568]         }
[10:34:11.568]         base::close(...future.stdout)
[10:34:11.568]         ...future.stdout <- NULL
[10:34:11.568]     }
[10:34:11.568]     ...future.result$conditions <- ...future.conditions
[10:34:11.568]     ...future.result$finished <- base::Sys.time()
[10:34:11.568]     ...future.result
[10:34:11.568] }
[10:34:11.571] MultisessionFuture started
[10:34:11.571] - Launch lazy future ... done
[10:34:11.571] run() for ‘MultisessionFuture’ ... done
[10:34:11.572] receiveMessageFromWorker() for ClusterFuture ...
[10:34:11.572] - Validating connection of MultisessionFuture
[10:34:11.573] - received message: FutureResult
[10:34:11.573] - Received FutureResult
[10:34:11.573] - Erased future from FutureRegistry
[10:34:11.573] result() for ClusterFuture ...
[10:34:11.573] - result already collected: FutureResult
[10:34:11.573] result() for ClusterFuture ... done
[10:34:11.573] signalConditions() ...
[10:34:11.573]  - include = ‘immediateCondition’
[10:34:11.574]  - exclude = 
[10:34:11.574]  - resignal = FALSE
[10:34:11.574]  - Number of conditions: 1
[10:34:11.574] signalConditions() ... done
[10:34:11.574] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:11.574] A MultisessionFuture was resolved
- result = TRUE, recursive = TRUE ... DONE
- result = TRUE, recursive = -1 ...
[10:34:11.574] getGlobalsAndPackages() ...
[10:34:11.574] Searching for globals...
[10:34:11.575] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:34:11.575] Searching for globals ... DONE
[10:34:11.576] Resolving globals: FALSE
[10:34:11.576] 
[10:34:11.576] 
[10:34:11.576] getGlobalsAndPackages() ... DONE
[10:34:11.576] run() for ‘Future’ ...
[10:34:11.576] - state: ‘created’
[10:34:11.576] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:11.591] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:11.591] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:11.591]   - Field: ‘node’
[10:34:11.591]   - Field: ‘label’
[10:34:11.591]   - Field: ‘local’
[10:34:11.591]   - Field: ‘owner’
[10:34:11.591]   - Field: ‘envir’
[10:34:11.591]   - Field: ‘workers’
[10:34:11.592]   - Field: ‘packages’
[10:34:11.592]   - Field: ‘gc’
[10:34:11.592]   - Field: ‘conditions’
[10:34:11.592]   - Field: ‘persistent’
[10:34:11.592]   - Field: ‘expr’
[10:34:11.592]   - Field: ‘uuid’
[10:34:11.592]   - Field: ‘seed’
[10:34:11.592]   - Field: ‘version’
[10:34:11.592]   - Field: ‘result’
[10:34:11.592]   - Field: ‘asynchronous’
[10:34:11.593]   - Field: ‘calls’
[10:34:11.593]   - Field: ‘globals’
[10:34:11.593]   - Field: ‘stdout’
[10:34:11.593]   - Field: ‘earlySignal’
[10:34:11.593]   - Field: ‘lazy’
[10:34:11.593]   - Field: ‘state’
[10:34:11.593] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:11.593] - Launch lazy future ...
[10:34:11.593] Packages needed by the future expression (n = 0): <none>
[10:34:11.594] Packages needed by future strategies (n = 0): <none>
[10:34:11.594] {
[10:34:11.594]     {
[10:34:11.594]         {
[10:34:11.594]             ...future.startTime <- base::Sys.time()
[10:34:11.594]             {
[10:34:11.594]                 {
[10:34:11.594]                   {
[10:34:11.594]                     {
[10:34:11.594]                       base::local({
[10:34:11.594]                         has_future <- base::requireNamespace("future", 
[10:34:11.594]                           quietly = TRUE)
[10:34:11.594]                         if (has_future) {
[10:34:11.594]                           ns <- base::getNamespace("future")
[10:34:11.594]                           version <- ns[[".package"]][["version"]]
[10:34:11.594]                           if (is.null(version)) 
[10:34:11.594]                             version <- utils::packageVersion("future")
[10:34:11.594]                         }
[10:34:11.594]                         else {
[10:34:11.594]                           version <- NULL
[10:34:11.594]                         }
[10:34:11.594]                         if (!has_future || version < "1.8.0") {
[10:34:11.594]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:11.594]                             "", base::R.version$version.string), 
[10:34:11.594]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:11.594]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:11.594]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:11.594]                               "release", "version")], collapse = " "), 
[10:34:11.594]                             hostname = base::Sys.info()[["nodename"]])
[10:34:11.594]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:11.594]                             info)
[10:34:11.594]                           info <- base::paste(info, collapse = "; ")
[10:34:11.594]                           if (!has_future) {
[10:34:11.594]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:11.594]                               info)
[10:34:11.594]                           }
[10:34:11.594]                           else {
[10:34:11.594]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:11.594]                               info, version)
[10:34:11.594]                           }
[10:34:11.594]                           base::stop(msg)
[10:34:11.594]                         }
[10:34:11.594]                       })
[10:34:11.594]                     }
[10:34:11.594]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:11.594]                     base::options(mc.cores = 1L)
[10:34:11.594]                   }
[10:34:11.594]                   ...future.strategy.old <- future::plan("list")
[10:34:11.594]                   options(future.plan = NULL)
[10:34:11.594]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:11.594]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:11.594]                 }
[10:34:11.594]                 ...future.workdir <- getwd()
[10:34:11.594]             }
[10:34:11.594]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:11.594]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:11.594]         }
[10:34:11.594]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:11.594]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:11.594]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:11.594]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:11.594]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:11.594]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:11.594]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:11.594]             base::names(...future.oldOptions))
[10:34:11.594]     }
[10:34:11.594]     if (FALSE) {
[10:34:11.594]     }
[10:34:11.594]     else {
[10:34:11.594]         if (TRUE) {
[10:34:11.594]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:11.594]                 open = "w")
[10:34:11.594]         }
[10:34:11.594]         else {
[10:34:11.594]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:11.594]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:11.594]         }
[10:34:11.594]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:11.594]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:11.594]             base::sink(type = "output", split = FALSE)
[10:34:11.594]             base::close(...future.stdout)
[10:34:11.594]         }, add = TRUE)
[10:34:11.594]     }
[10:34:11.594]     ...future.frame <- base::sys.nframe()
[10:34:11.594]     ...future.conditions <- base::list()
[10:34:11.594]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:11.594]     if (FALSE) {
[10:34:11.594]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:11.594]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:11.594]     }
[10:34:11.594]     ...future.result <- base::tryCatch({
[10:34:11.594]         base::withCallingHandlers({
[10:34:11.594]             ...future.value <- base::withVisible(base::local({
[10:34:11.594]                 ...future.makeSendCondition <- base::local({
[10:34:11.594]                   sendCondition <- NULL
[10:34:11.594]                   function(frame = 1L) {
[10:34:11.594]                     if (is.function(sendCondition)) 
[10:34:11.594]                       return(sendCondition)
[10:34:11.594]                     ns <- getNamespace("parallel")
[10:34:11.594]                     if (exists("sendData", mode = "function", 
[10:34:11.594]                       envir = ns)) {
[10:34:11.594]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:11.594]                         envir = ns)
[10:34:11.594]                       envir <- sys.frame(frame)
[10:34:11.594]                       master <- NULL
[10:34:11.594]                       while (!identical(envir, .GlobalEnv) && 
[10:34:11.594]                         !identical(envir, emptyenv())) {
[10:34:11.594]                         if (exists("master", mode = "list", envir = envir, 
[10:34:11.594]                           inherits = FALSE)) {
[10:34:11.594]                           master <- get("master", mode = "list", 
[10:34:11.594]                             envir = envir, inherits = FALSE)
[10:34:11.594]                           if (inherits(master, c("SOCKnode", 
[10:34:11.594]                             "SOCK0node"))) {
[10:34:11.594]                             sendCondition <<- function(cond) {
[10:34:11.594]                               data <- list(type = "VALUE", value = cond, 
[10:34:11.594]                                 success = TRUE)
[10:34:11.594]                               parallel_sendData(master, data)
[10:34:11.594]                             }
[10:34:11.594]                             return(sendCondition)
[10:34:11.594]                           }
[10:34:11.594]                         }
[10:34:11.594]                         frame <- frame + 1L
[10:34:11.594]                         envir <- sys.frame(frame)
[10:34:11.594]                       }
[10:34:11.594]                     }
[10:34:11.594]                     sendCondition <<- function(cond) NULL
[10:34:11.594]                   }
[10:34:11.594]                 })
[10:34:11.594]                 withCallingHandlers({
[10:34:11.594]                   {
[10:34:11.594]                     Sys.sleep(0.5)
[10:34:11.594]                     list(a = 1, b = 42L)
[10:34:11.594]                   }
[10:34:11.594]                 }, immediateCondition = function(cond) {
[10:34:11.594]                   sendCondition <- ...future.makeSendCondition()
[10:34:11.594]                   sendCondition(cond)
[10:34:11.594]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:11.594]                   {
[10:34:11.594]                     inherits <- base::inherits
[10:34:11.594]                     invokeRestart <- base::invokeRestart
[10:34:11.594]                     is.null <- base::is.null
[10:34:11.594]                     muffled <- FALSE
[10:34:11.594]                     if (inherits(cond, "message")) {
[10:34:11.594]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:11.594]                       if (muffled) 
[10:34:11.594]                         invokeRestart("muffleMessage")
[10:34:11.594]                     }
[10:34:11.594]                     else if (inherits(cond, "warning")) {
[10:34:11.594]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:11.594]                       if (muffled) 
[10:34:11.594]                         invokeRestart("muffleWarning")
[10:34:11.594]                     }
[10:34:11.594]                     else if (inherits(cond, "condition")) {
[10:34:11.594]                       if (!is.null(pattern)) {
[10:34:11.594]                         computeRestarts <- base::computeRestarts
[10:34:11.594]                         grepl <- base::grepl
[10:34:11.594]                         restarts <- computeRestarts(cond)
[10:34:11.594]                         for (restart in restarts) {
[10:34:11.594]                           name <- restart$name
[10:34:11.594]                           if (is.null(name)) 
[10:34:11.594]                             next
[10:34:11.594]                           if (!grepl(pattern, name)) 
[10:34:11.594]                             next
[10:34:11.594]                           invokeRestart(restart)
[10:34:11.594]                           muffled <- TRUE
[10:34:11.594]                           break
[10:34:11.594]                         }
[10:34:11.594]                       }
[10:34:11.594]                     }
[10:34:11.594]                     invisible(muffled)
[10:34:11.594]                   }
[10:34:11.594]                   muffleCondition(cond)
[10:34:11.594]                 })
[10:34:11.594]             }))
[10:34:11.594]             future::FutureResult(value = ...future.value$value, 
[10:34:11.594]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:11.594]                   ...future.rng), globalenv = if (FALSE) 
[10:34:11.594]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:11.594]                     ...future.globalenv.names))
[10:34:11.594]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:11.594]         }, condition = base::local({
[10:34:11.594]             c <- base::c
[10:34:11.594]             inherits <- base::inherits
[10:34:11.594]             invokeRestart <- base::invokeRestart
[10:34:11.594]             length <- base::length
[10:34:11.594]             list <- base::list
[10:34:11.594]             seq.int <- base::seq.int
[10:34:11.594]             signalCondition <- base::signalCondition
[10:34:11.594]             sys.calls <- base::sys.calls
[10:34:11.594]             `[[` <- base::`[[`
[10:34:11.594]             `+` <- base::`+`
[10:34:11.594]             `<<-` <- base::`<<-`
[10:34:11.594]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:11.594]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:11.594]                   3L)]
[10:34:11.594]             }
[10:34:11.594]             function(cond) {
[10:34:11.594]                 is_error <- inherits(cond, "error")
[10:34:11.594]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:11.594]                   NULL)
[10:34:11.594]                 if (is_error) {
[10:34:11.594]                   sessionInformation <- function() {
[10:34:11.594]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:11.594]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:11.594]                       search = base::search(), system = base::Sys.info())
[10:34:11.594]                   }
[10:34:11.594]                   ...future.conditions[[length(...future.conditions) + 
[10:34:11.594]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:11.594]                     cond$call), session = sessionInformation(), 
[10:34:11.594]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:11.594]                   signalCondition(cond)
[10:34:11.594]                 }
[10:34:11.594]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:11.594]                 "immediateCondition"))) {
[10:34:11.594]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:11.594]                   ...future.conditions[[length(...future.conditions) + 
[10:34:11.594]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:11.594]                   if (TRUE && !signal) {
[10:34:11.594]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:11.594]                     {
[10:34:11.594]                       inherits <- base::inherits
[10:34:11.594]                       invokeRestart <- base::invokeRestart
[10:34:11.594]                       is.null <- base::is.null
[10:34:11.594]                       muffled <- FALSE
[10:34:11.594]                       if (inherits(cond, "message")) {
[10:34:11.594]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:11.594]                         if (muffled) 
[10:34:11.594]                           invokeRestart("muffleMessage")
[10:34:11.594]                       }
[10:34:11.594]                       else if (inherits(cond, "warning")) {
[10:34:11.594]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:11.594]                         if (muffled) 
[10:34:11.594]                           invokeRestart("muffleWarning")
[10:34:11.594]                       }
[10:34:11.594]                       else if (inherits(cond, "condition")) {
[10:34:11.594]                         if (!is.null(pattern)) {
[10:34:11.594]                           computeRestarts <- base::computeRestarts
[10:34:11.594]                           grepl <- base::grepl
[10:34:11.594]                           restarts <- computeRestarts(cond)
[10:34:11.594]                           for (restart in restarts) {
[10:34:11.594]                             name <- restart$name
[10:34:11.594]                             if (is.null(name)) 
[10:34:11.594]                               next
[10:34:11.594]                             if (!grepl(pattern, name)) 
[10:34:11.594]                               next
[10:34:11.594]                             invokeRestart(restart)
[10:34:11.594]                             muffled <- TRUE
[10:34:11.594]                             break
[10:34:11.594]                           }
[10:34:11.594]                         }
[10:34:11.594]                       }
[10:34:11.594]                       invisible(muffled)
[10:34:11.594]                     }
[10:34:11.594]                     muffleCondition(cond, pattern = "^muffle")
[10:34:11.594]                   }
[10:34:11.594]                 }
[10:34:11.594]                 else {
[10:34:11.594]                   if (TRUE) {
[10:34:11.594]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:11.594]                     {
[10:34:11.594]                       inherits <- base::inherits
[10:34:11.594]                       invokeRestart <- base::invokeRestart
[10:34:11.594]                       is.null <- base::is.null
[10:34:11.594]                       muffled <- FALSE
[10:34:11.594]                       if (inherits(cond, "message")) {
[10:34:11.594]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:11.594]                         if (muffled) 
[10:34:11.594]                           invokeRestart("muffleMessage")
[10:34:11.594]                       }
[10:34:11.594]                       else if (inherits(cond, "warning")) {
[10:34:11.594]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:11.594]                         if (muffled) 
[10:34:11.594]                           invokeRestart("muffleWarning")
[10:34:11.594]                       }
[10:34:11.594]                       else if (inherits(cond, "condition")) {
[10:34:11.594]                         if (!is.null(pattern)) {
[10:34:11.594]                           computeRestarts <- base::computeRestarts
[10:34:11.594]                           grepl <- base::grepl
[10:34:11.594]                           restarts <- computeRestarts(cond)
[10:34:11.594]                           for (restart in restarts) {
[10:34:11.594]                             name <- restart$name
[10:34:11.594]                             if (is.null(name)) 
[10:34:11.594]                               next
[10:34:11.594]                             if (!grepl(pattern, name)) 
[10:34:11.594]                               next
[10:34:11.594]                             invokeRestart(restart)
[10:34:11.594]                             muffled <- TRUE
[10:34:11.594]                             break
[10:34:11.594]                           }
[10:34:11.594]                         }
[10:34:11.594]                       }
[10:34:11.594]                       invisible(muffled)
[10:34:11.594]                     }
[10:34:11.594]                     muffleCondition(cond, pattern = "^muffle")
[10:34:11.594]                   }
[10:34:11.594]                 }
[10:34:11.594]             }
[10:34:11.594]         }))
[10:34:11.594]     }, error = function(ex) {
[10:34:11.594]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:11.594]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:11.594]                 ...future.rng), started = ...future.startTime, 
[10:34:11.594]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:11.594]             version = "1.8"), class = "FutureResult")
[10:34:11.594]     }, finally = {
[10:34:11.594]         if (!identical(...future.workdir, getwd())) 
[10:34:11.594]             setwd(...future.workdir)
[10:34:11.594]         {
[10:34:11.594]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:11.594]                 ...future.oldOptions$nwarnings <- NULL
[10:34:11.594]             }
[10:34:11.594]             base::options(...future.oldOptions)
[10:34:11.594]             if (.Platform$OS.type == "windows") {
[10:34:11.594]                 old_names <- names(...future.oldEnvVars)
[10:34:11.594]                 envs <- base::Sys.getenv()
[10:34:11.594]                 names <- names(envs)
[10:34:11.594]                 common <- intersect(names, old_names)
[10:34:11.594]                 added <- setdiff(names, old_names)
[10:34:11.594]                 removed <- setdiff(old_names, names)
[10:34:11.594]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:11.594]                   envs[common]]
[10:34:11.594]                 NAMES <- toupper(changed)
[10:34:11.594]                 args <- list()
[10:34:11.594]                 for (kk in seq_along(NAMES)) {
[10:34:11.594]                   name <- changed[[kk]]
[10:34:11.594]                   NAME <- NAMES[[kk]]
[10:34:11.594]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:11.594]                     next
[10:34:11.594]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:11.594]                 }
[10:34:11.594]                 NAMES <- toupper(added)
[10:34:11.594]                 for (kk in seq_along(NAMES)) {
[10:34:11.594]                   name <- added[[kk]]
[10:34:11.594]                   NAME <- NAMES[[kk]]
[10:34:11.594]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:11.594]                     next
[10:34:11.594]                   args[[name]] <- ""
[10:34:11.594]                 }
[10:34:11.594]                 NAMES <- toupper(removed)
[10:34:11.594]                 for (kk in seq_along(NAMES)) {
[10:34:11.594]                   name <- removed[[kk]]
[10:34:11.594]                   NAME <- NAMES[[kk]]
[10:34:11.594]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:11.594]                     next
[10:34:11.594]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:11.594]                 }
[10:34:11.594]                 if (length(args) > 0) 
[10:34:11.594]                   base::do.call(base::Sys.setenv, args = args)
[10:34:11.594]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:11.594]             }
[10:34:11.594]             else {
[10:34:11.594]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:11.594]             }
[10:34:11.594]             {
[10:34:11.594]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:11.594]                   0L) {
[10:34:11.594]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:11.594]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:11.594]                   base::options(opts)
[10:34:11.594]                 }
[10:34:11.594]                 {
[10:34:11.594]                   {
[10:34:11.594]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:11.594]                     NULL
[10:34:11.594]                   }
[10:34:11.594]                   options(future.plan = NULL)
[10:34:11.594]                   if (is.na(NA_character_)) 
[10:34:11.594]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:11.594]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:11.594]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:11.594]                     .init = FALSE)
[10:34:11.594]                 }
[10:34:11.594]             }
[10:34:11.594]         }
[10:34:11.594]     })
[10:34:11.594]     if (TRUE) {
[10:34:11.594]         base::sink(type = "output", split = FALSE)
[10:34:11.594]         if (TRUE) {
[10:34:11.594]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:11.594]         }
[10:34:11.594]         else {
[10:34:11.594]             ...future.result["stdout"] <- base::list(NULL)
[10:34:11.594]         }
[10:34:11.594]         base::close(...future.stdout)
[10:34:11.594]         ...future.stdout <- NULL
[10:34:11.594]     }
[10:34:11.594]     ...future.result$conditions <- ...future.conditions
[10:34:11.594]     ...future.result$finished <- base::Sys.time()
[10:34:11.594]     ...future.result
[10:34:11.594] }
[10:34:11.597] MultisessionFuture started
[10:34:11.597] - Launch lazy future ... done
[10:34:11.597] run() for ‘MultisessionFuture’ ... done
[10:34:11.597] getGlobalsAndPackages() ...
[10:34:11.597] Searching for globals...
[10:34:11.598] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:34:11.598] Searching for globals ... DONE
[10:34:11.599] Resolving globals: FALSE
[10:34:11.599] 
[10:34:11.599] 
[10:34:11.599] getGlobalsAndPackages() ... DONE
- w/ exception ...
[10:34:11.599] getGlobalsAndPackages() ...
[10:34:11.599] Searching for globals...
[10:34:11.600] - globals found: [2] ‘list’, ‘stop’
[10:34:11.600] Searching for globals ... DONE
[10:34:11.600] Resolving globals: FALSE
[10:34:11.600] 
[10:34:11.601] 
[10:34:11.601] getGlobalsAndPackages() ... DONE
[10:34:11.601] run() for ‘Future’ ...
[10:34:11.601] - state: ‘created’
[10:34:11.601] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:11.614] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:11.614] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:11.615]   - Field: ‘node’
[10:34:11.615]   - Field: ‘label’
[10:34:11.615]   - Field: ‘local’
[10:34:11.615]   - Field: ‘owner’
[10:34:11.615]   - Field: ‘envir’
[10:34:11.615]   - Field: ‘workers’
[10:34:11.615]   - Field: ‘packages’
[10:34:11.615]   - Field: ‘gc’
[10:34:11.615]   - Field: ‘conditions’
[10:34:11.615]   - Field: ‘persistent’
[10:34:11.615]   - Field: ‘expr’
[10:34:11.616]   - Field: ‘uuid’
[10:34:11.616]   - Field: ‘seed’
[10:34:11.616]   - Field: ‘version’
[10:34:11.616]   - Field: ‘result’
[10:34:11.616]   - Field: ‘asynchronous’
[10:34:11.616]   - Field: ‘calls’
[10:34:11.616]   - Field: ‘globals’
[10:34:11.616]   - Field: ‘stdout’
[10:34:11.616]   - Field: ‘earlySignal’
[10:34:11.616]   - Field: ‘lazy’
[10:34:11.616]   - Field: ‘state’
[10:34:11.617] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:11.617] - Launch lazy future ...
[10:34:11.617] Packages needed by the future expression (n = 0): <none>
[10:34:11.617] Packages needed by future strategies (n = 0): <none>
[10:34:11.617] {
[10:34:11.617]     {
[10:34:11.617]         {
[10:34:11.617]             ...future.startTime <- base::Sys.time()
[10:34:11.617]             {
[10:34:11.617]                 {
[10:34:11.617]                   {
[10:34:11.617]                     {
[10:34:11.617]                       base::local({
[10:34:11.617]                         has_future <- base::requireNamespace("future", 
[10:34:11.617]                           quietly = TRUE)
[10:34:11.617]                         if (has_future) {
[10:34:11.617]                           ns <- base::getNamespace("future")
[10:34:11.617]                           version <- ns[[".package"]][["version"]]
[10:34:11.617]                           if (is.null(version)) 
[10:34:11.617]                             version <- utils::packageVersion("future")
[10:34:11.617]                         }
[10:34:11.617]                         else {
[10:34:11.617]                           version <- NULL
[10:34:11.617]                         }
[10:34:11.617]                         if (!has_future || version < "1.8.0") {
[10:34:11.617]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:11.617]                             "", base::R.version$version.string), 
[10:34:11.617]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:11.617]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:11.617]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:11.617]                               "release", "version")], collapse = " "), 
[10:34:11.617]                             hostname = base::Sys.info()[["nodename"]])
[10:34:11.617]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:11.617]                             info)
[10:34:11.617]                           info <- base::paste(info, collapse = "; ")
[10:34:11.617]                           if (!has_future) {
[10:34:11.617]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:11.617]                               info)
[10:34:11.617]                           }
[10:34:11.617]                           else {
[10:34:11.617]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:11.617]                               info, version)
[10:34:11.617]                           }
[10:34:11.617]                           base::stop(msg)
[10:34:11.617]                         }
[10:34:11.617]                       })
[10:34:11.617]                     }
[10:34:11.617]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:11.617]                     base::options(mc.cores = 1L)
[10:34:11.617]                   }
[10:34:11.617]                   ...future.strategy.old <- future::plan("list")
[10:34:11.617]                   options(future.plan = NULL)
[10:34:11.617]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:11.617]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:11.617]                 }
[10:34:11.617]                 ...future.workdir <- getwd()
[10:34:11.617]             }
[10:34:11.617]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:11.617]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:11.617]         }
[10:34:11.617]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:11.617]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:11.617]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:11.617]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:11.617]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:11.617]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:11.617]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:11.617]             base::names(...future.oldOptions))
[10:34:11.617]     }
[10:34:11.617]     if (FALSE) {
[10:34:11.617]     }
[10:34:11.617]     else {
[10:34:11.617]         if (TRUE) {
[10:34:11.617]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:11.617]                 open = "w")
[10:34:11.617]         }
[10:34:11.617]         else {
[10:34:11.617]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:11.617]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:11.617]         }
[10:34:11.617]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:11.617]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:11.617]             base::sink(type = "output", split = FALSE)
[10:34:11.617]             base::close(...future.stdout)
[10:34:11.617]         }, add = TRUE)
[10:34:11.617]     }
[10:34:11.617]     ...future.frame <- base::sys.nframe()
[10:34:11.617]     ...future.conditions <- base::list()
[10:34:11.617]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:11.617]     if (FALSE) {
[10:34:11.617]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:11.617]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:11.617]     }
[10:34:11.617]     ...future.result <- base::tryCatch({
[10:34:11.617]         base::withCallingHandlers({
[10:34:11.617]             ...future.value <- base::withVisible(base::local({
[10:34:11.617]                 ...future.makeSendCondition <- base::local({
[10:34:11.617]                   sendCondition <- NULL
[10:34:11.617]                   function(frame = 1L) {
[10:34:11.617]                     if (is.function(sendCondition)) 
[10:34:11.617]                       return(sendCondition)
[10:34:11.617]                     ns <- getNamespace("parallel")
[10:34:11.617]                     if (exists("sendData", mode = "function", 
[10:34:11.617]                       envir = ns)) {
[10:34:11.617]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:11.617]                         envir = ns)
[10:34:11.617]                       envir <- sys.frame(frame)
[10:34:11.617]                       master <- NULL
[10:34:11.617]                       while (!identical(envir, .GlobalEnv) && 
[10:34:11.617]                         !identical(envir, emptyenv())) {
[10:34:11.617]                         if (exists("master", mode = "list", envir = envir, 
[10:34:11.617]                           inherits = FALSE)) {
[10:34:11.617]                           master <- get("master", mode = "list", 
[10:34:11.617]                             envir = envir, inherits = FALSE)
[10:34:11.617]                           if (inherits(master, c("SOCKnode", 
[10:34:11.617]                             "SOCK0node"))) {
[10:34:11.617]                             sendCondition <<- function(cond) {
[10:34:11.617]                               data <- list(type = "VALUE", value = cond, 
[10:34:11.617]                                 success = TRUE)
[10:34:11.617]                               parallel_sendData(master, data)
[10:34:11.617]                             }
[10:34:11.617]                             return(sendCondition)
[10:34:11.617]                           }
[10:34:11.617]                         }
[10:34:11.617]                         frame <- frame + 1L
[10:34:11.617]                         envir <- sys.frame(frame)
[10:34:11.617]                       }
[10:34:11.617]                     }
[10:34:11.617]                     sendCondition <<- function(cond) NULL
[10:34:11.617]                   }
[10:34:11.617]                 })
[10:34:11.617]                 withCallingHandlers({
[10:34:11.617]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:34:11.617]                 }, immediateCondition = function(cond) {
[10:34:11.617]                   sendCondition <- ...future.makeSendCondition()
[10:34:11.617]                   sendCondition(cond)
[10:34:11.617]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:11.617]                   {
[10:34:11.617]                     inherits <- base::inherits
[10:34:11.617]                     invokeRestart <- base::invokeRestart
[10:34:11.617]                     is.null <- base::is.null
[10:34:11.617]                     muffled <- FALSE
[10:34:11.617]                     if (inherits(cond, "message")) {
[10:34:11.617]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:11.617]                       if (muffled) 
[10:34:11.617]                         invokeRestart("muffleMessage")
[10:34:11.617]                     }
[10:34:11.617]                     else if (inherits(cond, "warning")) {
[10:34:11.617]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:11.617]                       if (muffled) 
[10:34:11.617]                         invokeRestart("muffleWarning")
[10:34:11.617]                     }
[10:34:11.617]                     else if (inherits(cond, "condition")) {
[10:34:11.617]                       if (!is.null(pattern)) {
[10:34:11.617]                         computeRestarts <- base::computeRestarts
[10:34:11.617]                         grepl <- base::grepl
[10:34:11.617]                         restarts <- computeRestarts(cond)
[10:34:11.617]                         for (restart in restarts) {
[10:34:11.617]                           name <- restart$name
[10:34:11.617]                           if (is.null(name)) 
[10:34:11.617]                             next
[10:34:11.617]                           if (!grepl(pattern, name)) 
[10:34:11.617]                             next
[10:34:11.617]                           invokeRestart(restart)
[10:34:11.617]                           muffled <- TRUE
[10:34:11.617]                           break
[10:34:11.617]                         }
[10:34:11.617]                       }
[10:34:11.617]                     }
[10:34:11.617]                     invisible(muffled)
[10:34:11.617]                   }
[10:34:11.617]                   muffleCondition(cond)
[10:34:11.617]                 })
[10:34:11.617]             }))
[10:34:11.617]             future::FutureResult(value = ...future.value$value, 
[10:34:11.617]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:11.617]                   ...future.rng), globalenv = if (FALSE) 
[10:34:11.617]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:11.617]                     ...future.globalenv.names))
[10:34:11.617]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:11.617]         }, condition = base::local({
[10:34:11.617]             c <- base::c
[10:34:11.617]             inherits <- base::inherits
[10:34:11.617]             invokeRestart <- base::invokeRestart
[10:34:11.617]             length <- base::length
[10:34:11.617]             list <- base::list
[10:34:11.617]             seq.int <- base::seq.int
[10:34:11.617]             signalCondition <- base::signalCondition
[10:34:11.617]             sys.calls <- base::sys.calls
[10:34:11.617]             `[[` <- base::`[[`
[10:34:11.617]             `+` <- base::`+`
[10:34:11.617]             `<<-` <- base::`<<-`
[10:34:11.617]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:11.617]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:11.617]                   3L)]
[10:34:11.617]             }
[10:34:11.617]             function(cond) {
[10:34:11.617]                 is_error <- inherits(cond, "error")
[10:34:11.617]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:11.617]                   NULL)
[10:34:11.617]                 if (is_error) {
[10:34:11.617]                   sessionInformation <- function() {
[10:34:11.617]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:11.617]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:11.617]                       search = base::search(), system = base::Sys.info())
[10:34:11.617]                   }
[10:34:11.617]                   ...future.conditions[[length(...future.conditions) + 
[10:34:11.617]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:11.617]                     cond$call), session = sessionInformation(), 
[10:34:11.617]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:11.617]                   signalCondition(cond)
[10:34:11.617]                 }
[10:34:11.617]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:11.617]                 "immediateCondition"))) {
[10:34:11.617]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:11.617]                   ...future.conditions[[length(...future.conditions) + 
[10:34:11.617]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:11.617]                   if (TRUE && !signal) {
[10:34:11.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:11.617]                     {
[10:34:11.617]                       inherits <- base::inherits
[10:34:11.617]                       invokeRestart <- base::invokeRestart
[10:34:11.617]                       is.null <- base::is.null
[10:34:11.617]                       muffled <- FALSE
[10:34:11.617]                       if (inherits(cond, "message")) {
[10:34:11.617]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:11.617]                         if (muffled) 
[10:34:11.617]                           invokeRestart("muffleMessage")
[10:34:11.617]                       }
[10:34:11.617]                       else if (inherits(cond, "warning")) {
[10:34:11.617]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:11.617]                         if (muffled) 
[10:34:11.617]                           invokeRestart("muffleWarning")
[10:34:11.617]                       }
[10:34:11.617]                       else if (inherits(cond, "condition")) {
[10:34:11.617]                         if (!is.null(pattern)) {
[10:34:11.617]                           computeRestarts <- base::computeRestarts
[10:34:11.617]                           grepl <- base::grepl
[10:34:11.617]                           restarts <- computeRestarts(cond)
[10:34:11.617]                           for (restart in restarts) {
[10:34:11.617]                             name <- restart$name
[10:34:11.617]                             if (is.null(name)) 
[10:34:11.617]                               next
[10:34:11.617]                             if (!grepl(pattern, name)) 
[10:34:11.617]                               next
[10:34:11.617]                             invokeRestart(restart)
[10:34:11.617]                             muffled <- TRUE
[10:34:11.617]                             break
[10:34:11.617]                           }
[10:34:11.617]                         }
[10:34:11.617]                       }
[10:34:11.617]                       invisible(muffled)
[10:34:11.617]                     }
[10:34:11.617]                     muffleCondition(cond, pattern = "^muffle")
[10:34:11.617]                   }
[10:34:11.617]                 }
[10:34:11.617]                 else {
[10:34:11.617]                   if (TRUE) {
[10:34:11.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:11.617]                     {
[10:34:11.617]                       inherits <- base::inherits
[10:34:11.617]                       invokeRestart <- base::invokeRestart
[10:34:11.617]                       is.null <- base::is.null
[10:34:11.617]                       muffled <- FALSE
[10:34:11.617]                       if (inherits(cond, "message")) {
[10:34:11.617]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:11.617]                         if (muffled) 
[10:34:11.617]                           invokeRestart("muffleMessage")
[10:34:11.617]                       }
[10:34:11.617]                       else if (inherits(cond, "warning")) {
[10:34:11.617]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:11.617]                         if (muffled) 
[10:34:11.617]                           invokeRestart("muffleWarning")
[10:34:11.617]                       }
[10:34:11.617]                       else if (inherits(cond, "condition")) {
[10:34:11.617]                         if (!is.null(pattern)) {
[10:34:11.617]                           computeRestarts <- base::computeRestarts
[10:34:11.617]                           grepl <- base::grepl
[10:34:11.617]                           restarts <- computeRestarts(cond)
[10:34:11.617]                           for (restart in restarts) {
[10:34:11.617]                             name <- restart$name
[10:34:11.617]                             if (is.null(name)) 
[10:34:11.617]                               next
[10:34:11.617]                             if (!grepl(pattern, name)) 
[10:34:11.617]                               next
[10:34:11.617]                             invokeRestart(restart)
[10:34:11.617]                             muffled <- TRUE
[10:34:11.617]                             break
[10:34:11.617]                           }
[10:34:11.617]                         }
[10:34:11.617]                       }
[10:34:11.617]                       invisible(muffled)
[10:34:11.617]                     }
[10:34:11.617]                     muffleCondition(cond, pattern = "^muffle")
[10:34:11.617]                   }
[10:34:11.617]                 }
[10:34:11.617]             }
[10:34:11.617]         }))
[10:34:11.617]     }, error = function(ex) {
[10:34:11.617]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:11.617]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:11.617]                 ...future.rng), started = ...future.startTime, 
[10:34:11.617]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:11.617]             version = "1.8"), class = "FutureResult")
[10:34:11.617]     }, finally = {
[10:34:11.617]         if (!identical(...future.workdir, getwd())) 
[10:34:11.617]             setwd(...future.workdir)
[10:34:11.617]         {
[10:34:11.617]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:11.617]                 ...future.oldOptions$nwarnings <- NULL
[10:34:11.617]             }
[10:34:11.617]             base::options(...future.oldOptions)
[10:34:11.617]             if (.Platform$OS.type == "windows") {
[10:34:11.617]                 old_names <- names(...future.oldEnvVars)
[10:34:11.617]                 envs <- base::Sys.getenv()
[10:34:11.617]                 names <- names(envs)
[10:34:11.617]                 common <- intersect(names, old_names)
[10:34:11.617]                 added <- setdiff(names, old_names)
[10:34:11.617]                 removed <- setdiff(old_names, names)
[10:34:11.617]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:11.617]                   envs[common]]
[10:34:11.617]                 NAMES <- toupper(changed)
[10:34:11.617]                 args <- list()
[10:34:11.617]                 for (kk in seq_along(NAMES)) {
[10:34:11.617]                   name <- changed[[kk]]
[10:34:11.617]                   NAME <- NAMES[[kk]]
[10:34:11.617]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:11.617]                     next
[10:34:11.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:11.617]                 }
[10:34:11.617]                 NAMES <- toupper(added)
[10:34:11.617]                 for (kk in seq_along(NAMES)) {
[10:34:11.617]                   name <- added[[kk]]
[10:34:11.617]                   NAME <- NAMES[[kk]]
[10:34:11.617]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:11.617]                     next
[10:34:11.617]                   args[[name]] <- ""
[10:34:11.617]                 }
[10:34:11.617]                 NAMES <- toupper(removed)
[10:34:11.617]                 for (kk in seq_along(NAMES)) {
[10:34:11.617]                   name <- removed[[kk]]
[10:34:11.617]                   NAME <- NAMES[[kk]]
[10:34:11.617]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:11.617]                     next
[10:34:11.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:11.617]                 }
[10:34:11.617]                 if (length(args) > 0) 
[10:34:11.617]                   base::do.call(base::Sys.setenv, args = args)
[10:34:11.617]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:11.617]             }
[10:34:11.617]             else {
[10:34:11.617]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:11.617]             }
[10:34:11.617]             {
[10:34:11.617]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:11.617]                   0L) {
[10:34:11.617]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:11.617]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:11.617]                   base::options(opts)
[10:34:11.617]                 }
[10:34:11.617]                 {
[10:34:11.617]                   {
[10:34:11.617]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:11.617]                     NULL
[10:34:11.617]                   }
[10:34:11.617]                   options(future.plan = NULL)
[10:34:11.617]                   if (is.na(NA_character_)) 
[10:34:11.617]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:11.617]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:11.617]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:11.617]                     .init = FALSE)
[10:34:11.617]                 }
[10:34:11.617]             }
[10:34:11.617]         }
[10:34:11.617]     })
[10:34:11.617]     if (TRUE) {
[10:34:11.617]         base::sink(type = "output", split = FALSE)
[10:34:11.617]         if (TRUE) {
[10:34:11.617]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:11.617]         }
[10:34:11.617]         else {
[10:34:11.617]             ...future.result["stdout"] <- base::list(NULL)
[10:34:11.617]         }
[10:34:11.617]         base::close(...future.stdout)
[10:34:11.617]         ...future.stdout <- NULL
[10:34:11.617]     }
[10:34:11.617]     ...future.result$conditions <- ...future.conditions
[10:34:11.617]     ...future.result$finished <- base::Sys.time()
[10:34:11.617]     ...future.result
[10:34:11.617] }
[10:34:11.619] Poll #1 (0): usedNodes() = 2, workers = 2
[10:34:11.630] receiveMessageFromWorker() for ClusterFuture ...
[10:34:11.630] - Validating connection of MultisessionFuture
[10:34:11.630] - received message: FutureResult
[10:34:11.631] - Received FutureResult
[10:34:11.631] - Erased future from FutureRegistry
[10:34:11.631] result() for ClusterFuture ...
[10:34:11.631] - result already collected: FutureResult
[10:34:11.631] result() for ClusterFuture ... done
[10:34:11.631] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:11.631] result() for ClusterFuture ...
[10:34:11.631] - result already collected: FutureResult
[10:34:11.631] result() for ClusterFuture ... done
[10:34:11.631] result() for ClusterFuture ...
[10:34:11.631] - result already collected: FutureResult
[10:34:11.632] result() for ClusterFuture ... done
[10:34:11.633] MultisessionFuture started
[10:34:11.633] - Launch lazy future ... done
[10:34:11.633] run() for ‘MultisessionFuture’ ... done
[10:34:11.633] getGlobalsAndPackages() ...
[10:34:11.633] Searching for globals...
[10:34:11.634] - globals found: [2] ‘list’, ‘stop’
[10:34:11.634] Searching for globals ... DONE
[10:34:11.634] Resolving globals: FALSE
[10:34:11.634] 
[10:34:11.634] 
[10:34:11.634] getGlobalsAndPackages() ... DONE
- result = TRUE, recursive = -1 ... DONE
- result = TRUE, recursive = 0 ...
[10:34:11.635] getGlobalsAndPackages() ...
[10:34:11.635] Searching for globals...
[10:34:11.636] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:34:11.636] Searching for globals ... DONE
[10:34:11.636] Resolving globals: FALSE
[10:34:11.636] 
[10:34:11.636] 
[10:34:11.636] getGlobalsAndPackages() ... DONE
[10:34:11.637] run() for ‘Future’ ...
[10:34:11.637] - state: ‘created’
[10:34:11.637] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:11.650] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:11.650] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:11.650]   - Field: ‘node’
[10:34:11.650]   - Field: ‘label’
[10:34:11.651]   - Field: ‘local’
[10:34:11.651]   - Field: ‘owner’
[10:34:11.651]   - Field: ‘envir’
[10:34:11.651]   - Field: ‘workers’
[10:34:11.651]   - Field: ‘packages’
[10:34:11.651]   - Field: ‘gc’
[10:34:11.651]   - Field: ‘conditions’
[10:34:11.651]   - Field: ‘persistent’
[10:34:11.651]   - Field: ‘expr’
[10:34:11.651]   - Field: ‘uuid’
[10:34:11.651]   - Field: ‘seed’
[10:34:11.651]   - Field: ‘version’
[10:34:11.652]   - Field: ‘result’
[10:34:11.652]   - Field: ‘asynchronous’
[10:34:11.652]   - Field: ‘calls’
[10:34:11.652]   - Field: ‘globals’
[10:34:11.652]   - Field: ‘stdout’
[10:34:11.652]   - Field: ‘earlySignal’
[10:34:11.652]   - Field: ‘lazy’
[10:34:11.652]   - Field: ‘state’
[10:34:11.652] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:11.652] - Launch lazy future ...
[10:34:11.653] Packages needed by the future expression (n = 0): <none>
[10:34:11.653] Packages needed by future strategies (n = 0): <none>
[10:34:11.653] {
[10:34:11.653]     {
[10:34:11.653]         {
[10:34:11.653]             ...future.startTime <- base::Sys.time()
[10:34:11.653]             {
[10:34:11.653]                 {
[10:34:11.653]                   {
[10:34:11.653]                     {
[10:34:11.653]                       base::local({
[10:34:11.653]                         has_future <- base::requireNamespace("future", 
[10:34:11.653]                           quietly = TRUE)
[10:34:11.653]                         if (has_future) {
[10:34:11.653]                           ns <- base::getNamespace("future")
[10:34:11.653]                           version <- ns[[".package"]][["version"]]
[10:34:11.653]                           if (is.null(version)) 
[10:34:11.653]                             version <- utils::packageVersion("future")
[10:34:11.653]                         }
[10:34:11.653]                         else {
[10:34:11.653]                           version <- NULL
[10:34:11.653]                         }
[10:34:11.653]                         if (!has_future || version < "1.8.0") {
[10:34:11.653]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:11.653]                             "", base::R.version$version.string), 
[10:34:11.653]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:11.653]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:11.653]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:11.653]                               "release", "version")], collapse = " "), 
[10:34:11.653]                             hostname = base::Sys.info()[["nodename"]])
[10:34:11.653]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:11.653]                             info)
[10:34:11.653]                           info <- base::paste(info, collapse = "; ")
[10:34:11.653]                           if (!has_future) {
[10:34:11.653]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:11.653]                               info)
[10:34:11.653]                           }
[10:34:11.653]                           else {
[10:34:11.653]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:11.653]                               info, version)
[10:34:11.653]                           }
[10:34:11.653]                           base::stop(msg)
[10:34:11.653]                         }
[10:34:11.653]                       })
[10:34:11.653]                     }
[10:34:11.653]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:11.653]                     base::options(mc.cores = 1L)
[10:34:11.653]                   }
[10:34:11.653]                   ...future.strategy.old <- future::plan("list")
[10:34:11.653]                   options(future.plan = NULL)
[10:34:11.653]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:11.653]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:11.653]                 }
[10:34:11.653]                 ...future.workdir <- getwd()
[10:34:11.653]             }
[10:34:11.653]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:11.653]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:11.653]         }
[10:34:11.653]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:11.653]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:11.653]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:11.653]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:11.653]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:11.653]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:11.653]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:11.653]             base::names(...future.oldOptions))
[10:34:11.653]     }
[10:34:11.653]     if (FALSE) {
[10:34:11.653]     }
[10:34:11.653]     else {
[10:34:11.653]         if (TRUE) {
[10:34:11.653]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:11.653]                 open = "w")
[10:34:11.653]         }
[10:34:11.653]         else {
[10:34:11.653]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:11.653]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:11.653]         }
[10:34:11.653]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:11.653]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:11.653]             base::sink(type = "output", split = FALSE)
[10:34:11.653]             base::close(...future.stdout)
[10:34:11.653]         }, add = TRUE)
[10:34:11.653]     }
[10:34:11.653]     ...future.frame <- base::sys.nframe()
[10:34:11.653]     ...future.conditions <- base::list()
[10:34:11.653]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:11.653]     if (FALSE) {
[10:34:11.653]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:11.653]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:11.653]     }
[10:34:11.653]     ...future.result <- base::tryCatch({
[10:34:11.653]         base::withCallingHandlers({
[10:34:11.653]             ...future.value <- base::withVisible(base::local({
[10:34:11.653]                 ...future.makeSendCondition <- base::local({
[10:34:11.653]                   sendCondition <- NULL
[10:34:11.653]                   function(frame = 1L) {
[10:34:11.653]                     if (is.function(sendCondition)) 
[10:34:11.653]                       return(sendCondition)
[10:34:11.653]                     ns <- getNamespace("parallel")
[10:34:11.653]                     if (exists("sendData", mode = "function", 
[10:34:11.653]                       envir = ns)) {
[10:34:11.653]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:11.653]                         envir = ns)
[10:34:11.653]                       envir <- sys.frame(frame)
[10:34:11.653]                       master <- NULL
[10:34:11.653]                       while (!identical(envir, .GlobalEnv) && 
[10:34:11.653]                         !identical(envir, emptyenv())) {
[10:34:11.653]                         if (exists("master", mode = "list", envir = envir, 
[10:34:11.653]                           inherits = FALSE)) {
[10:34:11.653]                           master <- get("master", mode = "list", 
[10:34:11.653]                             envir = envir, inherits = FALSE)
[10:34:11.653]                           if (inherits(master, c("SOCKnode", 
[10:34:11.653]                             "SOCK0node"))) {
[10:34:11.653]                             sendCondition <<- function(cond) {
[10:34:11.653]                               data <- list(type = "VALUE", value = cond, 
[10:34:11.653]                                 success = TRUE)
[10:34:11.653]                               parallel_sendData(master, data)
[10:34:11.653]                             }
[10:34:11.653]                             return(sendCondition)
[10:34:11.653]                           }
[10:34:11.653]                         }
[10:34:11.653]                         frame <- frame + 1L
[10:34:11.653]                         envir <- sys.frame(frame)
[10:34:11.653]                       }
[10:34:11.653]                     }
[10:34:11.653]                     sendCondition <<- function(cond) NULL
[10:34:11.653]                   }
[10:34:11.653]                 })
[10:34:11.653]                 withCallingHandlers({
[10:34:11.653]                   {
[10:34:11.653]                     Sys.sleep(0.5)
[10:34:11.653]                     list(a = 1, b = 42L)
[10:34:11.653]                   }
[10:34:11.653]                 }, immediateCondition = function(cond) {
[10:34:11.653]                   sendCondition <- ...future.makeSendCondition()
[10:34:11.653]                   sendCondition(cond)
[10:34:11.653]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:11.653]                   {
[10:34:11.653]                     inherits <- base::inherits
[10:34:11.653]                     invokeRestart <- base::invokeRestart
[10:34:11.653]                     is.null <- base::is.null
[10:34:11.653]                     muffled <- FALSE
[10:34:11.653]                     if (inherits(cond, "message")) {
[10:34:11.653]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:11.653]                       if (muffled) 
[10:34:11.653]                         invokeRestart("muffleMessage")
[10:34:11.653]                     }
[10:34:11.653]                     else if (inherits(cond, "warning")) {
[10:34:11.653]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:11.653]                       if (muffled) 
[10:34:11.653]                         invokeRestart("muffleWarning")
[10:34:11.653]                     }
[10:34:11.653]                     else if (inherits(cond, "condition")) {
[10:34:11.653]                       if (!is.null(pattern)) {
[10:34:11.653]                         computeRestarts <- base::computeRestarts
[10:34:11.653]                         grepl <- base::grepl
[10:34:11.653]                         restarts <- computeRestarts(cond)
[10:34:11.653]                         for (restart in restarts) {
[10:34:11.653]                           name <- restart$name
[10:34:11.653]                           if (is.null(name)) 
[10:34:11.653]                             next
[10:34:11.653]                           if (!grepl(pattern, name)) 
[10:34:11.653]                             next
[10:34:11.653]                           invokeRestart(restart)
[10:34:11.653]                           muffled <- TRUE
[10:34:11.653]                           break
[10:34:11.653]                         }
[10:34:11.653]                       }
[10:34:11.653]                     }
[10:34:11.653]                     invisible(muffled)
[10:34:11.653]                   }
[10:34:11.653]                   muffleCondition(cond)
[10:34:11.653]                 })
[10:34:11.653]             }))
[10:34:11.653]             future::FutureResult(value = ...future.value$value, 
[10:34:11.653]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:11.653]                   ...future.rng), globalenv = if (FALSE) 
[10:34:11.653]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:11.653]                     ...future.globalenv.names))
[10:34:11.653]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:11.653]         }, condition = base::local({
[10:34:11.653]             c <- base::c
[10:34:11.653]             inherits <- base::inherits
[10:34:11.653]             invokeRestart <- base::invokeRestart
[10:34:11.653]             length <- base::length
[10:34:11.653]             list <- base::list
[10:34:11.653]             seq.int <- base::seq.int
[10:34:11.653]             signalCondition <- base::signalCondition
[10:34:11.653]             sys.calls <- base::sys.calls
[10:34:11.653]             `[[` <- base::`[[`
[10:34:11.653]             `+` <- base::`+`
[10:34:11.653]             `<<-` <- base::`<<-`
[10:34:11.653]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:11.653]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:11.653]                   3L)]
[10:34:11.653]             }
[10:34:11.653]             function(cond) {
[10:34:11.653]                 is_error <- inherits(cond, "error")
[10:34:11.653]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:11.653]                   NULL)
[10:34:11.653]                 if (is_error) {
[10:34:11.653]                   sessionInformation <- function() {
[10:34:11.653]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:11.653]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:11.653]                       search = base::search(), system = base::Sys.info())
[10:34:11.653]                   }
[10:34:11.653]                   ...future.conditions[[length(...future.conditions) + 
[10:34:11.653]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:11.653]                     cond$call), session = sessionInformation(), 
[10:34:11.653]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:11.653]                   signalCondition(cond)
[10:34:11.653]                 }
[10:34:11.653]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:11.653]                 "immediateCondition"))) {
[10:34:11.653]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:11.653]                   ...future.conditions[[length(...future.conditions) + 
[10:34:11.653]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:11.653]                   if (TRUE && !signal) {
[10:34:11.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:11.653]                     {
[10:34:11.653]                       inherits <- base::inherits
[10:34:11.653]                       invokeRestart <- base::invokeRestart
[10:34:11.653]                       is.null <- base::is.null
[10:34:11.653]                       muffled <- FALSE
[10:34:11.653]                       if (inherits(cond, "message")) {
[10:34:11.653]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:11.653]                         if (muffled) 
[10:34:11.653]                           invokeRestart("muffleMessage")
[10:34:11.653]                       }
[10:34:11.653]                       else if (inherits(cond, "warning")) {
[10:34:11.653]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:11.653]                         if (muffled) 
[10:34:11.653]                           invokeRestart("muffleWarning")
[10:34:11.653]                       }
[10:34:11.653]                       else if (inherits(cond, "condition")) {
[10:34:11.653]                         if (!is.null(pattern)) {
[10:34:11.653]                           computeRestarts <- base::computeRestarts
[10:34:11.653]                           grepl <- base::grepl
[10:34:11.653]                           restarts <- computeRestarts(cond)
[10:34:11.653]                           for (restart in restarts) {
[10:34:11.653]                             name <- restart$name
[10:34:11.653]                             if (is.null(name)) 
[10:34:11.653]                               next
[10:34:11.653]                             if (!grepl(pattern, name)) 
[10:34:11.653]                               next
[10:34:11.653]                             invokeRestart(restart)
[10:34:11.653]                             muffled <- TRUE
[10:34:11.653]                             break
[10:34:11.653]                           }
[10:34:11.653]                         }
[10:34:11.653]                       }
[10:34:11.653]                       invisible(muffled)
[10:34:11.653]                     }
[10:34:11.653]                     muffleCondition(cond, pattern = "^muffle")
[10:34:11.653]                   }
[10:34:11.653]                 }
[10:34:11.653]                 else {
[10:34:11.653]                   if (TRUE) {
[10:34:11.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:11.653]                     {
[10:34:11.653]                       inherits <- base::inherits
[10:34:11.653]                       invokeRestart <- base::invokeRestart
[10:34:11.653]                       is.null <- base::is.null
[10:34:11.653]                       muffled <- FALSE
[10:34:11.653]                       if (inherits(cond, "message")) {
[10:34:11.653]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:11.653]                         if (muffled) 
[10:34:11.653]                           invokeRestart("muffleMessage")
[10:34:11.653]                       }
[10:34:11.653]                       else if (inherits(cond, "warning")) {
[10:34:11.653]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:11.653]                         if (muffled) 
[10:34:11.653]                           invokeRestart("muffleWarning")
[10:34:11.653]                       }
[10:34:11.653]                       else if (inherits(cond, "condition")) {
[10:34:11.653]                         if (!is.null(pattern)) {
[10:34:11.653]                           computeRestarts <- base::computeRestarts
[10:34:11.653]                           grepl <- base::grepl
[10:34:11.653]                           restarts <- computeRestarts(cond)
[10:34:11.653]                           for (restart in restarts) {
[10:34:11.653]                             name <- restart$name
[10:34:11.653]                             if (is.null(name)) 
[10:34:11.653]                               next
[10:34:11.653]                             if (!grepl(pattern, name)) 
[10:34:11.653]                               next
[10:34:11.653]                             invokeRestart(restart)
[10:34:11.653]                             muffled <- TRUE
[10:34:11.653]                             break
[10:34:11.653]                           }
[10:34:11.653]                         }
[10:34:11.653]                       }
[10:34:11.653]                       invisible(muffled)
[10:34:11.653]                     }
[10:34:11.653]                     muffleCondition(cond, pattern = "^muffle")
[10:34:11.653]                   }
[10:34:11.653]                 }
[10:34:11.653]             }
[10:34:11.653]         }))
[10:34:11.653]     }, error = function(ex) {
[10:34:11.653]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:11.653]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:11.653]                 ...future.rng), started = ...future.startTime, 
[10:34:11.653]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:11.653]             version = "1.8"), class = "FutureResult")
[10:34:11.653]     }, finally = {
[10:34:11.653]         if (!identical(...future.workdir, getwd())) 
[10:34:11.653]             setwd(...future.workdir)
[10:34:11.653]         {
[10:34:11.653]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:11.653]                 ...future.oldOptions$nwarnings <- NULL
[10:34:11.653]             }
[10:34:11.653]             base::options(...future.oldOptions)
[10:34:11.653]             if (.Platform$OS.type == "windows") {
[10:34:11.653]                 old_names <- names(...future.oldEnvVars)
[10:34:11.653]                 envs <- base::Sys.getenv()
[10:34:11.653]                 names <- names(envs)
[10:34:11.653]                 common <- intersect(names, old_names)
[10:34:11.653]                 added <- setdiff(names, old_names)
[10:34:11.653]                 removed <- setdiff(old_names, names)
[10:34:11.653]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:11.653]                   envs[common]]
[10:34:11.653]                 NAMES <- toupper(changed)
[10:34:11.653]                 args <- list()
[10:34:11.653]                 for (kk in seq_along(NAMES)) {
[10:34:11.653]                   name <- changed[[kk]]
[10:34:11.653]                   NAME <- NAMES[[kk]]
[10:34:11.653]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:11.653]                     next
[10:34:11.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:11.653]                 }
[10:34:11.653]                 NAMES <- toupper(added)
[10:34:11.653]                 for (kk in seq_along(NAMES)) {
[10:34:11.653]                   name <- added[[kk]]
[10:34:11.653]                   NAME <- NAMES[[kk]]
[10:34:11.653]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:11.653]                     next
[10:34:11.653]                   args[[name]] <- ""
[10:34:11.653]                 }
[10:34:11.653]                 NAMES <- toupper(removed)
[10:34:11.653]                 for (kk in seq_along(NAMES)) {
[10:34:11.653]                   name <- removed[[kk]]
[10:34:11.653]                   NAME <- NAMES[[kk]]
[10:34:11.653]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:11.653]                     next
[10:34:11.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:11.653]                 }
[10:34:11.653]                 if (length(args) > 0) 
[10:34:11.653]                   base::do.call(base::Sys.setenv, args = args)
[10:34:11.653]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:11.653]             }
[10:34:11.653]             else {
[10:34:11.653]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:11.653]             }
[10:34:11.653]             {
[10:34:11.653]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:11.653]                   0L) {
[10:34:11.653]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:11.653]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:11.653]                   base::options(opts)
[10:34:11.653]                 }
[10:34:11.653]                 {
[10:34:11.653]                   {
[10:34:11.653]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:11.653]                     NULL
[10:34:11.653]                   }
[10:34:11.653]                   options(future.plan = NULL)
[10:34:11.653]                   if (is.na(NA_character_)) 
[10:34:11.653]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:11.653]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:11.653]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:11.653]                     .init = FALSE)
[10:34:11.653]                 }
[10:34:11.653]             }
[10:34:11.653]         }
[10:34:11.653]     })
[10:34:11.653]     if (TRUE) {
[10:34:11.653]         base::sink(type = "output", split = FALSE)
[10:34:11.653]         if (TRUE) {
[10:34:11.653]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:11.653]         }
[10:34:11.653]         else {
[10:34:11.653]             ...future.result["stdout"] <- base::list(NULL)
[10:34:11.653]         }
[10:34:11.653]         base::close(...future.stdout)
[10:34:11.653]         ...future.stdout <- NULL
[10:34:11.653]     }
[10:34:11.653]     ...future.result$conditions <- ...future.conditions
[10:34:11.653]     ...future.result$finished <- base::Sys.time()
[10:34:11.653]     ...future.result
[10:34:11.653] }
[10:34:11.655] Poll #1 (0): usedNodes() = 2, workers = 2
[10:34:11.676] receiveMessageFromWorker() for ClusterFuture ...
[10:34:11.676] - Validating connection of MultisessionFuture
[10:34:11.677] - received message: FutureResult
[10:34:11.677] - Received FutureResult
[10:34:11.677] - Erased future from FutureRegistry
[10:34:11.677] result() for ClusterFuture ...
[10:34:11.677] - result already collected: FutureResult
[10:34:11.677] result() for ClusterFuture ... done
[10:34:11.678] signalConditions() ...
[10:34:11.678]  - include = ‘immediateCondition’
[10:34:11.678]  - exclude = 
[10:34:11.678]  - resignal = FALSE
[10:34:11.678]  - Number of conditions: 1
[10:34:11.678] signalConditions() ... done
[10:34:11.678] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:11.678] result() for ClusterFuture ...
[10:34:11.678] - result already collected: FutureResult
[10:34:11.678] result() for ClusterFuture ... done
[10:34:11.678] result() for ClusterFuture ...
[10:34:11.679] - result already collected: FutureResult
[10:34:11.679] result() for ClusterFuture ... done
[10:34:11.679] signalConditions() ...
[10:34:11.679]  - include = ‘immediateCondition’
[10:34:11.679]  - exclude = 
[10:34:11.679]  - resignal = FALSE
[10:34:11.679]  - Number of conditions: 1
[10:34:11.679] signalConditions() ... done
[10:34:11.680] MultisessionFuture started
[10:34:11.680] - Launch lazy future ... done
[10:34:11.680] run() for ‘MultisessionFuture’ ... done
[10:34:12.183] receiveMessageFromWorker() for ClusterFuture ...
[10:34:12.183] - Validating connection of MultisessionFuture
[10:34:12.183] - received message: FutureResult
[10:34:12.183] - Received FutureResult
[10:34:12.183] - Erased future from FutureRegistry
[10:34:12.183] result() for ClusterFuture ...
[10:34:12.184] - result already collected: FutureResult
[10:34:12.184] result() for ClusterFuture ... done
[10:34:12.184] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:12.184] A MultisessionFuture was resolved
[10:34:12.184] getGlobalsAndPackages() ...
[10:34:12.184] Searching for globals...
[10:34:12.185] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:34:12.185] Searching for globals ... DONE
[10:34:12.185] Resolving globals: FALSE
[10:34:12.186] 
[10:34:12.186] 
[10:34:12.186] getGlobalsAndPackages() ... DONE
[10:34:12.186] run() for ‘Future’ ...
[10:34:12.186] - state: ‘created’
[10:34:12.187] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:12.208] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:12.209] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:12.209]   - Field: ‘node’
[10:34:12.209]   - Field: ‘label’
[10:34:12.209]   - Field: ‘local’
[10:34:12.209]   - Field: ‘owner’
[10:34:12.209]   - Field: ‘envir’
[10:34:12.209]   - Field: ‘workers’
[10:34:12.209]   - Field: ‘packages’
[10:34:12.209]   - Field: ‘gc’
[10:34:12.210]   - Field: ‘conditions’
[10:34:12.210]   - Field: ‘persistent’
[10:34:12.210]   - Field: ‘expr’
[10:34:12.210]   - Field: ‘uuid’
[10:34:12.210]   - Field: ‘seed’
[10:34:12.210]   - Field: ‘version’
[10:34:12.210]   - Field: ‘result’
[10:34:12.210]   - Field: ‘asynchronous’
[10:34:12.210]   - Field: ‘calls’
[10:34:12.211]   - Field: ‘globals’
[10:34:12.211]   - Field: ‘stdout’
[10:34:12.211]   - Field: ‘earlySignal’
[10:34:12.211]   - Field: ‘lazy’
[10:34:12.211]   - Field: ‘state’
[10:34:12.211] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:12.211] - Launch lazy future ...
[10:34:12.211] Packages needed by the future expression (n = 0): <none>
[10:34:12.211] Packages needed by future strategies (n = 0): <none>
[10:34:12.212] {
[10:34:12.212]     {
[10:34:12.212]         {
[10:34:12.212]             ...future.startTime <- base::Sys.time()
[10:34:12.212]             {
[10:34:12.212]                 {
[10:34:12.212]                   {
[10:34:12.212]                     {
[10:34:12.212]                       base::local({
[10:34:12.212]                         has_future <- base::requireNamespace("future", 
[10:34:12.212]                           quietly = TRUE)
[10:34:12.212]                         if (has_future) {
[10:34:12.212]                           ns <- base::getNamespace("future")
[10:34:12.212]                           version <- ns[[".package"]][["version"]]
[10:34:12.212]                           if (is.null(version)) 
[10:34:12.212]                             version <- utils::packageVersion("future")
[10:34:12.212]                         }
[10:34:12.212]                         else {
[10:34:12.212]                           version <- NULL
[10:34:12.212]                         }
[10:34:12.212]                         if (!has_future || version < "1.8.0") {
[10:34:12.212]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:12.212]                             "", base::R.version$version.string), 
[10:34:12.212]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:12.212]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:12.212]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:12.212]                               "release", "version")], collapse = " "), 
[10:34:12.212]                             hostname = base::Sys.info()[["nodename"]])
[10:34:12.212]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:12.212]                             info)
[10:34:12.212]                           info <- base::paste(info, collapse = "; ")
[10:34:12.212]                           if (!has_future) {
[10:34:12.212]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:12.212]                               info)
[10:34:12.212]                           }
[10:34:12.212]                           else {
[10:34:12.212]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:12.212]                               info, version)
[10:34:12.212]                           }
[10:34:12.212]                           base::stop(msg)
[10:34:12.212]                         }
[10:34:12.212]                       })
[10:34:12.212]                     }
[10:34:12.212]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:12.212]                     base::options(mc.cores = 1L)
[10:34:12.212]                   }
[10:34:12.212]                   ...future.strategy.old <- future::plan("list")
[10:34:12.212]                   options(future.plan = NULL)
[10:34:12.212]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:12.212]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:12.212]                 }
[10:34:12.212]                 ...future.workdir <- getwd()
[10:34:12.212]             }
[10:34:12.212]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:12.212]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:12.212]         }
[10:34:12.212]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:12.212]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:12.212]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:12.212]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:12.212]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:12.212]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:12.212]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:12.212]             base::names(...future.oldOptions))
[10:34:12.212]     }
[10:34:12.212]     if (FALSE) {
[10:34:12.212]     }
[10:34:12.212]     else {
[10:34:12.212]         if (TRUE) {
[10:34:12.212]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:12.212]                 open = "w")
[10:34:12.212]         }
[10:34:12.212]         else {
[10:34:12.212]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:12.212]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:12.212]         }
[10:34:12.212]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:12.212]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:12.212]             base::sink(type = "output", split = FALSE)
[10:34:12.212]             base::close(...future.stdout)
[10:34:12.212]         }, add = TRUE)
[10:34:12.212]     }
[10:34:12.212]     ...future.frame <- base::sys.nframe()
[10:34:12.212]     ...future.conditions <- base::list()
[10:34:12.212]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:12.212]     if (FALSE) {
[10:34:12.212]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:12.212]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:12.212]     }
[10:34:12.212]     ...future.result <- base::tryCatch({
[10:34:12.212]         base::withCallingHandlers({
[10:34:12.212]             ...future.value <- base::withVisible(base::local({
[10:34:12.212]                 ...future.makeSendCondition <- base::local({
[10:34:12.212]                   sendCondition <- NULL
[10:34:12.212]                   function(frame = 1L) {
[10:34:12.212]                     if (is.function(sendCondition)) 
[10:34:12.212]                       return(sendCondition)
[10:34:12.212]                     ns <- getNamespace("parallel")
[10:34:12.212]                     if (exists("sendData", mode = "function", 
[10:34:12.212]                       envir = ns)) {
[10:34:12.212]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:12.212]                         envir = ns)
[10:34:12.212]                       envir <- sys.frame(frame)
[10:34:12.212]                       master <- NULL
[10:34:12.212]                       while (!identical(envir, .GlobalEnv) && 
[10:34:12.212]                         !identical(envir, emptyenv())) {
[10:34:12.212]                         if (exists("master", mode = "list", envir = envir, 
[10:34:12.212]                           inherits = FALSE)) {
[10:34:12.212]                           master <- get("master", mode = "list", 
[10:34:12.212]                             envir = envir, inherits = FALSE)
[10:34:12.212]                           if (inherits(master, c("SOCKnode", 
[10:34:12.212]                             "SOCK0node"))) {
[10:34:12.212]                             sendCondition <<- function(cond) {
[10:34:12.212]                               data <- list(type = "VALUE", value = cond, 
[10:34:12.212]                                 success = TRUE)
[10:34:12.212]                               parallel_sendData(master, data)
[10:34:12.212]                             }
[10:34:12.212]                             return(sendCondition)
[10:34:12.212]                           }
[10:34:12.212]                         }
[10:34:12.212]                         frame <- frame + 1L
[10:34:12.212]                         envir <- sys.frame(frame)
[10:34:12.212]                       }
[10:34:12.212]                     }
[10:34:12.212]                     sendCondition <<- function(cond) NULL
[10:34:12.212]                   }
[10:34:12.212]                 })
[10:34:12.212]                 withCallingHandlers({
[10:34:12.212]                   {
[10:34:12.212]                     Sys.sleep(0.5)
[10:34:12.212]                     list(a = 1, b = 42L)
[10:34:12.212]                   }
[10:34:12.212]                 }, immediateCondition = function(cond) {
[10:34:12.212]                   sendCondition <- ...future.makeSendCondition()
[10:34:12.212]                   sendCondition(cond)
[10:34:12.212]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:12.212]                   {
[10:34:12.212]                     inherits <- base::inherits
[10:34:12.212]                     invokeRestart <- base::invokeRestart
[10:34:12.212]                     is.null <- base::is.null
[10:34:12.212]                     muffled <- FALSE
[10:34:12.212]                     if (inherits(cond, "message")) {
[10:34:12.212]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:12.212]                       if (muffled) 
[10:34:12.212]                         invokeRestart("muffleMessage")
[10:34:12.212]                     }
[10:34:12.212]                     else if (inherits(cond, "warning")) {
[10:34:12.212]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:12.212]                       if (muffled) 
[10:34:12.212]                         invokeRestart("muffleWarning")
[10:34:12.212]                     }
[10:34:12.212]                     else if (inherits(cond, "condition")) {
[10:34:12.212]                       if (!is.null(pattern)) {
[10:34:12.212]                         computeRestarts <- base::computeRestarts
[10:34:12.212]                         grepl <- base::grepl
[10:34:12.212]                         restarts <- computeRestarts(cond)
[10:34:12.212]                         for (restart in restarts) {
[10:34:12.212]                           name <- restart$name
[10:34:12.212]                           if (is.null(name)) 
[10:34:12.212]                             next
[10:34:12.212]                           if (!grepl(pattern, name)) 
[10:34:12.212]                             next
[10:34:12.212]                           invokeRestart(restart)
[10:34:12.212]                           muffled <- TRUE
[10:34:12.212]                           break
[10:34:12.212]                         }
[10:34:12.212]                       }
[10:34:12.212]                     }
[10:34:12.212]                     invisible(muffled)
[10:34:12.212]                   }
[10:34:12.212]                   muffleCondition(cond)
[10:34:12.212]                 })
[10:34:12.212]             }))
[10:34:12.212]             future::FutureResult(value = ...future.value$value, 
[10:34:12.212]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:12.212]                   ...future.rng), globalenv = if (FALSE) 
[10:34:12.212]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:12.212]                     ...future.globalenv.names))
[10:34:12.212]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:12.212]         }, condition = base::local({
[10:34:12.212]             c <- base::c
[10:34:12.212]             inherits <- base::inherits
[10:34:12.212]             invokeRestart <- base::invokeRestart
[10:34:12.212]             length <- base::length
[10:34:12.212]             list <- base::list
[10:34:12.212]             seq.int <- base::seq.int
[10:34:12.212]             signalCondition <- base::signalCondition
[10:34:12.212]             sys.calls <- base::sys.calls
[10:34:12.212]             `[[` <- base::`[[`
[10:34:12.212]             `+` <- base::`+`
[10:34:12.212]             `<<-` <- base::`<<-`
[10:34:12.212]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:12.212]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:12.212]                   3L)]
[10:34:12.212]             }
[10:34:12.212]             function(cond) {
[10:34:12.212]                 is_error <- inherits(cond, "error")
[10:34:12.212]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:12.212]                   NULL)
[10:34:12.212]                 if (is_error) {
[10:34:12.212]                   sessionInformation <- function() {
[10:34:12.212]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:12.212]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:12.212]                       search = base::search(), system = base::Sys.info())
[10:34:12.212]                   }
[10:34:12.212]                   ...future.conditions[[length(...future.conditions) + 
[10:34:12.212]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:12.212]                     cond$call), session = sessionInformation(), 
[10:34:12.212]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:12.212]                   signalCondition(cond)
[10:34:12.212]                 }
[10:34:12.212]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:12.212]                 "immediateCondition"))) {
[10:34:12.212]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:12.212]                   ...future.conditions[[length(...future.conditions) + 
[10:34:12.212]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:12.212]                   if (TRUE && !signal) {
[10:34:12.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:12.212]                     {
[10:34:12.212]                       inherits <- base::inherits
[10:34:12.212]                       invokeRestart <- base::invokeRestart
[10:34:12.212]                       is.null <- base::is.null
[10:34:12.212]                       muffled <- FALSE
[10:34:12.212]                       if (inherits(cond, "message")) {
[10:34:12.212]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:12.212]                         if (muffled) 
[10:34:12.212]                           invokeRestart("muffleMessage")
[10:34:12.212]                       }
[10:34:12.212]                       else if (inherits(cond, "warning")) {
[10:34:12.212]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:12.212]                         if (muffled) 
[10:34:12.212]                           invokeRestart("muffleWarning")
[10:34:12.212]                       }
[10:34:12.212]                       else if (inherits(cond, "condition")) {
[10:34:12.212]                         if (!is.null(pattern)) {
[10:34:12.212]                           computeRestarts <- base::computeRestarts
[10:34:12.212]                           grepl <- base::grepl
[10:34:12.212]                           restarts <- computeRestarts(cond)
[10:34:12.212]                           for (restart in restarts) {
[10:34:12.212]                             name <- restart$name
[10:34:12.212]                             if (is.null(name)) 
[10:34:12.212]                               next
[10:34:12.212]                             if (!grepl(pattern, name)) 
[10:34:12.212]                               next
[10:34:12.212]                             invokeRestart(restart)
[10:34:12.212]                             muffled <- TRUE
[10:34:12.212]                             break
[10:34:12.212]                           }
[10:34:12.212]                         }
[10:34:12.212]                       }
[10:34:12.212]                       invisible(muffled)
[10:34:12.212]                     }
[10:34:12.212]                     muffleCondition(cond, pattern = "^muffle")
[10:34:12.212]                   }
[10:34:12.212]                 }
[10:34:12.212]                 else {
[10:34:12.212]                   if (TRUE) {
[10:34:12.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:12.212]                     {
[10:34:12.212]                       inherits <- base::inherits
[10:34:12.212]                       invokeRestart <- base::invokeRestart
[10:34:12.212]                       is.null <- base::is.null
[10:34:12.212]                       muffled <- FALSE
[10:34:12.212]                       if (inherits(cond, "message")) {
[10:34:12.212]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:12.212]                         if (muffled) 
[10:34:12.212]                           invokeRestart("muffleMessage")
[10:34:12.212]                       }
[10:34:12.212]                       else if (inherits(cond, "warning")) {
[10:34:12.212]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:12.212]                         if (muffled) 
[10:34:12.212]                           invokeRestart("muffleWarning")
[10:34:12.212]                       }
[10:34:12.212]                       else if (inherits(cond, "condition")) {
[10:34:12.212]                         if (!is.null(pattern)) {
[10:34:12.212]                           computeRestarts <- base::computeRestarts
[10:34:12.212]                           grepl <- base::grepl
[10:34:12.212]                           restarts <- computeRestarts(cond)
[10:34:12.212]                           for (restart in restarts) {
[10:34:12.212]                             name <- restart$name
[10:34:12.212]                             if (is.null(name)) 
[10:34:12.212]                               next
[10:34:12.212]                             if (!grepl(pattern, name)) 
[10:34:12.212]                               next
[10:34:12.212]                             invokeRestart(restart)
[10:34:12.212]                             muffled <- TRUE
[10:34:12.212]                             break
[10:34:12.212]                           }
[10:34:12.212]                         }
[10:34:12.212]                       }
[10:34:12.212]                       invisible(muffled)
[10:34:12.212]                     }
[10:34:12.212]                     muffleCondition(cond, pattern = "^muffle")
[10:34:12.212]                   }
[10:34:12.212]                 }
[10:34:12.212]             }
[10:34:12.212]         }))
[10:34:12.212]     }, error = function(ex) {
[10:34:12.212]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:12.212]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:12.212]                 ...future.rng), started = ...future.startTime, 
[10:34:12.212]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:12.212]             version = "1.8"), class = "FutureResult")
[10:34:12.212]     }, finally = {
[10:34:12.212]         if (!identical(...future.workdir, getwd())) 
[10:34:12.212]             setwd(...future.workdir)
[10:34:12.212]         {
[10:34:12.212]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:12.212]                 ...future.oldOptions$nwarnings <- NULL
[10:34:12.212]             }
[10:34:12.212]             base::options(...future.oldOptions)
[10:34:12.212]             if (.Platform$OS.type == "windows") {
[10:34:12.212]                 old_names <- names(...future.oldEnvVars)
[10:34:12.212]                 envs <- base::Sys.getenv()
[10:34:12.212]                 names <- names(envs)
[10:34:12.212]                 common <- intersect(names, old_names)
[10:34:12.212]                 added <- setdiff(names, old_names)
[10:34:12.212]                 removed <- setdiff(old_names, names)
[10:34:12.212]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:12.212]                   envs[common]]
[10:34:12.212]                 NAMES <- toupper(changed)
[10:34:12.212]                 args <- list()
[10:34:12.212]                 for (kk in seq_along(NAMES)) {
[10:34:12.212]                   name <- changed[[kk]]
[10:34:12.212]                   NAME <- NAMES[[kk]]
[10:34:12.212]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:12.212]                     next
[10:34:12.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:12.212]                 }
[10:34:12.212]                 NAMES <- toupper(added)
[10:34:12.212]                 for (kk in seq_along(NAMES)) {
[10:34:12.212]                   name <- added[[kk]]
[10:34:12.212]                   NAME <- NAMES[[kk]]
[10:34:12.212]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:12.212]                     next
[10:34:12.212]                   args[[name]] <- ""
[10:34:12.212]                 }
[10:34:12.212]                 NAMES <- toupper(removed)
[10:34:12.212]                 for (kk in seq_along(NAMES)) {
[10:34:12.212]                   name <- removed[[kk]]
[10:34:12.212]                   NAME <- NAMES[[kk]]
[10:34:12.212]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:12.212]                     next
[10:34:12.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:12.212]                 }
[10:34:12.212]                 if (length(args) > 0) 
[10:34:12.212]                   base::do.call(base::Sys.setenv, args = args)
[10:34:12.212]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:12.212]             }
[10:34:12.212]             else {
[10:34:12.212]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:12.212]             }
[10:34:12.212]             {
[10:34:12.212]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:12.212]                   0L) {
[10:34:12.212]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:12.212]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:12.212]                   base::options(opts)
[10:34:12.212]                 }
[10:34:12.212]                 {
[10:34:12.212]                   {
[10:34:12.212]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:12.212]                     NULL
[10:34:12.212]                   }
[10:34:12.212]                   options(future.plan = NULL)
[10:34:12.212]                   if (is.na(NA_character_)) 
[10:34:12.212]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:12.212]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:12.212]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:12.212]                     .init = FALSE)
[10:34:12.212]                 }
[10:34:12.212]             }
[10:34:12.212]         }
[10:34:12.212]     })
[10:34:12.212]     if (TRUE) {
[10:34:12.212]         base::sink(type = "output", split = FALSE)
[10:34:12.212]         if (TRUE) {
[10:34:12.212]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:12.212]         }
[10:34:12.212]         else {
[10:34:12.212]             ...future.result["stdout"] <- base::list(NULL)
[10:34:12.212]         }
[10:34:12.212]         base::close(...future.stdout)
[10:34:12.212]         ...future.stdout <- NULL
[10:34:12.212]     }
[10:34:12.212]     ...future.result$conditions <- ...future.conditions
[10:34:12.212]     ...future.result$finished <- base::Sys.time()
[10:34:12.212]     ...future.result
[10:34:12.212] }
[10:34:12.215] MultisessionFuture started
[10:34:12.215] - Launch lazy future ... done
[10:34:12.215] run() for ‘MultisessionFuture’ ... done
[10:34:12.717] receiveMessageFromWorker() for ClusterFuture ...
[10:34:12.718] - Validating connection of MultisessionFuture
[10:34:12.718] - received message: FutureResult
[10:34:12.718] - Received FutureResult
[10:34:12.718] - Erased future from FutureRegistry
[10:34:12.718] result() for ClusterFuture ...
[10:34:12.718] - result already collected: FutureResult
[10:34:12.719] result() for ClusterFuture ... done
[10:34:12.719] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:12.719] A MultisessionFuture was resolved
- w/ exception ...
[10:34:12.719] getGlobalsAndPackages() ...
[10:34:12.719] Searching for globals...
[10:34:12.720] - globals found: [2] ‘list’, ‘stop’
[10:34:12.720] Searching for globals ... DONE
[10:34:12.720] Resolving globals: FALSE
[10:34:12.720] 
[10:34:12.720] 
[10:34:12.720] getGlobalsAndPackages() ... DONE
[10:34:12.721] run() for ‘Future’ ...
[10:34:12.721] - state: ‘created’
[10:34:12.721] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:12.735] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:12.735] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:12.735]   - Field: ‘node’
[10:34:12.735]   - Field: ‘label’
[10:34:12.736]   - Field: ‘local’
[10:34:12.736]   - Field: ‘owner’
[10:34:12.736]   - Field: ‘envir’
[10:34:12.736]   - Field: ‘workers’
[10:34:12.736]   - Field: ‘packages’
[10:34:12.736]   - Field: ‘gc’
[10:34:12.736]   - Field: ‘conditions’
[10:34:12.736]   - Field: ‘persistent’
[10:34:12.736]   - Field: ‘expr’
[10:34:12.736]   - Field: ‘uuid’
[10:34:12.736]   - Field: ‘seed’
[10:34:12.737]   - Field: ‘version’
[10:34:12.737]   - Field: ‘result’
[10:34:12.737]   - Field: ‘asynchronous’
[10:34:12.737]   - Field: ‘calls’
[10:34:12.737]   - Field: ‘globals’
[10:34:12.737]   - Field: ‘stdout’
[10:34:12.737]   - Field: ‘earlySignal’
[10:34:12.737]   - Field: ‘lazy’
[10:34:12.737]   - Field: ‘state’
[10:34:12.737] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:12.738] - Launch lazy future ...
[10:34:12.738] Packages needed by the future expression (n = 0): <none>
[10:34:12.738] Packages needed by future strategies (n = 0): <none>
[10:34:12.738] {
[10:34:12.738]     {
[10:34:12.738]         {
[10:34:12.738]             ...future.startTime <- base::Sys.time()
[10:34:12.738]             {
[10:34:12.738]                 {
[10:34:12.738]                   {
[10:34:12.738]                     {
[10:34:12.738]                       base::local({
[10:34:12.738]                         has_future <- base::requireNamespace("future", 
[10:34:12.738]                           quietly = TRUE)
[10:34:12.738]                         if (has_future) {
[10:34:12.738]                           ns <- base::getNamespace("future")
[10:34:12.738]                           version <- ns[[".package"]][["version"]]
[10:34:12.738]                           if (is.null(version)) 
[10:34:12.738]                             version <- utils::packageVersion("future")
[10:34:12.738]                         }
[10:34:12.738]                         else {
[10:34:12.738]                           version <- NULL
[10:34:12.738]                         }
[10:34:12.738]                         if (!has_future || version < "1.8.0") {
[10:34:12.738]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:12.738]                             "", base::R.version$version.string), 
[10:34:12.738]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:12.738]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:12.738]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:12.738]                               "release", "version")], collapse = " "), 
[10:34:12.738]                             hostname = base::Sys.info()[["nodename"]])
[10:34:12.738]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:12.738]                             info)
[10:34:12.738]                           info <- base::paste(info, collapse = "; ")
[10:34:12.738]                           if (!has_future) {
[10:34:12.738]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:12.738]                               info)
[10:34:12.738]                           }
[10:34:12.738]                           else {
[10:34:12.738]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:12.738]                               info, version)
[10:34:12.738]                           }
[10:34:12.738]                           base::stop(msg)
[10:34:12.738]                         }
[10:34:12.738]                       })
[10:34:12.738]                     }
[10:34:12.738]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:12.738]                     base::options(mc.cores = 1L)
[10:34:12.738]                   }
[10:34:12.738]                   ...future.strategy.old <- future::plan("list")
[10:34:12.738]                   options(future.plan = NULL)
[10:34:12.738]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:12.738]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:12.738]                 }
[10:34:12.738]                 ...future.workdir <- getwd()
[10:34:12.738]             }
[10:34:12.738]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:12.738]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:12.738]         }
[10:34:12.738]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:12.738]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:12.738]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:12.738]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:12.738]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:12.738]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:12.738]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:12.738]             base::names(...future.oldOptions))
[10:34:12.738]     }
[10:34:12.738]     if (FALSE) {
[10:34:12.738]     }
[10:34:12.738]     else {
[10:34:12.738]         if (TRUE) {
[10:34:12.738]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:12.738]                 open = "w")
[10:34:12.738]         }
[10:34:12.738]         else {
[10:34:12.738]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:12.738]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:12.738]         }
[10:34:12.738]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:12.738]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:12.738]             base::sink(type = "output", split = FALSE)
[10:34:12.738]             base::close(...future.stdout)
[10:34:12.738]         }, add = TRUE)
[10:34:12.738]     }
[10:34:12.738]     ...future.frame <- base::sys.nframe()
[10:34:12.738]     ...future.conditions <- base::list()
[10:34:12.738]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:12.738]     if (FALSE) {
[10:34:12.738]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:12.738]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:12.738]     }
[10:34:12.738]     ...future.result <- base::tryCatch({
[10:34:12.738]         base::withCallingHandlers({
[10:34:12.738]             ...future.value <- base::withVisible(base::local({
[10:34:12.738]                 ...future.makeSendCondition <- base::local({
[10:34:12.738]                   sendCondition <- NULL
[10:34:12.738]                   function(frame = 1L) {
[10:34:12.738]                     if (is.function(sendCondition)) 
[10:34:12.738]                       return(sendCondition)
[10:34:12.738]                     ns <- getNamespace("parallel")
[10:34:12.738]                     if (exists("sendData", mode = "function", 
[10:34:12.738]                       envir = ns)) {
[10:34:12.738]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:12.738]                         envir = ns)
[10:34:12.738]                       envir <- sys.frame(frame)
[10:34:12.738]                       master <- NULL
[10:34:12.738]                       while (!identical(envir, .GlobalEnv) && 
[10:34:12.738]                         !identical(envir, emptyenv())) {
[10:34:12.738]                         if (exists("master", mode = "list", envir = envir, 
[10:34:12.738]                           inherits = FALSE)) {
[10:34:12.738]                           master <- get("master", mode = "list", 
[10:34:12.738]                             envir = envir, inherits = FALSE)
[10:34:12.738]                           if (inherits(master, c("SOCKnode", 
[10:34:12.738]                             "SOCK0node"))) {
[10:34:12.738]                             sendCondition <<- function(cond) {
[10:34:12.738]                               data <- list(type = "VALUE", value = cond, 
[10:34:12.738]                                 success = TRUE)
[10:34:12.738]                               parallel_sendData(master, data)
[10:34:12.738]                             }
[10:34:12.738]                             return(sendCondition)
[10:34:12.738]                           }
[10:34:12.738]                         }
[10:34:12.738]                         frame <- frame + 1L
[10:34:12.738]                         envir <- sys.frame(frame)
[10:34:12.738]                       }
[10:34:12.738]                     }
[10:34:12.738]                     sendCondition <<- function(cond) NULL
[10:34:12.738]                   }
[10:34:12.738]                 })
[10:34:12.738]                 withCallingHandlers({
[10:34:12.738]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:34:12.738]                 }, immediateCondition = function(cond) {
[10:34:12.738]                   sendCondition <- ...future.makeSendCondition()
[10:34:12.738]                   sendCondition(cond)
[10:34:12.738]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:12.738]                   {
[10:34:12.738]                     inherits <- base::inherits
[10:34:12.738]                     invokeRestart <- base::invokeRestart
[10:34:12.738]                     is.null <- base::is.null
[10:34:12.738]                     muffled <- FALSE
[10:34:12.738]                     if (inherits(cond, "message")) {
[10:34:12.738]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:12.738]                       if (muffled) 
[10:34:12.738]                         invokeRestart("muffleMessage")
[10:34:12.738]                     }
[10:34:12.738]                     else if (inherits(cond, "warning")) {
[10:34:12.738]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:12.738]                       if (muffled) 
[10:34:12.738]                         invokeRestart("muffleWarning")
[10:34:12.738]                     }
[10:34:12.738]                     else if (inherits(cond, "condition")) {
[10:34:12.738]                       if (!is.null(pattern)) {
[10:34:12.738]                         computeRestarts <- base::computeRestarts
[10:34:12.738]                         grepl <- base::grepl
[10:34:12.738]                         restarts <- computeRestarts(cond)
[10:34:12.738]                         for (restart in restarts) {
[10:34:12.738]                           name <- restart$name
[10:34:12.738]                           if (is.null(name)) 
[10:34:12.738]                             next
[10:34:12.738]                           if (!grepl(pattern, name)) 
[10:34:12.738]                             next
[10:34:12.738]                           invokeRestart(restart)
[10:34:12.738]                           muffled <- TRUE
[10:34:12.738]                           break
[10:34:12.738]                         }
[10:34:12.738]                       }
[10:34:12.738]                     }
[10:34:12.738]                     invisible(muffled)
[10:34:12.738]                   }
[10:34:12.738]                   muffleCondition(cond)
[10:34:12.738]                 })
[10:34:12.738]             }))
[10:34:12.738]             future::FutureResult(value = ...future.value$value, 
[10:34:12.738]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:12.738]                   ...future.rng), globalenv = if (FALSE) 
[10:34:12.738]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:12.738]                     ...future.globalenv.names))
[10:34:12.738]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:12.738]         }, condition = base::local({
[10:34:12.738]             c <- base::c
[10:34:12.738]             inherits <- base::inherits
[10:34:12.738]             invokeRestart <- base::invokeRestart
[10:34:12.738]             length <- base::length
[10:34:12.738]             list <- base::list
[10:34:12.738]             seq.int <- base::seq.int
[10:34:12.738]             signalCondition <- base::signalCondition
[10:34:12.738]             sys.calls <- base::sys.calls
[10:34:12.738]             `[[` <- base::`[[`
[10:34:12.738]             `+` <- base::`+`
[10:34:12.738]             `<<-` <- base::`<<-`
[10:34:12.738]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:12.738]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:12.738]                   3L)]
[10:34:12.738]             }
[10:34:12.738]             function(cond) {
[10:34:12.738]                 is_error <- inherits(cond, "error")
[10:34:12.738]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:12.738]                   NULL)
[10:34:12.738]                 if (is_error) {
[10:34:12.738]                   sessionInformation <- function() {
[10:34:12.738]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:12.738]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:12.738]                       search = base::search(), system = base::Sys.info())
[10:34:12.738]                   }
[10:34:12.738]                   ...future.conditions[[length(...future.conditions) + 
[10:34:12.738]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:12.738]                     cond$call), session = sessionInformation(), 
[10:34:12.738]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:12.738]                   signalCondition(cond)
[10:34:12.738]                 }
[10:34:12.738]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:12.738]                 "immediateCondition"))) {
[10:34:12.738]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:12.738]                   ...future.conditions[[length(...future.conditions) + 
[10:34:12.738]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:12.738]                   if (TRUE && !signal) {
[10:34:12.738]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:12.738]                     {
[10:34:12.738]                       inherits <- base::inherits
[10:34:12.738]                       invokeRestart <- base::invokeRestart
[10:34:12.738]                       is.null <- base::is.null
[10:34:12.738]                       muffled <- FALSE
[10:34:12.738]                       if (inherits(cond, "message")) {
[10:34:12.738]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:12.738]                         if (muffled) 
[10:34:12.738]                           invokeRestart("muffleMessage")
[10:34:12.738]                       }
[10:34:12.738]                       else if (inherits(cond, "warning")) {
[10:34:12.738]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:12.738]                         if (muffled) 
[10:34:12.738]                           invokeRestart("muffleWarning")
[10:34:12.738]                       }
[10:34:12.738]                       else if (inherits(cond, "condition")) {
[10:34:12.738]                         if (!is.null(pattern)) {
[10:34:12.738]                           computeRestarts <- base::computeRestarts
[10:34:12.738]                           grepl <- base::grepl
[10:34:12.738]                           restarts <- computeRestarts(cond)
[10:34:12.738]                           for (restart in restarts) {
[10:34:12.738]                             name <- restart$name
[10:34:12.738]                             if (is.null(name)) 
[10:34:12.738]                               next
[10:34:12.738]                             if (!grepl(pattern, name)) 
[10:34:12.738]                               next
[10:34:12.738]                             invokeRestart(restart)
[10:34:12.738]                             muffled <- TRUE
[10:34:12.738]                             break
[10:34:12.738]                           }
[10:34:12.738]                         }
[10:34:12.738]                       }
[10:34:12.738]                       invisible(muffled)
[10:34:12.738]                     }
[10:34:12.738]                     muffleCondition(cond, pattern = "^muffle")
[10:34:12.738]                   }
[10:34:12.738]                 }
[10:34:12.738]                 else {
[10:34:12.738]                   if (TRUE) {
[10:34:12.738]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:12.738]                     {
[10:34:12.738]                       inherits <- base::inherits
[10:34:12.738]                       invokeRestart <- base::invokeRestart
[10:34:12.738]                       is.null <- base::is.null
[10:34:12.738]                       muffled <- FALSE
[10:34:12.738]                       if (inherits(cond, "message")) {
[10:34:12.738]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:12.738]                         if (muffled) 
[10:34:12.738]                           invokeRestart("muffleMessage")
[10:34:12.738]                       }
[10:34:12.738]                       else if (inherits(cond, "warning")) {
[10:34:12.738]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:12.738]                         if (muffled) 
[10:34:12.738]                           invokeRestart("muffleWarning")
[10:34:12.738]                       }
[10:34:12.738]                       else if (inherits(cond, "condition")) {
[10:34:12.738]                         if (!is.null(pattern)) {
[10:34:12.738]                           computeRestarts <- base::computeRestarts
[10:34:12.738]                           grepl <- base::grepl
[10:34:12.738]                           restarts <- computeRestarts(cond)
[10:34:12.738]                           for (restart in restarts) {
[10:34:12.738]                             name <- restart$name
[10:34:12.738]                             if (is.null(name)) 
[10:34:12.738]                               next
[10:34:12.738]                             if (!grepl(pattern, name)) 
[10:34:12.738]                               next
[10:34:12.738]                             invokeRestart(restart)
[10:34:12.738]                             muffled <- TRUE
[10:34:12.738]                             break
[10:34:12.738]                           }
[10:34:12.738]                         }
[10:34:12.738]                       }
[10:34:12.738]                       invisible(muffled)
[10:34:12.738]                     }
[10:34:12.738]                     muffleCondition(cond, pattern = "^muffle")
[10:34:12.738]                   }
[10:34:12.738]                 }
[10:34:12.738]             }
[10:34:12.738]         }))
[10:34:12.738]     }, error = function(ex) {
[10:34:12.738]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:12.738]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:12.738]                 ...future.rng), started = ...future.startTime, 
[10:34:12.738]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:12.738]             version = "1.8"), class = "FutureResult")
[10:34:12.738]     }, finally = {
[10:34:12.738]         if (!identical(...future.workdir, getwd())) 
[10:34:12.738]             setwd(...future.workdir)
[10:34:12.738]         {
[10:34:12.738]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:12.738]                 ...future.oldOptions$nwarnings <- NULL
[10:34:12.738]             }
[10:34:12.738]             base::options(...future.oldOptions)
[10:34:12.738]             if (.Platform$OS.type == "windows") {
[10:34:12.738]                 old_names <- names(...future.oldEnvVars)
[10:34:12.738]                 envs <- base::Sys.getenv()
[10:34:12.738]                 names <- names(envs)
[10:34:12.738]                 common <- intersect(names, old_names)
[10:34:12.738]                 added <- setdiff(names, old_names)
[10:34:12.738]                 removed <- setdiff(old_names, names)
[10:34:12.738]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:12.738]                   envs[common]]
[10:34:12.738]                 NAMES <- toupper(changed)
[10:34:12.738]                 args <- list()
[10:34:12.738]                 for (kk in seq_along(NAMES)) {
[10:34:12.738]                   name <- changed[[kk]]
[10:34:12.738]                   NAME <- NAMES[[kk]]
[10:34:12.738]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:12.738]                     next
[10:34:12.738]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:12.738]                 }
[10:34:12.738]                 NAMES <- toupper(added)
[10:34:12.738]                 for (kk in seq_along(NAMES)) {
[10:34:12.738]                   name <- added[[kk]]
[10:34:12.738]                   NAME <- NAMES[[kk]]
[10:34:12.738]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:12.738]                     next
[10:34:12.738]                   args[[name]] <- ""
[10:34:12.738]                 }
[10:34:12.738]                 NAMES <- toupper(removed)
[10:34:12.738]                 for (kk in seq_along(NAMES)) {
[10:34:12.738]                   name <- removed[[kk]]
[10:34:12.738]                   NAME <- NAMES[[kk]]
[10:34:12.738]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:12.738]                     next
[10:34:12.738]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:12.738]                 }
[10:34:12.738]                 if (length(args) > 0) 
[10:34:12.738]                   base::do.call(base::Sys.setenv, args = args)
[10:34:12.738]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:12.738]             }
[10:34:12.738]             else {
[10:34:12.738]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:12.738]             }
[10:34:12.738]             {
[10:34:12.738]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:12.738]                   0L) {
[10:34:12.738]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:12.738]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:12.738]                   base::options(opts)
[10:34:12.738]                 }
[10:34:12.738]                 {
[10:34:12.738]                   {
[10:34:12.738]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:12.738]                     NULL
[10:34:12.738]                   }
[10:34:12.738]                   options(future.plan = NULL)
[10:34:12.738]                   if (is.na(NA_character_)) 
[10:34:12.738]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:12.738]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:12.738]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:12.738]                     .init = FALSE)
[10:34:12.738]                 }
[10:34:12.738]             }
[10:34:12.738]         }
[10:34:12.738]     })
[10:34:12.738]     if (TRUE) {
[10:34:12.738]         base::sink(type = "output", split = FALSE)
[10:34:12.738]         if (TRUE) {
[10:34:12.738]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:12.738]         }
[10:34:12.738]         else {
[10:34:12.738]             ...future.result["stdout"] <- base::list(NULL)
[10:34:12.738]         }
[10:34:12.738]         base::close(...future.stdout)
[10:34:12.738]         ...future.stdout <- NULL
[10:34:12.738]     }
[10:34:12.738]     ...future.result$conditions <- ...future.conditions
[10:34:12.738]     ...future.result$finished <- base::Sys.time()
[10:34:12.738]     ...future.result
[10:34:12.738] }
[10:34:12.741] MultisessionFuture started
[10:34:12.741] - Launch lazy future ... done
[10:34:12.741] run() for ‘MultisessionFuture’ ... done
[10:34:12.743] receiveMessageFromWorker() for ClusterFuture ...
[10:34:12.743] - Validating connection of MultisessionFuture
[10:34:12.743] - received message: FutureResult
[10:34:12.743] - Received FutureResult
[10:34:12.744] - Erased future from FutureRegistry
[10:34:12.744] result() for ClusterFuture ...
[10:34:12.744] - result already collected: FutureResult
[10:34:12.744] result() for ClusterFuture ... done
[10:34:12.744] signalConditions() ...
[10:34:12.744]  - include = ‘immediateCondition’
[10:34:12.744]  - exclude = 
[10:34:12.744]  - resignal = FALSE
[10:34:12.744]  - Number of conditions: 1
[10:34:12.744] signalConditions() ... done
[10:34:12.744] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:12.745] A MultisessionFuture was resolved
[10:34:12.745] getGlobalsAndPackages() ...
[10:34:12.745] Searching for globals...
[10:34:12.745] - globals found: [2] ‘list’, ‘stop’
[10:34:12.746] Searching for globals ... DONE
[10:34:12.746] Resolving globals: FALSE
[10:34:12.746] 
[10:34:12.746] 
[10:34:12.746] getGlobalsAndPackages() ... DONE
[10:34:12.746] run() for ‘Future’ ...
[10:34:12.746] - state: ‘created’
[10:34:12.747] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:12.761] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:12.761] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:12.761]   - Field: ‘node’
[10:34:12.761]   - Field: ‘label’
[10:34:12.761]   - Field: ‘local’
[10:34:12.762]   - Field: ‘owner’
[10:34:12.762]   - Field: ‘envir’
[10:34:12.762]   - Field: ‘workers’
[10:34:12.762]   - Field: ‘packages’
[10:34:12.762]   - Field: ‘gc’
[10:34:12.762]   - Field: ‘conditions’
[10:34:12.762]   - Field: ‘persistent’
[10:34:12.762]   - Field: ‘expr’
[10:34:12.762]   - Field: ‘uuid’
[10:34:12.762]   - Field: ‘seed’
[10:34:12.762]   - Field: ‘version’
[10:34:12.763]   - Field: ‘result’
[10:34:12.763]   - Field: ‘asynchronous’
[10:34:12.763]   - Field: ‘calls’
[10:34:12.763]   - Field: ‘globals’
[10:34:12.763]   - Field: ‘stdout’
[10:34:12.763]   - Field: ‘earlySignal’
[10:34:12.763]   - Field: ‘lazy’
[10:34:12.763]   - Field: ‘state’
[10:34:12.763] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:12.763] - Launch lazy future ...
[10:34:12.764] Packages needed by the future expression (n = 0): <none>
[10:34:12.764] Packages needed by future strategies (n = 0): <none>
[10:34:12.764] {
[10:34:12.764]     {
[10:34:12.764]         {
[10:34:12.764]             ...future.startTime <- base::Sys.time()
[10:34:12.764]             {
[10:34:12.764]                 {
[10:34:12.764]                   {
[10:34:12.764]                     {
[10:34:12.764]                       base::local({
[10:34:12.764]                         has_future <- base::requireNamespace("future", 
[10:34:12.764]                           quietly = TRUE)
[10:34:12.764]                         if (has_future) {
[10:34:12.764]                           ns <- base::getNamespace("future")
[10:34:12.764]                           version <- ns[[".package"]][["version"]]
[10:34:12.764]                           if (is.null(version)) 
[10:34:12.764]                             version <- utils::packageVersion("future")
[10:34:12.764]                         }
[10:34:12.764]                         else {
[10:34:12.764]                           version <- NULL
[10:34:12.764]                         }
[10:34:12.764]                         if (!has_future || version < "1.8.0") {
[10:34:12.764]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:12.764]                             "", base::R.version$version.string), 
[10:34:12.764]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:12.764]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:12.764]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:12.764]                               "release", "version")], collapse = " "), 
[10:34:12.764]                             hostname = base::Sys.info()[["nodename"]])
[10:34:12.764]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:12.764]                             info)
[10:34:12.764]                           info <- base::paste(info, collapse = "; ")
[10:34:12.764]                           if (!has_future) {
[10:34:12.764]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:12.764]                               info)
[10:34:12.764]                           }
[10:34:12.764]                           else {
[10:34:12.764]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:12.764]                               info, version)
[10:34:12.764]                           }
[10:34:12.764]                           base::stop(msg)
[10:34:12.764]                         }
[10:34:12.764]                       })
[10:34:12.764]                     }
[10:34:12.764]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:12.764]                     base::options(mc.cores = 1L)
[10:34:12.764]                   }
[10:34:12.764]                   ...future.strategy.old <- future::plan("list")
[10:34:12.764]                   options(future.plan = NULL)
[10:34:12.764]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:12.764]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:12.764]                 }
[10:34:12.764]                 ...future.workdir <- getwd()
[10:34:12.764]             }
[10:34:12.764]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:12.764]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:12.764]         }
[10:34:12.764]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:12.764]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:12.764]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:12.764]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:12.764]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:12.764]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:12.764]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:12.764]             base::names(...future.oldOptions))
[10:34:12.764]     }
[10:34:12.764]     if (FALSE) {
[10:34:12.764]     }
[10:34:12.764]     else {
[10:34:12.764]         if (TRUE) {
[10:34:12.764]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:12.764]                 open = "w")
[10:34:12.764]         }
[10:34:12.764]         else {
[10:34:12.764]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:12.764]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:12.764]         }
[10:34:12.764]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:12.764]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:12.764]             base::sink(type = "output", split = FALSE)
[10:34:12.764]             base::close(...future.stdout)
[10:34:12.764]         }, add = TRUE)
[10:34:12.764]     }
[10:34:12.764]     ...future.frame <- base::sys.nframe()
[10:34:12.764]     ...future.conditions <- base::list()
[10:34:12.764]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:12.764]     if (FALSE) {
[10:34:12.764]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:12.764]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:12.764]     }
[10:34:12.764]     ...future.result <- base::tryCatch({
[10:34:12.764]         base::withCallingHandlers({
[10:34:12.764]             ...future.value <- base::withVisible(base::local({
[10:34:12.764]                 ...future.makeSendCondition <- base::local({
[10:34:12.764]                   sendCondition <- NULL
[10:34:12.764]                   function(frame = 1L) {
[10:34:12.764]                     if (is.function(sendCondition)) 
[10:34:12.764]                       return(sendCondition)
[10:34:12.764]                     ns <- getNamespace("parallel")
[10:34:12.764]                     if (exists("sendData", mode = "function", 
[10:34:12.764]                       envir = ns)) {
[10:34:12.764]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:12.764]                         envir = ns)
[10:34:12.764]                       envir <- sys.frame(frame)
[10:34:12.764]                       master <- NULL
[10:34:12.764]                       while (!identical(envir, .GlobalEnv) && 
[10:34:12.764]                         !identical(envir, emptyenv())) {
[10:34:12.764]                         if (exists("master", mode = "list", envir = envir, 
[10:34:12.764]                           inherits = FALSE)) {
[10:34:12.764]                           master <- get("master", mode = "list", 
[10:34:12.764]                             envir = envir, inherits = FALSE)
[10:34:12.764]                           if (inherits(master, c("SOCKnode", 
[10:34:12.764]                             "SOCK0node"))) {
[10:34:12.764]                             sendCondition <<- function(cond) {
[10:34:12.764]                               data <- list(type = "VALUE", value = cond, 
[10:34:12.764]                                 success = TRUE)
[10:34:12.764]                               parallel_sendData(master, data)
[10:34:12.764]                             }
[10:34:12.764]                             return(sendCondition)
[10:34:12.764]                           }
[10:34:12.764]                         }
[10:34:12.764]                         frame <- frame + 1L
[10:34:12.764]                         envir <- sys.frame(frame)
[10:34:12.764]                       }
[10:34:12.764]                     }
[10:34:12.764]                     sendCondition <<- function(cond) NULL
[10:34:12.764]                   }
[10:34:12.764]                 })
[10:34:12.764]                 withCallingHandlers({
[10:34:12.764]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:34:12.764]                 }, immediateCondition = function(cond) {
[10:34:12.764]                   sendCondition <- ...future.makeSendCondition()
[10:34:12.764]                   sendCondition(cond)
[10:34:12.764]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:12.764]                   {
[10:34:12.764]                     inherits <- base::inherits
[10:34:12.764]                     invokeRestart <- base::invokeRestart
[10:34:12.764]                     is.null <- base::is.null
[10:34:12.764]                     muffled <- FALSE
[10:34:12.764]                     if (inherits(cond, "message")) {
[10:34:12.764]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:12.764]                       if (muffled) 
[10:34:12.764]                         invokeRestart("muffleMessage")
[10:34:12.764]                     }
[10:34:12.764]                     else if (inherits(cond, "warning")) {
[10:34:12.764]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:12.764]                       if (muffled) 
[10:34:12.764]                         invokeRestart("muffleWarning")
[10:34:12.764]                     }
[10:34:12.764]                     else if (inherits(cond, "condition")) {
[10:34:12.764]                       if (!is.null(pattern)) {
[10:34:12.764]                         computeRestarts <- base::computeRestarts
[10:34:12.764]                         grepl <- base::grepl
[10:34:12.764]                         restarts <- computeRestarts(cond)
[10:34:12.764]                         for (restart in restarts) {
[10:34:12.764]                           name <- restart$name
[10:34:12.764]                           if (is.null(name)) 
[10:34:12.764]                             next
[10:34:12.764]                           if (!grepl(pattern, name)) 
[10:34:12.764]                             next
[10:34:12.764]                           invokeRestart(restart)
[10:34:12.764]                           muffled <- TRUE
[10:34:12.764]                           break
[10:34:12.764]                         }
[10:34:12.764]                       }
[10:34:12.764]                     }
[10:34:12.764]                     invisible(muffled)
[10:34:12.764]                   }
[10:34:12.764]                   muffleCondition(cond)
[10:34:12.764]                 })
[10:34:12.764]             }))
[10:34:12.764]             future::FutureResult(value = ...future.value$value, 
[10:34:12.764]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:12.764]                   ...future.rng), globalenv = if (FALSE) 
[10:34:12.764]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:12.764]                     ...future.globalenv.names))
[10:34:12.764]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:12.764]         }, condition = base::local({
[10:34:12.764]             c <- base::c
[10:34:12.764]             inherits <- base::inherits
[10:34:12.764]             invokeRestart <- base::invokeRestart
[10:34:12.764]             length <- base::length
[10:34:12.764]             list <- base::list
[10:34:12.764]             seq.int <- base::seq.int
[10:34:12.764]             signalCondition <- base::signalCondition
[10:34:12.764]             sys.calls <- base::sys.calls
[10:34:12.764]             `[[` <- base::`[[`
[10:34:12.764]             `+` <- base::`+`
[10:34:12.764]             `<<-` <- base::`<<-`
[10:34:12.764]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:12.764]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:12.764]                   3L)]
[10:34:12.764]             }
[10:34:12.764]             function(cond) {
[10:34:12.764]                 is_error <- inherits(cond, "error")
[10:34:12.764]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:12.764]                   NULL)
[10:34:12.764]                 if (is_error) {
[10:34:12.764]                   sessionInformation <- function() {
[10:34:12.764]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:12.764]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:12.764]                       search = base::search(), system = base::Sys.info())
[10:34:12.764]                   }
[10:34:12.764]                   ...future.conditions[[length(...future.conditions) + 
[10:34:12.764]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:12.764]                     cond$call), session = sessionInformation(), 
[10:34:12.764]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:12.764]                   signalCondition(cond)
[10:34:12.764]                 }
[10:34:12.764]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:12.764]                 "immediateCondition"))) {
[10:34:12.764]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:12.764]                   ...future.conditions[[length(...future.conditions) + 
[10:34:12.764]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:12.764]                   if (TRUE && !signal) {
[10:34:12.764]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:12.764]                     {
[10:34:12.764]                       inherits <- base::inherits
[10:34:12.764]                       invokeRestart <- base::invokeRestart
[10:34:12.764]                       is.null <- base::is.null
[10:34:12.764]                       muffled <- FALSE
[10:34:12.764]                       if (inherits(cond, "message")) {
[10:34:12.764]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:12.764]                         if (muffled) 
[10:34:12.764]                           invokeRestart("muffleMessage")
[10:34:12.764]                       }
[10:34:12.764]                       else if (inherits(cond, "warning")) {
[10:34:12.764]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:12.764]                         if (muffled) 
[10:34:12.764]                           invokeRestart("muffleWarning")
[10:34:12.764]                       }
[10:34:12.764]                       else if (inherits(cond, "condition")) {
[10:34:12.764]                         if (!is.null(pattern)) {
[10:34:12.764]                           computeRestarts <- base::computeRestarts
[10:34:12.764]                           grepl <- base::grepl
[10:34:12.764]                           restarts <- computeRestarts(cond)
[10:34:12.764]                           for (restart in restarts) {
[10:34:12.764]                             name <- restart$name
[10:34:12.764]                             if (is.null(name)) 
[10:34:12.764]                               next
[10:34:12.764]                             if (!grepl(pattern, name)) 
[10:34:12.764]                               next
[10:34:12.764]                             invokeRestart(restart)
[10:34:12.764]                             muffled <- TRUE
[10:34:12.764]                             break
[10:34:12.764]                           }
[10:34:12.764]                         }
[10:34:12.764]                       }
[10:34:12.764]                       invisible(muffled)
[10:34:12.764]                     }
[10:34:12.764]                     muffleCondition(cond, pattern = "^muffle")
[10:34:12.764]                   }
[10:34:12.764]                 }
[10:34:12.764]                 else {
[10:34:12.764]                   if (TRUE) {
[10:34:12.764]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:12.764]                     {
[10:34:12.764]                       inherits <- base::inherits
[10:34:12.764]                       invokeRestart <- base::invokeRestart
[10:34:12.764]                       is.null <- base::is.null
[10:34:12.764]                       muffled <- FALSE
[10:34:12.764]                       if (inherits(cond, "message")) {
[10:34:12.764]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:12.764]                         if (muffled) 
[10:34:12.764]                           invokeRestart("muffleMessage")
[10:34:12.764]                       }
[10:34:12.764]                       else if (inherits(cond, "warning")) {
[10:34:12.764]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:12.764]                         if (muffled) 
[10:34:12.764]                           invokeRestart("muffleWarning")
[10:34:12.764]                       }
[10:34:12.764]                       else if (inherits(cond, "condition")) {
[10:34:12.764]                         if (!is.null(pattern)) {
[10:34:12.764]                           computeRestarts <- base::computeRestarts
[10:34:12.764]                           grepl <- base::grepl
[10:34:12.764]                           restarts <- computeRestarts(cond)
[10:34:12.764]                           for (restart in restarts) {
[10:34:12.764]                             name <- restart$name
[10:34:12.764]                             if (is.null(name)) 
[10:34:12.764]                               next
[10:34:12.764]                             if (!grepl(pattern, name)) 
[10:34:12.764]                               next
[10:34:12.764]                             invokeRestart(restart)
[10:34:12.764]                             muffled <- TRUE
[10:34:12.764]                             break
[10:34:12.764]                           }
[10:34:12.764]                         }
[10:34:12.764]                       }
[10:34:12.764]                       invisible(muffled)
[10:34:12.764]                     }
[10:34:12.764]                     muffleCondition(cond, pattern = "^muffle")
[10:34:12.764]                   }
[10:34:12.764]                 }
[10:34:12.764]             }
[10:34:12.764]         }))
[10:34:12.764]     }, error = function(ex) {
[10:34:12.764]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:12.764]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:12.764]                 ...future.rng), started = ...future.startTime, 
[10:34:12.764]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:12.764]             version = "1.8"), class = "FutureResult")
[10:34:12.764]     }, finally = {
[10:34:12.764]         if (!identical(...future.workdir, getwd())) 
[10:34:12.764]             setwd(...future.workdir)
[10:34:12.764]         {
[10:34:12.764]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:12.764]                 ...future.oldOptions$nwarnings <- NULL
[10:34:12.764]             }
[10:34:12.764]             base::options(...future.oldOptions)
[10:34:12.764]             if (.Platform$OS.type == "windows") {
[10:34:12.764]                 old_names <- names(...future.oldEnvVars)
[10:34:12.764]                 envs <- base::Sys.getenv()
[10:34:12.764]                 names <- names(envs)
[10:34:12.764]                 common <- intersect(names, old_names)
[10:34:12.764]                 added <- setdiff(names, old_names)
[10:34:12.764]                 removed <- setdiff(old_names, names)
[10:34:12.764]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:12.764]                   envs[common]]
[10:34:12.764]                 NAMES <- toupper(changed)
[10:34:12.764]                 args <- list()
[10:34:12.764]                 for (kk in seq_along(NAMES)) {
[10:34:12.764]                   name <- changed[[kk]]
[10:34:12.764]                   NAME <- NAMES[[kk]]
[10:34:12.764]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:12.764]                     next
[10:34:12.764]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:12.764]                 }
[10:34:12.764]                 NAMES <- toupper(added)
[10:34:12.764]                 for (kk in seq_along(NAMES)) {
[10:34:12.764]                   name <- added[[kk]]
[10:34:12.764]                   NAME <- NAMES[[kk]]
[10:34:12.764]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:12.764]                     next
[10:34:12.764]                   args[[name]] <- ""
[10:34:12.764]                 }
[10:34:12.764]                 NAMES <- toupper(removed)
[10:34:12.764]                 for (kk in seq_along(NAMES)) {
[10:34:12.764]                   name <- removed[[kk]]
[10:34:12.764]                   NAME <- NAMES[[kk]]
[10:34:12.764]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:12.764]                     next
[10:34:12.764]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:12.764]                 }
[10:34:12.764]                 if (length(args) > 0) 
[10:34:12.764]                   base::do.call(base::Sys.setenv, args = args)
[10:34:12.764]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:12.764]             }
[10:34:12.764]             else {
[10:34:12.764]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:12.764]             }
[10:34:12.764]             {
[10:34:12.764]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:12.764]                   0L) {
[10:34:12.764]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:12.764]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:12.764]                   base::options(opts)
[10:34:12.764]                 }
[10:34:12.764]                 {
[10:34:12.764]                   {
[10:34:12.764]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:12.764]                     NULL
[10:34:12.764]                   }
[10:34:12.764]                   options(future.plan = NULL)
[10:34:12.764]                   if (is.na(NA_character_)) 
[10:34:12.764]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:12.764]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:12.764]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:12.764]                     .init = FALSE)
[10:34:12.764]                 }
[10:34:12.764]             }
[10:34:12.764]         }
[10:34:12.764]     })
[10:34:12.764]     if (TRUE) {
[10:34:12.764]         base::sink(type = "output", split = FALSE)
[10:34:12.764]         if (TRUE) {
[10:34:12.764]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:12.764]         }
[10:34:12.764]         else {
[10:34:12.764]             ...future.result["stdout"] <- base::list(NULL)
[10:34:12.764]         }
[10:34:12.764]         base::close(...future.stdout)
[10:34:12.764]         ...future.stdout <- NULL
[10:34:12.764]     }
[10:34:12.764]     ...future.result$conditions <- ...future.conditions
[10:34:12.764]     ...future.result$finished <- base::Sys.time()
[10:34:12.764]     ...future.result
[10:34:12.764] }
[10:34:12.767] MultisessionFuture started
[10:34:12.767] - Launch lazy future ... done
[10:34:12.767] run() for ‘MultisessionFuture’ ... done
[10:34:12.768] receiveMessageFromWorker() for ClusterFuture ...
[10:34:12.768] - Validating connection of MultisessionFuture
[10:34:12.769] - received message: FutureResult
[10:34:12.769] - Received FutureResult
[10:34:12.769] - Erased future from FutureRegistry
[10:34:12.769] result() for ClusterFuture ...
[10:34:12.769] - result already collected: FutureResult
[10:34:12.769] result() for ClusterFuture ... done
[10:34:12.770] signalConditions() ...
[10:34:12.770]  - include = ‘immediateCondition’
[10:34:12.770]  - exclude = 
[10:34:12.770]  - resignal = FALSE
[10:34:12.770]  - Number of conditions: 1
[10:34:12.770] signalConditions() ... done
[10:34:12.770] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:12.770] A MultisessionFuture was resolved
- result = TRUE, recursive = 0 ... DONE
- result = TRUE, recursive = 1 ...
[10:34:12.770] getGlobalsAndPackages() ...
[10:34:12.770] Searching for globals...
[10:34:12.772] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:34:12.772] Searching for globals ... DONE
[10:34:12.772] Resolving globals: FALSE
[10:34:12.772] 
[10:34:12.772] 
[10:34:12.772] getGlobalsAndPackages() ... DONE
[10:34:12.772] run() for ‘Future’ ...
[10:34:12.773] - state: ‘created’
[10:34:12.773] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:12.786] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:12.786] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:12.786]   - Field: ‘node’
[10:34:12.786]   - Field: ‘label’
[10:34:12.786]   - Field: ‘local’
[10:34:12.786]   - Field: ‘owner’
[10:34:12.786]   - Field: ‘envir’
[10:34:12.787]   - Field: ‘workers’
[10:34:12.787]   - Field: ‘packages’
[10:34:12.787]   - Field: ‘gc’
[10:34:12.787]   - Field: ‘conditions’
[10:34:12.787]   - Field: ‘persistent’
[10:34:12.787]   - Field: ‘expr’
[10:34:12.787]   - Field: ‘uuid’
[10:34:12.787]   - Field: ‘seed’
[10:34:12.787]   - Field: ‘version’
[10:34:12.787]   - Field: ‘result’
[10:34:12.787]   - Field: ‘asynchronous’
[10:34:12.788]   - Field: ‘calls’
[10:34:12.788]   - Field: ‘globals’
[10:34:12.788]   - Field: ‘stdout’
[10:34:12.788]   - Field: ‘earlySignal’
[10:34:12.788]   - Field: ‘lazy’
[10:34:12.788]   - Field: ‘state’
[10:34:12.788] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:12.788] - Launch lazy future ...
[10:34:12.788] Packages needed by the future expression (n = 0): <none>
[10:34:12.789] Packages needed by future strategies (n = 0): <none>
[10:34:12.789] {
[10:34:12.789]     {
[10:34:12.789]         {
[10:34:12.789]             ...future.startTime <- base::Sys.time()
[10:34:12.789]             {
[10:34:12.789]                 {
[10:34:12.789]                   {
[10:34:12.789]                     {
[10:34:12.789]                       base::local({
[10:34:12.789]                         has_future <- base::requireNamespace("future", 
[10:34:12.789]                           quietly = TRUE)
[10:34:12.789]                         if (has_future) {
[10:34:12.789]                           ns <- base::getNamespace("future")
[10:34:12.789]                           version <- ns[[".package"]][["version"]]
[10:34:12.789]                           if (is.null(version)) 
[10:34:12.789]                             version <- utils::packageVersion("future")
[10:34:12.789]                         }
[10:34:12.789]                         else {
[10:34:12.789]                           version <- NULL
[10:34:12.789]                         }
[10:34:12.789]                         if (!has_future || version < "1.8.0") {
[10:34:12.789]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:12.789]                             "", base::R.version$version.string), 
[10:34:12.789]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:12.789]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:12.789]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:12.789]                               "release", "version")], collapse = " "), 
[10:34:12.789]                             hostname = base::Sys.info()[["nodename"]])
[10:34:12.789]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:12.789]                             info)
[10:34:12.789]                           info <- base::paste(info, collapse = "; ")
[10:34:12.789]                           if (!has_future) {
[10:34:12.789]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:12.789]                               info)
[10:34:12.789]                           }
[10:34:12.789]                           else {
[10:34:12.789]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:12.789]                               info, version)
[10:34:12.789]                           }
[10:34:12.789]                           base::stop(msg)
[10:34:12.789]                         }
[10:34:12.789]                       })
[10:34:12.789]                     }
[10:34:12.789]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:12.789]                     base::options(mc.cores = 1L)
[10:34:12.789]                   }
[10:34:12.789]                   ...future.strategy.old <- future::plan("list")
[10:34:12.789]                   options(future.plan = NULL)
[10:34:12.789]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:12.789]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:12.789]                 }
[10:34:12.789]                 ...future.workdir <- getwd()
[10:34:12.789]             }
[10:34:12.789]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:12.789]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:12.789]         }
[10:34:12.789]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:12.789]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:12.789]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:12.789]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:12.789]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:12.789]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:12.789]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:12.789]             base::names(...future.oldOptions))
[10:34:12.789]     }
[10:34:12.789]     if (FALSE) {
[10:34:12.789]     }
[10:34:12.789]     else {
[10:34:12.789]         if (TRUE) {
[10:34:12.789]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:12.789]                 open = "w")
[10:34:12.789]         }
[10:34:12.789]         else {
[10:34:12.789]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:12.789]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:12.789]         }
[10:34:12.789]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:12.789]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:12.789]             base::sink(type = "output", split = FALSE)
[10:34:12.789]             base::close(...future.stdout)
[10:34:12.789]         }, add = TRUE)
[10:34:12.789]     }
[10:34:12.789]     ...future.frame <- base::sys.nframe()
[10:34:12.789]     ...future.conditions <- base::list()
[10:34:12.789]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:12.789]     if (FALSE) {
[10:34:12.789]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:12.789]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:12.789]     }
[10:34:12.789]     ...future.result <- base::tryCatch({
[10:34:12.789]         base::withCallingHandlers({
[10:34:12.789]             ...future.value <- base::withVisible(base::local({
[10:34:12.789]                 ...future.makeSendCondition <- base::local({
[10:34:12.789]                   sendCondition <- NULL
[10:34:12.789]                   function(frame = 1L) {
[10:34:12.789]                     if (is.function(sendCondition)) 
[10:34:12.789]                       return(sendCondition)
[10:34:12.789]                     ns <- getNamespace("parallel")
[10:34:12.789]                     if (exists("sendData", mode = "function", 
[10:34:12.789]                       envir = ns)) {
[10:34:12.789]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:12.789]                         envir = ns)
[10:34:12.789]                       envir <- sys.frame(frame)
[10:34:12.789]                       master <- NULL
[10:34:12.789]                       while (!identical(envir, .GlobalEnv) && 
[10:34:12.789]                         !identical(envir, emptyenv())) {
[10:34:12.789]                         if (exists("master", mode = "list", envir = envir, 
[10:34:12.789]                           inherits = FALSE)) {
[10:34:12.789]                           master <- get("master", mode = "list", 
[10:34:12.789]                             envir = envir, inherits = FALSE)
[10:34:12.789]                           if (inherits(master, c("SOCKnode", 
[10:34:12.789]                             "SOCK0node"))) {
[10:34:12.789]                             sendCondition <<- function(cond) {
[10:34:12.789]                               data <- list(type = "VALUE", value = cond, 
[10:34:12.789]                                 success = TRUE)
[10:34:12.789]                               parallel_sendData(master, data)
[10:34:12.789]                             }
[10:34:12.789]                             return(sendCondition)
[10:34:12.789]                           }
[10:34:12.789]                         }
[10:34:12.789]                         frame <- frame + 1L
[10:34:12.789]                         envir <- sys.frame(frame)
[10:34:12.789]                       }
[10:34:12.789]                     }
[10:34:12.789]                     sendCondition <<- function(cond) NULL
[10:34:12.789]                   }
[10:34:12.789]                 })
[10:34:12.789]                 withCallingHandlers({
[10:34:12.789]                   {
[10:34:12.789]                     Sys.sleep(0.5)
[10:34:12.789]                     list(a = 1, b = 42L)
[10:34:12.789]                   }
[10:34:12.789]                 }, immediateCondition = function(cond) {
[10:34:12.789]                   sendCondition <- ...future.makeSendCondition()
[10:34:12.789]                   sendCondition(cond)
[10:34:12.789]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:12.789]                   {
[10:34:12.789]                     inherits <- base::inherits
[10:34:12.789]                     invokeRestart <- base::invokeRestart
[10:34:12.789]                     is.null <- base::is.null
[10:34:12.789]                     muffled <- FALSE
[10:34:12.789]                     if (inherits(cond, "message")) {
[10:34:12.789]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:12.789]                       if (muffled) 
[10:34:12.789]                         invokeRestart("muffleMessage")
[10:34:12.789]                     }
[10:34:12.789]                     else if (inherits(cond, "warning")) {
[10:34:12.789]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:12.789]                       if (muffled) 
[10:34:12.789]                         invokeRestart("muffleWarning")
[10:34:12.789]                     }
[10:34:12.789]                     else if (inherits(cond, "condition")) {
[10:34:12.789]                       if (!is.null(pattern)) {
[10:34:12.789]                         computeRestarts <- base::computeRestarts
[10:34:12.789]                         grepl <- base::grepl
[10:34:12.789]                         restarts <- computeRestarts(cond)
[10:34:12.789]                         for (restart in restarts) {
[10:34:12.789]                           name <- restart$name
[10:34:12.789]                           if (is.null(name)) 
[10:34:12.789]                             next
[10:34:12.789]                           if (!grepl(pattern, name)) 
[10:34:12.789]                             next
[10:34:12.789]                           invokeRestart(restart)
[10:34:12.789]                           muffled <- TRUE
[10:34:12.789]                           break
[10:34:12.789]                         }
[10:34:12.789]                       }
[10:34:12.789]                     }
[10:34:12.789]                     invisible(muffled)
[10:34:12.789]                   }
[10:34:12.789]                   muffleCondition(cond)
[10:34:12.789]                 })
[10:34:12.789]             }))
[10:34:12.789]             future::FutureResult(value = ...future.value$value, 
[10:34:12.789]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:12.789]                   ...future.rng), globalenv = if (FALSE) 
[10:34:12.789]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:12.789]                     ...future.globalenv.names))
[10:34:12.789]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:12.789]         }, condition = base::local({
[10:34:12.789]             c <- base::c
[10:34:12.789]             inherits <- base::inherits
[10:34:12.789]             invokeRestart <- base::invokeRestart
[10:34:12.789]             length <- base::length
[10:34:12.789]             list <- base::list
[10:34:12.789]             seq.int <- base::seq.int
[10:34:12.789]             signalCondition <- base::signalCondition
[10:34:12.789]             sys.calls <- base::sys.calls
[10:34:12.789]             `[[` <- base::`[[`
[10:34:12.789]             `+` <- base::`+`
[10:34:12.789]             `<<-` <- base::`<<-`
[10:34:12.789]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:12.789]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:12.789]                   3L)]
[10:34:12.789]             }
[10:34:12.789]             function(cond) {
[10:34:12.789]                 is_error <- inherits(cond, "error")
[10:34:12.789]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:12.789]                   NULL)
[10:34:12.789]                 if (is_error) {
[10:34:12.789]                   sessionInformation <- function() {
[10:34:12.789]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:12.789]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:12.789]                       search = base::search(), system = base::Sys.info())
[10:34:12.789]                   }
[10:34:12.789]                   ...future.conditions[[length(...future.conditions) + 
[10:34:12.789]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:12.789]                     cond$call), session = sessionInformation(), 
[10:34:12.789]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:12.789]                   signalCondition(cond)
[10:34:12.789]                 }
[10:34:12.789]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:12.789]                 "immediateCondition"))) {
[10:34:12.789]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:12.789]                   ...future.conditions[[length(...future.conditions) + 
[10:34:12.789]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:12.789]                   if (TRUE && !signal) {
[10:34:12.789]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:12.789]                     {
[10:34:12.789]                       inherits <- base::inherits
[10:34:12.789]                       invokeRestart <- base::invokeRestart
[10:34:12.789]                       is.null <- base::is.null
[10:34:12.789]                       muffled <- FALSE
[10:34:12.789]                       if (inherits(cond, "message")) {
[10:34:12.789]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:12.789]                         if (muffled) 
[10:34:12.789]                           invokeRestart("muffleMessage")
[10:34:12.789]                       }
[10:34:12.789]                       else if (inherits(cond, "warning")) {
[10:34:12.789]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:12.789]                         if (muffled) 
[10:34:12.789]                           invokeRestart("muffleWarning")
[10:34:12.789]                       }
[10:34:12.789]                       else if (inherits(cond, "condition")) {
[10:34:12.789]                         if (!is.null(pattern)) {
[10:34:12.789]                           computeRestarts <- base::computeRestarts
[10:34:12.789]                           grepl <- base::grepl
[10:34:12.789]                           restarts <- computeRestarts(cond)
[10:34:12.789]                           for (restart in restarts) {
[10:34:12.789]                             name <- restart$name
[10:34:12.789]                             if (is.null(name)) 
[10:34:12.789]                               next
[10:34:12.789]                             if (!grepl(pattern, name)) 
[10:34:12.789]                               next
[10:34:12.789]                             invokeRestart(restart)
[10:34:12.789]                             muffled <- TRUE
[10:34:12.789]                             break
[10:34:12.789]                           }
[10:34:12.789]                         }
[10:34:12.789]                       }
[10:34:12.789]                       invisible(muffled)
[10:34:12.789]                     }
[10:34:12.789]                     muffleCondition(cond, pattern = "^muffle")
[10:34:12.789]                   }
[10:34:12.789]                 }
[10:34:12.789]                 else {
[10:34:12.789]                   if (TRUE) {
[10:34:12.789]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:12.789]                     {
[10:34:12.789]                       inherits <- base::inherits
[10:34:12.789]                       invokeRestart <- base::invokeRestart
[10:34:12.789]                       is.null <- base::is.null
[10:34:12.789]                       muffled <- FALSE
[10:34:12.789]                       if (inherits(cond, "message")) {
[10:34:12.789]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:12.789]                         if (muffled) 
[10:34:12.789]                           invokeRestart("muffleMessage")
[10:34:12.789]                       }
[10:34:12.789]                       else if (inherits(cond, "warning")) {
[10:34:12.789]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:12.789]                         if (muffled) 
[10:34:12.789]                           invokeRestart("muffleWarning")
[10:34:12.789]                       }
[10:34:12.789]                       else if (inherits(cond, "condition")) {
[10:34:12.789]                         if (!is.null(pattern)) {
[10:34:12.789]                           computeRestarts <- base::computeRestarts
[10:34:12.789]                           grepl <- base::grepl
[10:34:12.789]                           restarts <- computeRestarts(cond)
[10:34:12.789]                           for (restart in restarts) {
[10:34:12.789]                             name <- restart$name
[10:34:12.789]                             if (is.null(name)) 
[10:34:12.789]                               next
[10:34:12.789]                             if (!grepl(pattern, name)) 
[10:34:12.789]                               next
[10:34:12.789]                             invokeRestart(restart)
[10:34:12.789]                             muffled <- TRUE
[10:34:12.789]                             break
[10:34:12.789]                           }
[10:34:12.789]                         }
[10:34:12.789]                       }
[10:34:12.789]                       invisible(muffled)
[10:34:12.789]                     }
[10:34:12.789]                     muffleCondition(cond, pattern = "^muffle")
[10:34:12.789]                   }
[10:34:12.789]                 }
[10:34:12.789]             }
[10:34:12.789]         }))
[10:34:12.789]     }, error = function(ex) {
[10:34:12.789]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:12.789]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:12.789]                 ...future.rng), started = ...future.startTime, 
[10:34:12.789]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:12.789]             version = "1.8"), class = "FutureResult")
[10:34:12.789]     }, finally = {
[10:34:12.789]         if (!identical(...future.workdir, getwd())) 
[10:34:12.789]             setwd(...future.workdir)
[10:34:12.789]         {
[10:34:12.789]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:12.789]                 ...future.oldOptions$nwarnings <- NULL
[10:34:12.789]             }
[10:34:12.789]             base::options(...future.oldOptions)
[10:34:12.789]             if (.Platform$OS.type == "windows") {
[10:34:12.789]                 old_names <- names(...future.oldEnvVars)
[10:34:12.789]                 envs <- base::Sys.getenv()
[10:34:12.789]                 names <- names(envs)
[10:34:12.789]                 common <- intersect(names, old_names)
[10:34:12.789]                 added <- setdiff(names, old_names)
[10:34:12.789]                 removed <- setdiff(old_names, names)
[10:34:12.789]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:12.789]                   envs[common]]
[10:34:12.789]                 NAMES <- toupper(changed)
[10:34:12.789]                 args <- list()
[10:34:12.789]                 for (kk in seq_along(NAMES)) {
[10:34:12.789]                   name <- changed[[kk]]
[10:34:12.789]                   NAME <- NAMES[[kk]]
[10:34:12.789]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:12.789]                     next
[10:34:12.789]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:12.789]                 }
[10:34:12.789]                 NAMES <- toupper(added)
[10:34:12.789]                 for (kk in seq_along(NAMES)) {
[10:34:12.789]                   name <- added[[kk]]
[10:34:12.789]                   NAME <- NAMES[[kk]]
[10:34:12.789]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:12.789]                     next
[10:34:12.789]                   args[[name]] <- ""
[10:34:12.789]                 }
[10:34:12.789]                 NAMES <- toupper(removed)
[10:34:12.789]                 for (kk in seq_along(NAMES)) {
[10:34:12.789]                   name <- removed[[kk]]
[10:34:12.789]                   NAME <- NAMES[[kk]]
[10:34:12.789]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:12.789]                     next
[10:34:12.789]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:12.789]                 }
[10:34:12.789]                 if (length(args) > 0) 
[10:34:12.789]                   base::do.call(base::Sys.setenv, args = args)
[10:34:12.789]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:12.789]             }
[10:34:12.789]             else {
[10:34:12.789]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:12.789]             }
[10:34:12.789]             {
[10:34:12.789]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:12.789]                   0L) {
[10:34:12.789]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:12.789]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:12.789]                   base::options(opts)
[10:34:12.789]                 }
[10:34:12.789]                 {
[10:34:12.789]                   {
[10:34:12.789]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:12.789]                     NULL
[10:34:12.789]                   }
[10:34:12.789]                   options(future.plan = NULL)
[10:34:12.789]                   if (is.na(NA_character_)) 
[10:34:12.789]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:12.789]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:12.789]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:12.789]                     .init = FALSE)
[10:34:12.789]                 }
[10:34:12.789]             }
[10:34:12.789]         }
[10:34:12.789]     })
[10:34:12.789]     if (TRUE) {
[10:34:12.789]         base::sink(type = "output", split = FALSE)
[10:34:12.789]         if (TRUE) {
[10:34:12.789]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:12.789]         }
[10:34:12.789]         else {
[10:34:12.789]             ...future.result["stdout"] <- base::list(NULL)
[10:34:12.789]         }
[10:34:12.789]         base::close(...future.stdout)
[10:34:12.789]         ...future.stdout <- NULL
[10:34:12.789]     }
[10:34:12.789]     ...future.result$conditions <- ...future.conditions
[10:34:12.789]     ...future.result$finished <- base::Sys.time()
[10:34:12.789]     ...future.result
[10:34:12.789] }
[10:34:12.792] MultisessionFuture started
[10:34:12.792] - Launch lazy future ... done
[10:34:12.792] run() for ‘MultisessionFuture’ ... done
[10:34:13.294] receiveMessageFromWorker() for ClusterFuture ...
[10:34:13.294] - Validating connection of MultisessionFuture
[10:34:13.294] - received message: FutureResult
[10:34:13.295] - Received FutureResult
[10:34:13.295] - Erased future from FutureRegistry
[10:34:13.295] result() for ClusterFuture ...
[10:34:13.295] - result already collected: FutureResult
[10:34:13.295] result() for ClusterFuture ... done
[10:34:13.295] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:13.295] resolve() on list ...
[10:34:13.295]  recursive: 0
[10:34:13.295]  length: 2
[10:34:13.295]  elements: ‘a’, ‘b’
[10:34:13.296]  length: 1 (resolved future 1)
[10:34:13.296]  length: 0 (resolved future 2)
[10:34:13.296] resolve() on list ... DONE
[10:34:13.296] A MultisessionFuture was resolved (and resolved itself)
[10:34:13.296] getGlobalsAndPackages() ...
[10:34:13.296] Searching for globals...
[10:34:13.297] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:34:13.297] Searching for globals ... DONE
[10:34:13.298] Resolving globals: FALSE
[10:34:13.298] 
[10:34:13.298] 
[10:34:13.298] getGlobalsAndPackages() ... DONE
[10:34:13.298] run() for ‘Future’ ...
[10:34:13.298] - state: ‘created’
[10:34:13.299] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:13.313] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:13.313] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:13.313]   - Field: ‘node’
[10:34:13.313]   - Field: ‘label’
[10:34:13.313]   - Field: ‘local’
[10:34:13.313]   - Field: ‘owner’
[10:34:13.313]   - Field: ‘envir’
[10:34:13.313]   - Field: ‘workers’
[10:34:13.314]   - Field: ‘packages’
[10:34:13.314]   - Field: ‘gc’
[10:34:13.314]   - Field: ‘conditions’
[10:34:13.314]   - Field: ‘persistent’
[10:34:13.314]   - Field: ‘expr’
[10:34:13.314]   - Field: ‘uuid’
[10:34:13.314]   - Field: ‘seed’
[10:34:13.314]   - Field: ‘version’
[10:34:13.314]   - Field: ‘result’
[10:34:13.314]   - Field: ‘asynchronous’
[10:34:13.314]   - Field: ‘calls’
[10:34:13.315]   - Field: ‘globals’
[10:34:13.315]   - Field: ‘stdout’
[10:34:13.315]   - Field: ‘earlySignal’
[10:34:13.315]   - Field: ‘lazy’
[10:34:13.315]   - Field: ‘state’
[10:34:13.315] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:13.315] - Launch lazy future ...
[10:34:13.315] Packages needed by the future expression (n = 0): <none>
[10:34:13.316] Packages needed by future strategies (n = 0): <none>
[10:34:13.316] {
[10:34:13.316]     {
[10:34:13.316]         {
[10:34:13.316]             ...future.startTime <- base::Sys.time()
[10:34:13.316]             {
[10:34:13.316]                 {
[10:34:13.316]                   {
[10:34:13.316]                     {
[10:34:13.316]                       base::local({
[10:34:13.316]                         has_future <- base::requireNamespace("future", 
[10:34:13.316]                           quietly = TRUE)
[10:34:13.316]                         if (has_future) {
[10:34:13.316]                           ns <- base::getNamespace("future")
[10:34:13.316]                           version <- ns[[".package"]][["version"]]
[10:34:13.316]                           if (is.null(version)) 
[10:34:13.316]                             version <- utils::packageVersion("future")
[10:34:13.316]                         }
[10:34:13.316]                         else {
[10:34:13.316]                           version <- NULL
[10:34:13.316]                         }
[10:34:13.316]                         if (!has_future || version < "1.8.0") {
[10:34:13.316]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:13.316]                             "", base::R.version$version.string), 
[10:34:13.316]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:13.316]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:13.316]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:13.316]                               "release", "version")], collapse = " "), 
[10:34:13.316]                             hostname = base::Sys.info()[["nodename"]])
[10:34:13.316]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:13.316]                             info)
[10:34:13.316]                           info <- base::paste(info, collapse = "; ")
[10:34:13.316]                           if (!has_future) {
[10:34:13.316]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:13.316]                               info)
[10:34:13.316]                           }
[10:34:13.316]                           else {
[10:34:13.316]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:13.316]                               info, version)
[10:34:13.316]                           }
[10:34:13.316]                           base::stop(msg)
[10:34:13.316]                         }
[10:34:13.316]                       })
[10:34:13.316]                     }
[10:34:13.316]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:13.316]                     base::options(mc.cores = 1L)
[10:34:13.316]                   }
[10:34:13.316]                   ...future.strategy.old <- future::plan("list")
[10:34:13.316]                   options(future.plan = NULL)
[10:34:13.316]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:13.316]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:13.316]                 }
[10:34:13.316]                 ...future.workdir <- getwd()
[10:34:13.316]             }
[10:34:13.316]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:13.316]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:13.316]         }
[10:34:13.316]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:13.316]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:13.316]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:13.316]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:13.316]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:13.316]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:13.316]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:13.316]             base::names(...future.oldOptions))
[10:34:13.316]     }
[10:34:13.316]     if (FALSE) {
[10:34:13.316]     }
[10:34:13.316]     else {
[10:34:13.316]         if (TRUE) {
[10:34:13.316]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:13.316]                 open = "w")
[10:34:13.316]         }
[10:34:13.316]         else {
[10:34:13.316]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:13.316]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:13.316]         }
[10:34:13.316]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:13.316]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:13.316]             base::sink(type = "output", split = FALSE)
[10:34:13.316]             base::close(...future.stdout)
[10:34:13.316]         }, add = TRUE)
[10:34:13.316]     }
[10:34:13.316]     ...future.frame <- base::sys.nframe()
[10:34:13.316]     ...future.conditions <- base::list()
[10:34:13.316]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:13.316]     if (FALSE) {
[10:34:13.316]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:13.316]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:13.316]     }
[10:34:13.316]     ...future.result <- base::tryCatch({
[10:34:13.316]         base::withCallingHandlers({
[10:34:13.316]             ...future.value <- base::withVisible(base::local({
[10:34:13.316]                 ...future.makeSendCondition <- base::local({
[10:34:13.316]                   sendCondition <- NULL
[10:34:13.316]                   function(frame = 1L) {
[10:34:13.316]                     if (is.function(sendCondition)) 
[10:34:13.316]                       return(sendCondition)
[10:34:13.316]                     ns <- getNamespace("parallel")
[10:34:13.316]                     if (exists("sendData", mode = "function", 
[10:34:13.316]                       envir = ns)) {
[10:34:13.316]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:13.316]                         envir = ns)
[10:34:13.316]                       envir <- sys.frame(frame)
[10:34:13.316]                       master <- NULL
[10:34:13.316]                       while (!identical(envir, .GlobalEnv) && 
[10:34:13.316]                         !identical(envir, emptyenv())) {
[10:34:13.316]                         if (exists("master", mode = "list", envir = envir, 
[10:34:13.316]                           inherits = FALSE)) {
[10:34:13.316]                           master <- get("master", mode = "list", 
[10:34:13.316]                             envir = envir, inherits = FALSE)
[10:34:13.316]                           if (inherits(master, c("SOCKnode", 
[10:34:13.316]                             "SOCK0node"))) {
[10:34:13.316]                             sendCondition <<- function(cond) {
[10:34:13.316]                               data <- list(type = "VALUE", value = cond, 
[10:34:13.316]                                 success = TRUE)
[10:34:13.316]                               parallel_sendData(master, data)
[10:34:13.316]                             }
[10:34:13.316]                             return(sendCondition)
[10:34:13.316]                           }
[10:34:13.316]                         }
[10:34:13.316]                         frame <- frame + 1L
[10:34:13.316]                         envir <- sys.frame(frame)
[10:34:13.316]                       }
[10:34:13.316]                     }
[10:34:13.316]                     sendCondition <<- function(cond) NULL
[10:34:13.316]                   }
[10:34:13.316]                 })
[10:34:13.316]                 withCallingHandlers({
[10:34:13.316]                   {
[10:34:13.316]                     Sys.sleep(0.5)
[10:34:13.316]                     list(a = 1, b = 42L)
[10:34:13.316]                   }
[10:34:13.316]                 }, immediateCondition = function(cond) {
[10:34:13.316]                   sendCondition <- ...future.makeSendCondition()
[10:34:13.316]                   sendCondition(cond)
[10:34:13.316]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:13.316]                   {
[10:34:13.316]                     inherits <- base::inherits
[10:34:13.316]                     invokeRestart <- base::invokeRestart
[10:34:13.316]                     is.null <- base::is.null
[10:34:13.316]                     muffled <- FALSE
[10:34:13.316]                     if (inherits(cond, "message")) {
[10:34:13.316]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:13.316]                       if (muffled) 
[10:34:13.316]                         invokeRestart("muffleMessage")
[10:34:13.316]                     }
[10:34:13.316]                     else if (inherits(cond, "warning")) {
[10:34:13.316]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:13.316]                       if (muffled) 
[10:34:13.316]                         invokeRestart("muffleWarning")
[10:34:13.316]                     }
[10:34:13.316]                     else if (inherits(cond, "condition")) {
[10:34:13.316]                       if (!is.null(pattern)) {
[10:34:13.316]                         computeRestarts <- base::computeRestarts
[10:34:13.316]                         grepl <- base::grepl
[10:34:13.316]                         restarts <- computeRestarts(cond)
[10:34:13.316]                         for (restart in restarts) {
[10:34:13.316]                           name <- restart$name
[10:34:13.316]                           if (is.null(name)) 
[10:34:13.316]                             next
[10:34:13.316]                           if (!grepl(pattern, name)) 
[10:34:13.316]                             next
[10:34:13.316]                           invokeRestart(restart)
[10:34:13.316]                           muffled <- TRUE
[10:34:13.316]                           break
[10:34:13.316]                         }
[10:34:13.316]                       }
[10:34:13.316]                     }
[10:34:13.316]                     invisible(muffled)
[10:34:13.316]                   }
[10:34:13.316]                   muffleCondition(cond)
[10:34:13.316]                 })
[10:34:13.316]             }))
[10:34:13.316]             future::FutureResult(value = ...future.value$value, 
[10:34:13.316]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:13.316]                   ...future.rng), globalenv = if (FALSE) 
[10:34:13.316]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:13.316]                     ...future.globalenv.names))
[10:34:13.316]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:13.316]         }, condition = base::local({
[10:34:13.316]             c <- base::c
[10:34:13.316]             inherits <- base::inherits
[10:34:13.316]             invokeRestart <- base::invokeRestart
[10:34:13.316]             length <- base::length
[10:34:13.316]             list <- base::list
[10:34:13.316]             seq.int <- base::seq.int
[10:34:13.316]             signalCondition <- base::signalCondition
[10:34:13.316]             sys.calls <- base::sys.calls
[10:34:13.316]             `[[` <- base::`[[`
[10:34:13.316]             `+` <- base::`+`
[10:34:13.316]             `<<-` <- base::`<<-`
[10:34:13.316]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:13.316]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:13.316]                   3L)]
[10:34:13.316]             }
[10:34:13.316]             function(cond) {
[10:34:13.316]                 is_error <- inherits(cond, "error")
[10:34:13.316]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:13.316]                   NULL)
[10:34:13.316]                 if (is_error) {
[10:34:13.316]                   sessionInformation <- function() {
[10:34:13.316]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:13.316]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:13.316]                       search = base::search(), system = base::Sys.info())
[10:34:13.316]                   }
[10:34:13.316]                   ...future.conditions[[length(...future.conditions) + 
[10:34:13.316]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:13.316]                     cond$call), session = sessionInformation(), 
[10:34:13.316]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:13.316]                   signalCondition(cond)
[10:34:13.316]                 }
[10:34:13.316]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:13.316]                 "immediateCondition"))) {
[10:34:13.316]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:13.316]                   ...future.conditions[[length(...future.conditions) + 
[10:34:13.316]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:13.316]                   if (TRUE && !signal) {
[10:34:13.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:13.316]                     {
[10:34:13.316]                       inherits <- base::inherits
[10:34:13.316]                       invokeRestart <- base::invokeRestart
[10:34:13.316]                       is.null <- base::is.null
[10:34:13.316]                       muffled <- FALSE
[10:34:13.316]                       if (inherits(cond, "message")) {
[10:34:13.316]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:13.316]                         if (muffled) 
[10:34:13.316]                           invokeRestart("muffleMessage")
[10:34:13.316]                       }
[10:34:13.316]                       else if (inherits(cond, "warning")) {
[10:34:13.316]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:13.316]                         if (muffled) 
[10:34:13.316]                           invokeRestart("muffleWarning")
[10:34:13.316]                       }
[10:34:13.316]                       else if (inherits(cond, "condition")) {
[10:34:13.316]                         if (!is.null(pattern)) {
[10:34:13.316]                           computeRestarts <- base::computeRestarts
[10:34:13.316]                           grepl <- base::grepl
[10:34:13.316]                           restarts <- computeRestarts(cond)
[10:34:13.316]                           for (restart in restarts) {
[10:34:13.316]                             name <- restart$name
[10:34:13.316]                             if (is.null(name)) 
[10:34:13.316]                               next
[10:34:13.316]                             if (!grepl(pattern, name)) 
[10:34:13.316]                               next
[10:34:13.316]                             invokeRestart(restart)
[10:34:13.316]                             muffled <- TRUE
[10:34:13.316]                             break
[10:34:13.316]                           }
[10:34:13.316]                         }
[10:34:13.316]                       }
[10:34:13.316]                       invisible(muffled)
[10:34:13.316]                     }
[10:34:13.316]                     muffleCondition(cond, pattern = "^muffle")
[10:34:13.316]                   }
[10:34:13.316]                 }
[10:34:13.316]                 else {
[10:34:13.316]                   if (TRUE) {
[10:34:13.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:13.316]                     {
[10:34:13.316]                       inherits <- base::inherits
[10:34:13.316]                       invokeRestart <- base::invokeRestart
[10:34:13.316]                       is.null <- base::is.null
[10:34:13.316]                       muffled <- FALSE
[10:34:13.316]                       if (inherits(cond, "message")) {
[10:34:13.316]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:13.316]                         if (muffled) 
[10:34:13.316]                           invokeRestart("muffleMessage")
[10:34:13.316]                       }
[10:34:13.316]                       else if (inherits(cond, "warning")) {
[10:34:13.316]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:13.316]                         if (muffled) 
[10:34:13.316]                           invokeRestart("muffleWarning")
[10:34:13.316]                       }
[10:34:13.316]                       else if (inherits(cond, "condition")) {
[10:34:13.316]                         if (!is.null(pattern)) {
[10:34:13.316]                           computeRestarts <- base::computeRestarts
[10:34:13.316]                           grepl <- base::grepl
[10:34:13.316]                           restarts <- computeRestarts(cond)
[10:34:13.316]                           for (restart in restarts) {
[10:34:13.316]                             name <- restart$name
[10:34:13.316]                             if (is.null(name)) 
[10:34:13.316]                               next
[10:34:13.316]                             if (!grepl(pattern, name)) 
[10:34:13.316]                               next
[10:34:13.316]                             invokeRestart(restart)
[10:34:13.316]                             muffled <- TRUE
[10:34:13.316]                             break
[10:34:13.316]                           }
[10:34:13.316]                         }
[10:34:13.316]                       }
[10:34:13.316]                       invisible(muffled)
[10:34:13.316]                     }
[10:34:13.316]                     muffleCondition(cond, pattern = "^muffle")
[10:34:13.316]                   }
[10:34:13.316]                 }
[10:34:13.316]             }
[10:34:13.316]         }))
[10:34:13.316]     }, error = function(ex) {
[10:34:13.316]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:13.316]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:13.316]                 ...future.rng), started = ...future.startTime, 
[10:34:13.316]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:13.316]             version = "1.8"), class = "FutureResult")
[10:34:13.316]     }, finally = {
[10:34:13.316]         if (!identical(...future.workdir, getwd())) 
[10:34:13.316]             setwd(...future.workdir)
[10:34:13.316]         {
[10:34:13.316]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:13.316]                 ...future.oldOptions$nwarnings <- NULL
[10:34:13.316]             }
[10:34:13.316]             base::options(...future.oldOptions)
[10:34:13.316]             if (.Platform$OS.type == "windows") {
[10:34:13.316]                 old_names <- names(...future.oldEnvVars)
[10:34:13.316]                 envs <- base::Sys.getenv()
[10:34:13.316]                 names <- names(envs)
[10:34:13.316]                 common <- intersect(names, old_names)
[10:34:13.316]                 added <- setdiff(names, old_names)
[10:34:13.316]                 removed <- setdiff(old_names, names)
[10:34:13.316]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:13.316]                   envs[common]]
[10:34:13.316]                 NAMES <- toupper(changed)
[10:34:13.316]                 args <- list()
[10:34:13.316]                 for (kk in seq_along(NAMES)) {
[10:34:13.316]                   name <- changed[[kk]]
[10:34:13.316]                   NAME <- NAMES[[kk]]
[10:34:13.316]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:13.316]                     next
[10:34:13.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:13.316]                 }
[10:34:13.316]                 NAMES <- toupper(added)
[10:34:13.316]                 for (kk in seq_along(NAMES)) {
[10:34:13.316]                   name <- added[[kk]]
[10:34:13.316]                   NAME <- NAMES[[kk]]
[10:34:13.316]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:13.316]                     next
[10:34:13.316]                   args[[name]] <- ""
[10:34:13.316]                 }
[10:34:13.316]                 NAMES <- toupper(removed)
[10:34:13.316]                 for (kk in seq_along(NAMES)) {
[10:34:13.316]                   name <- removed[[kk]]
[10:34:13.316]                   NAME <- NAMES[[kk]]
[10:34:13.316]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:13.316]                     next
[10:34:13.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:13.316]                 }
[10:34:13.316]                 if (length(args) > 0) 
[10:34:13.316]                   base::do.call(base::Sys.setenv, args = args)
[10:34:13.316]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:13.316]             }
[10:34:13.316]             else {
[10:34:13.316]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:13.316]             }
[10:34:13.316]             {
[10:34:13.316]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:13.316]                   0L) {
[10:34:13.316]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:13.316]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:13.316]                   base::options(opts)
[10:34:13.316]                 }
[10:34:13.316]                 {
[10:34:13.316]                   {
[10:34:13.316]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:13.316]                     NULL
[10:34:13.316]                   }
[10:34:13.316]                   options(future.plan = NULL)
[10:34:13.316]                   if (is.na(NA_character_)) 
[10:34:13.316]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:13.316]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:13.316]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:13.316]                     .init = FALSE)
[10:34:13.316]                 }
[10:34:13.316]             }
[10:34:13.316]         }
[10:34:13.316]     })
[10:34:13.316]     if (TRUE) {
[10:34:13.316]         base::sink(type = "output", split = FALSE)
[10:34:13.316]         if (TRUE) {
[10:34:13.316]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:13.316]         }
[10:34:13.316]         else {
[10:34:13.316]             ...future.result["stdout"] <- base::list(NULL)
[10:34:13.316]         }
[10:34:13.316]         base::close(...future.stdout)
[10:34:13.316]         ...future.stdout <- NULL
[10:34:13.316]     }
[10:34:13.316]     ...future.result$conditions <- ...future.conditions
[10:34:13.316]     ...future.result$finished <- base::Sys.time()
[10:34:13.316]     ...future.result
[10:34:13.316] }
[10:34:13.319] MultisessionFuture started
[10:34:13.319] - Launch lazy future ... done
[10:34:13.319] run() for ‘MultisessionFuture’ ... done
[10:34:13.821] receiveMessageFromWorker() for ClusterFuture ...
[10:34:13.822] - Validating connection of MultisessionFuture
[10:34:13.822] - received message: FutureResult
[10:34:13.822] - Received FutureResult
[10:34:13.822] - Erased future from FutureRegistry
[10:34:13.822] result() for ClusterFuture ...
[10:34:13.822] - result already collected: FutureResult
[10:34:13.823] result() for ClusterFuture ... done
[10:34:13.823] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:13.823] resolve() on list ...
[10:34:13.823]  recursive: 0
[10:34:13.823]  length: 2
[10:34:13.823]  elements: ‘a’, ‘b’
[10:34:13.823]  length: 1 (resolved future 1)
[10:34:13.823]  length: 0 (resolved future 2)
[10:34:13.823] resolve() on list ... DONE
[10:34:13.823] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[10:34:13.824] getGlobalsAndPackages() ...
[10:34:13.826] Searching for globals...
[10:34:13.827] - globals found: [2] ‘list’, ‘stop’
[10:34:13.827] Searching for globals ... DONE
[10:34:13.827] Resolving globals: FALSE
[10:34:13.828] 
[10:34:13.828] 
[10:34:13.828] getGlobalsAndPackages() ... DONE
[10:34:13.828] run() for ‘Future’ ...
[10:34:13.828] - state: ‘created’
[10:34:13.828] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:13.842] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:13.842] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:13.843]   - Field: ‘node’
[10:34:13.843]   - Field: ‘label’
[10:34:13.843]   - Field: ‘local’
[10:34:13.843]   - Field: ‘owner’
[10:34:13.843]   - Field: ‘envir’
[10:34:13.843]   - Field: ‘workers’
[10:34:13.843]   - Field: ‘packages’
[10:34:13.843]   - Field: ‘gc’
[10:34:13.843]   - Field: ‘conditions’
[10:34:13.843]   - Field: ‘persistent’
[10:34:13.843]   - Field: ‘expr’
[10:34:13.844]   - Field: ‘uuid’
[10:34:13.844]   - Field: ‘seed’
[10:34:13.844]   - Field: ‘version’
[10:34:13.844]   - Field: ‘result’
[10:34:13.844]   - Field: ‘asynchronous’
[10:34:13.844]   - Field: ‘calls’
[10:34:13.844]   - Field: ‘globals’
[10:34:13.844]   - Field: ‘stdout’
[10:34:13.844]   - Field: ‘earlySignal’
[10:34:13.844]   - Field: ‘lazy’
[10:34:13.844]   - Field: ‘state’
[10:34:13.844] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:13.845] - Launch lazy future ...
[10:34:13.845] Packages needed by the future expression (n = 0): <none>
[10:34:13.845] Packages needed by future strategies (n = 0): <none>
[10:34:13.845] {
[10:34:13.845]     {
[10:34:13.845]         {
[10:34:13.845]             ...future.startTime <- base::Sys.time()
[10:34:13.845]             {
[10:34:13.845]                 {
[10:34:13.845]                   {
[10:34:13.845]                     {
[10:34:13.845]                       base::local({
[10:34:13.845]                         has_future <- base::requireNamespace("future", 
[10:34:13.845]                           quietly = TRUE)
[10:34:13.845]                         if (has_future) {
[10:34:13.845]                           ns <- base::getNamespace("future")
[10:34:13.845]                           version <- ns[[".package"]][["version"]]
[10:34:13.845]                           if (is.null(version)) 
[10:34:13.845]                             version <- utils::packageVersion("future")
[10:34:13.845]                         }
[10:34:13.845]                         else {
[10:34:13.845]                           version <- NULL
[10:34:13.845]                         }
[10:34:13.845]                         if (!has_future || version < "1.8.0") {
[10:34:13.845]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:13.845]                             "", base::R.version$version.string), 
[10:34:13.845]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:13.845]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:13.845]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:13.845]                               "release", "version")], collapse = " "), 
[10:34:13.845]                             hostname = base::Sys.info()[["nodename"]])
[10:34:13.845]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:13.845]                             info)
[10:34:13.845]                           info <- base::paste(info, collapse = "; ")
[10:34:13.845]                           if (!has_future) {
[10:34:13.845]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:13.845]                               info)
[10:34:13.845]                           }
[10:34:13.845]                           else {
[10:34:13.845]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:13.845]                               info, version)
[10:34:13.845]                           }
[10:34:13.845]                           base::stop(msg)
[10:34:13.845]                         }
[10:34:13.845]                       })
[10:34:13.845]                     }
[10:34:13.845]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:13.845]                     base::options(mc.cores = 1L)
[10:34:13.845]                   }
[10:34:13.845]                   ...future.strategy.old <- future::plan("list")
[10:34:13.845]                   options(future.plan = NULL)
[10:34:13.845]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:13.845]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:13.845]                 }
[10:34:13.845]                 ...future.workdir <- getwd()
[10:34:13.845]             }
[10:34:13.845]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:13.845]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:13.845]         }
[10:34:13.845]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:13.845]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:13.845]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:13.845]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:13.845]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:13.845]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:13.845]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:13.845]             base::names(...future.oldOptions))
[10:34:13.845]     }
[10:34:13.845]     if (FALSE) {
[10:34:13.845]     }
[10:34:13.845]     else {
[10:34:13.845]         if (TRUE) {
[10:34:13.845]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:13.845]                 open = "w")
[10:34:13.845]         }
[10:34:13.845]         else {
[10:34:13.845]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:13.845]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:13.845]         }
[10:34:13.845]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:13.845]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:13.845]             base::sink(type = "output", split = FALSE)
[10:34:13.845]             base::close(...future.stdout)
[10:34:13.845]         }, add = TRUE)
[10:34:13.845]     }
[10:34:13.845]     ...future.frame <- base::sys.nframe()
[10:34:13.845]     ...future.conditions <- base::list()
[10:34:13.845]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:13.845]     if (FALSE) {
[10:34:13.845]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:13.845]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:13.845]     }
[10:34:13.845]     ...future.result <- base::tryCatch({
[10:34:13.845]         base::withCallingHandlers({
[10:34:13.845]             ...future.value <- base::withVisible(base::local({
[10:34:13.845]                 ...future.makeSendCondition <- base::local({
[10:34:13.845]                   sendCondition <- NULL
[10:34:13.845]                   function(frame = 1L) {
[10:34:13.845]                     if (is.function(sendCondition)) 
[10:34:13.845]                       return(sendCondition)
[10:34:13.845]                     ns <- getNamespace("parallel")
[10:34:13.845]                     if (exists("sendData", mode = "function", 
[10:34:13.845]                       envir = ns)) {
[10:34:13.845]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:13.845]                         envir = ns)
[10:34:13.845]                       envir <- sys.frame(frame)
[10:34:13.845]                       master <- NULL
[10:34:13.845]                       while (!identical(envir, .GlobalEnv) && 
[10:34:13.845]                         !identical(envir, emptyenv())) {
[10:34:13.845]                         if (exists("master", mode = "list", envir = envir, 
[10:34:13.845]                           inherits = FALSE)) {
[10:34:13.845]                           master <- get("master", mode = "list", 
[10:34:13.845]                             envir = envir, inherits = FALSE)
[10:34:13.845]                           if (inherits(master, c("SOCKnode", 
[10:34:13.845]                             "SOCK0node"))) {
[10:34:13.845]                             sendCondition <<- function(cond) {
[10:34:13.845]                               data <- list(type = "VALUE", value = cond, 
[10:34:13.845]                                 success = TRUE)
[10:34:13.845]                               parallel_sendData(master, data)
[10:34:13.845]                             }
[10:34:13.845]                             return(sendCondition)
[10:34:13.845]                           }
[10:34:13.845]                         }
[10:34:13.845]                         frame <- frame + 1L
[10:34:13.845]                         envir <- sys.frame(frame)
[10:34:13.845]                       }
[10:34:13.845]                     }
[10:34:13.845]                     sendCondition <<- function(cond) NULL
[10:34:13.845]                   }
[10:34:13.845]                 })
[10:34:13.845]                 withCallingHandlers({
[10:34:13.845]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:34:13.845]                 }, immediateCondition = function(cond) {
[10:34:13.845]                   sendCondition <- ...future.makeSendCondition()
[10:34:13.845]                   sendCondition(cond)
[10:34:13.845]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:13.845]                   {
[10:34:13.845]                     inherits <- base::inherits
[10:34:13.845]                     invokeRestart <- base::invokeRestart
[10:34:13.845]                     is.null <- base::is.null
[10:34:13.845]                     muffled <- FALSE
[10:34:13.845]                     if (inherits(cond, "message")) {
[10:34:13.845]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:13.845]                       if (muffled) 
[10:34:13.845]                         invokeRestart("muffleMessage")
[10:34:13.845]                     }
[10:34:13.845]                     else if (inherits(cond, "warning")) {
[10:34:13.845]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:13.845]                       if (muffled) 
[10:34:13.845]                         invokeRestart("muffleWarning")
[10:34:13.845]                     }
[10:34:13.845]                     else if (inherits(cond, "condition")) {
[10:34:13.845]                       if (!is.null(pattern)) {
[10:34:13.845]                         computeRestarts <- base::computeRestarts
[10:34:13.845]                         grepl <- base::grepl
[10:34:13.845]                         restarts <- computeRestarts(cond)
[10:34:13.845]                         for (restart in restarts) {
[10:34:13.845]                           name <- restart$name
[10:34:13.845]                           if (is.null(name)) 
[10:34:13.845]                             next
[10:34:13.845]                           if (!grepl(pattern, name)) 
[10:34:13.845]                             next
[10:34:13.845]                           invokeRestart(restart)
[10:34:13.845]                           muffled <- TRUE
[10:34:13.845]                           break
[10:34:13.845]                         }
[10:34:13.845]                       }
[10:34:13.845]                     }
[10:34:13.845]                     invisible(muffled)
[10:34:13.845]                   }
[10:34:13.845]                   muffleCondition(cond)
[10:34:13.845]                 })
[10:34:13.845]             }))
[10:34:13.845]             future::FutureResult(value = ...future.value$value, 
[10:34:13.845]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:13.845]                   ...future.rng), globalenv = if (FALSE) 
[10:34:13.845]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:13.845]                     ...future.globalenv.names))
[10:34:13.845]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:13.845]         }, condition = base::local({
[10:34:13.845]             c <- base::c
[10:34:13.845]             inherits <- base::inherits
[10:34:13.845]             invokeRestart <- base::invokeRestart
[10:34:13.845]             length <- base::length
[10:34:13.845]             list <- base::list
[10:34:13.845]             seq.int <- base::seq.int
[10:34:13.845]             signalCondition <- base::signalCondition
[10:34:13.845]             sys.calls <- base::sys.calls
[10:34:13.845]             `[[` <- base::`[[`
[10:34:13.845]             `+` <- base::`+`
[10:34:13.845]             `<<-` <- base::`<<-`
[10:34:13.845]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:13.845]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:13.845]                   3L)]
[10:34:13.845]             }
[10:34:13.845]             function(cond) {
[10:34:13.845]                 is_error <- inherits(cond, "error")
[10:34:13.845]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:13.845]                   NULL)
[10:34:13.845]                 if (is_error) {
[10:34:13.845]                   sessionInformation <- function() {
[10:34:13.845]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:13.845]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:13.845]                       search = base::search(), system = base::Sys.info())
[10:34:13.845]                   }
[10:34:13.845]                   ...future.conditions[[length(...future.conditions) + 
[10:34:13.845]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:13.845]                     cond$call), session = sessionInformation(), 
[10:34:13.845]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:13.845]                   signalCondition(cond)
[10:34:13.845]                 }
[10:34:13.845]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:13.845]                 "immediateCondition"))) {
[10:34:13.845]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:13.845]                   ...future.conditions[[length(...future.conditions) + 
[10:34:13.845]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:13.845]                   if (TRUE && !signal) {
[10:34:13.845]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:13.845]                     {
[10:34:13.845]                       inherits <- base::inherits
[10:34:13.845]                       invokeRestart <- base::invokeRestart
[10:34:13.845]                       is.null <- base::is.null
[10:34:13.845]                       muffled <- FALSE
[10:34:13.845]                       if (inherits(cond, "message")) {
[10:34:13.845]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:13.845]                         if (muffled) 
[10:34:13.845]                           invokeRestart("muffleMessage")
[10:34:13.845]                       }
[10:34:13.845]                       else if (inherits(cond, "warning")) {
[10:34:13.845]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:13.845]                         if (muffled) 
[10:34:13.845]                           invokeRestart("muffleWarning")
[10:34:13.845]                       }
[10:34:13.845]                       else if (inherits(cond, "condition")) {
[10:34:13.845]                         if (!is.null(pattern)) {
[10:34:13.845]                           computeRestarts <- base::computeRestarts
[10:34:13.845]                           grepl <- base::grepl
[10:34:13.845]                           restarts <- computeRestarts(cond)
[10:34:13.845]                           for (restart in restarts) {
[10:34:13.845]                             name <- restart$name
[10:34:13.845]                             if (is.null(name)) 
[10:34:13.845]                               next
[10:34:13.845]                             if (!grepl(pattern, name)) 
[10:34:13.845]                               next
[10:34:13.845]                             invokeRestart(restart)
[10:34:13.845]                             muffled <- TRUE
[10:34:13.845]                             break
[10:34:13.845]                           }
[10:34:13.845]                         }
[10:34:13.845]                       }
[10:34:13.845]                       invisible(muffled)
[10:34:13.845]                     }
[10:34:13.845]                     muffleCondition(cond, pattern = "^muffle")
[10:34:13.845]                   }
[10:34:13.845]                 }
[10:34:13.845]                 else {
[10:34:13.845]                   if (TRUE) {
[10:34:13.845]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:13.845]                     {
[10:34:13.845]                       inherits <- base::inherits
[10:34:13.845]                       invokeRestart <- base::invokeRestart
[10:34:13.845]                       is.null <- base::is.null
[10:34:13.845]                       muffled <- FALSE
[10:34:13.845]                       if (inherits(cond, "message")) {
[10:34:13.845]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:13.845]                         if (muffled) 
[10:34:13.845]                           invokeRestart("muffleMessage")
[10:34:13.845]                       }
[10:34:13.845]                       else if (inherits(cond, "warning")) {
[10:34:13.845]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:13.845]                         if (muffled) 
[10:34:13.845]                           invokeRestart("muffleWarning")
[10:34:13.845]                       }
[10:34:13.845]                       else if (inherits(cond, "condition")) {
[10:34:13.845]                         if (!is.null(pattern)) {
[10:34:13.845]                           computeRestarts <- base::computeRestarts
[10:34:13.845]                           grepl <- base::grepl
[10:34:13.845]                           restarts <- computeRestarts(cond)
[10:34:13.845]                           for (restart in restarts) {
[10:34:13.845]                             name <- restart$name
[10:34:13.845]                             if (is.null(name)) 
[10:34:13.845]                               next
[10:34:13.845]                             if (!grepl(pattern, name)) 
[10:34:13.845]                               next
[10:34:13.845]                             invokeRestart(restart)
[10:34:13.845]                             muffled <- TRUE
[10:34:13.845]                             break
[10:34:13.845]                           }
[10:34:13.845]                         }
[10:34:13.845]                       }
[10:34:13.845]                       invisible(muffled)
[10:34:13.845]                     }
[10:34:13.845]                     muffleCondition(cond, pattern = "^muffle")
[10:34:13.845]                   }
[10:34:13.845]                 }
[10:34:13.845]             }
[10:34:13.845]         }))
[10:34:13.845]     }, error = function(ex) {
[10:34:13.845]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:13.845]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:13.845]                 ...future.rng), started = ...future.startTime, 
[10:34:13.845]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:13.845]             version = "1.8"), class = "FutureResult")
[10:34:13.845]     }, finally = {
[10:34:13.845]         if (!identical(...future.workdir, getwd())) 
[10:34:13.845]             setwd(...future.workdir)
[10:34:13.845]         {
[10:34:13.845]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:13.845]                 ...future.oldOptions$nwarnings <- NULL
[10:34:13.845]             }
[10:34:13.845]             base::options(...future.oldOptions)
[10:34:13.845]             if (.Platform$OS.type == "windows") {
[10:34:13.845]                 old_names <- names(...future.oldEnvVars)
[10:34:13.845]                 envs <- base::Sys.getenv()
[10:34:13.845]                 names <- names(envs)
[10:34:13.845]                 common <- intersect(names, old_names)
[10:34:13.845]                 added <- setdiff(names, old_names)
[10:34:13.845]                 removed <- setdiff(old_names, names)
[10:34:13.845]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:13.845]                   envs[common]]
[10:34:13.845]                 NAMES <- toupper(changed)
[10:34:13.845]                 args <- list()
[10:34:13.845]                 for (kk in seq_along(NAMES)) {
[10:34:13.845]                   name <- changed[[kk]]
[10:34:13.845]                   NAME <- NAMES[[kk]]
[10:34:13.845]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:13.845]                     next
[10:34:13.845]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:13.845]                 }
[10:34:13.845]                 NAMES <- toupper(added)
[10:34:13.845]                 for (kk in seq_along(NAMES)) {
[10:34:13.845]                   name <- added[[kk]]
[10:34:13.845]                   NAME <- NAMES[[kk]]
[10:34:13.845]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:13.845]                     next
[10:34:13.845]                   args[[name]] <- ""
[10:34:13.845]                 }
[10:34:13.845]                 NAMES <- toupper(removed)
[10:34:13.845]                 for (kk in seq_along(NAMES)) {
[10:34:13.845]                   name <- removed[[kk]]
[10:34:13.845]                   NAME <- NAMES[[kk]]
[10:34:13.845]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:13.845]                     next
[10:34:13.845]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:13.845]                 }
[10:34:13.845]                 if (length(args) > 0) 
[10:34:13.845]                   base::do.call(base::Sys.setenv, args = args)
[10:34:13.845]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:13.845]             }
[10:34:13.845]             else {
[10:34:13.845]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:13.845]             }
[10:34:13.845]             {
[10:34:13.845]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:13.845]                   0L) {
[10:34:13.845]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:13.845]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:13.845]                   base::options(opts)
[10:34:13.845]                 }
[10:34:13.845]                 {
[10:34:13.845]                   {
[10:34:13.845]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:13.845]                     NULL
[10:34:13.845]                   }
[10:34:13.845]                   options(future.plan = NULL)
[10:34:13.845]                   if (is.na(NA_character_)) 
[10:34:13.845]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:13.845]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:13.845]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:13.845]                     .init = FALSE)
[10:34:13.845]                 }
[10:34:13.845]             }
[10:34:13.845]         }
[10:34:13.845]     })
[10:34:13.845]     if (TRUE) {
[10:34:13.845]         base::sink(type = "output", split = FALSE)
[10:34:13.845]         if (TRUE) {
[10:34:13.845]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:13.845]         }
[10:34:13.845]         else {
[10:34:13.845]             ...future.result["stdout"] <- base::list(NULL)
[10:34:13.845]         }
[10:34:13.845]         base::close(...future.stdout)
[10:34:13.845]         ...future.stdout <- NULL
[10:34:13.845]     }
[10:34:13.845]     ...future.result$conditions <- ...future.conditions
[10:34:13.845]     ...future.result$finished <- base::Sys.time()
[10:34:13.845]     ...future.result
[10:34:13.845] }
[10:34:13.848] MultisessionFuture started
[10:34:13.849] - Launch lazy future ... done
[10:34:13.849] run() for ‘MultisessionFuture’ ... done
[10:34:13.851] receiveMessageFromWorker() for ClusterFuture ...
[10:34:13.851] - Validating connection of MultisessionFuture
[10:34:13.851] - received message: FutureResult
[10:34:13.851] - Received FutureResult
[10:34:13.852] - Erased future from FutureRegistry
[10:34:13.852] result() for ClusterFuture ...
[10:34:13.852] - result already collected: FutureResult
[10:34:13.852] result() for ClusterFuture ... done
[10:34:13.852] signalConditions() ...
[10:34:13.852]  - include = ‘immediateCondition’
[10:34:13.852]  - exclude = 
[10:34:13.852]  - resignal = FALSE
[10:34:13.852]  - Number of conditions: 1
[10:34:13.852] signalConditions() ... done
[10:34:13.852] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:13.852] A MultisessionFuture was resolved
[10:34:13.853] getGlobalsAndPackages() ...
[10:34:13.853] Searching for globals...
[10:34:13.853] - globals found: [2] ‘list’, ‘stop’
[10:34:13.853] Searching for globals ... DONE
[10:34:13.854] Resolving globals: FALSE
[10:34:13.854] 
[10:34:13.854] 
[10:34:13.854] getGlobalsAndPackages() ... DONE
[10:34:13.854] run() for ‘Future’ ...
[10:34:13.854] - state: ‘created’
[10:34:13.854] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:13.868] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:13.868] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:13.869]   - Field: ‘node’
[10:34:13.869]   - Field: ‘label’
[10:34:13.869]   - Field: ‘local’
[10:34:13.869]   - Field: ‘owner’
[10:34:13.869]   - Field: ‘envir’
[10:34:13.869]   - Field: ‘workers’
[10:34:13.869]   - Field: ‘packages’
[10:34:13.869]   - Field: ‘gc’
[10:34:13.869]   - Field: ‘conditions’
[10:34:13.869]   - Field: ‘persistent’
[10:34:13.869]   - Field: ‘expr’
[10:34:13.870]   - Field: ‘uuid’
[10:34:13.870]   - Field: ‘seed’
[10:34:13.870]   - Field: ‘version’
[10:34:13.870]   - Field: ‘result’
[10:34:13.870]   - Field: ‘asynchronous’
[10:34:13.870]   - Field: ‘calls’
[10:34:13.870]   - Field: ‘globals’
[10:34:13.870]   - Field: ‘stdout’
[10:34:13.870]   - Field: ‘earlySignal’
[10:34:13.870]   - Field: ‘lazy’
[10:34:13.870]   - Field: ‘state’
[10:34:13.871] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:13.871] - Launch lazy future ...
[10:34:13.871] Packages needed by the future expression (n = 0): <none>
[10:34:13.871] Packages needed by future strategies (n = 0): <none>
[10:34:13.871] {
[10:34:13.871]     {
[10:34:13.871]         {
[10:34:13.871]             ...future.startTime <- base::Sys.time()
[10:34:13.871]             {
[10:34:13.871]                 {
[10:34:13.871]                   {
[10:34:13.871]                     {
[10:34:13.871]                       base::local({
[10:34:13.871]                         has_future <- base::requireNamespace("future", 
[10:34:13.871]                           quietly = TRUE)
[10:34:13.871]                         if (has_future) {
[10:34:13.871]                           ns <- base::getNamespace("future")
[10:34:13.871]                           version <- ns[[".package"]][["version"]]
[10:34:13.871]                           if (is.null(version)) 
[10:34:13.871]                             version <- utils::packageVersion("future")
[10:34:13.871]                         }
[10:34:13.871]                         else {
[10:34:13.871]                           version <- NULL
[10:34:13.871]                         }
[10:34:13.871]                         if (!has_future || version < "1.8.0") {
[10:34:13.871]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:13.871]                             "", base::R.version$version.string), 
[10:34:13.871]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:13.871]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:13.871]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:13.871]                               "release", "version")], collapse = " "), 
[10:34:13.871]                             hostname = base::Sys.info()[["nodename"]])
[10:34:13.871]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:13.871]                             info)
[10:34:13.871]                           info <- base::paste(info, collapse = "; ")
[10:34:13.871]                           if (!has_future) {
[10:34:13.871]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:13.871]                               info)
[10:34:13.871]                           }
[10:34:13.871]                           else {
[10:34:13.871]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:13.871]                               info, version)
[10:34:13.871]                           }
[10:34:13.871]                           base::stop(msg)
[10:34:13.871]                         }
[10:34:13.871]                       })
[10:34:13.871]                     }
[10:34:13.871]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:13.871]                     base::options(mc.cores = 1L)
[10:34:13.871]                   }
[10:34:13.871]                   ...future.strategy.old <- future::plan("list")
[10:34:13.871]                   options(future.plan = NULL)
[10:34:13.871]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:13.871]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:13.871]                 }
[10:34:13.871]                 ...future.workdir <- getwd()
[10:34:13.871]             }
[10:34:13.871]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:13.871]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:13.871]         }
[10:34:13.871]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:13.871]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:13.871]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:13.871]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:13.871]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:13.871]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:13.871]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:13.871]             base::names(...future.oldOptions))
[10:34:13.871]     }
[10:34:13.871]     if (FALSE) {
[10:34:13.871]     }
[10:34:13.871]     else {
[10:34:13.871]         if (TRUE) {
[10:34:13.871]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:13.871]                 open = "w")
[10:34:13.871]         }
[10:34:13.871]         else {
[10:34:13.871]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:13.871]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:13.871]         }
[10:34:13.871]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:13.871]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:13.871]             base::sink(type = "output", split = FALSE)
[10:34:13.871]             base::close(...future.stdout)
[10:34:13.871]         }, add = TRUE)
[10:34:13.871]     }
[10:34:13.871]     ...future.frame <- base::sys.nframe()
[10:34:13.871]     ...future.conditions <- base::list()
[10:34:13.871]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:13.871]     if (FALSE) {
[10:34:13.871]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:13.871]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:13.871]     }
[10:34:13.871]     ...future.result <- base::tryCatch({
[10:34:13.871]         base::withCallingHandlers({
[10:34:13.871]             ...future.value <- base::withVisible(base::local({
[10:34:13.871]                 ...future.makeSendCondition <- base::local({
[10:34:13.871]                   sendCondition <- NULL
[10:34:13.871]                   function(frame = 1L) {
[10:34:13.871]                     if (is.function(sendCondition)) 
[10:34:13.871]                       return(sendCondition)
[10:34:13.871]                     ns <- getNamespace("parallel")
[10:34:13.871]                     if (exists("sendData", mode = "function", 
[10:34:13.871]                       envir = ns)) {
[10:34:13.871]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:13.871]                         envir = ns)
[10:34:13.871]                       envir <- sys.frame(frame)
[10:34:13.871]                       master <- NULL
[10:34:13.871]                       while (!identical(envir, .GlobalEnv) && 
[10:34:13.871]                         !identical(envir, emptyenv())) {
[10:34:13.871]                         if (exists("master", mode = "list", envir = envir, 
[10:34:13.871]                           inherits = FALSE)) {
[10:34:13.871]                           master <- get("master", mode = "list", 
[10:34:13.871]                             envir = envir, inherits = FALSE)
[10:34:13.871]                           if (inherits(master, c("SOCKnode", 
[10:34:13.871]                             "SOCK0node"))) {
[10:34:13.871]                             sendCondition <<- function(cond) {
[10:34:13.871]                               data <- list(type = "VALUE", value = cond, 
[10:34:13.871]                                 success = TRUE)
[10:34:13.871]                               parallel_sendData(master, data)
[10:34:13.871]                             }
[10:34:13.871]                             return(sendCondition)
[10:34:13.871]                           }
[10:34:13.871]                         }
[10:34:13.871]                         frame <- frame + 1L
[10:34:13.871]                         envir <- sys.frame(frame)
[10:34:13.871]                       }
[10:34:13.871]                     }
[10:34:13.871]                     sendCondition <<- function(cond) NULL
[10:34:13.871]                   }
[10:34:13.871]                 })
[10:34:13.871]                 withCallingHandlers({
[10:34:13.871]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:34:13.871]                 }, immediateCondition = function(cond) {
[10:34:13.871]                   sendCondition <- ...future.makeSendCondition()
[10:34:13.871]                   sendCondition(cond)
[10:34:13.871]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:13.871]                   {
[10:34:13.871]                     inherits <- base::inherits
[10:34:13.871]                     invokeRestart <- base::invokeRestart
[10:34:13.871]                     is.null <- base::is.null
[10:34:13.871]                     muffled <- FALSE
[10:34:13.871]                     if (inherits(cond, "message")) {
[10:34:13.871]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:13.871]                       if (muffled) 
[10:34:13.871]                         invokeRestart("muffleMessage")
[10:34:13.871]                     }
[10:34:13.871]                     else if (inherits(cond, "warning")) {
[10:34:13.871]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:13.871]                       if (muffled) 
[10:34:13.871]                         invokeRestart("muffleWarning")
[10:34:13.871]                     }
[10:34:13.871]                     else if (inherits(cond, "condition")) {
[10:34:13.871]                       if (!is.null(pattern)) {
[10:34:13.871]                         computeRestarts <- base::computeRestarts
[10:34:13.871]                         grepl <- base::grepl
[10:34:13.871]                         restarts <- computeRestarts(cond)
[10:34:13.871]                         for (restart in restarts) {
[10:34:13.871]                           name <- restart$name
[10:34:13.871]                           if (is.null(name)) 
[10:34:13.871]                             next
[10:34:13.871]                           if (!grepl(pattern, name)) 
[10:34:13.871]                             next
[10:34:13.871]                           invokeRestart(restart)
[10:34:13.871]                           muffled <- TRUE
[10:34:13.871]                           break
[10:34:13.871]                         }
[10:34:13.871]                       }
[10:34:13.871]                     }
[10:34:13.871]                     invisible(muffled)
[10:34:13.871]                   }
[10:34:13.871]                   muffleCondition(cond)
[10:34:13.871]                 })
[10:34:13.871]             }))
[10:34:13.871]             future::FutureResult(value = ...future.value$value, 
[10:34:13.871]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:13.871]                   ...future.rng), globalenv = if (FALSE) 
[10:34:13.871]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:13.871]                     ...future.globalenv.names))
[10:34:13.871]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:13.871]         }, condition = base::local({
[10:34:13.871]             c <- base::c
[10:34:13.871]             inherits <- base::inherits
[10:34:13.871]             invokeRestart <- base::invokeRestart
[10:34:13.871]             length <- base::length
[10:34:13.871]             list <- base::list
[10:34:13.871]             seq.int <- base::seq.int
[10:34:13.871]             signalCondition <- base::signalCondition
[10:34:13.871]             sys.calls <- base::sys.calls
[10:34:13.871]             `[[` <- base::`[[`
[10:34:13.871]             `+` <- base::`+`
[10:34:13.871]             `<<-` <- base::`<<-`
[10:34:13.871]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:13.871]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:13.871]                   3L)]
[10:34:13.871]             }
[10:34:13.871]             function(cond) {
[10:34:13.871]                 is_error <- inherits(cond, "error")
[10:34:13.871]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:13.871]                   NULL)
[10:34:13.871]                 if (is_error) {
[10:34:13.871]                   sessionInformation <- function() {
[10:34:13.871]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:13.871]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:13.871]                       search = base::search(), system = base::Sys.info())
[10:34:13.871]                   }
[10:34:13.871]                   ...future.conditions[[length(...future.conditions) + 
[10:34:13.871]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:13.871]                     cond$call), session = sessionInformation(), 
[10:34:13.871]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:13.871]                   signalCondition(cond)
[10:34:13.871]                 }
[10:34:13.871]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:13.871]                 "immediateCondition"))) {
[10:34:13.871]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:13.871]                   ...future.conditions[[length(...future.conditions) + 
[10:34:13.871]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:13.871]                   if (TRUE && !signal) {
[10:34:13.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:13.871]                     {
[10:34:13.871]                       inherits <- base::inherits
[10:34:13.871]                       invokeRestart <- base::invokeRestart
[10:34:13.871]                       is.null <- base::is.null
[10:34:13.871]                       muffled <- FALSE
[10:34:13.871]                       if (inherits(cond, "message")) {
[10:34:13.871]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:13.871]                         if (muffled) 
[10:34:13.871]                           invokeRestart("muffleMessage")
[10:34:13.871]                       }
[10:34:13.871]                       else if (inherits(cond, "warning")) {
[10:34:13.871]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:13.871]                         if (muffled) 
[10:34:13.871]                           invokeRestart("muffleWarning")
[10:34:13.871]                       }
[10:34:13.871]                       else if (inherits(cond, "condition")) {
[10:34:13.871]                         if (!is.null(pattern)) {
[10:34:13.871]                           computeRestarts <- base::computeRestarts
[10:34:13.871]                           grepl <- base::grepl
[10:34:13.871]                           restarts <- computeRestarts(cond)
[10:34:13.871]                           for (restart in restarts) {
[10:34:13.871]                             name <- restart$name
[10:34:13.871]                             if (is.null(name)) 
[10:34:13.871]                               next
[10:34:13.871]                             if (!grepl(pattern, name)) 
[10:34:13.871]                               next
[10:34:13.871]                             invokeRestart(restart)
[10:34:13.871]                             muffled <- TRUE
[10:34:13.871]                             break
[10:34:13.871]                           }
[10:34:13.871]                         }
[10:34:13.871]                       }
[10:34:13.871]                       invisible(muffled)
[10:34:13.871]                     }
[10:34:13.871]                     muffleCondition(cond, pattern = "^muffle")
[10:34:13.871]                   }
[10:34:13.871]                 }
[10:34:13.871]                 else {
[10:34:13.871]                   if (TRUE) {
[10:34:13.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:13.871]                     {
[10:34:13.871]                       inherits <- base::inherits
[10:34:13.871]                       invokeRestart <- base::invokeRestart
[10:34:13.871]                       is.null <- base::is.null
[10:34:13.871]                       muffled <- FALSE
[10:34:13.871]                       if (inherits(cond, "message")) {
[10:34:13.871]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:13.871]                         if (muffled) 
[10:34:13.871]                           invokeRestart("muffleMessage")
[10:34:13.871]                       }
[10:34:13.871]                       else if (inherits(cond, "warning")) {
[10:34:13.871]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:13.871]                         if (muffled) 
[10:34:13.871]                           invokeRestart("muffleWarning")
[10:34:13.871]                       }
[10:34:13.871]                       else if (inherits(cond, "condition")) {
[10:34:13.871]                         if (!is.null(pattern)) {
[10:34:13.871]                           computeRestarts <- base::computeRestarts
[10:34:13.871]                           grepl <- base::grepl
[10:34:13.871]                           restarts <- computeRestarts(cond)
[10:34:13.871]                           for (restart in restarts) {
[10:34:13.871]                             name <- restart$name
[10:34:13.871]                             if (is.null(name)) 
[10:34:13.871]                               next
[10:34:13.871]                             if (!grepl(pattern, name)) 
[10:34:13.871]                               next
[10:34:13.871]                             invokeRestart(restart)
[10:34:13.871]                             muffled <- TRUE
[10:34:13.871]                             break
[10:34:13.871]                           }
[10:34:13.871]                         }
[10:34:13.871]                       }
[10:34:13.871]                       invisible(muffled)
[10:34:13.871]                     }
[10:34:13.871]                     muffleCondition(cond, pattern = "^muffle")
[10:34:13.871]                   }
[10:34:13.871]                 }
[10:34:13.871]             }
[10:34:13.871]         }))
[10:34:13.871]     }, error = function(ex) {
[10:34:13.871]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:13.871]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:13.871]                 ...future.rng), started = ...future.startTime, 
[10:34:13.871]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:13.871]             version = "1.8"), class = "FutureResult")
[10:34:13.871]     }, finally = {
[10:34:13.871]         if (!identical(...future.workdir, getwd())) 
[10:34:13.871]             setwd(...future.workdir)
[10:34:13.871]         {
[10:34:13.871]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:13.871]                 ...future.oldOptions$nwarnings <- NULL
[10:34:13.871]             }
[10:34:13.871]             base::options(...future.oldOptions)
[10:34:13.871]             if (.Platform$OS.type == "windows") {
[10:34:13.871]                 old_names <- names(...future.oldEnvVars)
[10:34:13.871]                 envs <- base::Sys.getenv()
[10:34:13.871]                 names <- names(envs)
[10:34:13.871]                 common <- intersect(names, old_names)
[10:34:13.871]                 added <- setdiff(names, old_names)
[10:34:13.871]                 removed <- setdiff(old_names, names)
[10:34:13.871]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:13.871]                   envs[common]]
[10:34:13.871]                 NAMES <- toupper(changed)
[10:34:13.871]                 args <- list()
[10:34:13.871]                 for (kk in seq_along(NAMES)) {
[10:34:13.871]                   name <- changed[[kk]]
[10:34:13.871]                   NAME <- NAMES[[kk]]
[10:34:13.871]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:13.871]                     next
[10:34:13.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:13.871]                 }
[10:34:13.871]                 NAMES <- toupper(added)
[10:34:13.871]                 for (kk in seq_along(NAMES)) {
[10:34:13.871]                   name <- added[[kk]]
[10:34:13.871]                   NAME <- NAMES[[kk]]
[10:34:13.871]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:13.871]                     next
[10:34:13.871]                   args[[name]] <- ""
[10:34:13.871]                 }
[10:34:13.871]                 NAMES <- toupper(removed)
[10:34:13.871]                 for (kk in seq_along(NAMES)) {
[10:34:13.871]                   name <- removed[[kk]]
[10:34:13.871]                   NAME <- NAMES[[kk]]
[10:34:13.871]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:13.871]                     next
[10:34:13.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:13.871]                 }
[10:34:13.871]                 if (length(args) > 0) 
[10:34:13.871]                   base::do.call(base::Sys.setenv, args = args)
[10:34:13.871]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:13.871]             }
[10:34:13.871]             else {
[10:34:13.871]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:13.871]             }
[10:34:13.871]             {
[10:34:13.871]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:13.871]                   0L) {
[10:34:13.871]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:13.871]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:13.871]                   base::options(opts)
[10:34:13.871]                 }
[10:34:13.871]                 {
[10:34:13.871]                   {
[10:34:13.871]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:13.871]                     NULL
[10:34:13.871]                   }
[10:34:13.871]                   options(future.plan = NULL)
[10:34:13.871]                   if (is.na(NA_character_)) 
[10:34:13.871]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:13.871]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:13.871]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:13.871]                     .init = FALSE)
[10:34:13.871]                 }
[10:34:13.871]             }
[10:34:13.871]         }
[10:34:13.871]     })
[10:34:13.871]     if (TRUE) {
[10:34:13.871]         base::sink(type = "output", split = FALSE)
[10:34:13.871]         if (TRUE) {
[10:34:13.871]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:13.871]         }
[10:34:13.871]         else {
[10:34:13.871]             ...future.result["stdout"] <- base::list(NULL)
[10:34:13.871]         }
[10:34:13.871]         base::close(...future.stdout)
[10:34:13.871]         ...future.stdout <- NULL
[10:34:13.871]     }
[10:34:13.871]     ...future.result$conditions <- ...future.conditions
[10:34:13.871]     ...future.result$finished <- base::Sys.time()
[10:34:13.871]     ...future.result
[10:34:13.871] }
[10:34:13.874] MultisessionFuture started
[10:34:13.874] - Launch lazy future ... done
[10:34:13.875] run() for ‘MultisessionFuture’ ... done
[10:34:13.876] receiveMessageFromWorker() for ClusterFuture ...
[10:34:13.876] - Validating connection of MultisessionFuture
[10:34:13.877] - received message: FutureResult
[10:34:13.877] - Received FutureResult
[10:34:13.877] - Erased future from FutureRegistry
[10:34:13.877] result() for ClusterFuture ...
[10:34:13.877] - result already collected: FutureResult
[10:34:13.877] result() for ClusterFuture ... done
[10:34:13.877] signalConditions() ...
[10:34:13.878]  - include = ‘immediateCondition’
[10:34:13.878]  - exclude = 
[10:34:13.878]  - resignal = FALSE
[10:34:13.878]  - Number of conditions: 1
[10:34:13.878] signalConditions() ... done
[10:34:13.878] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:13.878] A MultisessionFuture was resolved
- result = TRUE, recursive = 1 ... DONE
- result = TRUE, recursive = 2 ...
[10:34:13.878] getGlobalsAndPackages() ...
[10:34:13.878] Searching for globals...
[10:34:13.879] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:34:13.880] Searching for globals ... DONE
[10:34:13.880] Resolving globals: FALSE
[10:34:13.880] 
[10:34:13.880] 
[10:34:13.880] getGlobalsAndPackages() ... DONE
[10:34:13.880] run() for ‘Future’ ...
[10:34:13.881] - state: ‘created’
[10:34:13.881] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:13.896] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:13.896] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:13.896]   - Field: ‘node’
[10:34:13.896]   - Field: ‘label’
[10:34:13.896]   - Field: ‘local’
[10:34:13.896]   - Field: ‘owner’
[10:34:13.896]   - Field: ‘envir’
[10:34:13.897]   - Field: ‘workers’
[10:34:13.897]   - Field: ‘packages’
[10:34:13.897]   - Field: ‘gc’
[10:34:13.897]   - Field: ‘conditions’
[10:34:13.897]   - Field: ‘persistent’
[10:34:13.897]   - Field: ‘expr’
[10:34:13.897]   - Field: ‘uuid’
[10:34:13.897]   - Field: ‘seed’
[10:34:13.897]   - Field: ‘version’
[10:34:13.897]   - Field: ‘result’
[10:34:13.898]   - Field: ‘asynchronous’
[10:34:13.898]   - Field: ‘calls’
[10:34:13.898]   - Field: ‘globals’
[10:34:13.898]   - Field: ‘stdout’
[10:34:13.898]   - Field: ‘earlySignal’
[10:34:13.898]   - Field: ‘lazy’
[10:34:13.898]   - Field: ‘state’
[10:34:13.898] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:13.898] - Launch lazy future ...
[10:34:13.898] Packages needed by the future expression (n = 0): <none>
[10:34:13.899] Packages needed by future strategies (n = 0): <none>
[10:34:13.899] {
[10:34:13.899]     {
[10:34:13.899]         {
[10:34:13.899]             ...future.startTime <- base::Sys.time()
[10:34:13.899]             {
[10:34:13.899]                 {
[10:34:13.899]                   {
[10:34:13.899]                     {
[10:34:13.899]                       base::local({
[10:34:13.899]                         has_future <- base::requireNamespace("future", 
[10:34:13.899]                           quietly = TRUE)
[10:34:13.899]                         if (has_future) {
[10:34:13.899]                           ns <- base::getNamespace("future")
[10:34:13.899]                           version <- ns[[".package"]][["version"]]
[10:34:13.899]                           if (is.null(version)) 
[10:34:13.899]                             version <- utils::packageVersion("future")
[10:34:13.899]                         }
[10:34:13.899]                         else {
[10:34:13.899]                           version <- NULL
[10:34:13.899]                         }
[10:34:13.899]                         if (!has_future || version < "1.8.0") {
[10:34:13.899]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:13.899]                             "", base::R.version$version.string), 
[10:34:13.899]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:13.899]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:13.899]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:13.899]                               "release", "version")], collapse = " "), 
[10:34:13.899]                             hostname = base::Sys.info()[["nodename"]])
[10:34:13.899]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:13.899]                             info)
[10:34:13.899]                           info <- base::paste(info, collapse = "; ")
[10:34:13.899]                           if (!has_future) {
[10:34:13.899]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:13.899]                               info)
[10:34:13.899]                           }
[10:34:13.899]                           else {
[10:34:13.899]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:13.899]                               info, version)
[10:34:13.899]                           }
[10:34:13.899]                           base::stop(msg)
[10:34:13.899]                         }
[10:34:13.899]                       })
[10:34:13.899]                     }
[10:34:13.899]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:13.899]                     base::options(mc.cores = 1L)
[10:34:13.899]                   }
[10:34:13.899]                   ...future.strategy.old <- future::plan("list")
[10:34:13.899]                   options(future.plan = NULL)
[10:34:13.899]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:13.899]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:13.899]                 }
[10:34:13.899]                 ...future.workdir <- getwd()
[10:34:13.899]             }
[10:34:13.899]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:13.899]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:13.899]         }
[10:34:13.899]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:13.899]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:13.899]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:13.899]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:13.899]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:13.899]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:13.899]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:13.899]             base::names(...future.oldOptions))
[10:34:13.899]     }
[10:34:13.899]     if (FALSE) {
[10:34:13.899]     }
[10:34:13.899]     else {
[10:34:13.899]         if (TRUE) {
[10:34:13.899]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:13.899]                 open = "w")
[10:34:13.899]         }
[10:34:13.899]         else {
[10:34:13.899]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:13.899]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:13.899]         }
[10:34:13.899]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:13.899]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:13.899]             base::sink(type = "output", split = FALSE)
[10:34:13.899]             base::close(...future.stdout)
[10:34:13.899]         }, add = TRUE)
[10:34:13.899]     }
[10:34:13.899]     ...future.frame <- base::sys.nframe()
[10:34:13.899]     ...future.conditions <- base::list()
[10:34:13.899]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:13.899]     if (FALSE) {
[10:34:13.899]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:13.899]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:13.899]     }
[10:34:13.899]     ...future.result <- base::tryCatch({
[10:34:13.899]         base::withCallingHandlers({
[10:34:13.899]             ...future.value <- base::withVisible(base::local({
[10:34:13.899]                 ...future.makeSendCondition <- base::local({
[10:34:13.899]                   sendCondition <- NULL
[10:34:13.899]                   function(frame = 1L) {
[10:34:13.899]                     if (is.function(sendCondition)) 
[10:34:13.899]                       return(sendCondition)
[10:34:13.899]                     ns <- getNamespace("parallel")
[10:34:13.899]                     if (exists("sendData", mode = "function", 
[10:34:13.899]                       envir = ns)) {
[10:34:13.899]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:13.899]                         envir = ns)
[10:34:13.899]                       envir <- sys.frame(frame)
[10:34:13.899]                       master <- NULL
[10:34:13.899]                       while (!identical(envir, .GlobalEnv) && 
[10:34:13.899]                         !identical(envir, emptyenv())) {
[10:34:13.899]                         if (exists("master", mode = "list", envir = envir, 
[10:34:13.899]                           inherits = FALSE)) {
[10:34:13.899]                           master <- get("master", mode = "list", 
[10:34:13.899]                             envir = envir, inherits = FALSE)
[10:34:13.899]                           if (inherits(master, c("SOCKnode", 
[10:34:13.899]                             "SOCK0node"))) {
[10:34:13.899]                             sendCondition <<- function(cond) {
[10:34:13.899]                               data <- list(type = "VALUE", value = cond, 
[10:34:13.899]                                 success = TRUE)
[10:34:13.899]                               parallel_sendData(master, data)
[10:34:13.899]                             }
[10:34:13.899]                             return(sendCondition)
[10:34:13.899]                           }
[10:34:13.899]                         }
[10:34:13.899]                         frame <- frame + 1L
[10:34:13.899]                         envir <- sys.frame(frame)
[10:34:13.899]                       }
[10:34:13.899]                     }
[10:34:13.899]                     sendCondition <<- function(cond) NULL
[10:34:13.899]                   }
[10:34:13.899]                 })
[10:34:13.899]                 withCallingHandlers({
[10:34:13.899]                   {
[10:34:13.899]                     Sys.sleep(0.5)
[10:34:13.899]                     list(a = 1, b = 42L)
[10:34:13.899]                   }
[10:34:13.899]                 }, immediateCondition = function(cond) {
[10:34:13.899]                   sendCondition <- ...future.makeSendCondition()
[10:34:13.899]                   sendCondition(cond)
[10:34:13.899]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:13.899]                   {
[10:34:13.899]                     inherits <- base::inherits
[10:34:13.899]                     invokeRestart <- base::invokeRestart
[10:34:13.899]                     is.null <- base::is.null
[10:34:13.899]                     muffled <- FALSE
[10:34:13.899]                     if (inherits(cond, "message")) {
[10:34:13.899]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:13.899]                       if (muffled) 
[10:34:13.899]                         invokeRestart("muffleMessage")
[10:34:13.899]                     }
[10:34:13.899]                     else if (inherits(cond, "warning")) {
[10:34:13.899]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:13.899]                       if (muffled) 
[10:34:13.899]                         invokeRestart("muffleWarning")
[10:34:13.899]                     }
[10:34:13.899]                     else if (inherits(cond, "condition")) {
[10:34:13.899]                       if (!is.null(pattern)) {
[10:34:13.899]                         computeRestarts <- base::computeRestarts
[10:34:13.899]                         grepl <- base::grepl
[10:34:13.899]                         restarts <- computeRestarts(cond)
[10:34:13.899]                         for (restart in restarts) {
[10:34:13.899]                           name <- restart$name
[10:34:13.899]                           if (is.null(name)) 
[10:34:13.899]                             next
[10:34:13.899]                           if (!grepl(pattern, name)) 
[10:34:13.899]                             next
[10:34:13.899]                           invokeRestart(restart)
[10:34:13.899]                           muffled <- TRUE
[10:34:13.899]                           break
[10:34:13.899]                         }
[10:34:13.899]                       }
[10:34:13.899]                     }
[10:34:13.899]                     invisible(muffled)
[10:34:13.899]                   }
[10:34:13.899]                   muffleCondition(cond)
[10:34:13.899]                 })
[10:34:13.899]             }))
[10:34:13.899]             future::FutureResult(value = ...future.value$value, 
[10:34:13.899]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:13.899]                   ...future.rng), globalenv = if (FALSE) 
[10:34:13.899]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:13.899]                     ...future.globalenv.names))
[10:34:13.899]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:13.899]         }, condition = base::local({
[10:34:13.899]             c <- base::c
[10:34:13.899]             inherits <- base::inherits
[10:34:13.899]             invokeRestart <- base::invokeRestart
[10:34:13.899]             length <- base::length
[10:34:13.899]             list <- base::list
[10:34:13.899]             seq.int <- base::seq.int
[10:34:13.899]             signalCondition <- base::signalCondition
[10:34:13.899]             sys.calls <- base::sys.calls
[10:34:13.899]             `[[` <- base::`[[`
[10:34:13.899]             `+` <- base::`+`
[10:34:13.899]             `<<-` <- base::`<<-`
[10:34:13.899]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:13.899]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:13.899]                   3L)]
[10:34:13.899]             }
[10:34:13.899]             function(cond) {
[10:34:13.899]                 is_error <- inherits(cond, "error")
[10:34:13.899]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:13.899]                   NULL)
[10:34:13.899]                 if (is_error) {
[10:34:13.899]                   sessionInformation <- function() {
[10:34:13.899]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:13.899]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:13.899]                       search = base::search(), system = base::Sys.info())
[10:34:13.899]                   }
[10:34:13.899]                   ...future.conditions[[length(...future.conditions) + 
[10:34:13.899]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:13.899]                     cond$call), session = sessionInformation(), 
[10:34:13.899]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:13.899]                   signalCondition(cond)
[10:34:13.899]                 }
[10:34:13.899]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:13.899]                 "immediateCondition"))) {
[10:34:13.899]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:13.899]                   ...future.conditions[[length(...future.conditions) + 
[10:34:13.899]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:13.899]                   if (TRUE && !signal) {
[10:34:13.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:13.899]                     {
[10:34:13.899]                       inherits <- base::inherits
[10:34:13.899]                       invokeRestart <- base::invokeRestart
[10:34:13.899]                       is.null <- base::is.null
[10:34:13.899]                       muffled <- FALSE
[10:34:13.899]                       if (inherits(cond, "message")) {
[10:34:13.899]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:13.899]                         if (muffled) 
[10:34:13.899]                           invokeRestart("muffleMessage")
[10:34:13.899]                       }
[10:34:13.899]                       else if (inherits(cond, "warning")) {
[10:34:13.899]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:13.899]                         if (muffled) 
[10:34:13.899]                           invokeRestart("muffleWarning")
[10:34:13.899]                       }
[10:34:13.899]                       else if (inherits(cond, "condition")) {
[10:34:13.899]                         if (!is.null(pattern)) {
[10:34:13.899]                           computeRestarts <- base::computeRestarts
[10:34:13.899]                           grepl <- base::grepl
[10:34:13.899]                           restarts <- computeRestarts(cond)
[10:34:13.899]                           for (restart in restarts) {
[10:34:13.899]                             name <- restart$name
[10:34:13.899]                             if (is.null(name)) 
[10:34:13.899]                               next
[10:34:13.899]                             if (!grepl(pattern, name)) 
[10:34:13.899]                               next
[10:34:13.899]                             invokeRestart(restart)
[10:34:13.899]                             muffled <- TRUE
[10:34:13.899]                             break
[10:34:13.899]                           }
[10:34:13.899]                         }
[10:34:13.899]                       }
[10:34:13.899]                       invisible(muffled)
[10:34:13.899]                     }
[10:34:13.899]                     muffleCondition(cond, pattern = "^muffle")
[10:34:13.899]                   }
[10:34:13.899]                 }
[10:34:13.899]                 else {
[10:34:13.899]                   if (TRUE) {
[10:34:13.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:13.899]                     {
[10:34:13.899]                       inherits <- base::inherits
[10:34:13.899]                       invokeRestart <- base::invokeRestart
[10:34:13.899]                       is.null <- base::is.null
[10:34:13.899]                       muffled <- FALSE
[10:34:13.899]                       if (inherits(cond, "message")) {
[10:34:13.899]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:13.899]                         if (muffled) 
[10:34:13.899]                           invokeRestart("muffleMessage")
[10:34:13.899]                       }
[10:34:13.899]                       else if (inherits(cond, "warning")) {
[10:34:13.899]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:13.899]                         if (muffled) 
[10:34:13.899]                           invokeRestart("muffleWarning")
[10:34:13.899]                       }
[10:34:13.899]                       else if (inherits(cond, "condition")) {
[10:34:13.899]                         if (!is.null(pattern)) {
[10:34:13.899]                           computeRestarts <- base::computeRestarts
[10:34:13.899]                           grepl <- base::grepl
[10:34:13.899]                           restarts <- computeRestarts(cond)
[10:34:13.899]                           for (restart in restarts) {
[10:34:13.899]                             name <- restart$name
[10:34:13.899]                             if (is.null(name)) 
[10:34:13.899]                               next
[10:34:13.899]                             if (!grepl(pattern, name)) 
[10:34:13.899]                               next
[10:34:13.899]                             invokeRestart(restart)
[10:34:13.899]                             muffled <- TRUE
[10:34:13.899]                             break
[10:34:13.899]                           }
[10:34:13.899]                         }
[10:34:13.899]                       }
[10:34:13.899]                       invisible(muffled)
[10:34:13.899]                     }
[10:34:13.899]                     muffleCondition(cond, pattern = "^muffle")
[10:34:13.899]                   }
[10:34:13.899]                 }
[10:34:13.899]             }
[10:34:13.899]         }))
[10:34:13.899]     }, error = function(ex) {
[10:34:13.899]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:13.899]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:13.899]                 ...future.rng), started = ...future.startTime, 
[10:34:13.899]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:13.899]             version = "1.8"), class = "FutureResult")
[10:34:13.899]     }, finally = {
[10:34:13.899]         if (!identical(...future.workdir, getwd())) 
[10:34:13.899]             setwd(...future.workdir)
[10:34:13.899]         {
[10:34:13.899]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:13.899]                 ...future.oldOptions$nwarnings <- NULL
[10:34:13.899]             }
[10:34:13.899]             base::options(...future.oldOptions)
[10:34:13.899]             if (.Platform$OS.type == "windows") {
[10:34:13.899]                 old_names <- names(...future.oldEnvVars)
[10:34:13.899]                 envs <- base::Sys.getenv()
[10:34:13.899]                 names <- names(envs)
[10:34:13.899]                 common <- intersect(names, old_names)
[10:34:13.899]                 added <- setdiff(names, old_names)
[10:34:13.899]                 removed <- setdiff(old_names, names)
[10:34:13.899]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:13.899]                   envs[common]]
[10:34:13.899]                 NAMES <- toupper(changed)
[10:34:13.899]                 args <- list()
[10:34:13.899]                 for (kk in seq_along(NAMES)) {
[10:34:13.899]                   name <- changed[[kk]]
[10:34:13.899]                   NAME <- NAMES[[kk]]
[10:34:13.899]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:13.899]                     next
[10:34:13.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:13.899]                 }
[10:34:13.899]                 NAMES <- toupper(added)
[10:34:13.899]                 for (kk in seq_along(NAMES)) {
[10:34:13.899]                   name <- added[[kk]]
[10:34:13.899]                   NAME <- NAMES[[kk]]
[10:34:13.899]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:13.899]                     next
[10:34:13.899]                   args[[name]] <- ""
[10:34:13.899]                 }
[10:34:13.899]                 NAMES <- toupper(removed)
[10:34:13.899]                 for (kk in seq_along(NAMES)) {
[10:34:13.899]                   name <- removed[[kk]]
[10:34:13.899]                   NAME <- NAMES[[kk]]
[10:34:13.899]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:13.899]                     next
[10:34:13.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:13.899]                 }
[10:34:13.899]                 if (length(args) > 0) 
[10:34:13.899]                   base::do.call(base::Sys.setenv, args = args)
[10:34:13.899]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:13.899]             }
[10:34:13.899]             else {
[10:34:13.899]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:13.899]             }
[10:34:13.899]             {
[10:34:13.899]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:13.899]                   0L) {
[10:34:13.899]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:13.899]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:13.899]                   base::options(opts)
[10:34:13.899]                 }
[10:34:13.899]                 {
[10:34:13.899]                   {
[10:34:13.899]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:13.899]                     NULL
[10:34:13.899]                   }
[10:34:13.899]                   options(future.plan = NULL)
[10:34:13.899]                   if (is.na(NA_character_)) 
[10:34:13.899]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:13.899]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:13.899]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:13.899]                     .init = FALSE)
[10:34:13.899]                 }
[10:34:13.899]             }
[10:34:13.899]         }
[10:34:13.899]     })
[10:34:13.899]     if (TRUE) {
[10:34:13.899]         base::sink(type = "output", split = FALSE)
[10:34:13.899]         if (TRUE) {
[10:34:13.899]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:13.899]         }
[10:34:13.899]         else {
[10:34:13.899]             ...future.result["stdout"] <- base::list(NULL)
[10:34:13.899]         }
[10:34:13.899]         base::close(...future.stdout)
[10:34:13.899]         ...future.stdout <- NULL
[10:34:13.899]     }
[10:34:13.899]     ...future.result$conditions <- ...future.conditions
[10:34:13.899]     ...future.result$finished <- base::Sys.time()
[10:34:13.899]     ...future.result
[10:34:13.899] }
[10:34:13.902] MultisessionFuture started
[10:34:13.902] - Launch lazy future ... done
[10:34:13.902] run() for ‘MultisessionFuture’ ... done
[10:34:14.404] receiveMessageFromWorker() for ClusterFuture ...
[10:34:14.404] - Validating connection of MultisessionFuture
[10:34:14.404] - received message: FutureResult
[10:34:14.405] - Received FutureResult
[10:34:14.405] - Erased future from FutureRegistry
[10:34:14.405] result() for ClusterFuture ...
[10:34:14.405] - result already collected: FutureResult
[10:34:14.405] result() for ClusterFuture ... done
[10:34:14.405] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:14.405] resolve() on list ...
[10:34:14.405]  recursive: 1
[10:34:14.405]  length: 2
[10:34:14.406]  elements: ‘a’, ‘b’
[10:34:14.406]  length: 1 (resolved future 1)
[10:34:14.406]  length: 0 (resolved future 2)
[10:34:14.406] resolve() on list ... DONE
[10:34:14.406] A MultisessionFuture was resolved (and resolved itself)
[10:34:14.406] getGlobalsAndPackages() ...
[10:34:14.406] Searching for globals...
[10:34:14.407] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:34:14.407] Searching for globals ... DONE
[10:34:14.408] Resolving globals: FALSE
[10:34:14.408] 
[10:34:14.408] 
[10:34:14.408] getGlobalsAndPackages() ... DONE
[10:34:14.408] run() for ‘Future’ ...
[10:34:14.408] - state: ‘created’
[10:34:14.409] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:14.422] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:14.422] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:14.422]   - Field: ‘node’
[10:34:14.423]   - Field: ‘label’
[10:34:14.423]   - Field: ‘local’
[10:34:14.423]   - Field: ‘owner’
[10:34:14.423]   - Field: ‘envir’
[10:34:14.423]   - Field: ‘workers’
[10:34:14.423]   - Field: ‘packages’
[10:34:14.423]   - Field: ‘gc’
[10:34:14.423]   - Field: ‘conditions’
[10:34:14.423]   - Field: ‘persistent’
[10:34:14.423]   - Field: ‘expr’
[10:34:14.423]   - Field: ‘uuid’
[10:34:14.424]   - Field: ‘seed’
[10:34:14.424]   - Field: ‘version’
[10:34:14.424]   - Field: ‘result’
[10:34:14.424]   - Field: ‘asynchronous’
[10:34:14.424]   - Field: ‘calls’
[10:34:14.424]   - Field: ‘globals’
[10:34:14.424]   - Field: ‘stdout’
[10:34:14.424]   - Field: ‘earlySignal’
[10:34:14.424]   - Field: ‘lazy’
[10:34:14.424]   - Field: ‘state’
[10:34:14.424] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:14.425] - Launch lazy future ...
[10:34:14.425] Packages needed by the future expression (n = 0): <none>
[10:34:14.425] Packages needed by future strategies (n = 0): <none>
[10:34:14.425] {
[10:34:14.425]     {
[10:34:14.425]         {
[10:34:14.425]             ...future.startTime <- base::Sys.time()
[10:34:14.425]             {
[10:34:14.425]                 {
[10:34:14.425]                   {
[10:34:14.425]                     {
[10:34:14.425]                       base::local({
[10:34:14.425]                         has_future <- base::requireNamespace("future", 
[10:34:14.425]                           quietly = TRUE)
[10:34:14.425]                         if (has_future) {
[10:34:14.425]                           ns <- base::getNamespace("future")
[10:34:14.425]                           version <- ns[[".package"]][["version"]]
[10:34:14.425]                           if (is.null(version)) 
[10:34:14.425]                             version <- utils::packageVersion("future")
[10:34:14.425]                         }
[10:34:14.425]                         else {
[10:34:14.425]                           version <- NULL
[10:34:14.425]                         }
[10:34:14.425]                         if (!has_future || version < "1.8.0") {
[10:34:14.425]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:14.425]                             "", base::R.version$version.string), 
[10:34:14.425]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:14.425]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:14.425]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:14.425]                               "release", "version")], collapse = " "), 
[10:34:14.425]                             hostname = base::Sys.info()[["nodename"]])
[10:34:14.425]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:14.425]                             info)
[10:34:14.425]                           info <- base::paste(info, collapse = "; ")
[10:34:14.425]                           if (!has_future) {
[10:34:14.425]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:14.425]                               info)
[10:34:14.425]                           }
[10:34:14.425]                           else {
[10:34:14.425]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:14.425]                               info, version)
[10:34:14.425]                           }
[10:34:14.425]                           base::stop(msg)
[10:34:14.425]                         }
[10:34:14.425]                       })
[10:34:14.425]                     }
[10:34:14.425]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:14.425]                     base::options(mc.cores = 1L)
[10:34:14.425]                   }
[10:34:14.425]                   ...future.strategy.old <- future::plan("list")
[10:34:14.425]                   options(future.plan = NULL)
[10:34:14.425]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:14.425]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:14.425]                 }
[10:34:14.425]                 ...future.workdir <- getwd()
[10:34:14.425]             }
[10:34:14.425]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:14.425]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:14.425]         }
[10:34:14.425]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:14.425]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:14.425]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:14.425]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:14.425]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:14.425]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:14.425]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:14.425]             base::names(...future.oldOptions))
[10:34:14.425]     }
[10:34:14.425]     if (FALSE) {
[10:34:14.425]     }
[10:34:14.425]     else {
[10:34:14.425]         if (TRUE) {
[10:34:14.425]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:14.425]                 open = "w")
[10:34:14.425]         }
[10:34:14.425]         else {
[10:34:14.425]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:14.425]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:14.425]         }
[10:34:14.425]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:14.425]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:14.425]             base::sink(type = "output", split = FALSE)
[10:34:14.425]             base::close(...future.stdout)
[10:34:14.425]         }, add = TRUE)
[10:34:14.425]     }
[10:34:14.425]     ...future.frame <- base::sys.nframe()
[10:34:14.425]     ...future.conditions <- base::list()
[10:34:14.425]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:14.425]     if (FALSE) {
[10:34:14.425]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:14.425]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:14.425]     }
[10:34:14.425]     ...future.result <- base::tryCatch({
[10:34:14.425]         base::withCallingHandlers({
[10:34:14.425]             ...future.value <- base::withVisible(base::local({
[10:34:14.425]                 ...future.makeSendCondition <- base::local({
[10:34:14.425]                   sendCondition <- NULL
[10:34:14.425]                   function(frame = 1L) {
[10:34:14.425]                     if (is.function(sendCondition)) 
[10:34:14.425]                       return(sendCondition)
[10:34:14.425]                     ns <- getNamespace("parallel")
[10:34:14.425]                     if (exists("sendData", mode = "function", 
[10:34:14.425]                       envir = ns)) {
[10:34:14.425]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:14.425]                         envir = ns)
[10:34:14.425]                       envir <- sys.frame(frame)
[10:34:14.425]                       master <- NULL
[10:34:14.425]                       while (!identical(envir, .GlobalEnv) && 
[10:34:14.425]                         !identical(envir, emptyenv())) {
[10:34:14.425]                         if (exists("master", mode = "list", envir = envir, 
[10:34:14.425]                           inherits = FALSE)) {
[10:34:14.425]                           master <- get("master", mode = "list", 
[10:34:14.425]                             envir = envir, inherits = FALSE)
[10:34:14.425]                           if (inherits(master, c("SOCKnode", 
[10:34:14.425]                             "SOCK0node"))) {
[10:34:14.425]                             sendCondition <<- function(cond) {
[10:34:14.425]                               data <- list(type = "VALUE", value = cond, 
[10:34:14.425]                                 success = TRUE)
[10:34:14.425]                               parallel_sendData(master, data)
[10:34:14.425]                             }
[10:34:14.425]                             return(sendCondition)
[10:34:14.425]                           }
[10:34:14.425]                         }
[10:34:14.425]                         frame <- frame + 1L
[10:34:14.425]                         envir <- sys.frame(frame)
[10:34:14.425]                       }
[10:34:14.425]                     }
[10:34:14.425]                     sendCondition <<- function(cond) NULL
[10:34:14.425]                   }
[10:34:14.425]                 })
[10:34:14.425]                 withCallingHandlers({
[10:34:14.425]                   {
[10:34:14.425]                     Sys.sleep(0.5)
[10:34:14.425]                     list(a = 1, b = 42L)
[10:34:14.425]                   }
[10:34:14.425]                 }, immediateCondition = function(cond) {
[10:34:14.425]                   sendCondition <- ...future.makeSendCondition()
[10:34:14.425]                   sendCondition(cond)
[10:34:14.425]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:14.425]                   {
[10:34:14.425]                     inherits <- base::inherits
[10:34:14.425]                     invokeRestart <- base::invokeRestart
[10:34:14.425]                     is.null <- base::is.null
[10:34:14.425]                     muffled <- FALSE
[10:34:14.425]                     if (inherits(cond, "message")) {
[10:34:14.425]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:14.425]                       if (muffled) 
[10:34:14.425]                         invokeRestart("muffleMessage")
[10:34:14.425]                     }
[10:34:14.425]                     else if (inherits(cond, "warning")) {
[10:34:14.425]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:14.425]                       if (muffled) 
[10:34:14.425]                         invokeRestart("muffleWarning")
[10:34:14.425]                     }
[10:34:14.425]                     else if (inherits(cond, "condition")) {
[10:34:14.425]                       if (!is.null(pattern)) {
[10:34:14.425]                         computeRestarts <- base::computeRestarts
[10:34:14.425]                         grepl <- base::grepl
[10:34:14.425]                         restarts <- computeRestarts(cond)
[10:34:14.425]                         for (restart in restarts) {
[10:34:14.425]                           name <- restart$name
[10:34:14.425]                           if (is.null(name)) 
[10:34:14.425]                             next
[10:34:14.425]                           if (!grepl(pattern, name)) 
[10:34:14.425]                             next
[10:34:14.425]                           invokeRestart(restart)
[10:34:14.425]                           muffled <- TRUE
[10:34:14.425]                           break
[10:34:14.425]                         }
[10:34:14.425]                       }
[10:34:14.425]                     }
[10:34:14.425]                     invisible(muffled)
[10:34:14.425]                   }
[10:34:14.425]                   muffleCondition(cond)
[10:34:14.425]                 })
[10:34:14.425]             }))
[10:34:14.425]             future::FutureResult(value = ...future.value$value, 
[10:34:14.425]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:14.425]                   ...future.rng), globalenv = if (FALSE) 
[10:34:14.425]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:14.425]                     ...future.globalenv.names))
[10:34:14.425]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:14.425]         }, condition = base::local({
[10:34:14.425]             c <- base::c
[10:34:14.425]             inherits <- base::inherits
[10:34:14.425]             invokeRestart <- base::invokeRestart
[10:34:14.425]             length <- base::length
[10:34:14.425]             list <- base::list
[10:34:14.425]             seq.int <- base::seq.int
[10:34:14.425]             signalCondition <- base::signalCondition
[10:34:14.425]             sys.calls <- base::sys.calls
[10:34:14.425]             `[[` <- base::`[[`
[10:34:14.425]             `+` <- base::`+`
[10:34:14.425]             `<<-` <- base::`<<-`
[10:34:14.425]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:14.425]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:14.425]                   3L)]
[10:34:14.425]             }
[10:34:14.425]             function(cond) {
[10:34:14.425]                 is_error <- inherits(cond, "error")
[10:34:14.425]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:14.425]                   NULL)
[10:34:14.425]                 if (is_error) {
[10:34:14.425]                   sessionInformation <- function() {
[10:34:14.425]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:14.425]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:14.425]                       search = base::search(), system = base::Sys.info())
[10:34:14.425]                   }
[10:34:14.425]                   ...future.conditions[[length(...future.conditions) + 
[10:34:14.425]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:14.425]                     cond$call), session = sessionInformation(), 
[10:34:14.425]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:14.425]                   signalCondition(cond)
[10:34:14.425]                 }
[10:34:14.425]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:14.425]                 "immediateCondition"))) {
[10:34:14.425]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:14.425]                   ...future.conditions[[length(...future.conditions) + 
[10:34:14.425]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:14.425]                   if (TRUE && !signal) {
[10:34:14.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:14.425]                     {
[10:34:14.425]                       inherits <- base::inherits
[10:34:14.425]                       invokeRestart <- base::invokeRestart
[10:34:14.425]                       is.null <- base::is.null
[10:34:14.425]                       muffled <- FALSE
[10:34:14.425]                       if (inherits(cond, "message")) {
[10:34:14.425]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:14.425]                         if (muffled) 
[10:34:14.425]                           invokeRestart("muffleMessage")
[10:34:14.425]                       }
[10:34:14.425]                       else if (inherits(cond, "warning")) {
[10:34:14.425]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:14.425]                         if (muffled) 
[10:34:14.425]                           invokeRestart("muffleWarning")
[10:34:14.425]                       }
[10:34:14.425]                       else if (inherits(cond, "condition")) {
[10:34:14.425]                         if (!is.null(pattern)) {
[10:34:14.425]                           computeRestarts <- base::computeRestarts
[10:34:14.425]                           grepl <- base::grepl
[10:34:14.425]                           restarts <- computeRestarts(cond)
[10:34:14.425]                           for (restart in restarts) {
[10:34:14.425]                             name <- restart$name
[10:34:14.425]                             if (is.null(name)) 
[10:34:14.425]                               next
[10:34:14.425]                             if (!grepl(pattern, name)) 
[10:34:14.425]                               next
[10:34:14.425]                             invokeRestart(restart)
[10:34:14.425]                             muffled <- TRUE
[10:34:14.425]                             break
[10:34:14.425]                           }
[10:34:14.425]                         }
[10:34:14.425]                       }
[10:34:14.425]                       invisible(muffled)
[10:34:14.425]                     }
[10:34:14.425]                     muffleCondition(cond, pattern = "^muffle")
[10:34:14.425]                   }
[10:34:14.425]                 }
[10:34:14.425]                 else {
[10:34:14.425]                   if (TRUE) {
[10:34:14.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:14.425]                     {
[10:34:14.425]                       inherits <- base::inherits
[10:34:14.425]                       invokeRestart <- base::invokeRestart
[10:34:14.425]                       is.null <- base::is.null
[10:34:14.425]                       muffled <- FALSE
[10:34:14.425]                       if (inherits(cond, "message")) {
[10:34:14.425]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:14.425]                         if (muffled) 
[10:34:14.425]                           invokeRestart("muffleMessage")
[10:34:14.425]                       }
[10:34:14.425]                       else if (inherits(cond, "warning")) {
[10:34:14.425]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:14.425]                         if (muffled) 
[10:34:14.425]                           invokeRestart("muffleWarning")
[10:34:14.425]                       }
[10:34:14.425]                       else if (inherits(cond, "condition")) {
[10:34:14.425]                         if (!is.null(pattern)) {
[10:34:14.425]                           computeRestarts <- base::computeRestarts
[10:34:14.425]                           grepl <- base::grepl
[10:34:14.425]                           restarts <- computeRestarts(cond)
[10:34:14.425]                           for (restart in restarts) {
[10:34:14.425]                             name <- restart$name
[10:34:14.425]                             if (is.null(name)) 
[10:34:14.425]                               next
[10:34:14.425]                             if (!grepl(pattern, name)) 
[10:34:14.425]                               next
[10:34:14.425]                             invokeRestart(restart)
[10:34:14.425]                             muffled <- TRUE
[10:34:14.425]                             break
[10:34:14.425]                           }
[10:34:14.425]                         }
[10:34:14.425]                       }
[10:34:14.425]                       invisible(muffled)
[10:34:14.425]                     }
[10:34:14.425]                     muffleCondition(cond, pattern = "^muffle")
[10:34:14.425]                   }
[10:34:14.425]                 }
[10:34:14.425]             }
[10:34:14.425]         }))
[10:34:14.425]     }, error = function(ex) {
[10:34:14.425]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:14.425]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:14.425]                 ...future.rng), started = ...future.startTime, 
[10:34:14.425]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:14.425]             version = "1.8"), class = "FutureResult")
[10:34:14.425]     }, finally = {
[10:34:14.425]         if (!identical(...future.workdir, getwd())) 
[10:34:14.425]             setwd(...future.workdir)
[10:34:14.425]         {
[10:34:14.425]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:14.425]                 ...future.oldOptions$nwarnings <- NULL
[10:34:14.425]             }
[10:34:14.425]             base::options(...future.oldOptions)
[10:34:14.425]             if (.Platform$OS.type == "windows") {
[10:34:14.425]                 old_names <- names(...future.oldEnvVars)
[10:34:14.425]                 envs <- base::Sys.getenv()
[10:34:14.425]                 names <- names(envs)
[10:34:14.425]                 common <- intersect(names, old_names)
[10:34:14.425]                 added <- setdiff(names, old_names)
[10:34:14.425]                 removed <- setdiff(old_names, names)
[10:34:14.425]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:14.425]                   envs[common]]
[10:34:14.425]                 NAMES <- toupper(changed)
[10:34:14.425]                 args <- list()
[10:34:14.425]                 for (kk in seq_along(NAMES)) {
[10:34:14.425]                   name <- changed[[kk]]
[10:34:14.425]                   NAME <- NAMES[[kk]]
[10:34:14.425]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:14.425]                     next
[10:34:14.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:14.425]                 }
[10:34:14.425]                 NAMES <- toupper(added)
[10:34:14.425]                 for (kk in seq_along(NAMES)) {
[10:34:14.425]                   name <- added[[kk]]
[10:34:14.425]                   NAME <- NAMES[[kk]]
[10:34:14.425]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:14.425]                     next
[10:34:14.425]                   args[[name]] <- ""
[10:34:14.425]                 }
[10:34:14.425]                 NAMES <- toupper(removed)
[10:34:14.425]                 for (kk in seq_along(NAMES)) {
[10:34:14.425]                   name <- removed[[kk]]
[10:34:14.425]                   NAME <- NAMES[[kk]]
[10:34:14.425]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:14.425]                     next
[10:34:14.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:14.425]                 }
[10:34:14.425]                 if (length(args) > 0) 
[10:34:14.425]                   base::do.call(base::Sys.setenv, args = args)
[10:34:14.425]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:14.425]             }
[10:34:14.425]             else {
[10:34:14.425]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:14.425]             }
[10:34:14.425]             {
[10:34:14.425]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:14.425]                   0L) {
[10:34:14.425]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:14.425]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:14.425]                   base::options(opts)
[10:34:14.425]                 }
[10:34:14.425]                 {
[10:34:14.425]                   {
[10:34:14.425]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:14.425]                     NULL
[10:34:14.425]                   }
[10:34:14.425]                   options(future.plan = NULL)
[10:34:14.425]                   if (is.na(NA_character_)) 
[10:34:14.425]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:14.425]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:14.425]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:14.425]                     .init = FALSE)
[10:34:14.425]                 }
[10:34:14.425]             }
[10:34:14.425]         }
[10:34:14.425]     })
[10:34:14.425]     if (TRUE) {
[10:34:14.425]         base::sink(type = "output", split = FALSE)
[10:34:14.425]         if (TRUE) {
[10:34:14.425]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:14.425]         }
[10:34:14.425]         else {
[10:34:14.425]             ...future.result["stdout"] <- base::list(NULL)
[10:34:14.425]         }
[10:34:14.425]         base::close(...future.stdout)
[10:34:14.425]         ...future.stdout <- NULL
[10:34:14.425]     }
[10:34:14.425]     ...future.result$conditions <- ...future.conditions
[10:34:14.425]     ...future.result$finished <- base::Sys.time()
[10:34:14.425]     ...future.result
[10:34:14.425] }
[10:34:14.428] MultisessionFuture started
[10:34:14.428] - Launch lazy future ... done
[10:34:14.429] run() for ‘MultisessionFuture’ ... done
[10:34:14.931] receiveMessageFromWorker() for ClusterFuture ...
[10:34:14.931] - Validating connection of MultisessionFuture
[10:34:14.931] - received message: FutureResult
[10:34:14.931] - Received FutureResult
[10:34:14.932] - Erased future from FutureRegistry
[10:34:14.932] result() for ClusterFuture ...
[10:34:14.932] - result already collected: FutureResult
[10:34:14.932] result() for ClusterFuture ... done
[10:34:14.932] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:14.932] resolve() on list ...
[10:34:14.932]  recursive: 1
[10:34:14.932]  length: 2
[10:34:14.932]  elements: ‘a’, ‘b’
[10:34:14.932]  length: 1 (resolved future 1)
[10:34:14.933]  length: 0 (resolved future 2)
[10:34:14.933] resolve() on list ... DONE
[10:34:14.933] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[10:34:14.933] getGlobalsAndPackages() ...
[10:34:14.933] Searching for globals...
[10:34:14.934] - globals found: [2] ‘list’, ‘stop’
[10:34:14.934] Searching for globals ... DONE
[10:34:14.934] Resolving globals: FALSE
[10:34:14.934] 
[10:34:14.934] 
[10:34:14.934] getGlobalsAndPackages() ... DONE
[10:34:14.935] run() for ‘Future’ ...
[10:34:14.935] - state: ‘created’
[10:34:14.935] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:14.949] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:14.949] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:14.949]   - Field: ‘node’
[10:34:14.949]   - Field: ‘label’
[10:34:14.949]   - Field: ‘local’
[10:34:14.949]   - Field: ‘owner’
[10:34:14.949]   - Field: ‘envir’
[10:34:14.949]   - Field: ‘workers’
[10:34:14.949]   - Field: ‘packages’
[10:34:14.950]   - Field: ‘gc’
[10:34:14.950]   - Field: ‘conditions’
[10:34:14.950]   - Field: ‘persistent’
[10:34:14.950]   - Field: ‘expr’
[10:34:14.950]   - Field: ‘uuid’
[10:34:14.950]   - Field: ‘seed’
[10:34:14.950]   - Field: ‘version’
[10:34:14.950]   - Field: ‘result’
[10:34:14.950]   - Field: ‘asynchronous’
[10:34:14.950]   - Field: ‘calls’
[10:34:14.950]   - Field: ‘globals’
[10:34:14.951]   - Field: ‘stdout’
[10:34:14.951]   - Field: ‘earlySignal’
[10:34:14.951]   - Field: ‘lazy’
[10:34:14.951]   - Field: ‘state’
[10:34:14.951] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:14.951] - Launch lazy future ...
[10:34:14.951] Packages needed by the future expression (n = 0): <none>
[10:34:14.951] Packages needed by future strategies (n = 0): <none>
[10:34:14.952] {
[10:34:14.952]     {
[10:34:14.952]         {
[10:34:14.952]             ...future.startTime <- base::Sys.time()
[10:34:14.952]             {
[10:34:14.952]                 {
[10:34:14.952]                   {
[10:34:14.952]                     {
[10:34:14.952]                       base::local({
[10:34:14.952]                         has_future <- base::requireNamespace("future", 
[10:34:14.952]                           quietly = TRUE)
[10:34:14.952]                         if (has_future) {
[10:34:14.952]                           ns <- base::getNamespace("future")
[10:34:14.952]                           version <- ns[[".package"]][["version"]]
[10:34:14.952]                           if (is.null(version)) 
[10:34:14.952]                             version <- utils::packageVersion("future")
[10:34:14.952]                         }
[10:34:14.952]                         else {
[10:34:14.952]                           version <- NULL
[10:34:14.952]                         }
[10:34:14.952]                         if (!has_future || version < "1.8.0") {
[10:34:14.952]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:14.952]                             "", base::R.version$version.string), 
[10:34:14.952]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:14.952]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:14.952]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:14.952]                               "release", "version")], collapse = " "), 
[10:34:14.952]                             hostname = base::Sys.info()[["nodename"]])
[10:34:14.952]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:14.952]                             info)
[10:34:14.952]                           info <- base::paste(info, collapse = "; ")
[10:34:14.952]                           if (!has_future) {
[10:34:14.952]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:14.952]                               info)
[10:34:14.952]                           }
[10:34:14.952]                           else {
[10:34:14.952]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:14.952]                               info, version)
[10:34:14.952]                           }
[10:34:14.952]                           base::stop(msg)
[10:34:14.952]                         }
[10:34:14.952]                       })
[10:34:14.952]                     }
[10:34:14.952]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:14.952]                     base::options(mc.cores = 1L)
[10:34:14.952]                   }
[10:34:14.952]                   ...future.strategy.old <- future::plan("list")
[10:34:14.952]                   options(future.plan = NULL)
[10:34:14.952]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:14.952]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:14.952]                 }
[10:34:14.952]                 ...future.workdir <- getwd()
[10:34:14.952]             }
[10:34:14.952]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:14.952]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:14.952]         }
[10:34:14.952]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:14.952]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:14.952]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:14.952]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:14.952]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:14.952]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:14.952]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:14.952]             base::names(...future.oldOptions))
[10:34:14.952]     }
[10:34:14.952]     if (FALSE) {
[10:34:14.952]     }
[10:34:14.952]     else {
[10:34:14.952]         if (TRUE) {
[10:34:14.952]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:14.952]                 open = "w")
[10:34:14.952]         }
[10:34:14.952]         else {
[10:34:14.952]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:14.952]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:14.952]         }
[10:34:14.952]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:14.952]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:14.952]             base::sink(type = "output", split = FALSE)
[10:34:14.952]             base::close(...future.stdout)
[10:34:14.952]         }, add = TRUE)
[10:34:14.952]     }
[10:34:14.952]     ...future.frame <- base::sys.nframe()
[10:34:14.952]     ...future.conditions <- base::list()
[10:34:14.952]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:14.952]     if (FALSE) {
[10:34:14.952]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:14.952]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:14.952]     }
[10:34:14.952]     ...future.result <- base::tryCatch({
[10:34:14.952]         base::withCallingHandlers({
[10:34:14.952]             ...future.value <- base::withVisible(base::local({
[10:34:14.952]                 ...future.makeSendCondition <- base::local({
[10:34:14.952]                   sendCondition <- NULL
[10:34:14.952]                   function(frame = 1L) {
[10:34:14.952]                     if (is.function(sendCondition)) 
[10:34:14.952]                       return(sendCondition)
[10:34:14.952]                     ns <- getNamespace("parallel")
[10:34:14.952]                     if (exists("sendData", mode = "function", 
[10:34:14.952]                       envir = ns)) {
[10:34:14.952]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:14.952]                         envir = ns)
[10:34:14.952]                       envir <- sys.frame(frame)
[10:34:14.952]                       master <- NULL
[10:34:14.952]                       while (!identical(envir, .GlobalEnv) && 
[10:34:14.952]                         !identical(envir, emptyenv())) {
[10:34:14.952]                         if (exists("master", mode = "list", envir = envir, 
[10:34:14.952]                           inherits = FALSE)) {
[10:34:14.952]                           master <- get("master", mode = "list", 
[10:34:14.952]                             envir = envir, inherits = FALSE)
[10:34:14.952]                           if (inherits(master, c("SOCKnode", 
[10:34:14.952]                             "SOCK0node"))) {
[10:34:14.952]                             sendCondition <<- function(cond) {
[10:34:14.952]                               data <- list(type = "VALUE", value = cond, 
[10:34:14.952]                                 success = TRUE)
[10:34:14.952]                               parallel_sendData(master, data)
[10:34:14.952]                             }
[10:34:14.952]                             return(sendCondition)
[10:34:14.952]                           }
[10:34:14.952]                         }
[10:34:14.952]                         frame <- frame + 1L
[10:34:14.952]                         envir <- sys.frame(frame)
[10:34:14.952]                       }
[10:34:14.952]                     }
[10:34:14.952]                     sendCondition <<- function(cond) NULL
[10:34:14.952]                   }
[10:34:14.952]                 })
[10:34:14.952]                 withCallingHandlers({
[10:34:14.952]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:34:14.952]                 }, immediateCondition = function(cond) {
[10:34:14.952]                   sendCondition <- ...future.makeSendCondition()
[10:34:14.952]                   sendCondition(cond)
[10:34:14.952]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:14.952]                   {
[10:34:14.952]                     inherits <- base::inherits
[10:34:14.952]                     invokeRestart <- base::invokeRestart
[10:34:14.952]                     is.null <- base::is.null
[10:34:14.952]                     muffled <- FALSE
[10:34:14.952]                     if (inherits(cond, "message")) {
[10:34:14.952]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:14.952]                       if (muffled) 
[10:34:14.952]                         invokeRestart("muffleMessage")
[10:34:14.952]                     }
[10:34:14.952]                     else if (inherits(cond, "warning")) {
[10:34:14.952]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:14.952]                       if (muffled) 
[10:34:14.952]                         invokeRestart("muffleWarning")
[10:34:14.952]                     }
[10:34:14.952]                     else if (inherits(cond, "condition")) {
[10:34:14.952]                       if (!is.null(pattern)) {
[10:34:14.952]                         computeRestarts <- base::computeRestarts
[10:34:14.952]                         grepl <- base::grepl
[10:34:14.952]                         restarts <- computeRestarts(cond)
[10:34:14.952]                         for (restart in restarts) {
[10:34:14.952]                           name <- restart$name
[10:34:14.952]                           if (is.null(name)) 
[10:34:14.952]                             next
[10:34:14.952]                           if (!grepl(pattern, name)) 
[10:34:14.952]                             next
[10:34:14.952]                           invokeRestart(restart)
[10:34:14.952]                           muffled <- TRUE
[10:34:14.952]                           break
[10:34:14.952]                         }
[10:34:14.952]                       }
[10:34:14.952]                     }
[10:34:14.952]                     invisible(muffled)
[10:34:14.952]                   }
[10:34:14.952]                   muffleCondition(cond)
[10:34:14.952]                 })
[10:34:14.952]             }))
[10:34:14.952]             future::FutureResult(value = ...future.value$value, 
[10:34:14.952]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:14.952]                   ...future.rng), globalenv = if (FALSE) 
[10:34:14.952]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:14.952]                     ...future.globalenv.names))
[10:34:14.952]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:14.952]         }, condition = base::local({
[10:34:14.952]             c <- base::c
[10:34:14.952]             inherits <- base::inherits
[10:34:14.952]             invokeRestart <- base::invokeRestart
[10:34:14.952]             length <- base::length
[10:34:14.952]             list <- base::list
[10:34:14.952]             seq.int <- base::seq.int
[10:34:14.952]             signalCondition <- base::signalCondition
[10:34:14.952]             sys.calls <- base::sys.calls
[10:34:14.952]             `[[` <- base::`[[`
[10:34:14.952]             `+` <- base::`+`
[10:34:14.952]             `<<-` <- base::`<<-`
[10:34:14.952]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:14.952]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:14.952]                   3L)]
[10:34:14.952]             }
[10:34:14.952]             function(cond) {
[10:34:14.952]                 is_error <- inherits(cond, "error")
[10:34:14.952]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:14.952]                   NULL)
[10:34:14.952]                 if (is_error) {
[10:34:14.952]                   sessionInformation <- function() {
[10:34:14.952]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:14.952]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:14.952]                       search = base::search(), system = base::Sys.info())
[10:34:14.952]                   }
[10:34:14.952]                   ...future.conditions[[length(...future.conditions) + 
[10:34:14.952]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:14.952]                     cond$call), session = sessionInformation(), 
[10:34:14.952]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:14.952]                   signalCondition(cond)
[10:34:14.952]                 }
[10:34:14.952]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:14.952]                 "immediateCondition"))) {
[10:34:14.952]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:14.952]                   ...future.conditions[[length(...future.conditions) + 
[10:34:14.952]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:14.952]                   if (TRUE && !signal) {
[10:34:14.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:14.952]                     {
[10:34:14.952]                       inherits <- base::inherits
[10:34:14.952]                       invokeRestart <- base::invokeRestart
[10:34:14.952]                       is.null <- base::is.null
[10:34:14.952]                       muffled <- FALSE
[10:34:14.952]                       if (inherits(cond, "message")) {
[10:34:14.952]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:14.952]                         if (muffled) 
[10:34:14.952]                           invokeRestart("muffleMessage")
[10:34:14.952]                       }
[10:34:14.952]                       else if (inherits(cond, "warning")) {
[10:34:14.952]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:14.952]                         if (muffled) 
[10:34:14.952]                           invokeRestart("muffleWarning")
[10:34:14.952]                       }
[10:34:14.952]                       else if (inherits(cond, "condition")) {
[10:34:14.952]                         if (!is.null(pattern)) {
[10:34:14.952]                           computeRestarts <- base::computeRestarts
[10:34:14.952]                           grepl <- base::grepl
[10:34:14.952]                           restarts <- computeRestarts(cond)
[10:34:14.952]                           for (restart in restarts) {
[10:34:14.952]                             name <- restart$name
[10:34:14.952]                             if (is.null(name)) 
[10:34:14.952]                               next
[10:34:14.952]                             if (!grepl(pattern, name)) 
[10:34:14.952]                               next
[10:34:14.952]                             invokeRestart(restart)
[10:34:14.952]                             muffled <- TRUE
[10:34:14.952]                             break
[10:34:14.952]                           }
[10:34:14.952]                         }
[10:34:14.952]                       }
[10:34:14.952]                       invisible(muffled)
[10:34:14.952]                     }
[10:34:14.952]                     muffleCondition(cond, pattern = "^muffle")
[10:34:14.952]                   }
[10:34:14.952]                 }
[10:34:14.952]                 else {
[10:34:14.952]                   if (TRUE) {
[10:34:14.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:14.952]                     {
[10:34:14.952]                       inherits <- base::inherits
[10:34:14.952]                       invokeRestart <- base::invokeRestart
[10:34:14.952]                       is.null <- base::is.null
[10:34:14.952]                       muffled <- FALSE
[10:34:14.952]                       if (inherits(cond, "message")) {
[10:34:14.952]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:14.952]                         if (muffled) 
[10:34:14.952]                           invokeRestart("muffleMessage")
[10:34:14.952]                       }
[10:34:14.952]                       else if (inherits(cond, "warning")) {
[10:34:14.952]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:14.952]                         if (muffled) 
[10:34:14.952]                           invokeRestart("muffleWarning")
[10:34:14.952]                       }
[10:34:14.952]                       else if (inherits(cond, "condition")) {
[10:34:14.952]                         if (!is.null(pattern)) {
[10:34:14.952]                           computeRestarts <- base::computeRestarts
[10:34:14.952]                           grepl <- base::grepl
[10:34:14.952]                           restarts <- computeRestarts(cond)
[10:34:14.952]                           for (restart in restarts) {
[10:34:14.952]                             name <- restart$name
[10:34:14.952]                             if (is.null(name)) 
[10:34:14.952]                               next
[10:34:14.952]                             if (!grepl(pattern, name)) 
[10:34:14.952]                               next
[10:34:14.952]                             invokeRestart(restart)
[10:34:14.952]                             muffled <- TRUE
[10:34:14.952]                             break
[10:34:14.952]                           }
[10:34:14.952]                         }
[10:34:14.952]                       }
[10:34:14.952]                       invisible(muffled)
[10:34:14.952]                     }
[10:34:14.952]                     muffleCondition(cond, pattern = "^muffle")
[10:34:14.952]                   }
[10:34:14.952]                 }
[10:34:14.952]             }
[10:34:14.952]         }))
[10:34:14.952]     }, error = function(ex) {
[10:34:14.952]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:14.952]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:14.952]                 ...future.rng), started = ...future.startTime, 
[10:34:14.952]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:14.952]             version = "1.8"), class = "FutureResult")
[10:34:14.952]     }, finally = {
[10:34:14.952]         if (!identical(...future.workdir, getwd())) 
[10:34:14.952]             setwd(...future.workdir)
[10:34:14.952]         {
[10:34:14.952]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:14.952]                 ...future.oldOptions$nwarnings <- NULL
[10:34:14.952]             }
[10:34:14.952]             base::options(...future.oldOptions)
[10:34:14.952]             if (.Platform$OS.type == "windows") {
[10:34:14.952]                 old_names <- names(...future.oldEnvVars)
[10:34:14.952]                 envs <- base::Sys.getenv()
[10:34:14.952]                 names <- names(envs)
[10:34:14.952]                 common <- intersect(names, old_names)
[10:34:14.952]                 added <- setdiff(names, old_names)
[10:34:14.952]                 removed <- setdiff(old_names, names)
[10:34:14.952]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:14.952]                   envs[common]]
[10:34:14.952]                 NAMES <- toupper(changed)
[10:34:14.952]                 args <- list()
[10:34:14.952]                 for (kk in seq_along(NAMES)) {
[10:34:14.952]                   name <- changed[[kk]]
[10:34:14.952]                   NAME <- NAMES[[kk]]
[10:34:14.952]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:14.952]                     next
[10:34:14.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:14.952]                 }
[10:34:14.952]                 NAMES <- toupper(added)
[10:34:14.952]                 for (kk in seq_along(NAMES)) {
[10:34:14.952]                   name <- added[[kk]]
[10:34:14.952]                   NAME <- NAMES[[kk]]
[10:34:14.952]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:14.952]                     next
[10:34:14.952]                   args[[name]] <- ""
[10:34:14.952]                 }
[10:34:14.952]                 NAMES <- toupper(removed)
[10:34:14.952]                 for (kk in seq_along(NAMES)) {
[10:34:14.952]                   name <- removed[[kk]]
[10:34:14.952]                   NAME <- NAMES[[kk]]
[10:34:14.952]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:14.952]                     next
[10:34:14.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:14.952]                 }
[10:34:14.952]                 if (length(args) > 0) 
[10:34:14.952]                   base::do.call(base::Sys.setenv, args = args)
[10:34:14.952]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:14.952]             }
[10:34:14.952]             else {
[10:34:14.952]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:14.952]             }
[10:34:14.952]             {
[10:34:14.952]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:14.952]                   0L) {
[10:34:14.952]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:14.952]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:14.952]                   base::options(opts)
[10:34:14.952]                 }
[10:34:14.952]                 {
[10:34:14.952]                   {
[10:34:14.952]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:14.952]                     NULL
[10:34:14.952]                   }
[10:34:14.952]                   options(future.plan = NULL)
[10:34:14.952]                   if (is.na(NA_character_)) 
[10:34:14.952]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:14.952]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:14.952]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:14.952]                     .init = FALSE)
[10:34:14.952]                 }
[10:34:14.952]             }
[10:34:14.952]         }
[10:34:14.952]     })
[10:34:14.952]     if (TRUE) {
[10:34:14.952]         base::sink(type = "output", split = FALSE)
[10:34:14.952]         if (TRUE) {
[10:34:14.952]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:14.952]         }
[10:34:14.952]         else {
[10:34:14.952]             ...future.result["stdout"] <- base::list(NULL)
[10:34:14.952]         }
[10:34:14.952]         base::close(...future.stdout)
[10:34:14.952]         ...future.stdout <- NULL
[10:34:14.952]     }
[10:34:14.952]     ...future.result$conditions <- ...future.conditions
[10:34:14.952]     ...future.result$finished <- base::Sys.time()
[10:34:14.952]     ...future.result
[10:34:14.952] }
[10:34:14.955] MultisessionFuture started
[10:34:14.955] - Launch lazy future ... done
[10:34:14.955] run() for ‘MultisessionFuture’ ... done
[10:34:14.957] receiveMessageFromWorker() for ClusterFuture ...
[10:34:14.957] - Validating connection of MultisessionFuture
[10:34:14.957] - received message: FutureResult
[10:34:14.957] - Received FutureResult
[10:34:14.957] - Erased future from FutureRegistry
[10:34:14.957] result() for ClusterFuture ...
[10:34:14.958] - result already collected: FutureResult
[10:34:14.958] result() for ClusterFuture ... done
[10:34:14.958] signalConditions() ...
[10:34:14.958]  - include = ‘immediateCondition’
[10:34:14.958]  - exclude = 
[10:34:14.958]  - resignal = FALSE
[10:34:14.958]  - Number of conditions: 1
[10:34:14.958] signalConditions() ... done
[10:34:14.958] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:14.958] A MultisessionFuture was resolved
[10:34:14.958] getGlobalsAndPackages() ...
[10:34:14.959] Searching for globals...
[10:34:14.962] - globals found: [2] ‘list’, ‘stop’
[10:34:14.962] Searching for globals ... DONE
[10:34:14.962] Resolving globals: FALSE
[10:34:14.962] 
[10:34:14.962] 
[10:34:14.962] getGlobalsAndPackages() ... DONE
[10:34:14.963] run() for ‘Future’ ...
[10:34:14.963] - state: ‘created’
[10:34:14.963] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:14.977] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:14.977] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:14.977]   - Field: ‘node’
[10:34:14.977]   - Field: ‘label’
[10:34:14.977]   - Field: ‘local’
[10:34:14.977]   - Field: ‘owner’
[10:34:14.977]   - Field: ‘envir’
[10:34:14.977]   - Field: ‘workers’
[10:34:14.978]   - Field: ‘packages’
[10:34:14.978]   - Field: ‘gc’
[10:34:14.978]   - Field: ‘conditions’
[10:34:14.978]   - Field: ‘persistent’
[10:34:14.978]   - Field: ‘expr’
[10:34:14.978]   - Field: ‘uuid’
[10:34:14.978]   - Field: ‘seed’
[10:34:14.978]   - Field: ‘version’
[10:34:14.978]   - Field: ‘result’
[10:34:14.978]   - Field: ‘asynchronous’
[10:34:14.978]   - Field: ‘calls’
[10:34:14.978]   - Field: ‘globals’
[10:34:14.979]   - Field: ‘stdout’
[10:34:14.979]   - Field: ‘earlySignal’
[10:34:14.979]   - Field: ‘lazy’
[10:34:14.979]   - Field: ‘state’
[10:34:14.979] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:14.979] - Launch lazy future ...
[10:34:14.979] Packages needed by the future expression (n = 0): <none>
[10:34:14.979] Packages needed by future strategies (n = 0): <none>
[10:34:14.980] {
[10:34:14.980]     {
[10:34:14.980]         {
[10:34:14.980]             ...future.startTime <- base::Sys.time()
[10:34:14.980]             {
[10:34:14.980]                 {
[10:34:14.980]                   {
[10:34:14.980]                     {
[10:34:14.980]                       base::local({
[10:34:14.980]                         has_future <- base::requireNamespace("future", 
[10:34:14.980]                           quietly = TRUE)
[10:34:14.980]                         if (has_future) {
[10:34:14.980]                           ns <- base::getNamespace("future")
[10:34:14.980]                           version <- ns[[".package"]][["version"]]
[10:34:14.980]                           if (is.null(version)) 
[10:34:14.980]                             version <- utils::packageVersion("future")
[10:34:14.980]                         }
[10:34:14.980]                         else {
[10:34:14.980]                           version <- NULL
[10:34:14.980]                         }
[10:34:14.980]                         if (!has_future || version < "1.8.0") {
[10:34:14.980]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:14.980]                             "", base::R.version$version.string), 
[10:34:14.980]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:14.980]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:14.980]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:14.980]                               "release", "version")], collapse = " "), 
[10:34:14.980]                             hostname = base::Sys.info()[["nodename"]])
[10:34:14.980]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:14.980]                             info)
[10:34:14.980]                           info <- base::paste(info, collapse = "; ")
[10:34:14.980]                           if (!has_future) {
[10:34:14.980]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:14.980]                               info)
[10:34:14.980]                           }
[10:34:14.980]                           else {
[10:34:14.980]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:14.980]                               info, version)
[10:34:14.980]                           }
[10:34:14.980]                           base::stop(msg)
[10:34:14.980]                         }
[10:34:14.980]                       })
[10:34:14.980]                     }
[10:34:14.980]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:14.980]                     base::options(mc.cores = 1L)
[10:34:14.980]                   }
[10:34:14.980]                   ...future.strategy.old <- future::plan("list")
[10:34:14.980]                   options(future.plan = NULL)
[10:34:14.980]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:14.980]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:14.980]                 }
[10:34:14.980]                 ...future.workdir <- getwd()
[10:34:14.980]             }
[10:34:14.980]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:14.980]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:14.980]         }
[10:34:14.980]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:14.980]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:14.980]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:14.980]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:14.980]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:14.980]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:14.980]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:14.980]             base::names(...future.oldOptions))
[10:34:14.980]     }
[10:34:14.980]     if (FALSE) {
[10:34:14.980]     }
[10:34:14.980]     else {
[10:34:14.980]         if (TRUE) {
[10:34:14.980]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:14.980]                 open = "w")
[10:34:14.980]         }
[10:34:14.980]         else {
[10:34:14.980]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:14.980]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:14.980]         }
[10:34:14.980]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:14.980]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:14.980]             base::sink(type = "output", split = FALSE)
[10:34:14.980]             base::close(...future.stdout)
[10:34:14.980]         }, add = TRUE)
[10:34:14.980]     }
[10:34:14.980]     ...future.frame <- base::sys.nframe()
[10:34:14.980]     ...future.conditions <- base::list()
[10:34:14.980]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:14.980]     if (FALSE) {
[10:34:14.980]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:14.980]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:14.980]     }
[10:34:14.980]     ...future.result <- base::tryCatch({
[10:34:14.980]         base::withCallingHandlers({
[10:34:14.980]             ...future.value <- base::withVisible(base::local({
[10:34:14.980]                 ...future.makeSendCondition <- base::local({
[10:34:14.980]                   sendCondition <- NULL
[10:34:14.980]                   function(frame = 1L) {
[10:34:14.980]                     if (is.function(sendCondition)) 
[10:34:14.980]                       return(sendCondition)
[10:34:14.980]                     ns <- getNamespace("parallel")
[10:34:14.980]                     if (exists("sendData", mode = "function", 
[10:34:14.980]                       envir = ns)) {
[10:34:14.980]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:14.980]                         envir = ns)
[10:34:14.980]                       envir <- sys.frame(frame)
[10:34:14.980]                       master <- NULL
[10:34:14.980]                       while (!identical(envir, .GlobalEnv) && 
[10:34:14.980]                         !identical(envir, emptyenv())) {
[10:34:14.980]                         if (exists("master", mode = "list", envir = envir, 
[10:34:14.980]                           inherits = FALSE)) {
[10:34:14.980]                           master <- get("master", mode = "list", 
[10:34:14.980]                             envir = envir, inherits = FALSE)
[10:34:14.980]                           if (inherits(master, c("SOCKnode", 
[10:34:14.980]                             "SOCK0node"))) {
[10:34:14.980]                             sendCondition <<- function(cond) {
[10:34:14.980]                               data <- list(type = "VALUE", value = cond, 
[10:34:14.980]                                 success = TRUE)
[10:34:14.980]                               parallel_sendData(master, data)
[10:34:14.980]                             }
[10:34:14.980]                             return(sendCondition)
[10:34:14.980]                           }
[10:34:14.980]                         }
[10:34:14.980]                         frame <- frame + 1L
[10:34:14.980]                         envir <- sys.frame(frame)
[10:34:14.980]                       }
[10:34:14.980]                     }
[10:34:14.980]                     sendCondition <<- function(cond) NULL
[10:34:14.980]                   }
[10:34:14.980]                 })
[10:34:14.980]                 withCallingHandlers({
[10:34:14.980]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:34:14.980]                 }, immediateCondition = function(cond) {
[10:34:14.980]                   sendCondition <- ...future.makeSendCondition()
[10:34:14.980]                   sendCondition(cond)
[10:34:14.980]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:14.980]                   {
[10:34:14.980]                     inherits <- base::inherits
[10:34:14.980]                     invokeRestart <- base::invokeRestart
[10:34:14.980]                     is.null <- base::is.null
[10:34:14.980]                     muffled <- FALSE
[10:34:14.980]                     if (inherits(cond, "message")) {
[10:34:14.980]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:14.980]                       if (muffled) 
[10:34:14.980]                         invokeRestart("muffleMessage")
[10:34:14.980]                     }
[10:34:14.980]                     else if (inherits(cond, "warning")) {
[10:34:14.980]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:14.980]                       if (muffled) 
[10:34:14.980]                         invokeRestart("muffleWarning")
[10:34:14.980]                     }
[10:34:14.980]                     else if (inherits(cond, "condition")) {
[10:34:14.980]                       if (!is.null(pattern)) {
[10:34:14.980]                         computeRestarts <- base::computeRestarts
[10:34:14.980]                         grepl <- base::grepl
[10:34:14.980]                         restarts <- computeRestarts(cond)
[10:34:14.980]                         for (restart in restarts) {
[10:34:14.980]                           name <- restart$name
[10:34:14.980]                           if (is.null(name)) 
[10:34:14.980]                             next
[10:34:14.980]                           if (!grepl(pattern, name)) 
[10:34:14.980]                             next
[10:34:14.980]                           invokeRestart(restart)
[10:34:14.980]                           muffled <- TRUE
[10:34:14.980]                           break
[10:34:14.980]                         }
[10:34:14.980]                       }
[10:34:14.980]                     }
[10:34:14.980]                     invisible(muffled)
[10:34:14.980]                   }
[10:34:14.980]                   muffleCondition(cond)
[10:34:14.980]                 })
[10:34:14.980]             }))
[10:34:14.980]             future::FutureResult(value = ...future.value$value, 
[10:34:14.980]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:14.980]                   ...future.rng), globalenv = if (FALSE) 
[10:34:14.980]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:14.980]                     ...future.globalenv.names))
[10:34:14.980]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:14.980]         }, condition = base::local({
[10:34:14.980]             c <- base::c
[10:34:14.980]             inherits <- base::inherits
[10:34:14.980]             invokeRestart <- base::invokeRestart
[10:34:14.980]             length <- base::length
[10:34:14.980]             list <- base::list
[10:34:14.980]             seq.int <- base::seq.int
[10:34:14.980]             signalCondition <- base::signalCondition
[10:34:14.980]             sys.calls <- base::sys.calls
[10:34:14.980]             `[[` <- base::`[[`
[10:34:14.980]             `+` <- base::`+`
[10:34:14.980]             `<<-` <- base::`<<-`
[10:34:14.980]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:14.980]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:14.980]                   3L)]
[10:34:14.980]             }
[10:34:14.980]             function(cond) {
[10:34:14.980]                 is_error <- inherits(cond, "error")
[10:34:14.980]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:14.980]                   NULL)
[10:34:14.980]                 if (is_error) {
[10:34:14.980]                   sessionInformation <- function() {
[10:34:14.980]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:14.980]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:14.980]                       search = base::search(), system = base::Sys.info())
[10:34:14.980]                   }
[10:34:14.980]                   ...future.conditions[[length(...future.conditions) + 
[10:34:14.980]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:14.980]                     cond$call), session = sessionInformation(), 
[10:34:14.980]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:14.980]                   signalCondition(cond)
[10:34:14.980]                 }
[10:34:14.980]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:14.980]                 "immediateCondition"))) {
[10:34:14.980]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:14.980]                   ...future.conditions[[length(...future.conditions) + 
[10:34:14.980]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:14.980]                   if (TRUE && !signal) {
[10:34:14.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:14.980]                     {
[10:34:14.980]                       inherits <- base::inherits
[10:34:14.980]                       invokeRestart <- base::invokeRestart
[10:34:14.980]                       is.null <- base::is.null
[10:34:14.980]                       muffled <- FALSE
[10:34:14.980]                       if (inherits(cond, "message")) {
[10:34:14.980]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:14.980]                         if (muffled) 
[10:34:14.980]                           invokeRestart("muffleMessage")
[10:34:14.980]                       }
[10:34:14.980]                       else if (inherits(cond, "warning")) {
[10:34:14.980]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:14.980]                         if (muffled) 
[10:34:14.980]                           invokeRestart("muffleWarning")
[10:34:14.980]                       }
[10:34:14.980]                       else if (inherits(cond, "condition")) {
[10:34:14.980]                         if (!is.null(pattern)) {
[10:34:14.980]                           computeRestarts <- base::computeRestarts
[10:34:14.980]                           grepl <- base::grepl
[10:34:14.980]                           restarts <- computeRestarts(cond)
[10:34:14.980]                           for (restart in restarts) {
[10:34:14.980]                             name <- restart$name
[10:34:14.980]                             if (is.null(name)) 
[10:34:14.980]                               next
[10:34:14.980]                             if (!grepl(pattern, name)) 
[10:34:14.980]                               next
[10:34:14.980]                             invokeRestart(restart)
[10:34:14.980]                             muffled <- TRUE
[10:34:14.980]                             break
[10:34:14.980]                           }
[10:34:14.980]                         }
[10:34:14.980]                       }
[10:34:14.980]                       invisible(muffled)
[10:34:14.980]                     }
[10:34:14.980]                     muffleCondition(cond, pattern = "^muffle")
[10:34:14.980]                   }
[10:34:14.980]                 }
[10:34:14.980]                 else {
[10:34:14.980]                   if (TRUE) {
[10:34:14.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:14.980]                     {
[10:34:14.980]                       inherits <- base::inherits
[10:34:14.980]                       invokeRestart <- base::invokeRestart
[10:34:14.980]                       is.null <- base::is.null
[10:34:14.980]                       muffled <- FALSE
[10:34:14.980]                       if (inherits(cond, "message")) {
[10:34:14.980]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:14.980]                         if (muffled) 
[10:34:14.980]                           invokeRestart("muffleMessage")
[10:34:14.980]                       }
[10:34:14.980]                       else if (inherits(cond, "warning")) {
[10:34:14.980]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:14.980]                         if (muffled) 
[10:34:14.980]                           invokeRestart("muffleWarning")
[10:34:14.980]                       }
[10:34:14.980]                       else if (inherits(cond, "condition")) {
[10:34:14.980]                         if (!is.null(pattern)) {
[10:34:14.980]                           computeRestarts <- base::computeRestarts
[10:34:14.980]                           grepl <- base::grepl
[10:34:14.980]                           restarts <- computeRestarts(cond)
[10:34:14.980]                           for (restart in restarts) {
[10:34:14.980]                             name <- restart$name
[10:34:14.980]                             if (is.null(name)) 
[10:34:14.980]                               next
[10:34:14.980]                             if (!grepl(pattern, name)) 
[10:34:14.980]                               next
[10:34:14.980]                             invokeRestart(restart)
[10:34:14.980]                             muffled <- TRUE
[10:34:14.980]                             break
[10:34:14.980]                           }
[10:34:14.980]                         }
[10:34:14.980]                       }
[10:34:14.980]                       invisible(muffled)
[10:34:14.980]                     }
[10:34:14.980]                     muffleCondition(cond, pattern = "^muffle")
[10:34:14.980]                   }
[10:34:14.980]                 }
[10:34:14.980]             }
[10:34:14.980]         }))
[10:34:14.980]     }, error = function(ex) {
[10:34:14.980]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:14.980]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:14.980]                 ...future.rng), started = ...future.startTime, 
[10:34:14.980]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:14.980]             version = "1.8"), class = "FutureResult")
[10:34:14.980]     }, finally = {
[10:34:14.980]         if (!identical(...future.workdir, getwd())) 
[10:34:14.980]             setwd(...future.workdir)
[10:34:14.980]         {
[10:34:14.980]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:14.980]                 ...future.oldOptions$nwarnings <- NULL
[10:34:14.980]             }
[10:34:14.980]             base::options(...future.oldOptions)
[10:34:14.980]             if (.Platform$OS.type == "windows") {
[10:34:14.980]                 old_names <- names(...future.oldEnvVars)
[10:34:14.980]                 envs <- base::Sys.getenv()
[10:34:14.980]                 names <- names(envs)
[10:34:14.980]                 common <- intersect(names, old_names)
[10:34:14.980]                 added <- setdiff(names, old_names)
[10:34:14.980]                 removed <- setdiff(old_names, names)
[10:34:14.980]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:14.980]                   envs[common]]
[10:34:14.980]                 NAMES <- toupper(changed)
[10:34:14.980]                 args <- list()
[10:34:14.980]                 for (kk in seq_along(NAMES)) {
[10:34:14.980]                   name <- changed[[kk]]
[10:34:14.980]                   NAME <- NAMES[[kk]]
[10:34:14.980]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:14.980]                     next
[10:34:14.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:14.980]                 }
[10:34:14.980]                 NAMES <- toupper(added)
[10:34:14.980]                 for (kk in seq_along(NAMES)) {
[10:34:14.980]                   name <- added[[kk]]
[10:34:14.980]                   NAME <- NAMES[[kk]]
[10:34:14.980]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:14.980]                     next
[10:34:14.980]                   args[[name]] <- ""
[10:34:14.980]                 }
[10:34:14.980]                 NAMES <- toupper(removed)
[10:34:14.980]                 for (kk in seq_along(NAMES)) {
[10:34:14.980]                   name <- removed[[kk]]
[10:34:14.980]                   NAME <- NAMES[[kk]]
[10:34:14.980]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:14.980]                     next
[10:34:14.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:14.980]                 }
[10:34:14.980]                 if (length(args) > 0) 
[10:34:14.980]                   base::do.call(base::Sys.setenv, args = args)
[10:34:14.980]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:14.980]             }
[10:34:14.980]             else {
[10:34:14.980]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:14.980]             }
[10:34:14.980]             {
[10:34:14.980]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:14.980]                   0L) {
[10:34:14.980]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:14.980]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:14.980]                   base::options(opts)
[10:34:14.980]                 }
[10:34:14.980]                 {
[10:34:14.980]                   {
[10:34:14.980]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:14.980]                     NULL
[10:34:14.980]                   }
[10:34:14.980]                   options(future.plan = NULL)
[10:34:14.980]                   if (is.na(NA_character_)) 
[10:34:14.980]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:14.980]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:14.980]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:14.980]                     .init = FALSE)
[10:34:14.980]                 }
[10:34:14.980]             }
[10:34:14.980]         }
[10:34:14.980]     })
[10:34:14.980]     if (TRUE) {
[10:34:14.980]         base::sink(type = "output", split = FALSE)
[10:34:14.980]         if (TRUE) {
[10:34:14.980]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:14.980]         }
[10:34:14.980]         else {
[10:34:14.980]             ...future.result["stdout"] <- base::list(NULL)
[10:34:14.980]         }
[10:34:14.980]         base::close(...future.stdout)
[10:34:14.980]         ...future.stdout <- NULL
[10:34:14.980]     }
[10:34:14.980]     ...future.result$conditions <- ...future.conditions
[10:34:14.980]     ...future.result$finished <- base::Sys.time()
[10:34:14.980]     ...future.result
[10:34:14.980] }
[10:34:14.983] MultisessionFuture started
[10:34:14.983] - Launch lazy future ... done
[10:34:14.983] run() for ‘MultisessionFuture’ ... done
[10:34:14.984] receiveMessageFromWorker() for ClusterFuture ...
[10:34:14.984] - Validating connection of MultisessionFuture
[10:34:14.985] - received message: FutureResult
[10:34:14.985] - Received FutureResult
[10:34:14.985] - Erased future from FutureRegistry
[10:34:14.985] result() for ClusterFuture ...
[10:34:14.985] - result already collected: FutureResult
[10:34:14.985] result() for ClusterFuture ... done
[10:34:14.985] signalConditions() ...
[10:34:14.985]  - include = ‘immediateCondition’
[10:34:14.985]  - exclude = 
[10:34:14.985]  - resignal = FALSE
[10:34:14.986]  - Number of conditions: 1
[10:34:14.986] signalConditions() ... done
[10:34:14.986] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:14.986] A MultisessionFuture was resolved
- result = TRUE, recursive = 2 ... DONE
- result = TRUE, recursive = Inf ...
[10:34:14.986] getGlobalsAndPackages() ...
[10:34:14.986] Searching for globals...
[10:34:14.987] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:34:14.987] Searching for globals ... DONE
[10:34:14.987] Resolving globals: FALSE
[10:34:14.988] 
[10:34:14.988] 
[10:34:14.988] getGlobalsAndPackages() ... DONE
[10:34:14.988] run() for ‘Future’ ...
[10:34:14.988] - state: ‘created’
[10:34:14.988] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:15.002] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:15.002] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:15.002]   - Field: ‘node’
[10:34:15.002]   - Field: ‘label’
[10:34:15.002]   - Field: ‘local’
[10:34:15.002]   - Field: ‘owner’
[10:34:15.002]   - Field: ‘envir’
[10:34:15.002]   - Field: ‘workers’
[10:34:15.002]   - Field: ‘packages’
[10:34:15.003]   - Field: ‘gc’
[10:34:15.003]   - Field: ‘conditions’
[10:34:15.003]   - Field: ‘persistent’
[10:34:15.003]   - Field: ‘expr’
[10:34:15.003]   - Field: ‘uuid’
[10:34:15.003]   - Field: ‘seed’
[10:34:15.003]   - Field: ‘version’
[10:34:15.003]   - Field: ‘result’
[10:34:15.003]   - Field: ‘asynchronous’
[10:34:15.003]   - Field: ‘calls’
[10:34:15.003]   - Field: ‘globals’
[10:34:15.003]   - Field: ‘stdout’
[10:34:15.004]   - Field: ‘earlySignal’
[10:34:15.004]   - Field: ‘lazy’
[10:34:15.004]   - Field: ‘state’
[10:34:15.004] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:15.004] - Launch lazy future ...
[10:34:15.004] Packages needed by the future expression (n = 0): <none>
[10:34:15.004] Packages needed by future strategies (n = 0): <none>
[10:34:15.005] {
[10:34:15.005]     {
[10:34:15.005]         {
[10:34:15.005]             ...future.startTime <- base::Sys.time()
[10:34:15.005]             {
[10:34:15.005]                 {
[10:34:15.005]                   {
[10:34:15.005]                     {
[10:34:15.005]                       base::local({
[10:34:15.005]                         has_future <- base::requireNamespace("future", 
[10:34:15.005]                           quietly = TRUE)
[10:34:15.005]                         if (has_future) {
[10:34:15.005]                           ns <- base::getNamespace("future")
[10:34:15.005]                           version <- ns[[".package"]][["version"]]
[10:34:15.005]                           if (is.null(version)) 
[10:34:15.005]                             version <- utils::packageVersion("future")
[10:34:15.005]                         }
[10:34:15.005]                         else {
[10:34:15.005]                           version <- NULL
[10:34:15.005]                         }
[10:34:15.005]                         if (!has_future || version < "1.8.0") {
[10:34:15.005]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:15.005]                             "", base::R.version$version.string), 
[10:34:15.005]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:15.005]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:15.005]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:15.005]                               "release", "version")], collapse = " "), 
[10:34:15.005]                             hostname = base::Sys.info()[["nodename"]])
[10:34:15.005]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:15.005]                             info)
[10:34:15.005]                           info <- base::paste(info, collapse = "; ")
[10:34:15.005]                           if (!has_future) {
[10:34:15.005]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:15.005]                               info)
[10:34:15.005]                           }
[10:34:15.005]                           else {
[10:34:15.005]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:15.005]                               info, version)
[10:34:15.005]                           }
[10:34:15.005]                           base::stop(msg)
[10:34:15.005]                         }
[10:34:15.005]                       })
[10:34:15.005]                     }
[10:34:15.005]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:15.005]                     base::options(mc.cores = 1L)
[10:34:15.005]                   }
[10:34:15.005]                   ...future.strategy.old <- future::plan("list")
[10:34:15.005]                   options(future.plan = NULL)
[10:34:15.005]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:15.005]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:15.005]                 }
[10:34:15.005]                 ...future.workdir <- getwd()
[10:34:15.005]             }
[10:34:15.005]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:15.005]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:15.005]         }
[10:34:15.005]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:15.005]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:15.005]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:15.005]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:15.005]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:15.005]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:15.005]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:15.005]             base::names(...future.oldOptions))
[10:34:15.005]     }
[10:34:15.005]     if (FALSE) {
[10:34:15.005]     }
[10:34:15.005]     else {
[10:34:15.005]         if (TRUE) {
[10:34:15.005]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:15.005]                 open = "w")
[10:34:15.005]         }
[10:34:15.005]         else {
[10:34:15.005]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:15.005]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:15.005]         }
[10:34:15.005]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:15.005]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:15.005]             base::sink(type = "output", split = FALSE)
[10:34:15.005]             base::close(...future.stdout)
[10:34:15.005]         }, add = TRUE)
[10:34:15.005]     }
[10:34:15.005]     ...future.frame <- base::sys.nframe()
[10:34:15.005]     ...future.conditions <- base::list()
[10:34:15.005]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:15.005]     if (FALSE) {
[10:34:15.005]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:15.005]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:15.005]     }
[10:34:15.005]     ...future.result <- base::tryCatch({
[10:34:15.005]         base::withCallingHandlers({
[10:34:15.005]             ...future.value <- base::withVisible(base::local({
[10:34:15.005]                 ...future.makeSendCondition <- base::local({
[10:34:15.005]                   sendCondition <- NULL
[10:34:15.005]                   function(frame = 1L) {
[10:34:15.005]                     if (is.function(sendCondition)) 
[10:34:15.005]                       return(sendCondition)
[10:34:15.005]                     ns <- getNamespace("parallel")
[10:34:15.005]                     if (exists("sendData", mode = "function", 
[10:34:15.005]                       envir = ns)) {
[10:34:15.005]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:15.005]                         envir = ns)
[10:34:15.005]                       envir <- sys.frame(frame)
[10:34:15.005]                       master <- NULL
[10:34:15.005]                       while (!identical(envir, .GlobalEnv) && 
[10:34:15.005]                         !identical(envir, emptyenv())) {
[10:34:15.005]                         if (exists("master", mode = "list", envir = envir, 
[10:34:15.005]                           inherits = FALSE)) {
[10:34:15.005]                           master <- get("master", mode = "list", 
[10:34:15.005]                             envir = envir, inherits = FALSE)
[10:34:15.005]                           if (inherits(master, c("SOCKnode", 
[10:34:15.005]                             "SOCK0node"))) {
[10:34:15.005]                             sendCondition <<- function(cond) {
[10:34:15.005]                               data <- list(type = "VALUE", value = cond, 
[10:34:15.005]                                 success = TRUE)
[10:34:15.005]                               parallel_sendData(master, data)
[10:34:15.005]                             }
[10:34:15.005]                             return(sendCondition)
[10:34:15.005]                           }
[10:34:15.005]                         }
[10:34:15.005]                         frame <- frame + 1L
[10:34:15.005]                         envir <- sys.frame(frame)
[10:34:15.005]                       }
[10:34:15.005]                     }
[10:34:15.005]                     sendCondition <<- function(cond) NULL
[10:34:15.005]                   }
[10:34:15.005]                 })
[10:34:15.005]                 withCallingHandlers({
[10:34:15.005]                   {
[10:34:15.005]                     Sys.sleep(0.5)
[10:34:15.005]                     list(a = 1, b = 42L)
[10:34:15.005]                   }
[10:34:15.005]                 }, immediateCondition = function(cond) {
[10:34:15.005]                   sendCondition <- ...future.makeSendCondition()
[10:34:15.005]                   sendCondition(cond)
[10:34:15.005]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:15.005]                   {
[10:34:15.005]                     inherits <- base::inherits
[10:34:15.005]                     invokeRestart <- base::invokeRestart
[10:34:15.005]                     is.null <- base::is.null
[10:34:15.005]                     muffled <- FALSE
[10:34:15.005]                     if (inherits(cond, "message")) {
[10:34:15.005]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:15.005]                       if (muffled) 
[10:34:15.005]                         invokeRestart("muffleMessage")
[10:34:15.005]                     }
[10:34:15.005]                     else if (inherits(cond, "warning")) {
[10:34:15.005]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:15.005]                       if (muffled) 
[10:34:15.005]                         invokeRestart("muffleWarning")
[10:34:15.005]                     }
[10:34:15.005]                     else if (inherits(cond, "condition")) {
[10:34:15.005]                       if (!is.null(pattern)) {
[10:34:15.005]                         computeRestarts <- base::computeRestarts
[10:34:15.005]                         grepl <- base::grepl
[10:34:15.005]                         restarts <- computeRestarts(cond)
[10:34:15.005]                         for (restart in restarts) {
[10:34:15.005]                           name <- restart$name
[10:34:15.005]                           if (is.null(name)) 
[10:34:15.005]                             next
[10:34:15.005]                           if (!grepl(pattern, name)) 
[10:34:15.005]                             next
[10:34:15.005]                           invokeRestart(restart)
[10:34:15.005]                           muffled <- TRUE
[10:34:15.005]                           break
[10:34:15.005]                         }
[10:34:15.005]                       }
[10:34:15.005]                     }
[10:34:15.005]                     invisible(muffled)
[10:34:15.005]                   }
[10:34:15.005]                   muffleCondition(cond)
[10:34:15.005]                 })
[10:34:15.005]             }))
[10:34:15.005]             future::FutureResult(value = ...future.value$value, 
[10:34:15.005]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:15.005]                   ...future.rng), globalenv = if (FALSE) 
[10:34:15.005]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:15.005]                     ...future.globalenv.names))
[10:34:15.005]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:15.005]         }, condition = base::local({
[10:34:15.005]             c <- base::c
[10:34:15.005]             inherits <- base::inherits
[10:34:15.005]             invokeRestart <- base::invokeRestart
[10:34:15.005]             length <- base::length
[10:34:15.005]             list <- base::list
[10:34:15.005]             seq.int <- base::seq.int
[10:34:15.005]             signalCondition <- base::signalCondition
[10:34:15.005]             sys.calls <- base::sys.calls
[10:34:15.005]             `[[` <- base::`[[`
[10:34:15.005]             `+` <- base::`+`
[10:34:15.005]             `<<-` <- base::`<<-`
[10:34:15.005]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:15.005]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:15.005]                   3L)]
[10:34:15.005]             }
[10:34:15.005]             function(cond) {
[10:34:15.005]                 is_error <- inherits(cond, "error")
[10:34:15.005]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:15.005]                   NULL)
[10:34:15.005]                 if (is_error) {
[10:34:15.005]                   sessionInformation <- function() {
[10:34:15.005]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:15.005]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:15.005]                       search = base::search(), system = base::Sys.info())
[10:34:15.005]                   }
[10:34:15.005]                   ...future.conditions[[length(...future.conditions) + 
[10:34:15.005]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:15.005]                     cond$call), session = sessionInformation(), 
[10:34:15.005]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:15.005]                   signalCondition(cond)
[10:34:15.005]                 }
[10:34:15.005]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:15.005]                 "immediateCondition"))) {
[10:34:15.005]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:15.005]                   ...future.conditions[[length(...future.conditions) + 
[10:34:15.005]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:15.005]                   if (TRUE && !signal) {
[10:34:15.005]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:15.005]                     {
[10:34:15.005]                       inherits <- base::inherits
[10:34:15.005]                       invokeRestart <- base::invokeRestart
[10:34:15.005]                       is.null <- base::is.null
[10:34:15.005]                       muffled <- FALSE
[10:34:15.005]                       if (inherits(cond, "message")) {
[10:34:15.005]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:15.005]                         if (muffled) 
[10:34:15.005]                           invokeRestart("muffleMessage")
[10:34:15.005]                       }
[10:34:15.005]                       else if (inherits(cond, "warning")) {
[10:34:15.005]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:15.005]                         if (muffled) 
[10:34:15.005]                           invokeRestart("muffleWarning")
[10:34:15.005]                       }
[10:34:15.005]                       else if (inherits(cond, "condition")) {
[10:34:15.005]                         if (!is.null(pattern)) {
[10:34:15.005]                           computeRestarts <- base::computeRestarts
[10:34:15.005]                           grepl <- base::grepl
[10:34:15.005]                           restarts <- computeRestarts(cond)
[10:34:15.005]                           for (restart in restarts) {
[10:34:15.005]                             name <- restart$name
[10:34:15.005]                             if (is.null(name)) 
[10:34:15.005]                               next
[10:34:15.005]                             if (!grepl(pattern, name)) 
[10:34:15.005]                               next
[10:34:15.005]                             invokeRestart(restart)
[10:34:15.005]                             muffled <- TRUE
[10:34:15.005]                             break
[10:34:15.005]                           }
[10:34:15.005]                         }
[10:34:15.005]                       }
[10:34:15.005]                       invisible(muffled)
[10:34:15.005]                     }
[10:34:15.005]                     muffleCondition(cond, pattern = "^muffle")
[10:34:15.005]                   }
[10:34:15.005]                 }
[10:34:15.005]                 else {
[10:34:15.005]                   if (TRUE) {
[10:34:15.005]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:15.005]                     {
[10:34:15.005]                       inherits <- base::inherits
[10:34:15.005]                       invokeRestart <- base::invokeRestart
[10:34:15.005]                       is.null <- base::is.null
[10:34:15.005]                       muffled <- FALSE
[10:34:15.005]                       if (inherits(cond, "message")) {
[10:34:15.005]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:15.005]                         if (muffled) 
[10:34:15.005]                           invokeRestart("muffleMessage")
[10:34:15.005]                       }
[10:34:15.005]                       else if (inherits(cond, "warning")) {
[10:34:15.005]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:15.005]                         if (muffled) 
[10:34:15.005]                           invokeRestart("muffleWarning")
[10:34:15.005]                       }
[10:34:15.005]                       else if (inherits(cond, "condition")) {
[10:34:15.005]                         if (!is.null(pattern)) {
[10:34:15.005]                           computeRestarts <- base::computeRestarts
[10:34:15.005]                           grepl <- base::grepl
[10:34:15.005]                           restarts <- computeRestarts(cond)
[10:34:15.005]                           for (restart in restarts) {
[10:34:15.005]                             name <- restart$name
[10:34:15.005]                             if (is.null(name)) 
[10:34:15.005]                               next
[10:34:15.005]                             if (!grepl(pattern, name)) 
[10:34:15.005]                               next
[10:34:15.005]                             invokeRestart(restart)
[10:34:15.005]                             muffled <- TRUE
[10:34:15.005]                             break
[10:34:15.005]                           }
[10:34:15.005]                         }
[10:34:15.005]                       }
[10:34:15.005]                       invisible(muffled)
[10:34:15.005]                     }
[10:34:15.005]                     muffleCondition(cond, pattern = "^muffle")
[10:34:15.005]                   }
[10:34:15.005]                 }
[10:34:15.005]             }
[10:34:15.005]         }))
[10:34:15.005]     }, error = function(ex) {
[10:34:15.005]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:15.005]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:15.005]                 ...future.rng), started = ...future.startTime, 
[10:34:15.005]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:15.005]             version = "1.8"), class = "FutureResult")
[10:34:15.005]     }, finally = {
[10:34:15.005]         if (!identical(...future.workdir, getwd())) 
[10:34:15.005]             setwd(...future.workdir)
[10:34:15.005]         {
[10:34:15.005]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:15.005]                 ...future.oldOptions$nwarnings <- NULL
[10:34:15.005]             }
[10:34:15.005]             base::options(...future.oldOptions)
[10:34:15.005]             if (.Platform$OS.type == "windows") {
[10:34:15.005]                 old_names <- names(...future.oldEnvVars)
[10:34:15.005]                 envs <- base::Sys.getenv()
[10:34:15.005]                 names <- names(envs)
[10:34:15.005]                 common <- intersect(names, old_names)
[10:34:15.005]                 added <- setdiff(names, old_names)
[10:34:15.005]                 removed <- setdiff(old_names, names)
[10:34:15.005]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:15.005]                   envs[common]]
[10:34:15.005]                 NAMES <- toupper(changed)
[10:34:15.005]                 args <- list()
[10:34:15.005]                 for (kk in seq_along(NAMES)) {
[10:34:15.005]                   name <- changed[[kk]]
[10:34:15.005]                   NAME <- NAMES[[kk]]
[10:34:15.005]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:15.005]                     next
[10:34:15.005]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:15.005]                 }
[10:34:15.005]                 NAMES <- toupper(added)
[10:34:15.005]                 for (kk in seq_along(NAMES)) {
[10:34:15.005]                   name <- added[[kk]]
[10:34:15.005]                   NAME <- NAMES[[kk]]
[10:34:15.005]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:15.005]                     next
[10:34:15.005]                   args[[name]] <- ""
[10:34:15.005]                 }
[10:34:15.005]                 NAMES <- toupper(removed)
[10:34:15.005]                 for (kk in seq_along(NAMES)) {
[10:34:15.005]                   name <- removed[[kk]]
[10:34:15.005]                   NAME <- NAMES[[kk]]
[10:34:15.005]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:15.005]                     next
[10:34:15.005]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:15.005]                 }
[10:34:15.005]                 if (length(args) > 0) 
[10:34:15.005]                   base::do.call(base::Sys.setenv, args = args)
[10:34:15.005]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:15.005]             }
[10:34:15.005]             else {
[10:34:15.005]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:15.005]             }
[10:34:15.005]             {
[10:34:15.005]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:15.005]                   0L) {
[10:34:15.005]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:15.005]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:15.005]                   base::options(opts)
[10:34:15.005]                 }
[10:34:15.005]                 {
[10:34:15.005]                   {
[10:34:15.005]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:15.005]                     NULL
[10:34:15.005]                   }
[10:34:15.005]                   options(future.plan = NULL)
[10:34:15.005]                   if (is.na(NA_character_)) 
[10:34:15.005]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:15.005]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:15.005]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:15.005]                     .init = FALSE)
[10:34:15.005]                 }
[10:34:15.005]             }
[10:34:15.005]         }
[10:34:15.005]     })
[10:34:15.005]     if (TRUE) {
[10:34:15.005]         base::sink(type = "output", split = FALSE)
[10:34:15.005]         if (TRUE) {
[10:34:15.005]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:15.005]         }
[10:34:15.005]         else {
[10:34:15.005]             ...future.result["stdout"] <- base::list(NULL)
[10:34:15.005]         }
[10:34:15.005]         base::close(...future.stdout)
[10:34:15.005]         ...future.stdout <- NULL
[10:34:15.005]     }
[10:34:15.005]     ...future.result$conditions <- ...future.conditions
[10:34:15.005]     ...future.result$finished <- base::Sys.time()
[10:34:15.005]     ...future.result
[10:34:15.005] }
[10:34:15.007] MultisessionFuture started
[10:34:15.008] - Launch lazy future ... done
[10:34:15.008] run() for ‘MultisessionFuture’ ... done
[10:34:15.510] receiveMessageFromWorker() for ClusterFuture ...
[10:34:15.510] - Validating connection of MultisessionFuture
[10:34:15.510] - received message: FutureResult
[10:34:15.510] - Received FutureResult
[10:34:15.510] - Erased future from FutureRegistry
[10:34:15.511] result() for ClusterFuture ...
[10:34:15.511] - result already collected: FutureResult
[10:34:15.511] result() for ClusterFuture ... done
[10:34:15.511] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:15.511] resolve() on list ...
[10:34:15.511]  recursive: Inf
[10:34:15.511]  length: 2
[10:34:15.511]  elements: ‘a’, ‘b’
[10:34:15.511]  length: 1 (resolved future 1)
[10:34:15.511]  length: 0 (resolved future 2)
[10:34:15.512] resolve() on list ... DONE
[10:34:15.512] A MultisessionFuture was resolved (and resolved itself)
[10:34:15.512] getGlobalsAndPackages() ...
[10:34:15.512] Searching for globals...
[10:34:15.513] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:34:15.513] Searching for globals ... DONE
[10:34:15.513] Resolving globals: FALSE
[10:34:15.514] 
[10:34:15.514] 
[10:34:15.514] getGlobalsAndPackages() ... DONE
[10:34:15.514] run() for ‘Future’ ...
[10:34:15.514] - state: ‘created’
[10:34:15.514] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:15.528] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:15.528] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:15.528]   - Field: ‘node’
[10:34:15.529]   - Field: ‘label’
[10:34:15.529]   - Field: ‘local’
[10:34:15.529]   - Field: ‘owner’
[10:34:15.529]   - Field: ‘envir’
[10:34:15.529]   - Field: ‘workers’
[10:34:15.529]   - Field: ‘packages’
[10:34:15.529]   - Field: ‘gc’
[10:34:15.529]   - Field: ‘conditions’
[10:34:15.529]   - Field: ‘persistent’
[10:34:15.530]   - Field: ‘expr’
[10:34:15.530]   - Field: ‘uuid’
[10:34:15.530]   - Field: ‘seed’
[10:34:15.530]   - Field: ‘version’
[10:34:15.530]   - Field: ‘result’
[10:34:15.530]   - Field: ‘asynchronous’
[10:34:15.530]   - Field: ‘calls’
[10:34:15.530]   - Field: ‘globals’
[10:34:15.530]   - Field: ‘stdout’
[10:34:15.530]   - Field: ‘earlySignal’
[10:34:15.530]   - Field: ‘lazy’
[10:34:15.531]   - Field: ‘state’
[10:34:15.531] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:15.531] - Launch lazy future ...
[10:34:15.531] Packages needed by the future expression (n = 0): <none>
[10:34:15.531] Packages needed by future strategies (n = 0): <none>
[10:34:15.532] {
[10:34:15.532]     {
[10:34:15.532]         {
[10:34:15.532]             ...future.startTime <- base::Sys.time()
[10:34:15.532]             {
[10:34:15.532]                 {
[10:34:15.532]                   {
[10:34:15.532]                     {
[10:34:15.532]                       base::local({
[10:34:15.532]                         has_future <- base::requireNamespace("future", 
[10:34:15.532]                           quietly = TRUE)
[10:34:15.532]                         if (has_future) {
[10:34:15.532]                           ns <- base::getNamespace("future")
[10:34:15.532]                           version <- ns[[".package"]][["version"]]
[10:34:15.532]                           if (is.null(version)) 
[10:34:15.532]                             version <- utils::packageVersion("future")
[10:34:15.532]                         }
[10:34:15.532]                         else {
[10:34:15.532]                           version <- NULL
[10:34:15.532]                         }
[10:34:15.532]                         if (!has_future || version < "1.8.0") {
[10:34:15.532]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:15.532]                             "", base::R.version$version.string), 
[10:34:15.532]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:15.532]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:15.532]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:15.532]                               "release", "version")], collapse = " "), 
[10:34:15.532]                             hostname = base::Sys.info()[["nodename"]])
[10:34:15.532]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:15.532]                             info)
[10:34:15.532]                           info <- base::paste(info, collapse = "; ")
[10:34:15.532]                           if (!has_future) {
[10:34:15.532]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:15.532]                               info)
[10:34:15.532]                           }
[10:34:15.532]                           else {
[10:34:15.532]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:15.532]                               info, version)
[10:34:15.532]                           }
[10:34:15.532]                           base::stop(msg)
[10:34:15.532]                         }
[10:34:15.532]                       })
[10:34:15.532]                     }
[10:34:15.532]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:15.532]                     base::options(mc.cores = 1L)
[10:34:15.532]                   }
[10:34:15.532]                   ...future.strategy.old <- future::plan("list")
[10:34:15.532]                   options(future.plan = NULL)
[10:34:15.532]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:15.532]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:15.532]                 }
[10:34:15.532]                 ...future.workdir <- getwd()
[10:34:15.532]             }
[10:34:15.532]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:15.532]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:15.532]         }
[10:34:15.532]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:15.532]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:15.532]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:15.532]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:15.532]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:15.532]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:15.532]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:15.532]             base::names(...future.oldOptions))
[10:34:15.532]     }
[10:34:15.532]     if (FALSE) {
[10:34:15.532]     }
[10:34:15.532]     else {
[10:34:15.532]         if (TRUE) {
[10:34:15.532]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:15.532]                 open = "w")
[10:34:15.532]         }
[10:34:15.532]         else {
[10:34:15.532]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:15.532]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:15.532]         }
[10:34:15.532]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:15.532]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:15.532]             base::sink(type = "output", split = FALSE)
[10:34:15.532]             base::close(...future.stdout)
[10:34:15.532]         }, add = TRUE)
[10:34:15.532]     }
[10:34:15.532]     ...future.frame <- base::sys.nframe()
[10:34:15.532]     ...future.conditions <- base::list()
[10:34:15.532]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:15.532]     if (FALSE) {
[10:34:15.532]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:15.532]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:15.532]     }
[10:34:15.532]     ...future.result <- base::tryCatch({
[10:34:15.532]         base::withCallingHandlers({
[10:34:15.532]             ...future.value <- base::withVisible(base::local({
[10:34:15.532]                 ...future.makeSendCondition <- base::local({
[10:34:15.532]                   sendCondition <- NULL
[10:34:15.532]                   function(frame = 1L) {
[10:34:15.532]                     if (is.function(sendCondition)) 
[10:34:15.532]                       return(sendCondition)
[10:34:15.532]                     ns <- getNamespace("parallel")
[10:34:15.532]                     if (exists("sendData", mode = "function", 
[10:34:15.532]                       envir = ns)) {
[10:34:15.532]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:15.532]                         envir = ns)
[10:34:15.532]                       envir <- sys.frame(frame)
[10:34:15.532]                       master <- NULL
[10:34:15.532]                       while (!identical(envir, .GlobalEnv) && 
[10:34:15.532]                         !identical(envir, emptyenv())) {
[10:34:15.532]                         if (exists("master", mode = "list", envir = envir, 
[10:34:15.532]                           inherits = FALSE)) {
[10:34:15.532]                           master <- get("master", mode = "list", 
[10:34:15.532]                             envir = envir, inherits = FALSE)
[10:34:15.532]                           if (inherits(master, c("SOCKnode", 
[10:34:15.532]                             "SOCK0node"))) {
[10:34:15.532]                             sendCondition <<- function(cond) {
[10:34:15.532]                               data <- list(type = "VALUE", value = cond, 
[10:34:15.532]                                 success = TRUE)
[10:34:15.532]                               parallel_sendData(master, data)
[10:34:15.532]                             }
[10:34:15.532]                             return(sendCondition)
[10:34:15.532]                           }
[10:34:15.532]                         }
[10:34:15.532]                         frame <- frame + 1L
[10:34:15.532]                         envir <- sys.frame(frame)
[10:34:15.532]                       }
[10:34:15.532]                     }
[10:34:15.532]                     sendCondition <<- function(cond) NULL
[10:34:15.532]                   }
[10:34:15.532]                 })
[10:34:15.532]                 withCallingHandlers({
[10:34:15.532]                   {
[10:34:15.532]                     Sys.sleep(0.5)
[10:34:15.532]                     list(a = 1, b = 42L)
[10:34:15.532]                   }
[10:34:15.532]                 }, immediateCondition = function(cond) {
[10:34:15.532]                   sendCondition <- ...future.makeSendCondition()
[10:34:15.532]                   sendCondition(cond)
[10:34:15.532]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:15.532]                   {
[10:34:15.532]                     inherits <- base::inherits
[10:34:15.532]                     invokeRestart <- base::invokeRestart
[10:34:15.532]                     is.null <- base::is.null
[10:34:15.532]                     muffled <- FALSE
[10:34:15.532]                     if (inherits(cond, "message")) {
[10:34:15.532]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:15.532]                       if (muffled) 
[10:34:15.532]                         invokeRestart("muffleMessage")
[10:34:15.532]                     }
[10:34:15.532]                     else if (inherits(cond, "warning")) {
[10:34:15.532]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:15.532]                       if (muffled) 
[10:34:15.532]                         invokeRestart("muffleWarning")
[10:34:15.532]                     }
[10:34:15.532]                     else if (inherits(cond, "condition")) {
[10:34:15.532]                       if (!is.null(pattern)) {
[10:34:15.532]                         computeRestarts <- base::computeRestarts
[10:34:15.532]                         grepl <- base::grepl
[10:34:15.532]                         restarts <- computeRestarts(cond)
[10:34:15.532]                         for (restart in restarts) {
[10:34:15.532]                           name <- restart$name
[10:34:15.532]                           if (is.null(name)) 
[10:34:15.532]                             next
[10:34:15.532]                           if (!grepl(pattern, name)) 
[10:34:15.532]                             next
[10:34:15.532]                           invokeRestart(restart)
[10:34:15.532]                           muffled <- TRUE
[10:34:15.532]                           break
[10:34:15.532]                         }
[10:34:15.532]                       }
[10:34:15.532]                     }
[10:34:15.532]                     invisible(muffled)
[10:34:15.532]                   }
[10:34:15.532]                   muffleCondition(cond)
[10:34:15.532]                 })
[10:34:15.532]             }))
[10:34:15.532]             future::FutureResult(value = ...future.value$value, 
[10:34:15.532]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:15.532]                   ...future.rng), globalenv = if (FALSE) 
[10:34:15.532]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:15.532]                     ...future.globalenv.names))
[10:34:15.532]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:15.532]         }, condition = base::local({
[10:34:15.532]             c <- base::c
[10:34:15.532]             inherits <- base::inherits
[10:34:15.532]             invokeRestart <- base::invokeRestart
[10:34:15.532]             length <- base::length
[10:34:15.532]             list <- base::list
[10:34:15.532]             seq.int <- base::seq.int
[10:34:15.532]             signalCondition <- base::signalCondition
[10:34:15.532]             sys.calls <- base::sys.calls
[10:34:15.532]             `[[` <- base::`[[`
[10:34:15.532]             `+` <- base::`+`
[10:34:15.532]             `<<-` <- base::`<<-`
[10:34:15.532]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:15.532]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:15.532]                   3L)]
[10:34:15.532]             }
[10:34:15.532]             function(cond) {
[10:34:15.532]                 is_error <- inherits(cond, "error")
[10:34:15.532]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:15.532]                   NULL)
[10:34:15.532]                 if (is_error) {
[10:34:15.532]                   sessionInformation <- function() {
[10:34:15.532]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:15.532]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:15.532]                       search = base::search(), system = base::Sys.info())
[10:34:15.532]                   }
[10:34:15.532]                   ...future.conditions[[length(...future.conditions) + 
[10:34:15.532]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:15.532]                     cond$call), session = sessionInformation(), 
[10:34:15.532]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:15.532]                   signalCondition(cond)
[10:34:15.532]                 }
[10:34:15.532]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:15.532]                 "immediateCondition"))) {
[10:34:15.532]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:15.532]                   ...future.conditions[[length(...future.conditions) + 
[10:34:15.532]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:15.532]                   if (TRUE && !signal) {
[10:34:15.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:15.532]                     {
[10:34:15.532]                       inherits <- base::inherits
[10:34:15.532]                       invokeRestart <- base::invokeRestart
[10:34:15.532]                       is.null <- base::is.null
[10:34:15.532]                       muffled <- FALSE
[10:34:15.532]                       if (inherits(cond, "message")) {
[10:34:15.532]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:15.532]                         if (muffled) 
[10:34:15.532]                           invokeRestart("muffleMessage")
[10:34:15.532]                       }
[10:34:15.532]                       else if (inherits(cond, "warning")) {
[10:34:15.532]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:15.532]                         if (muffled) 
[10:34:15.532]                           invokeRestart("muffleWarning")
[10:34:15.532]                       }
[10:34:15.532]                       else if (inherits(cond, "condition")) {
[10:34:15.532]                         if (!is.null(pattern)) {
[10:34:15.532]                           computeRestarts <- base::computeRestarts
[10:34:15.532]                           grepl <- base::grepl
[10:34:15.532]                           restarts <- computeRestarts(cond)
[10:34:15.532]                           for (restart in restarts) {
[10:34:15.532]                             name <- restart$name
[10:34:15.532]                             if (is.null(name)) 
[10:34:15.532]                               next
[10:34:15.532]                             if (!grepl(pattern, name)) 
[10:34:15.532]                               next
[10:34:15.532]                             invokeRestart(restart)
[10:34:15.532]                             muffled <- TRUE
[10:34:15.532]                             break
[10:34:15.532]                           }
[10:34:15.532]                         }
[10:34:15.532]                       }
[10:34:15.532]                       invisible(muffled)
[10:34:15.532]                     }
[10:34:15.532]                     muffleCondition(cond, pattern = "^muffle")
[10:34:15.532]                   }
[10:34:15.532]                 }
[10:34:15.532]                 else {
[10:34:15.532]                   if (TRUE) {
[10:34:15.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:15.532]                     {
[10:34:15.532]                       inherits <- base::inherits
[10:34:15.532]                       invokeRestart <- base::invokeRestart
[10:34:15.532]                       is.null <- base::is.null
[10:34:15.532]                       muffled <- FALSE
[10:34:15.532]                       if (inherits(cond, "message")) {
[10:34:15.532]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:15.532]                         if (muffled) 
[10:34:15.532]                           invokeRestart("muffleMessage")
[10:34:15.532]                       }
[10:34:15.532]                       else if (inherits(cond, "warning")) {
[10:34:15.532]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:15.532]                         if (muffled) 
[10:34:15.532]                           invokeRestart("muffleWarning")
[10:34:15.532]                       }
[10:34:15.532]                       else if (inherits(cond, "condition")) {
[10:34:15.532]                         if (!is.null(pattern)) {
[10:34:15.532]                           computeRestarts <- base::computeRestarts
[10:34:15.532]                           grepl <- base::grepl
[10:34:15.532]                           restarts <- computeRestarts(cond)
[10:34:15.532]                           for (restart in restarts) {
[10:34:15.532]                             name <- restart$name
[10:34:15.532]                             if (is.null(name)) 
[10:34:15.532]                               next
[10:34:15.532]                             if (!grepl(pattern, name)) 
[10:34:15.532]                               next
[10:34:15.532]                             invokeRestart(restart)
[10:34:15.532]                             muffled <- TRUE
[10:34:15.532]                             break
[10:34:15.532]                           }
[10:34:15.532]                         }
[10:34:15.532]                       }
[10:34:15.532]                       invisible(muffled)
[10:34:15.532]                     }
[10:34:15.532]                     muffleCondition(cond, pattern = "^muffle")
[10:34:15.532]                   }
[10:34:15.532]                 }
[10:34:15.532]             }
[10:34:15.532]         }))
[10:34:15.532]     }, error = function(ex) {
[10:34:15.532]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:15.532]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:15.532]                 ...future.rng), started = ...future.startTime, 
[10:34:15.532]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:15.532]             version = "1.8"), class = "FutureResult")
[10:34:15.532]     }, finally = {
[10:34:15.532]         if (!identical(...future.workdir, getwd())) 
[10:34:15.532]             setwd(...future.workdir)
[10:34:15.532]         {
[10:34:15.532]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:15.532]                 ...future.oldOptions$nwarnings <- NULL
[10:34:15.532]             }
[10:34:15.532]             base::options(...future.oldOptions)
[10:34:15.532]             if (.Platform$OS.type == "windows") {
[10:34:15.532]                 old_names <- names(...future.oldEnvVars)
[10:34:15.532]                 envs <- base::Sys.getenv()
[10:34:15.532]                 names <- names(envs)
[10:34:15.532]                 common <- intersect(names, old_names)
[10:34:15.532]                 added <- setdiff(names, old_names)
[10:34:15.532]                 removed <- setdiff(old_names, names)
[10:34:15.532]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:15.532]                   envs[common]]
[10:34:15.532]                 NAMES <- toupper(changed)
[10:34:15.532]                 args <- list()
[10:34:15.532]                 for (kk in seq_along(NAMES)) {
[10:34:15.532]                   name <- changed[[kk]]
[10:34:15.532]                   NAME <- NAMES[[kk]]
[10:34:15.532]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:15.532]                     next
[10:34:15.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:15.532]                 }
[10:34:15.532]                 NAMES <- toupper(added)
[10:34:15.532]                 for (kk in seq_along(NAMES)) {
[10:34:15.532]                   name <- added[[kk]]
[10:34:15.532]                   NAME <- NAMES[[kk]]
[10:34:15.532]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:15.532]                     next
[10:34:15.532]                   args[[name]] <- ""
[10:34:15.532]                 }
[10:34:15.532]                 NAMES <- toupper(removed)
[10:34:15.532]                 for (kk in seq_along(NAMES)) {
[10:34:15.532]                   name <- removed[[kk]]
[10:34:15.532]                   NAME <- NAMES[[kk]]
[10:34:15.532]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:15.532]                     next
[10:34:15.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:15.532]                 }
[10:34:15.532]                 if (length(args) > 0) 
[10:34:15.532]                   base::do.call(base::Sys.setenv, args = args)
[10:34:15.532]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:15.532]             }
[10:34:15.532]             else {
[10:34:15.532]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:15.532]             }
[10:34:15.532]             {
[10:34:15.532]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:15.532]                   0L) {
[10:34:15.532]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:15.532]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:15.532]                   base::options(opts)
[10:34:15.532]                 }
[10:34:15.532]                 {
[10:34:15.532]                   {
[10:34:15.532]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:15.532]                     NULL
[10:34:15.532]                   }
[10:34:15.532]                   options(future.plan = NULL)
[10:34:15.532]                   if (is.na(NA_character_)) 
[10:34:15.532]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:15.532]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:15.532]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:15.532]                     .init = FALSE)
[10:34:15.532]                 }
[10:34:15.532]             }
[10:34:15.532]         }
[10:34:15.532]     })
[10:34:15.532]     if (TRUE) {
[10:34:15.532]         base::sink(type = "output", split = FALSE)
[10:34:15.532]         if (TRUE) {
[10:34:15.532]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:15.532]         }
[10:34:15.532]         else {
[10:34:15.532]             ...future.result["stdout"] <- base::list(NULL)
[10:34:15.532]         }
[10:34:15.532]         base::close(...future.stdout)
[10:34:15.532]         ...future.stdout <- NULL
[10:34:15.532]     }
[10:34:15.532]     ...future.result$conditions <- ...future.conditions
[10:34:15.532]     ...future.result$finished <- base::Sys.time()
[10:34:15.532]     ...future.result
[10:34:15.532] }
[10:34:15.535] MultisessionFuture started
[10:34:15.535] - Launch lazy future ... done
[10:34:15.535] run() for ‘MultisessionFuture’ ... done
[10:34:16.037] receiveMessageFromWorker() for ClusterFuture ...
[10:34:16.037] - Validating connection of MultisessionFuture
[10:34:16.038] - received message: FutureResult
[10:34:16.038] - Received FutureResult
[10:34:16.038] - Erased future from FutureRegistry
[10:34:16.038] result() for ClusterFuture ...
[10:34:16.038] - result already collected: FutureResult
[10:34:16.038] result() for ClusterFuture ... done
[10:34:16.038] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:16.038] resolve() on list ...
[10:34:16.039]  recursive: Inf
[10:34:16.039]  length: 2
[10:34:16.039]  elements: ‘a’, ‘b’
[10:34:16.039]  length: 1 (resolved future 1)
[10:34:16.039]  length: 0 (resolved future 2)
[10:34:16.039] resolve() on list ... DONE
[10:34:16.039] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[10:34:16.039] getGlobalsAndPackages() ...
[10:34:16.039] Searching for globals...
[10:34:16.040] - globals found: [2] ‘list’, ‘stop’
[10:34:16.040] Searching for globals ... DONE
[10:34:16.040] Resolving globals: FALSE
[10:34:16.041] 
[10:34:16.041] 
[10:34:16.041] getGlobalsAndPackages() ... DONE
[10:34:16.041] run() for ‘Future’ ...
[10:34:16.041] - state: ‘created’
[10:34:16.041] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:16.055] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:16.055] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:16.055]   - Field: ‘node’
[10:34:16.055]   - Field: ‘label’
[10:34:16.056]   - Field: ‘local’
[10:34:16.056]   - Field: ‘owner’
[10:34:16.056]   - Field: ‘envir’
[10:34:16.056]   - Field: ‘workers’
[10:34:16.056]   - Field: ‘packages’
[10:34:16.056]   - Field: ‘gc’
[10:34:16.056]   - Field: ‘conditions’
[10:34:16.056]   - Field: ‘persistent’
[10:34:16.056]   - Field: ‘expr’
[10:34:16.056]   - Field: ‘uuid’
[10:34:16.056]   - Field: ‘seed’
[10:34:16.057]   - Field: ‘version’
[10:34:16.057]   - Field: ‘result’
[10:34:16.057]   - Field: ‘asynchronous’
[10:34:16.057]   - Field: ‘calls’
[10:34:16.057]   - Field: ‘globals’
[10:34:16.057]   - Field: ‘stdout’
[10:34:16.057]   - Field: ‘earlySignal’
[10:34:16.057]   - Field: ‘lazy’
[10:34:16.057]   - Field: ‘state’
[10:34:16.057] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:16.058] - Launch lazy future ...
[10:34:16.058] Packages needed by the future expression (n = 0): <none>
[10:34:16.058] Packages needed by future strategies (n = 0): <none>
[10:34:16.058] {
[10:34:16.058]     {
[10:34:16.058]         {
[10:34:16.058]             ...future.startTime <- base::Sys.time()
[10:34:16.058]             {
[10:34:16.058]                 {
[10:34:16.058]                   {
[10:34:16.058]                     {
[10:34:16.058]                       base::local({
[10:34:16.058]                         has_future <- base::requireNamespace("future", 
[10:34:16.058]                           quietly = TRUE)
[10:34:16.058]                         if (has_future) {
[10:34:16.058]                           ns <- base::getNamespace("future")
[10:34:16.058]                           version <- ns[[".package"]][["version"]]
[10:34:16.058]                           if (is.null(version)) 
[10:34:16.058]                             version <- utils::packageVersion("future")
[10:34:16.058]                         }
[10:34:16.058]                         else {
[10:34:16.058]                           version <- NULL
[10:34:16.058]                         }
[10:34:16.058]                         if (!has_future || version < "1.8.0") {
[10:34:16.058]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:16.058]                             "", base::R.version$version.string), 
[10:34:16.058]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:16.058]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:16.058]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:16.058]                               "release", "version")], collapse = " "), 
[10:34:16.058]                             hostname = base::Sys.info()[["nodename"]])
[10:34:16.058]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:16.058]                             info)
[10:34:16.058]                           info <- base::paste(info, collapse = "; ")
[10:34:16.058]                           if (!has_future) {
[10:34:16.058]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:16.058]                               info)
[10:34:16.058]                           }
[10:34:16.058]                           else {
[10:34:16.058]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:16.058]                               info, version)
[10:34:16.058]                           }
[10:34:16.058]                           base::stop(msg)
[10:34:16.058]                         }
[10:34:16.058]                       })
[10:34:16.058]                     }
[10:34:16.058]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:16.058]                     base::options(mc.cores = 1L)
[10:34:16.058]                   }
[10:34:16.058]                   ...future.strategy.old <- future::plan("list")
[10:34:16.058]                   options(future.plan = NULL)
[10:34:16.058]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:16.058]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:16.058]                 }
[10:34:16.058]                 ...future.workdir <- getwd()
[10:34:16.058]             }
[10:34:16.058]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:16.058]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:16.058]         }
[10:34:16.058]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:16.058]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:16.058]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:16.058]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:16.058]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:16.058]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:16.058]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:16.058]             base::names(...future.oldOptions))
[10:34:16.058]     }
[10:34:16.058]     if (FALSE) {
[10:34:16.058]     }
[10:34:16.058]     else {
[10:34:16.058]         if (TRUE) {
[10:34:16.058]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:16.058]                 open = "w")
[10:34:16.058]         }
[10:34:16.058]         else {
[10:34:16.058]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:16.058]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:16.058]         }
[10:34:16.058]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:16.058]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:16.058]             base::sink(type = "output", split = FALSE)
[10:34:16.058]             base::close(...future.stdout)
[10:34:16.058]         }, add = TRUE)
[10:34:16.058]     }
[10:34:16.058]     ...future.frame <- base::sys.nframe()
[10:34:16.058]     ...future.conditions <- base::list()
[10:34:16.058]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:16.058]     if (FALSE) {
[10:34:16.058]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:16.058]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:16.058]     }
[10:34:16.058]     ...future.result <- base::tryCatch({
[10:34:16.058]         base::withCallingHandlers({
[10:34:16.058]             ...future.value <- base::withVisible(base::local({
[10:34:16.058]                 ...future.makeSendCondition <- base::local({
[10:34:16.058]                   sendCondition <- NULL
[10:34:16.058]                   function(frame = 1L) {
[10:34:16.058]                     if (is.function(sendCondition)) 
[10:34:16.058]                       return(sendCondition)
[10:34:16.058]                     ns <- getNamespace("parallel")
[10:34:16.058]                     if (exists("sendData", mode = "function", 
[10:34:16.058]                       envir = ns)) {
[10:34:16.058]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:16.058]                         envir = ns)
[10:34:16.058]                       envir <- sys.frame(frame)
[10:34:16.058]                       master <- NULL
[10:34:16.058]                       while (!identical(envir, .GlobalEnv) && 
[10:34:16.058]                         !identical(envir, emptyenv())) {
[10:34:16.058]                         if (exists("master", mode = "list", envir = envir, 
[10:34:16.058]                           inherits = FALSE)) {
[10:34:16.058]                           master <- get("master", mode = "list", 
[10:34:16.058]                             envir = envir, inherits = FALSE)
[10:34:16.058]                           if (inherits(master, c("SOCKnode", 
[10:34:16.058]                             "SOCK0node"))) {
[10:34:16.058]                             sendCondition <<- function(cond) {
[10:34:16.058]                               data <- list(type = "VALUE", value = cond, 
[10:34:16.058]                                 success = TRUE)
[10:34:16.058]                               parallel_sendData(master, data)
[10:34:16.058]                             }
[10:34:16.058]                             return(sendCondition)
[10:34:16.058]                           }
[10:34:16.058]                         }
[10:34:16.058]                         frame <- frame + 1L
[10:34:16.058]                         envir <- sys.frame(frame)
[10:34:16.058]                       }
[10:34:16.058]                     }
[10:34:16.058]                     sendCondition <<- function(cond) NULL
[10:34:16.058]                   }
[10:34:16.058]                 })
[10:34:16.058]                 withCallingHandlers({
[10:34:16.058]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:34:16.058]                 }, immediateCondition = function(cond) {
[10:34:16.058]                   sendCondition <- ...future.makeSendCondition()
[10:34:16.058]                   sendCondition(cond)
[10:34:16.058]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.058]                   {
[10:34:16.058]                     inherits <- base::inherits
[10:34:16.058]                     invokeRestart <- base::invokeRestart
[10:34:16.058]                     is.null <- base::is.null
[10:34:16.058]                     muffled <- FALSE
[10:34:16.058]                     if (inherits(cond, "message")) {
[10:34:16.058]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:16.058]                       if (muffled) 
[10:34:16.058]                         invokeRestart("muffleMessage")
[10:34:16.058]                     }
[10:34:16.058]                     else if (inherits(cond, "warning")) {
[10:34:16.058]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:16.058]                       if (muffled) 
[10:34:16.058]                         invokeRestart("muffleWarning")
[10:34:16.058]                     }
[10:34:16.058]                     else if (inherits(cond, "condition")) {
[10:34:16.058]                       if (!is.null(pattern)) {
[10:34:16.058]                         computeRestarts <- base::computeRestarts
[10:34:16.058]                         grepl <- base::grepl
[10:34:16.058]                         restarts <- computeRestarts(cond)
[10:34:16.058]                         for (restart in restarts) {
[10:34:16.058]                           name <- restart$name
[10:34:16.058]                           if (is.null(name)) 
[10:34:16.058]                             next
[10:34:16.058]                           if (!grepl(pattern, name)) 
[10:34:16.058]                             next
[10:34:16.058]                           invokeRestart(restart)
[10:34:16.058]                           muffled <- TRUE
[10:34:16.058]                           break
[10:34:16.058]                         }
[10:34:16.058]                       }
[10:34:16.058]                     }
[10:34:16.058]                     invisible(muffled)
[10:34:16.058]                   }
[10:34:16.058]                   muffleCondition(cond)
[10:34:16.058]                 })
[10:34:16.058]             }))
[10:34:16.058]             future::FutureResult(value = ...future.value$value, 
[10:34:16.058]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:16.058]                   ...future.rng), globalenv = if (FALSE) 
[10:34:16.058]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:16.058]                     ...future.globalenv.names))
[10:34:16.058]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:16.058]         }, condition = base::local({
[10:34:16.058]             c <- base::c
[10:34:16.058]             inherits <- base::inherits
[10:34:16.058]             invokeRestart <- base::invokeRestart
[10:34:16.058]             length <- base::length
[10:34:16.058]             list <- base::list
[10:34:16.058]             seq.int <- base::seq.int
[10:34:16.058]             signalCondition <- base::signalCondition
[10:34:16.058]             sys.calls <- base::sys.calls
[10:34:16.058]             `[[` <- base::`[[`
[10:34:16.058]             `+` <- base::`+`
[10:34:16.058]             `<<-` <- base::`<<-`
[10:34:16.058]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:16.058]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:16.058]                   3L)]
[10:34:16.058]             }
[10:34:16.058]             function(cond) {
[10:34:16.058]                 is_error <- inherits(cond, "error")
[10:34:16.058]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:16.058]                   NULL)
[10:34:16.058]                 if (is_error) {
[10:34:16.058]                   sessionInformation <- function() {
[10:34:16.058]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:16.058]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:16.058]                       search = base::search(), system = base::Sys.info())
[10:34:16.058]                   }
[10:34:16.058]                   ...future.conditions[[length(...future.conditions) + 
[10:34:16.058]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:16.058]                     cond$call), session = sessionInformation(), 
[10:34:16.058]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:16.058]                   signalCondition(cond)
[10:34:16.058]                 }
[10:34:16.058]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:16.058]                 "immediateCondition"))) {
[10:34:16.058]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:16.058]                   ...future.conditions[[length(...future.conditions) + 
[10:34:16.058]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:16.058]                   if (TRUE && !signal) {
[10:34:16.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.058]                     {
[10:34:16.058]                       inherits <- base::inherits
[10:34:16.058]                       invokeRestart <- base::invokeRestart
[10:34:16.058]                       is.null <- base::is.null
[10:34:16.058]                       muffled <- FALSE
[10:34:16.058]                       if (inherits(cond, "message")) {
[10:34:16.058]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:16.058]                         if (muffled) 
[10:34:16.058]                           invokeRestart("muffleMessage")
[10:34:16.058]                       }
[10:34:16.058]                       else if (inherits(cond, "warning")) {
[10:34:16.058]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:16.058]                         if (muffled) 
[10:34:16.058]                           invokeRestart("muffleWarning")
[10:34:16.058]                       }
[10:34:16.058]                       else if (inherits(cond, "condition")) {
[10:34:16.058]                         if (!is.null(pattern)) {
[10:34:16.058]                           computeRestarts <- base::computeRestarts
[10:34:16.058]                           grepl <- base::grepl
[10:34:16.058]                           restarts <- computeRestarts(cond)
[10:34:16.058]                           for (restart in restarts) {
[10:34:16.058]                             name <- restart$name
[10:34:16.058]                             if (is.null(name)) 
[10:34:16.058]                               next
[10:34:16.058]                             if (!grepl(pattern, name)) 
[10:34:16.058]                               next
[10:34:16.058]                             invokeRestart(restart)
[10:34:16.058]                             muffled <- TRUE
[10:34:16.058]                             break
[10:34:16.058]                           }
[10:34:16.058]                         }
[10:34:16.058]                       }
[10:34:16.058]                       invisible(muffled)
[10:34:16.058]                     }
[10:34:16.058]                     muffleCondition(cond, pattern = "^muffle")
[10:34:16.058]                   }
[10:34:16.058]                 }
[10:34:16.058]                 else {
[10:34:16.058]                   if (TRUE) {
[10:34:16.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.058]                     {
[10:34:16.058]                       inherits <- base::inherits
[10:34:16.058]                       invokeRestart <- base::invokeRestart
[10:34:16.058]                       is.null <- base::is.null
[10:34:16.058]                       muffled <- FALSE
[10:34:16.058]                       if (inherits(cond, "message")) {
[10:34:16.058]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:16.058]                         if (muffled) 
[10:34:16.058]                           invokeRestart("muffleMessage")
[10:34:16.058]                       }
[10:34:16.058]                       else if (inherits(cond, "warning")) {
[10:34:16.058]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:16.058]                         if (muffled) 
[10:34:16.058]                           invokeRestart("muffleWarning")
[10:34:16.058]                       }
[10:34:16.058]                       else if (inherits(cond, "condition")) {
[10:34:16.058]                         if (!is.null(pattern)) {
[10:34:16.058]                           computeRestarts <- base::computeRestarts
[10:34:16.058]                           grepl <- base::grepl
[10:34:16.058]                           restarts <- computeRestarts(cond)
[10:34:16.058]                           for (restart in restarts) {
[10:34:16.058]                             name <- restart$name
[10:34:16.058]                             if (is.null(name)) 
[10:34:16.058]                               next
[10:34:16.058]                             if (!grepl(pattern, name)) 
[10:34:16.058]                               next
[10:34:16.058]                             invokeRestart(restart)
[10:34:16.058]                             muffled <- TRUE
[10:34:16.058]                             break
[10:34:16.058]                           }
[10:34:16.058]                         }
[10:34:16.058]                       }
[10:34:16.058]                       invisible(muffled)
[10:34:16.058]                     }
[10:34:16.058]                     muffleCondition(cond, pattern = "^muffle")
[10:34:16.058]                   }
[10:34:16.058]                 }
[10:34:16.058]             }
[10:34:16.058]         }))
[10:34:16.058]     }, error = function(ex) {
[10:34:16.058]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:16.058]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:16.058]                 ...future.rng), started = ...future.startTime, 
[10:34:16.058]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:16.058]             version = "1.8"), class = "FutureResult")
[10:34:16.058]     }, finally = {
[10:34:16.058]         if (!identical(...future.workdir, getwd())) 
[10:34:16.058]             setwd(...future.workdir)
[10:34:16.058]         {
[10:34:16.058]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:16.058]                 ...future.oldOptions$nwarnings <- NULL
[10:34:16.058]             }
[10:34:16.058]             base::options(...future.oldOptions)
[10:34:16.058]             if (.Platform$OS.type == "windows") {
[10:34:16.058]                 old_names <- names(...future.oldEnvVars)
[10:34:16.058]                 envs <- base::Sys.getenv()
[10:34:16.058]                 names <- names(envs)
[10:34:16.058]                 common <- intersect(names, old_names)
[10:34:16.058]                 added <- setdiff(names, old_names)
[10:34:16.058]                 removed <- setdiff(old_names, names)
[10:34:16.058]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:16.058]                   envs[common]]
[10:34:16.058]                 NAMES <- toupper(changed)
[10:34:16.058]                 args <- list()
[10:34:16.058]                 for (kk in seq_along(NAMES)) {
[10:34:16.058]                   name <- changed[[kk]]
[10:34:16.058]                   NAME <- NAMES[[kk]]
[10:34:16.058]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.058]                     next
[10:34:16.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:16.058]                 }
[10:34:16.058]                 NAMES <- toupper(added)
[10:34:16.058]                 for (kk in seq_along(NAMES)) {
[10:34:16.058]                   name <- added[[kk]]
[10:34:16.058]                   NAME <- NAMES[[kk]]
[10:34:16.058]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.058]                     next
[10:34:16.058]                   args[[name]] <- ""
[10:34:16.058]                 }
[10:34:16.058]                 NAMES <- toupper(removed)
[10:34:16.058]                 for (kk in seq_along(NAMES)) {
[10:34:16.058]                   name <- removed[[kk]]
[10:34:16.058]                   NAME <- NAMES[[kk]]
[10:34:16.058]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.058]                     next
[10:34:16.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:16.058]                 }
[10:34:16.058]                 if (length(args) > 0) 
[10:34:16.058]                   base::do.call(base::Sys.setenv, args = args)
[10:34:16.058]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:16.058]             }
[10:34:16.058]             else {
[10:34:16.058]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:16.058]             }
[10:34:16.058]             {
[10:34:16.058]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:16.058]                   0L) {
[10:34:16.058]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:16.058]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:16.058]                   base::options(opts)
[10:34:16.058]                 }
[10:34:16.058]                 {
[10:34:16.058]                   {
[10:34:16.058]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:16.058]                     NULL
[10:34:16.058]                   }
[10:34:16.058]                   options(future.plan = NULL)
[10:34:16.058]                   if (is.na(NA_character_)) 
[10:34:16.058]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:16.058]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:16.058]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:16.058]                     .init = FALSE)
[10:34:16.058]                 }
[10:34:16.058]             }
[10:34:16.058]         }
[10:34:16.058]     })
[10:34:16.058]     if (TRUE) {
[10:34:16.058]         base::sink(type = "output", split = FALSE)
[10:34:16.058]         if (TRUE) {
[10:34:16.058]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:16.058]         }
[10:34:16.058]         else {
[10:34:16.058]             ...future.result["stdout"] <- base::list(NULL)
[10:34:16.058]         }
[10:34:16.058]         base::close(...future.stdout)
[10:34:16.058]         ...future.stdout <- NULL
[10:34:16.058]     }
[10:34:16.058]     ...future.result$conditions <- ...future.conditions
[10:34:16.058]     ...future.result$finished <- base::Sys.time()
[10:34:16.058]     ...future.result
[10:34:16.058] }
[10:34:16.061] MultisessionFuture started
[10:34:16.061] - Launch lazy future ... done
[10:34:16.062] run() for ‘MultisessionFuture’ ... done
[10:34:16.063] receiveMessageFromWorker() for ClusterFuture ...
[10:34:16.063] - Validating connection of MultisessionFuture
[10:34:16.064] - received message: FutureResult
[10:34:16.064] - Received FutureResult
[10:34:16.064] - Erased future from FutureRegistry
[10:34:16.064] result() for ClusterFuture ...
[10:34:16.064] - result already collected: FutureResult
[10:34:16.064] result() for ClusterFuture ... done
[10:34:16.064] signalConditions() ...
[10:34:16.064]  - include = ‘immediateCondition’
[10:34:16.064]  - exclude = 
[10:34:16.064]  - resignal = FALSE
[10:34:16.065]  - Number of conditions: 1
[10:34:16.065] signalConditions() ... done
[10:34:16.065] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:16.065] A MultisessionFuture was resolved
[10:34:16.065] getGlobalsAndPackages() ...
[10:34:16.065] Searching for globals...
[10:34:16.066] - globals found: [2] ‘list’, ‘stop’
[10:34:16.066] Searching for globals ... DONE
[10:34:16.066] Resolving globals: FALSE
[10:34:16.066] 
[10:34:16.066] 
[10:34:16.066] getGlobalsAndPackages() ... DONE
[10:34:16.067] run() for ‘Future’ ...
[10:34:16.067] - state: ‘created’
[10:34:16.067] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:16.080] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:16.080] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:16.080]   - Field: ‘node’
[10:34:16.081]   - Field: ‘label’
[10:34:16.081]   - Field: ‘local’
[10:34:16.081]   - Field: ‘owner’
[10:34:16.081]   - Field: ‘envir’
[10:34:16.081]   - Field: ‘workers’
[10:34:16.081]   - Field: ‘packages’
[10:34:16.081]   - Field: ‘gc’
[10:34:16.081]   - Field: ‘conditions’
[10:34:16.081]   - Field: ‘persistent’
[10:34:16.081]   - Field: ‘expr’
[10:34:16.081]   - Field: ‘uuid’
[10:34:16.082]   - Field: ‘seed’
[10:34:16.082]   - Field: ‘version’
[10:34:16.082]   - Field: ‘result’
[10:34:16.082]   - Field: ‘asynchronous’
[10:34:16.082]   - Field: ‘calls’
[10:34:16.082]   - Field: ‘globals’
[10:34:16.082]   - Field: ‘stdout’
[10:34:16.082]   - Field: ‘earlySignal’
[10:34:16.082]   - Field: ‘lazy’
[10:34:16.082]   - Field: ‘state’
[10:34:16.082] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:16.083] - Launch lazy future ...
[10:34:16.083] Packages needed by the future expression (n = 0): <none>
[10:34:16.083] Packages needed by future strategies (n = 0): <none>
[10:34:16.083] {
[10:34:16.083]     {
[10:34:16.083]         {
[10:34:16.083]             ...future.startTime <- base::Sys.time()
[10:34:16.083]             {
[10:34:16.083]                 {
[10:34:16.083]                   {
[10:34:16.083]                     {
[10:34:16.083]                       base::local({
[10:34:16.083]                         has_future <- base::requireNamespace("future", 
[10:34:16.083]                           quietly = TRUE)
[10:34:16.083]                         if (has_future) {
[10:34:16.083]                           ns <- base::getNamespace("future")
[10:34:16.083]                           version <- ns[[".package"]][["version"]]
[10:34:16.083]                           if (is.null(version)) 
[10:34:16.083]                             version <- utils::packageVersion("future")
[10:34:16.083]                         }
[10:34:16.083]                         else {
[10:34:16.083]                           version <- NULL
[10:34:16.083]                         }
[10:34:16.083]                         if (!has_future || version < "1.8.0") {
[10:34:16.083]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:16.083]                             "", base::R.version$version.string), 
[10:34:16.083]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:16.083]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:16.083]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:16.083]                               "release", "version")], collapse = " "), 
[10:34:16.083]                             hostname = base::Sys.info()[["nodename"]])
[10:34:16.083]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:16.083]                             info)
[10:34:16.083]                           info <- base::paste(info, collapse = "; ")
[10:34:16.083]                           if (!has_future) {
[10:34:16.083]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:16.083]                               info)
[10:34:16.083]                           }
[10:34:16.083]                           else {
[10:34:16.083]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:16.083]                               info, version)
[10:34:16.083]                           }
[10:34:16.083]                           base::stop(msg)
[10:34:16.083]                         }
[10:34:16.083]                       })
[10:34:16.083]                     }
[10:34:16.083]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:16.083]                     base::options(mc.cores = 1L)
[10:34:16.083]                   }
[10:34:16.083]                   ...future.strategy.old <- future::plan("list")
[10:34:16.083]                   options(future.plan = NULL)
[10:34:16.083]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:16.083]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:16.083]                 }
[10:34:16.083]                 ...future.workdir <- getwd()
[10:34:16.083]             }
[10:34:16.083]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:16.083]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:16.083]         }
[10:34:16.083]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:16.083]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:16.083]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:16.083]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:16.083]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:16.083]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:16.083]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:16.083]             base::names(...future.oldOptions))
[10:34:16.083]     }
[10:34:16.083]     if (FALSE) {
[10:34:16.083]     }
[10:34:16.083]     else {
[10:34:16.083]         if (TRUE) {
[10:34:16.083]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:16.083]                 open = "w")
[10:34:16.083]         }
[10:34:16.083]         else {
[10:34:16.083]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:16.083]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:16.083]         }
[10:34:16.083]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:16.083]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:16.083]             base::sink(type = "output", split = FALSE)
[10:34:16.083]             base::close(...future.stdout)
[10:34:16.083]         }, add = TRUE)
[10:34:16.083]     }
[10:34:16.083]     ...future.frame <- base::sys.nframe()
[10:34:16.083]     ...future.conditions <- base::list()
[10:34:16.083]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:16.083]     if (FALSE) {
[10:34:16.083]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:16.083]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:16.083]     }
[10:34:16.083]     ...future.result <- base::tryCatch({
[10:34:16.083]         base::withCallingHandlers({
[10:34:16.083]             ...future.value <- base::withVisible(base::local({
[10:34:16.083]                 ...future.makeSendCondition <- base::local({
[10:34:16.083]                   sendCondition <- NULL
[10:34:16.083]                   function(frame = 1L) {
[10:34:16.083]                     if (is.function(sendCondition)) 
[10:34:16.083]                       return(sendCondition)
[10:34:16.083]                     ns <- getNamespace("parallel")
[10:34:16.083]                     if (exists("sendData", mode = "function", 
[10:34:16.083]                       envir = ns)) {
[10:34:16.083]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:16.083]                         envir = ns)
[10:34:16.083]                       envir <- sys.frame(frame)
[10:34:16.083]                       master <- NULL
[10:34:16.083]                       while (!identical(envir, .GlobalEnv) && 
[10:34:16.083]                         !identical(envir, emptyenv())) {
[10:34:16.083]                         if (exists("master", mode = "list", envir = envir, 
[10:34:16.083]                           inherits = FALSE)) {
[10:34:16.083]                           master <- get("master", mode = "list", 
[10:34:16.083]                             envir = envir, inherits = FALSE)
[10:34:16.083]                           if (inherits(master, c("SOCKnode", 
[10:34:16.083]                             "SOCK0node"))) {
[10:34:16.083]                             sendCondition <<- function(cond) {
[10:34:16.083]                               data <- list(type = "VALUE", value = cond, 
[10:34:16.083]                                 success = TRUE)
[10:34:16.083]                               parallel_sendData(master, data)
[10:34:16.083]                             }
[10:34:16.083]                             return(sendCondition)
[10:34:16.083]                           }
[10:34:16.083]                         }
[10:34:16.083]                         frame <- frame + 1L
[10:34:16.083]                         envir <- sys.frame(frame)
[10:34:16.083]                       }
[10:34:16.083]                     }
[10:34:16.083]                     sendCondition <<- function(cond) NULL
[10:34:16.083]                   }
[10:34:16.083]                 })
[10:34:16.083]                 withCallingHandlers({
[10:34:16.083]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:34:16.083]                 }, immediateCondition = function(cond) {
[10:34:16.083]                   sendCondition <- ...future.makeSendCondition()
[10:34:16.083]                   sendCondition(cond)
[10:34:16.083]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.083]                   {
[10:34:16.083]                     inherits <- base::inherits
[10:34:16.083]                     invokeRestart <- base::invokeRestart
[10:34:16.083]                     is.null <- base::is.null
[10:34:16.083]                     muffled <- FALSE
[10:34:16.083]                     if (inherits(cond, "message")) {
[10:34:16.083]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:16.083]                       if (muffled) 
[10:34:16.083]                         invokeRestart("muffleMessage")
[10:34:16.083]                     }
[10:34:16.083]                     else if (inherits(cond, "warning")) {
[10:34:16.083]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:16.083]                       if (muffled) 
[10:34:16.083]                         invokeRestart("muffleWarning")
[10:34:16.083]                     }
[10:34:16.083]                     else if (inherits(cond, "condition")) {
[10:34:16.083]                       if (!is.null(pattern)) {
[10:34:16.083]                         computeRestarts <- base::computeRestarts
[10:34:16.083]                         grepl <- base::grepl
[10:34:16.083]                         restarts <- computeRestarts(cond)
[10:34:16.083]                         for (restart in restarts) {
[10:34:16.083]                           name <- restart$name
[10:34:16.083]                           if (is.null(name)) 
[10:34:16.083]                             next
[10:34:16.083]                           if (!grepl(pattern, name)) 
[10:34:16.083]                             next
[10:34:16.083]                           invokeRestart(restart)
[10:34:16.083]                           muffled <- TRUE
[10:34:16.083]                           break
[10:34:16.083]                         }
[10:34:16.083]                       }
[10:34:16.083]                     }
[10:34:16.083]                     invisible(muffled)
[10:34:16.083]                   }
[10:34:16.083]                   muffleCondition(cond)
[10:34:16.083]                 })
[10:34:16.083]             }))
[10:34:16.083]             future::FutureResult(value = ...future.value$value, 
[10:34:16.083]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:16.083]                   ...future.rng), globalenv = if (FALSE) 
[10:34:16.083]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:16.083]                     ...future.globalenv.names))
[10:34:16.083]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:16.083]         }, condition = base::local({
[10:34:16.083]             c <- base::c
[10:34:16.083]             inherits <- base::inherits
[10:34:16.083]             invokeRestart <- base::invokeRestart
[10:34:16.083]             length <- base::length
[10:34:16.083]             list <- base::list
[10:34:16.083]             seq.int <- base::seq.int
[10:34:16.083]             signalCondition <- base::signalCondition
[10:34:16.083]             sys.calls <- base::sys.calls
[10:34:16.083]             `[[` <- base::`[[`
[10:34:16.083]             `+` <- base::`+`
[10:34:16.083]             `<<-` <- base::`<<-`
[10:34:16.083]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:16.083]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:16.083]                   3L)]
[10:34:16.083]             }
[10:34:16.083]             function(cond) {
[10:34:16.083]                 is_error <- inherits(cond, "error")
[10:34:16.083]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:16.083]                   NULL)
[10:34:16.083]                 if (is_error) {
[10:34:16.083]                   sessionInformation <- function() {
[10:34:16.083]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:16.083]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:16.083]                       search = base::search(), system = base::Sys.info())
[10:34:16.083]                   }
[10:34:16.083]                   ...future.conditions[[length(...future.conditions) + 
[10:34:16.083]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:16.083]                     cond$call), session = sessionInformation(), 
[10:34:16.083]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:16.083]                   signalCondition(cond)
[10:34:16.083]                 }
[10:34:16.083]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:16.083]                 "immediateCondition"))) {
[10:34:16.083]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:16.083]                   ...future.conditions[[length(...future.conditions) + 
[10:34:16.083]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:16.083]                   if (TRUE && !signal) {
[10:34:16.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.083]                     {
[10:34:16.083]                       inherits <- base::inherits
[10:34:16.083]                       invokeRestart <- base::invokeRestart
[10:34:16.083]                       is.null <- base::is.null
[10:34:16.083]                       muffled <- FALSE
[10:34:16.083]                       if (inherits(cond, "message")) {
[10:34:16.083]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:16.083]                         if (muffled) 
[10:34:16.083]                           invokeRestart("muffleMessage")
[10:34:16.083]                       }
[10:34:16.083]                       else if (inherits(cond, "warning")) {
[10:34:16.083]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:16.083]                         if (muffled) 
[10:34:16.083]                           invokeRestart("muffleWarning")
[10:34:16.083]                       }
[10:34:16.083]                       else if (inherits(cond, "condition")) {
[10:34:16.083]                         if (!is.null(pattern)) {
[10:34:16.083]                           computeRestarts <- base::computeRestarts
[10:34:16.083]                           grepl <- base::grepl
[10:34:16.083]                           restarts <- computeRestarts(cond)
[10:34:16.083]                           for (restart in restarts) {
[10:34:16.083]                             name <- restart$name
[10:34:16.083]                             if (is.null(name)) 
[10:34:16.083]                               next
[10:34:16.083]                             if (!grepl(pattern, name)) 
[10:34:16.083]                               next
[10:34:16.083]                             invokeRestart(restart)
[10:34:16.083]                             muffled <- TRUE
[10:34:16.083]                             break
[10:34:16.083]                           }
[10:34:16.083]                         }
[10:34:16.083]                       }
[10:34:16.083]                       invisible(muffled)
[10:34:16.083]                     }
[10:34:16.083]                     muffleCondition(cond, pattern = "^muffle")
[10:34:16.083]                   }
[10:34:16.083]                 }
[10:34:16.083]                 else {
[10:34:16.083]                   if (TRUE) {
[10:34:16.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.083]                     {
[10:34:16.083]                       inherits <- base::inherits
[10:34:16.083]                       invokeRestart <- base::invokeRestart
[10:34:16.083]                       is.null <- base::is.null
[10:34:16.083]                       muffled <- FALSE
[10:34:16.083]                       if (inherits(cond, "message")) {
[10:34:16.083]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:16.083]                         if (muffled) 
[10:34:16.083]                           invokeRestart("muffleMessage")
[10:34:16.083]                       }
[10:34:16.083]                       else if (inherits(cond, "warning")) {
[10:34:16.083]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:16.083]                         if (muffled) 
[10:34:16.083]                           invokeRestart("muffleWarning")
[10:34:16.083]                       }
[10:34:16.083]                       else if (inherits(cond, "condition")) {
[10:34:16.083]                         if (!is.null(pattern)) {
[10:34:16.083]                           computeRestarts <- base::computeRestarts
[10:34:16.083]                           grepl <- base::grepl
[10:34:16.083]                           restarts <- computeRestarts(cond)
[10:34:16.083]                           for (restart in restarts) {
[10:34:16.083]                             name <- restart$name
[10:34:16.083]                             if (is.null(name)) 
[10:34:16.083]                               next
[10:34:16.083]                             if (!grepl(pattern, name)) 
[10:34:16.083]                               next
[10:34:16.083]                             invokeRestart(restart)
[10:34:16.083]                             muffled <- TRUE
[10:34:16.083]                             break
[10:34:16.083]                           }
[10:34:16.083]                         }
[10:34:16.083]                       }
[10:34:16.083]                       invisible(muffled)
[10:34:16.083]                     }
[10:34:16.083]                     muffleCondition(cond, pattern = "^muffle")
[10:34:16.083]                   }
[10:34:16.083]                 }
[10:34:16.083]             }
[10:34:16.083]         }))
[10:34:16.083]     }, error = function(ex) {
[10:34:16.083]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:16.083]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:16.083]                 ...future.rng), started = ...future.startTime, 
[10:34:16.083]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:16.083]             version = "1.8"), class = "FutureResult")
[10:34:16.083]     }, finally = {
[10:34:16.083]         if (!identical(...future.workdir, getwd())) 
[10:34:16.083]             setwd(...future.workdir)
[10:34:16.083]         {
[10:34:16.083]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:16.083]                 ...future.oldOptions$nwarnings <- NULL
[10:34:16.083]             }
[10:34:16.083]             base::options(...future.oldOptions)
[10:34:16.083]             if (.Platform$OS.type == "windows") {
[10:34:16.083]                 old_names <- names(...future.oldEnvVars)
[10:34:16.083]                 envs <- base::Sys.getenv()
[10:34:16.083]                 names <- names(envs)
[10:34:16.083]                 common <- intersect(names, old_names)
[10:34:16.083]                 added <- setdiff(names, old_names)
[10:34:16.083]                 removed <- setdiff(old_names, names)
[10:34:16.083]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:16.083]                   envs[common]]
[10:34:16.083]                 NAMES <- toupper(changed)
[10:34:16.083]                 args <- list()
[10:34:16.083]                 for (kk in seq_along(NAMES)) {
[10:34:16.083]                   name <- changed[[kk]]
[10:34:16.083]                   NAME <- NAMES[[kk]]
[10:34:16.083]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.083]                     next
[10:34:16.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:16.083]                 }
[10:34:16.083]                 NAMES <- toupper(added)
[10:34:16.083]                 for (kk in seq_along(NAMES)) {
[10:34:16.083]                   name <- added[[kk]]
[10:34:16.083]                   NAME <- NAMES[[kk]]
[10:34:16.083]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.083]                     next
[10:34:16.083]                   args[[name]] <- ""
[10:34:16.083]                 }
[10:34:16.083]                 NAMES <- toupper(removed)
[10:34:16.083]                 for (kk in seq_along(NAMES)) {
[10:34:16.083]                   name <- removed[[kk]]
[10:34:16.083]                   NAME <- NAMES[[kk]]
[10:34:16.083]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.083]                     next
[10:34:16.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:16.083]                 }
[10:34:16.083]                 if (length(args) > 0) 
[10:34:16.083]                   base::do.call(base::Sys.setenv, args = args)
[10:34:16.083]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:16.083]             }
[10:34:16.083]             else {
[10:34:16.083]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:16.083]             }
[10:34:16.083]             {
[10:34:16.083]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:16.083]                   0L) {
[10:34:16.083]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:16.083]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:16.083]                   base::options(opts)
[10:34:16.083]                 }
[10:34:16.083]                 {
[10:34:16.083]                   {
[10:34:16.083]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:16.083]                     NULL
[10:34:16.083]                   }
[10:34:16.083]                   options(future.plan = NULL)
[10:34:16.083]                   if (is.na(NA_character_)) 
[10:34:16.083]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:16.083]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:16.083]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:16.083]                     .init = FALSE)
[10:34:16.083]                 }
[10:34:16.083]             }
[10:34:16.083]         }
[10:34:16.083]     })
[10:34:16.083]     if (TRUE) {
[10:34:16.083]         base::sink(type = "output", split = FALSE)
[10:34:16.083]         if (TRUE) {
[10:34:16.083]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:16.083]         }
[10:34:16.083]         else {
[10:34:16.083]             ...future.result["stdout"] <- base::list(NULL)
[10:34:16.083]         }
[10:34:16.083]         base::close(...future.stdout)
[10:34:16.083]         ...future.stdout <- NULL
[10:34:16.083]     }
[10:34:16.083]     ...future.result$conditions <- ...future.conditions
[10:34:16.083]     ...future.result$finished <- base::Sys.time()
[10:34:16.083]     ...future.result
[10:34:16.083] }
[10:34:16.086] MultisessionFuture started
[10:34:16.086] - Launch lazy future ... done
[10:34:16.086] run() for ‘MultisessionFuture’ ... done
[10:34:16.087] receiveMessageFromWorker() for ClusterFuture ...
[10:34:16.088] - Validating connection of MultisessionFuture
[10:34:16.088] - received message: FutureResult
[10:34:16.088] - Received FutureResult
[10:34:16.088] - Erased future from FutureRegistry
[10:34:16.088] result() for ClusterFuture ...
[10:34:16.088] - result already collected: FutureResult
[10:34:16.089] result() for ClusterFuture ... done
[10:34:16.089] signalConditions() ...
[10:34:16.089]  - include = ‘immediateCondition’
[10:34:16.089]  - exclude = 
[10:34:16.089]  - resignal = FALSE
[10:34:16.089]  - Number of conditions: 1
[10:34:16.089] signalConditions() ... done
[10:34:16.089] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:16.089] A MultisessionFuture was resolved
- result = TRUE, recursive = Inf ... DONE
*** resolve() for Future objects ... DONE
*** resolve() for lists ...
[10:34:16.090] resolve() on list ...
[10:34:16.090]  recursive: 0
[10:34:16.090]  length: 2
[10:34:16.090]  elements: ‘a’, ‘b’
[10:34:16.090]  length: 1 (resolved future 1)
[10:34:16.090]  length: 0 (resolved future 2)
[10:34:16.090] resolve() on list ... DONE
[10:34:16.093] getGlobalsAndPackages() ...
[10:34:16.093] Searching for globals...
[10:34:16.093] 
[10:34:16.093] Searching for globals ... DONE
[10:34:16.094] - globals: [0] <none>
[10:34:16.094] getGlobalsAndPackages() ... DONE
[10:34:16.094] run() for ‘Future’ ...
[10:34:16.094] - state: ‘created’
[10:34:16.094] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:16.108] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:16.108] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:16.108]   - Field: ‘node’
[10:34:16.108]   - Field: ‘label’
[10:34:16.109]   - Field: ‘local’
[10:34:16.109]   - Field: ‘owner’
[10:34:16.109]   - Field: ‘envir’
[10:34:16.109]   - Field: ‘workers’
[10:34:16.109]   - Field: ‘packages’
[10:34:16.109]   - Field: ‘gc’
[10:34:16.109]   - Field: ‘conditions’
[10:34:16.109]   - Field: ‘persistent’
[10:34:16.109]   - Field: ‘expr’
[10:34:16.109]   - Field: ‘uuid’
[10:34:16.109]   - Field: ‘seed’
[10:34:16.110]   - Field: ‘version’
[10:34:16.110]   - Field: ‘result’
[10:34:16.110]   - Field: ‘asynchronous’
[10:34:16.110]   - Field: ‘calls’
[10:34:16.110]   - Field: ‘globals’
[10:34:16.110]   - Field: ‘stdout’
[10:34:16.110]   - Field: ‘earlySignal’
[10:34:16.110]   - Field: ‘lazy’
[10:34:16.110]   - Field: ‘state’
[10:34:16.110] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:16.110] - Launch lazy future ...
[10:34:16.111] Packages needed by the future expression (n = 0): <none>
[10:34:16.111] Packages needed by future strategies (n = 0): <none>
[10:34:16.111] {
[10:34:16.111]     {
[10:34:16.111]         {
[10:34:16.111]             ...future.startTime <- base::Sys.time()
[10:34:16.111]             {
[10:34:16.111]                 {
[10:34:16.111]                   {
[10:34:16.111]                     {
[10:34:16.111]                       base::local({
[10:34:16.111]                         has_future <- base::requireNamespace("future", 
[10:34:16.111]                           quietly = TRUE)
[10:34:16.111]                         if (has_future) {
[10:34:16.111]                           ns <- base::getNamespace("future")
[10:34:16.111]                           version <- ns[[".package"]][["version"]]
[10:34:16.111]                           if (is.null(version)) 
[10:34:16.111]                             version <- utils::packageVersion("future")
[10:34:16.111]                         }
[10:34:16.111]                         else {
[10:34:16.111]                           version <- NULL
[10:34:16.111]                         }
[10:34:16.111]                         if (!has_future || version < "1.8.0") {
[10:34:16.111]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:16.111]                             "", base::R.version$version.string), 
[10:34:16.111]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:16.111]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:16.111]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:16.111]                               "release", "version")], collapse = " "), 
[10:34:16.111]                             hostname = base::Sys.info()[["nodename"]])
[10:34:16.111]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:16.111]                             info)
[10:34:16.111]                           info <- base::paste(info, collapse = "; ")
[10:34:16.111]                           if (!has_future) {
[10:34:16.111]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:16.111]                               info)
[10:34:16.111]                           }
[10:34:16.111]                           else {
[10:34:16.111]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:16.111]                               info, version)
[10:34:16.111]                           }
[10:34:16.111]                           base::stop(msg)
[10:34:16.111]                         }
[10:34:16.111]                       })
[10:34:16.111]                     }
[10:34:16.111]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:16.111]                     base::options(mc.cores = 1L)
[10:34:16.111]                   }
[10:34:16.111]                   ...future.strategy.old <- future::plan("list")
[10:34:16.111]                   options(future.plan = NULL)
[10:34:16.111]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:16.111]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:16.111]                 }
[10:34:16.111]                 ...future.workdir <- getwd()
[10:34:16.111]             }
[10:34:16.111]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:16.111]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:16.111]         }
[10:34:16.111]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:16.111]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:16.111]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:16.111]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:16.111]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:16.111]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:16.111]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:16.111]             base::names(...future.oldOptions))
[10:34:16.111]     }
[10:34:16.111]     if (FALSE) {
[10:34:16.111]     }
[10:34:16.111]     else {
[10:34:16.111]         if (TRUE) {
[10:34:16.111]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:16.111]                 open = "w")
[10:34:16.111]         }
[10:34:16.111]         else {
[10:34:16.111]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:16.111]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:16.111]         }
[10:34:16.111]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:16.111]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:16.111]             base::sink(type = "output", split = FALSE)
[10:34:16.111]             base::close(...future.stdout)
[10:34:16.111]         }, add = TRUE)
[10:34:16.111]     }
[10:34:16.111]     ...future.frame <- base::sys.nframe()
[10:34:16.111]     ...future.conditions <- base::list()
[10:34:16.111]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:16.111]     if (FALSE) {
[10:34:16.111]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:16.111]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:16.111]     }
[10:34:16.111]     ...future.result <- base::tryCatch({
[10:34:16.111]         base::withCallingHandlers({
[10:34:16.111]             ...future.value <- base::withVisible(base::local({
[10:34:16.111]                 ...future.makeSendCondition <- base::local({
[10:34:16.111]                   sendCondition <- NULL
[10:34:16.111]                   function(frame = 1L) {
[10:34:16.111]                     if (is.function(sendCondition)) 
[10:34:16.111]                       return(sendCondition)
[10:34:16.111]                     ns <- getNamespace("parallel")
[10:34:16.111]                     if (exists("sendData", mode = "function", 
[10:34:16.111]                       envir = ns)) {
[10:34:16.111]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:16.111]                         envir = ns)
[10:34:16.111]                       envir <- sys.frame(frame)
[10:34:16.111]                       master <- NULL
[10:34:16.111]                       while (!identical(envir, .GlobalEnv) && 
[10:34:16.111]                         !identical(envir, emptyenv())) {
[10:34:16.111]                         if (exists("master", mode = "list", envir = envir, 
[10:34:16.111]                           inherits = FALSE)) {
[10:34:16.111]                           master <- get("master", mode = "list", 
[10:34:16.111]                             envir = envir, inherits = FALSE)
[10:34:16.111]                           if (inherits(master, c("SOCKnode", 
[10:34:16.111]                             "SOCK0node"))) {
[10:34:16.111]                             sendCondition <<- function(cond) {
[10:34:16.111]                               data <- list(type = "VALUE", value = cond, 
[10:34:16.111]                                 success = TRUE)
[10:34:16.111]                               parallel_sendData(master, data)
[10:34:16.111]                             }
[10:34:16.111]                             return(sendCondition)
[10:34:16.111]                           }
[10:34:16.111]                         }
[10:34:16.111]                         frame <- frame + 1L
[10:34:16.111]                         envir <- sys.frame(frame)
[10:34:16.111]                       }
[10:34:16.111]                     }
[10:34:16.111]                     sendCondition <<- function(cond) NULL
[10:34:16.111]                   }
[10:34:16.111]                 })
[10:34:16.111]                 withCallingHandlers({
[10:34:16.111]                   1
[10:34:16.111]                 }, immediateCondition = function(cond) {
[10:34:16.111]                   sendCondition <- ...future.makeSendCondition()
[10:34:16.111]                   sendCondition(cond)
[10:34:16.111]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.111]                   {
[10:34:16.111]                     inherits <- base::inherits
[10:34:16.111]                     invokeRestart <- base::invokeRestart
[10:34:16.111]                     is.null <- base::is.null
[10:34:16.111]                     muffled <- FALSE
[10:34:16.111]                     if (inherits(cond, "message")) {
[10:34:16.111]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:16.111]                       if (muffled) 
[10:34:16.111]                         invokeRestart("muffleMessage")
[10:34:16.111]                     }
[10:34:16.111]                     else if (inherits(cond, "warning")) {
[10:34:16.111]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:16.111]                       if (muffled) 
[10:34:16.111]                         invokeRestart("muffleWarning")
[10:34:16.111]                     }
[10:34:16.111]                     else if (inherits(cond, "condition")) {
[10:34:16.111]                       if (!is.null(pattern)) {
[10:34:16.111]                         computeRestarts <- base::computeRestarts
[10:34:16.111]                         grepl <- base::grepl
[10:34:16.111]                         restarts <- computeRestarts(cond)
[10:34:16.111]                         for (restart in restarts) {
[10:34:16.111]                           name <- restart$name
[10:34:16.111]                           if (is.null(name)) 
[10:34:16.111]                             next
[10:34:16.111]                           if (!grepl(pattern, name)) 
[10:34:16.111]                             next
[10:34:16.111]                           invokeRestart(restart)
[10:34:16.111]                           muffled <- TRUE
[10:34:16.111]                           break
[10:34:16.111]                         }
[10:34:16.111]                       }
[10:34:16.111]                     }
[10:34:16.111]                     invisible(muffled)
[10:34:16.111]                   }
[10:34:16.111]                   muffleCondition(cond)
[10:34:16.111]                 })
[10:34:16.111]             }))
[10:34:16.111]             future::FutureResult(value = ...future.value$value, 
[10:34:16.111]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:16.111]                   ...future.rng), globalenv = if (FALSE) 
[10:34:16.111]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:16.111]                     ...future.globalenv.names))
[10:34:16.111]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:16.111]         }, condition = base::local({
[10:34:16.111]             c <- base::c
[10:34:16.111]             inherits <- base::inherits
[10:34:16.111]             invokeRestart <- base::invokeRestart
[10:34:16.111]             length <- base::length
[10:34:16.111]             list <- base::list
[10:34:16.111]             seq.int <- base::seq.int
[10:34:16.111]             signalCondition <- base::signalCondition
[10:34:16.111]             sys.calls <- base::sys.calls
[10:34:16.111]             `[[` <- base::`[[`
[10:34:16.111]             `+` <- base::`+`
[10:34:16.111]             `<<-` <- base::`<<-`
[10:34:16.111]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:16.111]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:16.111]                   3L)]
[10:34:16.111]             }
[10:34:16.111]             function(cond) {
[10:34:16.111]                 is_error <- inherits(cond, "error")
[10:34:16.111]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:16.111]                   NULL)
[10:34:16.111]                 if (is_error) {
[10:34:16.111]                   sessionInformation <- function() {
[10:34:16.111]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:16.111]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:16.111]                       search = base::search(), system = base::Sys.info())
[10:34:16.111]                   }
[10:34:16.111]                   ...future.conditions[[length(...future.conditions) + 
[10:34:16.111]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:16.111]                     cond$call), session = sessionInformation(), 
[10:34:16.111]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:16.111]                   signalCondition(cond)
[10:34:16.111]                 }
[10:34:16.111]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:16.111]                 "immediateCondition"))) {
[10:34:16.111]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:16.111]                   ...future.conditions[[length(...future.conditions) + 
[10:34:16.111]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:16.111]                   if (TRUE && !signal) {
[10:34:16.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.111]                     {
[10:34:16.111]                       inherits <- base::inherits
[10:34:16.111]                       invokeRestart <- base::invokeRestart
[10:34:16.111]                       is.null <- base::is.null
[10:34:16.111]                       muffled <- FALSE
[10:34:16.111]                       if (inherits(cond, "message")) {
[10:34:16.111]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:16.111]                         if (muffled) 
[10:34:16.111]                           invokeRestart("muffleMessage")
[10:34:16.111]                       }
[10:34:16.111]                       else if (inherits(cond, "warning")) {
[10:34:16.111]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:16.111]                         if (muffled) 
[10:34:16.111]                           invokeRestart("muffleWarning")
[10:34:16.111]                       }
[10:34:16.111]                       else if (inherits(cond, "condition")) {
[10:34:16.111]                         if (!is.null(pattern)) {
[10:34:16.111]                           computeRestarts <- base::computeRestarts
[10:34:16.111]                           grepl <- base::grepl
[10:34:16.111]                           restarts <- computeRestarts(cond)
[10:34:16.111]                           for (restart in restarts) {
[10:34:16.111]                             name <- restart$name
[10:34:16.111]                             if (is.null(name)) 
[10:34:16.111]                               next
[10:34:16.111]                             if (!grepl(pattern, name)) 
[10:34:16.111]                               next
[10:34:16.111]                             invokeRestart(restart)
[10:34:16.111]                             muffled <- TRUE
[10:34:16.111]                             break
[10:34:16.111]                           }
[10:34:16.111]                         }
[10:34:16.111]                       }
[10:34:16.111]                       invisible(muffled)
[10:34:16.111]                     }
[10:34:16.111]                     muffleCondition(cond, pattern = "^muffle")
[10:34:16.111]                   }
[10:34:16.111]                 }
[10:34:16.111]                 else {
[10:34:16.111]                   if (TRUE) {
[10:34:16.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.111]                     {
[10:34:16.111]                       inherits <- base::inherits
[10:34:16.111]                       invokeRestart <- base::invokeRestart
[10:34:16.111]                       is.null <- base::is.null
[10:34:16.111]                       muffled <- FALSE
[10:34:16.111]                       if (inherits(cond, "message")) {
[10:34:16.111]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:16.111]                         if (muffled) 
[10:34:16.111]                           invokeRestart("muffleMessage")
[10:34:16.111]                       }
[10:34:16.111]                       else if (inherits(cond, "warning")) {
[10:34:16.111]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:16.111]                         if (muffled) 
[10:34:16.111]                           invokeRestart("muffleWarning")
[10:34:16.111]                       }
[10:34:16.111]                       else if (inherits(cond, "condition")) {
[10:34:16.111]                         if (!is.null(pattern)) {
[10:34:16.111]                           computeRestarts <- base::computeRestarts
[10:34:16.111]                           grepl <- base::grepl
[10:34:16.111]                           restarts <- computeRestarts(cond)
[10:34:16.111]                           for (restart in restarts) {
[10:34:16.111]                             name <- restart$name
[10:34:16.111]                             if (is.null(name)) 
[10:34:16.111]                               next
[10:34:16.111]                             if (!grepl(pattern, name)) 
[10:34:16.111]                               next
[10:34:16.111]                             invokeRestart(restart)
[10:34:16.111]                             muffled <- TRUE
[10:34:16.111]                             break
[10:34:16.111]                           }
[10:34:16.111]                         }
[10:34:16.111]                       }
[10:34:16.111]                       invisible(muffled)
[10:34:16.111]                     }
[10:34:16.111]                     muffleCondition(cond, pattern = "^muffle")
[10:34:16.111]                   }
[10:34:16.111]                 }
[10:34:16.111]             }
[10:34:16.111]         }))
[10:34:16.111]     }, error = function(ex) {
[10:34:16.111]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:16.111]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:16.111]                 ...future.rng), started = ...future.startTime, 
[10:34:16.111]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:16.111]             version = "1.8"), class = "FutureResult")
[10:34:16.111]     }, finally = {
[10:34:16.111]         if (!identical(...future.workdir, getwd())) 
[10:34:16.111]             setwd(...future.workdir)
[10:34:16.111]         {
[10:34:16.111]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:16.111]                 ...future.oldOptions$nwarnings <- NULL
[10:34:16.111]             }
[10:34:16.111]             base::options(...future.oldOptions)
[10:34:16.111]             if (.Platform$OS.type == "windows") {
[10:34:16.111]                 old_names <- names(...future.oldEnvVars)
[10:34:16.111]                 envs <- base::Sys.getenv()
[10:34:16.111]                 names <- names(envs)
[10:34:16.111]                 common <- intersect(names, old_names)
[10:34:16.111]                 added <- setdiff(names, old_names)
[10:34:16.111]                 removed <- setdiff(old_names, names)
[10:34:16.111]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:16.111]                   envs[common]]
[10:34:16.111]                 NAMES <- toupper(changed)
[10:34:16.111]                 args <- list()
[10:34:16.111]                 for (kk in seq_along(NAMES)) {
[10:34:16.111]                   name <- changed[[kk]]
[10:34:16.111]                   NAME <- NAMES[[kk]]
[10:34:16.111]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.111]                     next
[10:34:16.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:16.111]                 }
[10:34:16.111]                 NAMES <- toupper(added)
[10:34:16.111]                 for (kk in seq_along(NAMES)) {
[10:34:16.111]                   name <- added[[kk]]
[10:34:16.111]                   NAME <- NAMES[[kk]]
[10:34:16.111]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.111]                     next
[10:34:16.111]                   args[[name]] <- ""
[10:34:16.111]                 }
[10:34:16.111]                 NAMES <- toupper(removed)
[10:34:16.111]                 for (kk in seq_along(NAMES)) {
[10:34:16.111]                   name <- removed[[kk]]
[10:34:16.111]                   NAME <- NAMES[[kk]]
[10:34:16.111]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.111]                     next
[10:34:16.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:16.111]                 }
[10:34:16.111]                 if (length(args) > 0) 
[10:34:16.111]                   base::do.call(base::Sys.setenv, args = args)
[10:34:16.111]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:16.111]             }
[10:34:16.111]             else {
[10:34:16.111]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:16.111]             }
[10:34:16.111]             {
[10:34:16.111]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:16.111]                   0L) {
[10:34:16.111]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:16.111]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:16.111]                   base::options(opts)
[10:34:16.111]                 }
[10:34:16.111]                 {
[10:34:16.111]                   {
[10:34:16.111]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:16.111]                     NULL
[10:34:16.111]                   }
[10:34:16.111]                   options(future.plan = NULL)
[10:34:16.111]                   if (is.na(NA_character_)) 
[10:34:16.111]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:16.111]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:16.111]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:16.111]                     .init = FALSE)
[10:34:16.111]                 }
[10:34:16.111]             }
[10:34:16.111]         }
[10:34:16.111]     })
[10:34:16.111]     if (TRUE) {
[10:34:16.111]         base::sink(type = "output", split = FALSE)
[10:34:16.111]         if (TRUE) {
[10:34:16.111]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:16.111]         }
[10:34:16.111]         else {
[10:34:16.111]             ...future.result["stdout"] <- base::list(NULL)
[10:34:16.111]         }
[10:34:16.111]         base::close(...future.stdout)
[10:34:16.111]         ...future.stdout <- NULL
[10:34:16.111]     }
[10:34:16.111]     ...future.result$conditions <- ...future.conditions
[10:34:16.111]     ...future.result$finished <- base::Sys.time()
[10:34:16.111]     ...future.result
[10:34:16.111] }
[10:34:16.114] MultisessionFuture started
[10:34:16.114] - Launch lazy future ... done
[10:34:16.114] run() for ‘MultisessionFuture’ ... done
[10:34:16.114] getGlobalsAndPackages() ...
[10:34:16.115] Searching for globals...
[10:34:16.115] 
[10:34:16.115] Searching for globals ... DONE
[10:34:16.115] - globals: [0] <none>
[10:34:16.115] getGlobalsAndPackages() ... DONE
[10:34:16.115] run() for ‘Future’ ...
[10:34:16.115] - state: ‘created’
[10:34:16.116] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:16.129] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:16.129] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:16.129]   - Field: ‘node’
[10:34:16.129]   - Field: ‘label’
[10:34:16.129]   - Field: ‘local’
[10:34:16.129]   - Field: ‘owner’
[10:34:16.130]   - Field: ‘envir’
[10:34:16.130]   - Field: ‘workers’
[10:34:16.130]   - Field: ‘packages’
[10:34:16.130]   - Field: ‘gc’
[10:34:16.130]   - Field: ‘conditions’
[10:34:16.130]   - Field: ‘persistent’
[10:34:16.130]   - Field: ‘expr’
[10:34:16.130]   - Field: ‘uuid’
[10:34:16.130]   - Field: ‘seed’
[10:34:16.130]   - Field: ‘version’
[10:34:16.130]   - Field: ‘result’
[10:34:16.131]   - Field: ‘asynchronous’
[10:34:16.131]   - Field: ‘calls’
[10:34:16.131]   - Field: ‘globals’
[10:34:16.131]   - Field: ‘stdout’
[10:34:16.131]   - Field: ‘earlySignal’
[10:34:16.131]   - Field: ‘lazy’
[10:34:16.131]   - Field: ‘state’
[10:34:16.131] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:16.131] - Launch lazy future ...
[10:34:16.131] Packages needed by the future expression (n = 0): <none>
[10:34:16.132] Packages needed by future strategies (n = 0): <none>
[10:34:16.132] {
[10:34:16.132]     {
[10:34:16.132]         {
[10:34:16.132]             ...future.startTime <- base::Sys.time()
[10:34:16.132]             {
[10:34:16.132]                 {
[10:34:16.132]                   {
[10:34:16.132]                     {
[10:34:16.132]                       base::local({
[10:34:16.132]                         has_future <- base::requireNamespace("future", 
[10:34:16.132]                           quietly = TRUE)
[10:34:16.132]                         if (has_future) {
[10:34:16.132]                           ns <- base::getNamespace("future")
[10:34:16.132]                           version <- ns[[".package"]][["version"]]
[10:34:16.132]                           if (is.null(version)) 
[10:34:16.132]                             version <- utils::packageVersion("future")
[10:34:16.132]                         }
[10:34:16.132]                         else {
[10:34:16.132]                           version <- NULL
[10:34:16.132]                         }
[10:34:16.132]                         if (!has_future || version < "1.8.0") {
[10:34:16.132]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:16.132]                             "", base::R.version$version.string), 
[10:34:16.132]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:16.132]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:16.132]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:16.132]                               "release", "version")], collapse = " "), 
[10:34:16.132]                             hostname = base::Sys.info()[["nodename"]])
[10:34:16.132]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:16.132]                             info)
[10:34:16.132]                           info <- base::paste(info, collapse = "; ")
[10:34:16.132]                           if (!has_future) {
[10:34:16.132]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:16.132]                               info)
[10:34:16.132]                           }
[10:34:16.132]                           else {
[10:34:16.132]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:16.132]                               info, version)
[10:34:16.132]                           }
[10:34:16.132]                           base::stop(msg)
[10:34:16.132]                         }
[10:34:16.132]                       })
[10:34:16.132]                     }
[10:34:16.132]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:16.132]                     base::options(mc.cores = 1L)
[10:34:16.132]                   }
[10:34:16.132]                   ...future.strategy.old <- future::plan("list")
[10:34:16.132]                   options(future.plan = NULL)
[10:34:16.132]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:16.132]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:16.132]                 }
[10:34:16.132]                 ...future.workdir <- getwd()
[10:34:16.132]             }
[10:34:16.132]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:16.132]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:16.132]         }
[10:34:16.132]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:16.132]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:16.132]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:16.132]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:16.132]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:16.132]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:16.132]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:16.132]             base::names(...future.oldOptions))
[10:34:16.132]     }
[10:34:16.132]     if (FALSE) {
[10:34:16.132]     }
[10:34:16.132]     else {
[10:34:16.132]         if (TRUE) {
[10:34:16.132]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:16.132]                 open = "w")
[10:34:16.132]         }
[10:34:16.132]         else {
[10:34:16.132]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:16.132]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:16.132]         }
[10:34:16.132]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:16.132]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:16.132]             base::sink(type = "output", split = FALSE)
[10:34:16.132]             base::close(...future.stdout)
[10:34:16.132]         }, add = TRUE)
[10:34:16.132]     }
[10:34:16.132]     ...future.frame <- base::sys.nframe()
[10:34:16.132]     ...future.conditions <- base::list()
[10:34:16.132]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:16.132]     if (FALSE) {
[10:34:16.132]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:16.132]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:16.132]     }
[10:34:16.132]     ...future.result <- base::tryCatch({
[10:34:16.132]         base::withCallingHandlers({
[10:34:16.132]             ...future.value <- base::withVisible(base::local({
[10:34:16.132]                 ...future.makeSendCondition <- base::local({
[10:34:16.132]                   sendCondition <- NULL
[10:34:16.132]                   function(frame = 1L) {
[10:34:16.132]                     if (is.function(sendCondition)) 
[10:34:16.132]                       return(sendCondition)
[10:34:16.132]                     ns <- getNamespace("parallel")
[10:34:16.132]                     if (exists("sendData", mode = "function", 
[10:34:16.132]                       envir = ns)) {
[10:34:16.132]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:16.132]                         envir = ns)
[10:34:16.132]                       envir <- sys.frame(frame)
[10:34:16.132]                       master <- NULL
[10:34:16.132]                       while (!identical(envir, .GlobalEnv) && 
[10:34:16.132]                         !identical(envir, emptyenv())) {
[10:34:16.132]                         if (exists("master", mode = "list", envir = envir, 
[10:34:16.132]                           inherits = FALSE)) {
[10:34:16.132]                           master <- get("master", mode = "list", 
[10:34:16.132]                             envir = envir, inherits = FALSE)
[10:34:16.132]                           if (inherits(master, c("SOCKnode", 
[10:34:16.132]                             "SOCK0node"))) {
[10:34:16.132]                             sendCondition <<- function(cond) {
[10:34:16.132]                               data <- list(type = "VALUE", value = cond, 
[10:34:16.132]                                 success = TRUE)
[10:34:16.132]                               parallel_sendData(master, data)
[10:34:16.132]                             }
[10:34:16.132]                             return(sendCondition)
[10:34:16.132]                           }
[10:34:16.132]                         }
[10:34:16.132]                         frame <- frame + 1L
[10:34:16.132]                         envir <- sys.frame(frame)
[10:34:16.132]                       }
[10:34:16.132]                     }
[10:34:16.132]                     sendCondition <<- function(cond) NULL
[10:34:16.132]                   }
[10:34:16.132]                 })
[10:34:16.132]                 withCallingHandlers({
[10:34:16.132]                   2
[10:34:16.132]                 }, immediateCondition = function(cond) {
[10:34:16.132]                   sendCondition <- ...future.makeSendCondition()
[10:34:16.132]                   sendCondition(cond)
[10:34:16.132]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.132]                   {
[10:34:16.132]                     inherits <- base::inherits
[10:34:16.132]                     invokeRestart <- base::invokeRestart
[10:34:16.132]                     is.null <- base::is.null
[10:34:16.132]                     muffled <- FALSE
[10:34:16.132]                     if (inherits(cond, "message")) {
[10:34:16.132]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:16.132]                       if (muffled) 
[10:34:16.132]                         invokeRestart("muffleMessage")
[10:34:16.132]                     }
[10:34:16.132]                     else if (inherits(cond, "warning")) {
[10:34:16.132]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:16.132]                       if (muffled) 
[10:34:16.132]                         invokeRestart("muffleWarning")
[10:34:16.132]                     }
[10:34:16.132]                     else if (inherits(cond, "condition")) {
[10:34:16.132]                       if (!is.null(pattern)) {
[10:34:16.132]                         computeRestarts <- base::computeRestarts
[10:34:16.132]                         grepl <- base::grepl
[10:34:16.132]                         restarts <- computeRestarts(cond)
[10:34:16.132]                         for (restart in restarts) {
[10:34:16.132]                           name <- restart$name
[10:34:16.132]                           if (is.null(name)) 
[10:34:16.132]                             next
[10:34:16.132]                           if (!grepl(pattern, name)) 
[10:34:16.132]                             next
[10:34:16.132]                           invokeRestart(restart)
[10:34:16.132]                           muffled <- TRUE
[10:34:16.132]                           break
[10:34:16.132]                         }
[10:34:16.132]                       }
[10:34:16.132]                     }
[10:34:16.132]                     invisible(muffled)
[10:34:16.132]                   }
[10:34:16.132]                   muffleCondition(cond)
[10:34:16.132]                 })
[10:34:16.132]             }))
[10:34:16.132]             future::FutureResult(value = ...future.value$value, 
[10:34:16.132]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:16.132]                   ...future.rng), globalenv = if (FALSE) 
[10:34:16.132]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:16.132]                     ...future.globalenv.names))
[10:34:16.132]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:16.132]         }, condition = base::local({
[10:34:16.132]             c <- base::c
[10:34:16.132]             inherits <- base::inherits
[10:34:16.132]             invokeRestart <- base::invokeRestart
[10:34:16.132]             length <- base::length
[10:34:16.132]             list <- base::list
[10:34:16.132]             seq.int <- base::seq.int
[10:34:16.132]             signalCondition <- base::signalCondition
[10:34:16.132]             sys.calls <- base::sys.calls
[10:34:16.132]             `[[` <- base::`[[`
[10:34:16.132]             `+` <- base::`+`
[10:34:16.132]             `<<-` <- base::`<<-`
[10:34:16.132]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:16.132]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:16.132]                   3L)]
[10:34:16.132]             }
[10:34:16.132]             function(cond) {
[10:34:16.132]                 is_error <- inherits(cond, "error")
[10:34:16.132]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:16.132]                   NULL)
[10:34:16.132]                 if (is_error) {
[10:34:16.132]                   sessionInformation <- function() {
[10:34:16.132]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:16.132]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:16.132]                       search = base::search(), system = base::Sys.info())
[10:34:16.132]                   }
[10:34:16.132]                   ...future.conditions[[length(...future.conditions) + 
[10:34:16.132]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:16.132]                     cond$call), session = sessionInformation(), 
[10:34:16.132]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:16.132]                   signalCondition(cond)
[10:34:16.132]                 }
[10:34:16.132]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:16.132]                 "immediateCondition"))) {
[10:34:16.132]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:16.132]                   ...future.conditions[[length(...future.conditions) + 
[10:34:16.132]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:16.132]                   if (TRUE && !signal) {
[10:34:16.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.132]                     {
[10:34:16.132]                       inherits <- base::inherits
[10:34:16.132]                       invokeRestart <- base::invokeRestart
[10:34:16.132]                       is.null <- base::is.null
[10:34:16.132]                       muffled <- FALSE
[10:34:16.132]                       if (inherits(cond, "message")) {
[10:34:16.132]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:16.132]                         if (muffled) 
[10:34:16.132]                           invokeRestart("muffleMessage")
[10:34:16.132]                       }
[10:34:16.132]                       else if (inherits(cond, "warning")) {
[10:34:16.132]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:16.132]                         if (muffled) 
[10:34:16.132]                           invokeRestart("muffleWarning")
[10:34:16.132]                       }
[10:34:16.132]                       else if (inherits(cond, "condition")) {
[10:34:16.132]                         if (!is.null(pattern)) {
[10:34:16.132]                           computeRestarts <- base::computeRestarts
[10:34:16.132]                           grepl <- base::grepl
[10:34:16.132]                           restarts <- computeRestarts(cond)
[10:34:16.132]                           for (restart in restarts) {
[10:34:16.132]                             name <- restart$name
[10:34:16.132]                             if (is.null(name)) 
[10:34:16.132]                               next
[10:34:16.132]                             if (!grepl(pattern, name)) 
[10:34:16.132]                               next
[10:34:16.132]                             invokeRestart(restart)
[10:34:16.132]                             muffled <- TRUE
[10:34:16.132]                             break
[10:34:16.132]                           }
[10:34:16.132]                         }
[10:34:16.132]                       }
[10:34:16.132]                       invisible(muffled)
[10:34:16.132]                     }
[10:34:16.132]                     muffleCondition(cond, pattern = "^muffle")
[10:34:16.132]                   }
[10:34:16.132]                 }
[10:34:16.132]                 else {
[10:34:16.132]                   if (TRUE) {
[10:34:16.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.132]                     {
[10:34:16.132]                       inherits <- base::inherits
[10:34:16.132]                       invokeRestart <- base::invokeRestart
[10:34:16.132]                       is.null <- base::is.null
[10:34:16.132]                       muffled <- FALSE
[10:34:16.132]                       if (inherits(cond, "message")) {
[10:34:16.132]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:16.132]                         if (muffled) 
[10:34:16.132]                           invokeRestart("muffleMessage")
[10:34:16.132]                       }
[10:34:16.132]                       else if (inherits(cond, "warning")) {
[10:34:16.132]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:16.132]                         if (muffled) 
[10:34:16.132]                           invokeRestart("muffleWarning")
[10:34:16.132]                       }
[10:34:16.132]                       else if (inherits(cond, "condition")) {
[10:34:16.132]                         if (!is.null(pattern)) {
[10:34:16.132]                           computeRestarts <- base::computeRestarts
[10:34:16.132]                           grepl <- base::grepl
[10:34:16.132]                           restarts <- computeRestarts(cond)
[10:34:16.132]                           for (restart in restarts) {
[10:34:16.132]                             name <- restart$name
[10:34:16.132]                             if (is.null(name)) 
[10:34:16.132]                               next
[10:34:16.132]                             if (!grepl(pattern, name)) 
[10:34:16.132]                               next
[10:34:16.132]                             invokeRestart(restart)
[10:34:16.132]                             muffled <- TRUE
[10:34:16.132]                             break
[10:34:16.132]                           }
[10:34:16.132]                         }
[10:34:16.132]                       }
[10:34:16.132]                       invisible(muffled)
[10:34:16.132]                     }
[10:34:16.132]                     muffleCondition(cond, pattern = "^muffle")
[10:34:16.132]                   }
[10:34:16.132]                 }
[10:34:16.132]             }
[10:34:16.132]         }))
[10:34:16.132]     }, error = function(ex) {
[10:34:16.132]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:16.132]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:16.132]                 ...future.rng), started = ...future.startTime, 
[10:34:16.132]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:16.132]             version = "1.8"), class = "FutureResult")
[10:34:16.132]     }, finally = {
[10:34:16.132]         if (!identical(...future.workdir, getwd())) 
[10:34:16.132]             setwd(...future.workdir)
[10:34:16.132]         {
[10:34:16.132]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:16.132]                 ...future.oldOptions$nwarnings <- NULL
[10:34:16.132]             }
[10:34:16.132]             base::options(...future.oldOptions)
[10:34:16.132]             if (.Platform$OS.type == "windows") {
[10:34:16.132]                 old_names <- names(...future.oldEnvVars)
[10:34:16.132]                 envs <- base::Sys.getenv()
[10:34:16.132]                 names <- names(envs)
[10:34:16.132]                 common <- intersect(names, old_names)
[10:34:16.132]                 added <- setdiff(names, old_names)
[10:34:16.132]                 removed <- setdiff(old_names, names)
[10:34:16.132]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:16.132]                   envs[common]]
[10:34:16.132]                 NAMES <- toupper(changed)
[10:34:16.132]                 args <- list()
[10:34:16.132]                 for (kk in seq_along(NAMES)) {
[10:34:16.132]                   name <- changed[[kk]]
[10:34:16.132]                   NAME <- NAMES[[kk]]
[10:34:16.132]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.132]                     next
[10:34:16.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:16.132]                 }
[10:34:16.132]                 NAMES <- toupper(added)
[10:34:16.132]                 for (kk in seq_along(NAMES)) {
[10:34:16.132]                   name <- added[[kk]]
[10:34:16.132]                   NAME <- NAMES[[kk]]
[10:34:16.132]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.132]                     next
[10:34:16.132]                   args[[name]] <- ""
[10:34:16.132]                 }
[10:34:16.132]                 NAMES <- toupper(removed)
[10:34:16.132]                 for (kk in seq_along(NAMES)) {
[10:34:16.132]                   name <- removed[[kk]]
[10:34:16.132]                   NAME <- NAMES[[kk]]
[10:34:16.132]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.132]                     next
[10:34:16.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:16.132]                 }
[10:34:16.132]                 if (length(args) > 0) 
[10:34:16.132]                   base::do.call(base::Sys.setenv, args = args)
[10:34:16.132]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:16.132]             }
[10:34:16.132]             else {
[10:34:16.132]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:16.132]             }
[10:34:16.132]             {
[10:34:16.132]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:16.132]                   0L) {
[10:34:16.132]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:16.132]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:16.132]                   base::options(opts)
[10:34:16.132]                 }
[10:34:16.132]                 {
[10:34:16.132]                   {
[10:34:16.132]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:16.132]                     NULL
[10:34:16.132]                   }
[10:34:16.132]                   options(future.plan = NULL)
[10:34:16.132]                   if (is.na(NA_character_)) 
[10:34:16.132]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:16.132]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:16.132]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:16.132]                     .init = FALSE)
[10:34:16.132]                 }
[10:34:16.132]             }
[10:34:16.132]         }
[10:34:16.132]     })
[10:34:16.132]     if (TRUE) {
[10:34:16.132]         base::sink(type = "output", split = FALSE)
[10:34:16.132]         if (TRUE) {
[10:34:16.132]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:16.132]         }
[10:34:16.132]         else {
[10:34:16.132]             ...future.result["stdout"] <- base::list(NULL)
[10:34:16.132]         }
[10:34:16.132]         base::close(...future.stdout)
[10:34:16.132]         ...future.stdout <- NULL
[10:34:16.132]     }
[10:34:16.132]     ...future.result$conditions <- ...future.conditions
[10:34:16.132]     ...future.result$finished <- base::Sys.time()
[10:34:16.132]     ...future.result
[10:34:16.132] }
[10:34:16.134] Poll #1 (0): usedNodes() = 2, workers = 2
[10:34:16.145] receiveMessageFromWorker() for ClusterFuture ...
[10:34:16.145] - Validating connection of MultisessionFuture
[10:34:16.145] - received message: FutureResult
[10:34:16.145] - Received FutureResult
[10:34:16.145] - Erased future from FutureRegistry
[10:34:16.145] result() for ClusterFuture ...
[10:34:16.146] - result already collected: FutureResult
[10:34:16.146] result() for ClusterFuture ... done
[10:34:16.146] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:16.146] result() for ClusterFuture ...
[10:34:16.146] - result already collected: FutureResult
[10:34:16.146] result() for ClusterFuture ... done
[10:34:16.146] result() for ClusterFuture ...
[10:34:16.146] - result already collected: FutureResult
[10:34:16.146] result() for ClusterFuture ... done
[10:34:16.147] MultisessionFuture started
[10:34:16.147] - Launch lazy future ... done
[10:34:16.147] run() for ‘MultisessionFuture’ ... done
[10:34:16.148] resolve() on list ...
[10:34:16.148]  recursive: 0
[10:34:16.148]  length: 3
[10:34:16.148]  elements: ‘a’, ‘b’, ‘’
[10:34:16.148] receiveMessageFromWorker() for ClusterFuture ...
[10:34:16.148] - Validating connection of MultisessionFuture
[10:34:16.149] - received message: FutureResult
[10:34:16.149] - Received FutureResult
[10:34:16.149] - Erased future from FutureRegistry
[10:34:16.149] result() for ClusterFuture ...
[10:34:16.149] - result already collected: FutureResult
[10:34:16.149] result() for ClusterFuture ... done
[10:34:16.149] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:16.149] Future #1
[10:34:16.149]  length: 2 (resolved future 1)
[10:34:16.150] receiveMessageFromWorker() for ClusterFuture ...
[10:34:16.150] - Validating connection of MultisessionFuture
[10:34:16.150] - received message: FutureResult
[10:34:16.150] - Received FutureResult
[10:34:16.150] - Erased future from FutureRegistry
[10:34:16.150] result() for ClusterFuture ...
[10:34:16.151] - result already collected: FutureResult
[10:34:16.151] result() for ClusterFuture ... done
[10:34:16.151] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:16.151] Future #2
[10:34:16.151]  length: 1 (resolved future 2)
[10:34:16.151]  length: 0 (resolved future 3)
[10:34:16.151] resolve() on list ... DONE
[10:34:16.151] getGlobalsAndPackages() ...
[10:34:16.151] Searching for globals...
[10:34:16.152] 
[10:34:16.152] Searching for globals ... DONE
[10:34:16.152] - globals: [0] <none>
[10:34:16.152] getGlobalsAndPackages() ... DONE
[10:34:16.152] getGlobalsAndPackages() ...
[10:34:16.152] Searching for globals...
[10:34:16.152] 
[10:34:16.153] Searching for globals ... DONE
[10:34:16.153] - globals: [0] <none>
[10:34:16.153] getGlobalsAndPackages() ... DONE
[10:34:16.153] run() for ‘Future’ ...
[10:34:16.153] - state: ‘created’
[10:34:16.153] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:16.169] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:16.169] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:16.170]   - Field: ‘node’
[10:34:16.170]   - Field: ‘label’
[10:34:16.170]   - Field: ‘local’
[10:34:16.170]   - Field: ‘owner’
[10:34:16.170]   - Field: ‘envir’
[10:34:16.170]   - Field: ‘workers’
[10:34:16.170]   - Field: ‘packages’
[10:34:16.170]   - Field: ‘gc’
[10:34:16.170]   - Field: ‘conditions’
[10:34:16.170]   - Field: ‘persistent’
[10:34:16.170]   - Field: ‘expr’
[10:34:16.171]   - Field: ‘uuid’
[10:34:16.171]   - Field: ‘seed’
[10:34:16.171]   - Field: ‘version’
[10:34:16.171]   - Field: ‘result’
[10:34:16.171]   - Field: ‘asynchronous’
[10:34:16.171]   - Field: ‘calls’
[10:34:16.171]   - Field: ‘globals’
[10:34:16.171]   - Field: ‘stdout’
[10:34:16.171]   - Field: ‘earlySignal’
[10:34:16.171]   - Field: ‘lazy’
[10:34:16.171]   - Field: ‘state’
[10:34:16.172] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:16.172] - Launch lazy future ...
[10:34:16.172] Packages needed by the future expression (n = 0): <none>
[10:34:16.172] Packages needed by future strategies (n = 0): <none>
[10:34:16.172] {
[10:34:16.172]     {
[10:34:16.172]         {
[10:34:16.172]             ...future.startTime <- base::Sys.time()
[10:34:16.172]             {
[10:34:16.172]                 {
[10:34:16.172]                   {
[10:34:16.172]                     {
[10:34:16.172]                       base::local({
[10:34:16.172]                         has_future <- base::requireNamespace("future", 
[10:34:16.172]                           quietly = TRUE)
[10:34:16.172]                         if (has_future) {
[10:34:16.172]                           ns <- base::getNamespace("future")
[10:34:16.172]                           version <- ns[[".package"]][["version"]]
[10:34:16.172]                           if (is.null(version)) 
[10:34:16.172]                             version <- utils::packageVersion("future")
[10:34:16.172]                         }
[10:34:16.172]                         else {
[10:34:16.172]                           version <- NULL
[10:34:16.172]                         }
[10:34:16.172]                         if (!has_future || version < "1.8.0") {
[10:34:16.172]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:16.172]                             "", base::R.version$version.string), 
[10:34:16.172]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:16.172]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:16.172]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:16.172]                               "release", "version")], collapse = " "), 
[10:34:16.172]                             hostname = base::Sys.info()[["nodename"]])
[10:34:16.172]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:16.172]                             info)
[10:34:16.172]                           info <- base::paste(info, collapse = "; ")
[10:34:16.172]                           if (!has_future) {
[10:34:16.172]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:16.172]                               info)
[10:34:16.172]                           }
[10:34:16.172]                           else {
[10:34:16.172]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:16.172]                               info, version)
[10:34:16.172]                           }
[10:34:16.172]                           base::stop(msg)
[10:34:16.172]                         }
[10:34:16.172]                       })
[10:34:16.172]                     }
[10:34:16.172]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:16.172]                     base::options(mc.cores = 1L)
[10:34:16.172]                   }
[10:34:16.172]                   ...future.strategy.old <- future::plan("list")
[10:34:16.172]                   options(future.plan = NULL)
[10:34:16.172]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:16.172]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:16.172]                 }
[10:34:16.172]                 ...future.workdir <- getwd()
[10:34:16.172]             }
[10:34:16.172]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:16.172]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:16.172]         }
[10:34:16.172]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:16.172]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:16.172]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:16.172]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:16.172]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:16.172]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:16.172]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:16.172]             base::names(...future.oldOptions))
[10:34:16.172]     }
[10:34:16.172]     if (FALSE) {
[10:34:16.172]     }
[10:34:16.172]     else {
[10:34:16.172]         if (TRUE) {
[10:34:16.172]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:16.172]                 open = "w")
[10:34:16.172]         }
[10:34:16.172]         else {
[10:34:16.172]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:16.172]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:16.172]         }
[10:34:16.172]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:16.172]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:16.172]             base::sink(type = "output", split = FALSE)
[10:34:16.172]             base::close(...future.stdout)
[10:34:16.172]         }, add = TRUE)
[10:34:16.172]     }
[10:34:16.172]     ...future.frame <- base::sys.nframe()
[10:34:16.172]     ...future.conditions <- base::list()
[10:34:16.172]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:16.172]     if (FALSE) {
[10:34:16.172]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:16.172]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:16.172]     }
[10:34:16.172]     ...future.result <- base::tryCatch({
[10:34:16.172]         base::withCallingHandlers({
[10:34:16.172]             ...future.value <- base::withVisible(base::local({
[10:34:16.172]                 ...future.makeSendCondition <- base::local({
[10:34:16.172]                   sendCondition <- NULL
[10:34:16.172]                   function(frame = 1L) {
[10:34:16.172]                     if (is.function(sendCondition)) 
[10:34:16.172]                       return(sendCondition)
[10:34:16.172]                     ns <- getNamespace("parallel")
[10:34:16.172]                     if (exists("sendData", mode = "function", 
[10:34:16.172]                       envir = ns)) {
[10:34:16.172]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:16.172]                         envir = ns)
[10:34:16.172]                       envir <- sys.frame(frame)
[10:34:16.172]                       master <- NULL
[10:34:16.172]                       while (!identical(envir, .GlobalEnv) && 
[10:34:16.172]                         !identical(envir, emptyenv())) {
[10:34:16.172]                         if (exists("master", mode = "list", envir = envir, 
[10:34:16.172]                           inherits = FALSE)) {
[10:34:16.172]                           master <- get("master", mode = "list", 
[10:34:16.172]                             envir = envir, inherits = FALSE)
[10:34:16.172]                           if (inherits(master, c("SOCKnode", 
[10:34:16.172]                             "SOCK0node"))) {
[10:34:16.172]                             sendCondition <<- function(cond) {
[10:34:16.172]                               data <- list(type = "VALUE", value = cond, 
[10:34:16.172]                                 success = TRUE)
[10:34:16.172]                               parallel_sendData(master, data)
[10:34:16.172]                             }
[10:34:16.172]                             return(sendCondition)
[10:34:16.172]                           }
[10:34:16.172]                         }
[10:34:16.172]                         frame <- frame + 1L
[10:34:16.172]                         envir <- sys.frame(frame)
[10:34:16.172]                       }
[10:34:16.172]                     }
[10:34:16.172]                     sendCondition <<- function(cond) NULL
[10:34:16.172]                   }
[10:34:16.172]                 })
[10:34:16.172]                 withCallingHandlers({
[10:34:16.172]                   2
[10:34:16.172]                 }, immediateCondition = function(cond) {
[10:34:16.172]                   sendCondition <- ...future.makeSendCondition()
[10:34:16.172]                   sendCondition(cond)
[10:34:16.172]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.172]                   {
[10:34:16.172]                     inherits <- base::inherits
[10:34:16.172]                     invokeRestart <- base::invokeRestart
[10:34:16.172]                     is.null <- base::is.null
[10:34:16.172]                     muffled <- FALSE
[10:34:16.172]                     if (inherits(cond, "message")) {
[10:34:16.172]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:16.172]                       if (muffled) 
[10:34:16.172]                         invokeRestart("muffleMessage")
[10:34:16.172]                     }
[10:34:16.172]                     else if (inherits(cond, "warning")) {
[10:34:16.172]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:16.172]                       if (muffled) 
[10:34:16.172]                         invokeRestart("muffleWarning")
[10:34:16.172]                     }
[10:34:16.172]                     else if (inherits(cond, "condition")) {
[10:34:16.172]                       if (!is.null(pattern)) {
[10:34:16.172]                         computeRestarts <- base::computeRestarts
[10:34:16.172]                         grepl <- base::grepl
[10:34:16.172]                         restarts <- computeRestarts(cond)
[10:34:16.172]                         for (restart in restarts) {
[10:34:16.172]                           name <- restart$name
[10:34:16.172]                           if (is.null(name)) 
[10:34:16.172]                             next
[10:34:16.172]                           if (!grepl(pattern, name)) 
[10:34:16.172]                             next
[10:34:16.172]                           invokeRestart(restart)
[10:34:16.172]                           muffled <- TRUE
[10:34:16.172]                           break
[10:34:16.172]                         }
[10:34:16.172]                       }
[10:34:16.172]                     }
[10:34:16.172]                     invisible(muffled)
[10:34:16.172]                   }
[10:34:16.172]                   muffleCondition(cond)
[10:34:16.172]                 })
[10:34:16.172]             }))
[10:34:16.172]             future::FutureResult(value = ...future.value$value, 
[10:34:16.172]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:16.172]                   ...future.rng), globalenv = if (FALSE) 
[10:34:16.172]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:16.172]                     ...future.globalenv.names))
[10:34:16.172]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:16.172]         }, condition = base::local({
[10:34:16.172]             c <- base::c
[10:34:16.172]             inherits <- base::inherits
[10:34:16.172]             invokeRestart <- base::invokeRestart
[10:34:16.172]             length <- base::length
[10:34:16.172]             list <- base::list
[10:34:16.172]             seq.int <- base::seq.int
[10:34:16.172]             signalCondition <- base::signalCondition
[10:34:16.172]             sys.calls <- base::sys.calls
[10:34:16.172]             `[[` <- base::`[[`
[10:34:16.172]             `+` <- base::`+`
[10:34:16.172]             `<<-` <- base::`<<-`
[10:34:16.172]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:16.172]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:16.172]                   3L)]
[10:34:16.172]             }
[10:34:16.172]             function(cond) {
[10:34:16.172]                 is_error <- inherits(cond, "error")
[10:34:16.172]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:16.172]                   NULL)
[10:34:16.172]                 if (is_error) {
[10:34:16.172]                   sessionInformation <- function() {
[10:34:16.172]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:16.172]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:16.172]                       search = base::search(), system = base::Sys.info())
[10:34:16.172]                   }
[10:34:16.172]                   ...future.conditions[[length(...future.conditions) + 
[10:34:16.172]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:16.172]                     cond$call), session = sessionInformation(), 
[10:34:16.172]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:16.172]                   signalCondition(cond)
[10:34:16.172]                 }
[10:34:16.172]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:16.172]                 "immediateCondition"))) {
[10:34:16.172]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:16.172]                   ...future.conditions[[length(...future.conditions) + 
[10:34:16.172]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:16.172]                   if (TRUE && !signal) {
[10:34:16.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.172]                     {
[10:34:16.172]                       inherits <- base::inherits
[10:34:16.172]                       invokeRestart <- base::invokeRestart
[10:34:16.172]                       is.null <- base::is.null
[10:34:16.172]                       muffled <- FALSE
[10:34:16.172]                       if (inherits(cond, "message")) {
[10:34:16.172]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:16.172]                         if (muffled) 
[10:34:16.172]                           invokeRestart("muffleMessage")
[10:34:16.172]                       }
[10:34:16.172]                       else if (inherits(cond, "warning")) {
[10:34:16.172]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:16.172]                         if (muffled) 
[10:34:16.172]                           invokeRestart("muffleWarning")
[10:34:16.172]                       }
[10:34:16.172]                       else if (inherits(cond, "condition")) {
[10:34:16.172]                         if (!is.null(pattern)) {
[10:34:16.172]                           computeRestarts <- base::computeRestarts
[10:34:16.172]                           grepl <- base::grepl
[10:34:16.172]                           restarts <- computeRestarts(cond)
[10:34:16.172]                           for (restart in restarts) {
[10:34:16.172]                             name <- restart$name
[10:34:16.172]                             if (is.null(name)) 
[10:34:16.172]                               next
[10:34:16.172]                             if (!grepl(pattern, name)) 
[10:34:16.172]                               next
[10:34:16.172]                             invokeRestart(restart)
[10:34:16.172]                             muffled <- TRUE
[10:34:16.172]                             break
[10:34:16.172]                           }
[10:34:16.172]                         }
[10:34:16.172]                       }
[10:34:16.172]                       invisible(muffled)
[10:34:16.172]                     }
[10:34:16.172]                     muffleCondition(cond, pattern = "^muffle")
[10:34:16.172]                   }
[10:34:16.172]                 }
[10:34:16.172]                 else {
[10:34:16.172]                   if (TRUE) {
[10:34:16.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.172]                     {
[10:34:16.172]                       inherits <- base::inherits
[10:34:16.172]                       invokeRestart <- base::invokeRestart
[10:34:16.172]                       is.null <- base::is.null
[10:34:16.172]                       muffled <- FALSE
[10:34:16.172]                       if (inherits(cond, "message")) {
[10:34:16.172]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:16.172]                         if (muffled) 
[10:34:16.172]                           invokeRestart("muffleMessage")
[10:34:16.172]                       }
[10:34:16.172]                       else if (inherits(cond, "warning")) {
[10:34:16.172]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:16.172]                         if (muffled) 
[10:34:16.172]                           invokeRestart("muffleWarning")
[10:34:16.172]                       }
[10:34:16.172]                       else if (inherits(cond, "condition")) {
[10:34:16.172]                         if (!is.null(pattern)) {
[10:34:16.172]                           computeRestarts <- base::computeRestarts
[10:34:16.172]                           grepl <- base::grepl
[10:34:16.172]                           restarts <- computeRestarts(cond)
[10:34:16.172]                           for (restart in restarts) {
[10:34:16.172]                             name <- restart$name
[10:34:16.172]                             if (is.null(name)) 
[10:34:16.172]                               next
[10:34:16.172]                             if (!grepl(pattern, name)) 
[10:34:16.172]                               next
[10:34:16.172]                             invokeRestart(restart)
[10:34:16.172]                             muffled <- TRUE
[10:34:16.172]                             break
[10:34:16.172]                           }
[10:34:16.172]                         }
[10:34:16.172]                       }
[10:34:16.172]                       invisible(muffled)
[10:34:16.172]                     }
[10:34:16.172]                     muffleCondition(cond, pattern = "^muffle")
[10:34:16.172]                   }
[10:34:16.172]                 }
[10:34:16.172]             }
[10:34:16.172]         }))
[10:34:16.172]     }, error = function(ex) {
[10:34:16.172]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:16.172]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:16.172]                 ...future.rng), started = ...future.startTime, 
[10:34:16.172]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:16.172]             version = "1.8"), class = "FutureResult")
[10:34:16.172]     }, finally = {
[10:34:16.172]         if (!identical(...future.workdir, getwd())) 
[10:34:16.172]             setwd(...future.workdir)
[10:34:16.172]         {
[10:34:16.172]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:16.172]                 ...future.oldOptions$nwarnings <- NULL
[10:34:16.172]             }
[10:34:16.172]             base::options(...future.oldOptions)
[10:34:16.172]             if (.Platform$OS.type == "windows") {
[10:34:16.172]                 old_names <- names(...future.oldEnvVars)
[10:34:16.172]                 envs <- base::Sys.getenv()
[10:34:16.172]                 names <- names(envs)
[10:34:16.172]                 common <- intersect(names, old_names)
[10:34:16.172]                 added <- setdiff(names, old_names)
[10:34:16.172]                 removed <- setdiff(old_names, names)
[10:34:16.172]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:16.172]                   envs[common]]
[10:34:16.172]                 NAMES <- toupper(changed)
[10:34:16.172]                 args <- list()
[10:34:16.172]                 for (kk in seq_along(NAMES)) {
[10:34:16.172]                   name <- changed[[kk]]
[10:34:16.172]                   NAME <- NAMES[[kk]]
[10:34:16.172]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.172]                     next
[10:34:16.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:16.172]                 }
[10:34:16.172]                 NAMES <- toupper(added)
[10:34:16.172]                 for (kk in seq_along(NAMES)) {
[10:34:16.172]                   name <- added[[kk]]
[10:34:16.172]                   NAME <- NAMES[[kk]]
[10:34:16.172]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.172]                     next
[10:34:16.172]                   args[[name]] <- ""
[10:34:16.172]                 }
[10:34:16.172]                 NAMES <- toupper(removed)
[10:34:16.172]                 for (kk in seq_along(NAMES)) {
[10:34:16.172]                   name <- removed[[kk]]
[10:34:16.172]                   NAME <- NAMES[[kk]]
[10:34:16.172]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.172]                     next
[10:34:16.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:16.172]                 }
[10:34:16.172]                 if (length(args) > 0) 
[10:34:16.172]                   base::do.call(base::Sys.setenv, args = args)
[10:34:16.172]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:16.172]             }
[10:34:16.172]             else {
[10:34:16.172]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:16.172]             }
[10:34:16.172]             {
[10:34:16.172]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:16.172]                   0L) {
[10:34:16.172]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:16.172]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:16.172]                   base::options(opts)
[10:34:16.172]                 }
[10:34:16.172]                 {
[10:34:16.172]                   {
[10:34:16.172]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:16.172]                     NULL
[10:34:16.172]                   }
[10:34:16.172]                   options(future.plan = NULL)
[10:34:16.172]                   if (is.na(NA_character_)) 
[10:34:16.172]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:16.172]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:16.172]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:16.172]                     .init = FALSE)
[10:34:16.172]                 }
[10:34:16.172]             }
[10:34:16.172]         }
[10:34:16.172]     })
[10:34:16.172]     if (TRUE) {
[10:34:16.172]         base::sink(type = "output", split = FALSE)
[10:34:16.172]         if (TRUE) {
[10:34:16.172]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:16.172]         }
[10:34:16.172]         else {
[10:34:16.172]             ...future.result["stdout"] <- base::list(NULL)
[10:34:16.172]         }
[10:34:16.172]         base::close(...future.stdout)
[10:34:16.172]         ...future.stdout <- NULL
[10:34:16.172]     }
[10:34:16.172]     ...future.result$conditions <- ...future.conditions
[10:34:16.172]     ...future.result$finished <- base::Sys.time()
[10:34:16.172]     ...future.result
[10:34:16.172] }
[10:34:16.175] MultisessionFuture started
[10:34:16.175] - Launch lazy future ... done
[10:34:16.175] run() for ‘MultisessionFuture’ ... done
[10:34:16.176] resolve() on list ...
[10:34:16.176]  recursive: 0
[10:34:16.176]  length: 3
[10:34:16.176]  elements: ‘a’, ‘b’, ‘’
[10:34:16.176] run() for ‘Future’ ...
[10:34:16.176] - state: ‘created’
[10:34:16.176] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:16.189] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:16.190] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:16.190]   - Field: ‘node’
[10:34:16.190]   - Field: ‘label’
[10:34:16.190]   - Field: ‘local’
[10:34:16.190]   - Field: ‘owner’
[10:34:16.190]   - Field: ‘envir’
[10:34:16.190]   - Field: ‘workers’
[10:34:16.190]   - Field: ‘packages’
[10:34:16.190]   - Field: ‘gc’
[10:34:16.190]   - Field: ‘conditions’
[10:34:16.191]   - Field: ‘persistent’
[10:34:16.191]   - Field: ‘expr’
[10:34:16.191]   - Field: ‘uuid’
[10:34:16.191]   - Field: ‘seed’
[10:34:16.191]   - Field: ‘version’
[10:34:16.191]   - Field: ‘result’
[10:34:16.191]   - Field: ‘asynchronous’
[10:34:16.191]   - Field: ‘calls’
[10:34:16.191]   - Field: ‘globals’
[10:34:16.191]   - Field: ‘stdout’
[10:34:16.191]   - Field: ‘earlySignal’
[10:34:16.192]   - Field: ‘lazy’
[10:34:16.192]   - Field: ‘state’
[10:34:16.192] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:16.192] - Launch lazy future ...
[10:34:16.192] Packages needed by the future expression (n = 0): <none>
[10:34:16.192] Packages needed by future strategies (n = 0): <none>
[10:34:16.193] {
[10:34:16.193]     {
[10:34:16.193]         {
[10:34:16.193]             ...future.startTime <- base::Sys.time()
[10:34:16.193]             {
[10:34:16.193]                 {
[10:34:16.193]                   {
[10:34:16.193]                     {
[10:34:16.193]                       base::local({
[10:34:16.193]                         has_future <- base::requireNamespace("future", 
[10:34:16.193]                           quietly = TRUE)
[10:34:16.193]                         if (has_future) {
[10:34:16.193]                           ns <- base::getNamespace("future")
[10:34:16.193]                           version <- ns[[".package"]][["version"]]
[10:34:16.193]                           if (is.null(version)) 
[10:34:16.193]                             version <- utils::packageVersion("future")
[10:34:16.193]                         }
[10:34:16.193]                         else {
[10:34:16.193]                           version <- NULL
[10:34:16.193]                         }
[10:34:16.193]                         if (!has_future || version < "1.8.0") {
[10:34:16.193]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:16.193]                             "", base::R.version$version.string), 
[10:34:16.193]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:16.193]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:16.193]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:16.193]                               "release", "version")], collapse = " "), 
[10:34:16.193]                             hostname = base::Sys.info()[["nodename"]])
[10:34:16.193]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:16.193]                             info)
[10:34:16.193]                           info <- base::paste(info, collapse = "; ")
[10:34:16.193]                           if (!has_future) {
[10:34:16.193]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:16.193]                               info)
[10:34:16.193]                           }
[10:34:16.193]                           else {
[10:34:16.193]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:16.193]                               info, version)
[10:34:16.193]                           }
[10:34:16.193]                           base::stop(msg)
[10:34:16.193]                         }
[10:34:16.193]                       })
[10:34:16.193]                     }
[10:34:16.193]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:16.193]                     base::options(mc.cores = 1L)
[10:34:16.193]                   }
[10:34:16.193]                   ...future.strategy.old <- future::plan("list")
[10:34:16.193]                   options(future.plan = NULL)
[10:34:16.193]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:16.193]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:16.193]                 }
[10:34:16.193]                 ...future.workdir <- getwd()
[10:34:16.193]             }
[10:34:16.193]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:16.193]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:16.193]         }
[10:34:16.193]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:16.193]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:16.193]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:16.193]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:16.193]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:16.193]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:16.193]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:16.193]             base::names(...future.oldOptions))
[10:34:16.193]     }
[10:34:16.193]     if (FALSE) {
[10:34:16.193]     }
[10:34:16.193]     else {
[10:34:16.193]         if (TRUE) {
[10:34:16.193]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:16.193]                 open = "w")
[10:34:16.193]         }
[10:34:16.193]         else {
[10:34:16.193]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:16.193]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:16.193]         }
[10:34:16.193]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:16.193]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:16.193]             base::sink(type = "output", split = FALSE)
[10:34:16.193]             base::close(...future.stdout)
[10:34:16.193]         }, add = TRUE)
[10:34:16.193]     }
[10:34:16.193]     ...future.frame <- base::sys.nframe()
[10:34:16.193]     ...future.conditions <- base::list()
[10:34:16.193]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:16.193]     if (FALSE) {
[10:34:16.193]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:16.193]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:16.193]     }
[10:34:16.193]     ...future.result <- base::tryCatch({
[10:34:16.193]         base::withCallingHandlers({
[10:34:16.193]             ...future.value <- base::withVisible(base::local({
[10:34:16.193]                 ...future.makeSendCondition <- base::local({
[10:34:16.193]                   sendCondition <- NULL
[10:34:16.193]                   function(frame = 1L) {
[10:34:16.193]                     if (is.function(sendCondition)) 
[10:34:16.193]                       return(sendCondition)
[10:34:16.193]                     ns <- getNamespace("parallel")
[10:34:16.193]                     if (exists("sendData", mode = "function", 
[10:34:16.193]                       envir = ns)) {
[10:34:16.193]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:16.193]                         envir = ns)
[10:34:16.193]                       envir <- sys.frame(frame)
[10:34:16.193]                       master <- NULL
[10:34:16.193]                       while (!identical(envir, .GlobalEnv) && 
[10:34:16.193]                         !identical(envir, emptyenv())) {
[10:34:16.193]                         if (exists("master", mode = "list", envir = envir, 
[10:34:16.193]                           inherits = FALSE)) {
[10:34:16.193]                           master <- get("master", mode = "list", 
[10:34:16.193]                             envir = envir, inherits = FALSE)
[10:34:16.193]                           if (inherits(master, c("SOCKnode", 
[10:34:16.193]                             "SOCK0node"))) {
[10:34:16.193]                             sendCondition <<- function(cond) {
[10:34:16.193]                               data <- list(type = "VALUE", value = cond, 
[10:34:16.193]                                 success = TRUE)
[10:34:16.193]                               parallel_sendData(master, data)
[10:34:16.193]                             }
[10:34:16.193]                             return(sendCondition)
[10:34:16.193]                           }
[10:34:16.193]                         }
[10:34:16.193]                         frame <- frame + 1L
[10:34:16.193]                         envir <- sys.frame(frame)
[10:34:16.193]                       }
[10:34:16.193]                     }
[10:34:16.193]                     sendCondition <<- function(cond) NULL
[10:34:16.193]                   }
[10:34:16.193]                 })
[10:34:16.193]                 withCallingHandlers({
[10:34:16.193]                   1
[10:34:16.193]                 }, immediateCondition = function(cond) {
[10:34:16.193]                   sendCondition <- ...future.makeSendCondition()
[10:34:16.193]                   sendCondition(cond)
[10:34:16.193]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.193]                   {
[10:34:16.193]                     inherits <- base::inherits
[10:34:16.193]                     invokeRestart <- base::invokeRestart
[10:34:16.193]                     is.null <- base::is.null
[10:34:16.193]                     muffled <- FALSE
[10:34:16.193]                     if (inherits(cond, "message")) {
[10:34:16.193]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:16.193]                       if (muffled) 
[10:34:16.193]                         invokeRestart("muffleMessage")
[10:34:16.193]                     }
[10:34:16.193]                     else if (inherits(cond, "warning")) {
[10:34:16.193]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:16.193]                       if (muffled) 
[10:34:16.193]                         invokeRestart("muffleWarning")
[10:34:16.193]                     }
[10:34:16.193]                     else if (inherits(cond, "condition")) {
[10:34:16.193]                       if (!is.null(pattern)) {
[10:34:16.193]                         computeRestarts <- base::computeRestarts
[10:34:16.193]                         grepl <- base::grepl
[10:34:16.193]                         restarts <- computeRestarts(cond)
[10:34:16.193]                         for (restart in restarts) {
[10:34:16.193]                           name <- restart$name
[10:34:16.193]                           if (is.null(name)) 
[10:34:16.193]                             next
[10:34:16.193]                           if (!grepl(pattern, name)) 
[10:34:16.193]                             next
[10:34:16.193]                           invokeRestart(restart)
[10:34:16.193]                           muffled <- TRUE
[10:34:16.193]                           break
[10:34:16.193]                         }
[10:34:16.193]                       }
[10:34:16.193]                     }
[10:34:16.193]                     invisible(muffled)
[10:34:16.193]                   }
[10:34:16.193]                   muffleCondition(cond)
[10:34:16.193]                 })
[10:34:16.193]             }))
[10:34:16.193]             future::FutureResult(value = ...future.value$value, 
[10:34:16.193]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:16.193]                   ...future.rng), globalenv = if (FALSE) 
[10:34:16.193]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:16.193]                     ...future.globalenv.names))
[10:34:16.193]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:16.193]         }, condition = base::local({
[10:34:16.193]             c <- base::c
[10:34:16.193]             inherits <- base::inherits
[10:34:16.193]             invokeRestart <- base::invokeRestart
[10:34:16.193]             length <- base::length
[10:34:16.193]             list <- base::list
[10:34:16.193]             seq.int <- base::seq.int
[10:34:16.193]             signalCondition <- base::signalCondition
[10:34:16.193]             sys.calls <- base::sys.calls
[10:34:16.193]             `[[` <- base::`[[`
[10:34:16.193]             `+` <- base::`+`
[10:34:16.193]             `<<-` <- base::`<<-`
[10:34:16.193]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:16.193]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:16.193]                   3L)]
[10:34:16.193]             }
[10:34:16.193]             function(cond) {
[10:34:16.193]                 is_error <- inherits(cond, "error")
[10:34:16.193]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:16.193]                   NULL)
[10:34:16.193]                 if (is_error) {
[10:34:16.193]                   sessionInformation <- function() {
[10:34:16.193]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:16.193]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:16.193]                       search = base::search(), system = base::Sys.info())
[10:34:16.193]                   }
[10:34:16.193]                   ...future.conditions[[length(...future.conditions) + 
[10:34:16.193]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:16.193]                     cond$call), session = sessionInformation(), 
[10:34:16.193]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:16.193]                   signalCondition(cond)
[10:34:16.193]                 }
[10:34:16.193]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:16.193]                 "immediateCondition"))) {
[10:34:16.193]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:16.193]                   ...future.conditions[[length(...future.conditions) + 
[10:34:16.193]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:16.193]                   if (TRUE && !signal) {
[10:34:16.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.193]                     {
[10:34:16.193]                       inherits <- base::inherits
[10:34:16.193]                       invokeRestart <- base::invokeRestart
[10:34:16.193]                       is.null <- base::is.null
[10:34:16.193]                       muffled <- FALSE
[10:34:16.193]                       if (inherits(cond, "message")) {
[10:34:16.193]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:16.193]                         if (muffled) 
[10:34:16.193]                           invokeRestart("muffleMessage")
[10:34:16.193]                       }
[10:34:16.193]                       else if (inherits(cond, "warning")) {
[10:34:16.193]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:16.193]                         if (muffled) 
[10:34:16.193]                           invokeRestart("muffleWarning")
[10:34:16.193]                       }
[10:34:16.193]                       else if (inherits(cond, "condition")) {
[10:34:16.193]                         if (!is.null(pattern)) {
[10:34:16.193]                           computeRestarts <- base::computeRestarts
[10:34:16.193]                           grepl <- base::grepl
[10:34:16.193]                           restarts <- computeRestarts(cond)
[10:34:16.193]                           for (restart in restarts) {
[10:34:16.193]                             name <- restart$name
[10:34:16.193]                             if (is.null(name)) 
[10:34:16.193]                               next
[10:34:16.193]                             if (!grepl(pattern, name)) 
[10:34:16.193]                               next
[10:34:16.193]                             invokeRestart(restart)
[10:34:16.193]                             muffled <- TRUE
[10:34:16.193]                             break
[10:34:16.193]                           }
[10:34:16.193]                         }
[10:34:16.193]                       }
[10:34:16.193]                       invisible(muffled)
[10:34:16.193]                     }
[10:34:16.193]                     muffleCondition(cond, pattern = "^muffle")
[10:34:16.193]                   }
[10:34:16.193]                 }
[10:34:16.193]                 else {
[10:34:16.193]                   if (TRUE) {
[10:34:16.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.193]                     {
[10:34:16.193]                       inherits <- base::inherits
[10:34:16.193]                       invokeRestart <- base::invokeRestart
[10:34:16.193]                       is.null <- base::is.null
[10:34:16.193]                       muffled <- FALSE
[10:34:16.193]                       if (inherits(cond, "message")) {
[10:34:16.193]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:16.193]                         if (muffled) 
[10:34:16.193]                           invokeRestart("muffleMessage")
[10:34:16.193]                       }
[10:34:16.193]                       else if (inherits(cond, "warning")) {
[10:34:16.193]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:16.193]                         if (muffled) 
[10:34:16.193]                           invokeRestart("muffleWarning")
[10:34:16.193]                       }
[10:34:16.193]                       else if (inherits(cond, "condition")) {
[10:34:16.193]                         if (!is.null(pattern)) {
[10:34:16.193]                           computeRestarts <- base::computeRestarts
[10:34:16.193]                           grepl <- base::grepl
[10:34:16.193]                           restarts <- computeRestarts(cond)
[10:34:16.193]                           for (restart in restarts) {
[10:34:16.193]                             name <- restart$name
[10:34:16.193]                             if (is.null(name)) 
[10:34:16.193]                               next
[10:34:16.193]                             if (!grepl(pattern, name)) 
[10:34:16.193]                               next
[10:34:16.193]                             invokeRestart(restart)
[10:34:16.193]                             muffled <- TRUE
[10:34:16.193]                             break
[10:34:16.193]                           }
[10:34:16.193]                         }
[10:34:16.193]                       }
[10:34:16.193]                       invisible(muffled)
[10:34:16.193]                     }
[10:34:16.193]                     muffleCondition(cond, pattern = "^muffle")
[10:34:16.193]                   }
[10:34:16.193]                 }
[10:34:16.193]             }
[10:34:16.193]         }))
[10:34:16.193]     }, error = function(ex) {
[10:34:16.193]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:16.193]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:16.193]                 ...future.rng), started = ...future.startTime, 
[10:34:16.193]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:16.193]             version = "1.8"), class = "FutureResult")
[10:34:16.193]     }, finally = {
[10:34:16.193]         if (!identical(...future.workdir, getwd())) 
[10:34:16.193]             setwd(...future.workdir)
[10:34:16.193]         {
[10:34:16.193]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:16.193]                 ...future.oldOptions$nwarnings <- NULL
[10:34:16.193]             }
[10:34:16.193]             base::options(...future.oldOptions)
[10:34:16.193]             if (.Platform$OS.type == "windows") {
[10:34:16.193]                 old_names <- names(...future.oldEnvVars)
[10:34:16.193]                 envs <- base::Sys.getenv()
[10:34:16.193]                 names <- names(envs)
[10:34:16.193]                 common <- intersect(names, old_names)
[10:34:16.193]                 added <- setdiff(names, old_names)
[10:34:16.193]                 removed <- setdiff(old_names, names)
[10:34:16.193]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:16.193]                   envs[common]]
[10:34:16.193]                 NAMES <- toupper(changed)
[10:34:16.193]                 args <- list()
[10:34:16.193]                 for (kk in seq_along(NAMES)) {
[10:34:16.193]                   name <- changed[[kk]]
[10:34:16.193]                   NAME <- NAMES[[kk]]
[10:34:16.193]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.193]                     next
[10:34:16.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:16.193]                 }
[10:34:16.193]                 NAMES <- toupper(added)
[10:34:16.193]                 for (kk in seq_along(NAMES)) {
[10:34:16.193]                   name <- added[[kk]]
[10:34:16.193]                   NAME <- NAMES[[kk]]
[10:34:16.193]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.193]                     next
[10:34:16.193]                   args[[name]] <- ""
[10:34:16.193]                 }
[10:34:16.193]                 NAMES <- toupper(removed)
[10:34:16.193]                 for (kk in seq_along(NAMES)) {
[10:34:16.193]                   name <- removed[[kk]]
[10:34:16.193]                   NAME <- NAMES[[kk]]
[10:34:16.193]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.193]                     next
[10:34:16.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:16.193]                 }
[10:34:16.193]                 if (length(args) > 0) 
[10:34:16.193]                   base::do.call(base::Sys.setenv, args = args)
[10:34:16.193]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:16.193]             }
[10:34:16.193]             else {
[10:34:16.193]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:16.193]             }
[10:34:16.193]             {
[10:34:16.193]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:16.193]                   0L) {
[10:34:16.193]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:16.193]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:16.193]                   base::options(opts)
[10:34:16.193]                 }
[10:34:16.193]                 {
[10:34:16.193]                   {
[10:34:16.193]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:16.193]                     NULL
[10:34:16.193]                   }
[10:34:16.193]                   options(future.plan = NULL)
[10:34:16.193]                   if (is.na(NA_character_)) 
[10:34:16.193]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:16.193]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:16.193]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:16.193]                     .init = FALSE)
[10:34:16.193]                 }
[10:34:16.193]             }
[10:34:16.193]         }
[10:34:16.193]     })
[10:34:16.193]     if (TRUE) {
[10:34:16.193]         base::sink(type = "output", split = FALSE)
[10:34:16.193]         if (TRUE) {
[10:34:16.193]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:16.193]         }
[10:34:16.193]         else {
[10:34:16.193]             ...future.result["stdout"] <- base::list(NULL)
[10:34:16.193]         }
[10:34:16.193]         base::close(...future.stdout)
[10:34:16.193]         ...future.stdout <- NULL
[10:34:16.193]     }
[10:34:16.193]     ...future.result$conditions <- ...future.conditions
[10:34:16.193]     ...future.result$finished <- base::Sys.time()
[10:34:16.193]     ...future.result
[10:34:16.193] }
[10:34:16.195] MultisessionFuture started
[10:34:16.196] - Launch lazy future ... done
[10:34:16.196] run() for ‘MultisessionFuture’ ... done
[10:34:16.197] receiveMessageFromWorker() for ClusterFuture ...
[10:34:16.197] - Validating connection of MultisessionFuture
[10:34:16.197] - received message: FutureResult
[10:34:16.197] - Received FutureResult
[10:34:16.197] - Erased future from FutureRegistry
[10:34:16.198] result() for ClusterFuture ...
[10:34:16.198] - result already collected: FutureResult
[10:34:16.198] result() for ClusterFuture ... done
[10:34:16.198] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:16.198] Future #1
[10:34:16.198]  length: 2 (resolved future 1)
[10:34:16.198] receiveMessageFromWorker() for ClusterFuture ...
[10:34:16.199] - Validating connection of MultisessionFuture
[10:34:16.199] - received message: FutureResult
[10:34:16.199] - Received FutureResult
[10:34:16.199] - Erased future from FutureRegistry
[10:34:16.199] result() for ClusterFuture ...
[10:34:16.199] - result already collected: FutureResult
[10:34:16.199] result() for ClusterFuture ... done
[10:34:16.199] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:16.199] Future #2
[10:34:16.199]  length: 1 (resolved future 2)
[10:34:16.200]  length: 0 (resolved future 3)
[10:34:16.200] resolve() on list ... DONE
[10:34:16.200] getGlobalsAndPackages() ...
[10:34:16.200] Searching for globals...
[10:34:16.200] 
[10:34:16.200] Searching for globals ... DONE
[10:34:16.200] - globals: [0] <none>
[10:34:16.200] getGlobalsAndPackages() ... DONE
[10:34:16.201] getGlobalsAndPackages() ...
[10:34:16.201] Searching for globals...
[10:34:16.201] 
[10:34:16.201] Searching for globals ... DONE
[10:34:16.201] - globals: [0] <none>
[10:34:16.201] getGlobalsAndPackages() ... DONE
[10:34:16.202] resolve() on list ...
[10:34:16.202]  recursive: 0
[10:34:16.202]  length: 3
[10:34:16.202]  elements: ‘a’, ‘b’, ‘’
[10:34:16.202] run() for ‘Future’ ...
[10:34:16.202] - state: ‘created’
[10:34:16.202] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:16.215] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:16.216] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:16.216]   - Field: ‘node’
[10:34:16.216]   - Field: ‘label’
[10:34:16.216]   - Field: ‘local’
[10:34:16.216]   - Field: ‘owner’
[10:34:16.216]   - Field: ‘envir’
[10:34:16.216]   - Field: ‘workers’
[10:34:16.216]   - Field: ‘packages’
[10:34:16.216]   - Field: ‘gc’
[10:34:16.216]   - Field: ‘conditions’
[10:34:16.217]   - Field: ‘persistent’
[10:34:16.217]   - Field: ‘expr’
[10:34:16.217]   - Field: ‘uuid’
[10:34:16.217]   - Field: ‘seed’
[10:34:16.217]   - Field: ‘version’
[10:34:16.217]   - Field: ‘result’
[10:34:16.217]   - Field: ‘asynchronous’
[10:34:16.217]   - Field: ‘calls’
[10:34:16.217]   - Field: ‘globals’
[10:34:16.217]   - Field: ‘stdout’
[10:34:16.217]   - Field: ‘earlySignal’
[10:34:16.218]   - Field: ‘lazy’
[10:34:16.218]   - Field: ‘state’
[10:34:16.218] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:16.218] - Launch lazy future ...
[10:34:16.218] Packages needed by the future expression (n = 0): <none>
[10:34:16.218] Packages needed by future strategies (n = 0): <none>
[10:34:16.219] {
[10:34:16.219]     {
[10:34:16.219]         {
[10:34:16.219]             ...future.startTime <- base::Sys.time()
[10:34:16.219]             {
[10:34:16.219]                 {
[10:34:16.219]                   {
[10:34:16.219]                     {
[10:34:16.219]                       base::local({
[10:34:16.219]                         has_future <- base::requireNamespace("future", 
[10:34:16.219]                           quietly = TRUE)
[10:34:16.219]                         if (has_future) {
[10:34:16.219]                           ns <- base::getNamespace("future")
[10:34:16.219]                           version <- ns[[".package"]][["version"]]
[10:34:16.219]                           if (is.null(version)) 
[10:34:16.219]                             version <- utils::packageVersion("future")
[10:34:16.219]                         }
[10:34:16.219]                         else {
[10:34:16.219]                           version <- NULL
[10:34:16.219]                         }
[10:34:16.219]                         if (!has_future || version < "1.8.0") {
[10:34:16.219]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:16.219]                             "", base::R.version$version.string), 
[10:34:16.219]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:16.219]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:16.219]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:16.219]                               "release", "version")], collapse = " "), 
[10:34:16.219]                             hostname = base::Sys.info()[["nodename"]])
[10:34:16.219]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:16.219]                             info)
[10:34:16.219]                           info <- base::paste(info, collapse = "; ")
[10:34:16.219]                           if (!has_future) {
[10:34:16.219]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:16.219]                               info)
[10:34:16.219]                           }
[10:34:16.219]                           else {
[10:34:16.219]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:16.219]                               info, version)
[10:34:16.219]                           }
[10:34:16.219]                           base::stop(msg)
[10:34:16.219]                         }
[10:34:16.219]                       })
[10:34:16.219]                     }
[10:34:16.219]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:16.219]                     base::options(mc.cores = 1L)
[10:34:16.219]                   }
[10:34:16.219]                   ...future.strategy.old <- future::plan("list")
[10:34:16.219]                   options(future.plan = NULL)
[10:34:16.219]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:16.219]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:16.219]                 }
[10:34:16.219]                 ...future.workdir <- getwd()
[10:34:16.219]             }
[10:34:16.219]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:16.219]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:16.219]         }
[10:34:16.219]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:16.219]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:16.219]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:16.219]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:16.219]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:16.219]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:16.219]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:16.219]             base::names(...future.oldOptions))
[10:34:16.219]     }
[10:34:16.219]     if (FALSE) {
[10:34:16.219]     }
[10:34:16.219]     else {
[10:34:16.219]         if (TRUE) {
[10:34:16.219]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:16.219]                 open = "w")
[10:34:16.219]         }
[10:34:16.219]         else {
[10:34:16.219]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:16.219]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:16.219]         }
[10:34:16.219]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:16.219]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:16.219]             base::sink(type = "output", split = FALSE)
[10:34:16.219]             base::close(...future.stdout)
[10:34:16.219]         }, add = TRUE)
[10:34:16.219]     }
[10:34:16.219]     ...future.frame <- base::sys.nframe()
[10:34:16.219]     ...future.conditions <- base::list()
[10:34:16.219]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:16.219]     if (FALSE) {
[10:34:16.219]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:16.219]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:16.219]     }
[10:34:16.219]     ...future.result <- base::tryCatch({
[10:34:16.219]         base::withCallingHandlers({
[10:34:16.219]             ...future.value <- base::withVisible(base::local({
[10:34:16.219]                 ...future.makeSendCondition <- base::local({
[10:34:16.219]                   sendCondition <- NULL
[10:34:16.219]                   function(frame = 1L) {
[10:34:16.219]                     if (is.function(sendCondition)) 
[10:34:16.219]                       return(sendCondition)
[10:34:16.219]                     ns <- getNamespace("parallel")
[10:34:16.219]                     if (exists("sendData", mode = "function", 
[10:34:16.219]                       envir = ns)) {
[10:34:16.219]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:16.219]                         envir = ns)
[10:34:16.219]                       envir <- sys.frame(frame)
[10:34:16.219]                       master <- NULL
[10:34:16.219]                       while (!identical(envir, .GlobalEnv) && 
[10:34:16.219]                         !identical(envir, emptyenv())) {
[10:34:16.219]                         if (exists("master", mode = "list", envir = envir, 
[10:34:16.219]                           inherits = FALSE)) {
[10:34:16.219]                           master <- get("master", mode = "list", 
[10:34:16.219]                             envir = envir, inherits = FALSE)
[10:34:16.219]                           if (inherits(master, c("SOCKnode", 
[10:34:16.219]                             "SOCK0node"))) {
[10:34:16.219]                             sendCondition <<- function(cond) {
[10:34:16.219]                               data <- list(type = "VALUE", value = cond, 
[10:34:16.219]                                 success = TRUE)
[10:34:16.219]                               parallel_sendData(master, data)
[10:34:16.219]                             }
[10:34:16.219]                             return(sendCondition)
[10:34:16.219]                           }
[10:34:16.219]                         }
[10:34:16.219]                         frame <- frame + 1L
[10:34:16.219]                         envir <- sys.frame(frame)
[10:34:16.219]                       }
[10:34:16.219]                     }
[10:34:16.219]                     sendCondition <<- function(cond) NULL
[10:34:16.219]                   }
[10:34:16.219]                 })
[10:34:16.219]                 withCallingHandlers({
[10:34:16.219]                   1
[10:34:16.219]                 }, immediateCondition = function(cond) {
[10:34:16.219]                   sendCondition <- ...future.makeSendCondition()
[10:34:16.219]                   sendCondition(cond)
[10:34:16.219]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.219]                   {
[10:34:16.219]                     inherits <- base::inherits
[10:34:16.219]                     invokeRestart <- base::invokeRestart
[10:34:16.219]                     is.null <- base::is.null
[10:34:16.219]                     muffled <- FALSE
[10:34:16.219]                     if (inherits(cond, "message")) {
[10:34:16.219]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:16.219]                       if (muffled) 
[10:34:16.219]                         invokeRestart("muffleMessage")
[10:34:16.219]                     }
[10:34:16.219]                     else if (inherits(cond, "warning")) {
[10:34:16.219]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:16.219]                       if (muffled) 
[10:34:16.219]                         invokeRestart("muffleWarning")
[10:34:16.219]                     }
[10:34:16.219]                     else if (inherits(cond, "condition")) {
[10:34:16.219]                       if (!is.null(pattern)) {
[10:34:16.219]                         computeRestarts <- base::computeRestarts
[10:34:16.219]                         grepl <- base::grepl
[10:34:16.219]                         restarts <- computeRestarts(cond)
[10:34:16.219]                         for (restart in restarts) {
[10:34:16.219]                           name <- restart$name
[10:34:16.219]                           if (is.null(name)) 
[10:34:16.219]                             next
[10:34:16.219]                           if (!grepl(pattern, name)) 
[10:34:16.219]                             next
[10:34:16.219]                           invokeRestart(restart)
[10:34:16.219]                           muffled <- TRUE
[10:34:16.219]                           break
[10:34:16.219]                         }
[10:34:16.219]                       }
[10:34:16.219]                     }
[10:34:16.219]                     invisible(muffled)
[10:34:16.219]                   }
[10:34:16.219]                   muffleCondition(cond)
[10:34:16.219]                 })
[10:34:16.219]             }))
[10:34:16.219]             future::FutureResult(value = ...future.value$value, 
[10:34:16.219]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:16.219]                   ...future.rng), globalenv = if (FALSE) 
[10:34:16.219]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:16.219]                     ...future.globalenv.names))
[10:34:16.219]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:16.219]         }, condition = base::local({
[10:34:16.219]             c <- base::c
[10:34:16.219]             inherits <- base::inherits
[10:34:16.219]             invokeRestart <- base::invokeRestart
[10:34:16.219]             length <- base::length
[10:34:16.219]             list <- base::list
[10:34:16.219]             seq.int <- base::seq.int
[10:34:16.219]             signalCondition <- base::signalCondition
[10:34:16.219]             sys.calls <- base::sys.calls
[10:34:16.219]             `[[` <- base::`[[`
[10:34:16.219]             `+` <- base::`+`
[10:34:16.219]             `<<-` <- base::`<<-`
[10:34:16.219]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:16.219]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:16.219]                   3L)]
[10:34:16.219]             }
[10:34:16.219]             function(cond) {
[10:34:16.219]                 is_error <- inherits(cond, "error")
[10:34:16.219]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:16.219]                   NULL)
[10:34:16.219]                 if (is_error) {
[10:34:16.219]                   sessionInformation <- function() {
[10:34:16.219]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:16.219]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:16.219]                       search = base::search(), system = base::Sys.info())
[10:34:16.219]                   }
[10:34:16.219]                   ...future.conditions[[length(...future.conditions) + 
[10:34:16.219]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:16.219]                     cond$call), session = sessionInformation(), 
[10:34:16.219]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:16.219]                   signalCondition(cond)
[10:34:16.219]                 }
[10:34:16.219]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:16.219]                 "immediateCondition"))) {
[10:34:16.219]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:16.219]                   ...future.conditions[[length(...future.conditions) + 
[10:34:16.219]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:16.219]                   if (TRUE && !signal) {
[10:34:16.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.219]                     {
[10:34:16.219]                       inherits <- base::inherits
[10:34:16.219]                       invokeRestart <- base::invokeRestart
[10:34:16.219]                       is.null <- base::is.null
[10:34:16.219]                       muffled <- FALSE
[10:34:16.219]                       if (inherits(cond, "message")) {
[10:34:16.219]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:16.219]                         if (muffled) 
[10:34:16.219]                           invokeRestart("muffleMessage")
[10:34:16.219]                       }
[10:34:16.219]                       else if (inherits(cond, "warning")) {
[10:34:16.219]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:16.219]                         if (muffled) 
[10:34:16.219]                           invokeRestart("muffleWarning")
[10:34:16.219]                       }
[10:34:16.219]                       else if (inherits(cond, "condition")) {
[10:34:16.219]                         if (!is.null(pattern)) {
[10:34:16.219]                           computeRestarts <- base::computeRestarts
[10:34:16.219]                           grepl <- base::grepl
[10:34:16.219]                           restarts <- computeRestarts(cond)
[10:34:16.219]                           for (restart in restarts) {
[10:34:16.219]                             name <- restart$name
[10:34:16.219]                             if (is.null(name)) 
[10:34:16.219]                               next
[10:34:16.219]                             if (!grepl(pattern, name)) 
[10:34:16.219]                               next
[10:34:16.219]                             invokeRestart(restart)
[10:34:16.219]                             muffled <- TRUE
[10:34:16.219]                             break
[10:34:16.219]                           }
[10:34:16.219]                         }
[10:34:16.219]                       }
[10:34:16.219]                       invisible(muffled)
[10:34:16.219]                     }
[10:34:16.219]                     muffleCondition(cond, pattern = "^muffle")
[10:34:16.219]                   }
[10:34:16.219]                 }
[10:34:16.219]                 else {
[10:34:16.219]                   if (TRUE) {
[10:34:16.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.219]                     {
[10:34:16.219]                       inherits <- base::inherits
[10:34:16.219]                       invokeRestart <- base::invokeRestart
[10:34:16.219]                       is.null <- base::is.null
[10:34:16.219]                       muffled <- FALSE
[10:34:16.219]                       if (inherits(cond, "message")) {
[10:34:16.219]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:16.219]                         if (muffled) 
[10:34:16.219]                           invokeRestart("muffleMessage")
[10:34:16.219]                       }
[10:34:16.219]                       else if (inherits(cond, "warning")) {
[10:34:16.219]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:16.219]                         if (muffled) 
[10:34:16.219]                           invokeRestart("muffleWarning")
[10:34:16.219]                       }
[10:34:16.219]                       else if (inherits(cond, "condition")) {
[10:34:16.219]                         if (!is.null(pattern)) {
[10:34:16.219]                           computeRestarts <- base::computeRestarts
[10:34:16.219]                           grepl <- base::grepl
[10:34:16.219]                           restarts <- computeRestarts(cond)
[10:34:16.219]                           for (restart in restarts) {
[10:34:16.219]                             name <- restart$name
[10:34:16.219]                             if (is.null(name)) 
[10:34:16.219]                               next
[10:34:16.219]                             if (!grepl(pattern, name)) 
[10:34:16.219]                               next
[10:34:16.219]                             invokeRestart(restart)
[10:34:16.219]                             muffled <- TRUE
[10:34:16.219]                             break
[10:34:16.219]                           }
[10:34:16.219]                         }
[10:34:16.219]                       }
[10:34:16.219]                       invisible(muffled)
[10:34:16.219]                     }
[10:34:16.219]                     muffleCondition(cond, pattern = "^muffle")
[10:34:16.219]                   }
[10:34:16.219]                 }
[10:34:16.219]             }
[10:34:16.219]         }))
[10:34:16.219]     }, error = function(ex) {
[10:34:16.219]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:16.219]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:16.219]                 ...future.rng), started = ...future.startTime, 
[10:34:16.219]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:16.219]             version = "1.8"), class = "FutureResult")
[10:34:16.219]     }, finally = {
[10:34:16.219]         if (!identical(...future.workdir, getwd())) 
[10:34:16.219]             setwd(...future.workdir)
[10:34:16.219]         {
[10:34:16.219]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:16.219]                 ...future.oldOptions$nwarnings <- NULL
[10:34:16.219]             }
[10:34:16.219]             base::options(...future.oldOptions)
[10:34:16.219]             if (.Platform$OS.type == "windows") {
[10:34:16.219]                 old_names <- names(...future.oldEnvVars)
[10:34:16.219]                 envs <- base::Sys.getenv()
[10:34:16.219]                 names <- names(envs)
[10:34:16.219]                 common <- intersect(names, old_names)
[10:34:16.219]                 added <- setdiff(names, old_names)
[10:34:16.219]                 removed <- setdiff(old_names, names)
[10:34:16.219]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:16.219]                   envs[common]]
[10:34:16.219]                 NAMES <- toupper(changed)
[10:34:16.219]                 args <- list()
[10:34:16.219]                 for (kk in seq_along(NAMES)) {
[10:34:16.219]                   name <- changed[[kk]]
[10:34:16.219]                   NAME <- NAMES[[kk]]
[10:34:16.219]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.219]                     next
[10:34:16.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:16.219]                 }
[10:34:16.219]                 NAMES <- toupper(added)
[10:34:16.219]                 for (kk in seq_along(NAMES)) {
[10:34:16.219]                   name <- added[[kk]]
[10:34:16.219]                   NAME <- NAMES[[kk]]
[10:34:16.219]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.219]                     next
[10:34:16.219]                   args[[name]] <- ""
[10:34:16.219]                 }
[10:34:16.219]                 NAMES <- toupper(removed)
[10:34:16.219]                 for (kk in seq_along(NAMES)) {
[10:34:16.219]                   name <- removed[[kk]]
[10:34:16.219]                   NAME <- NAMES[[kk]]
[10:34:16.219]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.219]                     next
[10:34:16.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:16.219]                 }
[10:34:16.219]                 if (length(args) > 0) 
[10:34:16.219]                   base::do.call(base::Sys.setenv, args = args)
[10:34:16.219]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:16.219]             }
[10:34:16.219]             else {
[10:34:16.219]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:16.219]             }
[10:34:16.219]             {
[10:34:16.219]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:16.219]                   0L) {
[10:34:16.219]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:16.219]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:16.219]                   base::options(opts)
[10:34:16.219]                 }
[10:34:16.219]                 {
[10:34:16.219]                   {
[10:34:16.219]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:16.219]                     NULL
[10:34:16.219]                   }
[10:34:16.219]                   options(future.plan = NULL)
[10:34:16.219]                   if (is.na(NA_character_)) 
[10:34:16.219]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:16.219]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:16.219]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:16.219]                     .init = FALSE)
[10:34:16.219]                 }
[10:34:16.219]             }
[10:34:16.219]         }
[10:34:16.219]     })
[10:34:16.219]     if (TRUE) {
[10:34:16.219]         base::sink(type = "output", split = FALSE)
[10:34:16.219]         if (TRUE) {
[10:34:16.219]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:16.219]         }
[10:34:16.219]         else {
[10:34:16.219]             ...future.result["stdout"] <- base::list(NULL)
[10:34:16.219]         }
[10:34:16.219]         base::close(...future.stdout)
[10:34:16.219]         ...future.stdout <- NULL
[10:34:16.219]     }
[10:34:16.219]     ...future.result$conditions <- ...future.conditions
[10:34:16.219]     ...future.result$finished <- base::Sys.time()
[10:34:16.219]     ...future.result
[10:34:16.219] }
[10:34:16.221] MultisessionFuture started
[10:34:16.221] - Launch lazy future ... done
[10:34:16.222] run() for ‘MultisessionFuture’ ... done
[10:34:16.223] receiveMessageFromWorker() for ClusterFuture ...
[10:34:16.223] - Validating connection of MultisessionFuture
[10:34:16.223] - received message: FutureResult
[10:34:16.223] - Received FutureResult
[10:34:16.223] - Erased future from FutureRegistry
[10:34:16.223] result() for ClusterFuture ...
[10:34:16.223] - result already collected: FutureResult
[10:34:16.224] result() for ClusterFuture ... done
[10:34:16.224] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:16.224] Future #1
[10:34:16.224]  length: 2 (resolved future 1)
[10:34:16.224] run() for ‘Future’ ...
[10:34:16.224] - state: ‘created’
[10:34:16.224] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:16.238] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:16.238] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:16.238]   - Field: ‘node’
[10:34:16.238]   - Field: ‘label’
[10:34:16.238]   - Field: ‘local’
[10:34:16.238]   - Field: ‘owner’
[10:34:16.239]   - Field: ‘envir’
[10:34:16.239]   - Field: ‘workers’
[10:34:16.239]   - Field: ‘packages’
[10:34:16.239]   - Field: ‘gc’
[10:34:16.239]   - Field: ‘conditions’
[10:34:16.239]   - Field: ‘persistent’
[10:34:16.239]   - Field: ‘expr’
[10:34:16.239]   - Field: ‘uuid’
[10:34:16.239]   - Field: ‘seed’
[10:34:16.239]   - Field: ‘version’
[10:34:16.239]   - Field: ‘result’
[10:34:16.240]   - Field: ‘asynchronous’
[10:34:16.240]   - Field: ‘calls’
[10:34:16.240]   - Field: ‘globals’
[10:34:16.240]   - Field: ‘stdout’
[10:34:16.240]   - Field: ‘earlySignal’
[10:34:16.240]   - Field: ‘lazy’
[10:34:16.240]   - Field: ‘state’
[10:34:16.240] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:16.240] - Launch lazy future ...
[10:34:16.240] Packages needed by the future expression (n = 0): <none>
[10:34:16.241] Packages needed by future strategies (n = 0): <none>
[10:34:16.241] {
[10:34:16.241]     {
[10:34:16.241]         {
[10:34:16.241]             ...future.startTime <- base::Sys.time()
[10:34:16.241]             {
[10:34:16.241]                 {
[10:34:16.241]                   {
[10:34:16.241]                     {
[10:34:16.241]                       base::local({
[10:34:16.241]                         has_future <- base::requireNamespace("future", 
[10:34:16.241]                           quietly = TRUE)
[10:34:16.241]                         if (has_future) {
[10:34:16.241]                           ns <- base::getNamespace("future")
[10:34:16.241]                           version <- ns[[".package"]][["version"]]
[10:34:16.241]                           if (is.null(version)) 
[10:34:16.241]                             version <- utils::packageVersion("future")
[10:34:16.241]                         }
[10:34:16.241]                         else {
[10:34:16.241]                           version <- NULL
[10:34:16.241]                         }
[10:34:16.241]                         if (!has_future || version < "1.8.0") {
[10:34:16.241]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:16.241]                             "", base::R.version$version.string), 
[10:34:16.241]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:16.241]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:16.241]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:16.241]                               "release", "version")], collapse = " "), 
[10:34:16.241]                             hostname = base::Sys.info()[["nodename"]])
[10:34:16.241]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:16.241]                             info)
[10:34:16.241]                           info <- base::paste(info, collapse = "; ")
[10:34:16.241]                           if (!has_future) {
[10:34:16.241]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:16.241]                               info)
[10:34:16.241]                           }
[10:34:16.241]                           else {
[10:34:16.241]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:16.241]                               info, version)
[10:34:16.241]                           }
[10:34:16.241]                           base::stop(msg)
[10:34:16.241]                         }
[10:34:16.241]                       })
[10:34:16.241]                     }
[10:34:16.241]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:16.241]                     base::options(mc.cores = 1L)
[10:34:16.241]                   }
[10:34:16.241]                   ...future.strategy.old <- future::plan("list")
[10:34:16.241]                   options(future.plan = NULL)
[10:34:16.241]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:16.241]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:16.241]                 }
[10:34:16.241]                 ...future.workdir <- getwd()
[10:34:16.241]             }
[10:34:16.241]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:16.241]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:16.241]         }
[10:34:16.241]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:16.241]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:16.241]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:16.241]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:16.241]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:16.241]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:16.241]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:16.241]             base::names(...future.oldOptions))
[10:34:16.241]     }
[10:34:16.241]     if (FALSE) {
[10:34:16.241]     }
[10:34:16.241]     else {
[10:34:16.241]         if (TRUE) {
[10:34:16.241]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:16.241]                 open = "w")
[10:34:16.241]         }
[10:34:16.241]         else {
[10:34:16.241]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:16.241]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:16.241]         }
[10:34:16.241]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:16.241]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:16.241]             base::sink(type = "output", split = FALSE)
[10:34:16.241]             base::close(...future.stdout)
[10:34:16.241]         }, add = TRUE)
[10:34:16.241]     }
[10:34:16.241]     ...future.frame <- base::sys.nframe()
[10:34:16.241]     ...future.conditions <- base::list()
[10:34:16.241]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:16.241]     if (FALSE) {
[10:34:16.241]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:16.241]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:16.241]     }
[10:34:16.241]     ...future.result <- base::tryCatch({
[10:34:16.241]         base::withCallingHandlers({
[10:34:16.241]             ...future.value <- base::withVisible(base::local({
[10:34:16.241]                 ...future.makeSendCondition <- base::local({
[10:34:16.241]                   sendCondition <- NULL
[10:34:16.241]                   function(frame = 1L) {
[10:34:16.241]                     if (is.function(sendCondition)) 
[10:34:16.241]                       return(sendCondition)
[10:34:16.241]                     ns <- getNamespace("parallel")
[10:34:16.241]                     if (exists("sendData", mode = "function", 
[10:34:16.241]                       envir = ns)) {
[10:34:16.241]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:16.241]                         envir = ns)
[10:34:16.241]                       envir <- sys.frame(frame)
[10:34:16.241]                       master <- NULL
[10:34:16.241]                       while (!identical(envir, .GlobalEnv) && 
[10:34:16.241]                         !identical(envir, emptyenv())) {
[10:34:16.241]                         if (exists("master", mode = "list", envir = envir, 
[10:34:16.241]                           inherits = FALSE)) {
[10:34:16.241]                           master <- get("master", mode = "list", 
[10:34:16.241]                             envir = envir, inherits = FALSE)
[10:34:16.241]                           if (inherits(master, c("SOCKnode", 
[10:34:16.241]                             "SOCK0node"))) {
[10:34:16.241]                             sendCondition <<- function(cond) {
[10:34:16.241]                               data <- list(type = "VALUE", value = cond, 
[10:34:16.241]                                 success = TRUE)
[10:34:16.241]                               parallel_sendData(master, data)
[10:34:16.241]                             }
[10:34:16.241]                             return(sendCondition)
[10:34:16.241]                           }
[10:34:16.241]                         }
[10:34:16.241]                         frame <- frame + 1L
[10:34:16.241]                         envir <- sys.frame(frame)
[10:34:16.241]                       }
[10:34:16.241]                     }
[10:34:16.241]                     sendCondition <<- function(cond) NULL
[10:34:16.241]                   }
[10:34:16.241]                 })
[10:34:16.241]                 withCallingHandlers({
[10:34:16.241]                   2
[10:34:16.241]                 }, immediateCondition = function(cond) {
[10:34:16.241]                   sendCondition <- ...future.makeSendCondition()
[10:34:16.241]                   sendCondition(cond)
[10:34:16.241]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.241]                   {
[10:34:16.241]                     inherits <- base::inherits
[10:34:16.241]                     invokeRestart <- base::invokeRestart
[10:34:16.241]                     is.null <- base::is.null
[10:34:16.241]                     muffled <- FALSE
[10:34:16.241]                     if (inherits(cond, "message")) {
[10:34:16.241]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:16.241]                       if (muffled) 
[10:34:16.241]                         invokeRestart("muffleMessage")
[10:34:16.241]                     }
[10:34:16.241]                     else if (inherits(cond, "warning")) {
[10:34:16.241]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:16.241]                       if (muffled) 
[10:34:16.241]                         invokeRestart("muffleWarning")
[10:34:16.241]                     }
[10:34:16.241]                     else if (inherits(cond, "condition")) {
[10:34:16.241]                       if (!is.null(pattern)) {
[10:34:16.241]                         computeRestarts <- base::computeRestarts
[10:34:16.241]                         grepl <- base::grepl
[10:34:16.241]                         restarts <- computeRestarts(cond)
[10:34:16.241]                         for (restart in restarts) {
[10:34:16.241]                           name <- restart$name
[10:34:16.241]                           if (is.null(name)) 
[10:34:16.241]                             next
[10:34:16.241]                           if (!grepl(pattern, name)) 
[10:34:16.241]                             next
[10:34:16.241]                           invokeRestart(restart)
[10:34:16.241]                           muffled <- TRUE
[10:34:16.241]                           break
[10:34:16.241]                         }
[10:34:16.241]                       }
[10:34:16.241]                     }
[10:34:16.241]                     invisible(muffled)
[10:34:16.241]                   }
[10:34:16.241]                   muffleCondition(cond)
[10:34:16.241]                 })
[10:34:16.241]             }))
[10:34:16.241]             future::FutureResult(value = ...future.value$value, 
[10:34:16.241]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:16.241]                   ...future.rng), globalenv = if (FALSE) 
[10:34:16.241]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:16.241]                     ...future.globalenv.names))
[10:34:16.241]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:16.241]         }, condition = base::local({
[10:34:16.241]             c <- base::c
[10:34:16.241]             inherits <- base::inherits
[10:34:16.241]             invokeRestart <- base::invokeRestart
[10:34:16.241]             length <- base::length
[10:34:16.241]             list <- base::list
[10:34:16.241]             seq.int <- base::seq.int
[10:34:16.241]             signalCondition <- base::signalCondition
[10:34:16.241]             sys.calls <- base::sys.calls
[10:34:16.241]             `[[` <- base::`[[`
[10:34:16.241]             `+` <- base::`+`
[10:34:16.241]             `<<-` <- base::`<<-`
[10:34:16.241]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:16.241]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:16.241]                   3L)]
[10:34:16.241]             }
[10:34:16.241]             function(cond) {
[10:34:16.241]                 is_error <- inherits(cond, "error")
[10:34:16.241]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:16.241]                   NULL)
[10:34:16.241]                 if (is_error) {
[10:34:16.241]                   sessionInformation <- function() {
[10:34:16.241]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:16.241]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:16.241]                       search = base::search(), system = base::Sys.info())
[10:34:16.241]                   }
[10:34:16.241]                   ...future.conditions[[length(...future.conditions) + 
[10:34:16.241]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:16.241]                     cond$call), session = sessionInformation(), 
[10:34:16.241]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:16.241]                   signalCondition(cond)
[10:34:16.241]                 }
[10:34:16.241]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:16.241]                 "immediateCondition"))) {
[10:34:16.241]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:16.241]                   ...future.conditions[[length(...future.conditions) + 
[10:34:16.241]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:16.241]                   if (TRUE && !signal) {
[10:34:16.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.241]                     {
[10:34:16.241]                       inherits <- base::inherits
[10:34:16.241]                       invokeRestart <- base::invokeRestart
[10:34:16.241]                       is.null <- base::is.null
[10:34:16.241]                       muffled <- FALSE
[10:34:16.241]                       if (inherits(cond, "message")) {
[10:34:16.241]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:16.241]                         if (muffled) 
[10:34:16.241]                           invokeRestart("muffleMessage")
[10:34:16.241]                       }
[10:34:16.241]                       else if (inherits(cond, "warning")) {
[10:34:16.241]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:16.241]                         if (muffled) 
[10:34:16.241]                           invokeRestart("muffleWarning")
[10:34:16.241]                       }
[10:34:16.241]                       else if (inherits(cond, "condition")) {
[10:34:16.241]                         if (!is.null(pattern)) {
[10:34:16.241]                           computeRestarts <- base::computeRestarts
[10:34:16.241]                           grepl <- base::grepl
[10:34:16.241]                           restarts <- computeRestarts(cond)
[10:34:16.241]                           for (restart in restarts) {
[10:34:16.241]                             name <- restart$name
[10:34:16.241]                             if (is.null(name)) 
[10:34:16.241]                               next
[10:34:16.241]                             if (!grepl(pattern, name)) 
[10:34:16.241]                               next
[10:34:16.241]                             invokeRestart(restart)
[10:34:16.241]                             muffled <- TRUE
[10:34:16.241]                             break
[10:34:16.241]                           }
[10:34:16.241]                         }
[10:34:16.241]                       }
[10:34:16.241]                       invisible(muffled)
[10:34:16.241]                     }
[10:34:16.241]                     muffleCondition(cond, pattern = "^muffle")
[10:34:16.241]                   }
[10:34:16.241]                 }
[10:34:16.241]                 else {
[10:34:16.241]                   if (TRUE) {
[10:34:16.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.241]                     {
[10:34:16.241]                       inherits <- base::inherits
[10:34:16.241]                       invokeRestart <- base::invokeRestart
[10:34:16.241]                       is.null <- base::is.null
[10:34:16.241]                       muffled <- FALSE
[10:34:16.241]                       if (inherits(cond, "message")) {
[10:34:16.241]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:16.241]                         if (muffled) 
[10:34:16.241]                           invokeRestart("muffleMessage")
[10:34:16.241]                       }
[10:34:16.241]                       else if (inherits(cond, "warning")) {
[10:34:16.241]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:16.241]                         if (muffled) 
[10:34:16.241]                           invokeRestart("muffleWarning")
[10:34:16.241]                       }
[10:34:16.241]                       else if (inherits(cond, "condition")) {
[10:34:16.241]                         if (!is.null(pattern)) {
[10:34:16.241]                           computeRestarts <- base::computeRestarts
[10:34:16.241]                           grepl <- base::grepl
[10:34:16.241]                           restarts <- computeRestarts(cond)
[10:34:16.241]                           for (restart in restarts) {
[10:34:16.241]                             name <- restart$name
[10:34:16.241]                             if (is.null(name)) 
[10:34:16.241]                               next
[10:34:16.241]                             if (!grepl(pattern, name)) 
[10:34:16.241]                               next
[10:34:16.241]                             invokeRestart(restart)
[10:34:16.241]                             muffled <- TRUE
[10:34:16.241]                             break
[10:34:16.241]                           }
[10:34:16.241]                         }
[10:34:16.241]                       }
[10:34:16.241]                       invisible(muffled)
[10:34:16.241]                     }
[10:34:16.241]                     muffleCondition(cond, pattern = "^muffle")
[10:34:16.241]                   }
[10:34:16.241]                 }
[10:34:16.241]             }
[10:34:16.241]         }))
[10:34:16.241]     }, error = function(ex) {
[10:34:16.241]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:16.241]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:16.241]                 ...future.rng), started = ...future.startTime, 
[10:34:16.241]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:16.241]             version = "1.8"), class = "FutureResult")
[10:34:16.241]     }, finally = {
[10:34:16.241]         if (!identical(...future.workdir, getwd())) 
[10:34:16.241]             setwd(...future.workdir)
[10:34:16.241]         {
[10:34:16.241]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:16.241]                 ...future.oldOptions$nwarnings <- NULL
[10:34:16.241]             }
[10:34:16.241]             base::options(...future.oldOptions)
[10:34:16.241]             if (.Platform$OS.type == "windows") {
[10:34:16.241]                 old_names <- names(...future.oldEnvVars)
[10:34:16.241]                 envs <- base::Sys.getenv()
[10:34:16.241]                 names <- names(envs)
[10:34:16.241]                 common <- intersect(names, old_names)
[10:34:16.241]                 added <- setdiff(names, old_names)
[10:34:16.241]                 removed <- setdiff(old_names, names)
[10:34:16.241]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:16.241]                   envs[common]]
[10:34:16.241]                 NAMES <- toupper(changed)
[10:34:16.241]                 args <- list()
[10:34:16.241]                 for (kk in seq_along(NAMES)) {
[10:34:16.241]                   name <- changed[[kk]]
[10:34:16.241]                   NAME <- NAMES[[kk]]
[10:34:16.241]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.241]                     next
[10:34:16.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:16.241]                 }
[10:34:16.241]                 NAMES <- toupper(added)
[10:34:16.241]                 for (kk in seq_along(NAMES)) {
[10:34:16.241]                   name <- added[[kk]]
[10:34:16.241]                   NAME <- NAMES[[kk]]
[10:34:16.241]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.241]                     next
[10:34:16.241]                   args[[name]] <- ""
[10:34:16.241]                 }
[10:34:16.241]                 NAMES <- toupper(removed)
[10:34:16.241]                 for (kk in seq_along(NAMES)) {
[10:34:16.241]                   name <- removed[[kk]]
[10:34:16.241]                   NAME <- NAMES[[kk]]
[10:34:16.241]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.241]                     next
[10:34:16.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:16.241]                 }
[10:34:16.241]                 if (length(args) > 0) 
[10:34:16.241]                   base::do.call(base::Sys.setenv, args = args)
[10:34:16.241]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:16.241]             }
[10:34:16.241]             else {
[10:34:16.241]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:16.241]             }
[10:34:16.241]             {
[10:34:16.241]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:16.241]                   0L) {
[10:34:16.241]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:16.241]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:16.241]                   base::options(opts)
[10:34:16.241]                 }
[10:34:16.241]                 {
[10:34:16.241]                   {
[10:34:16.241]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:16.241]                     NULL
[10:34:16.241]                   }
[10:34:16.241]                   options(future.plan = NULL)
[10:34:16.241]                   if (is.na(NA_character_)) 
[10:34:16.241]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:16.241]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:16.241]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:16.241]                     .init = FALSE)
[10:34:16.241]                 }
[10:34:16.241]             }
[10:34:16.241]         }
[10:34:16.241]     })
[10:34:16.241]     if (TRUE) {
[10:34:16.241]         base::sink(type = "output", split = FALSE)
[10:34:16.241]         if (TRUE) {
[10:34:16.241]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:16.241]         }
[10:34:16.241]         else {
[10:34:16.241]             ...future.result["stdout"] <- base::list(NULL)
[10:34:16.241]         }
[10:34:16.241]         base::close(...future.stdout)
[10:34:16.241]         ...future.stdout <- NULL
[10:34:16.241]     }
[10:34:16.241]     ...future.result$conditions <- ...future.conditions
[10:34:16.241]     ...future.result$finished <- base::Sys.time()
[10:34:16.241]     ...future.result
[10:34:16.241] }
[10:34:16.244] MultisessionFuture started
[10:34:16.244] - Launch lazy future ... done
[10:34:16.244] run() for ‘MultisessionFuture’ ... done
[10:34:16.245] receiveMessageFromWorker() for ClusterFuture ...
[10:34:16.245] - Validating connection of MultisessionFuture
[10:34:16.246] - received message: FutureResult
[10:34:16.246] - Received FutureResult
[10:34:16.246] - Erased future from FutureRegistry
[10:34:16.246] result() for ClusterFuture ...
[10:34:16.246] - result already collected: FutureResult
[10:34:16.246] result() for ClusterFuture ... done
[10:34:16.246] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:16.246] Future #2
[10:34:16.246]  length: 1 (resolved future 2)
[10:34:16.247]  length: 0 (resolved future 3)
[10:34:16.247] resolve() on list ... DONE
[10:34:16.247] getGlobalsAndPackages() ...
[10:34:16.247] Searching for globals...
[10:34:16.247] 
[10:34:16.247] Searching for globals ... DONE
[10:34:16.247] - globals: [0] <none>
[10:34:16.247] getGlobalsAndPackages() ... DONE
[10:34:16.248] run() for ‘Future’ ...
[10:34:16.248] - state: ‘created’
[10:34:16.248] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:16.261] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:16.262] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:16.262]   - Field: ‘node’
[10:34:16.262]   - Field: ‘label’
[10:34:16.262]   - Field: ‘local’
[10:34:16.262]   - Field: ‘owner’
[10:34:16.262]   - Field: ‘envir’
[10:34:16.262]   - Field: ‘workers’
[10:34:16.262]   - Field: ‘packages’
[10:34:16.262]   - Field: ‘gc’
[10:34:16.262]   - Field: ‘conditions’
[10:34:16.263]   - Field: ‘persistent’
[10:34:16.263]   - Field: ‘expr’
[10:34:16.263]   - Field: ‘uuid’
[10:34:16.263]   - Field: ‘seed’
[10:34:16.263]   - Field: ‘version’
[10:34:16.263]   - Field: ‘result’
[10:34:16.263]   - Field: ‘asynchronous’
[10:34:16.263]   - Field: ‘calls’
[10:34:16.263]   - Field: ‘globals’
[10:34:16.263]   - Field: ‘stdout’
[10:34:16.263]   - Field: ‘earlySignal’
[10:34:16.264]   - Field: ‘lazy’
[10:34:16.264]   - Field: ‘state’
[10:34:16.264] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:16.264] - Launch lazy future ...
[10:34:16.264] Packages needed by the future expression (n = 0): <none>
[10:34:16.264] Packages needed by future strategies (n = 0): <none>
[10:34:16.267] {
[10:34:16.267]     {
[10:34:16.267]         {
[10:34:16.267]             ...future.startTime <- base::Sys.time()
[10:34:16.267]             {
[10:34:16.267]                 {
[10:34:16.267]                   {
[10:34:16.267]                     {
[10:34:16.267]                       base::local({
[10:34:16.267]                         has_future <- base::requireNamespace("future", 
[10:34:16.267]                           quietly = TRUE)
[10:34:16.267]                         if (has_future) {
[10:34:16.267]                           ns <- base::getNamespace("future")
[10:34:16.267]                           version <- ns[[".package"]][["version"]]
[10:34:16.267]                           if (is.null(version)) 
[10:34:16.267]                             version <- utils::packageVersion("future")
[10:34:16.267]                         }
[10:34:16.267]                         else {
[10:34:16.267]                           version <- NULL
[10:34:16.267]                         }
[10:34:16.267]                         if (!has_future || version < "1.8.0") {
[10:34:16.267]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:16.267]                             "", base::R.version$version.string), 
[10:34:16.267]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:16.267]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:16.267]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:16.267]                               "release", "version")], collapse = " "), 
[10:34:16.267]                             hostname = base::Sys.info()[["nodename"]])
[10:34:16.267]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:16.267]                             info)
[10:34:16.267]                           info <- base::paste(info, collapse = "; ")
[10:34:16.267]                           if (!has_future) {
[10:34:16.267]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:16.267]                               info)
[10:34:16.267]                           }
[10:34:16.267]                           else {
[10:34:16.267]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:16.267]                               info, version)
[10:34:16.267]                           }
[10:34:16.267]                           base::stop(msg)
[10:34:16.267]                         }
[10:34:16.267]                       })
[10:34:16.267]                     }
[10:34:16.267]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:16.267]                     base::options(mc.cores = 1L)
[10:34:16.267]                   }
[10:34:16.267]                   ...future.strategy.old <- future::plan("list")
[10:34:16.267]                   options(future.plan = NULL)
[10:34:16.267]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:16.267]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:16.267]                 }
[10:34:16.267]                 ...future.workdir <- getwd()
[10:34:16.267]             }
[10:34:16.267]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:16.267]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:16.267]         }
[10:34:16.267]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:16.267]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:16.267]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:16.267]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:16.267]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:16.267]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:16.267]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:16.267]             base::names(...future.oldOptions))
[10:34:16.267]     }
[10:34:16.267]     if (FALSE) {
[10:34:16.267]     }
[10:34:16.267]     else {
[10:34:16.267]         if (TRUE) {
[10:34:16.267]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:16.267]                 open = "w")
[10:34:16.267]         }
[10:34:16.267]         else {
[10:34:16.267]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:16.267]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:16.267]         }
[10:34:16.267]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:16.267]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:16.267]             base::sink(type = "output", split = FALSE)
[10:34:16.267]             base::close(...future.stdout)
[10:34:16.267]         }, add = TRUE)
[10:34:16.267]     }
[10:34:16.267]     ...future.frame <- base::sys.nframe()
[10:34:16.267]     ...future.conditions <- base::list()
[10:34:16.267]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:16.267]     if (FALSE) {
[10:34:16.267]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:16.267]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:16.267]     }
[10:34:16.267]     ...future.result <- base::tryCatch({
[10:34:16.267]         base::withCallingHandlers({
[10:34:16.267]             ...future.value <- base::withVisible(base::local({
[10:34:16.267]                 ...future.makeSendCondition <- base::local({
[10:34:16.267]                   sendCondition <- NULL
[10:34:16.267]                   function(frame = 1L) {
[10:34:16.267]                     if (is.function(sendCondition)) 
[10:34:16.267]                       return(sendCondition)
[10:34:16.267]                     ns <- getNamespace("parallel")
[10:34:16.267]                     if (exists("sendData", mode = "function", 
[10:34:16.267]                       envir = ns)) {
[10:34:16.267]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:16.267]                         envir = ns)
[10:34:16.267]                       envir <- sys.frame(frame)
[10:34:16.267]                       master <- NULL
[10:34:16.267]                       while (!identical(envir, .GlobalEnv) && 
[10:34:16.267]                         !identical(envir, emptyenv())) {
[10:34:16.267]                         if (exists("master", mode = "list", envir = envir, 
[10:34:16.267]                           inherits = FALSE)) {
[10:34:16.267]                           master <- get("master", mode = "list", 
[10:34:16.267]                             envir = envir, inherits = FALSE)
[10:34:16.267]                           if (inherits(master, c("SOCKnode", 
[10:34:16.267]                             "SOCK0node"))) {
[10:34:16.267]                             sendCondition <<- function(cond) {
[10:34:16.267]                               data <- list(type = "VALUE", value = cond, 
[10:34:16.267]                                 success = TRUE)
[10:34:16.267]                               parallel_sendData(master, data)
[10:34:16.267]                             }
[10:34:16.267]                             return(sendCondition)
[10:34:16.267]                           }
[10:34:16.267]                         }
[10:34:16.267]                         frame <- frame + 1L
[10:34:16.267]                         envir <- sys.frame(frame)
[10:34:16.267]                       }
[10:34:16.267]                     }
[10:34:16.267]                     sendCondition <<- function(cond) NULL
[10:34:16.267]                   }
[10:34:16.267]                 })
[10:34:16.267]                 withCallingHandlers({
[10:34:16.267]                   1
[10:34:16.267]                 }, immediateCondition = function(cond) {
[10:34:16.267]                   sendCondition <- ...future.makeSendCondition()
[10:34:16.267]                   sendCondition(cond)
[10:34:16.267]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.267]                   {
[10:34:16.267]                     inherits <- base::inherits
[10:34:16.267]                     invokeRestart <- base::invokeRestart
[10:34:16.267]                     is.null <- base::is.null
[10:34:16.267]                     muffled <- FALSE
[10:34:16.267]                     if (inherits(cond, "message")) {
[10:34:16.267]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:16.267]                       if (muffled) 
[10:34:16.267]                         invokeRestart("muffleMessage")
[10:34:16.267]                     }
[10:34:16.267]                     else if (inherits(cond, "warning")) {
[10:34:16.267]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:16.267]                       if (muffled) 
[10:34:16.267]                         invokeRestart("muffleWarning")
[10:34:16.267]                     }
[10:34:16.267]                     else if (inherits(cond, "condition")) {
[10:34:16.267]                       if (!is.null(pattern)) {
[10:34:16.267]                         computeRestarts <- base::computeRestarts
[10:34:16.267]                         grepl <- base::grepl
[10:34:16.267]                         restarts <- computeRestarts(cond)
[10:34:16.267]                         for (restart in restarts) {
[10:34:16.267]                           name <- restart$name
[10:34:16.267]                           if (is.null(name)) 
[10:34:16.267]                             next
[10:34:16.267]                           if (!grepl(pattern, name)) 
[10:34:16.267]                             next
[10:34:16.267]                           invokeRestart(restart)
[10:34:16.267]                           muffled <- TRUE
[10:34:16.267]                           break
[10:34:16.267]                         }
[10:34:16.267]                       }
[10:34:16.267]                     }
[10:34:16.267]                     invisible(muffled)
[10:34:16.267]                   }
[10:34:16.267]                   muffleCondition(cond)
[10:34:16.267]                 })
[10:34:16.267]             }))
[10:34:16.267]             future::FutureResult(value = ...future.value$value, 
[10:34:16.267]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:16.267]                   ...future.rng), globalenv = if (FALSE) 
[10:34:16.267]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:16.267]                     ...future.globalenv.names))
[10:34:16.267]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:16.267]         }, condition = base::local({
[10:34:16.267]             c <- base::c
[10:34:16.267]             inherits <- base::inherits
[10:34:16.267]             invokeRestart <- base::invokeRestart
[10:34:16.267]             length <- base::length
[10:34:16.267]             list <- base::list
[10:34:16.267]             seq.int <- base::seq.int
[10:34:16.267]             signalCondition <- base::signalCondition
[10:34:16.267]             sys.calls <- base::sys.calls
[10:34:16.267]             `[[` <- base::`[[`
[10:34:16.267]             `+` <- base::`+`
[10:34:16.267]             `<<-` <- base::`<<-`
[10:34:16.267]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:16.267]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:16.267]                   3L)]
[10:34:16.267]             }
[10:34:16.267]             function(cond) {
[10:34:16.267]                 is_error <- inherits(cond, "error")
[10:34:16.267]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:16.267]                   NULL)
[10:34:16.267]                 if (is_error) {
[10:34:16.267]                   sessionInformation <- function() {
[10:34:16.267]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:16.267]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:16.267]                       search = base::search(), system = base::Sys.info())
[10:34:16.267]                   }
[10:34:16.267]                   ...future.conditions[[length(...future.conditions) + 
[10:34:16.267]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:16.267]                     cond$call), session = sessionInformation(), 
[10:34:16.267]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:16.267]                   signalCondition(cond)
[10:34:16.267]                 }
[10:34:16.267]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:16.267]                 "immediateCondition"))) {
[10:34:16.267]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:16.267]                   ...future.conditions[[length(...future.conditions) + 
[10:34:16.267]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:16.267]                   if (TRUE && !signal) {
[10:34:16.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.267]                     {
[10:34:16.267]                       inherits <- base::inherits
[10:34:16.267]                       invokeRestart <- base::invokeRestart
[10:34:16.267]                       is.null <- base::is.null
[10:34:16.267]                       muffled <- FALSE
[10:34:16.267]                       if (inherits(cond, "message")) {
[10:34:16.267]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:16.267]                         if (muffled) 
[10:34:16.267]                           invokeRestart("muffleMessage")
[10:34:16.267]                       }
[10:34:16.267]                       else if (inherits(cond, "warning")) {
[10:34:16.267]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:16.267]                         if (muffled) 
[10:34:16.267]                           invokeRestart("muffleWarning")
[10:34:16.267]                       }
[10:34:16.267]                       else if (inherits(cond, "condition")) {
[10:34:16.267]                         if (!is.null(pattern)) {
[10:34:16.267]                           computeRestarts <- base::computeRestarts
[10:34:16.267]                           grepl <- base::grepl
[10:34:16.267]                           restarts <- computeRestarts(cond)
[10:34:16.267]                           for (restart in restarts) {
[10:34:16.267]                             name <- restart$name
[10:34:16.267]                             if (is.null(name)) 
[10:34:16.267]                               next
[10:34:16.267]                             if (!grepl(pattern, name)) 
[10:34:16.267]                               next
[10:34:16.267]                             invokeRestart(restart)
[10:34:16.267]                             muffled <- TRUE
[10:34:16.267]                             break
[10:34:16.267]                           }
[10:34:16.267]                         }
[10:34:16.267]                       }
[10:34:16.267]                       invisible(muffled)
[10:34:16.267]                     }
[10:34:16.267]                     muffleCondition(cond, pattern = "^muffle")
[10:34:16.267]                   }
[10:34:16.267]                 }
[10:34:16.267]                 else {
[10:34:16.267]                   if (TRUE) {
[10:34:16.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.267]                     {
[10:34:16.267]                       inherits <- base::inherits
[10:34:16.267]                       invokeRestart <- base::invokeRestart
[10:34:16.267]                       is.null <- base::is.null
[10:34:16.267]                       muffled <- FALSE
[10:34:16.267]                       if (inherits(cond, "message")) {
[10:34:16.267]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:16.267]                         if (muffled) 
[10:34:16.267]                           invokeRestart("muffleMessage")
[10:34:16.267]                       }
[10:34:16.267]                       else if (inherits(cond, "warning")) {
[10:34:16.267]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:16.267]                         if (muffled) 
[10:34:16.267]                           invokeRestart("muffleWarning")
[10:34:16.267]                       }
[10:34:16.267]                       else if (inherits(cond, "condition")) {
[10:34:16.267]                         if (!is.null(pattern)) {
[10:34:16.267]                           computeRestarts <- base::computeRestarts
[10:34:16.267]                           grepl <- base::grepl
[10:34:16.267]                           restarts <- computeRestarts(cond)
[10:34:16.267]                           for (restart in restarts) {
[10:34:16.267]                             name <- restart$name
[10:34:16.267]                             if (is.null(name)) 
[10:34:16.267]                               next
[10:34:16.267]                             if (!grepl(pattern, name)) 
[10:34:16.267]                               next
[10:34:16.267]                             invokeRestart(restart)
[10:34:16.267]                             muffled <- TRUE
[10:34:16.267]                             break
[10:34:16.267]                           }
[10:34:16.267]                         }
[10:34:16.267]                       }
[10:34:16.267]                       invisible(muffled)
[10:34:16.267]                     }
[10:34:16.267]                     muffleCondition(cond, pattern = "^muffle")
[10:34:16.267]                   }
[10:34:16.267]                 }
[10:34:16.267]             }
[10:34:16.267]         }))
[10:34:16.267]     }, error = function(ex) {
[10:34:16.267]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:16.267]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:16.267]                 ...future.rng), started = ...future.startTime, 
[10:34:16.267]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:16.267]             version = "1.8"), class = "FutureResult")
[10:34:16.267]     }, finally = {
[10:34:16.267]         if (!identical(...future.workdir, getwd())) 
[10:34:16.267]             setwd(...future.workdir)
[10:34:16.267]         {
[10:34:16.267]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:16.267]                 ...future.oldOptions$nwarnings <- NULL
[10:34:16.267]             }
[10:34:16.267]             base::options(...future.oldOptions)
[10:34:16.267]             if (.Platform$OS.type == "windows") {
[10:34:16.267]                 old_names <- names(...future.oldEnvVars)
[10:34:16.267]                 envs <- base::Sys.getenv()
[10:34:16.267]                 names <- names(envs)
[10:34:16.267]                 common <- intersect(names, old_names)
[10:34:16.267]                 added <- setdiff(names, old_names)
[10:34:16.267]                 removed <- setdiff(old_names, names)
[10:34:16.267]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:16.267]                   envs[common]]
[10:34:16.267]                 NAMES <- toupper(changed)
[10:34:16.267]                 args <- list()
[10:34:16.267]                 for (kk in seq_along(NAMES)) {
[10:34:16.267]                   name <- changed[[kk]]
[10:34:16.267]                   NAME <- NAMES[[kk]]
[10:34:16.267]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.267]                     next
[10:34:16.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:16.267]                 }
[10:34:16.267]                 NAMES <- toupper(added)
[10:34:16.267]                 for (kk in seq_along(NAMES)) {
[10:34:16.267]                   name <- added[[kk]]
[10:34:16.267]                   NAME <- NAMES[[kk]]
[10:34:16.267]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.267]                     next
[10:34:16.267]                   args[[name]] <- ""
[10:34:16.267]                 }
[10:34:16.267]                 NAMES <- toupper(removed)
[10:34:16.267]                 for (kk in seq_along(NAMES)) {
[10:34:16.267]                   name <- removed[[kk]]
[10:34:16.267]                   NAME <- NAMES[[kk]]
[10:34:16.267]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.267]                     next
[10:34:16.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:16.267]                 }
[10:34:16.267]                 if (length(args) > 0) 
[10:34:16.267]                   base::do.call(base::Sys.setenv, args = args)
[10:34:16.267]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:16.267]             }
[10:34:16.267]             else {
[10:34:16.267]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:16.267]             }
[10:34:16.267]             {
[10:34:16.267]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:16.267]                   0L) {
[10:34:16.267]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:16.267]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:16.267]                   base::options(opts)
[10:34:16.267]                 }
[10:34:16.267]                 {
[10:34:16.267]                   {
[10:34:16.267]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:16.267]                     NULL
[10:34:16.267]                   }
[10:34:16.267]                   options(future.plan = NULL)
[10:34:16.267]                   if (is.na(NA_character_)) 
[10:34:16.267]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:16.267]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:16.267]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:16.267]                     .init = FALSE)
[10:34:16.267]                 }
[10:34:16.267]             }
[10:34:16.267]         }
[10:34:16.267]     })
[10:34:16.267]     if (TRUE) {
[10:34:16.267]         base::sink(type = "output", split = FALSE)
[10:34:16.267]         if (TRUE) {
[10:34:16.267]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:16.267]         }
[10:34:16.267]         else {
[10:34:16.267]             ...future.result["stdout"] <- base::list(NULL)
[10:34:16.267]         }
[10:34:16.267]         base::close(...future.stdout)
[10:34:16.267]         ...future.stdout <- NULL
[10:34:16.267]     }
[10:34:16.267]     ...future.result$conditions <- ...future.conditions
[10:34:16.267]     ...future.result$finished <- base::Sys.time()
[10:34:16.267]     ...future.result
[10:34:16.267] }
[10:34:16.270] MultisessionFuture started
[10:34:16.270] - Launch lazy future ... done
[10:34:16.271] run() for ‘MultisessionFuture’ ... done
[10:34:16.271] getGlobalsAndPackages() ...
[10:34:16.271] Searching for globals...
[10:34:16.272] - globals found: [2] ‘{’, ‘Sys.sleep’
[10:34:16.272] Searching for globals ... DONE
[10:34:16.272] Resolving globals: FALSE
[10:34:16.272] 
[10:34:16.273] 
[10:34:16.273] getGlobalsAndPackages() ... DONE
[10:34:16.273] run() for ‘Future’ ...
[10:34:16.273] - state: ‘created’
[10:34:16.273] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:16.287] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:16.287] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:16.287]   - Field: ‘node’
[10:34:16.287]   - Field: ‘label’
[10:34:16.287]   - Field: ‘local’
[10:34:16.287]   - Field: ‘owner’
[10:34:16.287]   - Field: ‘envir’
[10:34:16.287]   - Field: ‘workers’
[10:34:16.287]   - Field: ‘packages’
[10:34:16.288]   - Field: ‘gc’
[10:34:16.288]   - Field: ‘conditions’
[10:34:16.288]   - Field: ‘persistent’
[10:34:16.288]   - Field: ‘expr’
[10:34:16.288]   - Field: ‘uuid’
[10:34:16.288]   - Field: ‘seed’
[10:34:16.288]   - Field: ‘version’
[10:34:16.288]   - Field: ‘result’
[10:34:16.288]   - Field: ‘asynchronous’
[10:34:16.288]   - Field: ‘calls’
[10:34:16.288]   - Field: ‘globals’
[10:34:16.289]   - Field: ‘stdout’
[10:34:16.289]   - Field: ‘earlySignal’
[10:34:16.289]   - Field: ‘lazy’
[10:34:16.289]   - Field: ‘state’
[10:34:16.289] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:16.289] - Launch lazy future ...
[10:34:16.289] Packages needed by the future expression (n = 0): <none>
[10:34:16.289] Packages needed by future strategies (n = 0): <none>
[10:34:16.290] {
[10:34:16.290]     {
[10:34:16.290]         {
[10:34:16.290]             ...future.startTime <- base::Sys.time()
[10:34:16.290]             {
[10:34:16.290]                 {
[10:34:16.290]                   {
[10:34:16.290]                     {
[10:34:16.290]                       base::local({
[10:34:16.290]                         has_future <- base::requireNamespace("future", 
[10:34:16.290]                           quietly = TRUE)
[10:34:16.290]                         if (has_future) {
[10:34:16.290]                           ns <- base::getNamespace("future")
[10:34:16.290]                           version <- ns[[".package"]][["version"]]
[10:34:16.290]                           if (is.null(version)) 
[10:34:16.290]                             version <- utils::packageVersion("future")
[10:34:16.290]                         }
[10:34:16.290]                         else {
[10:34:16.290]                           version <- NULL
[10:34:16.290]                         }
[10:34:16.290]                         if (!has_future || version < "1.8.0") {
[10:34:16.290]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:16.290]                             "", base::R.version$version.string), 
[10:34:16.290]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:16.290]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:16.290]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:16.290]                               "release", "version")], collapse = " "), 
[10:34:16.290]                             hostname = base::Sys.info()[["nodename"]])
[10:34:16.290]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:16.290]                             info)
[10:34:16.290]                           info <- base::paste(info, collapse = "; ")
[10:34:16.290]                           if (!has_future) {
[10:34:16.290]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:16.290]                               info)
[10:34:16.290]                           }
[10:34:16.290]                           else {
[10:34:16.290]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:16.290]                               info, version)
[10:34:16.290]                           }
[10:34:16.290]                           base::stop(msg)
[10:34:16.290]                         }
[10:34:16.290]                       })
[10:34:16.290]                     }
[10:34:16.290]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:16.290]                     base::options(mc.cores = 1L)
[10:34:16.290]                   }
[10:34:16.290]                   ...future.strategy.old <- future::plan("list")
[10:34:16.290]                   options(future.plan = NULL)
[10:34:16.290]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:16.290]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:16.290]                 }
[10:34:16.290]                 ...future.workdir <- getwd()
[10:34:16.290]             }
[10:34:16.290]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:16.290]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:16.290]         }
[10:34:16.290]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:16.290]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:16.290]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:16.290]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:16.290]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:16.290]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:16.290]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:16.290]             base::names(...future.oldOptions))
[10:34:16.290]     }
[10:34:16.290]     if (FALSE) {
[10:34:16.290]     }
[10:34:16.290]     else {
[10:34:16.290]         if (TRUE) {
[10:34:16.290]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:16.290]                 open = "w")
[10:34:16.290]         }
[10:34:16.290]         else {
[10:34:16.290]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:16.290]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:16.290]         }
[10:34:16.290]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:16.290]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:16.290]             base::sink(type = "output", split = FALSE)
[10:34:16.290]             base::close(...future.stdout)
[10:34:16.290]         }, add = TRUE)
[10:34:16.290]     }
[10:34:16.290]     ...future.frame <- base::sys.nframe()
[10:34:16.290]     ...future.conditions <- base::list()
[10:34:16.290]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:16.290]     if (FALSE) {
[10:34:16.290]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:16.290]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:16.290]     }
[10:34:16.290]     ...future.result <- base::tryCatch({
[10:34:16.290]         base::withCallingHandlers({
[10:34:16.290]             ...future.value <- base::withVisible(base::local({
[10:34:16.290]                 ...future.makeSendCondition <- base::local({
[10:34:16.290]                   sendCondition <- NULL
[10:34:16.290]                   function(frame = 1L) {
[10:34:16.290]                     if (is.function(sendCondition)) 
[10:34:16.290]                       return(sendCondition)
[10:34:16.290]                     ns <- getNamespace("parallel")
[10:34:16.290]                     if (exists("sendData", mode = "function", 
[10:34:16.290]                       envir = ns)) {
[10:34:16.290]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:16.290]                         envir = ns)
[10:34:16.290]                       envir <- sys.frame(frame)
[10:34:16.290]                       master <- NULL
[10:34:16.290]                       while (!identical(envir, .GlobalEnv) && 
[10:34:16.290]                         !identical(envir, emptyenv())) {
[10:34:16.290]                         if (exists("master", mode = "list", envir = envir, 
[10:34:16.290]                           inherits = FALSE)) {
[10:34:16.290]                           master <- get("master", mode = "list", 
[10:34:16.290]                             envir = envir, inherits = FALSE)
[10:34:16.290]                           if (inherits(master, c("SOCKnode", 
[10:34:16.290]                             "SOCK0node"))) {
[10:34:16.290]                             sendCondition <<- function(cond) {
[10:34:16.290]                               data <- list(type = "VALUE", value = cond, 
[10:34:16.290]                                 success = TRUE)
[10:34:16.290]                               parallel_sendData(master, data)
[10:34:16.290]                             }
[10:34:16.290]                             return(sendCondition)
[10:34:16.290]                           }
[10:34:16.290]                         }
[10:34:16.290]                         frame <- frame + 1L
[10:34:16.290]                         envir <- sys.frame(frame)
[10:34:16.290]                       }
[10:34:16.290]                     }
[10:34:16.290]                     sendCondition <<- function(cond) NULL
[10:34:16.290]                   }
[10:34:16.290]                 })
[10:34:16.290]                 withCallingHandlers({
[10:34:16.290]                   {
[10:34:16.290]                     Sys.sleep(0.5)
[10:34:16.290]                     2
[10:34:16.290]                   }
[10:34:16.290]                 }, immediateCondition = function(cond) {
[10:34:16.290]                   sendCondition <- ...future.makeSendCondition()
[10:34:16.290]                   sendCondition(cond)
[10:34:16.290]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.290]                   {
[10:34:16.290]                     inherits <- base::inherits
[10:34:16.290]                     invokeRestart <- base::invokeRestart
[10:34:16.290]                     is.null <- base::is.null
[10:34:16.290]                     muffled <- FALSE
[10:34:16.290]                     if (inherits(cond, "message")) {
[10:34:16.290]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:16.290]                       if (muffled) 
[10:34:16.290]                         invokeRestart("muffleMessage")
[10:34:16.290]                     }
[10:34:16.290]                     else if (inherits(cond, "warning")) {
[10:34:16.290]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:16.290]                       if (muffled) 
[10:34:16.290]                         invokeRestart("muffleWarning")
[10:34:16.290]                     }
[10:34:16.290]                     else if (inherits(cond, "condition")) {
[10:34:16.290]                       if (!is.null(pattern)) {
[10:34:16.290]                         computeRestarts <- base::computeRestarts
[10:34:16.290]                         grepl <- base::grepl
[10:34:16.290]                         restarts <- computeRestarts(cond)
[10:34:16.290]                         for (restart in restarts) {
[10:34:16.290]                           name <- restart$name
[10:34:16.290]                           if (is.null(name)) 
[10:34:16.290]                             next
[10:34:16.290]                           if (!grepl(pattern, name)) 
[10:34:16.290]                             next
[10:34:16.290]                           invokeRestart(restart)
[10:34:16.290]                           muffled <- TRUE
[10:34:16.290]                           break
[10:34:16.290]                         }
[10:34:16.290]                       }
[10:34:16.290]                     }
[10:34:16.290]                     invisible(muffled)
[10:34:16.290]                   }
[10:34:16.290]                   muffleCondition(cond)
[10:34:16.290]                 })
[10:34:16.290]             }))
[10:34:16.290]             future::FutureResult(value = ...future.value$value, 
[10:34:16.290]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:16.290]                   ...future.rng), globalenv = if (FALSE) 
[10:34:16.290]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:16.290]                     ...future.globalenv.names))
[10:34:16.290]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:16.290]         }, condition = base::local({
[10:34:16.290]             c <- base::c
[10:34:16.290]             inherits <- base::inherits
[10:34:16.290]             invokeRestart <- base::invokeRestart
[10:34:16.290]             length <- base::length
[10:34:16.290]             list <- base::list
[10:34:16.290]             seq.int <- base::seq.int
[10:34:16.290]             signalCondition <- base::signalCondition
[10:34:16.290]             sys.calls <- base::sys.calls
[10:34:16.290]             `[[` <- base::`[[`
[10:34:16.290]             `+` <- base::`+`
[10:34:16.290]             `<<-` <- base::`<<-`
[10:34:16.290]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:16.290]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:16.290]                   3L)]
[10:34:16.290]             }
[10:34:16.290]             function(cond) {
[10:34:16.290]                 is_error <- inherits(cond, "error")
[10:34:16.290]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:16.290]                   NULL)
[10:34:16.290]                 if (is_error) {
[10:34:16.290]                   sessionInformation <- function() {
[10:34:16.290]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:16.290]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:16.290]                       search = base::search(), system = base::Sys.info())
[10:34:16.290]                   }
[10:34:16.290]                   ...future.conditions[[length(...future.conditions) + 
[10:34:16.290]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:16.290]                     cond$call), session = sessionInformation(), 
[10:34:16.290]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:16.290]                   signalCondition(cond)
[10:34:16.290]                 }
[10:34:16.290]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:16.290]                 "immediateCondition"))) {
[10:34:16.290]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:16.290]                   ...future.conditions[[length(...future.conditions) + 
[10:34:16.290]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:16.290]                   if (TRUE && !signal) {
[10:34:16.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.290]                     {
[10:34:16.290]                       inherits <- base::inherits
[10:34:16.290]                       invokeRestart <- base::invokeRestart
[10:34:16.290]                       is.null <- base::is.null
[10:34:16.290]                       muffled <- FALSE
[10:34:16.290]                       if (inherits(cond, "message")) {
[10:34:16.290]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:16.290]                         if (muffled) 
[10:34:16.290]                           invokeRestart("muffleMessage")
[10:34:16.290]                       }
[10:34:16.290]                       else if (inherits(cond, "warning")) {
[10:34:16.290]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:16.290]                         if (muffled) 
[10:34:16.290]                           invokeRestart("muffleWarning")
[10:34:16.290]                       }
[10:34:16.290]                       else if (inherits(cond, "condition")) {
[10:34:16.290]                         if (!is.null(pattern)) {
[10:34:16.290]                           computeRestarts <- base::computeRestarts
[10:34:16.290]                           grepl <- base::grepl
[10:34:16.290]                           restarts <- computeRestarts(cond)
[10:34:16.290]                           for (restart in restarts) {
[10:34:16.290]                             name <- restart$name
[10:34:16.290]                             if (is.null(name)) 
[10:34:16.290]                               next
[10:34:16.290]                             if (!grepl(pattern, name)) 
[10:34:16.290]                               next
[10:34:16.290]                             invokeRestart(restart)
[10:34:16.290]                             muffled <- TRUE
[10:34:16.290]                             break
[10:34:16.290]                           }
[10:34:16.290]                         }
[10:34:16.290]                       }
[10:34:16.290]                       invisible(muffled)
[10:34:16.290]                     }
[10:34:16.290]                     muffleCondition(cond, pattern = "^muffle")
[10:34:16.290]                   }
[10:34:16.290]                 }
[10:34:16.290]                 else {
[10:34:16.290]                   if (TRUE) {
[10:34:16.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.290]                     {
[10:34:16.290]                       inherits <- base::inherits
[10:34:16.290]                       invokeRestart <- base::invokeRestart
[10:34:16.290]                       is.null <- base::is.null
[10:34:16.290]                       muffled <- FALSE
[10:34:16.290]                       if (inherits(cond, "message")) {
[10:34:16.290]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:16.290]                         if (muffled) 
[10:34:16.290]                           invokeRestart("muffleMessage")
[10:34:16.290]                       }
[10:34:16.290]                       else if (inherits(cond, "warning")) {
[10:34:16.290]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:16.290]                         if (muffled) 
[10:34:16.290]                           invokeRestart("muffleWarning")
[10:34:16.290]                       }
[10:34:16.290]                       else if (inherits(cond, "condition")) {
[10:34:16.290]                         if (!is.null(pattern)) {
[10:34:16.290]                           computeRestarts <- base::computeRestarts
[10:34:16.290]                           grepl <- base::grepl
[10:34:16.290]                           restarts <- computeRestarts(cond)
[10:34:16.290]                           for (restart in restarts) {
[10:34:16.290]                             name <- restart$name
[10:34:16.290]                             if (is.null(name)) 
[10:34:16.290]                               next
[10:34:16.290]                             if (!grepl(pattern, name)) 
[10:34:16.290]                               next
[10:34:16.290]                             invokeRestart(restart)
[10:34:16.290]                             muffled <- TRUE
[10:34:16.290]                             break
[10:34:16.290]                           }
[10:34:16.290]                         }
[10:34:16.290]                       }
[10:34:16.290]                       invisible(muffled)
[10:34:16.290]                     }
[10:34:16.290]                     muffleCondition(cond, pattern = "^muffle")
[10:34:16.290]                   }
[10:34:16.290]                 }
[10:34:16.290]             }
[10:34:16.290]         }))
[10:34:16.290]     }, error = function(ex) {
[10:34:16.290]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:16.290]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:16.290]                 ...future.rng), started = ...future.startTime, 
[10:34:16.290]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:16.290]             version = "1.8"), class = "FutureResult")
[10:34:16.290]     }, finally = {
[10:34:16.290]         if (!identical(...future.workdir, getwd())) 
[10:34:16.290]             setwd(...future.workdir)
[10:34:16.290]         {
[10:34:16.290]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:16.290]                 ...future.oldOptions$nwarnings <- NULL
[10:34:16.290]             }
[10:34:16.290]             base::options(...future.oldOptions)
[10:34:16.290]             if (.Platform$OS.type == "windows") {
[10:34:16.290]                 old_names <- names(...future.oldEnvVars)
[10:34:16.290]                 envs <- base::Sys.getenv()
[10:34:16.290]                 names <- names(envs)
[10:34:16.290]                 common <- intersect(names, old_names)
[10:34:16.290]                 added <- setdiff(names, old_names)
[10:34:16.290]                 removed <- setdiff(old_names, names)
[10:34:16.290]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:16.290]                   envs[common]]
[10:34:16.290]                 NAMES <- toupper(changed)
[10:34:16.290]                 args <- list()
[10:34:16.290]                 for (kk in seq_along(NAMES)) {
[10:34:16.290]                   name <- changed[[kk]]
[10:34:16.290]                   NAME <- NAMES[[kk]]
[10:34:16.290]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.290]                     next
[10:34:16.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:16.290]                 }
[10:34:16.290]                 NAMES <- toupper(added)
[10:34:16.290]                 for (kk in seq_along(NAMES)) {
[10:34:16.290]                   name <- added[[kk]]
[10:34:16.290]                   NAME <- NAMES[[kk]]
[10:34:16.290]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.290]                     next
[10:34:16.290]                   args[[name]] <- ""
[10:34:16.290]                 }
[10:34:16.290]                 NAMES <- toupper(removed)
[10:34:16.290]                 for (kk in seq_along(NAMES)) {
[10:34:16.290]                   name <- removed[[kk]]
[10:34:16.290]                   NAME <- NAMES[[kk]]
[10:34:16.290]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.290]                     next
[10:34:16.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:16.290]                 }
[10:34:16.290]                 if (length(args) > 0) 
[10:34:16.290]                   base::do.call(base::Sys.setenv, args = args)
[10:34:16.290]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:16.290]             }
[10:34:16.290]             else {
[10:34:16.290]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:16.290]             }
[10:34:16.290]             {
[10:34:16.290]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:16.290]                   0L) {
[10:34:16.290]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:16.290]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:16.290]                   base::options(opts)
[10:34:16.290]                 }
[10:34:16.290]                 {
[10:34:16.290]                   {
[10:34:16.290]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:16.290]                     NULL
[10:34:16.290]                   }
[10:34:16.290]                   options(future.plan = NULL)
[10:34:16.290]                   if (is.na(NA_character_)) 
[10:34:16.290]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:16.290]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:16.290]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:16.290]                     .init = FALSE)
[10:34:16.290]                 }
[10:34:16.290]             }
[10:34:16.290]         }
[10:34:16.290]     })
[10:34:16.290]     if (TRUE) {
[10:34:16.290]         base::sink(type = "output", split = FALSE)
[10:34:16.290]         if (TRUE) {
[10:34:16.290]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:16.290]         }
[10:34:16.290]         else {
[10:34:16.290]             ...future.result["stdout"] <- base::list(NULL)
[10:34:16.290]         }
[10:34:16.290]         base::close(...future.stdout)
[10:34:16.290]         ...future.stdout <- NULL
[10:34:16.290]     }
[10:34:16.290]     ...future.result$conditions <- ...future.conditions
[10:34:16.290]     ...future.result$finished <- base::Sys.time()
[10:34:16.290]     ...future.result
[10:34:16.290] }
[10:34:16.293] MultisessionFuture started
[10:34:16.293] - Launch lazy future ... done
[10:34:16.293] run() for ‘MultisessionFuture’ ... done
[10:34:16.293] resolve() on list ...
[10:34:16.293]  recursive: 0
[10:34:16.293]  length: 1
[10:34:16.293] 
[10:34:16.294] receiveMessageFromWorker() for ClusterFuture ...
[10:34:16.294] - Validating connection of MultisessionFuture
[10:34:16.294] - received message: FutureResult
[10:34:16.294] - Received FutureResult
[10:34:16.294] - Erased future from FutureRegistry
[10:34:16.294] result() for ClusterFuture ...
[10:34:16.294] - result already collected: FutureResult
[10:34:16.294] result() for ClusterFuture ... done
[10:34:16.295] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:16.295] Future #1
[10:34:16.295]  length: 0 (resolved future 1)
[10:34:16.295] resolve() on list ... DONE
[10:34:16.295] resolve() on list ...
[10:34:16.295]  recursive: 0
[10:34:16.295]  length: 1
[10:34:16.295] 
[10:34:16.797] receiveMessageFromWorker() for ClusterFuture ...
[10:34:16.797] - Validating connection of MultisessionFuture
[10:34:16.797] - received message: FutureResult
[10:34:16.797] - Received FutureResult
[10:34:16.798] - Erased future from FutureRegistry
[10:34:16.798] result() for ClusterFuture ...
[10:34:16.798] - result already collected: FutureResult
[10:34:16.798] result() for ClusterFuture ... done
[10:34:16.798] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:16.798] Future #1
[10:34:16.798]  length: 0 (resolved future 1)
[10:34:16.798] resolve() on list ... DONE
[10:34:16.799] resolve() on list ...
[10:34:16.799]  recursive: 0
[10:34:16.799]  length: 1
[10:34:16.799] 
[10:34:16.799]  length: 0 (resolved future 1)
[10:34:16.799] resolve() on list ... DONE
[10:34:16.799] resolve() on list ...
[10:34:16.799]  recursive: 0
[10:34:16.799]  length: 4
[10:34:16.799] 
[10:34:16.800] Future #1
[10:34:16.800]  length: 3 (resolved future 1)
[10:34:16.800] Future #2
[10:34:16.800]  length: 2 (resolved future 2)
[10:34:16.800]  length: 1 (resolved future 3)
[10:34:16.800]  length: 0 (resolved future 4)
[10:34:16.800] resolve() on list ... DONE
[10:34:16.800] resolve() on list ...
[10:34:16.800]  recursive: 0
[10:34:16.800]  length: 4
[10:34:16.801] 
[10:34:16.801] Future #1
[10:34:16.801]  length: 3 (resolved future 1)
[10:34:16.801] Future #2
[10:34:16.801]  length: 2 (resolved future 2)
[10:34:16.801]  length: 1 (resolved future 3)
[10:34:16.801]  length: 0 (resolved future 4)
[10:34:16.801] resolve() on list ... DONE
[10:34:16.802] resolve() on list ...
[10:34:16.802]  recursive: 0
[10:34:16.802]  length: 1
[10:34:16.802] 
[10:34:16.802]  length: 0 (resolved future 1)
[10:34:16.802] resolve() on list ... DONE
[10:34:16.802] getGlobalsAndPackages() ...
[10:34:16.802] Searching for globals...
[10:34:16.803] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:34:16.803] Searching for globals ... DONE
[10:34:16.803] Resolving globals: FALSE
[10:34:16.804] The total size of the 1 globals is 56 bytes (56 bytes)
[10:34:16.804] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:34:16.804] - globals: [1] ‘kk’
[10:34:16.804] 
[10:34:16.804] getGlobalsAndPackages() ... DONE
[10:34:16.805] run() for ‘Future’ ...
[10:34:16.805] - state: ‘created’
[10:34:16.805] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:16.819] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:16.819] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:16.819]   - Field: ‘node’
[10:34:16.819]   - Field: ‘label’
[10:34:16.819]   - Field: ‘local’
[10:34:16.819]   - Field: ‘owner’
[10:34:16.819]   - Field: ‘envir’
[10:34:16.819]   - Field: ‘workers’
[10:34:16.820]   - Field: ‘packages’
[10:34:16.820]   - Field: ‘gc’
[10:34:16.820]   - Field: ‘conditions’
[10:34:16.820]   - Field: ‘persistent’
[10:34:16.820]   - Field: ‘expr’
[10:34:16.820]   - Field: ‘uuid’
[10:34:16.820]   - Field: ‘seed’
[10:34:16.820]   - Field: ‘version’
[10:34:16.820]   - Field: ‘result’
[10:34:16.820]   - Field: ‘asynchronous’
[10:34:16.820]   - Field: ‘calls’
[10:34:16.821]   - Field: ‘globals’
[10:34:16.821]   - Field: ‘stdout’
[10:34:16.821]   - Field: ‘earlySignal’
[10:34:16.821]   - Field: ‘lazy’
[10:34:16.821]   - Field: ‘state’
[10:34:16.821] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:16.821] - Launch lazy future ...
[10:34:16.821] Packages needed by the future expression (n = 0): <none>
[10:34:16.822] Packages needed by future strategies (n = 0): <none>
[10:34:16.822] {
[10:34:16.822]     {
[10:34:16.822]         {
[10:34:16.822]             ...future.startTime <- base::Sys.time()
[10:34:16.822]             {
[10:34:16.822]                 {
[10:34:16.822]                   {
[10:34:16.822]                     {
[10:34:16.822]                       base::local({
[10:34:16.822]                         has_future <- base::requireNamespace("future", 
[10:34:16.822]                           quietly = TRUE)
[10:34:16.822]                         if (has_future) {
[10:34:16.822]                           ns <- base::getNamespace("future")
[10:34:16.822]                           version <- ns[[".package"]][["version"]]
[10:34:16.822]                           if (is.null(version)) 
[10:34:16.822]                             version <- utils::packageVersion("future")
[10:34:16.822]                         }
[10:34:16.822]                         else {
[10:34:16.822]                           version <- NULL
[10:34:16.822]                         }
[10:34:16.822]                         if (!has_future || version < "1.8.0") {
[10:34:16.822]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:16.822]                             "", base::R.version$version.string), 
[10:34:16.822]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:16.822]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:16.822]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:16.822]                               "release", "version")], collapse = " "), 
[10:34:16.822]                             hostname = base::Sys.info()[["nodename"]])
[10:34:16.822]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:16.822]                             info)
[10:34:16.822]                           info <- base::paste(info, collapse = "; ")
[10:34:16.822]                           if (!has_future) {
[10:34:16.822]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:16.822]                               info)
[10:34:16.822]                           }
[10:34:16.822]                           else {
[10:34:16.822]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:16.822]                               info, version)
[10:34:16.822]                           }
[10:34:16.822]                           base::stop(msg)
[10:34:16.822]                         }
[10:34:16.822]                       })
[10:34:16.822]                     }
[10:34:16.822]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:16.822]                     base::options(mc.cores = 1L)
[10:34:16.822]                   }
[10:34:16.822]                   ...future.strategy.old <- future::plan("list")
[10:34:16.822]                   options(future.plan = NULL)
[10:34:16.822]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:16.822]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:16.822]                 }
[10:34:16.822]                 ...future.workdir <- getwd()
[10:34:16.822]             }
[10:34:16.822]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:16.822]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:16.822]         }
[10:34:16.822]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:16.822]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:16.822]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:16.822]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:16.822]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:16.822]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:16.822]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:16.822]             base::names(...future.oldOptions))
[10:34:16.822]     }
[10:34:16.822]     if (FALSE) {
[10:34:16.822]     }
[10:34:16.822]     else {
[10:34:16.822]         if (TRUE) {
[10:34:16.822]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:16.822]                 open = "w")
[10:34:16.822]         }
[10:34:16.822]         else {
[10:34:16.822]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:16.822]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:16.822]         }
[10:34:16.822]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:16.822]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:16.822]             base::sink(type = "output", split = FALSE)
[10:34:16.822]             base::close(...future.stdout)
[10:34:16.822]         }, add = TRUE)
[10:34:16.822]     }
[10:34:16.822]     ...future.frame <- base::sys.nframe()
[10:34:16.822]     ...future.conditions <- base::list()
[10:34:16.822]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:16.822]     if (FALSE) {
[10:34:16.822]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:16.822]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:16.822]     }
[10:34:16.822]     ...future.result <- base::tryCatch({
[10:34:16.822]         base::withCallingHandlers({
[10:34:16.822]             ...future.value <- base::withVisible(base::local({
[10:34:16.822]                 ...future.makeSendCondition <- base::local({
[10:34:16.822]                   sendCondition <- NULL
[10:34:16.822]                   function(frame = 1L) {
[10:34:16.822]                     if (is.function(sendCondition)) 
[10:34:16.822]                       return(sendCondition)
[10:34:16.822]                     ns <- getNamespace("parallel")
[10:34:16.822]                     if (exists("sendData", mode = "function", 
[10:34:16.822]                       envir = ns)) {
[10:34:16.822]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:16.822]                         envir = ns)
[10:34:16.822]                       envir <- sys.frame(frame)
[10:34:16.822]                       master <- NULL
[10:34:16.822]                       while (!identical(envir, .GlobalEnv) && 
[10:34:16.822]                         !identical(envir, emptyenv())) {
[10:34:16.822]                         if (exists("master", mode = "list", envir = envir, 
[10:34:16.822]                           inherits = FALSE)) {
[10:34:16.822]                           master <- get("master", mode = "list", 
[10:34:16.822]                             envir = envir, inherits = FALSE)
[10:34:16.822]                           if (inherits(master, c("SOCKnode", 
[10:34:16.822]                             "SOCK0node"))) {
[10:34:16.822]                             sendCondition <<- function(cond) {
[10:34:16.822]                               data <- list(type = "VALUE", value = cond, 
[10:34:16.822]                                 success = TRUE)
[10:34:16.822]                               parallel_sendData(master, data)
[10:34:16.822]                             }
[10:34:16.822]                             return(sendCondition)
[10:34:16.822]                           }
[10:34:16.822]                         }
[10:34:16.822]                         frame <- frame + 1L
[10:34:16.822]                         envir <- sys.frame(frame)
[10:34:16.822]                       }
[10:34:16.822]                     }
[10:34:16.822]                     sendCondition <<- function(cond) NULL
[10:34:16.822]                   }
[10:34:16.822]                 })
[10:34:16.822]                 withCallingHandlers({
[10:34:16.822]                   {
[10:34:16.822]                     Sys.sleep(0.1)
[10:34:16.822]                     kk
[10:34:16.822]                   }
[10:34:16.822]                 }, immediateCondition = function(cond) {
[10:34:16.822]                   sendCondition <- ...future.makeSendCondition()
[10:34:16.822]                   sendCondition(cond)
[10:34:16.822]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.822]                   {
[10:34:16.822]                     inherits <- base::inherits
[10:34:16.822]                     invokeRestart <- base::invokeRestart
[10:34:16.822]                     is.null <- base::is.null
[10:34:16.822]                     muffled <- FALSE
[10:34:16.822]                     if (inherits(cond, "message")) {
[10:34:16.822]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:16.822]                       if (muffled) 
[10:34:16.822]                         invokeRestart("muffleMessage")
[10:34:16.822]                     }
[10:34:16.822]                     else if (inherits(cond, "warning")) {
[10:34:16.822]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:16.822]                       if (muffled) 
[10:34:16.822]                         invokeRestart("muffleWarning")
[10:34:16.822]                     }
[10:34:16.822]                     else if (inherits(cond, "condition")) {
[10:34:16.822]                       if (!is.null(pattern)) {
[10:34:16.822]                         computeRestarts <- base::computeRestarts
[10:34:16.822]                         grepl <- base::grepl
[10:34:16.822]                         restarts <- computeRestarts(cond)
[10:34:16.822]                         for (restart in restarts) {
[10:34:16.822]                           name <- restart$name
[10:34:16.822]                           if (is.null(name)) 
[10:34:16.822]                             next
[10:34:16.822]                           if (!grepl(pattern, name)) 
[10:34:16.822]                             next
[10:34:16.822]                           invokeRestart(restart)
[10:34:16.822]                           muffled <- TRUE
[10:34:16.822]                           break
[10:34:16.822]                         }
[10:34:16.822]                       }
[10:34:16.822]                     }
[10:34:16.822]                     invisible(muffled)
[10:34:16.822]                   }
[10:34:16.822]                   muffleCondition(cond)
[10:34:16.822]                 })
[10:34:16.822]             }))
[10:34:16.822]             future::FutureResult(value = ...future.value$value, 
[10:34:16.822]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:16.822]                   ...future.rng), globalenv = if (FALSE) 
[10:34:16.822]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:16.822]                     ...future.globalenv.names))
[10:34:16.822]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:16.822]         }, condition = base::local({
[10:34:16.822]             c <- base::c
[10:34:16.822]             inherits <- base::inherits
[10:34:16.822]             invokeRestart <- base::invokeRestart
[10:34:16.822]             length <- base::length
[10:34:16.822]             list <- base::list
[10:34:16.822]             seq.int <- base::seq.int
[10:34:16.822]             signalCondition <- base::signalCondition
[10:34:16.822]             sys.calls <- base::sys.calls
[10:34:16.822]             `[[` <- base::`[[`
[10:34:16.822]             `+` <- base::`+`
[10:34:16.822]             `<<-` <- base::`<<-`
[10:34:16.822]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:16.822]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:16.822]                   3L)]
[10:34:16.822]             }
[10:34:16.822]             function(cond) {
[10:34:16.822]                 is_error <- inherits(cond, "error")
[10:34:16.822]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:16.822]                   NULL)
[10:34:16.822]                 if (is_error) {
[10:34:16.822]                   sessionInformation <- function() {
[10:34:16.822]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:16.822]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:16.822]                       search = base::search(), system = base::Sys.info())
[10:34:16.822]                   }
[10:34:16.822]                   ...future.conditions[[length(...future.conditions) + 
[10:34:16.822]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:16.822]                     cond$call), session = sessionInformation(), 
[10:34:16.822]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:16.822]                   signalCondition(cond)
[10:34:16.822]                 }
[10:34:16.822]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:16.822]                 "immediateCondition"))) {
[10:34:16.822]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:16.822]                   ...future.conditions[[length(...future.conditions) + 
[10:34:16.822]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:16.822]                   if (TRUE && !signal) {
[10:34:16.822]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.822]                     {
[10:34:16.822]                       inherits <- base::inherits
[10:34:16.822]                       invokeRestart <- base::invokeRestart
[10:34:16.822]                       is.null <- base::is.null
[10:34:16.822]                       muffled <- FALSE
[10:34:16.822]                       if (inherits(cond, "message")) {
[10:34:16.822]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:16.822]                         if (muffled) 
[10:34:16.822]                           invokeRestart("muffleMessage")
[10:34:16.822]                       }
[10:34:16.822]                       else if (inherits(cond, "warning")) {
[10:34:16.822]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:16.822]                         if (muffled) 
[10:34:16.822]                           invokeRestart("muffleWarning")
[10:34:16.822]                       }
[10:34:16.822]                       else if (inherits(cond, "condition")) {
[10:34:16.822]                         if (!is.null(pattern)) {
[10:34:16.822]                           computeRestarts <- base::computeRestarts
[10:34:16.822]                           grepl <- base::grepl
[10:34:16.822]                           restarts <- computeRestarts(cond)
[10:34:16.822]                           for (restart in restarts) {
[10:34:16.822]                             name <- restart$name
[10:34:16.822]                             if (is.null(name)) 
[10:34:16.822]                               next
[10:34:16.822]                             if (!grepl(pattern, name)) 
[10:34:16.822]                               next
[10:34:16.822]                             invokeRestart(restart)
[10:34:16.822]                             muffled <- TRUE
[10:34:16.822]                             break
[10:34:16.822]                           }
[10:34:16.822]                         }
[10:34:16.822]                       }
[10:34:16.822]                       invisible(muffled)
[10:34:16.822]                     }
[10:34:16.822]                     muffleCondition(cond, pattern = "^muffle")
[10:34:16.822]                   }
[10:34:16.822]                 }
[10:34:16.822]                 else {
[10:34:16.822]                   if (TRUE) {
[10:34:16.822]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.822]                     {
[10:34:16.822]                       inherits <- base::inherits
[10:34:16.822]                       invokeRestart <- base::invokeRestart
[10:34:16.822]                       is.null <- base::is.null
[10:34:16.822]                       muffled <- FALSE
[10:34:16.822]                       if (inherits(cond, "message")) {
[10:34:16.822]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:16.822]                         if (muffled) 
[10:34:16.822]                           invokeRestart("muffleMessage")
[10:34:16.822]                       }
[10:34:16.822]                       else if (inherits(cond, "warning")) {
[10:34:16.822]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:16.822]                         if (muffled) 
[10:34:16.822]                           invokeRestart("muffleWarning")
[10:34:16.822]                       }
[10:34:16.822]                       else if (inherits(cond, "condition")) {
[10:34:16.822]                         if (!is.null(pattern)) {
[10:34:16.822]                           computeRestarts <- base::computeRestarts
[10:34:16.822]                           grepl <- base::grepl
[10:34:16.822]                           restarts <- computeRestarts(cond)
[10:34:16.822]                           for (restart in restarts) {
[10:34:16.822]                             name <- restart$name
[10:34:16.822]                             if (is.null(name)) 
[10:34:16.822]                               next
[10:34:16.822]                             if (!grepl(pattern, name)) 
[10:34:16.822]                               next
[10:34:16.822]                             invokeRestart(restart)
[10:34:16.822]                             muffled <- TRUE
[10:34:16.822]                             break
[10:34:16.822]                           }
[10:34:16.822]                         }
[10:34:16.822]                       }
[10:34:16.822]                       invisible(muffled)
[10:34:16.822]                     }
[10:34:16.822]                     muffleCondition(cond, pattern = "^muffle")
[10:34:16.822]                   }
[10:34:16.822]                 }
[10:34:16.822]             }
[10:34:16.822]         }))
[10:34:16.822]     }, error = function(ex) {
[10:34:16.822]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:16.822]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:16.822]                 ...future.rng), started = ...future.startTime, 
[10:34:16.822]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:16.822]             version = "1.8"), class = "FutureResult")
[10:34:16.822]     }, finally = {
[10:34:16.822]         if (!identical(...future.workdir, getwd())) 
[10:34:16.822]             setwd(...future.workdir)
[10:34:16.822]         {
[10:34:16.822]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:16.822]                 ...future.oldOptions$nwarnings <- NULL
[10:34:16.822]             }
[10:34:16.822]             base::options(...future.oldOptions)
[10:34:16.822]             if (.Platform$OS.type == "windows") {
[10:34:16.822]                 old_names <- names(...future.oldEnvVars)
[10:34:16.822]                 envs <- base::Sys.getenv()
[10:34:16.822]                 names <- names(envs)
[10:34:16.822]                 common <- intersect(names, old_names)
[10:34:16.822]                 added <- setdiff(names, old_names)
[10:34:16.822]                 removed <- setdiff(old_names, names)
[10:34:16.822]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:16.822]                   envs[common]]
[10:34:16.822]                 NAMES <- toupper(changed)
[10:34:16.822]                 args <- list()
[10:34:16.822]                 for (kk in seq_along(NAMES)) {
[10:34:16.822]                   name <- changed[[kk]]
[10:34:16.822]                   NAME <- NAMES[[kk]]
[10:34:16.822]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.822]                     next
[10:34:16.822]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:16.822]                 }
[10:34:16.822]                 NAMES <- toupper(added)
[10:34:16.822]                 for (kk in seq_along(NAMES)) {
[10:34:16.822]                   name <- added[[kk]]
[10:34:16.822]                   NAME <- NAMES[[kk]]
[10:34:16.822]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.822]                     next
[10:34:16.822]                   args[[name]] <- ""
[10:34:16.822]                 }
[10:34:16.822]                 NAMES <- toupper(removed)
[10:34:16.822]                 for (kk in seq_along(NAMES)) {
[10:34:16.822]                   name <- removed[[kk]]
[10:34:16.822]                   NAME <- NAMES[[kk]]
[10:34:16.822]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.822]                     next
[10:34:16.822]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:16.822]                 }
[10:34:16.822]                 if (length(args) > 0) 
[10:34:16.822]                   base::do.call(base::Sys.setenv, args = args)
[10:34:16.822]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:16.822]             }
[10:34:16.822]             else {
[10:34:16.822]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:16.822]             }
[10:34:16.822]             {
[10:34:16.822]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:16.822]                   0L) {
[10:34:16.822]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:16.822]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:16.822]                   base::options(opts)
[10:34:16.822]                 }
[10:34:16.822]                 {
[10:34:16.822]                   {
[10:34:16.822]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:16.822]                     NULL
[10:34:16.822]                   }
[10:34:16.822]                   options(future.plan = NULL)
[10:34:16.822]                   if (is.na(NA_character_)) 
[10:34:16.822]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:16.822]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:16.822]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:16.822]                     .init = FALSE)
[10:34:16.822]                 }
[10:34:16.822]             }
[10:34:16.822]         }
[10:34:16.822]     })
[10:34:16.822]     if (TRUE) {
[10:34:16.822]         base::sink(type = "output", split = FALSE)
[10:34:16.822]         if (TRUE) {
[10:34:16.822]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:16.822]         }
[10:34:16.822]         else {
[10:34:16.822]             ...future.result["stdout"] <- base::list(NULL)
[10:34:16.822]         }
[10:34:16.822]         base::close(...future.stdout)
[10:34:16.822]         ...future.stdout <- NULL
[10:34:16.822]     }
[10:34:16.822]     ...future.result$conditions <- ...future.conditions
[10:34:16.822]     ...future.result$finished <- base::Sys.time()
[10:34:16.822]     ...future.result
[10:34:16.822] }
[10:34:16.825] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[10:34:16.825] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[10:34:16.825] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[10:34:16.825] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[10:34:16.826] MultisessionFuture started
[10:34:16.826] - Launch lazy future ... done
[10:34:16.826] run() for ‘MultisessionFuture’ ... done
[10:34:16.826] getGlobalsAndPackages() ...
[10:34:16.826] Searching for globals...
[10:34:16.827] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:34:16.827] Searching for globals ... DONE
[10:34:16.827] Resolving globals: FALSE
[10:34:16.828] The total size of the 1 globals is 56 bytes (56 bytes)
[10:34:16.828] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:34:16.828] - globals: [1] ‘kk’
[10:34:16.828] 
[10:34:16.828] getGlobalsAndPackages() ... DONE
[10:34:16.829] run() for ‘Future’ ...
[10:34:16.829] - state: ‘created’
[10:34:16.829] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:16.842] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:16.842] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:16.842]   - Field: ‘node’
[10:34:16.842]   - Field: ‘label’
[10:34:16.843]   - Field: ‘local’
[10:34:16.843]   - Field: ‘owner’
[10:34:16.843]   - Field: ‘envir’
[10:34:16.843]   - Field: ‘workers’
[10:34:16.843]   - Field: ‘packages’
[10:34:16.843]   - Field: ‘gc’
[10:34:16.843]   - Field: ‘conditions’
[10:34:16.843]   - Field: ‘persistent’
[10:34:16.843]   - Field: ‘expr’
[10:34:16.843]   - Field: ‘uuid’
[10:34:16.844]   - Field: ‘seed’
[10:34:16.844]   - Field: ‘version’
[10:34:16.844]   - Field: ‘result’
[10:34:16.844]   - Field: ‘asynchronous’
[10:34:16.844]   - Field: ‘calls’
[10:34:16.844]   - Field: ‘globals’
[10:34:16.844]   - Field: ‘stdout’
[10:34:16.844]   - Field: ‘earlySignal’
[10:34:16.844]   - Field: ‘lazy’
[10:34:16.844]   - Field: ‘state’
[10:34:16.844] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:16.845] - Launch lazy future ...
[10:34:16.845] Packages needed by the future expression (n = 0): <none>
[10:34:16.845] Packages needed by future strategies (n = 0): <none>
[10:34:16.845] {
[10:34:16.845]     {
[10:34:16.845]         {
[10:34:16.845]             ...future.startTime <- base::Sys.time()
[10:34:16.845]             {
[10:34:16.845]                 {
[10:34:16.845]                   {
[10:34:16.845]                     {
[10:34:16.845]                       base::local({
[10:34:16.845]                         has_future <- base::requireNamespace("future", 
[10:34:16.845]                           quietly = TRUE)
[10:34:16.845]                         if (has_future) {
[10:34:16.845]                           ns <- base::getNamespace("future")
[10:34:16.845]                           version <- ns[[".package"]][["version"]]
[10:34:16.845]                           if (is.null(version)) 
[10:34:16.845]                             version <- utils::packageVersion("future")
[10:34:16.845]                         }
[10:34:16.845]                         else {
[10:34:16.845]                           version <- NULL
[10:34:16.845]                         }
[10:34:16.845]                         if (!has_future || version < "1.8.0") {
[10:34:16.845]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:16.845]                             "", base::R.version$version.string), 
[10:34:16.845]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:16.845]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:16.845]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:16.845]                               "release", "version")], collapse = " "), 
[10:34:16.845]                             hostname = base::Sys.info()[["nodename"]])
[10:34:16.845]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:16.845]                             info)
[10:34:16.845]                           info <- base::paste(info, collapse = "; ")
[10:34:16.845]                           if (!has_future) {
[10:34:16.845]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:16.845]                               info)
[10:34:16.845]                           }
[10:34:16.845]                           else {
[10:34:16.845]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:16.845]                               info, version)
[10:34:16.845]                           }
[10:34:16.845]                           base::stop(msg)
[10:34:16.845]                         }
[10:34:16.845]                       })
[10:34:16.845]                     }
[10:34:16.845]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:16.845]                     base::options(mc.cores = 1L)
[10:34:16.845]                   }
[10:34:16.845]                   ...future.strategy.old <- future::plan("list")
[10:34:16.845]                   options(future.plan = NULL)
[10:34:16.845]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:16.845]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:16.845]                 }
[10:34:16.845]                 ...future.workdir <- getwd()
[10:34:16.845]             }
[10:34:16.845]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:16.845]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:16.845]         }
[10:34:16.845]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:16.845]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:16.845]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:16.845]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:16.845]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:16.845]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:16.845]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:16.845]             base::names(...future.oldOptions))
[10:34:16.845]     }
[10:34:16.845]     if (FALSE) {
[10:34:16.845]     }
[10:34:16.845]     else {
[10:34:16.845]         if (TRUE) {
[10:34:16.845]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:16.845]                 open = "w")
[10:34:16.845]         }
[10:34:16.845]         else {
[10:34:16.845]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:16.845]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:16.845]         }
[10:34:16.845]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:16.845]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:16.845]             base::sink(type = "output", split = FALSE)
[10:34:16.845]             base::close(...future.stdout)
[10:34:16.845]         }, add = TRUE)
[10:34:16.845]     }
[10:34:16.845]     ...future.frame <- base::sys.nframe()
[10:34:16.845]     ...future.conditions <- base::list()
[10:34:16.845]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:16.845]     if (FALSE) {
[10:34:16.845]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:16.845]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:16.845]     }
[10:34:16.845]     ...future.result <- base::tryCatch({
[10:34:16.845]         base::withCallingHandlers({
[10:34:16.845]             ...future.value <- base::withVisible(base::local({
[10:34:16.845]                 ...future.makeSendCondition <- base::local({
[10:34:16.845]                   sendCondition <- NULL
[10:34:16.845]                   function(frame = 1L) {
[10:34:16.845]                     if (is.function(sendCondition)) 
[10:34:16.845]                       return(sendCondition)
[10:34:16.845]                     ns <- getNamespace("parallel")
[10:34:16.845]                     if (exists("sendData", mode = "function", 
[10:34:16.845]                       envir = ns)) {
[10:34:16.845]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:16.845]                         envir = ns)
[10:34:16.845]                       envir <- sys.frame(frame)
[10:34:16.845]                       master <- NULL
[10:34:16.845]                       while (!identical(envir, .GlobalEnv) && 
[10:34:16.845]                         !identical(envir, emptyenv())) {
[10:34:16.845]                         if (exists("master", mode = "list", envir = envir, 
[10:34:16.845]                           inherits = FALSE)) {
[10:34:16.845]                           master <- get("master", mode = "list", 
[10:34:16.845]                             envir = envir, inherits = FALSE)
[10:34:16.845]                           if (inherits(master, c("SOCKnode", 
[10:34:16.845]                             "SOCK0node"))) {
[10:34:16.845]                             sendCondition <<- function(cond) {
[10:34:16.845]                               data <- list(type = "VALUE", value = cond, 
[10:34:16.845]                                 success = TRUE)
[10:34:16.845]                               parallel_sendData(master, data)
[10:34:16.845]                             }
[10:34:16.845]                             return(sendCondition)
[10:34:16.845]                           }
[10:34:16.845]                         }
[10:34:16.845]                         frame <- frame + 1L
[10:34:16.845]                         envir <- sys.frame(frame)
[10:34:16.845]                       }
[10:34:16.845]                     }
[10:34:16.845]                     sendCondition <<- function(cond) NULL
[10:34:16.845]                   }
[10:34:16.845]                 })
[10:34:16.845]                 withCallingHandlers({
[10:34:16.845]                   {
[10:34:16.845]                     Sys.sleep(0.1)
[10:34:16.845]                     kk
[10:34:16.845]                   }
[10:34:16.845]                 }, immediateCondition = function(cond) {
[10:34:16.845]                   sendCondition <- ...future.makeSendCondition()
[10:34:16.845]                   sendCondition(cond)
[10:34:16.845]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.845]                   {
[10:34:16.845]                     inherits <- base::inherits
[10:34:16.845]                     invokeRestart <- base::invokeRestart
[10:34:16.845]                     is.null <- base::is.null
[10:34:16.845]                     muffled <- FALSE
[10:34:16.845]                     if (inherits(cond, "message")) {
[10:34:16.845]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:16.845]                       if (muffled) 
[10:34:16.845]                         invokeRestart("muffleMessage")
[10:34:16.845]                     }
[10:34:16.845]                     else if (inherits(cond, "warning")) {
[10:34:16.845]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:16.845]                       if (muffled) 
[10:34:16.845]                         invokeRestart("muffleWarning")
[10:34:16.845]                     }
[10:34:16.845]                     else if (inherits(cond, "condition")) {
[10:34:16.845]                       if (!is.null(pattern)) {
[10:34:16.845]                         computeRestarts <- base::computeRestarts
[10:34:16.845]                         grepl <- base::grepl
[10:34:16.845]                         restarts <- computeRestarts(cond)
[10:34:16.845]                         for (restart in restarts) {
[10:34:16.845]                           name <- restart$name
[10:34:16.845]                           if (is.null(name)) 
[10:34:16.845]                             next
[10:34:16.845]                           if (!grepl(pattern, name)) 
[10:34:16.845]                             next
[10:34:16.845]                           invokeRestart(restart)
[10:34:16.845]                           muffled <- TRUE
[10:34:16.845]                           break
[10:34:16.845]                         }
[10:34:16.845]                       }
[10:34:16.845]                     }
[10:34:16.845]                     invisible(muffled)
[10:34:16.845]                   }
[10:34:16.845]                   muffleCondition(cond)
[10:34:16.845]                 })
[10:34:16.845]             }))
[10:34:16.845]             future::FutureResult(value = ...future.value$value, 
[10:34:16.845]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:16.845]                   ...future.rng), globalenv = if (FALSE) 
[10:34:16.845]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:16.845]                     ...future.globalenv.names))
[10:34:16.845]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:16.845]         }, condition = base::local({
[10:34:16.845]             c <- base::c
[10:34:16.845]             inherits <- base::inherits
[10:34:16.845]             invokeRestart <- base::invokeRestart
[10:34:16.845]             length <- base::length
[10:34:16.845]             list <- base::list
[10:34:16.845]             seq.int <- base::seq.int
[10:34:16.845]             signalCondition <- base::signalCondition
[10:34:16.845]             sys.calls <- base::sys.calls
[10:34:16.845]             `[[` <- base::`[[`
[10:34:16.845]             `+` <- base::`+`
[10:34:16.845]             `<<-` <- base::`<<-`
[10:34:16.845]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:16.845]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:16.845]                   3L)]
[10:34:16.845]             }
[10:34:16.845]             function(cond) {
[10:34:16.845]                 is_error <- inherits(cond, "error")
[10:34:16.845]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:16.845]                   NULL)
[10:34:16.845]                 if (is_error) {
[10:34:16.845]                   sessionInformation <- function() {
[10:34:16.845]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:16.845]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:16.845]                       search = base::search(), system = base::Sys.info())
[10:34:16.845]                   }
[10:34:16.845]                   ...future.conditions[[length(...future.conditions) + 
[10:34:16.845]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:16.845]                     cond$call), session = sessionInformation(), 
[10:34:16.845]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:16.845]                   signalCondition(cond)
[10:34:16.845]                 }
[10:34:16.845]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:16.845]                 "immediateCondition"))) {
[10:34:16.845]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:16.845]                   ...future.conditions[[length(...future.conditions) + 
[10:34:16.845]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:16.845]                   if (TRUE && !signal) {
[10:34:16.845]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.845]                     {
[10:34:16.845]                       inherits <- base::inherits
[10:34:16.845]                       invokeRestart <- base::invokeRestart
[10:34:16.845]                       is.null <- base::is.null
[10:34:16.845]                       muffled <- FALSE
[10:34:16.845]                       if (inherits(cond, "message")) {
[10:34:16.845]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:16.845]                         if (muffled) 
[10:34:16.845]                           invokeRestart("muffleMessage")
[10:34:16.845]                       }
[10:34:16.845]                       else if (inherits(cond, "warning")) {
[10:34:16.845]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:16.845]                         if (muffled) 
[10:34:16.845]                           invokeRestart("muffleWarning")
[10:34:16.845]                       }
[10:34:16.845]                       else if (inherits(cond, "condition")) {
[10:34:16.845]                         if (!is.null(pattern)) {
[10:34:16.845]                           computeRestarts <- base::computeRestarts
[10:34:16.845]                           grepl <- base::grepl
[10:34:16.845]                           restarts <- computeRestarts(cond)
[10:34:16.845]                           for (restart in restarts) {
[10:34:16.845]                             name <- restart$name
[10:34:16.845]                             if (is.null(name)) 
[10:34:16.845]                               next
[10:34:16.845]                             if (!grepl(pattern, name)) 
[10:34:16.845]                               next
[10:34:16.845]                             invokeRestart(restart)
[10:34:16.845]                             muffled <- TRUE
[10:34:16.845]                             break
[10:34:16.845]                           }
[10:34:16.845]                         }
[10:34:16.845]                       }
[10:34:16.845]                       invisible(muffled)
[10:34:16.845]                     }
[10:34:16.845]                     muffleCondition(cond, pattern = "^muffle")
[10:34:16.845]                   }
[10:34:16.845]                 }
[10:34:16.845]                 else {
[10:34:16.845]                   if (TRUE) {
[10:34:16.845]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.845]                     {
[10:34:16.845]                       inherits <- base::inherits
[10:34:16.845]                       invokeRestart <- base::invokeRestart
[10:34:16.845]                       is.null <- base::is.null
[10:34:16.845]                       muffled <- FALSE
[10:34:16.845]                       if (inherits(cond, "message")) {
[10:34:16.845]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:16.845]                         if (muffled) 
[10:34:16.845]                           invokeRestart("muffleMessage")
[10:34:16.845]                       }
[10:34:16.845]                       else if (inherits(cond, "warning")) {
[10:34:16.845]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:16.845]                         if (muffled) 
[10:34:16.845]                           invokeRestart("muffleWarning")
[10:34:16.845]                       }
[10:34:16.845]                       else if (inherits(cond, "condition")) {
[10:34:16.845]                         if (!is.null(pattern)) {
[10:34:16.845]                           computeRestarts <- base::computeRestarts
[10:34:16.845]                           grepl <- base::grepl
[10:34:16.845]                           restarts <- computeRestarts(cond)
[10:34:16.845]                           for (restart in restarts) {
[10:34:16.845]                             name <- restart$name
[10:34:16.845]                             if (is.null(name)) 
[10:34:16.845]                               next
[10:34:16.845]                             if (!grepl(pattern, name)) 
[10:34:16.845]                               next
[10:34:16.845]                             invokeRestart(restart)
[10:34:16.845]                             muffled <- TRUE
[10:34:16.845]                             break
[10:34:16.845]                           }
[10:34:16.845]                         }
[10:34:16.845]                       }
[10:34:16.845]                       invisible(muffled)
[10:34:16.845]                     }
[10:34:16.845]                     muffleCondition(cond, pattern = "^muffle")
[10:34:16.845]                   }
[10:34:16.845]                 }
[10:34:16.845]             }
[10:34:16.845]         }))
[10:34:16.845]     }, error = function(ex) {
[10:34:16.845]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:16.845]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:16.845]                 ...future.rng), started = ...future.startTime, 
[10:34:16.845]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:16.845]             version = "1.8"), class = "FutureResult")
[10:34:16.845]     }, finally = {
[10:34:16.845]         if (!identical(...future.workdir, getwd())) 
[10:34:16.845]             setwd(...future.workdir)
[10:34:16.845]         {
[10:34:16.845]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:16.845]                 ...future.oldOptions$nwarnings <- NULL
[10:34:16.845]             }
[10:34:16.845]             base::options(...future.oldOptions)
[10:34:16.845]             if (.Platform$OS.type == "windows") {
[10:34:16.845]                 old_names <- names(...future.oldEnvVars)
[10:34:16.845]                 envs <- base::Sys.getenv()
[10:34:16.845]                 names <- names(envs)
[10:34:16.845]                 common <- intersect(names, old_names)
[10:34:16.845]                 added <- setdiff(names, old_names)
[10:34:16.845]                 removed <- setdiff(old_names, names)
[10:34:16.845]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:16.845]                   envs[common]]
[10:34:16.845]                 NAMES <- toupper(changed)
[10:34:16.845]                 args <- list()
[10:34:16.845]                 for (kk in seq_along(NAMES)) {
[10:34:16.845]                   name <- changed[[kk]]
[10:34:16.845]                   NAME <- NAMES[[kk]]
[10:34:16.845]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.845]                     next
[10:34:16.845]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:16.845]                 }
[10:34:16.845]                 NAMES <- toupper(added)
[10:34:16.845]                 for (kk in seq_along(NAMES)) {
[10:34:16.845]                   name <- added[[kk]]
[10:34:16.845]                   NAME <- NAMES[[kk]]
[10:34:16.845]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.845]                     next
[10:34:16.845]                   args[[name]] <- ""
[10:34:16.845]                 }
[10:34:16.845]                 NAMES <- toupper(removed)
[10:34:16.845]                 for (kk in seq_along(NAMES)) {
[10:34:16.845]                   name <- removed[[kk]]
[10:34:16.845]                   NAME <- NAMES[[kk]]
[10:34:16.845]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.845]                     next
[10:34:16.845]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:16.845]                 }
[10:34:16.845]                 if (length(args) > 0) 
[10:34:16.845]                   base::do.call(base::Sys.setenv, args = args)
[10:34:16.845]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:16.845]             }
[10:34:16.845]             else {
[10:34:16.845]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:16.845]             }
[10:34:16.845]             {
[10:34:16.845]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:16.845]                   0L) {
[10:34:16.845]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:16.845]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:16.845]                   base::options(opts)
[10:34:16.845]                 }
[10:34:16.845]                 {
[10:34:16.845]                   {
[10:34:16.845]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:16.845]                     NULL
[10:34:16.845]                   }
[10:34:16.845]                   options(future.plan = NULL)
[10:34:16.845]                   if (is.na(NA_character_)) 
[10:34:16.845]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:16.845]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:16.845]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:16.845]                     .init = FALSE)
[10:34:16.845]                 }
[10:34:16.845]             }
[10:34:16.845]         }
[10:34:16.845]     })
[10:34:16.845]     if (TRUE) {
[10:34:16.845]         base::sink(type = "output", split = FALSE)
[10:34:16.845]         if (TRUE) {
[10:34:16.845]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:16.845]         }
[10:34:16.845]         else {
[10:34:16.845]             ...future.result["stdout"] <- base::list(NULL)
[10:34:16.845]         }
[10:34:16.845]         base::close(...future.stdout)
[10:34:16.845]         ...future.stdout <- NULL
[10:34:16.845]     }
[10:34:16.845]     ...future.result$conditions <- ...future.conditions
[10:34:16.845]     ...future.result$finished <- base::Sys.time()
[10:34:16.845]     ...future.result
[10:34:16.845] }
[10:34:16.848] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[10:34:16.848] Exporting ‘kk’ (56 bytes) to cluster node #2 ...
[10:34:16.848] Exporting ‘kk’ (56 bytes) to cluster node #2 ... DONE
[10:34:16.848] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[10:34:16.849] MultisessionFuture started
[10:34:16.849] - Launch lazy future ... done
[10:34:16.849] run() for ‘MultisessionFuture’ ... done
[10:34:16.849] getGlobalsAndPackages() ...
[10:34:16.849] Searching for globals...
[10:34:16.850] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:34:16.850] Searching for globals ... DONE
[10:34:16.850] Resolving globals: FALSE
[10:34:16.851] The total size of the 1 globals is 56 bytes (56 bytes)
[10:34:16.851] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:34:16.851] - globals: [1] ‘kk’
[10:34:16.851] 
[10:34:16.851] getGlobalsAndPackages() ... DONE
[10:34:16.852] run() for ‘Future’ ...
[10:34:16.852] - state: ‘created’
[10:34:16.852] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:16.865] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:16.865] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:16.865]   - Field: ‘node’
[10:34:16.865]   - Field: ‘label’
[10:34:16.866]   - Field: ‘local’
[10:34:16.866]   - Field: ‘owner’
[10:34:16.866]   - Field: ‘envir’
[10:34:16.866]   - Field: ‘workers’
[10:34:16.866]   - Field: ‘packages’
[10:34:16.866]   - Field: ‘gc’
[10:34:16.866]   - Field: ‘conditions’
[10:34:16.866]   - Field: ‘persistent’
[10:34:16.866]   - Field: ‘expr’
[10:34:16.866]   - Field: ‘uuid’
[10:34:16.866]   - Field: ‘seed’
[10:34:16.867]   - Field: ‘version’
[10:34:16.867]   - Field: ‘result’
[10:34:16.867]   - Field: ‘asynchronous’
[10:34:16.867]   - Field: ‘calls’
[10:34:16.867]   - Field: ‘globals’
[10:34:16.867]   - Field: ‘stdout’
[10:34:16.867]   - Field: ‘earlySignal’
[10:34:16.867]   - Field: ‘lazy’
[10:34:16.867]   - Field: ‘state’
[10:34:16.867] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:16.867] - Launch lazy future ...
[10:34:16.868] Packages needed by the future expression (n = 0): <none>
[10:34:16.868] Packages needed by future strategies (n = 0): <none>
[10:34:16.868] {
[10:34:16.868]     {
[10:34:16.868]         {
[10:34:16.868]             ...future.startTime <- base::Sys.time()
[10:34:16.868]             {
[10:34:16.868]                 {
[10:34:16.868]                   {
[10:34:16.868]                     {
[10:34:16.868]                       base::local({
[10:34:16.868]                         has_future <- base::requireNamespace("future", 
[10:34:16.868]                           quietly = TRUE)
[10:34:16.868]                         if (has_future) {
[10:34:16.868]                           ns <- base::getNamespace("future")
[10:34:16.868]                           version <- ns[[".package"]][["version"]]
[10:34:16.868]                           if (is.null(version)) 
[10:34:16.868]                             version <- utils::packageVersion("future")
[10:34:16.868]                         }
[10:34:16.868]                         else {
[10:34:16.868]                           version <- NULL
[10:34:16.868]                         }
[10:34:16.868]                         if (!has_future || version < "1.8.0") {
[10:34:16.868]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:16.868]                             "", base::R.version$version.string), 
[10:34:16.868]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:16.868]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:16.868]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:16.868]                               "release", "version")], collapse = " "), 
[10:34:16.868]                             hostname = base::Sys.info()[["nodename"]])
[10:34:16.868]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:16.868]                             info)
[10:34:16.868]                           info <- base::paste(info, collapse = "; ")
[10:34:16.868]                           if (!has_future) {
[10:34:16.868]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:16.868]                               info)
[10:34:16.868]                           }
[10:34:16.868]                           else {
[10:34:16.868]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:16.868]                               info, version)
[10:34:16.868]                           }
[10:34:16.868]                           base::stop(msg)
[10:34:16.868]                         }
[10:34:16.868]                       })
[10:34:16.868]                     }
[10:34:16.868]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:16.868]                     base::options(mc.cores = 1L)
[10:34:16.868]                   }
[10:34:16.868]                   ...future.strategy.old <- future::plan("list")
[10:34:16.868]                   options(future.plan = NULL)
[10:34:16.868]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:16.868]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:16.868]                 }
[10:34:16.868]                 ...future.workdir <- getwd()
[10:34:16.868]             }
[10:34:16.868]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:16.868]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:16.868]         }
[10:34:16.868]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:16.868]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:16.868]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:16.868]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:16.868]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:16.868]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:16.868]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:16.868]             base::names(...future.oldOptions))
[10:34:16.868]     }
[10:34:16.868]     if (FALSE) {
[10:34:16.868]     }
[10:34:16.868]     else {
[10:34:16.868]         if (TRUE) {
[10:34:16.868]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:16.868]                 open = "w")
[10:34:16.868]         }
[10:34:16.868]         else {
[10:34:16.868]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:16.868]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:16.868]         }
[10:34:16.868]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:16.868]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:16.868]             base::sink(type = "output", split = FALSE)
[10:34:16.868]             base::close(...future.stdout)
[10:34:16.868]         }, add = TRUE)
[10:34:16.868]     }
[10:34:16.868]     ...future.frame <- base::sys.nframe()
[10:34:16.868]     ...future.conditions <- base::list()
[10:34:16.868]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:16.868]     if (FALSE) {
[10:34:16.868]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:16.868]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:16.868]     }
[10:34:16.868]     ...future.result <- base::tryCatch({
[10:34:16.868]         base::withCallingHandlers({
[10:34:16.868]             ...future.value <- base::withVisible(base::local({
[10:34:16.868]                 ...future.makeSendCondition <- base::local({
[10:34:16.868]                   sendCondition <- NULL
[10:34:16.868]                   function(frame = 1L) {
[10:34:16.868]                     if (is.function(sendCondition)) 
[10:34:16.868]                       return(sendCondition)
[10:34:16.868]                     ns <- getNamespace("parallel")
[10:34:16.868]                     if (exists("sendData", mode = "function", 
[10:34:16.868]                       envir = ns)) {
[10:34:16.868]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:16.868]                         envir = ns)
[10:34:16.868]                       envir <- sys.frame(frame)
[10:34:16.868]                       master <- NULL
[10:34:16.868]                       while (!identical(envir, .GlobalEnv) && 
[10:34:16.868]                         !identical(envir, emptyenv())) {
[10:34:16.868]                         if (exists("master", mode = "list", envir = envir, 
[10:34:16.868]                           inherits = FALSE)) {
[10:34:16.868]                           master <- get("master", mode = "list", 
[10:34:16.868]                             envir = envir, inherits = FALSE)
[10:34:16.868]                           if (inherits(master, c("SOCKnode", 
[10:34:16.868]                             "SOCK0node"))) {
[10:34:16.868]                             sendCondition <<- function(cond) {
[10:34:16.868]                               data <- list(type = "VALUE", value = cond, 
[10:34:16.868]                                 success = TRUE)
[10:34:16.868]                               parallel_sendData(master, data)
[10:34:16.868]                             }
[10:34:16.868]                             return(sendCondition)
[10:34:16.868]                           }
[10:34:16.868]                         }
[10:34:16.868]                         frame <- frame + 1L
[10:34:16.868]                         envir <- sys.frame(frame)
[10:34:16.868]                       }
[10:34:16.868]                     }
[10:34:16.868]                     sendCondition <<- function(cond) NULL
[10:34:16.868]                   }
[10:34:16.868]                 })
[10:34:16.868]                 withCallingHandlers({
[10:34:16.868]                   {
[10:34:16.868]                     Sys.sleep(0.1)
[10:34:16.868]                     kk
[10:34:16.868]                   }
[10:34:16.868]                 }, immediateCondition = function(cond) {
[10:34:16.868]                   sendCondition <- ...future.makeSendCondition()
[10:34:16.868]                   sendCondition(cond)
[10:34:16.868]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.868]                   {
[10:34:16.868]                     inherits <- base::inherits
[10:34:16.868]                     invokeRestart <- base::invokeRestart
[10:34:16.868]                     is.null <- base::is.null
[10:34:16.868]                     muffled <- FALSE
[10:34:16.868]                     if (inherits(cond, "message")) {
[10:34:16.868]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:16.868]                       if (muffled) 
[10:34:16.868]                         invokeRestart("muffleMessage")
[10:34:16.868]                     }
[10:34:16.868]                     else if (inherits(cond, "warning")) {
[10:34:16.868]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:16.868]                       if (muffled) 
[10:34:16.868]                         invokeRestart("muffleWarning")
[10:34:16.868]                     }
[10:34:16.868]                     else if (inherits(cond, "condition")) {
[10:34:16.868]                       if (!is.null(pattern)) {
[10:34:16.868]                         computeRestarts <- base::computeRestarts
[10:34:16.868]                         grepl <- base::grepl
[10:34:16.868]                         restarts <- computeRestarts(cond)
[10:34:16.868]                         for (restart in restarts) {
[10:34:16.868]                           name <- restart$name
[10:34:16.868]                           if (is.null(name)) 
[10:34:16.868]                             next
[10:34:16.868]                           if (!grepl(pattern, name)) 
[10:34:16.868]                             next
[10:34:16.868]                           invokeRestart(restart)
[10:34:16.868]                           muffled <- TRUE
[10:34:16.868]                           break
[10:34:16.868]                         }
[10:34:16.868]                       }
[10:34:16.868]                     }
[10:34:16.868]                     invisible(muffled)
[10:34:16.868]                   }
[10:34:16.868]                   muffleCondition(cond)
[10:34:16.868]                 })
[10:34:16.868]             }))
[10:34:16.868]             future::FutureResult(value = ...future.value$value, 
[10:34:16.868]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:16.868]                   ...future.rng), globalenv = if (FALSE) 
[10:34:16.868]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:16.868]                     ...future.globalenv.names))
[10:34:16.868]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:16.868]         }, condition = base::local({
[10:34:16.868]             c <- base::c
[10:34:16.868]             inherits <- base::inherits
[10:34:16.868]             invokeRestart <- base::invokeRestart
[10:34:16.868]             length <- base::length
[10:34:16.868]             list <- base::list
[10:34:16.868]             seq.int <- base::seq.int
[10:34:16.868]             signalCondition <- base::signalCondition
[10:34:16.868]             sys.calls <- base::sys.calls
[10:34:16.868]             `[[` <- base::`[[`
[10:34:16.868]             `+` <- base::`+`
[10:34:16.868]             `<<-` <- base::`<<-`
[10:34:16.868]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:16.868]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:16.868]                   3L)]
[10:34:16.868]             }
[10:34:16.868]             function(cond) {
[10:34:16.868]                 is_error <- inherits(cond, "error")
[10:34:16.868]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:16.868]                   NULL)
[10:34:16.868]                 if (is_error) {
[10:34:16.868]                   sessionInformation <- function() {
[10:34:16.868]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:16.868]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:16.868]                       search = base::search(), system = base::Sys.info())
[10:34:16.868]                   }
[10:34:16.868]                   ...future.conditions[[length(...future.conditions) + 
[10:34:16.868]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:16.868]                     cond$call), session = sessionInformation(), 
[10:34:16.868]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:16.868]                   signalCondition(cond)
[10:34:16.868]                 }
[10:34:16.868]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:16.868]                 "immediateCondition"))) {
[10:34:16.868]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:16.868]                   ...future.conditions[[length(...future.conditions) + 
[10:34:16.868]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:16.868]                   if (TRUE && !signal) {
[10:34:16.868]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.868]                     {
[10:34:16.868]                       inherits <- base::inherits
[10:34:16.868]                       invokeRestart <- base::invokeRestart
[10:34:16.868]                       is.null <- base::is.null
[10:34:16.868]                       muffled <- FALSE
[10:34:16.868]                       if (inherits(cond, "message")) {
[10:34:16.868]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:16.868]                         if (muffled) 
[10:34:16.868]                           invokeRestart("muffleMessage")
[10:34:16.868]                       }
[10:34:16.868]                       else if (inherits(cond, "warning")) {
[10:34:16.868]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:16.868]                         if (muffled) 
[10:34:16.868]                           invokeRestart("muffleWarning")
[10:34:16.868]                       }
[10:34:16.868]                       else if (inherits(cond, "condition")) {
[10:34:16.868]                         if (!is.null(pattern)) {
[10:34:16.868]                           computeRestarts <- base::computeRestarts
[10:34:16.868]                           grepl <- base::grepl
[10:34:16.868]                           restarts <- computeRestarts(cond)
[10:34:16.868]                           for (restart in restarts) {
[10:34:16.868]                             name <- restart$name
[10:34:16.868]                             if (is.null(name)) 
[10:34:16.868]                               next
[10:34:16.868]                             if (!grepl(pattern, name)) 
[10:34:16.868]                               next
[10:34:16.868]                             invokeRestart(restart)
[10:34:16.868]                             muffled <- TRUE
[10:34:16.868]                             break
[10:34:16.868]                           }
[10:34:16.868]                         }
[10:34:16.868]                       }
[10:34:16.868]                       invisible(muffled)
[10:34:16.868]                     }
[10:34:16.868]                     muffleCondition(cond, pattern = "^muffle")
[10:34:16.868]                   }
[10:34:16.868]                 }
[10:34:16.868]                 else {
[10:34:16.868]                   if (TRUE) {
[10:34:16.868]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:16.868]                     {
[10:34:16.868]                       inherits <- base::inherits
[10:34:16.868]                       invokeRestart <- base::invokeRestart
[10:34:16.868]                       is.null <- base::is.null
[10:34:16.868]                       muffled <- FALSE
[10:34:16.868]                       if (inherits(cond, "message")) {
[10:34:16.868]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:16.868]                         if (muffled) 
[10:34:16.868]                           invokeRestart("muffleMessage")
[10:34:16.868]                       }
[10:34:16.868]                       else if (inherits(cond, "warning")) {
[10:34:16.868]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:16.868]                         if (muffled) 
[10:34:16.868]                           invokeRestart("muffleWarning")
[10:34:16.868]                       }
[10:34:16.868]                       else if (inherits(cond, "condition")) {
[10:34:16.868]                         if (!is.null(pattern)) {
[10:34:16.868]                           computeRestarts <- base::computeRestarts
[10:34:16.868]                           grepl <- base::grepl
[10:34:16.868]                           restarts <- computeRestarts(cond)
[10:34:16.868]                           for (restart in restarts) {
[10:34:16.868]                             name <- restart$name
[10:34:16.868]                             if (is.null(name)) 
[10:34:16.868]                               next
[10:34:16.868]                             if (!grepl(pattern, name)) 
[10:34:16.868]                               next
[10:34:16.868]                             invokeRestart(restart)
[10:34:16.868]                             muffled <- TRUE
[10:34:16.868]                             break
[10:34:16.868]                           }
[10:34:16.868]                         }
[10:34:16.868]                       }
[10:34:16.868]                       invisible(muffled)
[10:34:16.868]                     }
[10:34:16.868]                     muffleCondition(cond, pattern = "^muffle")
[10:34:16.868]                   }
[10:34:16.868]                 }
[10:34:16.868]             }
[10:34:16.868]         }))
[10:34:16.868]     }, error = function(ex) {
[10:34:16.868]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:16.868]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:16.868]                 ...future.rng), started = ...future.startTime, 
[10:34:16.868]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:16.868]             version = "1.8"), class = "FutureResult")
[10:34:16.868]     }, finally = {
[10:34:16.868]         if (!identical(...future.workdir, getwd())) 
[10:34:16.868]             setwd(...future.workdir)
[10:34:16.868]         {
[10:34:16.868]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:16.868]                 ...future.oldOptions$nwarnings <- NULL
[10:34:16.868]             }
[10:34:16.868]             base::options(...future.oldOptions)
[10:34:16.868]             if (.Platform$OS.type == "windows") {
[10:34:16.868]                 old_names <- names(...future.oldEnvVars)
[10:34:16.868]                 envs <- base::Sys.getenv()
[10:34:16.868]                 names <- names(envs)
[10:34:16.868]                 common <- intersect(names, old_names)
[10:34:16.868]                 added <- setdiff(names, old_names)
[10:34:16.868]                 removed <- setdiff(old_names, names)
[10:34:16.868]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:16.868]                   envs[common]]
[10:34:16.868]                 NAMES <- toupper(changed)
[10:34:16.868]                 args <- list()
[10:34:16.868]                 for (kk in seq_along(NAMES)) {
[10:34:16.868]                   name <- changed[[kk]]
[10:34:16.868]                   NAME <- NAMES[[kk]]
[10:34:16.868]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.868]                     next
[10:34:16.868]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:16.868]                 }
[10:34:16.868]                 NAMES <- toupper(added)
[10:34:16.868]                 for (kk in seq_along(NAMES)) {
[10:34:16.868]                   name <- added[[kk]]
[10:34:16.868]                   NAME <- NAMES[[kk]]
[10:34:16.868]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.868]                     next
[10:34:16.868]                   args[[name]] <- ""
[10:34:16.868]                 }
[10:34:16.868]                 NAMES <- toupper(removed)
[10:34:16.868]                 for (kk in seq_along(NAMES)) {
[10:34:16.868]                   name <- removed[[kk]]
[10:34:16.868]                   NAME <- NAMES[[kk]]
[10:34:16.868]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:16.868]                     next
[10:34:16.868]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:16.868]                 }
[10:34:16.868]                 if (length(args) > 0) 
[10:34:16.868]                   base::do.call(base::Sys.setenv, args = args)
[10:34:16.868]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:16.868]             }
[10:34:16.868]             else {
[10:34:16.868]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:16.868]             }
[10:34:16.868]             {
[10:34:16.868]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:16.868]                   0L) {
[10:34:16.868]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:16.868]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:16.868]                   base::options(opts)
[10:34:16.868]                 }
[10:34:16.868]                 {
[10:34:16.868]                   {
[10:34:16.868]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:16.868]                     NULL
[10:34:16.868]                   }
[10:34:16.868]                   options(future.plan = NULL)
[10:34:16.868]                   if (is.na(NA_character_)) 
[10:34:16.868]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:16.868]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:16.868]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:16.868]                     .init = FALSE)
[10:34:16.868]                 }
[10:34:16.868]             }
[10:34:16.868]         }
[10:34:16.868]     })
[10:34:16.868]     if (TRUE) {
[10:34:16.868]         base::sink(type = "output", split = FALSE)
[10:34:16.868]         if (TRUE) {
[10:34:16.868]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:16.868]         }
[10:34:16.868]         else {
[10:34:16.868]             ...future.result["stdout"] <- base::list(NULL)
[10:34:16.868]         }
[10:34:16.868]         base::close(...future.stdout)
[10:34:16.868]         ...future.stdout <- NULL
[10:34:16.868]     }
[10:34:16.868]     ...future.result$conditions <- ...future.conditions
[10:34:16.868]     ...future.result$finished <- base::Sys.time()
[10:34:16.868]     ...future.result
[10:34:16.868] }
[10:34:16.870] Poll #1 (0): usedNodes() = 2, workers = 2
[10:34:16.902] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[10:34:16.933] Poll #3 (0.06 secs): usedNodes() = 2, workers = 2
[10:34:16.944] receiveMessageFromWorker() for ClusterFuture ...
[10:34:16.944] - Validating connection of MultisessionFuture
[10:34:16.944] - received message: FutureResult
[10:34:16.944] - Received FutureResult
[10:34:16.944] - Erased future from FutureRegistry
[10:34:16.945] result() for ClusterFuture ...
[10:34:16.945] - result already collected: FutureResult
[10:34:16.945] result() for ClusterFuture ... done
[10:34:16.945] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:16.945] result() for ClusterFuture ...
[10:34:16.945] - result already collected: FutureResult
[10:34:16.945] result() for ClusterFuture ... done
[10:34:16.945] result() for ClusterFuture ...
[10:34:16.945] - result already collected: FutureResult
[10:34:16.945] result() for ClusterFuture ... done
[10:34:16.946] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[10:34:16.946] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[10:34:16.947] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[10:34:16.947] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[10:34:16.947] MultisessionFuture started
[10:34:16.947] - Launch lazy future ... done
[10:34:16.947] run() for ‘MultisessionFuture’ ... done
[10:34:16.947] resolve() on list ...
[10:34:16.947]  recursive: 0
[10:34:16.948]  length: 3
[10:34:16.948] 
[10:34:16.948] Future #1
[10:34:16.948]  length: 2 (resolved future 1)
[10:34:16.951] receiveMessageFromWorker() for ClusterFuture ...
[10:34:16.951] - Validating connection of MultisessionFuture
[10:34:16.951] - received message: FutureResult
[10:34:16.951] - Received FutureResult
[10:34:16.951] - Erased future from FutureRegistry
[10:34:16.952] result() for ClusterFuture ...
[10:34:16.952] - result already collected: FutureResult
[10:34:16.952] result() for ClusterFuture ... done
[10:34:16.952] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:16.952] Future #2
[10:34:16.952]  length: 1 (resolved future 2)
[10:34:17.055] receiveMessageFromWorker() for ClusterFuture ...
[10:34:17.055] - Validating connection of MultisessionFuture
[10:34:17.056] - received message: FutureResult
[10:34:17.056] - Received FutureResult
[10:34:17.056] - Erased future from FutureRegistry
[10:34:17.056] result() for ClusterFuture ...
[10:34:17.056] - result already collected: FutureResult
[10:34:17.056] result() for ClusterFuture ... done
[10:34:17.056] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:17.056] Future #3
[10:34:17.056]  length: 0 (resolved future 3)
[10:34:17.056] resolve() on list ... DONE
[10:34:17.057] getGlobalsAndPackages() ...
[10:34:17.057] Searching for globals...
[10:34:17.058] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:34:17.058] Searching for globals ... DONE
[10:34:17.058] Resolving globals: FALSE
[10:34:17.058] The total size of the 1 globals is 56 bytes (56 bytes)
[10:34:17.059] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:34:17.059] - globals: [1] ‘kk’
[10:34:17.059] 
[10:34:17.059] getGlobalsAndPackages() ... DONE
[10:34:17.059] getGlobalsAndPackages() ...
[10:34:17.059] Searching for globals...
[10:34:17.063] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:34:17.064] Searching for globals ... DONE
[10:34:17.064] Resolving globals: FALSE
[10:34:17.064] The total size of the 1 globals is 56 bytes (56 bytes)
[10:34:17.064] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:34:17.065] - globals: [1] ‘kk’
[10:34:17.065] 
[10:34:17.065] getGlobalsAndPackages() ... DONE
[10:34:17.065] getGlobalsAndPackages() ...
[10:34:17.065] Searching for globals...
[10:34:17.066] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:34:17.066] Searching for globals ... DONE
[10:34:17.066] Resolving globals: FALSE
[10:34:17.067] The total size of the 1 globals is 56 bytes (56 bytes)
[10:34:17.067] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:34:17.067] - globals: [1] ‘kk’
[10:34:17.067] 
[10:34:17.067] getGlobalsAndPackages() ... DONE
[10:34:17.068] resolve() on list ...
[10:34:17.068]  recursive: 0
[10:34:17.068]  length: 3
[10:34:17.068] 
[10:34:17.068] run() for ‘Future’ ...
[10:34:17.068] - state: ‘created’
[10:34:17.068] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:17.082] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:17.082] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:17.083]   - Field: ‘node’
[10:34:17.083]   - Field: ‘label’
[10:34:17.083]   - Field: ‘local’
[10:34:17.083]   - Field: ‘owner’
[10:34:17.083]   - Field: ‘envir’
[10:34:17.083]   - Field: ‘workers’
[10:34:17.083]   - Field: ‘packages’
[10:34:17.083]   - Field: ‘gc’
[10:34:17.083]   - Field: ‘conditions’
[10:34:17.083]   - Field: ‘persistent’
[10:34:17.084]   - Field: ‘expr’
[10:34:17.084]   - Field: ‘uuid’
[10:34:17.084]   - Field: ‘seed’
[10:34:17.084]   - Field: ‘version’
[10:34:17.084]   - Field: ‘result’
[10:34:17.084]   - Field: ‘asynchronous’
[10:34:17.084]   - Field: ‘calls’
[10:34:17.084]   - Field: ‘globals’
[10:34:17.084]   - Field: ‘stdout’
[10:34:17.084]   - Field: ‘earlySignal’
[10:34:17.084]   - Field: ‘lazy’
[10:34:17.084]   - Field: ‘state’
[10:34:17.085] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:17.085] - Launch lazy future ...
[10:34:17.085] Packages needed by the future expression (n = 0): <none>
[10:34:17.085] Packages needed by future strategies (n = 0): <none>
[10:34:17.086] {
[10:34:17.086]     {
[10:34:17.086]         {
[10:34:17.086]             ...future.startTime <- base::Sys.time()
[10:34:17.086]             {
[10:34:17.086]                 {
[10:34:17.086]                   {
[10:34:17.086]                     {
[10:34:17.086]                       base::local({
[10:34:17.086]                         has_future <- base::requireNamespace("future", 
[10:34:17.086]                           quietly = TRUE)
[10:34:17.086]                         if (has_future) {
[10:34:17.086]                           ns <- base::getNamespace("future")
[10:34:17.086]                           version <- ns[[".package"]][["version"]]
[10:34:17.086]                           if (is.null(version)) 
[10:34:17.086]                             version <- utils::packageVersion("future")
[10:34:17.086]                         }
[10:34:17.086]                         else {
[10:34:17.086]                           version <- NULL
[10:34:17.086]                         }
[10:34:17.086]                         if (!has_future || version < "1.8.0") {
[10:34:17.086]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:17.086]                             "", base::R.version$version.string), 
[10:34:17.086]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:17.086]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:17.086]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:17.086]                               "release", "version")], collapse = " "), 
[10:34:17.086]                             hostname = base::Sys.info()[["nodename"]])
[10:34:17.086]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:17.086]                             info)
[10:34:17.086]                           info <- base::paste(info, collapse = "; ")
[10:34:17.086]                           if (!has_future) {
[10:34:17.086]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:17.086]                               info)
[10:34:17.086]                           }
[10:34:17.086]                           else {
[10:34:17.086]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:17.086]                               info, version)
[10:34:17.086]                           }
[10:34:17.086]                           base::stop(msg)
[10:34:17.086]                         }
[10:34:17.086]                       })
[10:34:17.086]                     }
[10:34:17.086]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:17.086]                     base::options(mc.cores = 1L)
[10:34:17.086]                   }
[10:34:17.086]                   ...future.strategy.old <- future::plan("list")
[10:34:17.086]                   options(future.plan = NULL)
[10:34:17.086]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.086]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:17.086]                 }
[10:34:17.086]                 ...future.workdir <- getwd()
[10:34:17.086]             }
[10:34:17.086]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:17.086]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:17.086]         }
[10:34:17.086]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:17.086]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:17.086]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:17.086]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:17.086]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:17.086]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:17.086]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:17.086]             base::names(...future.oldOptions))
[10:34:17.086]     }
[10:34:17.086]     if (FALSE) {
[10:34:17.086]     }
[10:34:17.086]     else {
[10:34:17.086]         if (TRUE) {
[10:34:17.086]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:17.086]                 open = "w")
[10:34:17.086]         }
[10:34:17.086]         else {
[10:34:17.086]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:17.086]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:17.086]         }
[10:34:17.086]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:17.086]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:17.086]             base::sink(type = "output", split = FALSE)
[10:34:17.086]             base::close(...future.stdout)
[10:34:17.086]         }, add = TRUE)
[10:34:17.086]     }
[10:34:17.086]     ...future.frame <- base::sys.nframe()
[10:34:17.086]     ...future.conditions <- base::list()
[10:34:17.086]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:17.086]     if (FALSE) {
[10:34:17.086]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:17.086]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:17.086]     }
[10:34:17.086]     ...future.result <- base::tryCatch({
[10:34:17.086]         base::withCallingHandlers({
[10:34:17.086]             ...future.value <- base::withVisible(base::local({
[10:34:17.086]                 ...future.makeSendCondition <- base::local({
[10:34:17.086]                   sendCondition <- NULL
[10:34:17.086]                   function(frame = 1L) {
[10:34:17.086]                     if (is.function(sendCondition)) 
[10:34:17.086]                       return(sendCondition)
[10:34:17.086]                     ns <- getNamespace("parallel")
[10:34:17.086]                     if (exists("sendData", mode = "function", 
[10:34:17.086]                       envir = ns)) {
[10:34:17.086]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:17.086]                         envir = ns)
[10:34:17.086]                       envir <- sys.frame(frame)
[10:34:17.086]                       master <- NULL
[10:34:17.086]                       while (!identical(envir, .GlobalEnv) && 
[10:34:17.086]                         !identical(envir, emptyenv())) {
[10:34:17.086]                         if (exists("master", mode = "list", envir = envir, 
[10:34:17.086]                           inherits = FALSE)) {
[10:34:17.086]                           master <- get("master", mode = "list", 
[10:34:17.086]                             envir = envir, inherits = FALSE)
[10:34:17.086]                           if (inherits(master, c("SOCKnode", 
[10:34:17.086]                             "SOCK0node"))) {
[10:34:17.086]                             sendCondition <<- function(cond) {
[10:34:17.086]                               data <- list(type = "VALUE", value = cond, 
[10:34:17.086]                                 success = TRUE)
[10:34:17.086]                               parallel_sendData(master, data)
[10:34:17.086]                             }
[10:34:17.086]                             return(sendCondition)
[10:34:17.086]                           }
[10:34:17.086]                         }
[10:34:17.086]                         frame <- frame + 1L
[10:34:17.086]                         envir <- sys.frame(frame)
[10:34:17.086]                       }
[10:34:17.086]                     }
[10:34:17.086]                     sendCondition <<- function(cond) NULL
[10:34:17.086]                   }
[10:34:17.086]                 })
[10:34:17.086]                 withCallingHandlers({
[10:34:17.086]                   {
[10:34:17.086]                     Sys.sleep(0.1)
[10:34:17.086]                     kk
[10:34:17.086]                   }
[10:34:17.086]                 }, immediateCondition = function(cond) {
[10:34:17.086]                   sendCondition <- ...future.makeSendCondition()
[10:34:17.086]                   sendCondition(cond)
[10:34:17.086]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.086]                   {
[10:34:17.086]                     inherits <- base::inherits
[10:34:17.086]                     invokeRestart <- base::invokeRestart
[10:34:17.086]                     is.null <- base::is.null
[10:34:17.086]                     muffled <- FALSE
[10:34:17.086]                     if (inherits(cond, "message")) {
[10:34:17.086]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:17.086]                       if (muffled) 
[10:34:17.086]                         invokeRestart("muffleMessage")
[10:34:17.086]                     }
[10:34:17.086]                     else if (inherits(cond, "warning")) {
[10:34:17.086]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:17.086]                       if (muffled) 
[10:34:17.086]                         invokeRestart("muffleWarning")
[10:34:17.086]                     }
[10:34:17.086]                     else if (inherits(cond, "condition")) {
[10:34:17.086]                       if (!is.null(pattern)) {
[10:34:17.086]                         computeRestarts <- base::computeRestarts
[10:34:17.086]                         grepl <- base::grepl
[10:34:17.086]                         restarts <- computeRestarts(cond)
[10:34:17.086]                         for (restart in restarts) {
[10:34:17.086]                           name <- restart$name
[10:34:17.086]                           if (is.null(name)) 
[10:34:17.086]                             next
[10:34:17.086]                           if (!grepl(pattern, name)) 
[10:34:17.086]                             next
[10:34:17.086]                           invokeRestart(restart)
[10:34:17.086]                           muffled <- TRUE
[10:34:17.086]                           break
[10:34:17.086]                         }
[10:34:17.086]                       }
[10:34:17.086]                     }
[10:34:17.086]                     invisible(muffled)
[10:34:17.086]                   }
[10:34:17.086]                   muffleCondition(cond)
[10:34:17.086]                 })
[10:34:17.086]             }))
[10:34:17.086]             future::FutureResult(value = ...future.value$value, 
[10:34:17.086]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.086]                   ...future.rng), globalenv = if (FALSE) 
[10:34:17.086]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:17.086]                     ...future.globalenv.names))
[10:34:17.086]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:17.086]         }, condition = base::local({
[10:34:17.086]             c <- base::c
[10:34:17.086]             inherits <- base::inherits
[10:34:17.086]             invokeRestart <- base::invokeRestart
[10:34:17.086]             length <- base::length
[10:34:17.086]             list <- base::list
[10:34:17.086]             seq.int <- base::seq.int
[10:34:17.086]             signalCondition <- base::signalCondition
[10:34:17.086]             sys.calls <- base::sys.calls
[10:34:17.086]             `[[` <- base::`[[`
[10:34:17.086]             `+` <- base::`+`
[10:34:17.086]             `<<-` <- base::`<<-`
[10:34:17.086]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:17.086]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:17.086]                   3L)]
[10:34:17.086]             }
[10:34:17.086]             function(cond) {
[10:34:17.086]                 is_error <- inherits(cond, "error")
[10:34:17.086]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:17.086]                   NULL)
[10:34:17.086]                 if (is_error) {
[10:34:17.086]                   sessionInformation <- function() {
[10:34:17.086]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:17.086]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:17.086]                       search = base::search(), system = base::Sys.info())
[10:34:17.086]                   }
[10:34:17.086]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.086]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:17.086]                     cond$call), session = sessionInformation(), 
[10:34:17.086]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:17.086]                   signalCondition(cond)
[10:34:17.086]                 }
[10:34:17.086]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:17.086]                 "immediateCondition"))) {
[10:34:17.086]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:17.086]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.086]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:17.086]                   if (TRUE && !signal) {
[10:34:17.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.086]                     {
[10:34:17.086]                       inherits <- base::inherits
[10:34:17.086]                       invokeRestart <- base::invokeRestart
[10:34:17.086]                       is.null <- base::is.null
[10:34:17.086]                       muffled <- FALSE
[10:34:17.086]                       if (inherits(cond, "message")) {
[10:34:17.086]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.086]                         if (muffled) 
[10:34:17.086]                           invokeRestart("muffleMessage")
[10:34:17.086]                       }
[10:34:17.086]                       else if (inherits(cond, "warning")) {
[10:34:17.086]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.086]                         if (muffled) 
[10:34:17.086]                           invokeRestart("muffleWarning")
[10:34:17.086]                       }
[10:34:17.086]                       else if (inherits(cond, "condition")) {
[10:34:17.086]                         if (!is.null(pattern)) {
[10:34:17.086]                           computeRestarts <- base::computeRestarts
[10:34:17.086]                           grepl <- base::grepl
[10:34:17.086]                           restarts <- computeRestarts(cond)
[10:34:17.086]                           for (restart in restarts) {
[10:34:17.086]                             name <- restart$name
[10:34:17.086]                             if (is.null(name)) 
[10:34:17.086]                               next
[10:34:17.086]                             if (!grepl(pattern, name)) 
[10:34:17.086]                               next
[10:34:17.086]                             invokeRestart(restart)
[10:34:17.086]                             muffled <- TRUE
[10:34:17.086]                             break
[10:34:17.086]                           }
[10:34:17.086]                         }
[10:34:17.086]                       }
[10:34:17.086]                       invisible(muffled)
[10:34:17.086]                     }
[10:34:17.086]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.086]                   }
[10:34:17.086]                 }
[10:34:17.086]                 else {
[10:34:17.086]                   if (TRUE) {
[10:34:17.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.086]                     {
[10:34:17.086]                       inherits <- base::inherits
[10:34:17.086]                       invokeRestart <- base::invokeRestart
[10:34:17.086]                       is.null <- base::is.null
[10:34:17.086]                       muffled <- FALSE
[10:34:17.086]                       if (inherits(cond, "message")) {
[10:34:17.086]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.086]                         if (muffled) 
[10:34:17.086]                           invokeRestart("muffleMessage")
[10:34:17.086]                       }
[10:34:17.086]                       else if (inherits(cond, "warning")) {
[10:34:17.086]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.086]                         if (muffled) 
[10:34:17.086]                           invokeRestart("muffleWarning")
[10:34:17.086]                       }
[10:34:17.086]                       else if (inherits(cond, "condition")) {
[10:34:17.086]                         if (!is.null(pattern)) {
[10:34:17.086]                           computeRestarts <- base::computeRestarts
[10:34:17.086]                           grepl <- base::grepl
[10:34:17.086]                           restarts <- computeRestarts(cond)
[10:34:17.086]                           for (restart in restarts) {
[10:34:17.086]                             name <- restart$name
[10:34:17.086]                             if (is.null(name)) 
[10:34:17.086]                               next
[10:34:17.086]                             if (!grepl(pattern, name)) 
[10:34:17.086]                               next
[10:34:17.086]                             invokeRestart(restart)
[10:34:17.086]                             muffled <- TRUE
[10:34:17.086]                             break
[10:34:17.086]                           }
[10:34:17.086]                         }
[10:34:17.086]                       }
[10:34:17.086]                       invisible(muffled)
[10:34:17.086]                     }
[10:34:17.086]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.086]                   }
[10:34:17.086]                 }
[10:34:17.086]             }
[10:34:17.086]         }))
[10:34:17.086]     }, error = function(ex) {
[10:34:17.086]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:17.086]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.086]                 ...future.rng), started = ...future.startTime, 
[10:34:17.086]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:17.086]             version = "1.8"), class = "FutureResult")
[10:34:17.086]     }, finally = {
[10:34:17.086]         if (!identical(...future.workdir, getwd())) 
[10:34:17.086]             setwd(...future.workdir)
[10:34:17.086]         {
[10:34:17.086]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:17.086]                 ...future.oldOptions$nwarnings <- NULL
[10:34:17.086]             }
[10:34:17.086]             base::options(...future.oldOptions)
[10:34:17.086]             if (.Platform$OS.type == "windows") {
[10:34:17.086]                 old_names <- names(...future.oldEnvVars)
[10:34:17.086]                 envs <- base::Sys.getenv()
[10:34:17.086]                 names <- names(envs)
[10:34:17.086]                 common <- intersect(names, old_names)
[10:34:17.086]                 added <- setdiff(names, old_names)
[10:34:17.086]                 removed <- setdiff(old_names, names)
[10:34:17.086]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:17.086]                   envs[common]]
[10:34:17.086]                 NAMES <- toupper(changed)
[10:34:17.086]                 args <- list()
[10:34:17.086]                 for (kk in seq_along(NAMES)) {
[10:34:17.086]                   name <- changed[[kk]]
[10:34:17.086]                   NAME <- NAMES[[kk]]
[10:34:17.086]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.086]                     next
[10:34:17.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.086]                 }
[10:34:17.086]                 NAMES <- toupper(added)
[10:34:17.086]                 for (kk in seq_along(NAMES)) {
[10:34:17.086]                   name <- added[[kk]]
[10:34:17.086]                   NAME <- NAMES[[kk]]
[10:34:17.086]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.086]                     next
[10:34:17.086]                   args[[name]] <- ""
[10:34:17.086]                 }
[10:34:17.086]                 NAMES <- toupper(removed)
[10:34:17.086]                 for (kk in seq_along(NAMES)) {
[10:34:17.086]                   name <- removed[[kk]]
[10:34:17.086]                   NAME <- NAMES[[kk]]
[10:34:17.086]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.086]                     next
[10:34:17.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.086]                 }
[10:34:17.086]                 if (length(args) > 0) 
[10:34:17.086]                   base::do.call(base::Sys.setenv, args = args)
[10:34:17.086]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:17.086]             }
[10:34:17.086]             else {
[10:34:17.086]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:17.086]             }
[10:34:17.086]             {
[10:34:17.086]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:17.086]                   0L) {
[10:34:17.086]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:17.086]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:17.086]                   base::options(opts)
[10:34:17.086]                 }
[10:34:17.086]                 {
[10:34:17.086]                   {
[10:34:17.086]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:17.086]                     NULL
[10:34:17.086]                   }
[10:34:17.086]                   options(future.plan = NULL)
[10:34:17.086]                   if (is.na(NA_character_)) 
[10:34:17.086]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.086]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:17.086]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:17.086]                     .init = FALSE)
[10:34:17.086]                 }
[10:34:17.086]             }
[10:34:17.086]         }
[10:34:17.086]     })
[10:34:17.086]     if (TRUE) {
[10:34:17.086]         base::sink(type = "output", split = FALSE)
[10:34:17.086]         if (TRUE) {
[10:34:17.086]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:17.086]         }
[10:34:17.086]         else {
[10:34:17.086]             ...future.result["stdout"] <- base::list(NULL)
[10:34:17.086]         }
[10:34:17.086]         base::close(...future.stdout)
[10:34:17.086]         ...future.stdout <- NULL
[10:34:17.086]     }
[10:34:17.086]     ...future.result$conditions <- ...future.conditions
[10:34:17.086]     ...future.result$finished <- base::Sys.time()
[10:34:17.086]     ...future.result
[10:34:17.086] }
[10:34:17.088] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[10:34:17.088] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[10:34:17.089] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[10:34:17.089] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[10:34:17.089] MultisessionFuture started
[10:34:17.089] - Launch lazy future ... done
[10:34:17.089] run() for ‘MultisessionFuture’ ... done
[10:34:17.100] run() for ‘Future’ ...
[10:34:17.100] - state: ‘created’
[10:34:17.100] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:17.114] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:17.114] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:17.114]   - Field: ‘node’
[10:34:17.114]   - Field: ‘label’
[10:34:17.115]   - Field: ‘local’
[10:34:17.115]   - Field: ‘owner’
[10:34:17.115]   - Field: ‘envir’
[10:34:17.115]   - Field: ‘workers’
[10:34:17.115]   - Field: ‘packages’
[10:34:17.115]   - Field: ‘gc’
[10:34:17.115]   - Field: ‘conditions’
[10:34:17.115]   - Field: ‘persistent’
[10:34:17.115]   - Field: ‘expr’
[10:34:17.115]   - Field: ‘uuid’
[10:34:17.115]   - Field: ‘seed’
[10:34:17.116]   - Field: ‘version’
[10:34:17.116]   - Field: ‘result’
[10:34:17.116]   - Field: ‘asynchronous’
[10:34:17.116]   - Field: ‘calls’
[10:34:17.116]   - Field: ‘globals’
[10:34:17.116]   - Field: ‘stdout’
[10:34:17.116]   - Field: ‘earlySignal’
[10:34:17.116]   - Field: ‘lazy’
[10:34:17.116]   - Field: ‘state’
[10:34:17.116] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:17.116] - Launch lazy future ...
[10:34:17.117] Packages needed by the future expression (n = 0): <none>
[10:34:17.117] Packages needed by future strategies (n = 0): <none>
[10:34:17.117] {
[10:34:17.117]     {
[10:34:17.117]         {
[10:34:17.117]             ...future.startTime <- base::Sys.time()
[10:34:17.117]             {
[10:34:17.117]                 {
[10:34:17.117]                   {
[10:34:17.117]                     {
[10:34:17.117]                       base::local({
[10:34:17.117]                         has_future <- base::requireNamespace("future", 
[10:34:17.117]                           quietly = TRUE)
[10:34:17.117]                         if (has_future) {
[10:34:17.117]                           ns <- base::getNamespace("future")
[10:34:17.117]                           version <- ns[[".package"]][["version"]]
[10:34:17.117]                           if (is.null(version)) 
[10:34:17.117]                             version <- utils::packageVersion("future")
[10:34:17.117]                         }
[10:34:17.117]                         else {
[10:34:17.117]                           version <- NULL
[10:34:17.117]                         }
[10:34:17.117]                         if (!has_future || version < "1.8.0") {
[10:34:17.117]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:17.117]                             "", base::R.version$version.string), 
[10:34:17.117]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:17.117]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:17.117]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:17.117]                               "release", "version")], collapse = " "), 
[10:34:17.117]                             hostname = base::Sys.info()[["nodename"]])
[10:34:17.117]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:17.117]                             info)
[10:34:17.117]                           info <- base::paste(info, collapse = "; ")
[10:34:17.117]                           if (!has_future) {
[10:34:17.117]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:17.117]                               info)
[10:34:17.117]                           }
[10:34:17.117]                           else {
[10:34:17.117]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:17.117]                               info, version)
[10:34:17.117]                           }
[10:34:17.117]                           base::stop(msg)
[10:34:17.117]                         }
[10:34:17.117]                       })
[10:34:17.117]                     }
[10:34:17.117]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:17.117]                     base::options(mc.cores = 1L)
[10:34:17.117]                   }
[10:34:17.117]                   ...future.strategy.old <- future::plan("list")
[10:34:17.117]                   options(future.plan = NULL)
[10:34:17.117]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.117]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:17.117]                 }
[10:34:17.117]                 ...future.workdir <- getwd()
[10:34:17.117]             }
[10:34:17.117]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:17.117]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:17.117]         }
[10:34:17.117]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:17.117]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:17.117]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:17.117]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:17.117]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:17.117]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:17.117]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:17.117]             base::names(...future.oldOptions))
[10:34:17.117]     }
[10:34:17.117]     if (FALSE) {
[10:34:17.117]     }
[10:34:17.117]     else {
[10:34:17.117]         if (TRUE) {
[10:34:17.117]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:17.117]                 open = "w")
[10:34:17.117]         }
[10:34:17.117]         else {
[10:34:17.117]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:17.117]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:17.117]         }
[10:34:17.117]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:17.117]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:17.117]             base::sink(type = "output", split = FALSE)
[10:34:17.117]             base::close(...future.stdout)
[10:34:17.117]         }, add = TRUE)
[10:34:17.117]     }
[10:34:17.117]     ...future.frame <- base::sys.nframe()
[10:34:17.117]     ...future.conditions <- base::list()
[10:34:17.117]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:17.117]     if (FALSE) {
[10:34:17.117]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:17.117]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:17.117]     }
[10:34:17.117]     ...future.result <- base::tryCatch({
[10:34:17.117]         base::withCallingHandlers({
[10:34:17.117]             ...future.value <- base::withVisible(base::local({
[10:34:17.117]                 ...future.makeSendCondition <- base::local({
[10:34:17.117]                   sendCondition <- NULL
[10:34:17.117]                   function(frame = 1L) {
[10:34:17.117]                     if (is.function(sendCondition)) 
[10:34:17.117]                       return(sendCondition)
[10:34:17.117]                     ns <- getNamespace("parallel")
[10:34:17.117]                     if (exists("sendData", mode = "function", 
[10:34:17.117]                       envir = ns)) {
[10:34:17.117]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:17.117]                         envir = ns)
[10:34:17.117]                       envir <- sys.frame(frame)
[10:34:17.117]                       master <- NULL
[10:34:17.117]                       while (!identical(envir, .GlobalEnv) && 
[10:34:17.117]                         !identical(envir, emptyenv())) {
[10:34:17.117]                         if (exists("master", mode = "list", envir = envir, 
[10:34:17.117]                           inherits = FALSE)) {
[10:34:17.117]                           master <- get("master", mode = "list", 
[10:34:17.117]                             envir = envir, inherits = FALSE)
[10:34:17.117]                           if (inherits(master, c("SOCKnode", 
[10:34:17.117]                             "SOCK0node"))) {
[10:34:17.117]                             sendCondition <<- function(cond) {
[10:34:17.117]                               data <- list(type = "VALUE", value = cond, 
[10:34:17.117]                                 success = TRUE)
[10:34:17.117]                               parallel_sendData(master, data)
[10:34:17.117]                             }
[10:34:17.117]                             return(sendCondition)
[10:34:17.117]                           }
[10:34:17.117]                         }
[10:34:17.117]                         frame <- frame + 1L
[10:34:17.117]                         envir <- sys.frame(frame)
[10:34:17.117]                       }
[10:34:17.117]                     }
[10:34:17.117]                     sendCondition <<- function(cond) NULL
[10:34:17.117]                   }
[10:34:17.117]                 })
[10:34:17.117]                 withCallingHandlers({
[10:34:17.117]                   {
[10:34:17.117]                     Sys.sleep(0.1)
[10:34:17.117]                     kk
[10:34:17.117]                   }
[10:34:17.117]                 }, immediateCondition = function(cond) {
[10:34:17.117]                   sendCondition <- ...future.makeSendCondition()
[10:34:17.117]                   sendCondition(cond)
[10:34:17.117]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.117]                   {
[10:34:17.117]                     inherits <- base::inherits
[10:34:17.117]                     invokeRestart <- base::invokeRestart
[10:34:17.117]                     is.null <- base::is.null
[10:34:17.117]                     muffled <- FALSE
[10:34:17.117]                     if (inherits(cond, "message")) {
[10:34:17.117]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:17.117]                       if (muffled) 
[10:34:17.117]                         invokeRestart("muffleMessage")
[10:34:17.117]                     }
[10:34:17.117]                     else if (inherits(cond, "warning")) {
[10:34:17.117]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:17.117]                       if (muffled) 
[10:34:17.117]                         invokeRestart("muffleWarning")
[10:34:17.117]                     }
[10:34:17.117]                     else if (inherits(cond, "condition")) {
[10:34:17.117]                       if (!is.null(pattern)) {
[10:34:17.117]                         computeRestarts <- base::computeRestarts
[10:34:17.117]                         grepl <- base::grepl
[10:34:17.117]                         restarts <- computeRestarts(cond)
[10:34:17.117]                         for (restart in restarts) {
[10:34:17.117]                           name <- restart$name
[10:34:17.117]                           if (is.null(name)) 
[10:34:17.117]                             next
[10:34:17.117]                           if (!grepl(pattern, name)) 
[10:34:17.117]                             next
[10:34:17.117]                           invokeRestart(restart)
[10:34:17.117]                           muffled <- TRUE
[10:34:17.117]                           break
[10:34:17.117]                         }
[10:34:17.117]                       }
[10:34:17.117]                     }
[10:34:17.117]                     invisible(muffled)
[10:34:17.117]                   }
[10:34:17.117]                   muffleCondition(cond)
[10:34:17.117]                 })
[10:34:17.117]             }))
[10:34:17.117]             future::FutureResult(value = ...future.value$value, 
[10:34:17.117]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.117]                   ...future.rng), globalenv = if (FALSE) 
[10:34:17.117]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:17.117]                     ...future.globalenv.names))
[10:34:17.117]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:17.117]         }, condition = base::local({
[10:34:17.117]             c <- base::c
[10:34:17.117]             inherits <- base::inherits
[10:34:17.117]             invokeRestart <- base::invokeRestart
[10:34:17.117]             length <- base::length
[10:34:17.117]             list <- base::list
[10:34:17.117]             seq.int <- base::seq.int
[10:34:17.117]             signalCondition <- base::signalCondition
[10:34:17.117]             sys.calls <- base::sys.calls
[10:34:17.117]             `[[` <- base::`[[`
[10:34:17.117]             `+` <- base::`+`
[10:34:17.117]             `<<-` <- base::`<<-`
[10:34:17.117]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:17.117]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:17.117]                   3L)]
[10:34:17.117]             }
[10:34:17.117]             function(cond) {
[10:34:17.117]                 is_error <- inherits(cond, "error")
[10:34:17.117]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:17.117]                   NULL)
[10:34:17.117]                 if (is_error) {
[10:34:17.117]                   sessionInformation <- function() {
[10:34:17.117]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:17.117]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:17.117]                       search = base::search(), system = base::Sys.info())
[10:34:17.117]                   }
[10:34:17.117]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.117]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:17.117]                     cond$call), session = sessionInformation(), 
[10:34:17.117]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:17.117]                   signalCondition(cond)
[10:34:17.117]                 }
[10:34:17.117]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:17.117]                 "immediateCondition"))) {
[10:34:17.117]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:17.117]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.117]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:17.117]                   if (TRUE && !signal) {
[10:34:17.117]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.117]                     {
[10:34:17.117]                       inherits <- base::inherits
[10:34:17.117]                       invokeRestart <- base::invokeRestart
[10:34:17.117]                       is.null <- base::is.null
[10:34:17.117]                       muffled <- FALSE
[10:34:17.117]                       if (inherits(cond, "message")) {
[10:34:17.117]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.117]                         if (muffled) 
[10:34:17.117]                           invokeRestart("muffleMessage")
[10:34:17.117]                       }
[10:34:17.117]                       else if (inherits(cond, "warning")) {
[10:34:17.117]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.117]                         if (muffled) 
[10:34:17.117]                           invokeRestart("muffleWarning")
[10:34:17.117]                       }
[10:34:17.117]                       else if (inherits(cond, "condition")) {
[10:34:17.117]                         if (!is.null(pattern)) {
[10:34:17.117]                           computeRestarts <- base::computeRestarts
[10:34:17.117]                           grepl <- base::grepl
[10:34:17.117]                           restarts <- computeRestarts(cond)
[10:34:17.117]                           for (restart in restarts) {
[10:34:17.117]                             name <- restart$name
[10:34:17.117]                             if (is.null(name)) 
[10:34:17.117]                               next
[10:34:17.117]                             if (!grepl(pattern, name)) 
[10:34:17.117]                               next
[10:34:17.117]                             invokeRestart(restart)
[10:34:17.117]                             muffled <- TRUE
[10:34:17.117]                             break
[10:34:17.117]                           }
[10:34:17.117]                         }
[10:34:17.117]                       }
[10:34:17.117]                       invisible(muffled)
[10:34:17.117]                     }
[10:34:17.117]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.117]                   }
[10:34:17.117]                 }
[10:34:17.117]                 else {
[10:34:17.117]                   if (TRUE) {
[10:34:17.117]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.117]                     {
[10:34:17.117]                       inherits <- base::inherits
[10:34:17.117]                       invokeRestart <- base::invokeRestart
[10:34:17.117]                       is.null <- base::is.null
[10:34:17.117]                       muffled <- FALSE
[10:34:17.117]                       if (inherits(cond, "message")) {
[10:34:17.117]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.117]                         if (muffled) 
[10:34:17.117]                           invokeRestart("muffleMessage")
[10:34:17.117]                       }
[10:34:17.117]                       else if (inherits(cond, "warning")) {
[10:34:17.117]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.117]                         if (muffled) 
[10:34:17.117]                           invokeRestart("muffleWarning")
[10:34:17.117]                       }
[10:34:17.117]                       else if (inherits(cond, "condition")) {
[10:34:17.117]                         if (!is.null(pattern)) {
[10:34:17.117]                           computeRestarts <- base::computeRestarts
[10:34:17.117]                           grepl <- base::grepl
[10:34:17.117]                           restarts <- computeRestarts(cond)
[10:34:17.117]                           for (restart in restarts) {
[10:34:17.117]                             name <- restart$name
[10:34:17.117]                             if (is.null(name)) 
[10:34:17.117]                               next
[10:34:17.117]                             if (!grepl(pattern, name)) 
[10:34:17.117]                               next
[10:34:17.117]                             invokeRestart(restart)
[10:34:17.117]                             muffled <- TRUE
[10:34:17.117]                             break
[10:34:17.117]                           }
[10:34:17.117]                         }
[10:34:17.117]                       }
[10:34:17.117]                       invisible(muffled)
[10:34:17.117]                     }
[10:34:17.117]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.117]                   }
[10:34:17.117]                 }
[10:34:17.117]             }
[10:34:17.117]         }))
[10:34:17.117]     }, error = function(ex) {
[10:34:17.117]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:17.117]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.117]                 ...future.rng), started = ...future.startTime, 
[10:34:17.117]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:17.117]             version = "1.8"), class = "FutureResult")
[10:34:17.117]     }, finally = {
[10:34:17.117]         if (!identical(...future.workdir, getwd())) 
[10:34:17.117]             setwd(...future.workdir)
[10:34:17.117]         {
[10:34:17.117]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:17.117]                 ...future.oldOptions$nwarnings <- NULL
[10:34:17.117]             }
[10:34:17.117]             base::options(...future.oldOptions)
[10:34:17.117]             if (.Platform$OS.type == "windows") {
[10:34:17.117]                 old_names <- names(...future.oldEnvVars)
[10:34:17.117]                 envs <- base::Sys.getenv()
[10:34:17.117]                 names <- names(envs)
[10:34:17.117]                 common <- intersect(names, old_names)
[10:34:17.117]                 added <- setdiff(names, old_names)
[10:34:17.117]                 removed <- setdiff(old_names, names)
[10:34:17.117]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:17.117]                   envs[common]]
[10:34:17.117]                 NAMES <- toupper(changed)
[10:34:17.117]                 args <- list()
[10:34:17.117]                 for (kk in seq_along(NAMES)) {
[10:34:17.117]                   name <- changed[[kk]]
[10:34:17.117]                   NAME <- NAMES[[kk]]
[10:34:17.117]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.117]                     next
[10:34:17.117]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.117]                 }
[10:34:17.117]                 NAMES <- toupper(added)
[10:34:17.117]                 for (kk in seq_along(NAMES)) {
[10:34:17.117]                   name <- added[[kk]]
[10:34:17.117]                   NAME <- NAMES[[kk]]
[10:34:17.117]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.117]                     next
[10:34:17.117]                   args[[name]] <- ""
[10:34:17.117]                 }
[10:34:17.117]                 NAMES <- toupper(removed)
[10:34:17.117]                 for (kk in seq_along(NAMES)) {
[10:34:17.117]                   name <- removed[[kk]]
[10:34:17.117]                   NAME <- NAMES[[kk]]
[10:34:17.117]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.117]                     next
[10:34:17.117]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.117]                 }
[10:34:17.117]                 if (length(args) > 0) 
[10:34:17.117]                   base::do.call(base::Sys.setenv, args = args)
[10:34:17.117]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:17.117]             }
[10:34:17.117]             else {
[10:34:17.117]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:17.117]             }
[10:34:17.117]             {
[10:34:17.117]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:17.117]                   0L) {
[10:34:17.117]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:17.117]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:17.117]                   base::options(opts)
[10:34:17.117]                 }
[10:34:17.117]                 {
[10:34:17.117]                   {
[10:34:17.117]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:17.117]                     NULL
[10:34:17.117]                   }
[10:34:17.117]                   options(future.plan = NULL)
[10:34:17.117]                   if (is.na(NA_character_)) 
[10:34:17.117]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.117]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:17.117]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:17.117]                     .init = FALSE)
[10:34:17.117]                 }
[10:34:17.117]             }
[10:34:17.117]         }
[10:34:17.117]     })
[10:34:17.117]     if (TRUE) {
[10:34:17.117]         base::sink(type = "output", split = FALSE)
[10:34:17.117]         if (TRUE) {
[10:34:17.117]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:17.117]         }
[10:34:17.117]         else {
[10:34:17.117]             ...future.result["stdout"] <- base::list(NULL)
[10:34:17.117]         }
[10:34:17.117]         base::close(...future.stdout)
[10:34:17.117]         ...future.stdout <- NULL
[10:34:17.117]     }
[10:34:17.117]     ...future.result$conditions <- ...future.conditions
[10:34:17.117]     ...future.result$finished <- base::Sys.time()
[10:34:17.117]     ...future.result
[10:34:17.117] }
[10:34:17.120] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[10:34:17.120] Exporting ‘kk’ (56 bytes) to cluster node #2 ...
[10:34:17.120] Exporting ‘kk’ (56 bytes) to cluster node #2 ... DONE
[10:34:17.120] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[10:34:17.121] MultisessionFuture started
[10:34:17.121] - Launch lazy future ... done
[10:34:17.121] run() for ‘MultisessionFuture’ ... done
[10:34:17.132] run() for ‘Future’ ...
[10:34:17.132] - state: ‘created’
[10:34:17.132] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:17.147] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:17.147] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:17.147]   - Field: ‘node’
[10:34:17.147]   - Field: ‘label’
[10:34:17.147]   - Field: ‘local’
[10:34:17.147]   - Field: ‘owner’
[10:34:17.147]   - Field: ‘envir’
[10:34:17.147]   - Field: ‘workers’
[10:34:17.147]   - Field: ‘packages’
[10:34:17.147]   - Field: ‘gc’
[10:34:17.148]   - Field: ‘conditions’
[10:34:17.148]   - Field: ‘persistent’
[10:34:17.148]   - Field: ‘expr’
[10:34:17.148]   - Field: ‘uuid’
[10:34:17.148]   - Field: ‘seed’
[10:34:17.148]   - Field: ‘version’
[10:34:17.148]   - Field: ‘result’
[10:34:17.148]   - Field: ‘asynchronous’
[10:34:17.148]   - Field: ‘calls’
[10:34:17.148]   - Field: ‘globals’
[10:34:17.148]   - Field: ‘stdout’
[10:34:17.149]   - Field: ‘earlySignal’
[10:34:17.149]   - Field: ‘lazy’
[10:34:17.149]   - Field: ‘state’
[10:34:17.149] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:17.149] - Launch lazy future ...
[10:34:17.149] Packages needed by the future expression (n = 0): <none>
[10:34:17.149] Packages needed by future strategies (n = 0): <none>
[10:34:17.150] {
[10:34:17.150]     {
[10:34:17.150]         {
[10:34:17.150]             ...future.startTime <- base::Sys.time()
[10:34:17.150]             {
[10:34:17.150]                 {
[10:34:17.150]                   {
[10:34:17.150]                     {
[10:34:17.150]                       base::local({
[10:34:17.150]                         has_future <- base::requireNamespace("future", 
[10:34:17.150]                           quietly = TRUE)
[10:34:17.150]                         if (has_future) {
[10:34:17.150]                           ns <- base::getNamespace("future")
[10:34:17.150]                           version <- ns[[".package"]][["version"]]
[10:34:17.150]                           if (is.null(version)) 
[10:34:17.150]                             version <- utils::packageVersion("future")
[10:34:17.150]                         }
[10:34:17.150]                         else {
[10:34:17.150]                           version <- NULL
[10:34:17.150]                         }
[10:34:17.150]                         if (!has_future || version < "1.8.0") {
[10:34:17.150]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:17.150]                             "", base::R.version$version.string), 
[10:34:17.150]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:17.150]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:17.150]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:17.150]                               "release", "version")], collapse = " "), 
[10:34:17.150]                             hostname = base::Sys.info()[["nodename"]])
[10:34:17.150]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:17.150]                             info)
[10:34:17.150]                           info <- base::paste(info, collapse = "; ")
[10:34:17.150]                           if (!has_future) {
[10:34:17.150]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:17.150]                               info)
[10:34:17.150]                           }
[10:34:17.150]                           else {
[10:34:17.150]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:17.150]                               info, version)
[10:34:17.150]                           }
[10:34:17.150]                           base::stop(msg)
[10:34:17.150]                         }
[10:34:17.150]                       })
[10:34:17.150]                     }
[10:34:17.150]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:17.150]                     base::options(mc.cores = 1L)
[10:34:17.150]                   }
[10:34:17.150]                   ...future.strategy.old <- future::plan("list")
[10:34:17.150]                   options(future.plan = NULL)
[10:34:17.150]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.150]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:17.150]                 }
[10:34:17.150]                 ...future.workdir <- getwd()
[10:34:17.150]             }
[10:34:17.150]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:17.150]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:17.150]         }
[10:34:17.150]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:17.150]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:17.150]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:17.150]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:17.150]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:17.150]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:17.150]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:17.150]             base::names(...future.oldOptions))
[10:34:17.150]     }
[10:34:17.150]     if (FALSE) {
[10:34:17.150]     }
[10:34:17.150]     else {
[10:34:17.150]         if (TRUE) {
[10:34:17.150]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:17.150]                 open = "w")
[10:34:17.150]         }
[10:34:17.150]         else {
[10:34:17.150]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:17.150]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:17.150]         }
[10:34:17.150]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:17.150]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:17.150]             base::sink(type = "output", split = FALSE)
[10:34:17.150]             base::close(...future.stdout)
[10:34:17.150]         }, add = TRUE)
[10:34:17.150]     }
[10:34:17.150]     ...future.frame <- base::sys.nframe()
[10:34:17.150]     ...future.conditions <- base::list()
[10:34:17.150]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:17.150]     if (FALSE) {
[10:34:17.150]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:17.150]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:17.150]     }
[10:34:17.150]     ...future.result <- base::tryCatch({
[10:34:17.150]         base::withCallingHandlers({
[10:34:17.150]             ...future.value <- base::withVisible(base::local({
[10:34:17.150]                 ...future.makeSendCondition <- base::local({
[10:34:17.150]                   sendCondition <- NULL
[10:34:17.150]                   function(frame = 1L) {
[10:34:17.150]                     if (is.function(sendCondition)) 
[10:34:17.150]                       return(sendCondition)
[10:34:17.150]                     ns <- getNamespace("parallel")
[10:34:17.150]                     if (exists("sendData", mode = "function", 
[10:34:17.150]                       envir = ns)) {
[10:34:17.150]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:17.150]                         envir = ns)
[10:34:17.150]                       envir <- sys.frame(frame)
[10:34:17.150]                       master <- NULL
[10:34:17.150]                       while (!identical(envir, .GlobalEnv) && 
[10:34:17.150]                         !identical(envir, emptyenv())) {
[10:34:17.150]                         if (exists("master", mode = "list", envir = envir, 
[10:34:17.150]                           inherits = FALSE)) {
[10:34:17.150]                           master <- get("master", mode = "list", 
[10:34:17.150]                             envir = envir, inherits = FALSE)
[10:34:17.150]                           if (inherits(master, c("SOCKnode", 
[10:34:17.150]                             "SOCK0node"))) {
[10:34:17.150]                             sendCondition <<- function(cond) {
[10:34:17.150]                               data <- list(type = "VALUE", value = cond, 
[10:34:17.150]                                 success = TRUE)
[10:34:17.150]                               parallel_sendData(master, data)
[10:34:17.150]                             }
[10:34:17.150]                             return(sendCondition)
[10:34:17.150]                           }
[10:34:17.150]                         }
[10:34:17.150]                         frame <- frame + 1L
[10:34:17.150]                         envir <- sys.frame(frame)
[10:34:17.150]                       }
[10:34:17.150]                     }
[10:34:17.150]                     sendCondition <<- function(cond) NULL
[10:34:17.150]                   }
[10:34:17.150]                 })
[10:34:17.150]                 withCallingHandlers({
[10:34:17.150]                   {
[10:34:17.150]                     Sys.sleep(0.1)
[10:34:17.150]                     kk
[10:34:17.150]                   }
[10:34:17.150]                 }, immediateCondition = function(cond) {
[10:34:17.150]                   sendCondition <- ...future.makeSendCondition()
[10:34:17.150]                   sendCondition(cond)
[10:34:17.150]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.150]                   {
[10:34:17.150]                     inherits <- base::inherits
[10:34:17.150]                     invokeRestart <- base::invokeRestart
[10:34:17.150]                     is.null <- base::is.null
[10:34:17.150]                     muffled <- FALSE
[10:34:17.150]                     if (inherits(cond, "message")) {
[10:34:17.150]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:17.150]                       if (muffled) 
[10:34:17.150]                         invokeRestart("muffleMessage")
[10:34:17.150]                     }
[10:34:17.150]                     else if (inherits(cond, "warning")) {
[10:34:17.150]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:17.150]                       if (muffled) 
[10:34:17.150]                         invokeRestart("muffleWarning")
[10:34:17.150]                     }
[10:34:17.150]                     else if (inherits(cond, "condition")) {
[10:34:17.150]                       if (!is.null(pattern)) {
[10:34:17.150]                         computeRestarts <- base::computeRestarts
[10:34:17.150]                         grepl <- base::grepl
[10:34:17.150]                         restarts <- computeRestarts(cond)
[10:34:17.150]                         for (restart in restarts) {
[10:34:17.150]                           name <- restart$name
[10:34:17.150]                           if (is.null(name)) 
[10:34:17.150]                             next
[10:34:17.150]                           if (!grepl(pattern, name)) 
[10:34:17.150]                             next
[10:34:17.150]                           invokeRestart(restart)
[10:34:17.150]                           muffled <- TRUE
[10:34:17.150]                           break
[10:34:17.150]                         }
[10:34:17.150]                       }
[10:34:17.150]                     }
[10:34:17.150]                     invisible(muffled)
[10:34:17.150]                   }
[10:34:17.150]                   muffleCondition(cond)
[10:34:17.150]                 })
[10:34:17.150]             }))
[10:34:17.150]             future::FutureResult(value = ...future.value$value, 
[10:34:17.150]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.150]                   ...future.rng), globalenv = if (FALSE) 
[10:34:17.150]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:17.150]                     ...future.globalenv.names))
[10:34:17.150]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:17.150]         }, condition = base::local({
[10:34:17.150]             c <- base::c
[10:34:17.150]             inherits <- base::inherits
[10:34:17.150]             invokeRestart <- base::invokeRestart
[10:34:17.150]             length <- base::length
[10:34:17.150]             list <- base::list
[10:34:17.150]             seq.int <- base::seq.int
[10:34:17.150]             signalCondition <- base::signalCondition
[10:34:17.150]             sys.calls <- base::sys.calls
[10:34:17.150]             `[[` <- base::`[[`
[10:34:17.150]             `+` <- base::`+`
[10:34:17.150]             `<<-` <- base::`<<-`
[10:34:17.150]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:17.150]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:17.150]                   3L)]
[10:34:17.150]             }
[10:34:17.150]             function(cond) {
[10:34:17.150]                 is_error <- inherits(cond, "error")
[10:34:17.150]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:17.150]                   NULL)
[10:34:17.150]                 if (is_error) {
[10:34:17.150]                   sessionInformation <- function() {
[10:34:17.150]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:17.150]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:17.150]                       search = base::search(), system = base::Sys.info())
[10:34:17.150]                   }
[10:34:17.150]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.150]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:17.150]                     cond$call), session = sessionInformation(), 
[10:34:17.150]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:17.150]                   signalCondition(cond)
[10:34:17.150]                 }
[10:34:17.150]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:17.150]                 "immediateCondition"))) {
[10:34:17.150]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:17.150]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.150]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:17.150]                   if (TRUE && !signal) {
[10:34:17.150]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.150]                     {
[10:34:17.150]                       inherits <- base::inherits
[10:34:17.150]                       invokeRestart <- base::invokeRestart
[10:34:17.150]                       is.null <- base::is.null
[10:34:17.150]                       muffled <- FALSE
[10:34:17.150]                       if (inherits(cond, "message")) {
[10:34:17.150]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.150]                         if (muffled) 
[10:34:17.150]                           invokeRestart("muffleMessage")
[10:34:17.150]                       }
[10:34:17.150]                       else if (inherits(cond, "warning")) {
[10:34:17.150]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.150]                         if (muffled) 
[10:34:17.150]                           invokeRestart("muffleWarning")
[10:34:17.150]                       }
[10:34:17.150]                       else if (inherits(cond, "condition")) {
[10:34:17.150]                         if (!is.null(pattern)) {
[10:34:17.150]                           computeRestarts <- base::computeRestarts
[10:34:17.150]                           grepl <- base::grepl
[10:34:17.150]                           restarts <- computeRestarts(cond)
[10:34:17.150]                           for (restart in restarts) {
[10:34:17.150]                             name <- restart$name
[10:34:17.150]                             if (is.null(name)) 
[10:34:17.150]                               next
[10:34:17.150]                             if (!grepl(pattern, name)) 
[10:34:17.150]                               next
[10:34:17.150]                             invokeRestart(restart)
[10:34:17.150]                             muffled <- TRUE
[10:34:17.150]                             break
[10:34:17.150]                           }
[10:34:17.150]                         }
[10:34:17.150]                       }
[10:34:17.150]                       invisible(muffled)
[10:34:17.150]                     }
[10:34:17.150]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.150]                   }
[10:34:17.150]                 }
[10:34:17.150]                 else {
[10:34:17.150]                   if (TRUE) {
[10:34:17.150]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.150]                     {
[10:34:17.150]                       inherits <- base::inherits
[10:34:17.150]                       invokeRestart <- base::invokeRestart
[10:34:17.150]                       is.null <- base::is.null
[10:34:17.150]                       muffled <- FALSE
[10:34:17.150]                       if (inherits(cond, "message")) {
[10:34:17.150]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.150]                         if (muffled) 
[10:34:17.150]                           invokeRestart("muffleMessage")
[10:34:17.150]                       }
[10:34:17.150]                       else if (inherits(cond, "warning")) {
[10:34:17.150]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.150]                         if (muffled) 
[10:34:17.150]                           invokeRestart("muffleWarning")
[10:34:17.150]                       }
[10:34:17.150]                       else if (inherits(cond, "condition")) {
[10:34:17.150]                         if (!is.null(pattern)) {
[10:34:17.150]                           computeRestarts <- base::computeRestarts
[10:34:17.150]                           grepl <- base::grepl
[10:34:17.150]                           restarts <- computeRestarts(cond)
[10:34:17.150]                           for (restart in restarts) {
[10:34:17.150]                             name <- restart$name
[10:34:17.150]                             if (is.null(name)) 
[10:34:17.150]                               next
[10:34:17.150]                             if (!grepl(pattern, name)) 
[10:34:17.150]                               next
[10:34:17.150]                             invokeRestart(restart)
[10:34:17.150]                             muffled <- TRUE
[10:34:17.150]                             break
[10:34:17.150]                           }
[10:34:17.150]                         }
[10:34:17.150]                       }
[10:34:17.150]                       invisible(muffled)
[10:34:17.150]                     }
[10:34:17.150]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.150]                   }
[10:34:17.150]                 }
[10:34:17.150]             }
[10:34:17.150]         }))
[10:34:17.150]     }, error = function(ex) {
[10:34:17.150]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:17.150]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.150]                 ...future.rng), started = ...future.startTime, 
[10:34:17.150]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:17.150]             version = "1.8"), class = "FutureResult")
[10:34:17.150]     }, finally = {
[10:34:17.150]         if (!identical(...future.workdir, getwd())) 
[10:34:17.150]             setwd(...future.workdir)
[10:34:17.150]         {
[10:34:17.150]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:17.150]                 ...future.oldOptions$nwarnings <- NULL
[10:34:17.150]             }
[10:34:17.150]             base::options(...future.oldOptions)
[10:34:17.150]             if (.Platform$OS.type == "windows") {
[10:34:17.150]                 old_names <- names(...future.oldEnvVars)
[10:34:17.150]                 envs <- base::Sys.getenv()
[10:34:17.150]                 names <- names(envs)
[10:34:17.150]                 common <- intersect(names, old_names)
[10:34:17.150]                 added <- setdiff(names, old_names)
[10:34:17.150]                 removed <- setdiff(old_names, names)
[10:34:17.150]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:17.150]                   envs[common]]
[10:34:17.150]                 NAMES <- toupper(changed)
[10:34:17.150]                 args <- list()
[10:34:17.150]                 for (kk in seq_along(NAMES)) {
[10:34:17.150]                   name <- changed[[kk]]
[10:34:17.150]                   NAME <- NAMES[[kk]]
[10:34:17.150]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.150]                     next
[10:34:17.150]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.150]                 }
[10:34:17.150]                 NAMES <- toupper(added)
[10:34:17.150]                 for (kk in seq_along(NAMES)) {
[10:34:17.150]                   name <- added[[kk]]
[10:34:17.150]                   NAME <- NAMES[[kk]]
[10:34:17.150]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.150]                     next
[10:34:17.150]                   args[[name]] <- ""
[10:34:17.150]                 }
[10:34:17.150]                 NAMES <- toupper(removed)
[10:34:17.150]                 for (kk in seq_along(NAMES)) {
[10:34:17.150]                   name <- removed[[kk]]
[10:34:17.150]                   NAME <- NAMES[[kk]]
[10:34:17.150]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.150]                     next
[10:34:17.150]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.150]                 }
[10:34:17.150]                 if (length(args) > 0) 
[10:34:17.150]                   base::do.call(base::Sys.setenv, args = args)
[10:34:17.150]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:17.150]             }
[10:34:17.150]             else {
[10:34:17.150]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:17.150]             }
[10:34:17.150]             {
[10:34:17.150]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:17.150]                   0L) {
[10:34:17.150]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:17.150]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:17.150]                   base::options(opts)
[10:34:17.150]                 }
[10:34:17.150]                 {
[10:34:17.150]                   {
[10:34:17.150]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:17.150]                     NULL
[10:34:17.150]                   }
[10:34:17.150]                   options(future.plan = NULL)
[10:34:17.150]                   if (is.na(NA_character_)) 
[10:34:17.150]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.150]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:17.150]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:17.150]                     .init = FALSE)
[10:34:17.150]                 }
[10:34:17.150]             }
[10:34:17.150]         }
[10:34:17.150]     })
[10:34:17.150]     if (TRUE) {
[10:34:17.150]         base::sink(type = "output", split = FALSE)
[10:34:17.150]         if (TRUE) {
[10:34:17.150]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:17.150]         }
[10:34:17.150]         else {
[10:34:17.150]             ...future.result["stdout"] <- base::list(NULL)
[10:34:17.150]         }
[10:34:17.150]         base::close(...future.stdout)
[10:34:17.150]         ...future.stdout <- NULL
[10:34:17.150]     }
[10:34:17.150]     ...future.result$conditions <- ...future.conditions
[10:34:17.150]     ...future.result$finished <- base::Sys.time()
[10:34:17.150]     ...future.result
[10:34:17.150] }
[10:34:17.152] Poll #1 (0): usedNodes() = 2, workers = 2
[10:34:17.183] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[10:34:17.194] receiveMessageFromWorker() for ClusterFuture ...
[10:34:17.194] - Validating connection of MultisessionFuture
[10:34:17.194] - received message: FutureResult
[10:34:17.194] - Received FutureResult
[10:34:17.195] - Erased future from FutureRegistry
[10:34:17.195] result() for ClusterFuture ...
[10:34:17.195] - result already collected: FutureResult
[10:34:17.195] result() for ClusterFuture ... done
[10:34:17.195] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:17.195] result() for ClusterFuture ...
[10:34:17.195] - result already collected: FutureResult
[10:34:17.195] result() for ClusterFuture ... done
[10:34:17.195] result() for ClusterFuture ...
[10:34:17.195] - result already collected: FutureResult
[10:34:17.195] result() for ClusterFuture ... done
[10:34:17.196] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[10:34:17.196] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[10:34:17.197] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[10:34:17.197] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[10:34:17.197] MultisessionFuture started
[10:34:17.197] - Launch lazy future ... done
[10:34:17.197] run() for ‘MultisessionFuture’ ... done
[10:34:17.218] Future #1
[10:34:17.218]  length: 2 (resolved future 1)
[10:34:17.223] receiveMessageFromWorker() for ClusterFuture ...
[10:34:17.223] - Validating connection of MultisessionFuture
[10:34:17.223] - received message: FutureResult
[10:34:17.223] - Received FutureResult
[10:34:17.224] - Erased future from FutureRegistry
[10:34:17.224] result() for ClusterFuture ...
[10:34:17.224] - result already collected: FutureResult
[10:34:17.224] result() for ClusterFuture ... done
[10:34:17.224] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:17.224] Future #2
[10:34:17.224]  length: 1 (resolved future 2)
[10:34:17.307] receiveMessageFromWorker() for ClusterFuture ...
[10:34:17.307] - Validating connection of MultisessionFuture
[10:34:17.307] - received message: FutureResult
[10:34:17.307] - Received FutureResult
[10:34:17.307] - Erased future from FutureRegistry
[10:34:17.307] result() for ClusterFuture ...
[10:34:17.307] - result already collected: FutureResult
[10:34:17.307] result() for ClusterFuture ... done
[10:34:17.308] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:17.308] Future #3
[10:34:17.308]  length: 0 (resolved future 3)
[10:34:17.308] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[10:34:17.308] resolve() on environment ...
[10:34:17.308]  recursive: 0
[10:34:17.309]  elements: [2] ‘a’, ‘b’
[10:34:17.309]  length: 1 (resolved future 1)
[10:34:17.309]  length: 0 (resolved future 2)
[10:34:17.309] resolve() on environment ... DONE
[10:34:17.310] getGlobalsAndPackages() ...
[10:34:17.310] Searching for globals...
[10:34:17.310] 
[10:34:17.310] Searching for globals ... DONE
[10:34:17.310] - globals: [0] <none>
[10:34:17.310] getGlobalsAndPackages() ... DONE
[10:34:17.311] run() for ‘Future’ ...
[10:34:17.311] - state: ‘created’
[10:34:17.311] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:17.325] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:17.325] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:17.325]   - Field: ‘node’
[10:34:17.325]   - Field: ‘label’
[10:34:17.325]   - Field: ‘local’
[10:34:17.325]   - Field: ‘owner’
[10:34:17.325]   - Field: ‘envir’
[10:34:17.326]   - Field: ‘workers’
[10:34:17.326]   - Field: ‘packages’
[10:34:17.326]   - Field: ‘gc’
[10:34:17.326]   - Field: ‘conditions’
[10:34:17.326]   - Field: ‘persistent’
[10:34:17.326]   - Field: ‘expr’
[10:34:17.326]   - Field: ‘uuid’
[10:34:17.326]   - Field: ‘seed’
[10:34:17.326]   - Field: ‘version’
[10:34:17.326]   - Field: ‘result’
[10:34:17.326]   - Field: ‘asynchronous’
[10:34:17.327]   - Field: ‘calls’
[10:34:17.327]   - Field: ‘globals’
[10:34:17.327]   - Field: ‘stdout’
[10:34:17.327]   - Field: ‘earlySignal’
[10:34:17.327]   - Field: ‘lazy’
[10:34:17.327]   - Field: ‘state’
[10:34:17.327] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:17.327] - Launch lazy future ...
[10:34:17.327] Packages needed by the future expression (n = 0): <none>
[10:34:17.328] Packages needed by future strategies (n = 0): <none>
[10:34:17.328] {
[10:34:17.328]     {
[10:34:17.328]         {
[10:34:17.328]             ...future.startTime <- base::Sys.time()
[10:34:17.328]             {
[10:34:17.328]                 {
[10:34:17.328]                   {
[10:34:17.328]                     {
[10:34:17.328]                       base::local({
[10:34:17.328]                         has_future <- base::requireNamespace("future", 
[10:34:17.328]                           quietly = TRUE)
[10:34:17.328]                         if (has_future) {
[10:34:17.328]                           ns <- base::getNamespace("future")
[10:34:17.328]                           version <- ns[[".package"]][["version"]]
[10:34:17.328]                           if (is.null(version)) 
[10:34:17.328]                             version <- utils::packageVersion("future")
[10:34:17.328]                         }
[10:34:17.328]                         else {
[10:34:17.328]                           version <- NULL
[10:34:17.328]                         }
[10:34:17.328]                         if (!has_future || version < "1.8.0") {
[10:34:17.328]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:17.328]                             "", base::R.version$version.string), 
[10:34:17.328]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:17.328]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:17.328]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:17.328]                               "release", "version")], collapse = " "), 
[10:34:17.328]                             hostname = base::Sys.info()[["nodename"]])
[10:34:17.328]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:17.328]                             info)
[10:34:17.328]                           info <- base::paste(info, collapse = "; ")
[10:34:17.328]                           if (!has_future) {
[10:34:17.328]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:17.328]                               info)
[10:34:17.328]                           }
[10:34:17.328]                           else {
[10:34:17.328]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:17.328]                               info, version)
[10:34:17.328]                           }
[10:34:17.328]                           base::stop(msg)
[10:34:17.328]                         }
[10:34:17.328]                       })
[10:34:17.328]                     }
[10:34:17.328]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:17.328]                     base::options(mc.cores = 1L)
[10:34:17.328]                   }
[10:34:17.328]                   ...future.strategy.old <- future::plan("list")
[10:34:17.328]                   options(future.plan = NULL)
[10:34:17.328]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.328]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:17.328]                 }
[10:34:17.328]                 ...future.workdir <- getwd()
[10:34:17.328]             }
[10:34:17.328]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:17.328]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:17.328]         }
[10:34:17.328]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:17.328]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:17.328]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:17.328]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:17.328]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:17.328]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:17.328]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:17.328]             base::names(...future.oldOptions))
[10:34:17.328]     }
[10:34:17.328]     if (FALSE) {
[10:34:17.328]     }
[10:34:17.328]     else {
[10:34:17.328]         if (TRUE) {
[10:34:17.328]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:17.328]                 open = "w")
[10:34:17.328]         }
[10:34:17.328]         else {
[10:34:17.328]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:17.328]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:17.328]         }
[10:34:17.328]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:17.328]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:17.328]             base::sink(type = "output", split = FALSE)
[10:34:17.328]             base::close(...future.stdout)
[10:34:17.328]         }, add = TRUE)
[10:34:17.328]     }
[10:34:17.328]     ...future.frame <- base::sys.nframe()
[10:34:17.328]     ...future.conditions <- base::list()
[10:34:17.328]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:17.328]     if (FALSE) {
[10:34:17.328]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:17.328]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:17.328]     }
[10:34:17.328]     ...future.result <- base::tryCatch({
[10:34:17.328]         base::withCallingHandlers({
[10:34:17.328]             ...future.value <- base::withVisible(base::local({
[10:34:17.328]                 ...future.makeSendCondition <- base::local({
[10:34:17.328]                   sendCondition <- NULL
[10:34:17.328]                   function(frame = 1L) {
[10:34:17.328]                     if (is.function(sendCondition)) 
[10:34:17.328]                       return(sendCondition)
[10:34:17.328]                     ns <- getNamespace("parallel")
[10:34:17.328]                     if (exists("sendData", mode = "function", 
[10:34:17.328]                       envir = ns)) {
[10:34:17.328]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:17.328]                         envir = ns)
[10:34:17.328]                       envir <- sys.frame(frame)
[10:34:17.328]                       master <- NULL
[10:34:17.328]                       while (!identical(envir, .GlobalEnv) && 
[10:34:17.328]                         !identical(envir, emptyenv())) {
[10:34:17.328]                         if (exists("master", mode = "list", envir = envir, 
[10:34:17.328]                           inherits = FALSE)) {
[10:34:17.328]                           master <- get("master", mode = "list", 
[10:34:17.328]                             envir = envir, inherits = FALSE)
[10:34:17.328]                           if (inherits(master, c("SOCKnode", 
[10:34:17.328]                             "SOCK0node"))) {
[10:34:17.328]                             sendCondition <<- function(cond) {
[10:34:17.328]                               data <- list(type = "VALUE", value = cond, 
[10:34:17.328]                                 success = TRUE)
[10:34:17.328]                               parallel_sendData(master, data)
[10:34:17.328]                             }
[10:34:17.328]                             return(sendCondition)
[10:34:17.328]                           }
[10:34:17.328]                         }
[10:34:17.328]                         frame <- frame + 1L
[10:34:17.328]                         envir <- sys.frame(frame)
[10:34:17.328]                       }
[10:34:17.328]                     }
[10:34:17.328]                     sendCondition <<- function(cond) NULL
[10:34:17.328]                   }
[10:34:17.328]                 })
[10:34:17.328]                 withCallingHandlers({
[10:34:17.328]                   1
[10:34:17.328]                 }, immediateCondition = function(cond) {
[10:34:17.328]                   sendCondition <- ...future.makeSendCondition()
[10:34:17.328]                   sendCondition(cond)
[10:34:17.328]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.328]                   {
[10:34:17.328]                     inherits <- base::inherits
[10:34:17.328]                     invokeRestart <- base::invokeRestart
[10:34:17.328]                     is.null <- base::is.null
[10:34:17.328]                     muffled <- FALSE
[10:34:17.328]                     if (inherits(cond, "message")) {
[10:34:17.328]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:17.328]                       if (muffled) 
[10:34:17.328]                         invokeRestart("muffleMessage")
[10:34:17.328]                     }
[10:34:17.328]                     else if (inherits(cond, "warning")) {
[10:34:17.328]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:17.328]                       if (muffled) 
[10:34:17.328]                         invokeRestart("muffleWarning")
[10:34:17.328]                     }
[10:34:17.328]                     else if (inherits(cond, "condition")) {
[10:34:17.328]                       if (!is.null(pattern)) {
[10:34:17.328]                         computeRestarts <- base::computeRestarts
[10:34:17.328]                         grepl <- base::grepl
[10:34:17.328]                         restarts <- computeRestarts(cond)
[10:34:17.328]                         for (restart in restarts) {
[10:34:17.328]                           name <- restart$name
[10:34:17.328]                           if (is.null(name)) 
[10:34:17.328]                             next
[10:34:17.328]                           if (!grepl(pattern, name)) 
[10:34:17.328]                             next
[10:34:17.328]                           invokeRestart(restart)
[10:34:17.328]                           muffled <- TRUE
[10:34:17.328]                           break
[10:34:17.328]                         }
[10:34:17.328]                       }
[10:34:17.328]                     }
[10:34:17.328]                     invisible(muffled)
[10:34:17.328]                   }
[10:34:17.328]                   muffleCondition(cond)
[10:34:17.328]                 })
[10:34:17.328]             }))
[10:34:17.328]             future::FutureResult(value = ...future.value$value, 
[10:34:17.328]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.328]                   ...future.rng), globalenv = if (FALSE) 
[10:34:17.328]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:17.328]                     ...future.globalenv.names))
[10:34:17.328]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:17.328]         }, condition = base::local({
[10:34:17.328]             c <- base::c
[10:34:17.328]             inherits <- base::inherits
[10:34:17.328]             invokeRestart <- base::invokeRestart
[10:34:17.328]             length <- base::length
[10:34:17.328]             list <- base::list
[10:34:17.328]             seq.int <- base::seq.int
[10:34:17.328]             signalCondition <- base::signalCondition
[10:34:17.328]             sys.calls <- base::sys.calls
[10:34:17.328]             `[[` <- base::`[[`
[10:34:17.328]             `+` <- base::`+`
[10:34:17.328]             `<<-` <- base::`<<-`
[10:34:17.328]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:17.328]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:17.328]                   3L)]
[10:34:17.328]             }
[10:34:17.328]             function(cond) {
[10:34:17.328]                 is_error <- inherits(cond, "error")
[10:34:17.328]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:17.328]                   NULL)
[10:34:17.328]                 if (is_error) {
[10:34:17.328]                   sessionInformation <- function() {
[10:34:17.328]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:17.328]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:17.328]                       search = base::search(), system = base::Sys.info())
[10:34:17.328]                   }
[10:34:17.328]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.328]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:17.328]                     cond$call), session = sessionInformation(), 
[10:34:17.328]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:17.328]                   signalCondition(cond)
[10:34:17.328]                 }
[10:34:17.328]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:17.328]                 "immediateCondition"))) {
[10:34:17.328]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:17.328]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.328]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:17.328]                   if (TRUE && !signal) {
[10:34:17.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.328]                     {
[10:34:17.328]                       inherits <- base::inherits
[10:34:17.328]                       invokeRestart <- base::invokeRestart
[10:34:17.328]                       is.null <- base::is.null
[10:34:17.328]                       muffled <- FALSE
[10:34:17.328]                       if (inherits(cond, "message")) {
[10:34:17.328]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.328]                         if (muffled) 
[10:34:17.328]                           invokeRestart("muffleMessage")
[10:34:17.328]                       }
[10:34:17.328]                       else if (inherits(cond, "warning")) {
[10:34:17.328]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.328]                         if (muffled) 
[10:34:17.328]                           invokeRestart("muffleWarning")
[10:34:17.328]                       }
[10:34:17.328]                       else if (inherits(cond, "condition")) {
[10:34:17.328]                         if (!is.null(pattern)) {
[10:34:17.328]                           computeRestarts <- base::computeRestarts
[10:34:17.328]                           grepl <- base::grepl
[10:34:17.328]                           restarts <- computeRestarts(cond)
[10:34:17.328]                           for (restart in restarts) {
[10:34:17.328]                             name <- restart$name
[10:34:17.328]                             if (is.null(name)) 
[10:34:17.328]                               next
[10:34:17.328]                             if (!grepl(pattern, name)) 
[10:34:17.328]                               next
[10:34:17.328]                             invokeRestart(restart)
[10:34:17.328]                             muffled <- TRUE
[10:34:17.328]                             break
[10:34:17.328]                           }
[10:34:17.328]                         }
[10:34:17.328]                       }
[10:34:17.328]                       invisible(muffled)
[10:34:17.328]                     }
[10:34:17.328]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.328]                   }
[10:34:17.328]                 }
[10:34:17.328]                 else {
[10:34:17.328]                   if (TRUE) {
[10:34:17.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.328]                     {
[10:34:17.328]                       inherits <- base::inherits
[10:34:17.328]                       invokeRestart <- base::invokeRestart
[10:34:17.328]                       is.null <- base::is.null
[10:34:17.328]                       muffled <- FALSE
[10:34:17.328]                       if (inherits(cond, "message")) {
[10:34:17.328]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.328]                         if (muffled) 
[10:34:17.328]                           invokeRestart("muffleMessage")
[10:34:17.328]                       }
[10:34:17.328]                       else if (inherits(cond, "warning")) {
[10:34:17.328]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.328]                         if (muffled) 
[10:34:17.328]                           invokeRestart("muffleWarning")
[10:34:17.328]                       }
[10:34:17.328]                       else if (inherits(cond, "condition")) {
[10:34:17.328]                         if (!is.null(pattern)) {
[10:34:17.328]                           computeRestarts <- base::computeRestarts
[10:34:17.328]                           grepl <- base::grepl
[10:34:17.328]                           restarts <- computeRestarts(cond)
[10:34:17.328]                           for (restart in restarts) {
[10:34:17.328]                             name <- restart$name
[10:34:17.328]                             if (is.null(name)) 
[10:34:17.328]                               next
[10:34:17.328]                             if (!grepl(pattern, name)) 
[10:34:17.328]                               next
[10:34:17.328]                             invokeRestart(restart)
[10:34:17.328]                             muffled <- TRUE
[10:34:17.328]                             break
[10:34:17.328]                           }
[10:34:17.328]                         }
[10:34:17.328]                       }
[10:34:17.328]                       invisible(muffled)
[10:34:17.328]                     }
[10:34:17.328]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.328]                   }
[10:34:17.328]                 }
[10:34:17.328]             }
[10:34:17.328]         }))
[10:34:17.328]     }, error = function(ex) {
[10:34:17.328]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:17.328]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.328]                 ...future.rng), started = ...future.startTime, 
[10:34:17.328]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:17.328]             version = "1.8"), class = "FutureResult")
[10:34:17.328]     }, finally = {
[10:34:17.328]         if (!identical(...future.workdir, getwd())) 
[10:34:17.328]             setwd(...future.workdir)
[10:34:17.328]         {
[10:34:17.328]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:17.328]                 ...future.oldOptions$nwarnings <- NULL
[10:34:17.328]             }
[10:34:17.328]             base::options(...future.oldOptions)
[10:34:17.328]             if (.Platform$OS.type == "windows") {
[10:34:17.328]                 old_names <- names(...future.oldEnvVars)
[10:34:17.328]                 envs <- base::Sys.getenv()
[10:34:17.328]                 names <- names(envs)
[10:34:17.328]                 common <- intersect(names, old_names)
[10:34:17.328]                 added <- setdiff(names, old_names)
[10:34:17.328]                 removed <- setdiff(old_names, names)
[10:34:17.328]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:17.328]                   envs[common]]
[10:34:17.328]                 NAMES <- toupper(changed)
[10:34:17.328]                 args <- list()
[10:34:17.328]                 for (kk in seq_along(NAMES)) {
[10:34:17.328]                   name <- changed[[kk]]
[10:34:17.328]                   NAME <- NAMES[[kk]]
[10:34:17.328]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.328]                     next
[10:34:17.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.328]                 }
[10:34:17.328]                 NAMES <- toupper(added)
[10:34:17.328]                 for (kk in seq_along(NAMES)) {
[10:34:17.328]                   name <- added[[kk]]
[10:34:17.328]                   NAME <- NAMES[[kk]]
[10:34:17.328]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.328]                     next
[10:34:17.328]                   args[[name]] <- ""
[10:34:17.328]                 }
[10:34:17.328]                 NAMES <- toupper(removed)
[10:34:17.328]                 for (kk in seq_along(NAMES)) {
[10:34:17.328]                   name <- removed[[kk]]
[10:34:17.328]                   NAME <- NAMES[[kk]]
[10:34:17.328]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.328]                     next
[10:34:17.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.328]                 }
[10:34:17.328]                 if (length(args) > 0) 
[10:34:17.328]                   base::do.call(base::Sys.setenv, args = args)
[10:34:17.328]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:17.328]             }
[10:34:17.328]             else {
[10:34:17.328]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:17.328]             }
[10:34:17.328]             {
[10:34:17.328]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:17.328]                   0L) {
[10:34:17.328]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:17.328]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:17.328]                   base::options(opts)
[10:34:17.328]                 }
[10:34:17.328]                 {
[10:34:17.328]                   {
[10:34:17.328]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:17.328]                     NULL
[10:34:17.328]                   }
[10:34:17.328]                   options(future.plan = NULL)
[10:34:17.328]                   if (is.na(NA_character_)) 
[10:34:17.328]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.328]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:17.328]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:17.328]                     .init = FALSE)
[10:34:17.328]                 }
[10:34:17.328]             }
[10:34:17.328]         }
[10:34:17.328]     })
[10:34:17.328]     if (TRUE) {
[10:34:17.328]         base::sink(type = "output", split = FALSE)
[10:34:17.328]         if (TRUE) {
[10:34:17.328]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:17.328]         }
[10:34:17.328]         else {
[10:34:17.328]             ...future.result["stdout"] <- base::list(NULL)
[10:34:17.328]         }
[10:34:17.328]         base::close(...future.stdout)
[10:34:17.328]         ...future.stdout <- NULL
[10:34:17.328]     }
[10:34:17.328]     ...future.result$conditions <- ...future.conditions
[10:34:17.328]     ...future.result$finished <- base::Sys.time()
[10:34:17.328]     ...future.result
[10:34:17.328] }
[10:34:17.331] MultisessionFuture started
[10:34:17.331] - Launch lazy future ... done
[10:34:17.331] run() for ‘MultisessionFuture’ ... done
[10:34:17.331] getGlobalsAndPackages() ...
[10:34:17.331] Searching for globals...
[10:34:17.332] 
[10:34:17.332] Searching for globals ... DONE
[10:34:17.332] - globals: [0] <none>
[10:34:17.332] getGlobalsAndPackages() ... DONE
[10:34:17.332] run() for ‘Future’ ...
[10:34:17.332] - state: ‘created’
[10:34:17.332] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:17.346] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:17.346] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:17.346]   - Field: ‘node’
[10:34:17.346]   - Field: ‘label’
[10:34:17.346]   - Field: ‘local’
[10:34:17.346]   - Field: ‘owner’
[10:34:17.346]   - Field: ‘envir’
[10:34:17.347]   - Field: ‘workers’
[10:34:17.347]   - Field: ‘packages’
[10:34:17.347]   - Field: ‘gc’
[10:34:17.347]   - Field: ‘conditions’
[10:34:17.347]   - Field: ‘persistent’
[10:34:17.347]   - Field: ‘expr’
[10:34:17.347]   - Field: ‘uuid’
[10:34:17.347]   - Field: ‘seed’
[10:34:17.347]   - Field: ‘version’
[10:34:17.347]   - Field: ‘result’
[10:34:17.347]   - Field: ‘asynchronous’
[10:34:17.348]   - Field: ‘calls’
[10:34:17.348]   - Field: ‘globals’
[10:34:17.348]   - Field: ‘stdout’
[10:34:17.348]   - Field: ‘earlySignal’
[10:34:17.348]   - Field: ‘lazy’
[10:34:17.348]   - Field: ‘state’
[10:34:17.348] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:17.348] - Launch lazy future ...
[10:34:17.348] Packages needed by the future expression (n = 0): <none>
[10:34:17.349] Packages needed by future strategies (n = 0): <none>
[10:34:17.349] {
[10:34:17.349]     {
[10:34:17.349]         {
[10:34:17.349]             ...future.startTime <- base::Sys.time()
[10:34:17.349]             {
[10:34:17.349]                 {
[10:34:17.349]                   {
[10:34:17.349]                     {
[10:34:17.349]                       base::local({
[10:34:17.349]                         has_future <- base::requireNamespace("future", 
[10:34:17.349]                           quietly = TRUE)
[10:34:17.349]                         if (has_future) {
[10:34:17.349]                           ns <- base::getNamespace("future")
[10:34:17.349]                           version <- ns[[".package"]][["version"]]
[10:34:17.349]                           if (is.null(version)) 
[10:34:17.349]                             version <- utils::packageVersion("future")
[10:34:17.349]                         }
[10:34:17.349]                         else {
[10:34:17.349]                           version <- NULL
[10:34:17.349]                         }
[10:34:17.349]                         if (!has_future || version < "1.8.0") {
[10:34:17.349]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:17.349]                             "", base::R.version$version.string), 
[10:34:17.349]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:17.349]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:17.349]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:17.349]                               "release", "version")], collapse = " "), 
[10:34:17.349]                             hostname = base::Sys.info()[["nodename"]])
[10:34:17.349]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:17.349]                             info)
[10:34:17.349]                           info <- base::paste(info, collapse = "; ")
[10:34:17.349]                           if (!has_future) {
[10:34:17.349]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:17.349]                               info)
[10:34:17.349]                           }
[10:34:17.349]                           else {
[10:34:17.349]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:17.349]                               info, version)
[10:34:17.349]                           }
[10:34:17.349]                           base::stop(msg)
[10:34:17.349]                         }
[10:34:17.349]                       })
[10:34:17.349]                     }
[10:34:17.349]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:17.349]                     base::options(mc.cores = 1L)
[10:34:17.349]                   }
[10:34:17.349]                   ...future.strategy.old <- future::plan("list")
[10:34:17.349]                   options(future.plan = NULL)
[10:34:17.349]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.349]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:17.349]                 }
[10:34:17.349]                 ...future.workdir <- getwd()
[10:34:17.349]             }
[10:34:17.349]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:17.349]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:17.349]         }
[10:34:17.349]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:17.349]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:17.349]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:17.349]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:17.349]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:17.349]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:17.349]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:17.349]             base::names(...future.oldOptions))
[10:34:17.349]     }
[10:34:17.349]     if (FALSE) {
[10:34:17.349]     }
[10:34:17.349]     else {
[10:34:17.349]         if (TRUE) {
[10:34:17.349]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:17.349]                 open = "w")
[10:34:17.349]         }
[10:34:17.349]         else {
[10:34:17.349]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:17.349]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:17.349]         }
[10:34:17.349]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:17.349]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:17.349]             base::sink(type = "output", split = FALSE)
[10:34:17.349]             base::close(...future.stdout)
[10:34:17.349]         }, add = TRUE)
[10:34:17.349]     }
[10:34:17.349]     ...future.frame <- base::sys.nframe()
[10:34:17.349]     ...future.conditions <- base::list()
[10:34:17.349]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:17.349]     if (FALSE) {
[10:34:17.349]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:17.349]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:17.349]     }
[10:34:17.349]     ...future.result <- base::tryCatch({
[10:34:17.349]         base::withCallingHandlers({
[10:34:17.349]             ...future.value <- base::withVisible(base::local({
[10:34:17.349]                 ...future.makeSendCondition <- base::local({
[10:34:17.349]                   sendCondition <- NULL
[10:34:17.349]                   function(frame = 1L) {
[10:34:17.349]                     if (is.function(sendCondition)) 
[10:34:17.349]                       return(sendCondition)
[10:34:17.349]                     ns <- getNamespace("parallel")
[10:34:17.349]                     if (exists("sendData", mode = "function", 
[10:34:17.349]                       envir = ns)) {
[10:34:17.349]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:17.349]                         envir = ns)
[10:34:17.349]                       envir <- sys.frame(frame)
[10:34:17.349]                       master <- NULL
[10:34:17.349]                       while (!identical(envir, .GlobalEnv) && 
[10:34:17.349]                         !identical(envir, emptyenv())) {
[10:34:17.349]                         if (exists("master", mode = "list", envir = envir, 
[10:34:17.349]                           inherits = FALSE)) {
[10:34:17.349]                           master <- get("master", mode = "list", 
[10:34:17.349]                             envir = envir, inherits = FALSE)
[10:34:17.349]                           if (inherits(master, c("SOCKnode", 
[10:34:17.349]                             "SOCK0node"))) {
[10:34:17.349]                             sendCondition <<- function(cond) {
[10:34:17.349]                               data <- list(type = "VALUE", value = cond, 
[10:34:17.349]                                 success = TRUE)
[10:34:17.349]                               parallel_sendData(master, data)
[10:34:17.349]                             }
[10:34:17.349]                             return(sendCondition)
[10:34:17.349]                           }
[10:34:17.349]                         }
[10:34:17.349]                         frame <- frame + 1L
[10:34:17.349]                         envir <- sys.frame(frame)
[10:34:17.349]                       }
[10:34:17.349]                     }
[10:34:17.349]                     sendCondition <<- function(cond) NULL
[10:34:17.349]                   }
[10:34:17.349]                 })
[10:34:17.349]                 withCallingHandlers({
[10:34:17.349]                   2
[10:34:17.349]                 }, immediateCondition = function(cond) {
[10:34:17.349]                   sendCondition <- ...future.makeSendCondition()
[10:34:17.349]                   sendCondition(cond)
[10:34:17.349]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.349]                   {
[10:34:17.349]                     inherits <- base::inherits
[10:34:17.349]                     invokeRestart <- base::invokeRestart
[10:34:17.349]                     is.null <- base::is.null
[10:34:17.349]                     muffled <- FALSE
[10:34:17.349]                     if (inherits(cond, "message")) {
[10:34:17.349]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:17.349]                       if (muffled) 
[10:34:17.349]                         invokeRestart("muffleMessage")
[10:34:17.349]                     }
[10:34:17.349]                     else if (inherits(cond, "warning")) {
[10:34:17.349]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:17.349]                       if (muffled) 
[10:34:17.349]                         invokeRestart("muffleWarning")
[10:34:17.349]                     }
[10:34:17.349]                     else if (inherits(cond, "condition")) {
[10:34:17.349]                       if (!is.null(pattern)) {
[10:34:17.349]                         computeRestarts <- base::computeRestarts
[10:34:17.349]                         grepl <- base::grepl
[10:34:17.349]                         restarts <- computeRestarts(cond)
[10:34:17.349]                         for (restart in restarts) {
[10:34:17.349]                           name <- restart$name
[10:34:17.349]                           if (is.null(name)) 
[10:34:17.349]                             next
[10:34:17.349]                           if (!grepl(pattern, name)) 
[10:34:17.349]                             next
[10:34:17.349]                           invokeRestart(restart)
[10:34:17.349]                           muffled <- TRUE
[10:34:17.349]                           break
[10:34:17.349]                         }
[10:34:17.349]                       }
[10:34:17.349]                     }
[10:34:17.349]                     invisible(muffled)
[10:34:17.349]                   }
[10:34:17.349]                   muffleCondition(cond)
[10:34:17.349]                 })
[10:34:17.349]             }))
[10:34:17.349]             future::FutureResult(value = ...future.value$value, 
[10:34:17.349]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.349]                   ...future.rng), globalenv = if (FALSE) 
[10:34:17.349]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:17.349]                     ...future.globalenv.names))
[10:34:17.349]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:17.349]         }, condition = base::local({
[10:34:17.349]             c <- base::c
[10:34:17.349]             inherits <- base::inherits
[10:34:17.349]             invokeRestart <- base::invokeRestart
[10:34:17.349]             length <- base::length
[10:34:17.349]             list <- base::list
[10:34:17.349]             seq.int <- base::seq.int
[10:34:17.349]             signalCondition <- base::signalCondition
[10:34:17.349]             sys.calls <- base::sys.calls
[10:34:17.349]             `[[` <- base::`[[`
[10:34:17.349]             `+` <- base::`+`
[10:34:17.349]             `<<-` <- base::`<<-`
[10:34:17.349]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:17.349]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:17.349]                   3L)]
[10:34:17.349]             }
[10:34:17.349]             function(cond) {
[10:34:17.349]                 is_error <- inherits(cond, "error")
[10:34:17.349]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:17.349]                   NULL)
[10:34:17.349]                 if (is_error) {
[10:34:17.349]                   sessionInformation <- function() {
[10:34:17.349]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:17.349]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:17.349]                       search = base::search(), system = base::Sys.info())
[10:34:17.349]                   }
[10:34:17.349]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.349]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:17.349]                     cond$call), session = sessionInformation(), 
[10:34:17.349]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:17.349]                   signalCondition(cond)
[10:34:17.349]                 }
[10:34:17.349]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:17.349]                 "immediateCondition"))) {
[10:34:17.349]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:17.349]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.349]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:17.349]                   if (TRUE && !signal) {
[10:34:17.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.349]                     {
[10:34:17.349]                       inherits <- base::inherits
[10:34:17.349]                       invokeRestart <- base::invokeRestart
[10:34:17.349]                       is.null <- base::is.null
[10:34:17.349]                       muffled <- FALSE
[10:34:17.349]                       if (inherits(cond, "message")) {
[10:34:17.349]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.349]                         if (muffled) 
[10:34:17.349]                           invokeRestart("muffleMessage")
[10:34:17.349]                       }
[10:34:17.349]                       else if (inherits(cond, "warning")) {
[10:34:17.349]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.349]                         if (muffled) 
[10:34:17.349]                           invokeRestart("muffleWarning")
[10:34:17.349]                       }
[10:34:17.349]                       else if (inherits(cond, "condition")) {
[10:34:17.349]                         if (!is.null(pattern)) {
[10:34:17.349]                           computeRestarts <- base::computeRestarts
[10:34:17.349]                           grepl <- base::grepl
[10:34:17.349]                           restarts <- computeRestarts(cond)
[10:34:17.349]                           for (restart in restarts) {
[10:34:17.349]                             name <- restart$name
[10:34:17.349]                             if (is.null(name)) 
[10:34:17.349]                               next
[10:34:17.349]                             if (!grepl(pattern, name)) 
[10:34:17.349]                               next
[10:34:17.349]                             invokeRestart(restart)
[10:34:17.349]                             muffled <- TRUE
[10:34:17.349]                             break
[10:34:17.349]                           }
[10:34:17.349]                         }
[10:34:17.349]                       }
[10:34:17.349]                       invisible(muffled)
[10:34:17.349]                     }
[10:34:17.349]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.349]                   }
[10:34:17.349]                 }
[10:34:17.349]                 else {
[10:34:17.349]                   if (TRUE) {
[10:34:17.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.349]                     {
[10:34:17.349]                       inherits <- base::inherits
[10:34:17.349]                       invokeRestart <- base::invokeRestart
[10:34:17.349]                       is.null <- base::is.null
[10:34:17.349]                       muffled <- FALSE
[10:34:17.349]                       if (inherits(cond, "message")) {
[10:34:17.349]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.349]                         if (muffled) 
[10:34:17.349]                           invokeRestart("muffleMessage")
[10:34:17.349]                       }
[10:34:17.349]                       else if (inherits(cond, "warning")) {
[10:34:17.349]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.349]                         if (muffled) 
[10:34:17.349]                           invokeRestart("muffleWarning")
[10:34:17.349]                       }
[10:34:17.349]                       else if (inherits(cond, "condition")) {
[10:34:17.349]                         if (!is.null(pattern)) {
[10:34:17.349]                           computeRestarts <- base::computeRestarts
[10:34:17.349]                           grepl <- base::grepl
[10:34:17.349]                           restarts <- computeRestarts(cond)
[10:34:17.349]                           for (restart in restarts) {
[10:34:17.349]                             name <- restart$name
[10:34:17.349]                             if (is.null(name)) 
[10:34:17.349]                               next
[10:34:17.349]                             if (!grepl(pattern, name)) 
[10:34:17.349]                               next
[10:34:17.349]                             invokeRestart(restart)
[10:34:17.349]                             muffled <- TRUE
[10:34:17.349]                             break
[10:34:17.349]                           }
[10:34:17.349]                         }
[10:34:17.349]                       }
[10:34:17.349]                       invisible(muffled)
[10:34:17.349]                     }
[10:34:17.349]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.349]                   }
[10:34:17.349]                 }
[10:34:17.349]             }
[10:34:17.349]         }))
[10:34:17.349]     }, error = function(ex) {
[10:34:17.349]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:17.349]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.349]                 ...future.rng), started = ...future.startTime, 
[10:34:17.349]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:17.349]             version = "1.8"), class = "FutureResult")
[10:34:17.349]     }, finally = {
[10:34:17.349]         if (!identical(...future.workdir, getwd())) 
[10:34:17.349]             setwd(...future.workdir)
[10:34:17.349]         {
[10:34:17.349]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:17.349]                 ...future.oldOptions$nwarnings <- NULL
[10:34:17.349]             }
[10:34:17.349]             base::options(...future.oldOptions)
[10:34:17.349]             if (.Platform$OS.type == "windows") {
[10:34:17.349]                 old_names <- names(...future.oldEnvVars)
[10:34:17.349]                 envs <- base::Sys.getenv()
[10:34:17.349]                 names <- names(envs)
[10:34:17.349]                 common <- intersect(names, old_names)
[10:34:17.349]                 added <- setdiff(names, old_names)
[10:34:17.349]                 removed <- setdiff(old_names, names)
[10:34:17.349]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:17.349]                   envs[common]]
[10:34:17.349]                 NAMES <- toupper(changed)
[10:34:17.349]                 args <- list()
[10:34:17.349]                 for (kk in seq_along(NAMES)) {
[10:34:17.349]                   name <- changed[[kk]]
[10:34:17.349]                   NAME <- NAMES[[kk]]
[10:34:17.349]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.349]                     next
[10:34:17.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.349]                 }
[10:34:17.349]                 NAMES <- toupper(added)
[10:34:17.349]                 for (kk in seq_along(NAMES)) {
[10:34:17.349]                   name <- added[[kk]]
[10:34:17.349]                   NAME <- NAMES[[kk]]
[10:34:17.349]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.349]                     next
[10:34:17.349]                   args[[name]] <- ""
[10:34:17.349]                 }
[10:34:17.349]                 NAMES <- toupper(removed)
[10:34:17.349]                 for (kk in seq_along(NAMES)) {
[10:34:17.349]                   name <- removed[[kk]]
[10:34:17.349]                   NAME <- NAMES[[kk]]
[10:34:17.349]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.349]                     next
[10:34:17.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.349]                 }
[10:34:17.349]                 if (length(args) > 0) 
[10:34:17.349]                   base::do.call(base::Sys.setenv, args = args)
[10:34:17.349]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:17.349]             }
[10:34:17.349]             else {
[10:34:17.349]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:17.349]             }
[10:34:17.349]             {
[10:34:17.349]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:17.349]                   0L) {
[10:34:17.349]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:17.349]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:17.349]                   base::options(opts)
[10:34:17.349]                 }
[10:34:17.349]                 {
[10:34:17.349]                   {
[10:34:17.349]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:17.349]                     NULL
[10:34:17.349]                   }
[10:34:17.349]                   options(future.plan = NULL)
[10:34:17.349]                   if (is.na(NA_character_)) 
[10:34:17.349]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.349]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:17.349]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:17.349]                     .init = FALSE)
[10:34:17.349]                 }
[10:34:17.349]             }
[10:34:17.349]         }
[10:34:17.349]     })
[10:34:17.349]     if (TRUE) {
[10:34:17.349]         base::sink(type = "output", split = FALSE)
[10:34:17.349]         if (TRUE) {
[10:34:17.349]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:17.349]         }
[10:34:17.349]         else {
[10:34:17.349]             ...future.result["stdout"] <- base::list(NULL)
[10:34:17.349]         }
[10:34:17.349]         base::close(...future.stdout)
[10:34:17.349]         ...future.stdout <- NULL
[10:34:17.349]     }
[10:34:17.349]     ...future.result$conditions <- ...future.conditions
[10:34:17.349]     ...future.result$finished <- base::Sys.time()
[10:34:17.349]     ...future.result
[10:34:17.349] }
[10:34:17.352] MultisessionFuture started
[10:34:17.352] - Launch lazy future ... done
[10:34:17.352] run() for ‘MultisessionFuture’ ... done
[10:34:17.353] resolve() on environment ...
[10:34:17.353]  recursive: 0
[10:34:17.353]  elements: [3] ‘a’, ‘b’, ‘c’
[10:34:17.354] receiveMessageFromWorker() for ClusterFuture ...
[10:34:17.354] - Validating connection of MultisessionFuture
[10:34:17.354] - received message: FutureResult
[10:34:17.354] - Received FutureResult
[10:34:17.354] - Erased future from FutureRegistry
[10:34:17.354] result() for ClusterFuture ...
[10:34:17.354] - result already collected: FutureResult
[10:34:17.354] result() for ClusterFuture ... done
[10:34:17.354] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:17.355] Future #1
[10:34:17.355]  length: 2 (resolved future 1)
[10:34:17.355] receiveMessageFromWorker() for ClusterFuture ...
[10:34:17.355] - Validating connection of MultisessionFuture
[10:34:17.355] - received message: FutureResult
[10:34:17.355] - Received FutureResult
[10:34:17.356] - Erased future from FutureRegistry
[10:34:17.356] result() for ClusterFuture ...
[10:34:17.356] - result already collected: FutureResult
[10:34:17.356] result() for ClusterFuture ... done
[10:34:17.356] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:17.356] Future #2
[10:34:17.356]  length: 1 (resolved future 2)
[10:34:17.356]  length: 0 (resolved future 3)
[10:34:17.356] resolve() on environment ... DONE
[10:34:17.357] getGlobalsAndPackages() ...
[10:34:17.357] Searching for globals...
[10:34:17.358] - globals found: [1] ‘{’
[10:34:17.358] Searching for globals ... DONE
[10:34:17.358] Resolving globals: FALSE
[10:34:17.358] 
[10:34:17.358] 
[10:34:17.358] getGlobalsAndPackages() ... DONE
[10:34:17.358] run() for ‘Future’ ...
[10:34:17.359] - state: ‘created’
[10:34:17.359] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:17.372] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:17.372] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:17.372]   - Field: ‘node’
[10:34:17.372]   - Field: ‘label’
[10:34:17.373]   - Field: ‘local’
[10:34:17.373]   - Field: ‘owner’
[10:34:17.373]   - Field: ‘envir’
[10:34:17.373]   - Field: ‘workers’
[10:34:17.373]   - Field: ‘packages’
[10:34:17.373]   - Field: ‘gc’
[10:34:17.373]   - Field: ‘conditions’
[10:34:17.373]   - Field: ‘persistent’
[10:34:17.373]   - Field: ‘expr’
[10:34:17.373]   - Field: ‘uuid’
[10:34:17.373]   - Field: ‘seed’
[10:34:17.374]   - Field: ‘version’
[10:34:17.374]   - Field: ‘result’
[10:34:17.374]   - Field: ‘asynchronous’
[10:34:17.374]   - Field: ‘calls’
[10:34:17.374]   - Field: ‘globals’
[10:34:17.374]   - Field: ‘stdout’
[10:34:17.374]   - Field: ‘earlySignal’
[10:34:17.374]   - Field: ‘lazy’
[10:34:17.374]   - Field: ‘state’
[10:34:17.374] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:17.374] - Launch lazy future ...
[10:34:17.375] Packages needed by the future expression (n = 0): <none>
[10:34:17.375] Packages needed by future strategies (n = 0): <none>
[10:34:17.375] {
[10:34:17.375]     {
[10:34:17.375]         {
[10:34:17.375]             ...future.startTime <- base::Sys.time()
[10:34:17.375]             {
[10:34:17.375]                 {
[10:34:17.375]                   {
[10:34:17.375]                     {
[10:34:17.375]                       base::local({
[10:34:17.375]                         has_future <- base::requireNamespace("future", 
[10:34:17.375]                           quietly = TRUE)
[10:34:17.375]                         if (has_future) {
[10:34:17.375]                           ns <- base::getNamespace("future")
[10:34:17.375]                           version <- ns[[".package"]][["version"]]
[10:34:17.375]                           if (is.null(version)) 
[10:34:17.375]                             version <- utils::packageVersion("future")
[10:34:17.375]                         }
[10:34:17.375]                         else {
[10:34:17.375]                           version <- NULL
[10:34:17.375]                         }
[10:34:17.375]                         if (!has_future || version < "1.8.0") {
[10:34:17.375]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:17.375]                             "", base::R.version$version.string), 
[10:34:17.375]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:17.375]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:17.375]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:17.375]                               "release", "version")], collapse = " "), 
[10:34:17.375]                             hostname = base::Sys.info()[["nodename"]])
[10:34:17.375]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:17.375]                             info)
[10:34:17.375]                           info <- base::paste(info, collapse = "; ")
[10:34:17.375]                           if (!has_future) {
[10:34:17.375]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:17.375]                               info)
[10:34:17.375]                           }
[10:34:17.375]                           else {
[10:34:17.375]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:17.375]                               info, version)
[10:34:17.375]                           }
[10:34:17.375]                           base::stop(msg)
[10:34:17.375]                         }
[10:34:17.375]                       })
[10:34:17.375]                     }
[10:34:17.375]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:17.375]                     base::options(mc.cores = 1L)
[10:34:17.375]                   }
[10:34:17.375]                   ...future.strategy.old <- future::plan("list")
[10:34:17.375]                   options(future.plan = NULL)
[10:34:17.375]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.375]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:17.375]                 }
[10:34:17.375]                 ...future.workdir <- getwd()
[10:34:17.375]             }
[10:34:17.375]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:17.375]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:17.375]         }
[10:34:17.375]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:17.375]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:17.375]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:17.375]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:17.375]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:17.375]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:17.375]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:17.375]             base::names(...future.oldOptions))
[10:34:17.375]     }
[10:34:17.375]     if (FALSE) {
[10:34:17.375]     }
[10:34:17.375]     else {
[10:34:17.375]         if (TRUE) {
[10:34:17.375]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:17.375]                 open = "w")
[10:34:17.375]         }
[10:34:17.375]         else {
[10:34:17.375]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:17.375]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:17.375]         }
[10:34:17.375]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:17.375]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:17.375]             base::sink(type = "output", split = FALSE)
[10:34:17.375]             base::close(...future.stdout)
[10:34:17.375]         }, add = TRUE)
[10:34:17.375]     }
[10:34:17.375]     ...future.frame <- base::sys.nframe()
[10:34:17.375]     ...future.conditions <- base::list()
[10:34:17.375]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:17.375]     if (FALSE) {
[10:34:17.375]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:17.375]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:17.375]     }
[10:34:17.375]     ...future.result <- base::tryCatch({
[10:34:17.375]         base::withCallingHandlers({
[10:34:17.375]             ...future.value <- base::withVisible(base::local({
[10:34:17.375]                 ...future.makeSendCondition <- base::local({
[10:34:17.375]                   sendCondition <- NULL
[10:34:17.375]                   function(frame = 1L) {
[10:34:17.375]                     if (is.function(sendCondition)) 
[10:34:17.375]                       return(sendCondition)
[10:34:17.375]                     ns <- getNamespace("parallel")
[10:34:17.375]                     if (exists("sendData", mode = "function", 
[10:34:17.375]                       envir = ns)) {
[10:34:17.375]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:17.375]                         envir = ns)
[10:34:17.375]                       envir <- sys.frame(frame)
[10:34:17.375]                       master <- NULL
[10:34:17.375]                       while (!identical(envir, .GlobalEnv) && 
[10:34:17.375]                         !identical(envir, emptyenv())) {
[10:34:17.375]                         if (exists("master", mode = "list", envir = envir, 
[10:34:17.375]                           inherits = FALSE)) {
[10:34:17.375]                           master <- get("master", mode = "list", 
[10:34:17.375]                             envir = envir, inherits = FALSE)
[10:34:17.375]                           if (inherits(master, c("SOCKnode", 
[10:34:17.375]                             "SOCK0node"))) {
[10:34:17.375]                             sendCondition <<- function(cond) {
[10:34:17.375]                               data <- list(type = "VALUE", value = cond, 
[10:34:17.375]                                 success = TRUE)
[10:34:17.375]                               parallel_sendData(master, data)
[10:34:17.375]                             }
[10:34:17.375]                             return(sendCondition)
[10:34:17.375]                           }
[10:34:17.375]                         }
[10:34:17.375]                         frame <- frame + 1L
[10:34:17.375]                         envir <- sys.frame(frame)
[10:34:17.375]                       }
[10:34:17.375]                     }
[10:34:17.375]                     sendCondition <<- function(cond) NULL
[10:34:17.375]                   }
[10:34:17.375]                 })
[10:34:17.375]                 withCallingHandlers({
[10:34:17.375]                   {
[10:34:17.375]                     1
[10:34:17.375]                   }
[10:34:17.375]                 }, immediateCondition = function(cond) {
[10:34:17.375]                   sendCondition <- ...future.makeSendCondition()
[10:34:17.375]                   sendCondition(cond)
[10:34:17.375]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.375]                   {
[10:34:17.375]                     inherits <- base::inherits
[10:34:17.375]                     invokeRestart <- base::invokeRestart
[10:34:17.375]                     is.null <- base::is.null
[10:34:17.375]                     muffled <- FALSE
[10:34:17.375]                     if (inherits(cond, "message")) {
[10:34:17.375]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:17.375]                       if (muffled) 
[10:34:17.375]                         invokeRestart("muffleMessage")
[10:34:17.375]                     }
[10:34:17.375]                     else if (inherits(cond, "warning")) {
[10:34:17.375]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:17.375]                       if (muffled) 
[10:34:17.375]                         invokeRestart("muffleWarning")
[10:34:17.375]                     }
[10:34:17.375]                     else if (inherits(cond, "condition")) {
[10:34:17.375]                       if (!is.null(pattern)) {
[10:34:17.375]                         computeRestarts <- base::computeRestarts
[10:34:17.375]                         grepl <- base::grepl
[10:34:17.375]                         restarts <- computeRestarts(cond)
[10:34:17.375]                         for (restart in restarts) {
[10:34:17.375]                           name <- restart$name
[10:34:17.375]                           if (is.null(name)) 
[10:34:17.375]                             next
[10:34:17.375]                           if (!grepl(pattern, name)) 
[10:34:17.375]                             next
[10:34:17.375]                           invokeRestart(restart)
[10:34:17.375]                           muffled <- TRUE
[10:34:17.375]                           break
[10:34:17.375]                         }
[10:34:17.375]                       }
[10:34:17.375]                     }
[10:34:17.375]                     invisible(muffled)
[10:34:17.375]                   }
[10:34:17.375]                   muffleCondition(cond)
[10:34:17.375]                 })
[10:34:17.375]             }))
[10:34:17.375]             future::FutureResult(value = ...future.value$value, 
[10:34:17.375]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.375]                   ...future.rng), globalenv = if (FALSE) 
[10:34:17.375]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:17.375]                     ...future.globalenv.names))
[10:34:17.375]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:17.375]         }, condition = base::local({
[10:34:17.375]             c <- base::c
[10:34:17.375]             inherits <- base::inherits
[10:34:17.375]             invokeRestart <- base::invokeRestart
[10:34:17.375]             length <- base::length
[10:34:17.375]             list <- base::list
[10:34:17.375]             seq.int <- base::seq.int
[10:34:17.375]             signalCondition <- base::signalCondition
[10:34:17.375]             sys.calls <- base::sys.calls
[10:34:17.375]             `[[` <- base::`[[`
[10:34:17.375]             `+` <- base::`+`
[10:34:17.375]             `<<-` <- base::`<<-`
[10:34:17.375]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:17.375]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:17.375]                   3L)]
[10:34:17.375]             }
[10:34:17.375]             function(cond) {
[10:34:17.375]                 is_error <- inherits(cond, "error")
[10:34:17.375]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:17.375]                   NULL)
[10:34:17.375]                 if (is_error) {
[10:34:17.375]                   sessionInformation <- function() {
[10:34:17.375]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:17.375]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:17.375]                       search = base::search(), system = base::Sys.info())
[10:34:17.375]                   }
[10:34:17.375]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.375]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:17.375]                     cond$call), session = sessionInformation(), 
[10:34:17.375]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:17.375]                   signalCondition(cond)
[10:34:17.375]                 }
[10:34:17.375]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:17.375]                 "immediateCondition"))) {
[10:34:17.375]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:17.375]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.375]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:17.375]                   if (TRUE && !signal) {
[10:34:17.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.375]                     {
[10:34:17.375]                       inherits <- base::inherits
[10:34:17.375]                       invokeRestart <- base::invokeRestart
[10:34:17.375]                       is.null <- base::is.null
[10:34:17.375]                       muffled <- FALSE
[10:34:17.375]                       if (inherits(cond, "message")) {
[10:34:17.375]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.375]                         if (muffled) 
[10:34:17.375]                           invokeRestart("muffleMessage")
[10:34:17.375]                       }
[10:34:17.375]                       else if (inherits(cond, "warning")) {
[10:34:17.375]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.375]                         if (muffled) 
[10:34:17.375]                           invokeRestart("muffleWarning")
[10:34:17.375]                       }
[10:34:17.375]                       else if (inherits(cond, "condition")) {
[10:34:17.375]                         if (!is.null(pattern)) {
[10:34:17.375]                           computeRestarts <- base::computeRestarts
[10:34:17.375]                           grepl <- base::grepl
[10:34:17.375]                           restarts <- computeRestarts(cond)
[10:34:17.375]                           for (restart in restarts) {
[10:34:17.375]                             name <- restart$name
[10:34:17.375]                             if (is.null(name)) 
[10:34:17.375]                               next
[10:34:17.375]                             if (!grepl(pattern, name)) 
[10:34:17.375]                               next
[10:34:17.375]                             invokeRestart(restart)
[10:34:17.375]                             muffled <- TRUE
[10:34:17.375]                             break
[10:34:17.375]                           }
[10:34:17.375]                         }
[10:34:17.375]                       }
[10:34:17.375]                       invisible(muffled)
[10:34:17.375]                     }
[10:34:17.375]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.375]                   }
[10:34:17.375]                 }
[10:34:17.375]                 else {
[10:34:17.375]                   if (TRUE) {
[10:34:17.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.375]                     {
[10:34:17.375]                       inherits <- base::inherits
[10:34:17.375]                       invokeRestart <- base::invokeRestart
[10:34:17.375]                       is.null <- base::is.null
[10:34:17.375]                       muffled <- FALSE
[10:34:17.375]                       if (inherits(cond, "message")) {
[10:34:17.375]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.375]                         if (muffled) 
[10:34:17.375]                           invokeRestart("muffleMessage")
[10:34:17.375]                       }
[10:34:17.375]                       else if (inherits(cond, "warning")) {
[10:34:17.375]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.375]                         if (muffled) 
[10:34:17.375]                           invokeRestart("muffleWarning")
[10:34:17.375]                       }
[10:34:17.375]                       else if (inherits(cond, "condition")) {
[10:34:17.375]                         if (!is.null(pattern)) {
[10:34:17.375]                           computeRestarts <- base::computeRestarts
[10:34:17.375]                           grepl <- base::grepl
[10:34:17.375]                           restarts <- computeRestarts(cond)
[10:34:17.375]                           for (restart in restarts) {
[10:34:17.375]                             name <- restart$name
[10:34:17.375]                             if (is.null(name)) 
[10:34:17.375]                               next
[10:34:17.375]                             if (!grepl(pattern, name)) 
[10:34:17.375]                               next
[10:34:17.375]                             invokeRestart(restart)
[10:34:17.375]                             muffled <- TRUE
[10:34:17.375]                             break
[10:34:17.375]                           }
[10:34:17.375]                         }
[10:34:17.375]                       }
[10:34:17.375]                       invisible(muffled)
[10:34:17.375]                     }
[10:34:17.375]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.375]                   }
[10:34:17.375]                 }
[10:34:17.375]             }
[10:34:17.375]         }))
[10:34:17.375]     }, error = function(ex) {
[10:34:17.375]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:17.375]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.375]                 ...future.rng), started = ...future.startTime, 
[10:34:17.375]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:17.375]             version = "1.8"), class = "FutureResult")
[10:34:17.375]     }, finally = {
[10:34:17.375]         if (!identical(...future.workdir, getwd())) 
[10:34:17.375]             setwd(...future.workdir)
[10:34:17.375]         {
[10:34:17.375]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:17.375]                 ...future.oldOptions$nwarnings <- NULL
[10:34:17.375]             }
[10:34:17.375]             base::options(...future.oldOptions)
[10:34:17.375]             if (.Platform$OS.type == "windows") {
[10:34:17.375]                 old_names <- names(...future.oldEnvVars)
[10:34:17.375]                 envs <- base::Sys.getenv()
[10:34:17.375]                 names <- names(envs)
[10:34:17.375]                 common <- intersect(names, old_names)
[10:34:17.375]                 added <- setdiff(names, old_names)
[10:34:17.375]                 removed <- setdiff(old_names, names)
[10:34:17.375]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:17.375]                   envs[common]]
[10:34:17.375]                 NAMES <- toupper(changed)
[10:34:17.375]                 args <- list()
[10:34:17.375]                 for (kk in seq_along(NAMES)) {
[10:34:17.375]                   name <- changed[[kk]]
[10:34:17.375]                   NAME <- NAMES[[kk]]
[10:34:17.375]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.375]                     next
[10:34:17.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.375]                 }
[10:34:17.375]                 NAMES <- toupper(added)
[10:34:17.375]                 for (kk in seq_along(NAMES)) {
[10:34:17.375]                   name <- added[[kk]]
[10:34:17.375]                   NAME <- NAMES[[kk]]
[10:34:17.375]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.375]                     next
[10:34:17.375]                   args[[name]] <- ""
[10:34:17.375]                 }
[10:34:17.375]                 NAMES <- toupper(removed)
[10:34:17.375]                 for (kk in seq_along(NAMES)) {
[10:34:17.375]                   name <- removed[[kk]]
[10:34:17.375]                   NAME <- NAMES[[kk]]
[10:34:17.375]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.375]                     next
[10:34:17.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.375]                 }
[10:34:17.375]                 if (length(args) > 0) 
[10:34:17.375]                   base::do.call(base::Sys.setenv, args = args)
[10:34:17.375]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:17.375]             }
[10:34:17.375]             else {
[10:34:17.375]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:17.375]             }
[10:34:17.375]             {
[10:34:17.375]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:17.375]                   0L) {
[10:34:17.375]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:17.375]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:17.375]                   base::options(opts)
[10:34:17.375]                 }
[10:34:17.375]                 {
[10:34:17.375]                   {
[10:34:17.375]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:17.375]                     NULL
[10:34:17.375]                   }
[10:34:17.375]                   options(future.plan = NULL)
[10:34:17.375]                   if (is.na(NA_character_)) 
[10:34:17.375]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.375]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:17.375]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:17.375]                     .init = FALSE)
[10:34:17.375]                 }
[10:34:17.375]             }
[10:34:17.375]         }
[10:34:17.375]     })
[10:34:17.375]     if (TRUE) {
[10:34:17.375]         base::sink(type = "output", split = FALSE)
[10:34:17.375]         if (TRUE) {
[10:34:17.375]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:17.375]         }
[10:34:17.375]         else {
[10:34:17.375]             ...future.result["stdout"] <- base::list(NULL)
[10:34:17.375]         }
[10:34:17.375]         base::close(...future.stdout)
[10:34:17.375]         ...future.stdout <- NULL
[10:34:17.375]     }
[10:34:17.375]     ...future.result$conditions <- ...future.conditions
[10:34:17.375]     ...future.result$finished <- base::Sys.time()
[10:34:17.375]     ...future.result
[10:34:17.375] }
[10:34:17.378] MultisessionFuture started
[10:34:17.378] - Launch lazy future ... done
[10:34:17.378] run() for ‘MultisessionFuture’ ... done
[10:34:17.382] getGlobalsAndPackages() ...
[10:34:17.382] Searching for globals...
[10:34:17.383] - globals found: [1] ‘{’
[10:34:17.383] Searching for globals ... DONE
[10:34:17.383] Resolving globals: FALSE
[10:34:17.383] 
[10:34:17.383] 
[10:34:17.383] getGlobalsAndPackages() ... DONE
[10:34:17.384] run() for ‘Future’ ...
[10:34:17.384] - state: ‘created’
[10:34:17.384] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:17.397] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:17.398] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:17.398]   - Field: ‘node’
[10:34:17.398]   - Field: ‘label’
[10:34:17.398]   - Field: ‘local’
[10:34:17.398]   - Field: ‘owner’
[10:34:17.398]   - Field: ‘envir’
[10:34:17.399]   - Field: ‘workers’
[10:34:17.399]   - Field: ‘packages’
[10:34:17.399]   - Field: ‘gc’
[10:34:17.399]   - Field: ‘conditions’
[10:34:17.399]   - Field: ‘persistent’
[10:34:17.399]   - Field: ‘expr’
[10:34:17.399]   - Field: ‘uuid’
[10:34:17.399]   - Field: ‘seed’
[10:34:17.400]   - Field: ‘version’
[10:34:17.400]   - Field: ‘result’
[10:34:17.400]   - Field: ‘asynchronous’
[10:34:17.400]   - Field: ‘calls’
[10:34:17.400]   - Field: ‘globals’
[10:34:17.400]   - Field: ‘stdout’
[10:34:17.400]   - Field: ‘earlySignal’
[10:34:17.401]   - Field: ‘lazy’
[10:34:17.401]   - Field: ‘state’
[10:34:17.401] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:17.401] - Launch lazy future ...
[10:34:17.401] Packages needed by the future expression (n = 0): <none>
[10:34:17.401] Packages needed by future strategies (n = 0): <none>
[10:34:17.402] {
[10:34:17.402]     {
[10:34:17.402]         {
[10:34:17.402]             ...future.startTime <- base::Sys.time()
[10:34:17.402]             {
[10:34:17.402]                 {
[10:34:17.402]                   {
[10:34:17.402]                     {
[10:34:17.402]                       base::local({
[10:34:17.402]                         has_future <- base::requireNamespace("future", 
[10:34:17.402]                           quietly = TRUE)
[10:34:17.402]                         if (has_future) {
[10:34:17.402]                           ns <- base::getNamespace("future")
[10:34:17.402]                           version <- ns[[".package"]][["version"]]
[10:34:17.402]                           if (is.null(version)) 
[10:34:17.402]                             version <- utils::packageVersion("future")
[10:34:17.402]                         }
[10:34:17.402]                         else {
[10:34:17.402]                           version <- NULL
[10:34:17.402]                         }
[10:34:17.402]                         if (!has_future || version < "1.8.0") {
[10:34:17.402]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:17.402]                             "", base::R.version$version.string), 
[10:34:17.402]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:17.402]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:17.402]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:17.402]                               "release", "version")], collapse = " "), 
[10:34:17.402]                             hostname = base::Sys.info()[["nodename"]])
[10:34:17.402]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:17.402]                             info)
[10:34:17.402]                           info <- base::paste(info, collapse = "; ")
[10:34:17.402]                           if (!has_future) {
[10:34:17.402]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:17.402]                               info)
[10:34:17.402]                           }
[10:34:17.402]                           else {
[10:34:17.402]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:17.402]                               info, version)
[10:34:17.402]                           }
[10:34:17.402]                           base::stop(msg)
[10:34:17.402]                         }
[10:34:17.402]                       })
[10:34:17.402]                     }
[10:34:17.402]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:17.402]                     base::options(mc.cores = 1L)
[10:34:17.402]                   }
[10:34:17.402]                   ...future.strategy.old <- future::plan("list")
[10:34:17.402]                   options(future.plan = NULL)
[10:34:17.402]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.402]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:17.402]                 }
[10:34:17.402]                 ...future.workdir <- getwd()
[10:34:17.402]             }
[10:34:17.402]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:17.402]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:17.402]         }
[10:34:17.402]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:17.402]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:17.402]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:17.402]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:17.402]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:17.402]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:17.402]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:17.402]             base::names(...future.oldOptions))
[10:34:17.402]     }
[10:34:17.402]     if (FALSE) {
[10:34:17.402]     }
[10:34:17.402]     else {
[10:34:17.402]         if (TRUE) {
[10:34:17.402]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:17.402]                 open = "w")
[10:34:17.402]         }
[10:34:17.402]         else {
[10:34:17.402]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:17.402]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:17.402]         }
[10:34:17.402]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:17.402]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:17.402]             base::sink(type = "output", split = FALSE)
[10:34:17.402]             base::close(...future.stdout)
[10:34:17.402]         }, add = TRUE)
[10:34:17.402]     }
[10:34:17.402]     ...future.frame <- base::sys.nframe()
[10:34:17.402]     ...future.conditions <- base::list()
[10:34:17.402]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:17.402]     if (FALSE) {
[10:34:17.402]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:17.402]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:17.402]     }
[10:34:17.402]     ...future.result <- base::tryCatch({
[10:34:17.402]         base::withCallingHandlers({
[10:34:17.402]             ...future.value <- base::withVisible(base::local({
[10:34:17.402]                 ...future.makeSendCondition <- base::local({
[10:34:17.402]                   sendCondition <- NULL
[10:34:17.402]                   function(frame = 1L) {
[10:34:17.402]                     if (is.function(sendCondition)) 
[10:34:17.402]                       return(sendCondition)
[10:34:17.402]                     ns <- getNamespace("parallel")
[10:34:17.402]                     if (exists("sendData", mode = "function", 
[10:34:17.402]                       envir = ns)) {
[10:34:17.402]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:17.402]                         envir = ns)
[10:34:17.402]                       envir <- sys.frame(frame)
[10:34:17.402]                       master <- NULL
[10:34:17.402]                       while (!identical(envir, .GlobalEnv) && 
[10:34:17.402]                         !identical(envir, emptyenv())) {
[10:34:17.402]                         if (exists("master", mode = "list", envir = envir, 
[10:34:17.402]                           inherits = FALSE)) {
[10:34:17.402]                           master <- get("master", mode = "list", 
[10:34:17.402]                             envir = envir, inherits = FALSE)
[10:34:17.402]                           if (inherits(master, c("SOCKnode", 
[10:34:17.402]                             "SOCK0node"))) {
[10:34:17.402]                             sendCondition <<- function(cond) {
[10:34:17.402]                               data <- list(type = "VALUE", value = cond, 
[10:34:17.402]                                 success = TRUE)
[10:34:17.402]                               parallel_sendData(master, data)
[10:34:17.402]                             }
[10:34:17.402]                             return(sendCondition)
[10:34:17.402]                           }
[10:34:17.402]                         }
[10:34:17.402]                         frame <- frame + 1L
[10:34:17.402]                         envir <- sys.frame(frame)
[10:34:17.402]                       }
[10:34:17.402]                     }
[10:34:17.402]                     sendCondition <<- function(cond) NULL
[10:34:17.402]                   }
[10:34:17.402]                 })
[10:34:17.402]                 withCallingHandlers({
[10:34:17.402]                   {
[10:34:17.402]                     2
[10:34:17.402]                   }
[10:34:17.402]                 }, immediateCondition = function(cond) {
[10:34:17.402]                   sendCondition <- ...future.makeSendCondition()
[10:34:17.402]                   sendCondition(cond)
[10:34:17.402]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.402]                   {
[10:34:17.402]                     inherits <- base::inherits
[10:34:17.402]                     invokeRestart <- base::invokeRestart
[10:34:17.402]                     is.null <- base::is.null
[10:34:17.402]                     muffled <- FALSE
[10:34:17.402]                     if (inherits(cond, "message")) {
[10:34:17.402]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:17.402]                       if (muffled) 
[10:34:17.402]                         invokeRestart("muffleMessage")
[10:34:17.402]                     }
[10:34:17.402]                     else if (inherits(cond, "warning")) {
[10:34:17.402]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:17.402]                       if (muffled) 
[10:34:17.402]                         invokeRestart("muffleWarning")
[10:34:17.402]                     }
[10:34:17.402]                     else if (inherits(cond, "condition")) {
[10:34:17.402]                       if (!is.null(pattern)) {
[10:34:17.402]                         computeRestarts <- base::computeRestarts
[10:34:17.402]                         grepl <- base::grepl
[10:34:17.402]                         restarts <- computeRestarts(cond)
[10:34:17.402]                         for (restart in restarts) {
[10:34:17.402]                           name <- restart$name
[10:34:17.402]                           if (is.null(name)) 
[10:34:17.402]                             next
[10:34:17.402]                           if (!grepl(pattern, name)) 
[10:34:17.402]                             next
[10:34:17.402]                           invokeRestart(restart)
[10:34:17.402]                           muffled <- TRUE
[10:34:17.402]                           break
[10:34:17.402]                         }
[10:34:17.402]                       }
[10:34:17.402]                     }
[10:34:17.402]                     invisible(muffled)
[10:34:17.402]                   }
[10:34:17.402]                   muffleCondition(cond)
[10:34:17.402]                 })
[10:34:17.402]             }))
[10:34:17.402]             future::FutureResult(value = ...future.value$value, 
[10:34:17.402]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.402]                   ...future.rng), globalenv = if (FALSE) 
[10:34:17.402]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:17.402]                     ...future.globalenv.names))
[10:34:17.402]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:17.402]         }, condition = base::local({
[10:34:17.402]             c <- base::c
[10:34:17.402]             inherits <- base::inherits
[10:34:17.402]             invokeRestart <- base::invokeRestart
[10:34:17.402]             length <- base::length
[10:34:17.402]             list <- base::list
[10:34:17.402]             seq.int <- base::seq.int
[10:34:17.402]             signalCondition <- base::signalCondition
[10:34:17.402]             sys.calls <- base::sys.calls
[10:34:17.402]             `[[` <- base::`[[`
[10:34:17.402]             `+` <- base::`+`
[10:34:17.402]             `<<-` <- base::`<<-`
[10:34:17.402]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:17.402]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:17.402]                   3L)]
[10:34:17.402]             }
[10:34:17.402]             function(cond) {
[10:34:17.402]                 is_error <- inherits(cond, "error")
[10:34:17.402]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:17.402]                   NULL)
[10:34:17.402]                 if (is_error) {
[10:34:17.402]                   sessionInformation <- function() {
[10:34:17.402]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:17.402]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:17.402]                       search = base::search(), system = base::Sys.info())
[10:34:17.402]                   }
[10:34:17.402]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.402]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:17.402]                     cond$call), session = sessionInformation(), 
[10:34:17.402]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:17.402]                   signalCondition(cond)
[10:34:17.402]                 }
[10:34:17.402]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:17.402]                 "immediateCondition"))) {
[10:34:17.402]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:17.402]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.402]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:17.402]                   if (TRUE && !signal) {
[10:34:17.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.402]                     {
[10:34:17.402]                       inherits <- base::inherits
[10:34:17.402]                       invokeRestart <- base::invokeRestart
[10:34:17.402]                       is.null <- base::is.null
[10:34:17.402]                       muffled <- FALSE
[10:34:17.402]                       if (inherits(cond, "message")) {
[10:34:17.402]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.402]                         if (muffled) 
[10:34:17.402]                           invokeRestart("muffleMessage")
[10:34:17.402]                       }
[10:34:17.402]                       else if (inherits(cond, "warning")) {
[10:34:17.402]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.402]                         if (muffled) 
[10:34:17.402]                           invokeRestart("muffleWarning")
[10:34:17.402]                       }
[10:34:17.402]                       else if (inherits(cond, "condition")) {
[10:34:17.402]                         if (!is.null(pattern)) {
[10:34:17.402]                           computeRestarts <- base::computeRestarts
[10:34:17.402]                           grepl <- base::grepl
[10:34:17.402]                           restarts <- computeRestarts(cond)
[10:34:17.402]                           for (restart in restarts) {
[10:34:17.402]                             name <- restart$name
[10:34:17.402]                             if (is.null(name)) 
[10:34:17.402]                               next
[10:34:17.402]                             if (!grepl(pattern, name)) 
[10:34:17.402]                               next
[10:34:17.402]                             invokeRestart(restart)
[10:34:17.402]                             muffled <- TRUE
[10:34:17.402]                             break
[10:34:17.402]                           }
[10:34:17.402]                         }
[10:34:17.402]                       }
[10:34:17.402]                       invisible(muffled)
[10:34:17.402]                     }
[10:34:17.402]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.402]                   }
[10:34:17.402]                 }
[10:34:17.402]                 else {
[10:34:17.402]                   if (TRUE) {
[10:34:17.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.402]                     {
[10:34:17.402]                       inherits <- base::inherits
[10:34:17.402]                       invokeRestart <- base::invokeRestart
[10:34:17.402]                       is.null <- base::is.null
[10:34:17.402]                       muffled <- FALSE
[10:34:17.402]                       if (inherits(cond, "message")) {
[10:34:17.402]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.402]                         if (muffled) 
[10:34:17.402]                           invokeRestart("muffleMessage")
[10:34:17.402]                       }
[10:34:17.402]                       else if (inherits(cond, "warning")) {
[10:34:17.402]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.402]                         if (muffled) 
[10:34:17.402]                           invokeRestart("muffleWarning")
[10:34:17.402]                       }
[10:34:17.402]                       else if (inherits(cond, "condition")) {
[10:34:17.402]                         if (!is.null(pattern)) {
[10:34:17.402]                           computeRestarts <- base::computeRestarts
[10:34:17.402]                           grepl <- base::grepl
[10:34:17.402]                           restarts <- computeRestarts(cond)
[10:34:17.402]                           for (restart in restarts) {
[10:34:17.402]                             name <- restart$name
[10:34:17.402]                             if (is.null(name)) 
[10:34:17.402]                               next
[10:34:17.402]                             if (!grepl(pattern, name)) 
[10:34:17.402]                               next
[10:34:17.402]                             invokeRestart(restart)
[10:34:17.402]                             muffled <- TRUE
[10:34:17.402]                             break
[10:34:17.402]                           }
[10:34:17.402]                         }
[10:34:17.402]                       }
[10:34:17.402]                       invisible(muffled)
[10:34:17.402]                     }
[10:34:17.402]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.402]                   }
[10:34:17.402]                 }
[10:34:17.402]             }
[10:34:17.402]         }))
[10:34:17.402]     }, error = function(ex) {
[10:34:17.402]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:17.402]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.402]                 ...future.rng), started = ...future.startTime, 
[10:34:17.402]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:17.402]             version = "1.8"), class = "FutureResult")
[10:34:17.402]     }, finally = {
[10:34:17.402]         if (!identical(...future.workdir, getwd())) 
[10:34:17.402]             setwd(...future.workdir)
[10:34:17.402]         {
[10:34:17.402]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:17.402]                 ...future.oldOptions$nwarnings <- NULL
[10:34:17.402]             }
[10:34:17.402]             base::options(...future.oldOptions)
[10:34:17.402]             if (.Platform$OS.type == "windows") {
[10:34:17.402]                 old_names <- names(...future.oldEnvVars)
[10:34:17.402]                 envs <- base::Sys.getenv()
[10:34:17.402]                 names <- names(envs)
[10:34:17.402]                 common <- intersect(names, old_names)
[10:34:17.402]                 added <- setdiff(names, old_names)
[10:34:17.402]                 removed <- setdiff(old_names, names)
[10:34:17.402]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:17.402]                   envs[common]]
[10:34:17.402]                 NAMES <- toupper(changed)
[10:34:17.402]                 args <- list()
[10:34:17.402]                 for (kk in seq_along(NAMES)) {
[10:34:17.402]                   name <- changed[[kk]]
[10:34:17.402]                   NAME <- NAMES[[kk]]
[10:34:17.402]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.402]                     next
[10:34:17.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.402]                 }
[10:34:17.402]                 NAMES <- toupper(added)
[10:34:17.402]                 for (kk in seq_along(NAMES)) {
[10:34:17.402]                   name <- added[[kk]]
[10:34:17.402]                   NAME <- NAMES[[kk]]
[10:34:17.402]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.402]                     next
[10:34:17.402]                   args[[name]] <- ""
[10:34:17.402]                 }
[10:34:17.402]                 NAMES <- toupper(removed)
[10:34:17.402]                 for (kk in seq_along(NAMES)) {
[10:34:17.402]                   name <- removed[[kk]]
[10:34:17.402]                   NAME <- NAMES[[kk]]
[10:34:17.402]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.402]                     next
[10:34:17.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.402]                 }
[10:34:17.402]                 if (length(args) > 0) 
[10:34:17.402]                   base::do.call(base::Sys.setenv, args = args)
[10:34:17.402]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:17.402]             }
[10:34:17.402]             else {
[10:34:17.402]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:17.402]             }
[10:34:17.402]             {
[10:34:17.402]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:17.402]                   0L) {
[10:34:17.402]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:17.402]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:17.402]                   base::options(opts)
[10:34:17.402]                 }
[10:34:17.402]                 {
[10:34:17.402]                   {
[10:34:17.402]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:17.402]                     NULL
[10:34:17.402]                   }
[10:34:17.402]                   options(future.plan = NULL)
[10:34:17.402]                   if (is.na(NA_character_)) 
[10:34:17.402]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.402]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:17.402]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:17.402]                     .init = FALSE)
[10:34:17.402]                 }
[10:34:17.402]             }
[10:34:17.402]         }
[10:34:17.402]     })
[10:34:17.402]     if (TRUE) {
[10:34:17.402]         base::sink(type = "output", split = FALSE)
[10:34:17.402]         if (TRUE) {
[10:34:17.402]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:17.402]         }
[10:34:17.402]         else {
[10:34:17.402]             ...future.result["stdout"] <- base::list(NULL)
[10:34:17.402]         }
[10:34:17.402]         base::close(...future.stdout)
[10:34:17.402]         ...future.stdout <- NULL
[10:34:17.402]     }
[10:34:17.402]     ...future.result$conditions <- ...future.conditions
[10:34:17.402]     ...future.result$finished <- base::Sys.time()
[10:34:17.402]     ...future.result
[10:34:17.402] }
[10:34:17.406] MultisessionFuture started
[10:34:17.406] - Launch lazy future ... done
[10:34:17.406] run() for ‘MultisessionFuture’ ... done
[10:34:17.406] resolve() on environment ...
[10:34:17.407]  recursive: 0
[10:34:17.407]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[10:34:17.407] receiveMessageFromWorker() for ClusterFuture ...
[10:34:17.408] - Validating connection of MultisessionFuture
[10:34:17.408] - received message: FutureResult
[10:34:17.408] - Received FutureResult
[10:34:17.408] - Erased future from FutureRegistry
[10:34:17.408] result() for ClusterFuture ...
[10:34:17.408] - result already collected: FutureResult
[10:34:17.408] result() for ClusterFuture ... done
[10:34:17.408] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:17.408] Future #1
[10:34:17.409]  length: 2 (resolved future 1)
[10:34:17.409] receiveMessageFromWorker() for ClusterFuture ...
[10:34:17.409] - Validating connection of MultisessionFuture
[10:34:17.409] - received message: FutureResult
[10:34:17.409] - Received FutureResult
[10:34:17.409] - Erased future from FutureRegistry
[10:34:17.410] result() for ClusterFuture ...
[10:34:17.410] - result already collected: FutureResult
[10:34:17.410] result() for ClusterFuture ... done
[10:34:17.410] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:17.410] Future #2
[10:34:17.410]  length: 1 (resolved future 2)
[10:34:17.410]  length: 0 (resolved future 3)
[10:34:17.410] resolve() on environment ... DONE
[10:34:17.411] getGlobalsAndPackages() ...
[10:34:17.411] Searching for globals...
[10:34:17.411] - globals found: [1] ‘{’
[10:34:17.411] Searching for globals ... DONE
[10:34:17.411] Resolving globals: FALSE
[10:34:17.412] 
[10:34:17.412] 
[10:34:17.412] getGlobalsAndPackages() ... DONE
[10:34:17.412] run() for ‘Future’ ...
[10:34:17.412] - state: ‘created’
[10:34:17.412] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:17.427] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:17.427] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:17.427]   - Field: ‘node’
[10:34:17.427]   - Field: ‘label’
[10:34:17.427]   - Field: ‘local’
[10:34:17.427]   - Field: ‘owner’
[10:34:17.427]   - Field: ‘envir’
[10:34:17.427]   - Field: ‘workers’
[10:34:17.427]   - Field: ‘packages’
[10:34:17.427]   - Field: ‘gc’
[10:34:17.428]   - Field: ‘conditions’
[10:34:17.428]   - Field: ‘persistent’
[10:34:17.428]   - Field: ‘expr’
[10:34:17.428]   - Field: ‘uuid’
[10:34:17.428]   - Field: ‘seed’
[10:34:17.428]   - Field: ‘version’
[10:34:17.428]   - Field: ‘result’
[10:34:17.428]   - Field: ‘asynchronous’
[10:34:17.428]   - Field: ‘calls’
[10:34:17.428]   - Field: ‘globals’
[10:34:17.428]   - Field: ‘stdout’
[10:34:17.429]   - Field: ‘earlySignal’
[10:34:17.429]   - Field: ‘lazy’
[10:34:17.429]   - Field: ‘state’
[10:34:17.429] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:17.429] - Launch lazy future ...
[10:34:17.429] Packages needed by the future expression (n = 0): <none>
[10:34:17.429] Packages needed by future strategies (n = 0): <none>
[10:34:17.430] {
[10:34:17.430]     {
[10:34:17.430]         {
[10:34:17.430]             ...future.startTime <- base::Sys.time()
[10:34:17.430]             {
[10:34:17.430]                 {
[10:34:17.430]                   {
[10:34:17.430]                     {
[10:34:17.430]                       base::local({
[10:34:17.430]                         has_future <- base::requireNamespace("future", 
[10:34:17.430]                           quietly = TRUE)
[10:34:17.430]                         if (has_future) {
[10:34:17.430]                           ns <- base::getNamespace("future")
[10:34:17.430]                           version <- ns[[".package"]][["version"]]
[10:34:17.430]                           if (is.null(version)) 
[10:34:17.430]                             version <- utils::packageVersion("future")
[10:34:17.430]                         }
[10:34:17.430]                         else {
[10:34:17.430]                           version <- NULL
[10:34:17.430]                         }
[10:34:17.430]                         if (!has_future || version < "1.8.0") {
[10:34:17.430]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:17.430]                             "", base::R.version$version.string), 
[10:34:17.430]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:17.430]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:17.430]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:17.430]                               "release", "version")], collapse = " "), 
[10:34:17.430]                             hostname = base::Sys.info()[["nodename"]])
[10:34:17.430]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:17.430]                             info)
[10:34:17.430]                           info <- base::paste(info, collapse = "; ")
[10:34:17.430]                           if (!has_future) {
[10:34:17.430]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:17.430]                               info)
[10:34:17.430]                           }
[10:34:17.430]                           else {
[10:34:17.430]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:17.430]                               info, version)
[10:34:17.430]                           }
[10:34:17.430]                           base::stop(msg)
[10:34:17.430]                         }
[10:34:17.430]                       })
[10:34:17.430]                     }
[10:34:17.430]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:17.430]                     base::options(mc.cores = 1L)
[10:34:17.430]                   }
[10:34:17.430]                   ...future.strategy.old <- future::plan("list")
[10:34:17.430]                   options(future.plan = NULL)
[10:34:17.430]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.430]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:17.430]                 }
[10:34:17.430]                 ...future.workdir <- getwd()
[10:34:17.430]             }
[10:34:17.430]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:17.430]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:17.430]         }
[10:34:17.430]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:17.430]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:17.430]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:17.430]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:17.430]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:17.430]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:17.430]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:17.430]             base::names(...future.oldOptions))
[10:34:17.430]     }
[10:34:17.430]     if (FALSE) {
[10:34:17.430]     }
[10:34:17.430]     else {
[10:34:17.430]         if (TRUE) {
[10:34:17.430]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:17.430]                 open = "w")
[10:34:17.430]         }
[10:34:17.430]         else {
[10:34:17.430]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:17.430]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:17.430]         }
[10:34:17.430]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:17.430]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:17.430]             base::sink(type = "output", split = FALSE)
[10:34:17.430]             base::close(...future.stdout)
[10:34:17.430]         }, add = TRUE)
[10:34:17.430]     }
[10:34:17.430]     ...future.frame <- base::sys.nframe()
[10:34:17.430]     ...future.conditions <- base::list()
[10:34:17.430]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:17.430]     if (FALSE) {
[10:34:17.430]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:17.430]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:17.430]     }
[10:34:17.430]     ...future.result <- base::tryCatch({
[10:34:17.430]         base::withCallingHandlers({
[10:34:17.430]             ...future.value <- base::withVisible(base::local({
[10:34:17.430]                 ...future.makeSendCondition <- base::local({
[10:34:17.430]                   sendCondition <- NULL
[10:34:17.430]                   function(frame = 1L) {
[10:34:17.430]                     if (is.function(sendCondition)) 
[10:34:17.430]                       return(sendCondition)
[10:34:17.430]                     ns <- getNamespace("parallel")
[10:34:17.430]                     if (exists("sendData", mode = "function", 
[10:34:17.430]                       envir = ns)) {
[10:34:17.430]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:17.430]                         envir = ns)
[10:34:17.430]                       envir <- sys.frame(frame)
[10:34:17.430]                       master <- NULL
[10:34:17.430]                       while (!identical(envir, .GlobalEnv) && 
[10:34:17.430]                         !identical(envir, emptyenv())) {
[10:34:17.430]                         if (exists("master", mode = "list", envir = envir, 
[10:34:17.430]                           inherits = FALSE)) {
[10:34:17.430]                           master <- get("master", mode = "list", 
[10:34:17.430]                             envir = envir, inherits = FALSE)
[10:34:17.430]                           if (inherits(master, c("SOCKnode", 
[10:34:17.430]                             "SOCK0node"))) {
[10:34:17.430]                             sendCondition <<- function(cond) {
[10:34:17.430]                               data <- list(type = "VALUE", value = cond, 
[10:34:17.430]                                 success = TRUE)
[10:34:17.430]                               parallel_sendData(master, data)
[10:34:17.430]                             }
[10:34:17.430]                             return(sendCondition)
[10:34:17.430]                           }
[10:34:17.430]                         }
[10:34:17.430]                         frame <- frame + 1L
[10:34:17.430]                         envir <- sys.frame(frame)
[10:34:17.430]                       }
[10:34:17.430]                     }
[10:34:17.430]                     sendCondition <<- function(cond) NULL
[10:34:17.430]                   }
[10:34:17.430]                 })
[10:34:17.430]                 withCallingHandlers({
[10:34:17.430]                   {
[10:34:17.430]                     1
[10:34:17.430]                   }
[10:34:17.430]                 }, immediateCondition = function(cond) {
[10:34:17.430]                   sendCondition <- ...future.makeSendCondition()
[10:34:17.430]                   sendCondition(cond)
[10:34:17.430]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.430]                   {
[10:34:17.430]                     inherits <- base::inherits
[10:34:17.430]                     invokeRestart <- base::invokeRestart
[10:34:17.430]                     is.null <- base::is.null
[10:34:17.430]                     muffled <- FALSE
[10:34:17.430]                     if (inherits(cond, "message")) {
[10:34:17.430]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:17.430]                       if (muffled) 
[10:34:17.430]                         invokeRestart("muffleMessage")
[10:34:17.430]                     }
[10:34:17.430]                     else if (inherits(cond, "warning")) {
[10:34:17.430]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:17.430]                       if (muffled) 
[10:34:17.430]                         invokeRestart("muffleWarning")
[10:34:17.430]                     }
[10:34:17.430]                     else if (inherits(cond, "condition")) {
[10:34:17.430]                       if (!is.null(pattern)) {
[10:34:17.430]                         computeRestarts <- base::computeRestarts
[10:34:17.430]                         grepl <- base::grepl
[10:34:17.430]                         restarts <- computeRestarts(cond)
[10:34:17.430]                         for (restart in restarts) {
[10:34:17.430]                           name <- restart$name
[10:34:17.430]                           if (is.null(name)) 
[10:34:17.430]                             next
[10:34:17.430]                           if (!grepl(pattern, name)) 
[10:34:17.430]                             next
[10:34:17.430]                           invokeRestart(restart)
[10:34:17.430]                           muffled <- TRUE
[10:34:17.430]                           break
[10:34:17.430]                         }
[10:34:17.430]                       }
[10:34:17.430]                     }
[10:34:17.430]                     invisible(muffled)
[10:34:17.430]                   }
[10:34:17.430]                   muffleCondition(cond)
[10:34:17.430]                 })
[10:34:17.430]             }))
[10:34:17.430]             future::FutureResult(value = ...future.value$value, 
[10:34:17.430]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.430]                   ...future.rng), globalenv = if (FALSE) 
[10:34:17.430]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:17.430]                     ...future.globalenv.names))
[10:34:17.430]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:17.430]         }, condition = base::local({
[10:34:17.430]             c <- base::c
[10:34:17.430]             inherits <- base::inherits
[10:34:17.430]             invokeRestart <- base::invokeRestart
[10:34:17.430]             length <- base::length
[10:34:17.430]             list <- base::list
[10:34:17.430]             seq.int <- base::seq.int
[10:34:17.430]             signalCondition <- base::signalCondition
[10:34:17.430]             sys.calls <- base::sys.calls
[10:34:17.430]             `[[` <- base::`[[`
[10:34:17.430]             `+` <- base::`+`
[10:34:17.430]             `<<-` <- base::`<<-`
[10:34:17.430]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:17.430]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:17.430]                   3L)]
[10:34:17.430]             }
[10:34:17.430]             function(cond) {
[10:34:17.430]                 is_error <- inherits(cond, "error")
[10:34:17.430]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:17.430]                   NULL)
[10:34:17.430]                 if (is_error) {
[10:34:17.430]                   sessionInformation <- function() {
[10:34:17.430]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:17.430]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:17.430]                       search = base::search(), system = base::Sys.info())
[10:34:17.430]                   }
[10:34:17.430]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.430]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:17.430]                     cond$call), session = sessionInformation(), 
[10:34:17.430]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:17.430]                   signalCondition(cond)
[10:34:17.430]                 }
[10:34:17.430]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:17.430]                 "immediateCondition"))) {
[10:34:17.430]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:17.430]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.430]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:17.430]                   if (TRUE && !signal) {
[10:34:17.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.430]                     {
[10:34:17.430]                       inherits <- base::inherits
[10:34:17.430]                       invokeRestart <- base::invokeRestart
[10:34:17.430]                       is.null <- base::is.null
[10:34:17.430]                       muffled <- FALSE
[10:34:17.430]                       if (inherits(cond, "message")) {
[10:34:17.430]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.430]                         if (muffled) 
[10:34:17.430]                           invokeRestart("muffleMessage")
[10:34:17.430]                       }
[10:34:17.430]                       else if (inherits(cond, "warning")) {
[10:34:17.430]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.430]                         if (muffled) 
[10:34:17.430]                           invokeRestart("muffleWarning")
[10:34:17.430]                       }
[10:34:17.430]                       else if (inherits(cond, "condition")) {
[10:34:17.430]                         if (!is.null(pattern)) {
[10:34:17.430]                           computeRestarts <- base::computeRestarts
[10:34:17.430]                           grepl <- base::grepl
[10:34:17.430]                           restarts <- computeRestarts(cond)
[10:34:17.430]                           for (restart in restarts) {
[10:34:17.430]                             name <- restart$name
[10:34:17.430]                             if (is.null(name)) 
[10:34:17.430]                               next
[10:34:17.430]                             if (!grepl(pattern, name)) 
[10:34:17.430]                               next
[10:34:17.430]                             invokeRestart(restart)
[10:34:17.430]                             muffled <- TRUE
[10:34:17.430]                             break
[10:34:17.430]                           }
[10:34:17.430]                         }
[10:34:17.430]                       }
[10:34:17.430]                       invisible(muffled)
[10:34:17.430]                     }
[10:34:17.430]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.430]                   }
[10:34:17.430]                 }
[10:34:17.430]                 else {
[10:34:17.430]                   if (TRUE) {
[10:34:17.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.430]                     {
[10:34:17.430]                       inherits <- base::inherits
[10:34:17.430]                       invokeRestart <- base::invokeRestart
[10:34:17.430]                       is.null <- base::is.null
[10:34:17.430]                       muffled <- FALSE
[10:34:17.430]                       if (inherits(cond, "message")) {
[10:34:17.430]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.430]                         if (muffled) 
[10:34:17.430]                           invokeRestart("muffleMessage")
[10:34:17.430]                       }
[10:34:17.430]                       else if (inherits(cond, "warning")) {
[10:34:17.430]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.430]                         if (muffled) 
[10:34:17.430]                           invokeRestart("muffleWarning")
[10:34:17.430]                       }
[10:34:17.430]                       else if (inherits(cond, "condition")) {
[10:34:17.430]                         if (!is.null(pattern)) {
[10:34:17.430]                           computeRestarts <- base::computeRestarts
[10:34:17.430]                           grepl <- base::grepl
[10:34:17.430]                           restarts <- computeRestarts(cond)
[10:34:17.430]                           for (restart in restarts) {
[10:34:17.430]                             name <- restart$name
[10:34:17.430]                             if (is.null(name)) 
[10:34:17.430]                               next
[10:34:17.430]                             if (!grepl(pattern, name)) 
[10:34:17.430]                               next
[10:34:17.430]                             invokeRestart(restart)
[10:34:17.430]                             muffled <- TRUE
[10:34:17.430]                             break
[10:34:17.430]                           }
[10:34:17.430]                         }
[10:34:17.430]                       }
[10:34:17.430]                       invisible(muffled)
[10:34:17.430]                     }
[10:34:17.430]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.430]                   }
[10:34:17.430]                 }
[10:34:17.430]             }
[10:34:17.430]         }))
[10:34:17.430]     }, error = function(ex) {
[10:34:17.430]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:17.430]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.430]                 ...future.rng), started = ...future.startTime, 
[10:34:17.430]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:17.430]             version = "1.8"), class = "FutureResult")
[10:34:17.430]     }, finally = {
[10:34:17.430]         if (!identical(...future.workdir, getwd())) 
[10:34:17.430]             setwd(...future.workdir)
[10:34:17.430]         {
[10:34:17.430]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:17.430]                 ...future.oldOptions$nwarnings <- NULL
[10:34:17.430]             }
[10:34:17.430]             base::options(...future.oldOptions)
[10:34:17.430]             if (.Platform$OS.type == "windows") {
[10:34:17.430]                 old_names <- names(...future.oldEnvVars)
[10:34:17.430]                 envs <- base::Sys.getenv()
[10:34:17.430]                 names <- names(envs)
[10:34:17.430]                 common <- intersect(names, old_names)
[10:34:17.430]                 added <- setdiff(names, old_names)
[10:34:17.430]                 removed <- setdiff(old_names, names)
[10:34:17.430]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:17.430]                   envs[common]]
[10:34:17.430]                 NAMES <- toupper(changed)
[10:34:17.430]                 args <- list()
[10:34:17.430]                 for (kk in seq_along(NAMES)) {
[10:34:17.430]                   name <- changed[[kk]]
[10:34:17.430]                   NAME <- NAMES[[kk]]
[10:34:17.430]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.430]                     next
[10:34:17.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.430]                 }
[10:34:17.430]                 NAMES <- toupper(added)
[10:34:17.430]                 for (kk in seq_along(NAMES)) {
[10:34:17.430]                   name <- added[[kk]]
[10:34:17.430]                   NAME <- NAMES[[kk]]
[10:34:17.430]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.430]                     next
[10:34:17.430]                   args[[name]] <- ""
[10:34:17.430]                 }
[10:34:17.430]                 NAMES <- toupper(removed)
[10:34:17.430]                 for (kk in seq_along(NAMES)) {
[10:34:17.430]                   name <- removed[[kk]]
[10:34:17.430]                   NAME <- NAMES[[kk]]
[10:34:17.430]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.430]                     next
[10:34:17.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.430]                 }
[10:34:17.430]                 if (length(args) > 0) 
[10:34:17.430]                   base::do.call(base::Sys.setenv, args = args)
[10:34:17.430]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:17.430]             }
[10:34:17.430]             else {
[10:34:17.430]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:17.430]             }
[10:34:17.430]             {
[10:34:17.430]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:17.430]                   0L) {
[10:34:17.430]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:17.430]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:17.430]                   base::options(opts)
[10:34:17.430]                 }
[10:34:17.430]                 {
[10:34:17.430]                   {
[10:34:17.430]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:17.430]                     NULL
[10:34:17.430]                   }
[10:34:17.430]                   options(future.plan = NULL)
[10:34:17.430]                   if (is.na(NA_character_)) 
[10:34:17.430]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.430]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:17.430]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:17.430]                     .init = FALSE)
[10:34:17.430]                 }
[10:34:17.430]             }
[10:34:17.430]         }
[10:34:17.430]     })
[10:34:17.430]     if (TRUE) {
[10:34:17.430]         base::sink(type = "output", split = FALSE)
[10:34:17.430]         if (TRUE) {
[10:34:17.430]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:17.430]         }
[10:34:17.430]         else {
[10:34:17.430]             ...future.result["stdout"] <- base::list(NULL)
[10:34:17.430]         }
[10:34:17.430]         base::close(...future.stdout)
[10:34:17.430]         ...future.stdout <- NULL
[10:34:17.430]     }
[10:34:17.430]     ...future.result$conditions <- ...future.conditions
[10:34:17.430]     ...future.result$finished <- base::Sys.time()
[10:34:17.430]     ...future.result
[10:34:17.430] }
[10:34:17.433] MultisessionFuture started
[10:34:17.433] - Launch lazy future ... done
[10:34:17.433] run() for ‘MultisessionFuture’ ... done
[10:34:17.433] getGlobalsAndPackages() ...
[10:34:17.433] Searching for globals...
[10:34:17.434] - globals found: [1] ‘{’
[10:34:17.434] Searching for globals ... DONE
[10:34:17.434] Resolving globals: FALSE
[10:34:17.434] 
[10:34:17.434] 
[10:34:17.435] getGlobalsAndPackages() ... DONE
[10:34:17.435] run() for ‘Future’ ...
[10:34:17.435] - state: ‘created’
[10:34:17.435] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:17.449] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:17.449] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:17.450]   - Field: ‘node’
[10:34:17.450]   - Field: ‘label’
[10:34:17.450]   - Field: ‘local’
[10:34:17.450]   - Field: ‘owner’
[10:34:17.450]   - Field: ‘envir’
[10:34:17.450]   - Field: ‘workers’
[10:34:17.450]   - Field: ‘packages’
[10:34:17.450]   - Field: ‘gc’
[10:34:17.450]   - Field: ‘conditions’
[10:34:17.450]   - Field: ‘persistent’
[10:34:17.450]   - Field: ‘expr’
[10:34:17.451]   - Field: ‘uuid’
[10:34:17.451]   - Field: ‘seed’
[10:34:17.451]   - Field: ‘version’
[10:34:17.451]   - Field: ‘result’
[10:34:17.451]   - Field: ‘asynchronous’
[10:34:17.451]   - Field: ‘calls’
[10:34:17.451]   - Field: ‘globals’
[10:34:17.451]   - Field: ‘stdout’
[10:34:17.451]   - Field: ‘earlySignal’
[10:34:17.451]   - Field: ‘lazy’
[10:34:17.451]   - Field: ‘state’
[10:34:17.452] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:17.452] - Launch lazy future ...
[10:34:17.452] Packages needed by the future expression (n = 0): <none>
[10:34:17.452] Packages needed by future strategies (n = 0): <none>
[10:34:17.452] {
[10:34:17.452]     {
[10:34:17.452]         {
[10:34:17.452]             ...future.startTime <- base::Sys.time()
[10:34:17.452]             {
[10:34:17.452]                 {
[10:34:17.452]                   {
[10:34:17.452]                     {
[10:34:17.452]                       base::local({
[10:34:17.452]                         has_future <- base::requireNamespace("future", 
[10:34:17.452]                           quietly = TRUE)
[10:34:17.452]                         if (has_future) {
[10:34:17.452]                           ns <- base::getNamespace("future")
[10:34:17.452]                           version <- ns[[".package"]][["version"]]
[10:34:17.452]                           if (is.null(version)) 
[10:34:17.452]                             version <- utils::packageVersion("future")
[10:34:17.452]                         }
[10:34:17.452]                         else {
[10:34:17.452]                           version <- NULL
[10:34:17.452]                         }
[10:34:17.452]                         if (!has_future || version < "1.8.0") {
[10:34:17.452]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:17.452]                             "", base::R.version$version.string), 
[10:34:17.452]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:17.452]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:17.452]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:17.452]                               "release", "version")], collapse = " "), 
[10:34:17.452]                             hostname = base::Sys.info()[["nodename"]])
[10:34:17.452]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:17.452]                             info)
[10:34:17.452]                           info <- base::paste(info, collapse = "; ")
[10:34:17.452]                           if (!has_future) {
[10:34:17.452]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:17.452]                               info)
[10:34:17.452]                           }
[10:34:17.452]                           else {
[10:34:17.452]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:17.452]                               info, version)
[10:34:17.452]                           }
[10:34:17.452]                           base::stop(msg)
[10:34:17.452]                         }
[10:34:17.452]                       })
[10:34:17.452]                     }
[10:34:17.452]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:17.452]                     base::options(mc.cores = 1L)
[10:34:17.452]                   }
[10:34:17.452]                   ...future.strategy.old <- future::plan("list")
[10:34:17.452]                   options(future.plan = NULL)
[10:34:17.452]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.452]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:17.452]                 }
[10:34:17.452]                 ...future.workdir <- getwd()
[10:34:17.452]             }
[10:34:17.452]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:17.452]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:17.452]         }
[10:34:17.452]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:17.452]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:17.452]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:17.452]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:17.452]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:17.452]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:17.452]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:17.452]             base::names(...future.oldOptions))
[10:34:17.452]     }
[10:34:17.452]     if (FALSE) {
[10:34:17.452]     }
[10:34:17.452]     else {
[10:34:17.452]         if (TRUE) {
[10:34:17.452]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:17.452]                 open = "w")
[10:34:17.452]         }
[10:34:17.452]         else {
[10:34:17.452]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:17.452]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:17.452]         }
[10:34:17.452]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:17.452]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:17.452]             base::sink(type = "output", split = FALSE)
[10:34:17.452]             base::close(...future.stdout)
[10:34:17.452]         }, add = TRUE)
[10:34:17.452]     }
[10:34:17.452]     ...future.frame <- base::sys.nframe()
[10:34:17.452]     ...future.conditions <- base::list()
[10:34:17.452]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:17.452]     if (FALSE) {
[10:34:17.452]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:17.452]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:17.452]     }
[10:34:17.452]     ...future.result <- base::tryCatch({
[10:34:17.452]         base::withCallingHandlers({
[10:34:17.452]             ...future.value <- base::withVisible(base::local({
[10:34:17.452]                 ...future.makeSendCondition <- base::local({
[10:34:17.452]                   sendCondition <- NULL
[10:34:17.452]                   function(frame = 1L) {
[10:34:17.452]                     if (is.function(sendCondition)) 
[10:34:17.452]                       return(sendCondition)
[10:34:17.452]                     ns <- getNamespace("parallel")
[10:34:17.452]                     if (exists("sendData", mode = "function", 
[10:34:17.452]                       envir = ns)) {
[10:34:17.452]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:17.452]                         envir = ns)
[10:34:17.452]                       envir <- sys.frame(frame)
[10:34:17.452]                       master <- NULL
[10:34:17.452]                       while (!identical(envir, .GlobalEnv) && 
[10:34:17.452]                         !identical(envir, emptyenv())) {
[10:34:17.452]                         if (exists("master", mode = "list", envir = envir, 
[10:34:17.452]                           inherits = FALSE)) {
[10:34:17.452]                           master <- get("master", mode = "list", 
[10:34:17.452]                             envir = envir, inherits = FALSE)
[10:34:17.452]                           if (inherits(master, c("SOCKnode", 
[10:34:17.452]                             "SOCK0node"))) {
[10:34:17.452]                             sendCondition <<- function(cond) {
[10:34:17.452]                               data <- list(type = "VALUE", value = cond, 
[10:34:17.452]                                 success = TRUE)
[10:34:17.452]                               parallel_sendData(master, data)
[10:34:17.452]                             }
[10:34:17.452]                             return(sendCondition)
[10:34:17.452]                           }
[10:34:17.452]                         }
[10:34:17.452]                         frame <- frame + 1L
[10:34:17.452]                         envir <- sys.frame(frame)
[10:34:17.452]                       }
[10:34:17.452]                     }
[10:34:17.452]                     sendCondition <<- function(cond) NULL
[10:34:17.452]                   }
[10:34:17.452]                 })
[10:34:17.452]                 withCallingHandlers({
[10:34:17.452]                   {
[10:34:17.452]                     2
[10:34:17.452]                   }
[10:34:17.452]                 }, immediateCondition = function(cond) {
[10:34:17.452]                   sendCondition <- ...future.makeSendCondition()
[10:34:17.452]                   sendCondition(cond)
[10:34:17.452]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.452]                   {
[10:34:17.452]                     inherits <- base::inherits
[10:34:17.452]                     invokeRestart <- base::invokeRestart
[10:34:17.452]                     is.null <- base::is.null
[10:34:17.452]                     muffled <- FALSE
[10:34:17.452]                     if (inherits(cond, "message")) {
[10:34:17.452]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:17.452]                       if (muffled) 
[10:34:17.452]                         invokeRestart("muffleMessage")
[10:34:17.452]                     }
[10:34:17.452]                     else if (inherits(cond, "warning")) {
[10:34:17.452]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:17.452]                       if (muffled) 
[10:34:17.452]                         invokeRestart("muffleWarning")
[10:34:17.452]                     }
[10:34:17.452]                     else if (inherits(cond, "condition")) {
[10:34:17.452]                       if (!is.null(pattern)) {
[10:34:17.452]                         computeRestarts <- base::computeRestarts
[10:34:17.452]                         grepl <- base::grepl
[10:34:17.452]                         restarts <- computeRestarts(cond)
[10:34:17.452]                         for (restart in restarts) {
[10:34:17.452]                           name <- restart$name
[10:34:17.452]                           if (is.null(name)) 
[10:34:17.452]                             next
[10:34:17.452]                           if (!grepl(pattern, name)) 
[10:34:17.452]                             next
[10:34:17.452]                           invokeRestart(restart)
[10:34:17.452]                           muffled <- TRUE
[10:34:17.452]                           break
[10:34:17.452]                         }
[10:34:17.452]                       }
[10:34:17.452]                     }
[10:34:17.452]                     invisible(muffled)
[10:34:17.452]                   }
[10:34:17.452]                   muffleCondition(cond)
[10:34:17.452]                 })
[10:34:17.452]             }))
[10:34:17.452]             future::FutureResult(value = ...future.value$value, 
[10:34:17.452]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.452]                   ...future.rng), globalenv = if (FALSE) 
[10:34:17.452]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:17.452]                     ...future.globalenv.names))
[10:34:17.452]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:17.452]         }, condition = base::local({
[10:34:17.452]             c <- base::c
[10:34:17.452]             inherits <- base::inherits
[10:34:17.452]             invokeRestart <- base::invokeRestart
[10:34:17.452]             length <- base::length
[10:34:17.452]             list <- base::list
[10:34:17.452]             seq.int <- base::seq.int
[10:34:17.452]             signalCondition <- base::signalCondition
[10:34:17.452]             sys.calls <- base::sys.calls
[10:34:17.452]             `[[` <- base::`[[`
[10:34:17.452]             `+` <- base::`+`
[10:34:17.452]             `<<-` <- base::`<<-`
[10:34:17.452]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:17.452]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:17.452]                   3L)]
[10:34:17.452]             }
[10:34:17.452]             function(cond) {
[10:34:17.452]                 is_error <- inherits(cond, "error")
[10:34:17.452]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:17.452]                   NULL)
[10:34:17.452]                 if (is_error) {
[10:34:17.452]                   sessionInformation <- function() {
[10:34:17.452]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:17.452]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:17.452]                       search = base::search(), system = base::Sys.info())
[10:34:17.452]                   }
[10:34:17.452]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.452]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:17.452]                     cond$call), session = sessionInformation(), 
[10:34:17.452]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:17.452]                   signalCondition(cond)
[10:34:17.452]                 }
[10:34:17.452]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:17.452]                 "immediateCondition"))) {
[10:34:17.452]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:17.452]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.452]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:17.452]                   if (TRUE && !signal) {
[10:34:17.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.452]                     {
[10:34:17.452]                       inherits <- base::inherits
[10:34:17.452]                       invokeRestart <- base::invokeRestart
[10:34:17.452]                       is.null <- base::is.null
[10:34:17.452]                       muffled <- FALSE
[10:34:17.452]                       if (inherits(cond, "message")) {
[10:34:17.452]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.452]                         if (muffled) 
[10:34:17.452]                           invokeRestart("muffleMessage")
[10:34:17.452]                       }
[10:34:17.452]                       else if (inherits(cond, "warning")) {
[10:34:17.452]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.452]                         if (muffled) 
[10:34:17.452]                           invokeRestart("muffleWarning")
[10:34:17.452]                       }
[10:34:17.452]                       else if (inherits(cond, "condition")) {
[10:34:17.452]                         if (!is.null(pattern)) {
[10:34:17.452]                           computeRestarts <- base::computeRestarts
[10:34:17.452]                           grepl <- base::grepl
[10:34:17.452]                           restarts <- computeRestarts(cond)
[10:34:17.452]                           for (restart in restarts) {
[10:34:17.452]                             name <- restart$name
[10:34:17.452]                             if (is.null(name)) 
[10:34:17.452]                               next
[10:34:17.452]                             if (!grepl(pattern, name)) 
[10:34:17.452]                               next
[10:34:17.452]                             invokeRestart(restart)
[10:34:17.452]                             muffled <- TRUE
[10:34:17.452]                             break
[10:34:17.452]                           }
[10:34:17.452]                         }
[10:34:17.452]                       }
[10:34:17.452]                       invisible(muffled)
[10:34:17.452]                     }
[10:34:17.452]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.452]                   }
[10:34:17.452]                 }
[10:34:17.452]                 else {
[10:34:17.452]                   if (TRUE) {
[10:34:17.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.452]                     {
[10:34:17.452]                       inherits <- base::inherits
[10:34:17.452]                       invokeRestart <- base::invokeRestart
[10:34:17.452]                       is.null <- base::is.null
[10:34:17.452]                       muffled <- FALSE
[10:34:17.452]                       if (inherits(cond, "message")) {
[10:34:17.452]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.452]                         if (muffled) 
[10:34:17.452]                           invokeRestart("muffleMessage")
[10:34:17.452]                       }
[10:34:17.452]                       else if (inherits(cond, "warning")) {
[10:34:17.452]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.452]                         if (muffled) 
[10:34:17.452]                           invokeRestart("muffleWarning")
[10:34:17.452]                       }
[10:34:17.452]                       else if (inherits(cond, "condition")) {
[10:34:17.452]                         if (!is.null(pattern)) {
[10:34:17.452]                           computeRestarts <- base::computeRestarts
[10:34:17.452]                           grepl <- base::grepl
[10:34:17.452]                           restarts <- computeRestarts(cond)
[10:34:17.452]                           for (restart in restarts) {
[10:34:17.452]                             name <- restart$name
[10:34:17.452]                             if (is.null(name)) 
[10:34:17.452]                               next
[10:34:17.452]                             if (!grepl(pattern, name)) 
[10:34:17.452]                               next
[10:34:17.452]                             invokeRestart(restart)
[10:34:17.452]                             muffled <- TRUE
[10:34:17.452]                             break
[10:34:17.452]                           }
[10:34:17.452]                         }
[10:34:17.452]                       }
[10:34:17.452]                       invisible(muffled)
[10:34:17.452]                     }
[10:34:17.452]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.452]                   }
[10:34:17.452]                 }
[10:34:17.452]             }
[10:34:17.452]         }))
[10:34:17.452]     }, error = function(ex) {
[10:34:17.452]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:17.452]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.452]                 ...future.rng), started = ...future.startTime, 
[10:34:17.452]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:17.452]             version = "1.8"), class = "FutureResult")
[10:34:17.452]     }, finally = {
[10:34:17.452]         if (!identical(...future.workdir, getwd())) 
[10:34:17.452]             setwd(...future.workdir)
[10:34:17.452]         {
[10:34:17.452]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:17.452]                 ...future.oldOptions$nwarnings <- NULL
[10:34:17.452]             }
[10:34:17.452]             base::options(...future.oldOptions)
[10:34:17.452]             if (.Platform$OS.type == "windows") {
[10:34:17.452]                 old_names <- names(...future.oldEnvVars)
[10:34:17.452]                 envs <- base::Sys.getenv()
[10:34:17.452]                 names <- names(envs)
[10:34:17.452]                 common <- intersect(names, old_names)
[10:34:17.452]                 added <- setdiff(names, old_names)
[10:34:17.452]                 removed <- setdiff(old_names, names)
[10:34:17.452]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:17.452]                   envs[common]]
[10:34:17.452]                 NAMES <- toupper(changed)
[10:34:17.452]                 args <- list()
[10:34:17.452]                 for (kk in seq_along(NAMES)) {
[10:34:17.452]                   name <- changed[[kk]]
[10:34:17.452]                   NAME <- NAMES[[kk]]
[10:34:17.452]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.452]                     next
[10:34:17.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.452]                 }
[10:34:17.452]                 NAMES <- toupper(added)
[10:34:17.452]                 for (kk in seq_along(NAMES)) {
[10:34:17.452]                   name <- added[[kk]]
[10:34:17.452]                   NAME <- NAMES[[kk]]
[10:34:17.452]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.452]                     next
[10:34:17.452]                   args[[name]] <- ""
[10:34:17.452]                 }
[10:34:17.452]                 NAMES <- toupper(removed)
[10:34:17.452]                 for (kk in seq_along(NAMES)) {
[10:34:17.452]                   name <- removed[[kk]]
[10:34:17.452]                   NAME <- NAMES[[kk]]
[10:34:17.452]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.452]                     next
[10:34:17.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.452]                 }
[10:34:17.452]                 if (length(args) > 0) 
[10:34:17.452]                   base::do.call(base::Sys.setenv, args = args)
[10:34:17.452]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:17.452]             }
[10:34:17.452]             else {
[10:34:17.452]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:17.452]             }
[10:34:17.452]             {
[10:34:17.452]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:17.452]                   0L) {
[10:34:17.452]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:17.452]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:17.452]                   base::options(opts)
[10:34:17.452]                 }
[10:34:17.452]                 {
[10:34:17.452]                   {
[10:34:17.452]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:17.452]                     NULL
[10:34:17.452]                   }
[10:34:17.452]                   options(future.plan = NULL)
[10:34:17.452]                   if (is.na(NA_character_)) 
[10:34:17.452]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.452]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:17.452]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:17.452]                     .init = FALSE)
[10:34:17.452]                 }
[10:34:17.452]             }
[10:34:17.452]         }
[10:34:17.452]     })
[10:34:17.452]     if (TRUE) {
[10:34:17.452]         base::sink(type = "output", split = FALSE)
[10:34:17.452]         if (TRUE) {
[10:34:17.452]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:17.452]         }
[10:34:17.452]         else {
[10:34:17.452]             ...future.result["stdout"] <- base::list(NULL)
[10:34:17.452]         }
[10:34:17.452]         base::close(...future.stdout)
[10:34:17.452]         ...future.stdout <- NULL
[10:34:17.452]     }
[10:34:17.452]     ...future.result$conditions <- ...future.conditions
[10:34:17.452]     ...future.result$finished <- base::Sys.time()
[10:34:17.452]     ...future.result
[10:34:17.452] }
[10:34:17.455] MultisessionFuture started
[10:34:17.455] - Launch lazy future ... done
[10:34:17.455] run() for ‘MultisessionFuture’ ... done
[10:34:17.456] resolve() on environment ...
[10:34:17.456]  recursive: 0
[10:34:17.457]  elements: [3] ‘a’
[10:34:17.457] receiveMessageFromWorker() for ClusterFuture ...
[10:34:17.457] - Validating connection of MultisessionFuture
[10:34:17.457] - received message: FutureResult
[10:34:17.457] - Received FutureResult
[10:34:17.458] - Erased future from FutureRegistry
[10:34:17.458] result() for ClusterFuture ...
[10:34:17.458] - result already collected: FutureResult
[10:34:17.458] result() for ClusterFuture ... done
[10:34:17.458] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:17.458] Future #1
[10:34:17.458]  length: 2 (resolved future 1)
[10:34:17.459] receiveMessageFromWorker() for ClusterFuture ...
[10:34:17.459] - Validating connection of MultisessionFuture
[10:34:17.459] - received message: FutureResult
[10:34:17.459] - Received FutureResult
[10:34:17.459] - Erased future from FutureRegistry
[10:34:17.459] result() for ClusterFuture ...
[10:34:17.459] - result already collected: FutureResult
[10:34:17.459] result() for ClusterFuture ... done
[10:34:17.459] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:17.459] Future #2
[10:34:17.460]  length: 1 (resolved future 2)
[10:34:17.460]  length: 0 (resolved future 3)
[10:34:17.460] resolve() on environment ... DONE
[10:34:17.460] resolve() on environment ...
[10:34:17.460]  recursive: 0
[10:34:17.461]  elements: [3] ‘b’
[10:34:17.461] Future #1
[10:34:17.461]  length: 2 (resolved future 1)
[10:34:17.461] Future #2
[10:34:17.461]  length: 1 (resolved future 2)
[10:34:17.461]  length: 0 (resolved future 3)
[10:34:17.461] resolve() on environment ... DONE
[10:34:17.462] resolve() on environment ...
[10:34:17.462]  recursive: 0
[10:34:17.462]  elements: [3] ‘c’
[10:34:17.463] Future #1
[10:34:17.463]  length: 2 (resolved future 1)
[10:34:17.463] Future #2
[10:34:17.463]  length: 1 (resolved future 2)
[10:34:17.463]  length: 0 (resolved future 3)
[10:34:17.463] resolve() on environment ... DONE
[10:34:17.463] resolve() on environment ...
[10:34:17.464]  recursive: 0
[10:34:17.464]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[10:34:17.464] Future #1
[10:34:17.464] result() for ClusterFuture ...
[10:34:17.464] - result already collected: FutureResult
[10:34:17.464] result() for ClusterFuture ... done
[10:34:17.464] result() for ClusterFuture ...
[10:34:17.465] - result already collected: FutureResult
[10:34:17.465] result() for ClusterFuture ... done
[10:34:17.465]  length: 2 (resolved future 1)
[10:34:17.465] Future #2
[10:34:17.465] result() for ClusterFuture ...
[10:34:17.465] - result already collected: FutureResult
[10:34:17.465] result() for ClusterFuture ... done
[10:34:17.465] result() for ClusterFuture ...
[10:34:17.465] - result already collected: FutureResult
[10:34:17.465] result() for ClusterFuture ... done
[10:34:17.466]  length: 1 (resolved future 2)
[10:34:17.466]  length: 0 (resolved future 3)
[10:34:17.466] resolve() on environment ... DONE
[10:34:17.466] resolve() on environment ...
[10:34:17.466]  recursive: 99
[10:34:17.467]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[10:34:17.467] Future #1
[10:34:17.467] result() for ClusterFuture ...
[10:34:17.467] - result already collected: FutureResult
[10:34:17.467] result() for ClusterFuture ... done
[10:34:17.467] result() for ClusterFuture ...
[10:34:17.467] - result already collected: FutureResult
[10:34:17.467] result() for ClusterFuture ... done
[10:34:17.468] A MultisessionFuture was resolved
[10:34:17.468]  length: 2 (resolved future 1)
[10:34:17.468] Future #2
[10:34:17.468] result() for ClusterFuture ...
[10:34:17.468] - result already collected: FutureResult
[10:34:17.468] result() for ClusterFuture ... done
[10:34:17.468] result() for ClusterFuture ...
[10:34:17.468] - result already collected: FutureResult
[10:34:17.468] result() for ClusterFuture ... done
[10:34:17.468] A MultisessionFuture was resolved
[10:34:17.468]  length: 1 (resolved future 2)
[10:34:17.469]  length: 0 (resolved future 3)
[10:34:17.469] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[10:34:17.469] resolve() on list environment ...
[10:34:17.469]  recursive: 0
[10:34:17.470]  length: 2
[10:34:17.470]  elements: ‘a’, ‘b’
[10:34:17.470]  length: 1 (resolved future 1)
[10:34:17.470]  length: 0 (resolved future 2)
[10:34:17.470] resolve() on list environment ... DONE
[10:34:17.470] getGlobalsAndPackages() ...
[10:34:17.471] Searching for globals...
[10:34:17.471] 
[10:34:17.471] Searching for globals ... DONE
[10:34:17.471] - globals: [0] <none>
[10:34:17.471] getGlobalsAndPackages() ... DONE
[10:34:17.471] run() for ‘Future’ ...
[10:34:17.471] - state: ‘created’
[10:34:17.472] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:17.485] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:17.485] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:17.485]   - Field: ‘node’
[10:34:17.485]   - Field: ‘label’
[10:34:17.485]   - Field: ‘local’
[10:34:17.485]   - Field: ‘owner’
[10:34:17.485]   - Field: ‘envir’
[10:34:17.486]   - Field: ‘workers’
[10:34:17.486]   - Field: ‘packages’
[10:34:17.486]   - Field: ‘gc’
[10:34:17.486]   - Field: ‘conditions’
[10:34:17.486]   - Field: ‘persistent’
[10:34:17.486]   - Field: ‘expr’
[10:34:17.486]   - Field: ‘uuid’
[10:34:17.486]   - Field: ‘seed’
[10:34:17.486]   - Field: ‘version’
[10:34:17.486]   - Field: ‘result’
[10:34:17.486]   - Field: ‘asynchronous’
[10:34:17.487]   - Field: ‘calls’
[10:34:17.487]   - Field: ‘globals’
[10:34:17.487]   - Field: ‘stdout’
[10:34:17.487]   - Field: ‘earlySignal’
[10:34:17.487]   - Field: ‘lazy’
[10:34:17.487]   - Field: ‘state’
[10:34:17.487] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:17.487] - Launch lazy future ...
[10:34:17.487] Packages needed by the future expression (n = 0): <none>
[10:34:17.488] Packages needed by future strategies (n = 0): <none>
[10:34:17.488] {
[10:34:17.488]     {
[10:34:17.488]         {
[10:34:17.488]             ...future.startTime <- base::Sys.time()
[10:34:17.488]             {
[10:34:17.488]                 {
[10:34:17.488]                   {
[10:34:17.488]                     {
[10:34:17.488]                       base::local({
[10:34:17.488]                         has_future <- base::requireNamespace("future", 
[10:34:17.488]                           quietly = TRUE)
[10:34:17.488]                         if (has_future) {
[10:34:17.488]                           ns <- base::getNamespace("future")
[10:34:17.488]                           version <- ns[[".package"]][["version"]]
[10:34:17.488]                           if (is.null(version)) 
[10:34:17.488]                             version <- utils::packageVersion("future")
[10:34:17.488]                         }
[10:34:17.488]                         else {
[10:34:17.488]                           version <- NULL
[10:34:17.488]                         }
[10:34:17.488]                         if (!has_future || version < "1.8.0") {
[10:34:17.488]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:17.488]                             "", base::R.version$version.string), 
[10:34:17.488]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:17.488]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:17.488]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:17.488]                               "release", "version")], collapse = " "), 
[10:34:17.488]                             hostname = base::Sys.info()[["nodename"]])
[10:34:17.488]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:17.488]                             info)
[10:34:17.488]                           info <- base::paste(info, collapse = "; ")
[10:34:17.488]                           if (!has_future) {
[10:34:17.488]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:17.488]                               info)
[10:34:17.488]                           }
[10:34:17.488]                           else {
[10:34:17.488]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:17.488]                               info, version)
[10:34:17.488]                           }
[10:34:17.488]                           base::stop(msg)
[10:34:17.488]                         }
[10:34:17.488]                       })
[10:34:17.488]                     }
[10:34:17.488]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:17.488]                     base::options(mc.cores = 1L)
[10:34:17.488]                   }
[10:34:17.488]                   ...future.strategy.old <- future::plan("list")
[10:34:17.488]                   options(future.plan = NULL)
[10:34:17.488]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.488]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:17.488]                 }
[10:34:17.488]                 ...future.workdir <- getwd()
[10:34:17.488]             }
[10:34:17.488]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:17.488]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:17.488]         }
[10:34:17.488]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:17.488]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:17.488]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:17.488]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:17.488]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:17.488]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:17.488]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:17.488]             base::names(...future.oldOptions))
[10:34:17.488]     }
[10:34:17.488]     if (FALSE) {
[10:34:17.488]     }
[10:34:17.488]     else {
[10:34:17.488]         if (TRUE) {
[10:34:17.488]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:17.488]                 open = "w")
[10:34:17.488]         }
[10:34:17.488]         else {
[10:34:17.488]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:17.488]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:17.488]         }
[10:34:17.488]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:17.488]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:17.488]             base::sink(type = "output", split = FALSE)
[10:34:17.488]             base::close(...future.stdout)
[10:34:17.488]         }, add = TRUE)
[10:34:17.488]     }
[10:34:17.488]     ...future.frame <- base::sys.nframe()
[10:34:17.488]     ...future.conditions <- base::list()
[10:34:17.488]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:17.488]     if (FALSE) {
[10:34:17.488]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:17.488]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:17.488]     }
[10:34:17.488]     ...future.result <- base::tryCatch({
[10:34:17.488]         base::withCallingHandlers({
[10:34:17.488]             ...future.value <- base::withVisible(base::local({
[10:34:17.488]                 ...future.makeSendCondition <- base::local({
[10:34:17.488]                   sendCondition <- NULL
[10:34:17.488]                   function(frame = 1L) {
[10:34:17.488]                     if (is.function(sendCondition)) 
[10:34:17.488]                       return(sendCondition)
[10:34:17.488]                     ns <- getNamespace("parallel")
[10:34:17.488]                     if (exists("sendData", mode = "function", 
[10:34:17.488]                       envir = ns)) {
[10:34:17.488]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:17.488]                         envir = ns)
[10:34:17.488]                       envir <- sys.frame(frame)
[10:34:17.488]                       master <- NULL
[10:34:17.488]                       while (!identical(envir, .GlobalEnv) && 
[10:34:17.488]                         !identical(envir, emptyenv())) {
[10:34:17.488]                         if (exists("master", mode = "list", envir = envir, 
[10:34:17.488]                           inherits = FALSE)) {
[10:34:17.488]                           master <- get("master", mode = "list", 
[10:34:17.488]                             envir = envir, inherits = FALSE)
[10:34:17.488]                           if (inherits(master, c("SOCKnode", 
[10:34:17.488]                             "SOCK0node"))) {
[10:34:17.488]                             sendCondition <<- function(cond) {
[10:34:17.488]                               data <- list(type = "VALUE", value = cond, 
[10:34:17.488]                                 success = TRUE)
[10:34:17.488]                               parallel_sendData(master, data)
[10:34:17.488]                             }
[10:34:17.488]                             return(sendCondition)
[10:34:17.488]                           }
[10:34:17.488]                         }
[10:34:17.488]                         frame <- frame + 1L
[10:34:17.488]                         envir <- sys.frame(frame)
[10:34:17.488]                       }
[10:34:17.488]                     }
[10:34:17.488]                     sendCondition <<- function(cond) NULL
[10:34:17.488]                   }
[10:34:17.488]                 })
[10:34:17.488]                 withCallingHandlers({
[10:34:17.488]                   1
[10:34:17.488]                 }, immediateCondition = function(cond) {
[10:34:17.488]                   sendCondition <- ...future.makeSendCondition()
[10:34:17.488]                   sendCondition(cond)
[10:34:17.488]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.488]                   {
[10:34:17.488]                     inherits <- base::inherits
[10:34:17.488]                     invokeRestart <- base::invokeRestart
[10:34:17.488]                     is.null <- base::is.null
[10:34:17.488]                     muffled <- FALSE
[10:34:17.488]                     if (inherits(cond, "message")) {
[10:34:17.488]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:17.488]                       if (muffled) 
[10:34:17.488]                         invokeRestart("muffleMessage")
[10:34:17.488]                     }
[10:34:17.488]                     else if (inherits(cond, "warning")) {
[10:34:17.488]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:17.488]                       if (muffled) 
[10:34:17.488]                         invokeRestart("muffleWarning")
[10:34:17.488]                     }
[10:34:17.488]                     else if (inherits(cond, "condition")) {
[10:34:17.488]                       if (!is.null(pattern)) {
[10:34:17.488]                         computeRestarts <- base::computeRestarts
[10:34:17.488]                         grepl <- base::grepl
[10:34:17.488]                         restarts <- computeRestarts(cond)
[10:34:17.488]                         for (restart in restarts) {
[10:34:17.488]                           name <- restart$name
[10:34:17.488]                           if (is.null(name)) 
[10:34:17.488]                             next
[10:34:17.488]                           if (!grepl(pattern, name)) 
[10:34:17.488]                             next
[10:34:17.488]                           invokeRestart(restart)
[10:34:17.488]                           muffled <- TRUE
[10:34:17.488]                           break
[10:34:17.488]                         }
[10:34:17.488]                       }
[10:34:17.488]                     }
[10:34:17.488]                     invisible(muffled)
[10:34:17.488]                   }
[10:34:17.488]                   muffleCondition(cond)
[10:34:17.488]                 })
[10:34:17.488]             }))
[10:34:17.488]             future::FutureResult(value = ...future.value$value, 
[10:34:17.488]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.488]                   ...future.rng), globalenv = if (FALSE) 
[10:34:17.488]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:17.488]                     ...future.globalenv.names))
[10:34:17.488]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:17.488]         }, condition = base::local({
[10:34:17.488]             c <- base::c
[10:34:17.488]             inherits <- base::inherits
[10:34:17.488]             invokeRestart <- base::invokeRestart
[10:34:17.488]             length <- base::length
[10:34:17.488]             list <- base::list
[10:34:17.488]             seq.int <- base::seq.int
[10:34:17.488]             signalCondition <- base::signalCondition
[10:34:17.488]             sys.calls <- base::sys.calls
[10:34:17.488]             `[[` <- base::`[[`
[10:34:17.488]             `+` <- base::`+`
[10:34:17.488]             `<<-` <- base::`<<-`
[10:34:17.488]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:17.488]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:17.488]                   3L)]
[10:34:17.488]             }
[10:34:17.488]             function(cond) {
[10:34:17.488]                 is_error <- inherits(cond, "error")
[10:34:17.488]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:17.488]                   NULL)
[10:34:17.488]                 if (is_error) {
[10:34:17.488]                   sessionInformation <- function() {
[10:34:17.488]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:17.488]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:17.488]                       search = base::search(), system = base::Sys.info())
[10:34:17.488]                   }
[10:34:17.488]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.488]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:17.488]                     cond$call), session = sessionInformation(), 
[10:34:17.488]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:17.488]                   signalCondition(cond)
[10:34:17.488]                 }
[10:34:17.488]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:17.488]                 "immediateCondition"))) {
[10:34:17.488]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:17.488]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.488]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:17.488]                   if (TRUE && !signal) {
[10:34:17.488]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.488]                     {
[10:34:17.488]                       inherits <- base::inherits
[10:34:17.488]                       invokeRestart <- base::invokeRestart
[10:34:17.488]                       is.null <- base::is.null
[10:34:17.488]                       muffled <- FALSE
[10:34:17.488]                       if (inherits(cond, "message")) {
[10:34:17.488]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.488]                         if (muffled) 
[10:34:17.488]                           invokeRestart("muffleMessage")
[10:34:17.488]                       }
[10:34:17.488]                       else if (inherits(cond, "warning")) {
[10:34:17.488]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.488]                         if (muffled) 
[10:34:17.488]                           invokeRestart("muffleWarning")
[10:34:17.488]                       }
[10:34:17.488]                       else if (inherits(cond, "condition")) {
[10:34:17.488]                         if (!is.null(pattern)) {
[10:34:17.488]                           computeRestarts <- base::computeRestarts
[10:34:17.488]                           grepl <- base::grepl
[10:34:17.488]                           restarts <- computeRestarts(cond)
[10:34:17.488]                           for (restart in restarts) {
[10:34:17.488]                             name <- restart$name
[10:34:17.488]                             if (is.null(name)) 
[10:34:17.488]                               next
[10:34:17.488]                             if (!grepl(pattern, name)) 
[10:34:17.488]                               next
[10:34:17.488]                             invokeRestart(restart)
[10:34:17.488]                             muffled <- TRUE
[10:34:17.488]                             break
[10:34:17.488]                           }
[10:34:17.488]                         }
[10:34:17.488]                       }
[10:34:17.488]                       invisible(muffled)
[10:34:17.488]                     }
[10:34:17.488]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.488]                   }
[10:34:17.488]                 }
[10:34:17.488]                 else {
[10:34:17.488]                   if (TRUE) {
[10:34:17.488]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.488]                     {
[10:34:17.488]                       inherits <- base::inherits
[10:34:17.488]                       invokeRestart <- base::invokeRestart
[10:34:17.488]                       is.null <- base::is.null
[10:34:17.488]                       muffled <- FALSE
[10:34:17.488]                       if (inherits(cond, "message")) {
[10:34:17.488]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.488]                         if (muffled) 
[10:34:17.488]                           invokeRestart("muffleMessage")
[10:34:17.488]                       }
[10:34:17.488]                       else if (inherits(cond, "warning")) {
[10:34:17.488]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.488]                         if (muffled) 
[10:34:17.488]                           invokeRestart("muffleWarning")
[10:34:17.488]                       }
[10:34:17.488]                       else if (inherits(cond, "condition")) {
[10:34:17.488]                         if (!is.null(pattern)) {
[10:34:17.488]                           computeRestarts <- base::computeRestarts
[10:34:17.488]                           grepl <- base::grepl
[10:34:17.488]                           restarts <- computeRestarts(cond)
[10:34:17.488]                           for (restart in restarts) {
[10:34:17.488]                             name <- restart$name
[10:34:17.488]                             if (is.null(name)) 
[10:34:17.488]                               next
[10:34:17.488]                             if (!grepl(pattern, name)) 
[10:34:17.488]                               next
[10:34:17.488]                             invokeRestart(restart)
[10:34:17.488]                             muffled <- TRUE
[10:34:17.488]                             break
[10:34:17.488]                           }
[10:34:17.488]                         }
[10:34:17.488]                       }
[10:34:17.488]                       invisible(muffled)
[10:34:17.488]                     }
[10:34:17.488]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.488]                   }
[10:34:17.488]                 }
[10:34:17.488]             }
[10:34:17.488]         }))
[10:34:17.488]     }, error = function(ex) {
[10:34:17.488]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:17.488]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.488]                 ...future.rng), started = ...future.startTime, 
[10:34:17.488]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:17.488]             version = "1.8"), class = "FutureResult")
[10:34:17.488]     }, finally = {
[10:34:17.488]         if (!identical(...future.workdir, getwd())) 
[10:34:17.488]             setwd(...future.workdir)
[10:34:17.488]         {
[10:34:17.488]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:17.488]                 ...future.oldOptions$nwarnings <- NULL
[10:34:17.488]             }
[10:34:17.488]             base::options(...future.oldOptions)
[10:34:17.488]             if (.Platform$OS.type == "windows") {
[10:34:17.488]                 old_names <- names(...future.oldEnvVars)
[10:34:17.488]                 envs <- base::Sys.getenv()
[10:34:17.488]                 names <- names(envs)
[10:34:17.488]                 common <- intersect(names, old_names)
[10:34:17.488]                 added <- setdiff(names, old_names)
[10:34:17.488]                 removed <- setdiff(old_names, names)
[10:34:17.488]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:17.488]                   envs[common]]
[10:34:17.488]                 NAMES <- toupper(changed)
[10:34:17.488]                 args <- list()
[10:34:17.488]                 for (kk in seq_along(NAMES)) {
[10:34:17.488]                   name <- changed[[kk]]
[10:34:17.488]                   NAME <- NAMES[[kk]]
[10:34:17.488]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.488]                     next
[10:34:17.488]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.488]                 }
[10:34:17.488]                 NAMES <- toupper(added)
[10:34:17.488]                 for (kk in seq_along(NAMES)) {
[10:34:17.488]                   name <- added[[kk]]
[10:34:17.488]                   NAME <- NAMES[[kk]]
[10:34:17.488]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.488]                     next
[10:34:17.488]                   args[[name]] <- ""
[10:34:17.488]                 }
[10:34:17.488]                 NAMES <- toupper(removed)
[10:34:17.488]                 for (kk in seq_along(NAMES)) {
[10:34:17.488]                   name <- removed[[kk]]
[10:34:17.488]                   NAME <- NAMES[[kk]]
[10:34:17.488]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.488]                     next
[10:34:17.488]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.488]                 }
[10:34:17.488]                 if (length(args) > 0) 
[10:34:17.488]                   base::do.call(base::Sys.setenv, args = args)
[10:34:17.488]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:17.488]             }
[10:34:17.488]             else {
[10:34:17.488]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:17.488]             }
[10:34:17.488]             {
[10:34:17.488]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:17.488]                   0L) {
[10:34:17.488]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:17.488]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:17.488]                   base::options(opts)
[10:34:17.488]                 }
[10:34:17.488]                 {
[10:34:17.488]                   {
[10:34:17.488]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:17.488]                     NULL
[10:34:17.488]                   }
[10:34:17.488]                   options(future.plan = NULL)
[10:34:17.488]                   if (is.na(NA_character_)) 
[10:34:17.488]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.488]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:17.488]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:17.488]                     .init = FALSE)
[10:34:17.488]                 }
[10:34:17.488]             }
[10:34:17.488]         }
[10:34:17.488]     })
[10:34:17.488]     if (TRUE) {
[10:34:17.488]         base::sink(type = "output", split = FALSE)
[10:34:17.488]         if (TRUE) {
[10:34:17.488]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:17.488]         }
[10:34:17.488]         else {
[10:34:17.488]             ...future.result["stdout"] <- base::list(NULL)
[10:34:17.488]         }
[10:34:17.488]         base::close(...future.stdout)
[10:34:17.488]         ...future.stdout <- NULL
[10:34:17.488]     }
[10:34:17.488]     ...future.result$conditions <- ...future.conditions
[10:34:17.488]     ...future.result$finished <- base::Sys.time()
[10:34:17.488]     ...future.result
[10:34:17.488] }
[10:34:17.491] MultisessionFuture started
[10:34:17.491] - Launch lazy future ... done
[10:34:17.491] run() for ‘MultisessionFuture’ ... done
[10:34:17.491] getGlobalsAndPackages() ...
[10:34:17.491] Searching for globals...
[10:34:17.492] 
[10:34:17.492] Searching for globals ... DONE
[10:34:17.492] - globals: [0] <none>
[10:34:17.492] getGlobalsAndPackages() ... DONE
[10:34:17.492] run() for ‘Future’ ...
[10:34:17.492] - state: ‘created’
[10:34:17.492] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:17.506] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:17.506] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:17.506]   - Field: ‘node’
[10:34:17.506]   - Field: ‘label’
[10:34:17.506]   - Field: ‘local’
[10:34:17.506]   - Field: ‘owner’
[10:34:17.506]   - Field: ‘envir’
[10:34:17.506]   - Field: ‘workers’
[10:34:17.506]   - Field: ‘packages’
[10:34:17.506]   - Field: ‘gc’
[10:34:17.507]   - Field: ‘conditions’
[10:34:17.507]   - Field: ‘persistent’
[10:34:17.507]   - Field: ‘expr’
[10:34:17.507]   - Field: ‘uuid’
[10:34:17.507]   - Field: ‘seed’
[10:34:17.507]   - Field: ‘version’
[10:34:17.507]   - Field: ‘result’
[10:34:17.507]   - Field: ‘asynchronous’
[10:34:17.507]   - Field: ‘calls’
[10:34:17.507]   - Field: ‘globals’
[10:34:17.507]   - Field: ‘stdout’
[10:34:17.508]   - Field: ‘earlySignal’
[10:34:17.508]   - Field: ‘lazy’
[10:34:17.508]   - Field: ‘state’
[10:34:17.508] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:17.508] - Launch lazy future ...
[10:34:17.508] Packages needed by the future expression (n = 0): <none>
[10:34:17.508] Packages needed by future strategies (n = 0): <none>
[10:34:17.509] {
[10:34:17.509]     {
[10:34:17.509]         {
[10:34:17.509]             ...future.startTime <- base::Sys.time()
[10:34:17.509]             {
[10:34:17.509]                 {
[10:34:17.509]                   {
[10:34:17.509]                     {
[10:34:17.509]                       base::local({
[10:34:17.509]                         has_future <- base::requireNamespace("future", 
[10:34:17.509]                           quietly = TRUE)
[10:34:17.509]                         if (has_future) {
[10:34:17.509]                           ns <- base::getNamespace("future")
[10:34:17.509]                           version <- ns[[".package"]][["version"]]
[10:34:17.509]                           if (is.null(version)) 
[10:34:17.509]                             version <- utils::packageVersion("future")
[10:34:17.509]                         }
[10:34:17.509]                         else {
[10:34:17.509]                           version <- NULL
[10:34:17.509]                         }
[10:34:17.509]                         if (!has_future || version < "1.8.0") {
[10:34:17.509]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:17.509]                             "", base::R.version$version.string), 
[10:34:17.509]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:17.509]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:17.509]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:17.509]                               "release", "version")], collapse = " "), 
[10:34:17.509]                             hostname = base::Sys.info()[["nodename"]])
[10:34:17.509]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:17.509]                             info)
[10:34:17.509]                           info <- base::paste(info, collapse = "; ")
[10:34:17.509]                           if (!has_future) {
[10:34:17.509]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:17.509]                               info)
[10:34:17.509]                           }
[10:34:17.509]                           else {
[10:34:17.509]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:17.509]                               info, version)
[10:34:17.509]                           }
[10:34:17.509]                           base::stop(msg)
[10:34:17.509]                         }
[10:34:17.509]                       })
[10:34:17.509]                     }
[10:34:17.509]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:17.509]                     base::options(mc.cores = 1L)
[10:34:17.509]                   }
[10:34:17.509]                   ...future.strategy.old <- future::plan("list")
[10:34:17.509]                   options(future.plan = NULL)
[10:34:17.509]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.509]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:17.509]                 }
[10:34:17.509]                 ...future.workdir <- getwd()
[10:34:17.509]             }
[10:34:17.509]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:17.509]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:17.509]         }
[10:34:17.509]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:17.509]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:17.509]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:17.509]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:17.509]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:17.509]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:17.509]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:17.509]             base::names(...future.oldOptions))
[10:34:17.509]     }
[10:34:17.509]     if (FALSE) {
[10:34:17.509]     }
[10:34:17.509]     else {
[10:34:17.509]         if (TRUE) {
[10:34:17.509]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:17.509]                 open = "w")
[10:34:17.509]         }
[10:34:17.509]         else {
[10:34:17.509]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:17.509]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:17.509]         }
[10:34:17.509]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:17.509]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:17.509]             base::sink(type = "output", split = FALSE)
[10:34:17.509]             base::close(...future.stdout)
[10:34:17.509]         }, add = TRUE)
[10:34:17.509]     }
[10:34:17.509]     ...future.frame <- base::sys.nframe()
[10:34:17.509]     ...future.conditions <- base::list()
[10:34:17.509]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:17.509]     if (FALSE) {
[10:34:17.509]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:17.509]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:17.509]     }
[10:34:17.509]     ...future.result <- base::tryCatch({
[10:34:17.509]         base::withCallingHandlers({
[10:34:17.509]             ...future.value <- base::withVisible(base::local({
[10:34:17.509]                 ...future.makeSendCondition <- base::local({
[10:34:17.509]                   sendCondition <- NULL
[10:34:17.509]                   function(frame = 1L) {
[10:34:17.509]                     if (is.function(sendCondition)) 
[10:34:17.509]                       return(sendCondition)
[10:34:17.509]                     ns <- getNamespace("parallel")
[10:34:17.509]                     if (exists("sendData", mode = "function", 
[10:34:17.509]                       envir = ns)) {
[10:34:17.509]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:17.509]                         envir = ns)
[10:34:17.509]                       envir <- sys.frame(frame)
[10:34:17.509]                       master <- NULL
[10:34:17.509]                       while (!identical(envir, .GlobalEnv) && 
[10:34:17.509]                         !identical(envir, emptyenv())) {
[10:34:17.509]                         if (exists("master", mode = "list", envir = envir, 
[10:34:17.509]                           inherits = FALSE)) {
[10:34:17.509]                           master <- get("master", mode = "list", 
[10:34:17.509]                             envir = envir, inherits = FALSE)
[10:34:17.509]                           if (inherits(master, c("SOCKnode", 
[10:34:17.509]                             "SOCK0node"))) {
[10:34:17.509]                             sendCondition <<- function(cond) {
[10:34:17.509]                               data <- list(type = "VALUE", value = cond, 
[10:34:17.509]                                 success = TRUE)
[10:34:17.509]                               parallel_sendData(master, data)
[10:34:17.509]                             }
[10:34:17.509]                             return(sendCondition)
[10:34:17.509]                           }
[10:34:17.509]                         }
[10:34:17.509]                         frame <- frame + 1L
[10:34:17.509]                         envir <- sys.frame(frame)
[10:34:17.509]                       }
[10:34:17.509]                     }
[10:34:17.509]                     sendCondition <<- function(cond) NULL
[10:34:17.509]                   }
[10:34:17.509]                 })
[10:34:17.509]                 withCallingHandlers({
[10:34:17.509]                   2
[10:34:17.509]                 }, immediateCondition = function(cond) {
[10:34:17.509]                   sendCondition <- ...future.makeSendCondition()
[10:34:17.509]                   sendCondition(cond)
[10:34:17.509]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.509]                   {
[10:34:17.509]                     inherits <- base::inherits
[10:34:17.509]                     invokeRestart <- base::invokeRestart
[10:34:17.509]                     is.null <- base::is.null
[10:34:17.509]                     muffled <- FALSE
[10:34:17.509]                     if (inherits(cond, "message")) {
[10:34:17.509]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:17.509]                       if (muffled) 
[10:34:17.509]                         invokeRestart("muffleMessage")
[10:34:17.509]                     }
[10:34:17.509]                     else if (inherits(cond, "warning")) {
[10:34:17.509]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:17.509]                       if (muffled) 
[10:34:17.509]                         invokeRestart("muffleWarning")
[10:34:17.509]                     }
[10:34:17.509]                     else if (inherits(cond, "condition")) {
[10:34:17.509]                       if (!is.null(pattern)) {
[10:34:17.509]                         computeRestarts <- base::computeRestarts
[10:34:17.509]                         grepl <- base::grepl
[10:34:17.509]                         restarts <- computeRestarts(cond)
[10:34:17.509]                         for (restart in restarts) {
[10:34:17.509]                           name <- restart$name
[10:34:17.509]                           if (is.null(name)) 
[10:34:17.509]                             next
[10:34:17.509]                           if (!grepl(pattern, name)) 
[10:34:17.509]                             next
[10:34:17.509]                           invokeRestart(restart)
[10:34:17.509]                           muffled <- TRUE
[10:34:17.509]                           break
[10:34:17.509]                         }
[10:34:17.509]                       }
[10:34:17.509]                     }
[10:34:17.509]                     invisible(muffled)
[10:34:17.509]                   }
[10:34:17.509]                   muffleCondition(cond)
[10:34:17.509]                 })
[10:34:17.509]             }))
[10:34:17.509]             future::FutureResult(value = ...future.value$value, 
[10:34:17.509]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.509]                   ...future.rng), globalenv = if (FALSE) 
[10:34:17.509]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:17.509]                     ...future.globalenv.names))
[10:34:17.509]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:17.509]         }, condition = base::local({
[10:34:17.509]             c <- base::c
[10:34:17.509]             inherits <- base::inherits
[10:34:17.509]             invokeRestart <- base::invokeRestart
[10:34:17.509]             length <- base::length
[10:34:17.509]             list <- base::list
[10:34:17.509]             seq.int <- base::seq.int
[10:34:17.509]             signalCondition <- base::signalCondition
[10:34:17.509]             sys.calls <- base::sys.calls
[10:34:17.509]             `[[` <- base::`[[`
[10:34:17.509]             `+` <- base::`+`
[10:34:17.509]             `<<-` <- base::`<<-`
[10:34:17.509]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:17.509]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:17.509]                   3L)]
[10:34:17.509]             }
[10:34:17.509]             function(cond) {
[10:34:17.509]                 is_error <- inherits(cond, "error")
[10:34:17.509]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:17.509]                   NULL)
[10:34:17.509]                 if (is_error) {
[10:34:17.509]                   sessionInformation <- function() {
[10:34:17.509]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:17.509]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:17.509]                       search = base::search(), system = base::Sys.info())
[10:34:17.509]                   }
[10:34:17.509]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.509]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:17.509]                     cond$call), session = sessionInformation(), 
[10:34:17.509]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:17.509]                   signalCondition(cond)
[10:34:17.509]                 }
[10:34:17.509]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:17.509]                 "immediateCondition"))) {
[10:34:17.509]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:17.509]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.509]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:17.509]                   if (TRUE && !signal) {
[10:34:17.509]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.509]                     {
[10:34:17.509]                       inherits <- base::inherits
[10:34:17.509]                       invokeRestart <- base::invokeRestart
[10:34:17.509]                       is.null <- base::is.null
[10:34:17.509]                       muffled <- FALSE
[10:34:17.509]                       if (inherits(cond, "message")) {
[10:34:17.509]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.509]                         if (muffled) 
[10:34:17.509]                           invokeRestart("muffleMessage")
[10:34:17.509]                       }
[10:34:17.509]                       else if (inherits(cond, "warning")) {
[10:34:17.509]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.509]                         if (muffled) 
[10:34:17.509]                           invokeRestart("muffleWarning")
[10:34:17.509]                       }
[10:34:17.509]                       else if (inherits(cond, "condition")) {
[10:34:17.509]                         if (!is.null(pattern)) {
[10:34:17.509]                           computeRestarts <- base::computeRestarts
[10:34:17.509]                           grepl <- base::grepl
[10:34:17.509]                           restarts <- computeRestarts(cond)
[10:34:17.509]                           for (restart in restarts) {
[10:34:17.509]                             name <- restart$name
[10:34:17.509]                             if (is.null(name)) 
[10:34:17.509]                               next
[10:34:17.509]                             if (!grepl(pattern, name)) 
[10:34:17.509]                               next
[10:34:17.509]                             invokeRestart(restart)
[10:34:17.509]                             muffled <- TRUE
[10:34:17.509]                             break
[10:34:17.509]                           }
[10:34:17.509]                         }
[10:34:17.509]                       }
[10:34:17.509]                       invisible(muffled)
[10:34:17.509]                     }
[10:34:17.509]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.509]                   }
[10:34:17.509]                 }
[10:34:17.509]                 else {
[10:34:17.509]                   if (TRUE) {
[10:34:17.509]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.509]                     {
[10:34:17.509]                       inherits <- base::inherits
[10:34:17.509]                       invokeRestart <- base::invokeRestart
[10:34:17.509]                       is.null <- base::is.null
[10:34:17.509]                       muffled <- FALSE
[10:34:17.509]                       if (inherits(cond, "message")) {
[10:34:17.509]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.509]                         if (muffled) 
[10:34:17.509]                           invokeRestart("muffleMessage")
[10:34:17.509]                       }
[10:34:17.509]                       else if (inherits(cond, "warning")) {
[10:34:17.509]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.509]                         if (muffled) 
[10:34:17.509]                           invokeRestart("muffleWarning")
[10:34:17.509]                       }
[10:34:17.509]                       else if (inherits(cond, "condition")) {
[10:34:17.509]                         if (!is.null(pattern)) {
[10:34:17.509]                           computeRestarts <- base::computeRestarts
[10:34:17.509]                           grepl <- base::grepl
[10:34:17.509]                           restarts <- computeRestarts(cond)
[10:34:17.509]                           for (restart in restarts) {
[10:34:17.509]                             name <- restart$name
[10:34:17.509]                             if (is.null(name)) 
[10:34:17.509]                               next
[10:34:17.509]                             if (!grepl(pattern, name)) 
[10:34:17.509]                               next
[10:34:17.509]                             invokeRestart(restart)
[10:34:17.509]                             muffled <- TRUE
[10:34:17.509]                             break
[10:34:17.509]                           }
[10:34:17.509]                         }
[10:34:17.509]                       }
[10:34:17.509]                       invisible(muffled)
[10:34:17.509]                     }
[10:34:17.509]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.509]                   }
[10:34:17.509]                 }
[10:34:17.509]             }
[10:34:17.509]         }))
[10:34:17.509]     }, error = function(ex) {
[10:34:17.509]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:17.509]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.509]                 ...future.rng), started = ...future.startTime, 
[10:34:17.509]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:17.509]             version = "1.8"), class = "FutureResult")
[10:34:17.509]     }, finally = {
[10:34:17.509]         if (!identical(...future.workdir, getwd())) 
[10:34:17.509]             setwd(...future.workdir)
[10:34:17.509]         {
[10:34:17.509]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:17.509]                 ...future.oldOptions$nwarnings <- NULL
[10:34:17.509]             }
[10:34:17.509]             base::options(...future.oldOptions)
[10:34:17.509]             if (.Platform$OS.type == "windows") {
[10:34:17.509]                 old_names <- names(...future.oldEnvVars)
[10:34:17.509]                 envs <- base::Sys.getenv()
[10:34:17.509]                 names <- names(envs)
[10:34:17.509]                 common <- intersect(names, old_names)
[10:34:17.509]                 added <- setdiff(names, old_names)
[10:34:17.509]                 removed <- setdiff(old_names, names)
[10:34:17.509]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:17.509]                   envs[common]]
[10:34:17.509]                 NAMES <- toupper(changed)
[10:34:17.509]                 args <- list()
[10:34:17.509]                 for (kk in seq_along(NAMES)) {
[10:34:17.509]                   name <- changed[[kk]]
[10:34:17.509]                   NAME <- NAMES[[kk]]
[10:34:17.509]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.509]                     next
[10:34:17.509]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.509]                 }
[10:34:17.509]                 NAMES <- toupper(added)
[10:34:17.509]                 for (kk in seq_along(NAMES)) {
[10:34:17.509]                   name <- added[[kk]]
[10:34:17.509]                   NAME <- NAMES[[kk]]
[10:34:17.509]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.509]                     next
[10:34:17.509]                   args[[name]] <- ""
[10:34:17.509]                 }
[10:34:17.509]                 NAMES <- toupper(removed)
[10:34:17.509]                 for (kk in seq_along(NAMES)) {
[10:34:17.509]                   name <- removed[[kk]]
[10:34:17.509]                   NAME <- NAMES[[kk]]
[10:34:17.509]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.509]                     next
[10:34:17.509]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.509]                 }
[10:34:17.509]                 if (length(args) > 0) 
[10:34:17.509]                   base::do.call(base::Sys.setenv, args = args)
[10:34:17.509]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:17.509]             }
[10:34:17.509]             else {
[10:34:17.509]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:17.509]             }
[10:34:17.509]             {
[10:34:17.509]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:17.509]                   0L) {
[10:34:17.509]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:17.509]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:17.509]                   base::options(opts)
[10:34:17.509]                 }
[10:34:17.509]                 {
[10:34:17.509]                   {
[10:34:17.509]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:17.509]                     NULL
[10:34:17.509]                   }
[10:34:17.509]                   options(future.plan = NULL)
[10:34:17.509]                   if (is.na(NA_character_)) 
[10:34:17.509]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.509]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:17.509]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:17.509]                     .init = FALSE)
[10:34:17.509]                 }
[10:34:17.509]             }
[10:34:17.509]         }
[10:34:17.509]     })
[10:34:17.509]     if (TRUE) {
[10:34:17.509]         base::sink(type = "output", split = FALSE)
[10:34:17.509]         if (TRUE) {
[10:34:17.509]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:17.509]         }
[10:34:17.509]         else {
[10:34:17.509]             ...future.result["stdout"] <- base::list(NULL)
[10:34:17.509]         }
[10:34:17.509]         base::close(...future.stdout)
[10:34:17.509]         ...future.stdout <- NULL
[10:34:17.509]     }
[10:34:17.509]     ...future.result$conditions <- ...future.conditions
[10:34:17.509]     ...future.result$finished <- base::Sys.time()
[10:34:17.509]     ...future.result
[10:34:17.509] }
[10:34:17.511] MultisessionFuture started
[10:34:17.512] - Launch lazy future ... done
[10:34:17.512] run() for ‘MultisessionFuture’ ... done
[10:34:17.512] resolve() on list environment ...
[10:34:17.512]  recursive: 0
[10:34:17.513]  length: 3
[10:34:17.513]  elements: ‘a’, ‘b’, ‘c’
[10:34:17.513] receiveMessageFromWorker() for ClusterFuture ...
[10:34:17.514] - Validating connection of MultisessionFuture
[10:34:17.514] - received message: FutureResult
[10:34:17.514] - Received FutureResult
[10:34:17.514] - Erased future from FutureRegistry
[10:34:17.514] result() for ClusterFuture ...
[10:34:17.514] - result already collected: FutureResult
[10:34:17.514] result() for ClusterFuture ... done
[10:34:17.514] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:17.514] Future #1
[10:34:17.515]  length: 2 (resolved future 1)
[10:34:17.518] receiveMessageFromWorker() for ClusterFuture ...
[10:34:17.518] - Validating connection of MultisessionFuture
[10:34:17.518] - received message: FutureResult
[10:34:17.518] - Received FutureResult
[10:34:17.518] - Erased future from FutureRegistry
[10:34:17.519] result() for ClusterFuture ...
[10:34:17.519] - result already collected: FutureResult
[10:34:17.519] result() for ClusterFuture ... done
[10:34:17.519] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:17.519] Future #2
[10:34:17.519]  length: 1 (resolved future 2)
[10:34:17.519]  length: 0 (resolved future 3)
[10:34:17.519] resolve() on list environment ... DONE
[10:34:17.520] getGlobalsAndPackages() ...
[10:34:17.520] Searching for globals...
[10:34:17.521] - globals found: [1] ‘{’
[10:34:17.521] Searching for globals ... DONE
[10:34:17.521] Resolving globals: FALSE
[10:34:17.521] 
[10:34:17.521] 
[10:34:17.521] getGlobalsAndPackages() ... DONE
[10:34:17.522] run() for ‘Future’ ...
[10:34:17.522] - state: ‘created’
[10:34:17.522] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:17.535] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:17.536] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:17.536]   - Field: ‘node’
[10:34:17.536]   - Field: ‘label’
[10:34:17.536]   - Field: ‘local’
[10:34:17.536]   - Field: ‘owner’
[10:34:17.536]   - Field: ‘envir’
[10:34:17.536]   - Field: ‘workers’
[10:34:17.536]   - Field: ‘packages’
[10:34:17.536]   - Field: ‘gc’
[10:34:17.536]   - Field: ‘conditions’
[10:34:17.537]   - Field: ‘persistent’
[10:34:17.537]   - Field: ‘expr’
[10:34:17.537]   - Field: ‘uuid’
[10:34:17.537]   - Field: ‘seed’
[10:34:17.537]   - Field: ‘version’
[10:34:17.537]   - Field: ‘result’
[10:34:17.537]   - Field: ‘asynchronous’
[10:34:17.537]   - Field: ‘calls’
[10:34:17.537]   - Field: ‘globals’
[10:34:17.537]   - Field: ‘stdout’
[10:34:17.537]   - Field: ‘earlySignal’
[10:34:17.538]   - Field: ‘lazy’
[10:34:17.538]   - Field: ‘state’
[10:34:17.538] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:17.538] - Launch lazy future ...
[10:34:17.538] Packages needed by the future expression (n = 0): <none>
[10:34:17.538] Packages needed by future strategies (n = 0): <none>
[10:34:17.539] {
[10:34:17.539]     {
[10:34:17.539]         {
[10:34:17.539]             ...future.startTime <- base::Sys.time()
[10:34:17.539]             {
[10:34:17.539]                 {
[10:34:17.539]                   {
[10:34:17.539]                     {
[10:34:17.539]                       base::local({
[10:34:17.539]                         has_future <- base::requireNamespace("future", 
[10:34:17.539]                           quietly = TRUE)
[10:34:17.539]                         if (has_future) {
[10:34:17.539]                           ns <- base::getNamespace("future")
[10:34:17.539]                           version <- ns[[".package"]][["version"]]
[10:34:17.539]                           if (is.null(version)) 
[10:34:17.539]                             version <- utils::packageVersion("future")
[10:34:17.539]                         }
[10:34:17.539]                         else {
[10:34:17.539]                           version <- NULL
[10:34:17.539]                         }
[10:34:17.539]                         if (!has_future || version < "1.8.0") {
[10:34:17.539]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:17.539]                             "", base::R.version$version.string), 
[10:34:17.539]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:17.539]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:17.539]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:17.539]                               "release", "version")], collapse = " "), 
[10:34:17.539]                             hostname = base::Sys.info()[["nodename"]])
[10:34:17.539]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:17.539]                             info)
[10:34:17.539]                           info <- base::paste(info, collapse = "; ")
[10:34:17.539]                           if (!has_future) {
[10:34:17.539]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:17.539]                               info)
[10:34:17.539]                           }
[10:34:17.539]                           else {
[10:34:17.539]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:17.539]                               info, version)
[10:34:17.539]                           }
[10:34:17.539]                           base::stop(msg)
[10:34:17.539]                         }
[10:34:17.539]                       })
[10:34:17.539]                     }
[10:34:17.539]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:17.539]                     base::options(mc.cores = 1L)
[10:34:17.539]                   }
[10:34:17.539]                   ...future.strategy.old <- future::plan("list")
[10:34:17.539]                   options(future.plan = NULL)
[10:34:17.539]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.539]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:17.539]                 }
[10:34:17.539]                 ...future.workdir <- getwd()
[10:34:17.539]             }
[10:34:17.539]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:17.539]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:17.539]         }
[10:34:17.539]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:17.539]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:17.539]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:17.539]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:17.539]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:17.539]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:17.539]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:17.539]             base::names(...future.oldOptions))
[10:34:17.539]     }
[10:34:17.539]     if (FALSE) {
[10:34:17.539]     }
[10:34:17.539]     else {
[10:34:17.539]         if (TRUE) {
[10:34:17.539]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:17.539]                 open = "w")
[10:34:17.539]         }
[10:34:17.539]         else {
[10:34:17.539]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:17.539]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:17.539]         }
[10:34:17.539]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:17.539]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:17.539]             base::sink(type = "output", split = FALSE)
[10:34:17.539]             base::close(...future.stdout)
[10:34:17.539]         }, add = TRUE)
[10:34:17.539]     }
[10:34:17.539]     ...future.frame <- base::sys.nframe()
[10:34:17.539]     ...future.conditions <- base::list()
[10:34:17.539]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:17.539]     if (FALSE) {
[10:34:17.539]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:17.539]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:17.539]     }
[10:34:17.539]     ...future.result <- base::tryCatch({
[10:34:17.539]         base::withCallingHandlers({
[10:34:17.539]             ...future.value <- base::withVisible(base::local({
[10:34:17.539]                 ...future.makeSendCondition <- base::local({
[10:34:17.539]                   sendCondition <- NULL
[10:34:17.539]                   function(frame = 1L) {
[10:34:17.539]                     if (is.function(sendCondition)) 
[10:34:17.539]                       return(sendCondition)
[10:34:17.539]                     ns <- getNamespace("parallel")
[10:34:17.539]                     if (exists("sendData", mode = "function", 
[10:34:17.539]                       envir = ns)) {
[10:34:17.539]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:17.539]                         envir = ns)
[10:34:17.539]                       envir <- sys.frame(frame)
[10:34:17.539]                       master <- NULL
[10:34:17.539]                       while (!identical(envir, .GlobalEnv) && 
[10:34:17.539]                         !identical(envir, emptyenv())) {
[10:34:17.539]                         if (exists("master", mode = "list", envir = envir, 
[10:34:17.539]                           inherits = FALSE)) {
[10:34:17.539]                           master <- get("master", mode = "list", 
[10:34:17.539]                             envir = envir, inherits = FALSE)
[10:34:17.539]                           if (inherits(master, c("SOCKnode", 
[10:34:17.539]                             "SOCK0node"))) {
[10:34:17.539]                             sendCondition <<- function(cond) {
[10:34:17.539]                               data <- list(type = "VALUE", value = cond, 
[10:34:17.539]                                 success = TRUE)
[10:34:17.539]                               parallel_sendData(master, data)
[10:34:17.539]                             }
[10:34:17.539]                             return(sendCondition)
[10:34:17.539]                           }
[10:34:17.539]                         }
[10:34:17.539]                         frame <- frame + 1L
[10:34:17.539]                         envir <- sys.frame(frame)
[10:34:17.539]                       }
[10:34:17.539]                     }
[10:34:17.539]                     sendCondition <<- function(cond) NULL
[10:34:17.539]                   }
[10:34:17.539]                 })
[10:34:17.539]                 withCallingHandlers({
[10:34:17.539]                   {
[10:34:17.539]                     1
[10:34:17.539]                   }
[10:34:17.539]                 }, immediateCondition = function(cond) {
[10:34:17.539]                   sendCondition <- ...future.makeSendCondition()
[10:34:17.539]                   sendCondition(cond)
[10:34:17.539]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.539]                   {
[10:34:17.539]                     inherits <- base::inherits
[10:34:17.539]                     invokeRestart <- base::invokeRestart
[10:34:17.539]                     is.null <- base::is.null
[10:34:17.539]                     muffled <- FALSE
[10:34:17.539]                     if (inherits(cond, "message")) {
[10:34:17.539]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:17.539]                       if (muffled) 
[10:34:17.539]                         invokeRestart("muffleMessage")
[10:34:17.539]                     }
[10:34:17.539]                     else if (inherits(cond, "warning")) {
[10:34:17.539]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:17.539]                       if (muffled) 
[10:34:17.539]                         invokeRestart("muffleWarning")
[10:34:17.539]                     }
[10:34:17.539]                     else if (inherits(cond, "condition")) {
[10:34:17.539]                       if (!is.null(pattern)) {
[10:34:17.539]                         computeRestarts <- base::computeRestarts
[10:34:17.539]                         grepl <- base::grepl
[10:34:17.539]                         restarts <- computeRestarts(cond)
[10:34:17.539]                         for (restart in restarts) {
[10:34:17.539]                           name <- restart$name
[10:34:17.539]                           if (is.null(name)) 
[10:34:17.539]                             next
[10:34:17.539]                           if (!grepl(pattern, name)) 
[10:34:17.539]                             next
[10:34:17.539]                           invokeRestart(restart)
[10:34:17.539]                           muffled <- TRUE
[10:34:17.539]                           break
[10:34:17.539]                         }
[10:34:17.539]                       }
[10:34:17.539]                     }
[10:34:17.539]                     invisible(muffled)
[10:34:17.539]                   }
[10:34:17.539]                   muffleCondition(cond)
[10:34:17.539]                 })
[10:34:17.539]             }))
[10:34:17.539]             future::FutureResult(value = ...future.value$value, 
[10:34:17.539]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.539]                   ...future.rng), globalenv = if (FALSE) 
[10:34:17.539]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:17.539]                     ...future.globalenv.names))
[10:34:17.539]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:17.539]         }, condition = base::local({
[10:34:17.539]             c <- base::c
[10:34:17.539]             inherits <- base::inherits
[10:34:17.539]             invokeRestart <- base::invokeRestart
[10:34:17.539]             length <- base::length
[10:34:17.539]             list <- base::list
[10:34:17.539]             seq.int <- base::seq.int
[10:34:17.539]             signalCondition <- base::signalCondition
[10:34:17.539]             sys.calls <- base::sys.calls
[10:34:17.539]             `[[` <- base::`[[`
[10:34:17.539]             `+` <- base::`+`
[10:34:17.539]             `<<-` <- base::`<<-`
[10:34:17.539]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:17.539]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:17.539]                   3L)]
[10:34:17.539]             }
[10:34:17.539]             function(cond) {
[10:34:17.539]                 is_error <- inherits(cond, "error")
[10:34:17.539]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:17.539]                   NULL)
[10:34:17.539]                 if (is_error) {
[10:34:17.539]                   sessionInformation <- function() {
[10:34:17.539]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:17.539]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:17.539]                       search = base::search(), system = base::Sys.info())
[10:34:17.539]                   }
[10:34:17.539]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.539]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:17.539]                     cond$call), session = sessionInformation(), 
[10:34:17.539]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:17.539]                   signalCondition(cond)
[10:34:17.539]                 }
[10:34:17.539]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:17.539]                 "immediateCondition"))) {
[10:34:17.539]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:17.539]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.539]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:17.539]                   if (TRUE && !signal) {
[10:34:17.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.539]                     {
[10:34:17.539]                       inherits <- base::inherits
[10:34:17.539]                       invokeRestart <- base::invokeRestart
[10:34:17.539]                       is.null <- base::is.null
[10:34:17.539]                       muffled <- FALSE
[10:34:17.539]                       if (inherits(cond, "message")) {
[10:34:17.539]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.539]                         if (muffled) 
[10:34:17.539]                           invokeRestart("muffleMessage")
[10:34:17.539]                       }
[10:34:17.539]                       else if (inherits(cond, "warning")) {
[10:34:17.539]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.539]                         if (muffled) 
[10:34:17.539]                           invokeRestart("muffleWarning")
[10:34:17.539]                       }
[10:34:17.539]                       else if (inherits(cond, "condition")) {
[10:34:17.539]                         if (!is.null(pattern)) {
[10:34:17.539]                           computeRestarts <- base::computeRestarts
[10:34:17.539]                           grepl <- base::grepl
[10:34:17.539]                           restarts <- computeRestarts(cond)
[10:34:17.539]                           for (restart in restarts) {
[10:34:17.539]                             name <- restart$name
[10:34:17.539]                             if (is.null(name)) 
[10:34:17.539]                               next
[10:34:17.539]                             if (!grepl(pattern, name)) 
[10:34:17.539]                               next
[10:34:17.539]                             invokeRestart(restart)
[10:34:17.539]                             muffled <- TRUE
[10:34:17.539]                             break
[10:34:17.539]                           }
[10:34:17.539]                         }
[10:34:17.539]                       }
[10:34:17.539]                       invisible(muffled)
[10:34:17.539]                     }
[10:34:17.539]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.539]                   }
[10:34:17.539]                 }
[10:34:17.539]                 else {
[10:34:17.539]                   if (TRUE) {
[10:34:17.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.539]                     {
[10:34:17.539]                       inherits <- base::inherits
[10:34:17.539]                       invokeRestart <- base::invokeRestart
[10:34:17.539]                       is.null <- base::is.null
[10:34:17.539]                       muffled <- FALSE
[10:34:17.539]                       if (inherits(cond, "message")) {
[10:34:17.539]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.539]                         if (muffled) 
[10:34:17.539]                           invokeRestart("muffleMessage")
[10:34:17.539]                       }
[10:34:17.539]                       else if (inherits(cond, "warning")) {
[10:34:17.539]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.539]                         if (muffled) 
[10:34:17.539]                           invokeRestart("muffleWarning")
[10:34:17.539]                       }
[10:34:17.539]                       else if (inherits(cond, "condition")) {
[10:34:17.539]                         if (!is.null(pattern)) {
[10:34:17.539]                           computeRestarts <- base::computeRestarts
[10:34:17.539]                           grepl <- base::grepl
[10:34:17.539]                           restarts <- computeRestarts(cond)
[10:34:17.539]                           for (restart in restarts) {
[10:34:17.539]                             name <- restart$name
[10:34:17.539]                             if (is.null(name)) 
[10:34:17.539]                               next
[10:34:17.539]                             if (!grepl(pattern, name)) 
[10:34:17.539]                               next
[10:34:17.539]                             invokeRestart(restart)
[10:34:17.539]                             muffled <- TRUE
[10:34:17.539]                             break
[10:34:17.539]                           }
[10:34:17.539]                         }
[10:34:17.539]                       }
[10:34:17.539]                       invisible(muffled)
[10:34:17.539]                     }
[10:34:17.539]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.539]                   }
[10:34:17.539]                 }
[10:34:17.539]             }
[10:34:17.539]         }))
[10:34:17.539]     }, error = function(ex) {
[10:34:17.539]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:17.539]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.539]                 ...future.rng), started = ...future.startTime, 
[10:34:17.539]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:17.539]             version = "1.8"), class = "FutureResult")
[10:34:17.539]     }, finally = {
[10:34:17.539]         if (!identical(...future.workdir, getwd())) 
[10:34:17.539]             setwd(...future.workdir)
[10:34:17.539]         {
[10:34:17.539]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:17.539]                 ...future.oldOptions$nwarnings <- NULL
[10:34:17.539]             }
[10:34:17.539]             base::options(...future.oldOptions)
[10:34:17.539]             if (.Platform$OS.type == "windows") {
[10:34:17.539]                 old_names <- names(...future.oldEnvVars)
[10:34:17.539]                 envs <- base::Sys.getenv()
[10:34:17.539]                 names <- names(envs)
[10:34:17.539]                 common <- intersect(names, old_names)
[10:34:17.539]                 added <- setdiff(names, old_names)
[10:34:17.539]                 removed <- setdiff(old_names, names)
[10:34:17.539]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:17.539]                   envs[common]]
[10:34:17.539]                 NAMES <- toupper(changed)
[10:34:17.539]                 args <- list()
[10:34:17.539]                 for (kk in seq_along(NAMES)) {
[10:34:17.539]                   name <- changed[[kk]]
[10:34:17.539]                   NAME <- NAMES[[kk]]
[10:34:17.539]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.539]                     next
[10:34:17.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.539]                 }
[10:34:17.539]                 NAMES <- toupper(added)
[10:34:17.539]                 for (kk in seq_along(NAMES)) {
[10:34:17.539]                   name <- added[[kk]]
[10:34:17.539]                   NAME <- NAMES[[kk]]
[10:34:17.539]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.539]                     next
[10:34:17.539]                   args[[name]] <- ""
[10:34:17.539]                 }
[10:34:17.539]                 NAMES <- toupper(removed)
[10:34:17.539]                 for (kk in seq_along(NAMES)) {
[10:34:17.539]                   name <- removed[[kk]]
[10:34:17.539]                   NAME <- NAMES[[kk]]
[10:34:17.539]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.539]                     next
[10:34:17.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.539]                 }
[10:34:17.539]                 if (length(args) > 0) 
[10:34:17.539]                   base::do.call(base::Sys.setenv, args = args)
[10:34:17.539]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:17.539]             }
[10:34:17.539]             else {
[10:34:17.539]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:17.539]             }
[10:34:17.539]             {
[10:34:17.539]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:17.539]                   0L) {
[10:34:17.539]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:17.539]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:17.539]                   base::options(opts)
[10:34:17.539]                 }
[10:34:17.539]                 {
[10:34:17.539]                   {
[10:34:17.539]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:17.539]                     NULL
[10:34:17.539]                   }
[10:34:17.539]                   options(future.plan = NULL)
[10:34:17.539]                   if (is.na(NA_character_)) 
[10:34:17.539]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.539]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:17.539]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:17.539]                     .init = FALSE)
[10:34:17.539]                 }
[10:34:17.539]             }
[10:34:17.539]         }
[10:34:17.539]     })
[10:34:17.539]     if (TRUE) {
[10:34:17.539]         base::sink(type = "output", split = FALSE)
[10:34:17.539]         if (TRUE) {
[10:34:17.539]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:17.539]         }
[10:34:17.539]         else {
[10:34:17.539]             ...future.result["stdout"] <- base::list(NULL)
[10:34:17.539]         }
[10:34:17.539]         base::close(...future.stdout)
[10:34:17.539]         ...future.stdout <- NULL
[10:34:17.539]     }
[10:34:17.539]     ...future.result$conditions <- ...future.conditions
[10:34:17.539]     ...future.result$finished <- base::Sys.time()
[10:34:17.539]     ...future.result
[10:34:17.539] }
[10:34:17.541] MultisessionFuture started
[10:34:17.541] - Launch lazy future ... done
[10:34:17.542] run() for ‘MultisessionFuture’ ... done
[10:34:17.542] getGlobalsAndPackages() ...
[10:34:17.542] Searching for globals...
[10:34:17.543] - globals found: [1] ‘{’
[10:34:17.543] Searching for globals ... DONE
[10:34:17.543] Resolving globals: FALSE
[10:34:17.543] 
[10:34:17.543] 
[10:34:17.543] getGlobalsAndPackages() ... DONE
[10:34:17.543] run() for ‘Future’ ...
[10:34:17.544] - state: ‘created’
[10:34:17.544] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:17.557] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:17.557] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:17.557]   - Field: ‘node’
[10:34:17.557]   - Field: ‘label’
[10:34:17.558]   - Field: ‘local’
[10:34:17.558]   - Field: ‘owner’
[10:34:17.558]   - Field: ‘envir’
[10:34:17.558]   - Field: ‘workers’
[10:34:17.558]   - Field: ‘packages’
[10:34:17.558]   - Field: ‘gc’
[10:34:17.558]   - Field: ‘conditions’
[10:34:17.558]   - Field: ‘persistent’
[10:34:17.558]   - Field: ‘expr’
[10:34:17.558]   - Field: ‘uuid’
[10:34:17.558]   - Field: ‘seed’
[10:34:17.559]   - Field: ‘version’
[10:34:17.559]   - Field: ‘result’
[10:34:17.559]   - Field: ‘asynchronous’
[10:34:17.559]   - Field: ‘calls’
[10:34:17.559]   - Field: ‘globals’
[10:34:17.559]   - Field: ‘stdout’
[10:34:17.559]   - Field: ‘earlySignal’
[10:34:17.559]   - Field: ‘lazy’
[10:34:17.559]   - Field: ‘state’
[10:34:17.559] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:17.559] - Launch lazy future ...
[10:34:17.560] Packages needed by the future expression (n = 0): <none>
[10:34:17.560] Packages needed by future strategies (n = 0): <none>
[10:34:17.560] {
[10:34:17.560]     {
[10:34:17.560]         {
[10:34:17.560]             ...future.startTime <- base::Sys.time()
[10:34:17.560]             {
[10:34:17.560]                 {
[10:34:17.560]                   {
[10:34:17.560]                     {
[10:34:17.560]                       base::local({
[10:34:17.560]                         has_future <- base::requireNamespace("future", 
[10:34:17.560]                           quietly = TRUE)
[10:34:17.560]                         if (has_future) {
[10:34:17.560]                           ns <- base::getNamespace("future")
[10:34:17.560]                           version <- ns[[".package"]][["version"]]
[10:34:17.560]                           if (is.null(version)) 
[10:34:17.560]                             version <- utils::packageVersion("future")
[10:34:17.560]                         }
[10:34:17.560]                         else {
[10:34:17.560]                           version <- NULL
[10:34:17.560]                         }
[10:34:17.560]                         if (!has_future || version < "1.8.0") {
[10:34:17.560]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:17.560]                             "", base::R.version$version.string), 
[10:34:17.560]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:17.560]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:17.560]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:17.560]                               "release", "version")], collapse = " "), 
[10:34:17.560]                             hostname = base::Sys.info()[["nodename"]])
[10:34:17.560]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:17.560]                             info)
[10:34:17.560]                           info <- base::paste(info, collapse = "; ")
[10:34:17.560]                           if (!has_future) {
[10:34:17.560]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:17.560]                               info)
[10:34:17.560]                           }
[10:34:17.560]                           else {
[10:34:17.560]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:17.560]                               info, version)
[10:34:17.560]                           }
[10:34:17.560]                           base::stop(msg)
[10:34:17.560]                         }
[10:34:17.560]                       })
[10:34:17.560]                     }
[10:34:17.560]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:17.560]                     base::options(mc.cores = 1L)
[10:34:17.560]                   }
[10:34:17.560]                   ...future.strategy.old <- future::plan("list")
[10:34:17.560]                   options(future.plan = NULL)
[10:34:17.560]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.560]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:17.560]                 }
[10:34:17.560]                 ...future.workdir <- getwd()
[10:34:17.560]             }
[10:34:17.560]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:17.560]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:17.560]         }
[10:34:17.560]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:17.560]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:17.560]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:17.560]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:17.560]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:17.560]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:17.560]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:17.560]             base::names(...future.oldOptions))
[10:34:17.560]     }
[10:34:17.560]     if (FALSE) {
[10:34:17.560]     }
[10:34:17.560]     else {
[10:34:17.560]         if (TRUE) {
[10:34:17.560]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:17.560]                 open = "w")
[10:34:17.560]         }
[10:34:17.560]         else {
[10:34:17.560]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:17.560]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:17.560]         }
[10:34:17.560]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:17.560]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:17.560]             base::sink(type = "output", split = FALSE)
[10:34:17.560]             base::close(...future.stdout)
[10:34:17.560]         }, add = TRUE)
[10:34:17.560]     }
[10:34:17.560]     ...future.frame <- base::sys.nframe()
[10:34:17.560]     ...future.conditions <- base::list()
[10:34:17.560]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:17.560]     if (FALSE) {
[10:34:17.560]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:17.560]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:17.560]     }
[10:34:17.560]     ...future.result <- base::tryCatch({
[10:34:17.560]         base::withCallingHandlers({
[10:34:17.560]             ...future.value <- base::withVisible(base::local({
[10:34:17.560]                 ...future.makeSendCondition <- base::local({
[10:34:17.560]                   sendCondition <- NULL
[10:34:17.560]                   function(frame = 1L) {
[10:34:17.560]                     if (is.function(sendCondition)) 
[10:34:17.560]                       return(sendCondition)
[10:34:17.560]                     ns <- getNamespace("parallel")
[10:34:17.560]                     if (exists("sendData", mode = "function", 
[10:34:17.560]                       envir = ns)) {
[10:34:17.560]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:17.560]                         envir = ns)
[10:34:17.560]                       envir <- sys.frame(frame)
[10:34:17.560]                       master <- NULL
[10:34:17.560]                       while (!identical(envir, .GlobalEnv) && 
[10:34:17.560]                         !identical(envir, emptyenv())) {
[10:34:17.560]                         if (exists("master", mode = "list", envir = envir, 
[10:34:17.560]                           inherits = FALSE)) {
[10:34:17.560]                           master <- get("master", mode = "list", 
[10:34:17.560]                             envir = envir, inherits = FALSE)
[10:34:17.560]                           if (inherits(master, c("SOCKnode", 
[10:34:17.560]                             "SOCK0node"))) {
[10:34:17.560]                             sendCondition <<- function(cond) {
[10:34:17.560]                               data <- list(type = "VALUE", value = cond, 
[10:34:17.560]                                 success = TRUE)
[10:34:17.560]                               parallel_sendData(master, data)
[10:34:17.560]                             }
[10:34:17.560]                             return(sendCondition)
[10:34:17.560]                           }
[10:34:17.560]                         }
[10:34:17.560]                         frame <- frame + 1L
[10:34:17.560]                         envir <- sys.frame(frame)
[10:34:17.560]                       }
[10:34:17.560]                     }
[10:34:17.560]                     sendCondition <<- function(cond) NULL
[10:34:17.560]                   }
[10:34:17.560]                 })
[10:34:17.560]                 withCallingHandlers({
[10:34:17.560]                   {
[10:34:17.560]                     2
[10:34:17.560]                   }
[10:34:17.560]                 }, immediateCondition = function(cond) {
[10:34:17.560]                   sendCondition <- ...future.makeSendCondition()
[10:34:17.560]                   sendCondition(cond)
[10:34:17.560]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.560]                   {
[10:34:17.560]                     inherits <- base::inherits
[10:34:17.560]                     invokeRestart <- base::invokeRestart
[10:34:17.560]                     is.null <- base::is.null
[10:34:17.560]                     muffled <- FALSE
[10:34:17.560]                     if (inherits(cond, "message")) {
[10:34:17.560]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:17.560]                       if (muffled) 
[10:34:17.560]                         invokeRestart("muffleMessage")
[10:34:17.560]                     }
[10:34:17.560]                     else if (inherits(cond, "warning")) {
[10:34:17.560]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:17.560]                       if (muffled) 
[10:34:17.560]                         invokeRestart("muffleWarning")
[10:34:17.560]                     }
[10:34:17.560]                     else if (inherits(cond, "condition")) {
[10:34:17.560]                       if (!is.null(pattern)) {
[10:34:17.560]                         computeRestarts <- base::computeRestarts
[10:34:17.560]                         grepl <- base::grepl
[10:34:17.560]                         restarts <- computeRestarts(cond)
[10:34:17.560]                         for (restart in restarts) {
[10:34:17.560]                           name <- restart$name
[10:34:17.560]                           if (is.null(name)) 
[10:34:17.560]                             next
[10:34:17.560]                           if (!grepl(pattern, name)) 
[10:34:17.560]                             next
[10:34:17.560]                           invokeRestart(restart)
[10:34:17.560]                           muffled <- TRUE
[10:34:17.560]                           break
[10:34:17.560]                         }
[10:34:17.560]                       }
[10:34:17.560]                     }
[10:34:17.560]                     invisible(muffled)
[10:34:17.560]                   }
[10:34:17.560]                   muffleCondition(cond)
[10:34:17.560]                 })
[10:34:17.560]             }))
[10:34:17.560]             future::FutureResult(value = ...future.value$value, 
[10:34:17.560]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.560]                   ...future.rng), globalenv = if (FALSE) 
[10:34:17.560]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:17.560]                     ...future.globalenv.names))
[10:34:17.560]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:17.560]         }, condition = base::local({
[10:34:17.560]             c <- base::c
[10:34:17.560]             inherits <- base::inherits
[10:34:17.560]             invokeRestart <- base::invokeRestart
[10:34:17.560]             length <- base::length
[10:34:17.560]             list <- base::list
[10:34:17.560]             seq.int <- base::seq.int
[10:34:17.560]             signalCondition <- base::signalCondition
[10:34:17.560]             sys.calls <- base::sys.calls
[10:34:17.560]             `[[` <- base::`[[`
[10:34:17.560]             `+` <- base::`+`
[10:34:17.560]             `<<-` <- base::`<<-`
[10:34:17.560]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:17.560]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:17.560]                   3L)]
[10:34:17.560]             }
[10:34:17.560]             function(cond) {
[10:34:17.560]                 is_error <- inherits(cond, "error")
[10:34:17.560]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:17.560]                   NULL)
[10:34:17.560]                 if (is_error) {
[10:34:17.560]                   sessionInformation <- function() {
[10:34:17.560]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:17.560]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:17.560]                       search = base::search(), system = base::Sys.info())
[10:34:17.560]                   }
[10:34:17.560]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.560]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:17.560]                     cond$call), session = sessionInformation(), 
[10:34:17.560]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:17.560]                   signalCondition(cond)
[10:34:17.560]                 }
[10:34:17.560]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:17.560]                 "immediateCondition"))) {
[10:34:17.560]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:17.560]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.560]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:17.560]                   if (TRUE && !signal) {
[10:34:17.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.560]                     {
[10:34:17.560]                       inherits <- base::inherits
[10:34:17.560]                       invokeRestart <- base::invokeRestart
[10:34:17.560]                       is.null <- base::is.null
[10:34:17.560]                       muffled <- FALSE
[10:34:17.560]                       if (inherits(cond, "message")) {
[10:34:17.560]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.560]                         if (muffled) 
[10:34:17.560]                           invokeRestart("muffleMessage")
[10:34:17.560]                       }
[10:34:17.560]                       else if (inherits(cond, "warning")) {
[10:34:17.560]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.560]                         if (muffled) 
[10:34:17.560]                           invokeRestart("muffleWarning")
[10:34:17.560]                       }
[10:34:17.560]                       else if (inherits(cond, "condition")) {
[10:34:17.560]                         if (!is.null(pattern)) {
[10:34:17.560]                           computeRestarts <- base::computeRestarts
[10:34:17.560]                           grepl <- base::grepl
[10:34:17.560]                           restarts <- computeRestarts(cond)
[10:34:17.560]                           for (restart in restarts) {
[10:34:17.560]                             name <- restart$name
[10:34:17.560]                             if (is.null(name)) 
[10:34:17.560]                               next
[10:34:17.560]                             if (!grepl(pattern, name)) 
[10:34:17.560]                               next
[10:34:17.560]                             invokeRestart(restart)
[10:34:17.560]                             muffled <- TRUE
[10:34:17.560]                             break
[10:34:17.560]                           }
[10:34:17.560]                         }
[10:34:17.560]                       }
[10:34:17.560]                       invisible(muffled)
[10:34:17.560]                     }
[10:34:17.560]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.560]                   }
[10:34:17.560]                 }
[10:34:17.560]                 else {
[10:34:17.560]                   if (TRUE) {
[10:34:17.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.560]                     {
[10:34:17.560]                       inherits <- base::inherits
[10:34:17.560]                       invokeRestart <- base::invokeRestart
[10:34:17.560]                       is.null <- base::is.null
[10:34:17.560]                       muffled <- FALSE
[10:34:17.560]                       if (inherits(cond, "message")) {
[10:34:17.560]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.560]                         if (muffled) 
[10:34:17.560]                           invokeRestart("muffleMessage")
[10:34:17.560]                       }
[10:34:17.560]                       else if (inherits(cond, "warning")) {
[10:34:17.560]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.560]                         if (muffled) 
[10:34:17.560]                           invokeRestart("muffleWarning")
[10:34:17.560]                       }
[10:34:17.560]                       else if (inherits(cond, "condition")) {
[10:34:17.560]                         if (!is.null(pattern)) {
[10:34:17.560]                           computeRestarts <- base::computeRestarts
[10:34:17.560]                           grepl <- base::grepl
[10:34:17.560]                           restarts <- computeRestarts(cond)
[10:34:17.560]                           for (restart in restarts) {
[10:34:17.560]                             name <- restart$name
[10:34:17.560]                             if (is.null(name)) 
[10:34:17.560]                               next
[10:34:17.560]                             if (!grepl(pattern, name)) 
[10:34:17.560]                               next
[10:34:17.560]                             invokeRestart(restart)
[10:34:17.560]                             muffled <- TRUE
[10:34:17.560]                             break
[10:34:17.560]                           }
[10:34:17.560]                         }
[10:34:17.560]                       }
[10:34:17.560]                       invisible(muffled)
[10:34:17.560]                     }
[10:34:17.560]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.560]                   }
[10:34:17.560]                 }
[10:34:17.560]             }
[10:34:17.560]         }))
[10:34:17.560]     }, error = function(ex) {
[10:34:17.560]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:17.560]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.560]                 ...future.rng), started = ...future.startTime, 
[10:34:17.560]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:17.560]             version = "1.8"), class = "FutureResult")
[10:34:17.560]     }, finally = {
[10:34:17.560]         if (!identical(...future.workdir, getwd())) 
[10:34:17.560]             setwd(...future.workdir)
[10:34:17.560]         {
[10:34:17.560]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:17.560]                 ...future.oldOptions$nwarnings <- NULL
[10:34:17.560]             }
[10:34:17.560]             base::options(...future.oldOptions)
[10:34:17.560]             if (.Platform$OS.type == "windows") {
[10:34:17.560]                 old_names <- names(...future.oldEnvVars)
[10:34:17.560]                 envs <- base::Sys.getenv()
[10:34:17.560]                 names <- names(envs)
[10:34:17.560]                 common <- intersect(names, old_names)
[10:34:17.560]                 added <- setdiff(names, old_names)
[10:34:17.560]                 removed <- setdiff(old_names, names)
[10:34:17.560]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:17.560]                   envs[common]]
[10:34:17.560]                 NAMES <- toupper(changed)
[10:34:17.560]                 args <- list()
[10:34:17.560]                 for (kk in seq_along(NAMES)) {
[10:34:17.560]                   name <- changed[[kk]]
[10:34:17.560]                   NAME <- NAMES[[kk]]
[10:34:17.560]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.560]                     next
[10:34:17.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.560]                 }
[10:34:17.560]                 NAMES <- toupper(added)
[10:34:17.560]                 for (kk in seq_along(NAMES)) {
[10:34:17.560]                   name <- added[[kk]]
[10:34:17.560]                   NAME <- NAMES[[kk]]
[10:34:17.560]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.560]                     next
[10:34:17.560]                   args[[name]] <- ""
[10:34:17.560]                 }
[10:34:17.560]                 NAMES <- toupper(removed)
[10:34:17.560]                 for (kk in seq_along(NAMES)) {
[10:34:17.560]                   name <- removed[[kk]]
[10:34:17.560]                   NAME <- NAMES[[kk]]
[10:34:17.560]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.560]                     next
[10:34:17.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.560]                 }
[10:34:17.560]                 if (length(args) > 0) 
[10:34:17.560]                   base::do.call(base::Sys.setenv, args = args)
[10:34:17.560]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:17.560]             }
[10:34:17.560]             else {
[10:34:17.560]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:17.560]             }
[10:34:17.560]             {
[10:34:17.560]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:17.560]                   0L) {
[10:34:17.560]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:17.560]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:17.560]                   base::options(opts)
[10:34:17.560]                 }
[10:34:17.560]                 {
[10:34:17.560]                   {
[10:34:17.560]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:17.560]                     NULL
[10:34:17.560]                   }
[10:34:17.560]                   options(future.plan = NULL)
[10:34:17.560]                   if (is.na(NA_character_)) 
[10:34:17.560]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.560]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:17.560]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:17.560]                     .init = FALSE)
[10:34:17.560]                 }
[10:34:17.560]             }
[10:34:17.560]         }
[10:34:17.560]     })
[10:34:17.560]     if (TRUE) {
[10:34:17.560]         base::sink(type = "output", split = FALSE)
[10:34:17.560]         if (TRUE) {
[10:34:17.560]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:17.560]         }
[10:34:17.560]         else {
[10:34:17.560]             ...future.result["stdout"] <- base::list(NULL)
[10:34:17.560]         }
[10:34:17.560]         base::close(...future.stdout)
[10:34:17.560]         ...future.stdout <- NULL
[10:34:17.560]     }
[10:34:17.560]     ...future.result$conditions <- ...future.conditions
[10:34:17.560]     ...future.result$finished <- base::Sys.time()
[10:34:17.560]     ...future.result
[10:34:17.560] }
[10:34:17.563] MultisessionFuture started
[10:34:17.563] - Launch lazy future ... done
[10:34:17.563] run() for ‘MultisessionFuture’ ... done
[10:34:17.564] resolve() on list environment ...
[10:34:17.564]  recursive: 0
[10:34:17.564]  length: 3
[10:34:17.564]  elements: ‘a’, ‘b’, ‘c’
[10:34:17.565] receiveMessageFromWorker() for ClusterFuture ...
[10:34:17.565] - Validating connection of MultisessionFuture
[10:34:17.565] - received message: FutureResult
[10:34:17.565] - Received FutureResult
[10:34:17.566] - Erased future from FutureRegistry
[10:34:17.566] result() for ClusterFuture ...
[10:34:17.566] - result already collected: FutureResult
[10:34:17.566] result() for ClusterFuture ... done
[10:34:17.566] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:17.566] Future #1
[10:34:17.566]  length: 2 (resolved future 1)
[10:34:17.566] receiveMessageFromWorker() for ClusterFuture ...
[10:34:17.567] - Validating connection of MultisessionFuture
[10:34:17.567] - received message: FutureResult
[10:34:17.567] - Received FutureResult
[10:34:17.567] - Erased future from FutureRegistry
[10:34:17.567] result() for ClusterFuture ...
[10:34:17.567] - result already collected: FutureResult
[10:34:17.567] result() for ClusterFuture ... done
[10:34:17.567] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:17.567] Future #2
[10:34:17.568]  length: 1 (resolved future 2)
[10:34:17.568]  length: 0 (resolved future 3)
[10:34:17.568] resolve() on list environment ... DONE
[10:34:17.568] getGlobalsAndPackages() ...
[10:34:17.568] Searching for globals...
[10:34:17.569] - globals found: [1] ‘{’
[10:34:17.569] Searching for globals ... DONE
[10:34:17.569] Resolving globals: FALSE
[10:34:17.569] 
[10:34:17.569] 
[10:34:17.570] getGlobalsAndPackages() ... DONE
[10:34:17.570] run() for ‘Future’ ...
[10:34:17.570] - state: ‘created’
[10:34:17.570] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:17.583] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:17.583] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:17.584]   - Field: ‘node’
[10:34:17.584]   - Field: ‘label’
[10:34:17.584]   - Field: ‘local’
[10:34:17.584]   - Field: ‘owner’
[10:34:17.584]   - Field: ‘envir’
[10:34:17.584]   - Field: ‘workers’
[10:34:17.584]   - Field: ‘packages’
[10:34:17.584]   - Field: ‘gc’
[10:34:17.584]   - Field: ‘conditions’
[10:34:17.584]   - Field: ‘persistent’
[10:34:17.584]   - Field: ‘expr’
[10:34:17.585]   - Field: ‘uuid’
[10:34:17.585]   - Field: ‘seed’
[10:34:17.585]   - Field: ‘version’
[10:34:17.585]   - Field: ‘result’
[10:34:17.585]   - Field: ‘asynchronous’
[10:34:17.585]   - Field: ‘calls’
[10:34:17.585]   - Field: ‘globals’
[10:34:17.585]   - Field: ‘stdout’
[10:34:17.585]   - Field: ‘earlySignal’
[10:34:17.585]   - Field: ‘lazy’
[10:34:17.586]   - Field: ‘state’
[10:34:17.586] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:17.586] - Launch lazy future ...
[10:34:17.586] Packages needed by the future expression (n = 0): <none>
[10:34:17.586] Packages needed by future strategies (n = 0): <none>
[10:34:17.586] {
[10:34:17.586]     {
[10:34:17.586]         {
[10:34:17.586]             ...future.startTime <- base::Sys.time()
[10:34:17.586]             {
[10:34:17.586]                 {
[10:34:17.586]                   {
[10:34:17.586]                     {
[10:34:17.586]                       base::local({
[10:34:17.586]                         has_future <- base::requireNamespace("future", 
[10:34:17.586]                           quietly = TRUE)
[10:34:17.586]                         if (has_future) {
[10:34:17.586]                           ns <- base::getNamespace("future")
[10:34:17.586]                           version <- ns[[".package"]][["version"]]
[10:34:17.586]                           if (is.null(version)) 
[10:34:17.586]                             version <- utils::packageVersion("future")
[10:34:17.586]                         }
[10:34:17.586]                         else {
[10:34:17.586]                           version <- NULL
[10:34:17.586]                         }
[10:34:17.586]                         if (!has_future || version < "1.8.0") {
[10:34:17.586]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:17.586]                             "", base::R.version$version.string), 
[10:34:17.586]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:17.586]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:17.586]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:17.586]                               "release", "version")], collapse = " "), 
[10:34:17.586]                             hostname = base::Sys.info()[["nodename"]])
[10:34:17.586]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:17.586]                             info)
[10:34:17.586]                           info <- base::paste(info, collapse = "; ")
[10:34:17.586]                           if (!has_future) {
[10:34:17.586]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:17.586]                               info)
[10:34:17.586]                           }
[10:34:17.586]                           else {
[10:34:17.586]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:17.586]                               info, version)
[10:34:17.586]                           }
[10:34:17.586]                           base::stop(msg)
[10:34:17.586]                         }
[10:34:17.586]                       })
[10:34:17.586]                     }
[10:34:17.586]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:17.586]                     base::options(mc.cores = 1L)
[10:34:17.586]                   }
[10:34:17.586]                   ...future.strategy.old <- future::plan("list")
[10:34:17.586]                   options(future.plan = NULL)
[10:34:17.586]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.586]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:17.586]                 }
[10:34:17.586]                 ...future.workdir <- getwd()
[10:34:17.586]             }
[10:34:17.586]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:17.586]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:17.586]         }
[10:34:17.586]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:17.586]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:17.586]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:17.586]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:17.586]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:17.586]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:17.586]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:17.586]             base::names(...future.oldOptions))
[10:34:17.586]     }
[10:34:17.586]     if (FALSE) {
[10:34:17.586]     }
[10:34:17.586]     else {
[10:34:17.586]         if (TRUE) {
[10:34:17.586]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:17.586]                 open = "w")
[10:34:17.586]         }
[10:34:17.586]         else {
[10:34:17.586]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:17.586]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:17.586]         }
[10:34:17.586]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:17.586]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:17.586]             base::sink(type = "output", split = FALSE)
[10:34:17.586]             base::close(...future.stdout)
[10:34:17.586]         }, add = TRUE)
[10:34:17.586]     }
[10:34:17.586]     ...future.frame <- base::sys.nframe()
[10:34:17.586]     ...future.conditions <- base::list()
[10:34:17.586]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:17.586]     if (FALSE) {
[10:34:17.586]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:17.586]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:17.586]     }
[10:34:17.586]     ...future.result <- base::tryCatch({
[10:34:17.586]         base::withCallingHandlers({
[10:34:17.586]             ...future.value <- base::withVisible(base::local({
[10:34:17.586]                 ...future.makeSendCondition <- base::local({
[10:34:17.586]                   sendCondition <- NULL
[10:34:17.586]                   function(frame = 1L) {
[10:34:17.586]                     if (is.function(sendCondition)) 
[10:34:17.586]                       return(sendCondition)
[10:34:17.586]                     ns <- getNamespace("parallel")
[10:34:17.586]                     if (exists("sendData", mode = "function", 
[10:34:17.586]                       envir = ns)) {
[10:34:17.586]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:17.586]                         envir = ns)
[10:34:17.586]                       envir <- sys.frame(frame)
[10:34:17.586]                       master <- NULL
[10:34:17.586]                       while (!identical(envir, .GlobalEnv) && 
[10:34:17.586]                         !identical(envir, emptyenv())) {
[10:34:17.586]                         if (exists("master", mode = "list", envir = envir, 
[10:34:17.586]                           inherits = FALSE)) {
[10:34:17.586]                           master <- get("master", mode = "list", 
[10:34:17.586]                             envir = envir, inherits = FALSE)
[10:34:17.586]                           if (inherits(master, c("SOCKnode", 
[10:34:17.586]                             "SOCK0node"))) {
[10:34:17.586]                             sendCondition <<- function(cond) {
[10:34:17.586]                               data <- list(type = "VALUE", value = cond, 
[10:34:17.586]                                 success = TRUE)
[10:34:17.586]                               parallel_sendData(master, data)
[10:34:17.586]                             }
[10:34:17.586]                             return(sendCondition)
[10:34:17.586]                           }
[10:34:17.586]                         }
[10:34:17.586]                         frame <- frame + 1L
[10:34:17.586]                         envir <- sys.frame(frame)
[10:34:17.586]                       }
[10:34:17.586]                     }
[10:34:17.586]                     sendCondition <<- function(cond) NULL
[10:34:17.586]                   }
[10:34:17.586]                 })
[10:34:17.586]                 withCallingHandlers({
[10:34:17.586]                   {
[10:34:17.586]                     1
[10:34:17.586]                   }
[10:34:17.586]                 }, immediateCondition = function(cond) {
[10:34:17.586]                   sendCondition <- ...future.makeSendCondition()
[10:34:17.586]                   sendCondition(cond)
[10:34:17.586]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.586]                   {
[10:34:17.586]                     inherits <- base::inherits
[10:34:17.586]                     invokeRestart <- base::invokeRestart
[10:34:17.586]                     is.null <- base::is.null
[10:34:17.586]                     muffled <- FALSE
[10:34:17.586]                     if (inherits(cond, "message")) {
[10:34:17.586]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:17.586]                       if (muffled) 
[10:34:17.586]                         invokeRestart("muffleMessage")
[10:34:17.586]                     }
[10:34:17.586]                     else if (inherits(cond, "warning")) {
[10:34:17.586]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:17.586]                       if (muffled) 
[10:34:17.586]                         invokeRestart("muffleWarning")
[10:34:17.586]                     }
[10:34:17.586]                     else if (inherits(cond, "condition")) {
[10:34:17.586]                       if (!is.null(pattern)) {
[10:34:17.586]                         computeRestarts <- base::computeRestarts
[10:34:17.586]                         grepl <- base::grepl
[10:34:17.586]                         restarts <- computeRestarts(cond)
[10:34:17.586]                         for (restart in restarts) {
[10:34:17.586]                           name <- restart$name
[10:34:17.586]                           if (is.null(name)) 
[10:34:17.586]                             next
[10:34:17.586]                           if (!grepl(pattern, name)) 
[10:34:17.586]                             next
[10:34:17.586]                           invokeRestart(restart)
[10:34:17.586]                           muffled <- TRUE
[10:34:17.586]                           break
[10:34:17.586]                         }
[10:34:17.586]                       }
[10:34:17.586]                     }
[10:34:17.586]                     invisible(muffled)
[10:34:17.586]                   }
[10:34:17.586]                   muffleCondition(cond)
[10:34:17.586]                 })
[10:34:17.586]             }))
[10:34:17.586]             future::FutureResult(value = ...future.value$value, 
[10:34:17.586]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.586]                   ...future.rng), globalenv = if (FALSE) 
[10:34:17.586]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:17.586]                     ...future.globalenv.names))
[10:34:17.586]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:17.586]         }, condition = base::local({
[10:34:17.586]             c <- base::c
[10:34:17.586]             inherits <- base::inherits
[10:34:17.586]             invokeRestart <- base::invokeRestart
[10:34:17.586]             length <- base::length
[10:34:17.586]             list <- base::list
[10:34:17.586]             seq.int <- base::seq.int
[10:34:17.586]             signalCondition <- base::signalCondition
[10:34:17.586]             sys.calls <- base::sys.calls
[10:34:17.586]             `[[` <- base::`[[`
[10:34:17.586]             `+` <- base::`+`
[10:34:17.586]             `<<-` <- base::`<<-`
[10:34:17.586]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:17.586]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:17.586]                   3L)]
[10:34:17.586]             }
[10:34:17.586]             function(cond) {
[10:34:17.586]                 is_error <- inherits(cond, "error")
[10:34:17.586]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:17.586]                   NULL)
[10:34:17.586]                 if (is_error) {
[10:34:17.586]                   sessionInformation <- function() {
[10:34:17.586]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:17.586]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:17.586]                       search = base::search(), system = base::Sys.info())
[10:34:17.586]                   }
[10:34:17.586]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.586]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:17.586]                     cond$call), session = sessionInformation(), 
[10:34:17.586]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:17.586]                   signalCondition(cond)
[10:34:17.586]                 }
[10:34:17.586]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:17.586]                 "immediateCondition"))) {
[10:34:17.586]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:17.586]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.586]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:17.586]                   if (TRUE && !signal) {
[10:34:17.586]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.586]                     {
[10:34:17.586]                       inherits <- base::inherits
[10:34:17.586]                       invokeRestart <- base::invokeRestart
[10:34:17.586]                       is.null <- base::is.null
[10:34:17.586]                       muffled <- FALSE
[10:34:17.586]                       if (inherits(cond, "message")) {
[10:34:17.586]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.586]                         if (muffled) 
[10:34:17.586]                           invokeRestart("muffleMessage")
[10:34:17.586]                       }
[10:34:17.586]                       else if (inherits(cond, "warning")) {
[10:34:17.586]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.586]                         if (muffled) 
[10:34:17.586]                           invokeRestart("muffleWarning")
[10:34:17.586]                       }
[10:34:17.586]                       else if (inherits(cond, "condition")) {
[10:34:17.586]                         if (!is.null(pattern)) {
[10:34:17.586]                           computeRestarts <- base::computeRestarts
[10:34:17.586]                           grepl <- base::grepl
[10:34:17.586]                           restarts <- computeRestarts(cond)
[10:34:17.586]                           for (restart in restarts) {
[10:34:17.586]                             name <- restart$name
[10:34:17.586]                             if (is.null(name)) 
[10:34:17.586]                               next
[10:34:17.586]                             if (!grepl(pattern, name)) 
[10:34:17.586]                               next
[10:34:17.586]                             invokeRestart(restart)
[10:34:17.586]                             muffled <- TRUE
[10:34:17.586]                             break
[10:34:17.586]                           }
[10:34:17.586]                         }
[10:34:17.586]                       }
[10:34:17.586]                       invisible(muffled)
[10:34:17.586]                     }
[10:34:17.586]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.586]                   }
[10:34:17.586]                 }
[10:34:17.586]                 else {
[10:34:17.586]                   if (TRUE) {
[10:34:17.586]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.586]                     {
[10:34:17.586]                       inherits <- base::inherits
[10:34:17.586]                       invokeRestart <- base::invokeRestart
[10:34:17.586]                       is.null <- base::is.null
[10:34:17.586]                       muffled <- FALSE
[10:34:17.586]                       if (inherits(cond, "message")) {
[10:34:17.586]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.586]                         if (muffled) 
[10:34:17.586]                           invokeRestart("muffleMessage")
[10:34:17.586]                       }
[10:34:17.586]                       else if (inherits(cond, "warning")) {
[10:34:17.586]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.586]                         if (muffled) 
[10:34:17.586]                           invokeRestart("muffleWarning")
[10:34:17.586]                       }
[10:34:17.586]                       else if (inherits(cond, "condition")) {
[10:34:17.586]                         if (!is.null(pattern)) {
[10:34:17.586]                           computeRestarts <- base::computeRestarts
[10:34:17.586]                           grepl <- base::grepl
[10:34:17.586]                           restarts <- computeRestarts(cond)
[10:34:17.586]                           for (restart in restarts) {
[10:34:17.586]                             name <- restart$name
[10:34:17.586]                             if (is.null(name)) 
[10:34:17.586]                               next
[10:34:17.586]                             if (!grepl(pattern, name)) 
[10:34:17.586]                               next
[10:34:17.586]                             invokeRestart(restart)
[10:34:17.586]                             muffled <- TRUE
[10:34:17.586]                             break
[10:34:17.586]                           }
[10:34:17.586]                         }
[10:34:17.586]                       }
[10:34:17.586]                       invisible(muffled)
[10:34:17.586]                     }
[10:34:17.586]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.586]                   }
[10:34:17.586]                 }
[10:34:17.586]             }
[10:34:17.586]         }))
[10:34:17.586]     }, error = function(ex) {
[10:34:17.586]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:17.586]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.586]                 ...future.rng), started = ...future.startTime, 
[10:34:17.586]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:17.586]             version = "1.8"), class = "FutureResult")
[10:34:17.586]     }, finally = {
[10:34:17.586]         if (!identical(...future.workdir, getwd())) 
[10:34:17.586]             setwd(...future.workdir)
[10:34:17.586]         {
[10:34:17.586]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:17.586]                 ...future.oldOptions$nwarnings <- NULL
[10:34:17.586]             }
[10:34:17.586]             base::options(...future.oldOptions)
[10:34:17.586]             if (.Platform$OS.type == "windows") {
[10:34:17.586]                 old_names <- names(...future.oldEnvVars)
[10:34:17.586]                 envs <- base::Sys.getenv()
[10:34:17.586]                 names <- names(envs)
[10:34:17.586]                 common <- intersect(names, old_names)
[10:34:17.586]                 added <- setdiff(names, old_names)
[10:34:17.586]                 removed <- setdiff(old_names, names)
[10:34:17.586]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:17.586]                   envs[common]]
[10:34:17.586]                 NAMES <- toupper(changed)
[10:34:17.586]                 args <- list()
[10:34:17.586]                 for (kk in seq_along(NAMES)) {
[10:34:17.586]                   name <- changed[[kk]]
[10:34:17.586]                   NAME <- NAMES[[kk]]
[10:34:17.586]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.586]                     next
[10:34:17.586]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.586]                 }
[10:34:17.586]                 NAMES <- toupper(added)
[10:34:17.586]                 for (kk in seq_along(NAMES)) {
[10:34:17.586]                   name <- added[[kk]]
[10:34:17.586]                   NAME <- NAMES[[kk]]
[10:34:17.586]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.586]                     next
[10:34:17.586]                   args[[name]] <- ""
[10:34:17.586]                 }
[10:34:17.586]                 NAMES <- toupper(removed)
[10:34:17.586]                 for (kk in seq_along(NAMES)) {
[10:34:17.586]                   name <- removed[[kk]]
[10:34:17.586]                   NAME <- NAMES[[kk]]
[10:34:17.586]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.586]                     next
[10:34:17.586]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.586]                 }
[10:34:17.586]                 if (length(args) > 0) 
[10:34:17.586]                   base::do.call(base::Sys.setenv, args = args)
[10:34:17.586]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:17.586]             }
[10:34:17.586]             else {
[10:34:17.586]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:17.586]             }
[10:34:17.586]             {
[10:34:17.586]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:17.586]                   0L) {
[10:34:17.586]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:17.586]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:17.586]                   base::options(opts)
[10:34:17.586]                 }
[10:34:17.586]                 {
[10:34:17.586]                   {
[10:34:17.586]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:17.586]                     NULL
[10:34:17.586]                   }
[10:34:17.586]                   options(future.plan = NULL)
[10:34:17.586]                   if (is.na(NA_character_)) 
[10:34:17.586]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.586]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:17.586]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:17.586]                     .init = FALSE)
[10:34:17.586]                 }
[10:34:17.586]             }
[10:34:17.586]         }
[10:34:17.586]     })
[10:34:17.586]     if (TRUE) {
[10:34:17.586]         base::sink(type = "output", split = FALSE)
[10:34:17.586]         if (TRUE) {
[10:34:17.586]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:17.586]         }
[10:34:17.586]         else {
[10:34:17.586]             ...future.result["stdout"] <- base::list(NULL)
[10:34:17.586]         }
[10:34:17.586]         base::close(...future.stdout)
[10:34:17.586]         ...future.stdout <- NULL
[10:34:17.586]     }
[10:34:17.586]     ...future.result$conditions <- ...future.conditions
[10:34:17.586]     ...future.result$finished <- base::Sys.time()
[10:34:17.586]     ...future.result
[10:34:17.586] }
[10:34:17.589] MultisessionFuture started
[10:34:17.589] - Launch lazy future ... done
[10:34:17.589] run() for ‘MultisessionFuture’ ... done
[10:34:17.590] getGlobalsAndPackages() ...
[10:34:17.590] Searching for globals...
[10:34:17.591] - globals found: [2] ‘{’, ‘Sys.sleep’
[10:34:17.591] Searching for globals ... DONE
[10:34:17.591] Resolving globals: FALSE
[10:34:17.591] 
[10:34:17.591] 
[10:34:17.592] getGlobalsAndPackages() ... DONE
[10:34:17.592] run() for ‘Future’ ...
[10:34:17.592] - state: ‘created’
[10:34:17.592] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:17.605] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:17.606] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:17.606]   - Field: ‘node’
[10:34:17.606]   - Field: ‘label’
[10:34:17.606]   - Field: ‘local’
[10:34:17.606]   - Field: ‘owner’
[10:34:17.606]   - Field: ‘envir’
[10:34:17.606]   - Field: ‘workers’
[10:34:17.606]   - Field: ‘packages’
[10:34:17.606]   - Field: ‘gc’
[10:34:17.606]   - Field: ‘conditions’
[10:34:17.607]   - Field: ‘persistent’
[10:34:17.607]   - Field: ‘expr’
[10:34:17.607]   - Field: ‘uuid’
[10:34:17.607]   - Field: ‘seed’
[10:34:17.607]   - Field: ‘version’
[10:34:17.607]   - Field: ‘result’
[10:34:17.607]   - Field: ‘asynchronous’
[10:34:17.607]   - Field: ‘calls’
[10:34:17.607]   - Field: ‘globals’
[10:34:17.607]   - Field: ‘stdout’
[10:34:17.607]   - Field: ‘earlySignal’
[10:34:17.607]   - Field: ‘lazy’
[10:34:17.608]   - Field: ‘state’
[10:34:17.608] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:17.608] - Launch lazy future ...
[10:34:17.608] Packages needed by the future expression (n = 0): <none>
[10:34:17.608] Packages needed by future strategies (n = 0): <none>
[10:34:17.609] {
[10:34:17.609]     {
[10:34:17.609]         {
[10:34:17.609]             ...future.startTime <- base::Sys.time()
[10:34:17.609]             {
[10:34:17.609]                 {
[10:34:17.609]                   {
[10:34:17.609]                     {
[10:34:17.609]                       base::local({
[10:34:17.609]                         has_future <- base::requireNamespace("future", 
[10:34:17.609]                           quietly = TRUE)
[10:34:17.609]                         if (has_future) {
[10:34:17.609]                           ns <- base::getNamespace("future")
[10:34:17.609]                           version <- ns[[".package"]][["version"]]
[10:34:17.609]                           if (is.null(version)) 
[10:34:17.609]                             version <- utils::packageVersion("future")
[10:34:17.609]                         }
[10:34:17.609]                         else {
[10:34:17.609]                           version <- NULL
[10:34:17.609]                         }
[10:34:17.609]                         if (!has_future || version < "1.8.0") {
[10:34:17.609]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:17.609]                             "", base::R.version$version.string), 
[10:34:17.609]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:17.609]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:17.609]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:17.609]                               "release", "version")], collapse = " "), 
[10:34:17.609]                             hostname = base::Sys.info()[["nodename"]])
[10:34:17.609]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:17.609]                             info)
[10:34:17.609]                           info <- base::paste(info, collapse = "; ")
[10:34:17.609]                           if (!has_future) {
[10:34:17.609]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:17.609]                               info)
[10:34:17.609]                           }
[10:34:17.609]                           else {
[10:34:17.609]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:17.609]                               info, version)
[10:34:17.609]                           }
[10:34:17.609]                           base::stop(msg)
[10:34:17.609]                         }
[10:34:17.609]                       })
[10:34:17.609]                     }
[10:34:17.609]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:17.609]                     base::options(mc.cores = 1L)
[10:34:17.609]                   }
[10:34:17.609]                   ...future.strategy.old <- future::plan("list")
[10:34:17.609]                   options(future.plan = NULL)
[10:34:17.609]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.609]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:17.609]                 }
[10:34:17.609]                 ...future.workdir <- getwd()
[10:34:17.609]             }
[10:34:17.609]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:17.609]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:17.609]         }
[10:34:17.609]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:17.609]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:17.609]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:17.609]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:17.609]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:17.609]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:17.609]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:17.609]             base::names(...future.oldOptions))
[10:34:17.609]     }
[10:34:17.609]     if (FALSE) {
[10:34:17.609]     }
[10:34:17.609]     else {
[10:34:17.609]         if (TRUE) {
[10:34:17.609]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:17.609]                 open = "w")
[10:34:17.609]         }
[10:34:17.609]         else {
[10:34:17.609]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:17.609]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:17.609]         }
[10:34:17.609]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:17.609]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:17.609]             base::sink(type = "output", split = FALSE)
[10:34:17.609]             base::close(...future.stdout)
[10:34:17.609]         }, add = TRUE)
[10:34:17.609]     }
[10:34:17.609]     ...future.frame <- base::sys.nframe()
[10:34:17.609]     ...future.conditions <- base::list()
[10:34:17.609]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:17.609]     if (FALSE) {
[10:34:17.609]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:17.609]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:17.609]     }
[10:34:17.609]     ...future.result <- base::tryCatch({
[10:34:17.609]         base::withCallingHandlers({
[10:34:17.609]             ...future.value <- base::withVisible(base::local({
[10:34:17.609]                 ...future.makeSendCondition <- base::local({
[10:34:17.609]                   sendCondition <- NULL
[10:34:17.609]                   function(frame = 1L) {
[10:34:17.609]                     if (is.function(sendCondition)) 
[10:34:17.609]                       return(sendCondition)
[10:34:17.609]                     ns <- getNamespace("parallel")
[10:34:17.609]                     if (exists("sendData", mode = "function", 
[10:34:17.609]                       envir = ns)) {
[10:34:17.609]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:17.609]                         envir = ns)
[10:34:17.609]                       envir <- sys.frame(frame)
[10:34:17.609]                       master <- NULL
[10:34:17.609]                       while (!identical(envir, .GlobalEnv) && 
[10:34:17.609]                         !identical(envir, emptyenv())) {
[10:34:17.609]                         if (exists("master", mode = "list", envir = envir, 
[10:34:17.609]                           inherits = FALSE)) {
[10:34:17.609]                           master <- get("master", mode = "list", 
[10:34:17.609]                             envir = envir, inherits = FALSE)
[10:34:17.609]                           if (inherits(master, c("SOCKnode", 
[10:34:17.609]                             "SOCK0node"))) {
[10:34:17.609]                             sendCondition <<- function(cond) {
[10:34:17.609]                               data <- list(type = "VALUE", value = cond, 
[10:34:17.609]                                 success = TRUE)
[10:34:17.609]                               parallel_sendData(master, data)
[10:34:17.609]                             }
[10:34:17.609]                             return(sendCondition)
[10:34:17.609]                           }
[10:34:17.609]                         }
[10:34:17.609]                         frame <- frame + 1L
[10:34:17.609]                         envir <- sys.frame(frame)
[10:34:17.609]                       }
[10:34:17.609]                     }
[10:34:17.609]                     sendCondition <<- function(cond) NULL
[10:34:17.609]                   }
[10:34:17.609]                 })
[10:34:17.609]                 withCallingHandlers({
[10:34:17.609]                   {
[10:34:17.609]                     Sys.sleep(0.5)
[10:34:17.609]                     2
[10:34:17.609]                   }
[10:34:17.609]                 }, immediateCondition = function(cond) {
[10:34:17.609]                   sendCondition <- ...future.makeSendCondition()
[10:34:17.609]                   sendCondition(cond)
[10:34:17.609]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.609]                   {
[10:34:17.609]                     inherits <- base::inherits
[10:34:17.609]                     invokeRestart <- base::invokeRestart
[10:34:17.609]                     is.null <- base::is.null
[10:34:17.609]                     muffled <- FALSE
[10:34:17.609]                     if (inherits(cond, "message")) {
[10:34:17.609]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:17.609]                       if (muffled) 
[10:34:17.609]                         invokeRestart("muffleMessage")
[10:34:17.609]                     }
[10:34:17.609]                     else if (inherits(cond, "warning")) {
[10:34:17.609]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:17.609]                       if (muffled) 
[10:34:17.609]                         invokeRestart("muffleWarning")
[10:34:17.609]                     }
[10:34:17.609]                     else if (inherits(cond, "condition")) {
[10:34:17.609]                       if (!is.null(pattern)) {
[10:34:17.609]                         computeRestarts <- base::computeRestarts
[10:34:17.609]                         grepl <- base::grepl
[10:34:17.609]                         restarts <- computeRestarts(cond)
[10:34:17.609]                         for (restart in restarts) {
[10:34:17.609]                           name <- restart$name
[10:34:17.609]                           if (is.null(name)) 
[10:34:17.609]                             next
[10:34:17.609]                           if (!grepl(pattern, name)) 
[10:34:17.609]                             next
[10:34:17.609]                           invokeRestart(restart)
[10:34:17.609]                           muffled <- TRUE
[10:34:17.609]                           break
[10:34:17.609]                         }
[10:34:17.609]                       }
[10:34:17.609]                     }
[10:34:17.609]                     invisible(muffled)
[10:34:17.609]                   }
[10:34:17.609]                   muffleCondition(cond)
[10:34:17.609]                 })
[10:34:17.609]             }))
[10:34:17.609]             future::FutureResult(value = ...future.value$value, 
[10:34:17.609]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.609]                   ...future.rng), globalenv = if (FALSE) 
[10:34:17.609]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:17.609]                     ...future.globalenv.names))
[10:34:17.609]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:17.609]         }, condition = base::local({
[10:34:17.609]             c <- base::c
[10:34:17.609]             inherits <- base::inherits
[10:34:17.609]             invokeRestart <- base::invokeRestart
[10:34:17.609]             length <- base::length
[10:34:17.609]             list <- base::list
[10:34:17.609]             seq.int <- base::seq.int
[10:34:17.609]             signalCondition <- base::signalCondition
[10:34:17.609]             sys.calls <- base::sys.calls
[10:34:17.609]             `[[` <- base::`[[`
[10:34:17.609]             `+` <- base::`+`
[10:34:17.609]             `<<-` <- base::`<<-`
[10:34:17.609]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:17.609]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:17.609]                   3L)]
[10:34:17.609]             }
[10:34:17.609]             function(cond) {
[10:34:17.609]                 is_error <- inherits(cond, "error")
[10:34:17.609]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:17.609]                   NULL)
[10:34:17.609]                 if (is_error) {
[10:34:17.609]                   sessionInformation <- function() {
[10:34:17.609]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:17.609]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:17.609]                       search = base::search(), system = base::Sys.info())
[10:34:17.609]                   }
[10:34:17.609]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.609]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:17.609]                     cond$call), session = sessionInformation(), 
[10:34:17.609]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:17.609]                   signalCondition(cond)
[10:34:17.609]                 }
[10:34:17.609]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:17.609]                 "immediateCondition"))) {
[10:34:17.609]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:17.609]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.609]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:17.609]                   if (TRUE && !signal) {
[10:34:17.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.609]                     {
[10:34:17.609]                       inherits <- base::inherits
[10:34:17.609]                       invokeRestart <- base::invokeRestart
[10:34:17.609]                       is.null <- base::is.null
[10:34:17.609]                       muffled <- FALSE
[10:34:17.609]                       if (inherits(cond, "message")) {
[10:34:17.609]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.609]                         if (muffled) 
[10:34:17.609]                           invokeRestart("muffleMessage")
[10:34:17.609]                       }
[10:34:17.609]                       else if (inherits(cond, "warning")) {
[10:34:17.609]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.609]                         if (muffled) 
[10:34:17.609]                           invokeRestart("muffleWarning")
[10:34:17.609]                       }
[10:34:17.609]                       else if (inherits(cond, "condition")) {
[10:34:17.609]                         if (!is.null(pattern)) {
[10:34:17.609]                           computeRestarts <- base::computeRestarts
[10:34:17.609]                           grepl <- base::grepl
[10:34:17.609]                           restarts <- computeRestarts(cond)
[10:34:17.609]                           for (restart in restarts) {
[10:34:17.609]                             name <- restart$name
[10:34:17.609]                             if (is.null(name)) 
[10:34:17.609]                               next
[10:34:17.609]                             if (!grepl(pattern, name)) 
[10:34:17.609]                               next
[10:34:17.609]                             invokeRestart(restart)
[10:34:17.609]                             muffled <- TRUE
[10:34:17.609]                             break
[10:34:17.609]                           }
[10:34:17.609]                         }
[10:34:17.609]                       }
[10:34:17.609]                       invisible(muffled)
[10:34:17.609]                     }
[10:34:17.609]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.609]                   }
[10:34:17.609]                 }
[10:34:17.609]                 else {
[10:34:17.609]                   if (TRUE) {
[10:34:17.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.609]                     {
[10:34:17.609]                       inherits <- base::inherits
[10:34:17.609]                       invokeRestart <- base::invokeRestart
[10:34:17.609]                       is.null <- base::is.null
[10:34:17.609]                       muffled <- FALSE
[10:34:17.609]                       if (inherits(cond, "message")) {
[10:34:17.609]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.609]                         if (muffled) 
[10:34:17.609]                           invokeRestart("muffleMessage")
[10:34:17.609]                       }
[10:34:17.609]                       else if (inherits(cond, "warning")) {
[10:34:17.609]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.609]                         if (muffled) 
[10:34:17.609]                           invokeRestart("muffleWarning")
[10:34:17.609]                       }
[10:34:17.609]                       else if (inherits(cond, "condition")) {
[10:34:17.609]                         if (!is.null(pattern)) {
[10:34:17.609]                           computeRestarts <- base::computeRestarts
[10:34:17.609]                           grepl <- base::grepl
[10:34:17.609]                           restarts <- computeRestarts(cond)
[10:34:17.609]                           for (restart in restarts) {
[10:34:17.609]                             name <- restart$name
[10:34:17.609]                             if (is.null(name)) 
[10:34:17.609]                               next
[10:34:17.609]                             if (!grepl(pattern, name)) 
[10:34:17.609]                               next
[10:34:17.609]                             invokeRestart(restart)
[10:34:17.609]                             muffled <- TRUE
[10:34:17.609]                             break
[10:34:17.609]                           }
[10:34:17.609]                         }
[10:34:17.609]                       }
[10:34:17.609]                       invisible(muffled)
[10:34:17.609]                     }
[10:34:17.609]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.609]                   }
[10:34:17.609]                 }
[10:34:17.609]             }
[10:34:17.609]         }))
[10:34:17.609]     }, error = function(ex) {
[10:34:17.609]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:17.609]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.609]                 ...future.rng), started = ...future.startTime, 
[10:34:17.609]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:17.609]             version = "1.8"), class = "FutureResult")
[10:34:17.609]     }, finally = {
[10:34:17.609]         if (!identical(...future.workdir, getwd())) 
[10:34:17.609]             setwd(...future.workdir)
[10:34:17.609]         {
[10:34:17.609]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:17.609]                 ...future.oldOptions$nwarnings <- NULL
[10:34:17.609]             }
[10:34:17.609]             base::options(...future.oldOptions)
[10:34:17.609]             if (.Platform$OS.type == "windows") {
[10:34:17.609]                 old_names <- names(...future.oldEnvVars)
[10:34:17.609]                 envs <- base::Sys.getenv()
[10:34:17.609]                 names <- names(envs)
[10:34:17.609]                 common <- intersect(names, old_names)
[10:34:17.609]                 added <- setdiff(names, old_names)
[10:34:17.609]                 removed <- setdiff(old_names, names)
[10:34:17.609]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:17.609]                   envs[common]]
[10:34:17.609]                 NAMES <- toupper(changed)
[10:34:17.609]                 args <- list()
[10:34:17.609]                 for (kk in seq_along(NAMES)) {
[10:34:17.609]                   name <- changed[[kk]]
[10:34:17.609]                   NAME <- NAMES[[kk]]
[10:34:17.609]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.609]                     next
[10:34:17.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.609]                 }
[10:34:17.609]                 NAMES <- toupper(added)
[10:34:17.609]                 for (kk in seq_along(NAMES)) {
[10:34:17.609]                   name <- added[[kk]]
[10:34:17.609]                   NAME <- NAMES[[kk]]
[10:34:17.609]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.609]                     next
[10:34:17.609]                   args[[name]] <- ""
[10:34:17.609]                 }
[10:34:17.609]                 NAMES <- toupper(removed)
[10:34:17.609]                 for (kk in seq_along(NAMES)) {
[10:34:17.609]                   name <- removed[[kk]]
[10:34:17.609]                   NAME <- NAMES[[kk]]
[10:34:17.609]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.609]                     next
[10:34:17.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.609]                 }
[10:34:17.609]                 if (length(args) > 0) 
[10:34:17.609]                   base::do.call(base::Sys.setenv, args = args)
[10:34:17.609]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:17.609]             }
[10:34:17.609]             else {
[10:34:17.609]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:17.609]             }
[10:34:17.609]             {
[10:34:17.609]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:17.609]                   0L) {
[10:34:17.609]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:17.609]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:17.609]                   base::options(opts)
[10:34:17.609]                 }
[10:34:17.609]                 {
[10:34:17.609]                   {
[10:34:17.609]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:17.609]                     NULL
[10:34:17.609]                   }
[10:34:17.609]                   options(future.plan = NULL)
[10:34:17.609]                   if (is.na(NA_character_)) 
[10:34:17.609]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.609]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:17.609]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:17.609]                     .init = FALSE)
[10:34:17.609]                 }
[10:34:17.609]             }
[10:34:17.609]         }
[10:34:17.609]     })
[10:34:17.609]     if (TRUE) {
[10:34:17.609]         base::sink(type = "output", split = FALSE)
[10:34:17.609]         if (TRUE) {
[10:34:17.609]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:17.609]         }
[10:34:17.609]         else {
[10:34:17.609]             ...future.result["stdout"] <- base::list(NULL)
[10:34:17.609]         }
[10:34:17.609]         base::close(...future.stdout)
[10:34:17.609]         ...future.stdout <- NULL
[10:34:17.609]     }
[10:34:17.609]     ...future.result$conditions <- ...future.conditions
[10:34:17.609]     ...future.result$finished <- base::Sys.time()
[10:34:17.609]     ...future.result
[10:34:17.609] }
[10:34:17.611] MultisessionFuture started
[10:34:17.611] - Launch lazy future ... done
[10:34:17.612] run() for ‘MultisessionFuture’ ... done
[10:34:17.612] getGlobalsAndPackages() ...
[10:34:17.612] Searching for globals...
[10:34:17.613] - globals found: [1] ‘{’
[10:34:17.613] Searching for globals ... DONE
[10:34:17.613] Resolving globals: FALSE
[10:34:17.613] 
[10:34:17.613] 
[10:34:17.613] getGlobalsAndPackages() ... DONE
[10:34:17.613] run() for ‘Future’ ...
[10:34:17.614] - state: ‘created’
[10:34:17.614] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:34:17.627] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:34:17.627] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:34:17.627]   - Field: ‘node’
[10:34:17.627]   - Field: ‘label’
[10:34:17.627]   - Field: ‘local’
[10:34:17.627]   - Field: ‘owner’
[10:34:17.628]   - Field: ‘envir’
[10:34:17.628]   - Field: ‘workers’
[10:34:17.628]   - Field: ‘packages’
[10:34:17.628]   - Field: ‘gc’
[10:34:17.628]   - Field: ‘conditions’
[10:34:17.628]   - Field: ‘persistent’
[10:34:17.628]   - Field: ‘expr’
[10:34:17.628]   - Field: ‘uuid’
[10:34:17.628]   - Field: ‘seed’
[10:34:17.628]   - Field: ‘version’
[10:34:17.628]   - Field: ‘result’
[10:34:17.629]   - Field: ‘asynchronous’
[10:34:17.629]   - Field: ‘calls’
[10:34:17.629]   - Field: ‘globals’
[10:34:17.629]   - Field: ‘stdout’
[10:34:17.629]   - Field: ‘earlySignal’
[10:34:17.629]   - Field: ‘lazy’
[10:34:17.629]   - Field: ‘state’
[10:34:17.629] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:34:17.629] - Launch lazy future ...
[10:34:17.630] Packages needed by the future expression (n = 0): <none>
[10:34:17.630] Packages needed by future strategies (n = 0): <none>
[10:34:17.630] {
[10:34:17.630]     {
[10:34:17.630]         {
[10:34:17.630]             ...future.startTime <- base::Sys.time()
[10:34:17.630]             {
[10:34:17.630]                 {
[10:34:17.630]                   {
[10:34:17.630]                     {
[10:34:17.630]                       base::local({
[10:34:17.630]                         has_future <- base::requireNamespace("future", 
[10:34:17.630]                           quietly = TRUE)
[10:34:17.630]                         if (has_future) {
[10:34:17.630]                           ns <- base::getNamespace("future")
[10:34:17.630]                           version <- ns[[".package"]][["version"]]
[10:34:17.630]                           if (is.null(version)) 
[10:34:17.630]                             version <- utils::packageVersion("future")
[10:34:17.630]                         }
[10:34:17.630]                         else {
[10:34:17.630]                           version <- NULL
[10:34:17.630]                         }
[10:34:17.630]                         if (!has_future || version < "1.8.0") {
[10:34:17.630]                           info <- base::c(r_version = base::gsub("R version ", 
[10:34:17.630]                             "", base::R.version$version.string), 
[10:34:17.630]                             platform = base::sprintf("%s (%s-bit)", 
[10:34:17.630]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:34:17.630]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:34:17.630]                               "release", "version")], collapse = " "), 
[10:34:17.630]                             hostname = base::Sys.info()[["nodename"]])
[10:34:17.630]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:34:17.630]                             info)
[10:34:17.630]                           info <- base::paste(info, collapse = "; ")
[10:34:17.630]                           if (!has_future) {
[10:34:17.630]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:34:17.630]                               info)
[10:34:17.630]                           }
[10:34:17.630]                           else {
[10:34:17.630]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:34:17.630]                               info, version)
[10:34:17.630]                           }
[10:34:17.630]                           base::stop(msg)
[10:34:17.630]                         }
[10:34:17.630]                       })
[10:34:17.630]                     }
[10:34:17.630]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:34:17.630]                     base::options(mc.cores = 1L)
[10:34:17.630]                   }
[10:34:17.630]                   ...future.strategy.old <- future::plan("list")
[10:34:17.630]                   options(future.plan = NULL)
[10:34:17.630]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.630]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:34:17.630]                 }
[10:34:17.630]                 ...future.workdir <- getwd()
[10:34:17.630]             }
[10:34:17.630]             ...future.oldOptions <- base::as.list(base::.Options)
[10:34:17.630]             ...future.oldEnvVars <- base::Sys.getenv()
[10:34:17.630]         }
[10:34:17.630]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:34:17.630]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:34:17.630]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:34:17.630]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:34:17.630]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:34:17.630]             future.stdout.windows.reencode = NULL, width = 80L)
[10:34:17.630]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:34:17.630]             base::names(...future.oldOptions))
[10:34:17.630]     }
[10:34:17.630]     if (FALSE) {
[10:34:17.630]     }
[10:34:17.630]     else {
[10:34:17.630]         if (TRUE) {
[10:34:17.630]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:34:17.630]                 open = "w")
[10:34:17.630]         }
[10:34:17.630]         else {
[10:34:17.630]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:34:17.630]                 windows = "NUL", "/dev/null"), open = "w")
[10:34:17.630]         }
[10:34:17.630]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:34:17.630]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:34:17.630]             base::sink(type = "output", split = FALSE)
[10:34:17.630]             base::close(...future.stdout)
[10:34:17.630]         }, add = TRUE)
[10:34:17.630]     }
[10:34:17.630]     ...future.frame <- base::sys.nframe()
[10:34:17.630]     ...future.conditions <- base::list()
[10:34:17.630]     ...future.rng <- base::globalenv()$.Random.seed
[10:34:17.630]     if (FALSE) {
[10:34:17.630]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:34:17.630]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:34:17.630]     }
[10:34:17.630]     ...future.result <- base::tryCatch({
[10:34:17.630]         base::withCallingHandlers({
[10:34:17.630]             ...future.value <- base::withVisible(base::local({
[10:34:17.630]                 ...future.makeSendCondition <- base::local({
[10:34:17.630]                   sendCondition <- NULL
[10:34:17.630]                   function(frame = 1L) {
[10:34:17.630]                     if (is.function(sendCondition)) 
[10:34:17.630]                       return(sendCondition)
[10:34:17.630]                     ns <- getNamespace("parallel")
[10:34:17.630]                     if (exists("sendData", mode = "function", 
[10:34:17.630]                       envir = ns)) {
[10:34:17.630]                       parallel_sendData <- get("sendData", mode = "function", 
[10:34:17.630]                         envir = ns)
[10:34:17.630]                       envir <- sys.frame(frame)
[10:34:17.630]                       master <- NULL
[10:34:17.630]                       while (!identical(envir, .GlobalEnv) && 
[10:34:17.630]                         !identical(envir, emptyenv())) {
[10:34:17.630]                         if (exists("master", mode = "list", envir = envir, 
[10:34:17.630]                           inherits = FALSE)) {
[10:34:17.630]                           master <- get("master", mode = "list", 
[10:34:17.630]                             envir = envir, inherits = FALSE)
[10:34:17.630]                           if (inherits(master, c("SOCKnode", 
[10:34:17.630]                             "SOCK0node"))) {
[10:34:17.630]                             sendCondition <<- function(cond) {
[10:34:17.630]                               data <- list(type = "VALUE", value = cond, 
[10:34:17.630]                                 success = TRUE)
[10:34:17.630]                               parallel_sendData(master, data)
[10:34:17.630]                             }
[10:34:17.630]                             return(sendCondition)
[10:34:17.630]                           }
[10:34:17.630]                         }
[10:34:17.630]                         frame <- frame + 1L
[10:34:17.630]                         envir <- sys.frame(frame)
[10:34:17.630]                       }
[10:34:17.630]                     }
[10:34:17.630]                     sendCondition <<- function(cond) NULL
[10:34:17.630]                   }
[10:34:17.630]                 })
[10:34:17.630]                 withCallingHandlers({
[10:34:17.630]                   {
[10:34:17.630]                     3
[10:34:17.630]                   }
[10:34:17.630]                 }, immediateCondition = function(cond) {
[10:34:17.630]                   sendCondition <- ...future.makeSendCondition()
[10:34:17.630]                   sendCondition(cond)
[10:34:17.630]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.630]                   {
[10:34:17.630]                     inherits <- base::inherits
[10:34:17.630]                     invokeRestart <- base::invokeRestart
[10:34:17.630]                     is.null <- base::is.null
[10:34:17.630]                     muffled <- FALSE
[10:34:17.630]                     if (inherits(cond, "message")) {
[10:34:17.630]                       muffled <- grepl(pattern, "muffleMessage")
[10:34:17.630]                       if (muffled) 
[10:34:17.630]                         invokeRestart("muffleMessage")
[10:34:17.630]                     }
[10:34:17.630]                     else if (inherits(cond, "warning")) {
[10:34:17.630]                       muffled <- grepl(pattern, "muffleWarning")
[10:34:17.630]                       if (muffled) 
[10:34:17.630]                         invokeRestart("muffleWarning")
[10:34:17.630]                     }
[10:34:17.630]                     else if (inherits(cond, "condition")) {
[10:34:17.630]                       if (!is.null(pattern)) {
[10:34:17.630]                         computeRestarts <- base::computeRestarts
[10:34:17.630]                         grepl <- base::grepl
[10:34:17.630]                         restarts <- computeRestarts(cond)
[10:34:17.630]                         for (restart in restarts) {
[10:34:17.630]                           name <- restart$name
[10:34:17.630]                           if (is.null(name)) 
[10:34:17.630]                             next
[10:34:17.630]                           if (!grepl(pattern, name)) 
[10:34:17.630]                             next
[10:34:17.630]                           invokeRestart(restart)
[10:34:17.630]                           muffled <- TRUE
[10:34:17.630]                           break
[10:34:17.630]                         }
[10:34:17.630]                       }
[10:34:17.630]                     }
[10:34:17.630]                     invisible(muffled)
[10:34:17.630]                   }
[10:34:17.630]                   muffleCondition(cond)
[10:34:17.630]                 })
[10:34:17.630]             }))
[10:34:17.630]             future::FutureResult(value = ...future.value$value, 
[10:34:17.630]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.630]                   ...future.rng), globalenv = if (FALSE) 
[10:34:17.630]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:34:17.630]                     ...future.globalenv.names))
[10:34:17.630]                 else NULL, started = ...future.startTime, version = "1.8")
[10:34:17.630]         }, condition = base::local({
[10:34:17.630]             c <- base::c
[10:34:17.630]             inherits <- base::inherits
[10:34:17.630]             invokeRestart <- base::invokeRestart
[10:34:17.630]             length <- base::length
[10:34:17.630]             list <- base::list
[10:34:17.630]             seq.int <- base::seq.int
[10:34:17.630]             signalCondition <- base::signalCondition
[10:34:17.630]             sys.calls <- base::sys.calls
[10:34:17.630]             `[[` <- base::`[[`
[10:34:17.630]             `+` <- base::`+`
[10:34:17.630]             `<<-` <- base::`<<-`
[10:34:17.630]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:34:17.630]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:34:17.630]                   3L)]
[10:34:17.630]             }
[10:34:17.630]             function(cond) {
[10:34:17.630]                 is_error <- inherits(cond, "error")
[10:34:17.630]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:34:17.630]                   NULL)
[10:34:17.630]                 if (is_error) {
[10:34:17.630]                   sessionInformation <- function() {
[10:34:17.630]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:34:17.630]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:34:17.630]                       search = base::search(), system = base::Sys.info())
[10:34:17.630]                   }
[10:34:17.630]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.630]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:34:17.630]                     cond$call), session = sessionInformation(), 
[10:34:17.630]                     timestamp = base::Sys.time(), signaled = 0L)
[10:34:17.630]                   signalCondition(cond)
[10:34:17.630]                 }
[10:34:17.630]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:34:17.630]                 "immediateCondition"))) {
[10:34:17.630]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:34:17.630]                   ...future.conditions[[length(...future.conditions) + 
[10:34:17.630]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:34:17.630]                   if (TRUE && !signal) {
[10:34:17.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.630]                     {
[10:34:17.630]                       inherits <- base::inherits
[10:34:17.630]                       invokeRestart <- base::invokeRestart
[10:34:17.630]                       is.null <- base::is.null
[10:34:17.630]                       muffled <- FALSE
[10:34:17.630]                       if (inherits(cond, "message")) {
[10:34:17.630]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.630]                         if (muffled) 
[10:34:17.630]                           invokeRestart("muffleMessage")
[10:34:17.630]                       }
[10:34:17.630]                       else if (inherits(cond, "warning")) {
[10:34:17.630]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.630]                         if (muffled) 
[10:34:17.630]                           invokeRestart("muffleWarning")
[10:34:17.630]                       }
[10:34:17.630]                       else if (inherits(cond, "condition")) {
[10:34:17.630]                         if (!is.null(pattern)) {
[10:34:17.630]                           computeRestarts <- base::computeRestarts
[10:34:17.630]                           grepl <- base::grepl
[10:34:17.630]                           restarts <- computeRestarts(cond)
[10:34:17.630]                           for (restart in restarts) {
[10:34:17.630]                             name <- restart$name
[10:34:17.630]                             if (is.null(name)) 
[10:34:17.630]                               next
[10:34:17.630]                             if (!grepl(pattern, name)) 
[10:34:17.630]                               next
[10:34:17.630]                             invokeRestart(restart)
[10:34:17.630]                             muffled <- TRUE
[10:34:17.630]                             break
[10:34:17.630]                           }
[10:34:17.630]                         }
[10:34:17.630]                       }
[10:34:17.630]                       invisible(muffled)
[10:34:17.630]                     }
[10:34:17.630]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.630]                   }
[10:34:17.630]                 }
[10:34:17.630]                 else {
[10:34:17.630]                   if (TRUE) {
[10:34:17.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:34:17.630]                     {
[10:34:17.630]                       inherits <- base::inherits
[10:34:17.630]                       invokeRestart <- base::invokeRestart
[10:34:17.630]                       is.null <- base::is.null
[10:34:17.630]                       muffled <- FALSE
[10:34:17.630]                       if (inherits(cond, "message")) {
[10:34:17.630]                         muffled <- grepl(pattern, "muffleMessage")
[10:34:17.630]                         if (muffled) 
[10:34:17.630]                           invokeRestart("muffleMessage")
[10:34:17.630]                       }
[10:34:17.630]                       else if (inherits(cond, "warning")) {
[10:34:17.630]                         muffled <- grepl(pattern, "muffleWarning")
[10:34:17.630]                         if (muffled) 
[10:34:17.630]                           invokeRestart("muffleWarning")
[10:34:17.630]                       }
[10:34:17.630]                       else if (inherits(cond, "condition")) {
[10:34:17.630]                         if (!is.null(pattern)) {
[10:34:17.630]                           computeRestarts <- base::computeRestarts
[10:34:17.630]                           grepl <- base::grepl
[10:34:17.630]                           restarts <- computeRestarts(cond)
[10:34:17.630]                           for (restart in restarts) {
[10:34:17.630]                             name <- restart$name
[10:34:17.630]                             if (is.null(name)) 
[10:34:17.630]                               next
[10:34:17.630]                             if (!grepl(pattern, name)) 
[10:34:17.630]                               next
[10:34:17.630]                             invokeRestart(restart)
[10:34:17.630]                             muffled <- TRUE
[10:34:17.630]                             break
[10:34:17.630]                           }
[10:34:17.630]                         }
[10:34:17.630]                       }
[10:34:17.630]                       invisible(muffled)
[10:34:17.630]                     }
[10:34:17.630]                     muffleCondition(cond, pattern = "^muffle")
[10:34:17.630]                   }
[10:34:17.630]                 }
[10:34:17.630]             }
[10:34:17.630]         }))
[10:34:17.630]     }, error = function(ex) {
[10:34:17.630]         base::structure(base::list(value = NULL, visible = NULL, 
[10:34:17.630]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:34:17.630]                 ...future.rng), started = ...future.startTime, 
[10:34:17.630]             finished = Sys.time(), session_uuid = NA_character_, 
[10:34:17.630]             version = "1.8"), class = "FutureResult")
[10:34:17.630]     }, finally = {
[10:34:17.630]         if (!identical(...future.workdir, getwd())) 
[10:34:17.630]             setwd(...future.workdir)
[10:34:17.630]         {
[10:34:17.630]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:34:17.630]                 ...future.oldOptions$nwarnings <- NULL
[10:34:17.630]             }
[10:34:17.630]             base::options(...future.oldOptions)
[10:34:17.630]             if (.Platform$OS.type == "windows") {
[10:34:17.630]                 old_names <- names(...future.oldEnvVars)
[10:34:17.630]                 envs <- base::Sys.getenv()
[10:34:17.630]                 names <- names(envs)
[10:34:17.630]                 common <- intersect(names, old_names)
[10:34:17.630]                 added <- setdiff(names, old_names)
[10:34:17.630]                 removed <- setdiff(old_names, names)
[10:34:17.630]                 changed <- common[...future.oldEnvVars[common] != 
[10:34:17.630]                   envs[common]]
[10:34:17.630]                 NAMES <- toupper(changed)
[10:34:17.630]                 args <- list()
[10:34:17.630]                 for (kk in seq_along(NAMES)) {
[10:34:17.630]                   name <- changed[[kk]]
[10:34:17.630]                   NAME <- NAMES[[kk]]
[10:34:17.630]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.630]                     next
[10:34:17.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.630]                 }
[10:34:17.630]                 NAMES <- toupper(added)
[10:34:17.630]                 for (kk in seq_along(NAMES)) {
[10:34:17.630]                   name <- added[[kk]]
[10:34:17.630]                   NAME <- NAMES[[kk]]
[10:34:17.630]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.630]                     next
[10:34:17.630]                   args[[name]] <- ""
[10:34:17.630]                 }
[10:34:17.630]                 NAMES <- toupper(removed)
[10:34:17.630]                 for (kk in seq_along(NAMES)) {
[10:34:17.630]                   name <- removed[[kk]]
[10:34:17.630]                   NAME <- NAMES[[kk]]
[10:34:17.630]                   if (name != NAME && is.element(NAME, old_names)) 
[10:34:17.630]                     next
[10:34:17.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:34:17.630]                 }
[10:34:17.630]                 if (length(args) > 0) 
[10:34:17.630]                   base::do.call(base::Sys.setenv, args = args)
[10:34:17.630]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:34:17.630]             }
[10:34:17.630]             else {
[10:34:17.630]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:34:17.630]             }
[10:34:17.630]             {
[10:34:17.630]                 if (base::length(...future.futureOptionsAdded) > 
[10:34:17.630]                   0L) {
[10:34:17.630]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:34:17.630]                   base::names(opts) <- ...future.futureOptionsAdded
[10:34:17.630]                   base::options(opts)
[10:34:17.630]                 }
[10:34:17.630]                 {
[10:34:17.630]                   {
[10:34:17.630]                     base::options(mc.cores = ...future.mc.cores.old)
[10:34:17.630]                     NULL
[10:34:17.630]                   }
[10:34:17.630]                   options(future.plan = NULL)
[10:34:17.630]                   if (is.na(NA_character_)) 
[10:34:17.630]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:34:17.630]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:34:17.630]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:34:17.630]                     .init = FALSE)
[10:34:17.630]                 }
[10:34:17.630]             }
[10:34:17.630]         }
[10:34:17.630]     })
[10:34:17.630]     if (TRUE) {
[10:34:17.630]         base::sink(type = "output", split = FALSE)
[10:34:17.630]         if (TRUE) {
[10:34:17.630]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:34:17.630]         }
[10:34:17.630]         else {
[10:34:17.630]             ...future.result["stdout"] <- base::list(NULL)
[10:34:17.630]         }
[10:34:17.630]         base::close(...future.stdout)
[10:34:17.630]         ...future.stdout <- NULL
[10:34:17.630]     }
[10:34:17.630]     ...future.result$conditions <- ...future.conditions
[10:34:17.630]     ...future.result$finished <- base::Sys.time()
[10:34:17.630]     ...future.result
[10:34:17.630] }
[10:34:17.632] Poll #1 (0): usedNodes() = 2, workers = 2
[10:34:17.643] receiveMessageFromWorker() for ClusterFuture ...
[10:34:17.643] - Validating connection of MultisessionFuture
[10:34:17.643] - received message: FutureResult
[10:34:17.643] - Received FutureResult
[10:34:17.643] - Erased future from FutureRegistry
[10:34:17.643] result() for ClusterFuture ...
[10:34:17.644] - result already collected: FutureResult
[10:34:17.644] result() for ClusterFuture ... done
[10:34:17.644] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:17.644] result() for ClusterFuture ...
[10:34:17.644] - result already collected: FutureResult
[10:34:17.644] result() for ClusterFuture ... done
[10:34:17.644] result() for ClusterFuture ...
[10:34:17.644] - result already collected: FutureResult
[10:34:17.644] result() for ClusterFuture ... done
[10:34:17.645] MultisessionFuture started
[10:34:17.645] - Launch lazy future ... done
[10:34:17.645] run() for ‘MultisessionFuture’ ... done
[10:34:17.646] resolve() on list environment ...
[10:34:17.646]  recursive: 0
[10:34:17.647]  length: 4
[10:34:17.647]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:34:17.647] Future #1
[10:34:17.647]  length: 3 (resolved future 1)
[10:34:17.658] receiveMessageFromWorker() for ClusterFuture ...
[10:34:17.658] - Validating connection of MultisessionFuture
[10:34:17.658] - received message: FutureResult
[10:34:17.659] - Received FutureResult
[10:34:17.659] - Erased future from FutureRegistry
[10:34:17.659] result() for ClusterFuture ...
[10:34:17.659] - result already collected: FutureResult
[10:34:17.659] result() for ClusterFuture ... done
[10:34:17.659] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:17.659] Future #3
[10:34:17.659]  length: 2 (resolved future 3)
[10:34:17.659]  length: 1 (resolved future 4)
[10:34:18.123] receiveMessageFromWorker() for ClusterFuture ...
[10:34:18.123] - Validating connection of MultisessionFuture
[10:34:18.123] - received message: FutureResult
[10:34:18.123] - Received FutureResult
[10:34:18.124] - Erased future from FutureRegistry
[10:34:18.124] result() for ClusterFuture ...
[10:34:18.124] - result already collected: FutureResult
[10:34:18.124] result() for ClusterFuture ... done
[10:34:18.124] receiveMessageFromWorker() for ClusterFuture ... done
[10:34:18.124] Future #2
[10:34:18.124]  length: 0 (resolved future 2)
[10:34:18.124] resolve() on list environment ... DONE
[10:34:18.125] resolve() on list environment ...
[10:34:18.125]  recursive: 0
[10:34:18.128]  length: 4
[10:34:18.128]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:34:18.129] Future #1
[10:34:18.129]  length: 3 (resolved future 1)
[10:34:18.129] Future #2
[10:34:18.129]  length: 2 (resolved future 2)
[10:34:18.129] Future #3
[10:34:18.129]  length: 1 (resolved future 3)
[10:34:18.129]  length: 0 (resolved future 4)
[10:34:18.130] resolve() on list environment ... DONE
[10:34:18.130] resolve() on list environment ...
[10:34:18.130]  recursive: 0
[10:34:18.131]  length: 4
[10:34:18.131]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:34:18.131] Future #1
[10:34:18.131]  length: 3 (resolved future 1)
[10:34:18.131] Future #2
[10:34:18.131]  length: 2 (resolved future 2)
[10:34:18.132] Future #3
[10:34:18.132]  length: 1 (resolved future 3)
[10:34:18.132]  length: 0 (resolved future 4)
[10:34:18.132] resolve() on list environment ... DONE
[10:34:18.132] resolve() on list environment ...
[10:34:18.132]  recursive: 0
[10:34:18.133]  length: 4
[10:34:18.133]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:34:18.133] Future #1
[10:34:18.133]  length: 3 (resolved future 1)
[10:34:18.133] Future #2
[10:34:18.134]  length: 2 (resolved future 2)
[10:34:18.134] Future #3
[10:34:18.134]  length: 1 (resolved future 3)
[10:34:18.134]  length: 0 (resolved future 4)
[10:34:18.134] resolve() on list environment ... DONE
[10:34:18.134] resolve() on list environment ...
[10:34:18.134]  recursive: 0
[10:34:18.135]  length: 4
[10:34:18.135]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:34:18.135] Future #1
[10:34:18.135] result() for ClusterFuture ...
[10:34:18.135] - result already collected: FutureResult
[10:34:18.136] result() for ClusterFuture ... done
[10:34:18.136] result() for ClusterFuture ...
[10:34:18.136] - result already collected: FutureResult
[10:34:18.136] result() for ClusterFuture ... done
[10:34:18.136]  length: 3 (resolved future 1)
[10:34:18.136] Future #2
[10:34:18.136] result() for ClusterFuture ...
[10:34:18.136] - result already collected: FutureResult
[10:34:18.136] result() for ClusterFuture ... done
[10:34:18.136] result() for ClusterFuture ...
[10:34:18.136] - result already collected: FutureResult
[10:34:18.137] result() for ClusterFuture ... done
[10:34:18.137]  length: 2 (resolved future 2)
[10:34:18.137] Future #3
[10:34:18.137] result() for ClusterFuture ...
[10:34:18.137] - result already collected: FutureResult
[10:34:18.137] result() for ClusterFuture ... done
[10:34:18.137] result() for ClusterFuture ...
[10:34:18.137] - result already collected: FutureResult
[10:34:18.137] result() for ClusterFuture ... done
[10:34:18.137]  length: 1 (resolved future 3)
[10:34:18.138]  length: 0 (resolved future 4)
[10:34:18.138] resolve() on list environment ... DONE
[10:34:18.138] resolve() on list environment ...
[10:34:18.138]  recursive: 99
[10:34:18.139]  length: 4
[10:34:18.139]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:34:18.139] Future #1
[10:34:18.139] result() for ClusterFuture ...
[10:34:18.139] - result already collected: FutureResult
[10:34:18.139] result() for ClusterFuture ... done
[10:34:18.139] result() for ClusterFuture ...
[10:34:18.139] - result already collected: FutureResult
[10:34:18.139] result() for ClusterFuture ... done
[10:34:18.140] A MultisessionFuture was resolved
[10:34:18.140]  length: 3 (resolved future 1)
[10:34:18.140] Future #2
[10:34:18.140] result() for ClusterFuture ...
[10:34:18.140] - result already collected: FutureResult
[10:34:18.140] result() for ClusterFuture ... done
[10:34:18.140] result() for ClusterFuture ...
[10:34:18.140] - result already collected: FutureResult
[10:34:18.140] result() for ClusterFuture ... done
[10:34:18.140] A MultisessionFuture was resolved
[10:34:18.141]  length: 2 (resolved future 2)
[10:34:18.141] Future #3
[10:34:18.141] result() for ClusterFuture ...
[10:34:18.141] - result already collected: FutureResult
[10:34:18.141] result() for ClusterFuture ... done
[10:34:18.141] result() for ClusterFuture ...
[10:34:18.141] - result already collected: FutureResult
[10:34:18.141] result() for ClusterFuture ... done
[10:34:18.141] A MultisessionFuture was resolved
[10:34:18.141]  length: 1 (resolved future 3)
[10:34:18.141]  length: 0 (resolved future 4)
[10:34:18.142] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multisession') ...
> 
> 
> message("*** resolve() - globals with non-trustful length() ...")
*** resolve() - globals with non-trustful length() ...
> 
> length.CantTrustLength <- function(x) length(unclass(x)) + 1L
> 
> .length <- future:::.length
> 
> x <- structure(as.list(1:3), class = c("CantTrustLength", "list"))
> str(list(n = length(x), n_true = .length(x)))
List of 2
 $ n     : int 4
 $ n_true: int 3
> stopifnot(length(x) > .length(x))
> x <- resolve(x)
[10:34:18.145] resolve() on list ...
[10:34:18.145]  recursive: 0
[10:34:18.145]  length: 3
[10:34:18.145] 
[10:34:18.145]  length: 2 (resolved future 1)
[10:34:18.145]  length: 1 (resolved future 2)
[10:34:18.145]  length: 0 (resolved future 3)
[10:34:18.145] resolve() on list ... DONE
> 
> message("*** resolve() - globals with non-trustful length() ... DONE")
*** resolve() - globals with non-trustful length() ... DONE
> 
> 
> message("*** resolved() - default ...")
*** resolved() - default ...
> 
> res <- resolved(42L)
> stopifnot(isTRUE(res))
> 
> message("*** resolved() - default ... DONE")
*** resolved() - default ... DONE
> 
> 
> message("*** resolve() ... DONE")
*** resolve() ... DONE
> 
> source("incl/end.R")
[10:34:18.146] plan(): Setting new future strategy stack:
[10:34:18.147] List of future strategies:
[10:34:18.147] 1. FutureStrategy:
[10:34:18.147]    - args: function (..., envir = parent.frame())
[10:34:18.147]    - tweaked: FALSE
[10:34:18.147]    - call: future::plan(oplan)
[10:34:18.147] plan(): nbrOfWorkers() = 1
> 
