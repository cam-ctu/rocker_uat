
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[13:37:41.502] plan(): Setting new future strategy stack:
[13:37:41.503] List of future strategies:
[13:37:41.503] 1. sequential:
[13:37:41.503]    - args: function (..., envir = parent.frame())
[13:37:41.503]    - tweaked: FALSE
[13:37:41.503]    - call: future::plan("sequential")
[13:37:41.519] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> strategies <- supportedStrategies()
> 
> message("*** resolve() ...")
*** resolve() ...
> 
> message("*** resolve() for default ...")
*** resolve() for default ...
> 
> x <- 1
> y <- resolve(x)
> stopifnot(identical(y, x))
> 
> message("*** resolve() for default ... DONE")
*** resolve() for default ... DONE
> 
> 
> for (strategy in strategies) {
+   message(sprintf("- plan('%s') ...", strategy))
+   plan(strategy)
+ 
+   if (strategy == "multisession" && availableCores() >= 2) {
+     message("*** resolve() for Future objects ...")
+     
+     for (result in c(FALSE, TRUE)) {
+       for (recursive in list(FALSE, TRUE, -1, 0, 1, 2, Inf)) {
+         message(sprintf("- result = %s, recursive = %s ...", result, recursive))
+       
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         })
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         }, lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message("- w/ exception ...")
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")))
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")), lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message(sprintf("- result = %s, recursive = %s ... DONE", result, recursive))
+       } ## for (resolve ...)
+     } ## for (result ...)
+     
+     message("*** resolve() for Future objects ... DONE")
+   } ## if (strategy == "multisession" && availableCores() >= 2)
+   
+   message("*** resolve() for lists ...")
+ 
+   x <- list()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2, lazy = TRUE)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future({Sys.sleep(0.5); 2})
+   x[[4]] <- 4
+   dim(x) <- c(2, 2)
+   y <- resolve(x, idxs = 1)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[1]]))
+   y <- resolve(x, idxs = 2)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[2]]))
+   y <- resolve(x, idxs = 3)
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = seq_along(x))
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = names(x))
+   stopifnot(identical(y, x))
+ 
+   y <- resolve(x, idxs = matrix(c(1, 2), ncol = 2L), result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk })
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk }, lazy = TRUE)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+ 
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   x <- list(1, 2)
+   res <- tryCatch(x <- resolve(x, idxs = "a"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for lists ... DONE")
+ 
+ 
+   message("*** resolve() for environments ...")
+ 
+   x <- new.env()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- new.env()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+ 
+   x <- new.env()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x$b))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a <- future({ 1 })
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "c")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for environments ... DONE")
+ 
+ 
+   message("*** resolve() for list environments ...")
+ 
+   x <- listenv()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- 1
+   x$b <- 2
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   names <- names(x)
+   dim(x) <- c(1, 3)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$a, mustExist = FALSE)))
+   #stopifnot(is.na(futureOf(x$b, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a <- future({ 1 })
+   x$b %<-% { Sys.sleep(0.5); 2 }
+   x$c %<-% { 3 }
+   x$d <- 4
+   names <- names(x)
+   dim(x) <- c(2, 2)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(identical(futureOf(x$a, mustExist = FALSE), x$a))
+   stopifnot(resolved(x$a))
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   idxs <- matrix(c(1, 2), ncol = 2L)
+   y <- resolve(x, idxs = idxs)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$c, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = 4L)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x[[4L]], mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for list environments ... DONE")
+ 
+   message(sprintf("- plan('%s') ...", strategy))
+ } ## for (strategy ...)
- plan('sequential') ...
[13:37:41.717] plan(): Setting new future strategy stack:
[13:37:41.717] List of future strategies:
[13:37:41.717] 1. sequential:
[13:37:41.717]    - args: function (..., envir = parent.frame())
[13:37:41.717]    - tweaked: FALSE
[13:37:41.717]    - call: plan(strategy)
[13:37:41.731] plan(): nbrOfWorkers() = 1
*** resolve() for lists ...
[13:37:41.731] resolve() on list ...
[13:37:41.731]  recursive: 0
[13:37:41.732]  length: 2
[13:37:41.732]  elements: ‘a’, ‘b’
[13:37:41.732]  length: 1 (resolved future 1)
[13:37:41.732]  length: 0 (resolved future 2)
[13:37:41.732] resolve() on list ... DONE
[13:37:41.733] getGlobalsAndPackages() ...
[13:37:41.733] Searching for globals...
[13:37:41.736] 
[13:37:41.736] Searching for globals ... DONE
[13:37:41.736] - globals: [0] <none>
[13:37:41.736] getGlobalsAndPackages() ... DONE
[13:37:41.737] run() for ‘Future’ ...
[13:37:41.737] - state: ‘created’
[13:37:41.737] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:37:41.737] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:37:41.738] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:37:41.738]   - Field: ‘label’
[13:37:41.738]   - Field: ‘local’
[13:37:41.738]   - Field: ‘owner’
[13:37:41.738]   - Field: ‘envir’
[13:37:41.738]   - Field: ‘packages’
[13:37:41.738]   - Field: ‘gc’
[13:37:41.738]   - Field: ‘conditions’
[13:37:41.738]   - Field: ‘expr’
[13:37:41.738]   - Field: ‘uuid’
[13:37:41.739]   - Field: ‘seed’
[13:37:41.739]   - Field: ‘version’
[13:37:41.739]   - Field: ‘result’
[13:37:41.739]   - Field: ‘asynchronous’
[13:37:41.739]   - Field: ‘calls’
[13:37:41.739]   - Field: ‘globals’
[13:37:41.739]   - Field: ‘stdout’
[13:37:41.739]   - Field: ‘earlySignal’
[13:37:41.739]   - Field: ‘lazy’
[13:37:41.739]   - Field: ‘state’
[13:37:41.739] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:37:41.740] - Launch lazy future ...
[13:37:41.740] Packages needed by the future expression (n = 0): <none>
[13:37:41.741] Packages needed by future strategies (n = 0): <none>
[13:37:41.741] {
[13:37:41.741]     {
[13:37:41.741]         {
[13:37:41.741]             ...future.startTime <- base::Sys.time()
[13:37:41.741]             {
[13:37:41.741]                 {
[13:37:41.741]                   {
[13:37:41.741]                     base::local({
[13:37:41.741]                       has_future <- base::requireNamespace("future", 
[13:37:41.741]                         quietly = TRUE)
[13:37:41.741]                       if (has_future) {
[13:37:41.741]                         ns <- base::getNamespace("future")
[13:37:41.741]                         version <- ns[[".package"]][["version"]]
[13:37:41.741]                         if (is.null(version)) 
[13:37:41.741]                           version <- utils::packageVersion("future")
[13:37:41.741]                       }
[13:37:41.741]                       else {
[13:37:41.741]                         version <- NULL
[13:37:41.741]                       }
[13:37:41.741]                       if (!has_future || version < "1.8.0") {
[13:37:41.741]                         info <- base::c(r_version = base::gsub("R version ", 
[13:37:41.741]                           "", base::R.version$version.string), 
[13:37:41.741]                           platform = base::sprintf("%s (%s-bit)", 
[13:37:41.741]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:41.741]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:41.741]                             "release", "version")], collapse = " "), 
[13:37:41.741]                           hostname = base::Sys.info()[["nodename"]])
[13:37:41.741]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:37:41.741]                           info)
[13:37:41.741]                         info <- base::paste(info, collapse = "; ")
[13:37:41.741]                         if (!has_future) {
[13:37:41.741]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:41.741]                             info)
[13:37:41.741]                         }
[13:37:41.741]                         else {
[13:37:41.741]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:41.741]                             info, version)
[13:37:41.741]                         }
[13:37:41.741]                         base::stop(msg)
[13:37:41.741]                       }
[13:37:41.741]                     })
[13:37:41.741]                   }
[13:37:41.741]                   ...future.strategy.old <- future::plan("list")
[13:37:41.741]                   options(future.plan = NULL)
[13:37:41.741]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:41.741]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:41.741]                 }
[13:37:41.741]                 ...future.workdir <- getwd()
[13:37:41.741]             }
[13:37:41.741]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:41.741]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:41.741]         }
[13:37:41.741]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:41.741]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:41.741]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:41.741]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:41.741]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:41.741]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:41.741]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:41.741]             base::names(...future.oldOptions))
[13:37:41.741]     }
[13:37:41.741]     if (FALSE) {
[13:37:41.741]     }
[13:37:41.741]     else {
[13:37:41.741]         if (TRUE) {
[13:37:41.741]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:41.741]                 open = "w")
[13:37:41.741]         }
[13:37:41.741]         else {
[13:37:41.741]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:41.741]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:41.741]         }
[13:37:41.741]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:41.741]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:41.741]             base::sink(type = "output", split = FALSE)
[13:37:41.741]             base::close(...future.stdout)
[13:37:41.741]         }, add = TRUE)
[13:37:41.741]     }
[13:37:41.741]     ...future.frame <- base::sys.nframe()
[13:37:41.741]     ...future.conditions <- base::list()
[13:37:41.741]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:41.741]     if (FALSE) {
[13:37:41.741]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:41.741]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:41.741]     }
[13:37:41.741]     ...future.result <- base::tryCatch({
[13:37:41.741]         base::withCallingHandlers({
[13:37:41.741]             ...future.value <- base::withVisible(base::local(1))
[13:37:41.741]             future::FutureResult(value = ...future.value$value, 
[13:37:41.741]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:41.741]                   ...future.rng), globalenv = if (FALSE) 
[13:37:41.741]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:41.741]                     ...future.globalenv.names))
[13:37:41.741]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:41.741]         }, condition = base::local({
[13:37:41.741]             c <- base::c
[13:37:41.741]             inherits <- base::inherits
[13:37:41.741]             invokeRestart <- base::invokeRestart
[13:37:41.741]             length <- base::length
[13:37:41.741]             list <- base::list
[13:37:41.741]             seq.int <- base::seq.int
[13:37:41.741]             signalCondition <- base::signalCondition
[13:37:41.741]             sys.calls <- base::sys.calls
[13:37:41.741]             `[[` <- base::`[[`
[13:37:41.741]             `+` <- base::`+`
[13:37:41.741]             `<<-` <- base::`<<-`
[13:37:41.741]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:41.741]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:41.741]                   3L)]
[13:37:41.741]             }
[13:37:41.741]             function(cond) {
[13:37:41.741]                 is_error <- inherits(cond, "error")
[13:37:41.741]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:41.741]                   NULL)
[13:37:41.741]                 if (is_error) {
[13:37:41.741]                   sessionInformation <- function() {
[13:37:41.741]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:41.741]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:41.741]                       search = base::search(), system = base::Sys.info())
[13:37:41.741]                   }
[13:37:41.741]                   ...future.conditions[[length(...future.conditions) + 
[13:37:41.741]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:41.741]                     cond$call), session = sessionInformation(), 
[13:37:41.741]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:41.741]                   signalCondition(cond)
[13:37:41.741]                 }
[13:37:41.741]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:41.741]                 "immediateCondition"))) {
[13:37:41.741]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:41.741]                   ...future.conditions[[length(...future.conditions) + 
[13:37:41.741]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:41.741]                   if (TRUE && !signal) {
[13:37:41.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:41.741]                     {
[13:37:41.741]                       inherits <- base::inherits
[13:37:41.741]                       invokeRestart <- base::invokeRestart
[13:37:41.741]                       is.null <- base::is.null
[13:37:41.741]                       muffled <- FALSE
[13:37:41.741]                       if (inherits(cond, "message")) {
[13:37:41.741]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:41.741]                         if (muffled) 
[13:37:41.741]                           invokeRestart("muffleMessage")
[13:37:41.741]                       }
[13:37:41.741]                       else if (inherits(cond, "warning")) {
[13:37:41.741]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:41.741]                         if (muffled) 
[13:37:41.741]                           invokeRestart("muffleWarning")
[13:37:41.741]                       }
[13:37:41.741]                       else if (inherits(cond, "condition")) {
[13:37:41.741]                         if (!is.null(pattern)) {
[13:37:41.741]                           computeRestarts <- base::computeRestarts
[13:37:41.741]                           grepl <- base::grepl
[13:37:41.741]                           restarts <- computeRestarts(cond)
[13:37:41.741]                           for (restart in restarts) {
[13:37:41.741]                             name <- restart$name
[13:37:41.741]                             if (is.null(name)) 
[13:37:41.741]                               next
[13:37:41.741]                             if (!grepl(pattern, name)) 
[13:37:41.741]                               next
[13:37:41.741]                             invokeRestart(restart)
[13:37:41.741]                             muffled <- TRUE
[13:37:41.741]                             break
[13:37:41.741]                           }
[13:37:41.741]                         }
[13:37:41.741]                       }
[13:37:41.741]                       invisible(muffled)
[13:37:41.741]                     }
[13:37:41.741]                     muffleCondition(cond, pattern = "^muffle")
[13:37:41.741]                   }
[13:37:41.741]                 }
[13:37:41.741]                 else {
[13:37:41.741]                   if (TRUE) {
[13:37:41.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:41.741]                     {
[13:37:41.741]                       inherits <- base::inherits
[13:37:41.741]                       invokeRestart <- base::invokeRestart
[13:37:41.741]                       is.null <- base::is.null
[13:37:41.741]                       muffled <- FALSE
[13:37:41.741]                       if (inherits(cond, "message")) {
[13:37:41.741]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:41.741]                         if (muffled) 
[13:37:41.741]                           invokeRestart("muffleMessage")
[13:37:41.741]                       }
[13:37:41.741]                       else if (inherits(cond, "warning")) {
[13:37:41.741]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:41.741]                         if (muffled) 
[13:37:41.741]                           invokeRestart("muffleWarning")
[13:37:41.741]                       }
[13:37:41.741]                       else if (inherits(cond, "condition")) {
[13:37:41.741]                         if (!is.null(pattern)) {
[13:37:41.741]                           computeRestarts <- base::computeRestarts
[13:37:41.741]                           grepl <- base::grepl
[13:37:41.741]                           restarts <- computeRestarts(cond)
[13:37:41.741]                           for (restart in restarts) {
[13:37:41.741]                             name <- restart$name
[13:37:41.741]                             if (is.null(name)) 
[13:37:41.741]                               next
[13:37:41.741]                             if (!grepl(pattern, name)) 
[13:37:41.741]                               next
[13:37:41.741]                             invokeRestart(restart)
[13:37:41.741]                             muffled <- TRUE
[13:37:41.741]                             break
[13:37:41.741]                           }
[13:37:41.741]                         }
[13:37:41.741]                       }
[13:37:41.741]                       invisible(muffled)
[13:37:41.741]                     }
[13:37:41.741]                     muffleCondition(cond, pattern = "^muffle")
[13:37:41.741]                   }
[13:37:41.741]                 }
[13:37:41.741]             }
[13:37:41.741]         }))
[13:37:41.741]     }, error = function(ex) {
[13:37:41.741]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:41.741]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:41.741]                 ...future.rng), started = ...future.startTime, 
[13:37:41.741]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:41.741]             version = "1.8"), class = "FutureResult")
[13:37:41.741]     }, finally = {
[13:37:41.741]         if (!identical(...future.workdir, getwd())) 
[13:37:41.741]             setwd(...future.workdir)
[13:37:41.741]         {
[13:37:41.741]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:41.741]                 ...future.oldOptions$nwarnings <- NULL
[13:37:41.741]             }
[13:37:41.741]             base::options(...future.oldOptions)
[13:37:41.741]             if (.Platform$OS.type == "windows") {
[13:37:41.741]                 old_names <- names(...future.oldEnvVars)
[13:37:41.741]                 envs <- base::Sys.getenv()
[13:37:41.741]                 names <- names(envs)
[13:37:41.741]                 common <- intersect(names, old_names)
[13:37:41.741]                 added <- setdiff(names, old_names)
[13:37:41.741]                 removed <- setdiff(old_names, names)
[13:37:41.741]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:41.741]                   envs[common]]
[13:37:41.741]                 NAMES <- toupper(changed)
[13:37:41.741]                 args <- list()
[13:37:41.741]                 for (kk in seq_along(NAMES)) {
[13:37:41.741]                   name <- changed[[kk]]
[13:37:41.741]                   NAME <- NAMES[[kk]]
[13:37:41.741]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:41.741]                     next
[13:37:41.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:41.741]                 }
[13:37:41.741]                 NAMES <- toupper(added)
[13:37:41.741]                 for (kk in seq_along(NAMES)) {
[13:37:41.741]                   name <- added[[kk]]
[13:37:41.741]                   NAME <- NAMES[[kk]]
[13:37:41.741]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:41.741]                     next
[13:37:41.741]                   args[[name]] <- ""
[13:37:41.741]                 }
[13:37:41.741]                 NAMES <- toupper(removed)
[13:37:41.741]                 for (kk in seq_along(NAMES)) {
[13:37:41.741]                   name <- removed[[kk]]
[13:37:41.741]                   NAME <- NAMES[[kk]]
[13:37:41.741]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:41.741]                     next
[13:37:41.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:41.741]                 }
[13:37:41.741]                 if (length(args) > 0) 
[13:37:41.741]                   base::do.call(base::Sys.setenv, args = args)
[13:37:41.741]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:41.741]             }
[13:37:41.741]             else {
[13:37:41.741]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:41.741]             }
[13:37:41.741]             {
[13:37:41.741]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:41.741]                   0L) {
[13:37:41.741]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:41.741]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:41.741]                   base::options(opts)
[13:37:41.741]                 }
[13:37:41.741]                 {
[13:37:41.741]                   {
[13:37:41.741]                     NULL
[13:37:41.741]                     RNGkind("Mersenne-Twister")
[13:37:41.741]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:37:41.741]                       inherits = FALSE)
[13:37:41.741]                   }
[13:37:41.741]                   options(future.plan = NULL)
[13:37:41.741]                   if (is.na(NA_character_)) 
[13:37:41.741]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:41.741]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:41.741]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:41.741]                     .init = FALSE)
[13:37:41.741]                 }
[13:37:41.741]             }
[13:37:41.741]         }
[13:37:41.741]     })
[13:37:41.741]     if (TRUE) {
[13:37:41.741]         base::sink(type = "output", split = FALSE)
[13:37:41.741]         if (TRUE) {
[13:37:41.741]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:41.741]         }
[13:37:41.741]         else {
[13:37:41.741]             ...future.result["stdout"] <- base::list(NULL)
[13:37:41.741]         }
[13:37:41.741]         base::close(...future.stdout)
[13:37:41.741]         ...future.stdout <- NULL
[13:37:41.741]     }
[13:37:41.741]     ...future.result$conditions <- ...future.conditions
[13:37:41.741]     ...future.result$finished <- base::Sys.time()
[13:37:41.741]     ...future.result
[13:37:41.741] }
[13:37:41.744] plan(): Setting new future strategy stack:
[13:37:41.744] List of future strategies:
[13:37:41.744] 1. sequential:
[13:37:41.744]    - args: function (..., envir = parent.frame())
[13:37:41.744]    - tweaked: FALSE
[13:37:41.744]    - call: NULL
[13:37:41.744] plan(): nbrOfWorkers() = 1
[13:37:41.746] plan(): Setting new future strategy stack:
[13:37:41.746] List of future strategies:
[13:37:41.746] 1. sequential:
[13:37:41.746]    - args: function (..., envir = parent.frame())
[13:37:41.746]    - tweaked: FALSE
[13:37:41.746]    - call: plan(strategy)
[13:37:41.746] plan(): nbrOfWorkers() = 1
[13:37:41.746] SequentialFuture started (and completed)
[13:37:41.747] - Launch lazy future ... done
[13:37:41.747] run() for ‘SequentialFuture’ ... done
[13:37:41.747] getGlobalsAndPackages() ...
[13:37:41.747] Searching for globals...
[13:37:41.747] 
[13:37:41.748] Searching for globals ... DONE
[13:37:41.748] - globals: [0] <none>
[13:37:41.748] getGlobalsAndPackages() ... DONE
[13:37:41.748] run() for ‘Future’ ...
[13:37:41.748] - state: ‘created’
[13:37:41.748] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:37:41.749] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:37:41.749] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:37:41.749]   - Field: ‘label’
[13:37:41.749]   - Field: ‘local’
[13:37:41.749]   - Field: ‘owner’
[13:37:41.749]   - Field: ‘envir’
[13:37:41.749]   - Field: ‘packages’
[13:37:41.749]   - Field: ‘gc’
[13:37:41.749]   - Field: ‘conditions’
[13:37:41.749]   - Field: ‘expr’
[13:37:41.750]   - Field: ‘uuid’
[13:37:41.750]   - Field: ‘seed’
[13:37:41.750]   - Field: ‘version’
[13:37:41.750]   - Field: ‘result’
[13:37:41.750]   - Field: ‘asynchronous’
[13:37:41.750]   - Field: ‘calls’
[13:37:41.750]   - Field: ‘globals’
[13:37:41.750]   - Field: ‘stdout’
[13:37:41.750]   - Field: ‘earlySignal’
[13:37:41.750]   - Field: ‘lazy’
[13:37:41.750]   - Field: ‘state’
[13:37:41.751] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:37:41.751] - Launch lazy future ...
[13:37:41.751] Packages needed by the future expression (n = 0): <none>
[13:37:41.751] Packages needed by future strategies (n = 0): <none>
[13:37:41.751] {
[13:37:41.751]     {
[13:37:41.751]         {
[13:37:41.751]             ...future.startTime <- base::Sys.time()
[13:37:41.751]             {
[13:37:41.751]                 {
[13:37:41.751]                   {
[13:37:41.751]                     base::local({
[13:37:41.751]                       has_future <- base::requireNamespace("future", 
[13:37:41.751]                         quietly = TRUE)
[13:37:41.751]                       if (has_future) {
[13:37:41.751]                         ns <- base::getNamespace("future")
[13:37:41.751]                         version <- ns[[".package"]][["version"]]
[13:37:41.751]                         if (is.null(version)) 
[13:37:41.751]                           version <- utils::packageVersion("future")
[13:37:41.751]                       }
[13:37:41.751]                       else {
[13:37:41.751]                         version <- NULL
[13:37:41.751]                       }
[13:37:41.751]                       if (!has_future || version < "1.8.0") {
[13:37:41.751]                         info <- base::c(r_version = base::gsub("R version ", 
[13:37:41.751]                           "", base::R.version$version.string), 
[13:37:41.751]                           platform = base::sprintf("%s (%s-bit)", 
[13:37:41.751]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:41.751]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:41.751]                             "release", "version")], collapse = " "), 
[13:37:41.751]                           hostname = base::Sys.info()[["nodename"]])
[13:37:41.751]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:37:41.751]                           info)
[13:37:41.751]                         info <- base::paste(info, collapse = "; ")
[13:37:41.751]                         if (!has_future) {
[13:37:41.751]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:41.751]                             info)
[13:37:41.751]                         }
[13:37:41.751]                         else {
[13:37:41.751]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:41.751]                             info, version)
[13:37:41.751]                         }
[13:37:41.751]                         base::stop(msg)
[13:37:41.751]                       }
[13:37:41.751]                     })
[13:37:41.751]                   }
[13:37:41.751]                   ...future.strategy.old <- future::plan("list")
[13:37:41.751]                   options(future.plan = NULL)
[13:37:41.751]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:41.751]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:41.751]                 }
[13:37:41.751]                 ...future.workdir <- getwd()
[13:37:41.751]             }
[13:37:41.751]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:41.751]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:41.751]         }
[13:37:41.751]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:41.751]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:41.751]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:41.751]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:41.751]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:41.751]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:41.751]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:41.751]             base::names(...future.oldOptions))
[13:37:41.751]     }
[13:37:41.751]     if (FALSE) {
[13:37:41.751]     }
[13:37:41.751]     else {
[13:37:41.751]         if (TRUE) {
[13:37:41.751]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:41.751]                 open = "w")
[13:37:41.751]         }
[13:37:41.751]         else {
[13:37:41.751]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:41.751]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:41.751]         }
[13:37:41.751]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:41.751]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:41.751]             base::sink(type = "output", split = FALSE)
[13:37:41.751]             base::close(...future.stdout)
[13:37:41.751]         }, add = TRUE)
[13:37:41.751]     }
[13:37:41.751]     ...future.frame <- base::sys.nframe()
[13:37:41.751]     ...future.conditions <- base::list()
[13:37:41.751]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:41.751]     if (FALSE) {
[13:37:41.751]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:41.751]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:41.751]     }
[13:37:41.751]     ...future.result <- base::tryCatch({
[13:37:41.751]         base::withCallingHandlers({
[13:37:41.751]             ...future.value <- base::withVisible(base::local(2))
[13:37:41.751]             future::FutureResult(value = ...future.value$value, 
[13:37:41.751]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:41.751]                   ...future.rng), globalenv = if (FALSE) 
[13:37:41.751]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:41.751]                     ...future.globalenv.names))
[13:37:41.751]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:41.751]         }, condition = base::local({
[13:37:41.751]             c <- base::c
[13:37:41.751]             inherits <- base::inherits
[13:37:41.751]             invokeRestart <- base::invokeRestart
[13:37:41.751]             length <- base::length
[13:37:41.751]             list <- base::list
[13:37:41.751]             seq.int <- base::seq.int
[13:37:41.751]             signalCondition <- base::signalCondition
[13:37:41.751]             sys.calls <- base::sys.calls
[13:37:41.751]             `[[` <- base::`[[`
[13:37:41.751]             `+` <- base::`+`
[13:37:41.751]             `<<-` <- base::`<<-`
[13:37:41.751]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:41.751]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:41.751]                   3L)]
[13:37:41.751]             }
[13:37:41.751]             function(cond) {
[13:37:41.751]                 is_error <- inherits(cond, "error")
[13:37:41.751]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:41.751]                   NULL)
[13:37:41.751]                 if (is_error) {
[13:37:41.751]                   sessionInformation <- function() {
[13:37:41.751]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:41.751]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:41.751]                       search = base::search(), system = base::Sys.info())
[13:37:41.751]                   }
[13:37:41.751]                   ...future.conditions[[length(...future.conditions) + 
[13:37:41.751]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:41.751]                     cond$call), session = sessionInformation(), 
[13:37:41.751]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:41.751]                   signalCondition(cond)
[13:37:41.751]                 }
[13:37:41.751]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:41.751]                 "immediateCondition"))) {
[13:37:41.751]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:41.751]                   ...future.conditions[[length(...future.conditions) + 
[13:37:41.751]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:41.751]                   if (TRUE && !signal) {
[13:37:41.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:41.751]                     {
[13:37:41.751]                       inherits <- base::inherits
[13:37:41.751]                       invokeRestart <- base::invokeRestart
[13:37:41.751]                       is.null <- base::is.null
[13:37:41.751]                       muffled <- FALSE
[13:37:41.751]                       if (inherits(cond, "message")) {
[13:37:41.751]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:41.751]                         if (muffled) 
[13:37:41.751]                           invokeRestart("muffleMessage")
[13:37:41.751]                       }
[13:37:41.751]                       else if (inherits(cond, "warning")) {
[13:37:41.751]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:41.751]                         if (muffled) 
[13:37:41.751]                           invokeRestart("muffleWarning")
[13:37:41.751]                       }
[13:37:41.751]                       else if (inherits(cond, "condition")) {
[13:37:41.751]                         if (!is.null(pattern)) {
[13:37:41.751]                           computeRestarts <- base::computeRestarts
[13:37:41.751]                           grepl <- base::grepl
[13:37:41.751]                           restarts <- computeRestarts(cond)
[13:37:41.751]                           for (restart in restarts) {
[13:37:41.751]                             name <- restart$name
[13:37:41.751]                             if (is.null(name)) 
[13:37:41.751]                               next
[13:37:41.751]                             if (!grepl(pattern, name)) 
[13:37:41.751]                               next
[13:37:41.751]                             invokeRestart(restart)
[13:37:41.751]                             muffled <- TRUE
[13:37:41.751]                             break
[13:37:41.751]                           }
[13:37:41.751]                         }
[13:37:41.751]                       }
[13:37:41.751]                       invisible(muffled)
[13:37:41.751]                     }
[13:37:41.751]                     muffleCondition(cond, pattern = "^muffle")
[13:37:41.751]                   }
[13:37:41.751]                 }
[13:37:41.751]                 else {
[13:37:41.751]                   if (TRUE) {
[13:37:41.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:41.751]                     {
[13:37:41.751]                       inherits <- base::inherits
[13:37:41.751]                       invokeRestart <- base::invokeRestart
[13:37:41.751]                       is.null <- base::is.null
[13:37:41.751]                       muffled <- FALSE
[13:37:41.751]                       if (inherits(cond, "message")) {
[13:37:41.751]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:41.751]                         if (muffled) 
[13:37:41.751]                           invokeRestart("muffleMessage")
[13:37:41.751]                       }
[13:37:41.751]                       else if (inherits(cond, "warning")) {
[13:37:41.751]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:41.751]                         if (muffled) 
[13:37:41.751]                           invokeRestart("muffleWarning")
[13:37:41.751]                       }
[13:37:41.751]                       else if (inherits(cond, "condition")) {
[13:37:41.751]                         if (!is.null(pattern)) {
[13:37:41.751]                           computeRestarts <- base::computeRestarts
[13:37:41.751]                           grepl <- base::grepl
[13:37:41.751]                           restarts <- computeRestarts(cond)
[13:37:41.751]                           for (restart in restarts) {
[13:37:41.751]                             name <- restart$name
[13:37:41.751]                             if (is.null(name)) 
[13:37:41.751]                               next
[13:37:41.751]                             if (!grepl(pattern, name)) 
[13:37:41.751]                               next
[13:37:41.751]                             invokeRestart(restart)
[13:37:41.751]                             muffled <- TRUE
[13:37:41.751]                             break
[13:37:41.751]                           }
[13:37:41.751]                         }
[13:37:41.751]                       }
[13:37:41.751]                       invisible(muffled)
[13:37:41.751]                     }
[13:37:41.751]                     muffleCondition(cond, pattern = "^muffle")
[13:37:41.751]                   }
[13:37:41.751]                 }
[13:37:41.751]             }
[13:37:41.751]         }))
[13:37:41.751]     }, error = function(ex) {
[13:37:41.751]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:41.751]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:41.751]                 ...future.rng), started = ...future.startTime, 
[13:37:41.751]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:41.751]             version = "1.8"), class = "FutureResult")
[13:37:41.751]     }, finally = {
[13:37:41.751]         if (!identical(...future.workdir, getwd())) 
[13:37:41.751]             setwd(...future.workdir)
[13:37:41.751]         {
[13:37:41.751]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:41.751]                 ...future.oldOptions$nwarnings <- NULL
[13:37:41.751]             }
[13:37:41.751]             base::options(...future.oldOptions)
[13:37:41.751]             if (.Platform$OS.type == "windows") {
[13:37:41.751]                 old_names <- names(...future.oldEnvVars)
[13:37:41.751]                 envs <- base::Sys.getenv()
[13:37:41.751]                 names <- names(envs)
[13:37:41.751]                 common <- intersect(names, old_names)
[13:37:41.751]                 added <- setdiff(names, old_names)
[13:37:41.751]                 removed <- setdiff(old_names, names)
[13:37:41.751]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:41.751]                   envs[common]]
[13:37:41.751]                 NAMES <- toupper(changed)
[13:37:41.751]                 args <- list()
[13:37:41.751]                 for (kk in seq_along(NAMES)) {
[13:37:41.751]                   name <- changed[[kk]]
[13:37:41.751]                   NAME <- NAMES[[kk]]
[13:37:41.751]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:41.751]                     next
[13:37:41.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:41.751]                 }
[13:37:41.751]                 NAMES <- toupper(added)
[13:37:41.751]                 for (kk in seq_along(NAMES)) {
[13:37:41.751]                   name <- added[[kk]]
[13:37:41.751]                   NAME <- NAMES[[kk]]
[13:37:41.751]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:41.751]                     next
[13:37:41.751]                   args[[name]] <- ""
[13:37:41.751]                 }
[13:37:41.751]                 NAMES <- toupper(removed)
[13:37:41.751]                 for (kk in seq_along(NAMES)) {
[13:37:41.751]                   name <- removed[[kk]]
[13:37:41.751]                   NAME <- NAMES[[kk]]
[13:37:41.751]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:41.751]                     next
[13:37:41.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:41.751]                 }
[13:37:41.751]                 if (length(args) > 0) 
[13:37:41.751]                   base::do.call(base::Sys.setenv, args = args)
[13:37:41.751]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:41.751]             }
[13:37:41.751]             else {
[13:37:41.751]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:41.751]             }
[13:37:41.751]             {
[13:37:41.751]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:41.751]                   0L) {
[13:37:41.751]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:41.751]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:41.751]                   base::options(opts)
[13:37:41.751]                 }
[13:37:41.751]                 {
[13:37:41.751]                   {
[13:37:41.751]                     NULL
[13:37:41.751]                     RNGkind("Mersenne-Twister")
[13:37:41.751]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:37:41.751]                       inherits = FALSE)
[13:37:41.751]                   }
[13:37:41.751]                   options(future.plan = NULL)
[13:37:41.751]                   if (is.na(NA_character_)) 
[13:37:41.751]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:41.751]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:41.751]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:41.751]                     .init = FALSE)
[13:37:41.751]                 }
[13:37:41.751]             }
[13:37:41.751]         }
[13:37:41.751]     })
[13:37:41.751]     if (TRUE) {
[13:37:41.751]         base::sink(type = "output", split = FALSE)
[13:37:41.751]         if (TRUE) {
[13:37:41.751]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:41.751]         }
[13:37:41.751]         else {
[13:37:41.751]             ...future.result["stdout"] <- base::list(NULL)
[13:37:41.751]         }
[13:37:41.751]         base::close(...future.stdout)
[13:37:41.751]         ...future.stdout <- NULL
[13:37:41.751]     }
[13:37:41.751]     ...future.result$conditions <- ...future.conditions
[13:37:41.751]     ...future.result$finished <- base::Sys.time()
[13:37:41.751]     ...future.result
[13:37:41.751] }
[13:37:41.753] plan(): Setting new future strategy stack:
[13:37:41.753] List of future strategies:
[13:37:41.753] 1. sequential:
[13:37:41.753]    - args: function (..., envir = parent.frame())
[13:37:41.753]    - tweaked: FALSE
[13:37:41.753]    - call: NULL
[13:37:41.754] plan(): nbrOfWorkers() = 1
[13:37:41.755] plan(): Setting new future strategy stack:
[13:37:41.755] List of future strategies:
[13:37:41.755] 1. sequential:
[13:37:41.755]    - args: function (..., envir = parent.frame())
[13:37:41.755]    - tweaked: FALSE
[13:37:41.755]    - call: plan(strategy)
[13:37:41.755] plan(): nbrOfWorkers() = 1
[13:37:41.755] SequentialFuture started (and completed)
[13:37:41.756] - Launch lazy future ... done
[13:37:41.756] run() for ‘SequentialFuture’ ... done
[13:37:41.756] resolve() on list ...
[13:37:41.756]  recursive: 0
[13:37:41.756]  length: 3
[13:37:41.756]  elements: ‘a’, ‘b’, ‘’
[13:37:41.756] resolved() for ‘SequentialFuture’ ...
[13:37:41.756] - state: ‘finished’
[13:37:41.757] - run: TRUE
[13:37:41.757] - result: ‘FutureResult’
[13:37:41.757] resolved() for ‘SequentialFuture’ ... done
[13:37:41.757] Future #1
[13:37:41.757]  length: 2 (resolved future 1)
[13:37:41.757] resolved() for ‘SequentialFuture’ ...
[13:37:41.757] - state: ‘finished’
[13:37:41.757] - run: TRUE
[13:37:41.757] - result: ‘FutureResult’
[13:37:41.758] resolved() for ‘SequentialFuture’ ... done
[13:37:41.758] Future #2
[13:37:41.758]  length: 1 (resolved future 2)
[13:37:41.758]  length: 0 (resolved future 3)
[13:37:41.758] resolve() on list ... DONE
[13:37:41.758] resolved() for ‘SequentialFuture’ ...
[13:37:41.758] - state: ‘finished’
[13:37:41.758] - run: TRUE
[13:37:41.758] - result: ‘FutureResult’
[13:37:41.758] resolved() for ‘SequentialFuture’ ... done
[13:37:41.759] resolved() for ‘SequentialFuture’ ...
[13:37:41.759] - state: ‘finished’
[13:37:41.759] - run: TRUE
[13:37:41.759] - result: ‘FutureResult’
[13:37:41.759] resolved() for ‘SequentialFuture’ ... done
[13:37:41.759] getGlobalsAndPackages() ...
[13:37:41.762] Searching for globals...
[13:37:41.762] 
[13:37:41.762] Searching for globals ... DONE
[13:37:41.762] - globals: [0] <none>
[13:37:41.763] getGlobalsAndPackages() ... DONE
[13:37:41.763] getGlobalsAndPackages() ...
[13:37:41.763] Searching for globals...
[13:37:41.763] 
[13:37:41.763] Searching for globals ... DONE
[13:37:41.763] - globals: [0] <none>
[13:37:41.764] getGlobalsAndPackages() ... DONE
[13:37:41.764] run() for ‘Future’ ...
[13:37:41.764] - state: ‘created’
[13:37:41.764] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:37:41.764] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:37:41.764] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:37:41.765]   - Field: ‘label’
[13:37:41.765]   - Field: ‘local’
[13:37:41.765]   - Field: ‘owner’
[13:37:41.765]   - Field: ‘envir’
[13:37:41.765]   - Field: ‘packages’
[13:37:41.765]   - Field: ‘gc’
[13:37:41.765]   - Field: ‘conditions’
[13:37:41.765]   - Field: ‘expr’
[13:37:41.765]   - Field: ‘uuid’
[13:37:41.765]   - Field: ‘seed’
[13:37:41.766]   - Field: ‘version’
[13:37:41.766]   - Field: ‘result’
[13:37:41.766]   - Field: ‘asynchronous’
[13:37:41.766]   - Field: ‘calls’
[13:37:41.766]   - Field: ‘globals’
[13:37:41.766]   - Field: ‘stdout’
[13:37:41.766]   - Field: ‘earlySignal’
[13:37:41.766]   - Field: ‘lazy’
[13:37:41.766]   - Field: ‘state’
[13:37:41.766] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:37:41.767] - Launch lazy future ...
[13:37:41.767] Packages needed by the future expression (n = 0): <none>
[13:37:41.767] Packages needed by future strategies (n = 0): <none>
[13:37:41.767] {
[13:37:41.767]     {
[13:37:41.767]         {
[13:37:41.767]             ...future.startTime <- base::Sys.time()
[13:37:41.767]             {
[13:37:41.767]                 {
[13:37:41.767]                   {
[13:37:41.767]                     base::local({
[13:37:41.767]                       has_future <- base::requireNamespace("future", 
[13:37:41.767]                         quietly = TRUE)
[13:37:41.767]                       if (has_future) {
[13:37:41.767]                         ns <- base::getNamespace("future")
[13:37:41.767]                         version <- ns[[".package"]][["version"]]
[13:37:41.767]                         if (is.null(version)) 
[13:37:41.767]                           version <- utils::packageVersion("future")
[13:37:41.767]                       }
[13:37:41.767]                       else {
[13:37:41.767]                         version <- NULL
[13:37:41.767]                       }
[13:37:41.767]                       if (!has_future || version < "1.8.0") {
[13:37:41.767]                         info <- base::c(r_version = base::gsub("R version ", 
[13:37:41.767]                           "", base::R.version$version.string), 
[13:37:41.767]                           platform = base::sprintf("%s (%s-bit)", 
[13:37:41.767]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:41.767]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:41.767]                             "release", "version")], collapse = " "), 
[13:37:41.767]                           hostname = base::Sys.info()[["nodename"]])
[13:37:41.767]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:37:41.767]                           info)
[13:37:41.767]                         info <- base::paste(info, collapse = "; ")
[13:37:41.767]                         if (!has_future) {
[13:37:41.767]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:41.767]                             info)
[13:37:41.767]                         }
[13:37:41.767]                         else {
[13:37:41.767]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:41.767]                             info, version)
[13:37:41.767]                         }
[13:37:41.767]                         base::stop(msg)
[13:37:41.767]                       }
[13:37:41.767]                     })
[13:37:41.767]                   }
[13:37:41.767]                   ...future.strategy.old <- future::plan("list")
[13:37:41.767]                   options(future.plan = NULL)
[13:37:41.767]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:41.767]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:41.767]                 }
[13:37:41.767]                 ...future.workdir <- getwd()
[13:37:41.767]             }
[13:37:41.767]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:41.767]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:41.767]         }
[13:37:41.767]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:41.767]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:41.767]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:41.767]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:41.767]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:41.767]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:41.767]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:41.767]             base::names(...future.oldOptions))
[13:37:41.767]     }
[13:37:41.767]     if (FALSE) {
[13:37:41.767]     }
[13:37:41.767]     else {
[13:37:41.767]         if (TRUE) {
[13:37:41.767]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:41.767]                 open = "w")
[13:37:41.767]         }
[13:37:41.767]         else {
[13:37:41.767]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:41.767]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:41.767]         }
[13:37:41.767]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:41.767]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:41.767]             base::sink(type = "output", split = FALSE)
[13:37:41.767]             base::close(...future.stdout)
[13:37:41.767]         }, add = TRUE)
[13:37:41.767]     }
[13:37:41.767]     ...future.frame <- base::sys.nframe()
[13:37:41.767]     ...future.conditions <- base::list()
[13:37:41.767]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:41.767]     if (FALSE) {
[13:37:41.767]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:41.767]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:41.767]     }
[13:37:41.767]     ...future.result <- base::tryCatch({
[13:37:41.767]         base::withCallingHandlers({
[13:37:41.767]             ...future.value <- base::withVisible(base::local(2))
[13:37:41.767]             future::FutureResult(value = ...future.value$value, 
[13:37:41.767]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:41.767]                   ...future.rng), globalenv = if (FALSE) 
[13:37:41.767]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:41.767]                     ...future.globalenv.names))
[13:37:41.767]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:41.767]         }, condition = base::local({
[13:37:41.767]             c <- base::c
[13:37:41.767]             inherits <- base::inherits
[13:37:41.767]             invokeRestart <- base::invokeRestart
[13:37:41.767]             length <- base::length
[13:37:41.767]             list <- base::list
[13:37:41.767]             seq.int <- base::seq.int
[13:37:41.767]             signalCondition <- base::signalCondition
[13:37:41.767]             sys.calls <- base::sys.calls
[13:37:41.767]             `[[` <- base::`[[`
[13:37:41.767]             `+` <- base::`+`
[13:37:41.767]             `<<-` <- base::`<<-`
[13:37:41.767]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:41.767]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:41.767]                   3L)]
[13:37:41.767]             }
[13:37:41.767]             function(cond) {
[13:37:41.767]                 is_error <- inherits(cond, "error")
[13:37:41.767]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:41.767]                   NULL)
[13:37:41.767]                 if (is_error) {
[13:37:41.767]                   sessionInformation <- function() {
[13:37:41.767]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:41.767]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:41.767]                       search = base::search(), system = base::Sys.info())
[13:37:41.767]                   }
[13:37:41.767]                   ...future.conditions[[length(...future.conditions) + 
[13:37:41.767]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:41.767]                     cond$call), session = sessionInformation(), 
[13:37:41.767]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:41.767]                   signalCondition(cond)
[13:37:41.767]                 }
[13:37:41.767]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:41.767]                 "immediateCondition"))) {
[13:37:41.767]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:41.767]                   ...future.conditions[[length(...future.conditions) + 
[13:37:41.767]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:41.767]                   if (TRUE && !signal) {
[13:37:41.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:41.767]                     {
[13:37:41.767]                       inherits <- base::inherits
[13:37:41.767]                       invokeRestart <- base::invokeRestart
[13:37:41.767]                       is.null <- base::is.null
[13:37:41.767]                       muffled <- FALSE
[13:37:41.767]                       if (inherits(cond, "message")) {
[13:37:41.767]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:41.767]                         if (muffled) 
[13:37:41.767]                           invokeRestart("muffleMessage")
[13:37:41.767]                       }
[13:37:41.767]                       else if (inherits(cond, "warning")) {
[13:37:41.767]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:41.767]                         if (muffled) 
[13:37:41.767]                           invokeRestart("muffleWarning")
[13:37:41.767]                       }
[13:37:41.767]                       else if (inherits(cond, "condition")) {
[13:37:41.767]                         if (!is.null(pattern)) {
[13:37:41.767]                           computeRestarts <- base::computeRestarts
[13:37:41.767]                           grepl <- base::grepl
[13:37:41.767]                           restarts <- computeRestarts(cond)
[13:37:41.767]                           for (restart in restarts) {
[13:37:41.767]                             name <- restart$name
[13:37:41.767]                             if (is.null(name)) 
[13:37:41.767]                               next
[13:37:41.767]                             if (!grepl(pattern, name)) 
[13:37:41.767]                               next
[13:37:41.767]                             invokeRestart(restart)
[13:37:41.767]                             muffled <- TRUE
[13:37:41.767]                             break
[13:37:41.767]                           }
[13:37:41.767]                         }
[13:37:41.767]                       }
[13:37:41.767]                       invisible(muffled)
[13:37:41.767]                     }
[13:37:41.767]                     muffleCondition(cond, pattern = "^muffle")
[13:37:41.767]                   }
[13:37:41.767]                 }
[13:37:41.767]                 else {
[13:37:41.767]                   if (TRUE) {
[13:37:41.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:41.767]                     {
[13:37:41.767]                       inherits <- base::inherits
[13:37:41.767]                       invokeRestart <- base::invokeRestart
[13:37:41.767]                       is.null <- base::is.null
[13:37:41.767]                       muffled <- FALSE
[13:37:41.767]                       if (inherits(cond, "message")) {
[13:37:41.767]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:41.767]                         if (muffled) 
[13:37:41.767]                           invokeRestart("muffleMessage")
[13:37:41.767]                       }
[13:37:41.767]                       else if (inherits(cond, "warning")) {
[13:37:41.767]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:41.767]                         if (muffled) 
[13:37:41.767]                           invokeRestart("muffleWarning")
[13:37:41.767]                       }
[13:37:41.767]                       else if (inherits(cond, "condition")) {
[13:37:41.767]                         if (!is.null(pattern)) {
[13:37:41.767]                           computeRestarts <- base::computeRestarts
[13:37:41.767]                           grepl <- base::grepl
[13:37:41.767]                           restarts <- computeRestarts(cond)
[13:37:41.767]                           for (restart in restarts) {
[13:37:41.767]                             name <- restart$name
[13:37:41.767]                             if (is.null(name)) 
[13:37:41.767]                               next
[13:37:41.767]                             if (!grepl(pattern, name)) 
[13:37:41.767]                               next
[13:37:41.767]                             invokeRestart(restart)
[13:37:41.767]                             muffled <- TRUE
[13:37:41.767]                             break
[13:37:41.767]                           }
[13:37:41.767]                         }
[13:37:41.767]                       }
[13:37:41.767]                       invisible(muffled)
[13:37:41.767]                     }
[13:37:41.767]                     muffleCondition(cond, pattern = "^muffle")
[13:37:41.767]                   }
[13:37:41.767]                 }
[13:37:41.767]             }
[13:37:41.767]         }))
[13:37:41.767]     }, error = function(ex) {
[13:37:41.767]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:41.767]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:41.767]                 ...future.rng), started = ...future.startTime, 
[13:37:41.767]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:41.767]             version = "1.8"), class = "FutureResult")
[13:37:41.767]     }, finally = {
[13:37:41.767]         if (!identical(...future.workdir, getwd())) 
[13:37:41.767]             setwd(...future.workdir)
[13:37:41.767]         {
[13:37:41.767]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:41.767]                 ...future.oldOptions$nwarnings <- NULL
[13:37:41.767]             }
[13:37:41.767]             base::options(...future.oldOptions)
[13:37:41.767]             if (.Platform$OS.type == "windows") {
[13:37:41.767]                 old_names <- names(...future.oldEnvVars)
[13:37:41.767]                 envs <- base::Sys.getenv()
[13:37:41.767]                 names <- names(envs)
[13:37:41.767]                 common <- intersect(names, old_names)
[13:37:41.767]                 added <- setdiff(names, old_names)
[13:37:41.767]                 removed <- setdiff(old_names, names)
[13:37:41.767]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:41.767]                   envs[common]]
[13:37:41.767]                 NAMES <- toupper(changed)
[13:37:41.767]                 args <- list()
[13:37:41.767]                 for (kk in seq_along(NAMES)) {
[13:37:41.767]                   name <- changed[[kk]]
[13:37:41.767]                   NAME <- NAMES[[kk]]
[13:37:41.767]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:41.767]                     next
[13:37:41.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:41.767]                 }
[13:37:41.767]                 NAMES <- toupper(added)
[13:37:41.767]                 for (kk in seq_along(NAMES)) {
[13:37:41.767]                   name <- added[[kk]]
[13:37:41.767]                   NAME <- NAMES[[kk]]
[13:37:41.767]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:41.767]                     next
[13:37:41.767]                   args[[name]] <- ""
[13:37:41.767]                 }
[13:37:41.767]                 NAMES <- toupper(removed)
[13:37:41.767]                 for (kk in seq_along(NAMES)) {
[13:37:41.767]                   name <- removed[[kk]]
[13:37:41.767]                   NAME <- NAMES[[kk]]
[13:37:41.767]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:41.767]                     next
[13:37:41.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:41.767]                 }
[13:37:41.767]                 if (length(args) > 0) 
[13:37:41.767]                   base::do.call(base::Sys.setenv, args = args)
[13:37:41.767]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:41.767]             }
[13:37:41.767]             else {
[13:37:41.767]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:41.767]             }
[13:37:41.767]             {
[13:37:41.767]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:41.767]                   0L) {
[13:37:41.767]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:41.767]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:41.767]                   base::options(opts)
[13:37:41.767]                 }
[13:37:41.767]                 {
[13:37:41.767]                   {
[13:37:41.767]                     NULL
[13:37:41.767]                     RNGkind("Mersenne-Twister")
[13:37:41.767]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:37:41.767]                       inherits = FALSE)
[13:37:41.767]                   }
[13:37:41.767]                   options(future.plan = NULL)
[13:37:41.767]                   if (is.na(NA_character_)) 
[13:37:41.767]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:41.767]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:41.767]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:41.767]                     .init = FALSE)
[13:37:41.767]                 }
[13:37:41.767]             }
[13:37:41.767]         }
[13:37:41.767]     })
[13:37:41.767]     if (TRUE) {
[13:37:41.767]         base::sink(type = "output", split = FALSE)
[13:37:41.767]         if (TRUE) {
[13:37:41.767]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:41.767]         }
[13:37:41.767]         else {
[13:37:41.767]             ...future.result["stdout"] <- base::list(NULL)
[13:37:41.767]         }
[13:37:41.767]         base::close(...future.stdout)
[13:37:41.767]         ...future.stdout <- NULL
[13:37:41.767]     }
[13:37:41.767]     ...future.result$conditions <- ...future.conditions
[13:37:41.767]     ...future.result$finished <- base::Sys.time()
[13:37:41.767]     ...future.result
[13:37:41.767] }
[13:37:41.769] plan(): Setting new future strategy stack:
[13:37:41.769] List of future strategies:
[13:37:41.769] 1. sequential:
[13:37:41.769]    - args: function (..., envir = parent.frame())
[13:37:41.769]    - tweaked: FALSE
[13:37:41.769]    - call: NULL
[13:37:41.770] plan(): nbrOfWorkers() = 1
[13:37:41.770] plan(): Setting new future strategy stack:
[13:37:41.770] List of future strategies:
[13:37:41.770] 1. sequential:
[13:37:41.770]    - args: function (..., envir = parent.frame())
[13:37:41.770]    - tweaked: FALSE
[13:37:41.770]    - call: plan(strategy)
[13:37:41.771] plan(): nbrOfWorkers() = 1
[13:37:41.771] SequentialFuture started (and completed)
[13:37:41.771] - Launch lazy future ... done
[13:37:41.771] run() for ‘SequentialFuture’ ... done
[13:37:41.771] resolve() on list ...
[13:37:41.771]  recursive: 0
[13:37:41.772]  length: 3
[13:37:41.772]  elements: ‘a’, ‘b’, ‘’
[13:37:41.772] run() for ‘Future’ ...
[13:37:41.772] - state: ‘created’
[13:37:41.772] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:37:41.772] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:37:41.772] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:37:41.773]   - Field: ‘label’
[13:37:41.773]   - Field: ‘local’
[13:37:41.773]   - Field: ‘owner’
[13:37:41.773]   - Field: ‘envir’
[13:37:41.773]   - Field: ‘packages’
[13:37:41.773]   - Field: ‘gc’
[13:37:41.773]   - Field: ‘conditions’
[13:37:41.773]   - Field: ‘expr’
[13:37:41.773]   - Field: ‘uuid’
[13:37:41.773]   - Field: ‘seed’
[13:37:41.773]   - Field: ‘version’
[13:37:41.774]   - Field: ‘result’
[13:37:41.774]   - Field: ‘asynchronous’
[13:37:41.774]   - Field: ‘calls’
[13:37:41.774]   - Field: ‘globals’
[13:37:41.774]   - Field: ‘stdout’
[13:37:41.774]   - Field: ‘earlySignal’
[13:37:41.774]   - Field: ‘lazy’
[13:37:41.774]   - Field: ‘state’
[13:37:41.774] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:37:41.774] - Launch lazy future ...
[13:37:41.775] Packages needed by the future expression (n = 0): <none>
[13:37:41.775] Packages needed by future strategies (n = 0): <none>
[13:37:41.775] {
[13:37:41.775]     {
[13:37:41.775]         {
[13:37:41.775]             ...future.startTime <- base::Sys.time()
[13:37:41.775]             {
[13:37:41.775]                 {
[13:37:41.775]                   {
[13:37:41.775]                     base::local({
[13:37:41.775]                       has_future <- base::requireNamespace("future", 
[13:37:41.775]                         quietly = TRUE)
[13:37:41.775]                       if (has_future) {
[13:37:41.775]                         ns <- base::getNamespace("future")
[13:37:41.775]                         version <- ns[[".package"]][["version"]]
[13:37:41.775]                         if (is.null(version)) 
[13:37:41.775]                           version <- utils::packageVersion("future")
[13:37:41.775]                       }
[13:37:41.775]                       else {
[13:37:41.775]                         version <- NULL
[13:37:41.775]                       }
[13:37:41.775]                       if (!has_future || version < "1.8.0") {
[13:37:41.775]                         info <- base::c(r_version = base::gsub("R version ", 
[13:37:41.775]                           "", base::R.version$version.string), 
[13:37:41.775]                           platform = base::sprintf("%s (%s-bit)", 
[13:37:41.775]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:41.775]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:41.775]                             "release", "version")], collapse = " "), 
[13:37:41.775]                           hostname = base::Sys.info()[["nodename"]])
[13:37:41.775]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:37:41.775]                           info)
[13:37:41.775]                         info <- base::paste(info, collapse = "; ")
[13:37:41.775]                         if (!has_future) {
[13:37:41.775]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:41.775]                             info)
[13:37:41.775]                         }
[13:37:41.775]                         else {
[13:37:41.775]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:41.775]                             info, version)
[13:37:41.775]                         }
[13:37:41.775]                         base::stop(msg)
[13:37:41.775]                       }
[13:37:41.775]                     })
[13:37:41.775]                   }
[13:37:41.775]                   ...future.strategy.old <- future::plan("list")
[13:37:41.775]                   options(future.plan = NULL)
[13:37:41.775]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:41.775]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:41.775]                 }
[13:37:41.775]                 ...future.workdir <- getwd()
[13:37:41.775]             }
[13:37:41.775]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:41.775]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:41.775]         }
[13:37:41.775]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:41.775]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:41.775]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:41.775]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:41.775]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:41.775]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:41.775]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:41.775]             base::names(...future.oldOptions))
[13:37:41.775]     }
[13:37:41.775]     if (FALSE) {
[13:37:41.775]     }
[13:37:41.775]     else {
[13:37:41.775]         if (TRUE) {
[13:37:41.775]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:41.775]                 open = "w")
[13:37:41.775]         }
[13:37:41.775]         else {
[13:37:41.775]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:41.775]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:41.775]         }
[13:37:41.775]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:41.775]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:41.775]             base::sink(type = "output", split = FALSE)
[13:37:41.775]             base::close(...future.stdout)
[13:37:41.775]         }, add = TRUE)
[13:37:41.775]     }
[13:37:41.775]     ...future.frame <- base::sys.nframe()
[13:37:41.775]     ...future.conditions <- base::list()
[13:37:41.775]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:41.775]     if (FALSE) {
[13:37:41.775]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:41.775]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:41.775]     }
[13:37:41.775]     ...future.result <- base::tryCatch({
[13:37:41.775]         base::withCallingHandlers({
[13:37:41.775]             ...future.value <- base::withVisible(base::local(1))
[13:37:41.775]             future::FutureResult(value = ...future.value$value, 
[13:37:41.775]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:41.775]                   ...future.rng), globalenv = if (FALSE) 
[13:37:41.775]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:41.775]                     ...future.globalenv.names))
[13:37:41.775]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:41.775]         }, condition = base::local({
[13:37:41.775]             c <- base::c
[13:37:41.775]             inherits <- base::inherits
[13:37:41.775]             invokeRestart <- base::invokeRestart
[13:37:41.775]             length <- base::length
[13:37:41.775]             list <- base::list
[13:37:41.775]             seq.int <- base::seq.int
[13:37:41.775]             signalCondition <- base::signalCondition
[13:37:41.775]             sys.calls <- base::sys.calls
[13:37:41.775]             `[[` <- base::`[[`
[13:37:41.775]             `+` <- base::`+`
[13:37:41.775]             `<<-` <- base::`<<-`
[13:37:41.775]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:41.775]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:41.775]                   3L)]
[13:37:41.775]             }
[13:37:41.775]             function(cond) {
[13:37:41.775]                 is_error <- inherits(cond, "error")
[13:37:41.775]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:41.775]                   NULL)
[13:37:41.775]                 if (is_error) {
[13:37:41.775]                   sessionInformation <- function() {
[13:37:41.775]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:41.775]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:41.775]                       search = base::search(), system = base::Sys.info())
[13:37:41.775]                   }
[13:37:41.775]                   ...future.conditions[[length(...future.conditions) + 
[13:37:41.775]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:41.775]                     cond$call), session = sessionInformation(), 
[13:37:41.775]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:41.775]                   signalCondition(cond)
[13:37:41.775]                 }
[13:37:41.775]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:41.775]                 "immediateCondition"))) {
[13:37:41.775]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:41.775]                   ...future.conditions[[length(...future.conditions) + 
[13:37:41.775]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:41.775]                   if (TRUE && !signal) {
[13:37:41.775]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:41.775]                     {
[13:37:41.775]                       inherits <- base::inherits
[13:37:41.775]                       invokeRestart <- base::invokeRestart
[13:37:41.775]                       is.null <- base::is.null
[13:37:41.775]                       muffled <- FALSE
[13:37:41.775]                       if (inherits(cond, "message")) {
[13:37:41.775]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:41.775]                         if (muffled) 
[13:37:41.775]                           invokeRestart("muffleMessage")
[13:37:41.775]                       }
[13:37:41.775]                       else if (inherits(cond, "warning")) {
[13:37:41.775]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:41.775]                         if (muffled) 
[13:37:41.775]                           invokeRestart("muffleWarning")
[13:37:41.775]                       }
[13:37:41.775]                       else if (inherits(cond, "condition")) {
[13:37:41.775]                         if (!is.null(pattern)) {
[13:37:41.775]                           computeRestarts <- base::computeRestarts
[13:37:41.775]                           grepl <- base::grepl
[13:37:41.775]                           restarts <- computeRestarts(cond)
[13:37:41.775]                           for (restart in restarts) {
[13:37:41.775]                             name <- restart$name
[13:37:41.775]                             if (is.null(name)) 
[13:37:41.775]                               next
[13:37:41.775]                             if (!grepl(pattern, name)) 
[13:37:41.775]                               next
[13:37:41.775]                             invokeRestart(restart)
[13:37:41.775]                             muffled <- TRUE
[13:37:41.775]                             break
[13:37:41.775]                           }
[13:37:41.775]                         }
[13:37:41.775]                       }
[13:37:41.775]                       invisible(muffled)
[13:37:41.775]                     }
[13:37:41.775]                     muffleCondition(cond, pattern = "^muffle")
[13:37:41.775]                   }
[13:37:41.775]                 }
[13:37:41.775]                 else {
[13:37:41.775]                   if (TRUE) {
[13:37:41.775]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:41.775]                     {
[13:37:41.775]                       inherits <- base::inherits
[13:37:41.775]                       invokeRestart <- base::invokeRestart
[13:37:41.775]                       is.null <- base::is.null
[13:37:41.775]                       muffled <- FALSE
[13:37:41.775]                       if (inherits(cond, "message")) {
[13:37:41.775]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:41.775]                         if (muffled) 
[13:37:41.775]                           invokeRestart("muffleMessage")
[13:37:41.775]                       }
[13:37:41.775]                       else if (inherits(cond, "warning")) {
[13:37:41.775]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:41.775]                         if (muffled) 
[13:37:41.775]                           invokeRestart("muffleWarning")
[13:37:41.775]                       }
[13:37:41.775]                       else if (inherits(cond, "condition")) {
[13:37:41.775]                         if (!is.null(pattern)) {
[13:37:41.775]                           computeRestarts <- base::computeRestarts
[13:37:41.775]                           grepl <- base::grepl
[13:37:41.775]                           restarts <- computeRestarts(cond)
[13:37:41.775]                           for (restart in restarts) {
[13:37:41.775]                             name <- restart$name
[13:37:41.775]                             if (is.null(name)) 
[13:37:41.775]                               next
[13:37:41.775]                             if (!grepl(pattern, name)) 
[13:37:41.775]                               next
[13:37:41.775]                             invokeRestart(restart)
[13:37:41.775]                             muffled <- TRUE
[13:37:41.775]                             break
[13:37:41.775]                           }
[13:37:41.775]                         }
[13:37:41.775]                       }
[13:37:41.775]                       invisible(muffled)
[13:37:41.775]                     }
[13:37:41.775]                     muffleCondition(cond, pattern = "^muffle")
[13:37:41.775]                   }
[13:37:41.775]                 }
[13:37:41.775]             }
[13:37:41.775]         }))
[13:37:41.775]     }, error = function(ex) {
[13:37:41.775]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:41.775]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:41.775]                 ...future.rng), started = ...future.startTime, 
[13:37:41.775]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:41.775]             version = "1.8"), class = "FutureResult")
[13:37:41.775]     }, finally = {
[13:37:41.775]         if (!identical(...future.workdir, getwd())) 
[13:37:41.775]             setwd(...future.workdir)
[13:37:41.775]         {
[13:37:41.775]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:41.775]                 ...future.oldOptions$nwarnings <- NULL
[13:37:41.775]             }
[13:37:41.775]             base::options(...future.oldOptions)
[13:37:41.775]             if (.Platform$OS.type == "windows") {
[13:37:41.775]                 old_names <- names(...future.oldEnvVars)
[13:37:41.775]                 envs <- base::Sys.getenv()
[13:37:41.775]                 names <- names(envs)
[13:37:41.775]                 common <- intersect(names, old_names)
[13:37:41.775]                 added <- setdiff(names, old_names)
[13:37:41.775]                 removed <- setdiff(old_names, names)
[13:37:41.775]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:41.775]                   envs[common]]
[13:37:41.775]                 NAMES <- toupper(changed)
[13:37:41.775]                 args <- list()
[13:37:41.775]                 for (kk in seq_along(NAMES)) {
[13:37:41.775]                   name <- changed[[kk]]
[13:37:41.775]                   NAME <- NAMES[[kk]]
[13:37:41.775]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:41.775]                     next
[13:37:41.775]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:41.775]                 }
[13:37:41.775]                 NAMES <- toupper(added)
[13:37:41.775]                 for (kk in seq_along(NAMES)) {
[13:37:41.775]                   name <- added[[kk]]
[13:37:41.775]                   NAME <- NAMES[[kk]]
[13:37:41.775]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:41.775]                     next
[13:37:41.775]                   args[[name]] <- ""
[13:37:41.775]                 }
[13:37:41.775]                 NAMES <- toupper(removed)
[13:37:41.775]                 for (kk in seq_along(NAMES)) {
[13:37:41.775]                   name <- removed[[kk]]
[13:37:41.775]                   NAME <- NAMES[[kk]]
[13:37:41.775]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:41.775]                     next
[13:37:41.775]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:41.775]                 }
[13:37:41.775]                 if (length(args) > 0) 
[13:37:41.775]                   base::do.call(base::Sys.setenv, args = args)
[13:37:41.775]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:41.775]             }
[13:37:41.775]             else {
[13:37:41.775]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:41.775]             }
[13:37:41.775]             {
[13:37:41.775]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:41.775]                   0L) {
[13:37:41.775]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:41.775]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:41.775]                   base::options(opts)
[13:37:41.775]                 }
[13:37:41.775]                 {
[13:37:41.775]                   {
[13:37:41.775]                     NULL
[13:37:41.775]                     RNGkind("Mersenne-Twister")
[13:37:41.775]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:37:41.775]                       inherits = FALSE)
[13:37:41.775]                   }
[13:37:41.775]                   options(future.plan = NULL)
[13:37:41.775]                   if (is.na(NA_character_)) 
[13:37:41.775]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:41.775]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:41.775]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:41.775]                     .init = FALSE)
[13:37:41.775]                 }
[13:37:41.775]             }
[13:37:41.775]         }
[13:37:41.775]     })
[13:37:41.775]     if (TRUE) {
[13:37:41.775]         base::sink(type = "output", split = FALSE)
[13:37:41.775]         if (TRUE) {
[13:37:41.775]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:41.775]         }
[13:37:41.775]         else {
[13:37:41.775]             ...future.result["stdout"] <- base::list(NULL)
[13:37:41.775]         }
[13:37:41.775]         base::close(...future.stdout)
[13:37:41.775]         ...future.stdout <- NULL
[13:37:41.775]     }
[13:37:41.775]     ...future.result$conditions <- ...future.conditions
[13:37:41.775]     ...future.result$finished <- base::Sys.time()
[13:37:41.775]     ...future.result
[13:37:41.775] }
[13:37:41.777] plan(): Setting new future strategy stack:
[13:37:41.777] List of future strategies:
[13:37:41.777] 1. sequential:
[13:37:41.777]    - args: function (..., envir = parent.frame())
[13:37:41.777]    - tweaked: FALSE
[13:37:41.777]    - call: NULL
[13:37:41.777] plan(): nbrOfWorkers() = 1
[13:37:41.778] plan(): Setting new future strategy stack:
[13:37:41.778] List of future strategies:
[13:37:41.778] 1. sequential:
[13:37:41.778]    - args: function (..., envir = parent.frame())
[13:37:41.778]    - tweaked: FALSE
[13:37:41.778]    - call: plan(strategy)
[13:37:41.779] plan(): nbrOfWorkers() = 1
[13:37:41.779] SequentialFuture started (and completed)
[13:37:41.779] - Launch lazy future ... done
[13:37:41.779] run() for ‘SequentialFuture’ ... done
[13:37:41.779] resolved() for ‘SequentialFuture’ ...
[13:37:41.779] - state: ‘finished’
[13:37:41.779] - run: TRUE
[13:37:41.779] - result: ‘FutureResult’
[13:37:41.780] resolved() for ‘SequentialFuture’ ... done
[13:37:41.780] Future #1
[13:37:41.780]  length: 2 (resolved future 1)
[13:37:41.780] resolved() for ‘SequentialFuture’ ...
[13:37:41.780] - state: ‘finished’
[13:37:41.780] - run: TRUE
[13:37:41.780] - result: ‘FutureResult’
[13:37:41.780] resolved() for ‘SequentialFuture’ ... done
[13:37:41.780] Future #2
[13:37:41.780]  length: 1 (resolved future 2)
[13:37:41.781]  length: 0 (resolved future 3)
[13:37:41.781] resolve() on list ... DONE
[13:37:41.781] resolved() for ‘SequentialFuture’ ...
[13:37:41.781] - state: ‘finished’
[13:37:41.781] - run: TRUE
[13:37:41.781] - result: ‘FutureResult’
[13:37:41.781] resolved() for ‘SequentialFuture’ ... done
[13:37:41.781] resolved() for ‘SequentialFuture’ ...
[13:37:41.781] - state: ‘finished’
[13:37:41.781] - run: TRUE
[13:37:41.782] - result: ‘FutureResult’
[13:37:41.782] resolved() for ‘SequentialFuture’ ... done
[13:37:41.782] getGlobalsAndPackages() ...
[13:37:41.782] Searching for globals...
[13:37:41.782] 
[13:37:41.782] Searching for globals ... DONE
[13:37:41.782] - globals: [0] <none>
[13:37:41.782] getGlobalsAndPackages() ... DONE
[13:37:41.783] getGlobalsAndPackages() ...
[13:37:41.783] Searching for globals...
[13:37:41.783] 
[13:37:41.783] Searching for globals ... DONE
[13:37:41.783] - globals: [0] <none>
[13:37:41.783] getGlobalsAndPackages() ... DONE
[13:37:41.784] resolve() on list ...
[13:37:41.784]  recursive: 0
[13:37:41.784]  length: 3
[13:37:41.784]  elements: ‘a’, ‘b’, ‘’
[13:37:41.784] run() for ‘Future’ ...
[13:37:41.784] - state: ‘created’
[13:37:41.784] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:37:41.784] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:37:41.785] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:37:41.785]   - Field: ‘label’
[13:37:41.785]   - Field: ‘local’
[13:37:41.785]   - Field: ‘owner’
[13:37:41.785]   - Field: ‘envir’
[13:37:41.785]   - Field: ‘packages’
[13:37:41.785]   - Field: ‘gc’
[13:37:41.785]   - Field: ‘conditions’
[13:37:41.785]   - Field: ‘expr’
[13:37:41.785]   - Field: ‘uuid’
[13:37:41.786]   - Field: ‘seed’
[13:37:41.786]   - Field: ‘version’
[13:37:41.786]   - Field: ‘result’
[13:37:41.786]   - Field: ‘asynchronous’
[13:37:41.786]   - Field: ‘calls’
[13:37:41.786]   - Field: ‘globals’
[13:37:41.786]   - Field: ‘stdout’
[13:37:41.786]   - Field: ‘earlySignal’
[13:37:41.786]   - Field: ‘lazy’
[13:37:41.786]   - Field: ‘state’
[13:37:41.786] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:37:41.787] - Launch lazy future ...
[13:37:41.787] Packages needed by the future expression (n = 0): <none>
[13:37:41.787] Packages needed by future strategies (n = 0): <none>
[13:37:41.787] {
[13:37:41.787]     {
[13:37:41.787]         {
[13:37:41.787]             ...future.startTime <- base::Sys.time()
[13:37:41.787]             {
[13:37:41.787]                 {
[13:37:41.787]                   {
[13:37:41.787]                     base::local({
[13:37:41.787]                       has_future <- base::requireNamespace("future", 
[13:37:41.787]                         quietly = TRUE)
[13:37:41.787]                       if (has_future) {
[13:37:41.787]                         ns <- base::getNamespace("future")
[13:37:41.787]                         version <- ns[[".package"]][["version"]]
[13:37:41.787]                         if (is.null(version)) 
[13:37:41.787]                           version <- utils::packageVersion("future")
[13:37:41.787]                       }
[13:37:41.787]                       else {
[13:37:41.787]                         version <- NULL
[13:37:41.787]                       }
[13:37:41.787]                       if (!has_future || version < "1.8.0") {
[13:37:41.787]                         info <- base::c(r_version = base::gsub("R version ", 
[13:37:41.787]                           "", base::R.version$version.string), 
[13:37:41.787]                           platform = base::sprintf("%s (%s-bit)", 
[13:37:41.787]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:41.787]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:41.787]                             "release", "version")], collapse = " "), 
[13:37:41.787]                           hostname = base::Sys.info()[["nodename"]])
[13:37:41.787]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:37:41.787]                           info)
[13:37:41.787]                         info <- base::paste(info, collapse = "; ")
[13:37:41.787]                         if (!has_future) {
[13:37:41.787]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:41.787]                             info)
[13:37:41.787]                         }
[13:37:41.787]                         else {
[13:37:41.787]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:41.787]                             info, version)
[13:37:41.787]                         }
[13:37:41.787]                         base::stop(msg)
[13:37:41.787]                       }
[13:37:41.787]                     })
[13:37:41.787]                   }
[13:37:41.787]                   ...future.strategy.old <- future::plan("list")
[13:37:41.787]                   options(future.plan = NULL)
[13:37:41.787]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:41.787]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:41.787]                 }
[13:37:41.787]                 ...future.workdir <- getwd()
[13:37:41.787]             }
[13:37:41.787]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:41.787]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:41.787]         }
[13:37:41.787]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:41.787]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:41.787]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:41.787]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:41.787]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:41.787]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:41.787]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:41.787]             base::names(...future.oldOptions))
[13:37:41.787]     }
[13:37:41.787]     if (FALSE) {
[13:37:41.787]     }
[13:37:41.787]     else {
[13:37:41.787]         if (TRUE) {
[13:37:41.787]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:41.787]                 open = "w")
[13:37:41.787]         }
[13:37:41.787]         else {
[13:37:41.787]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:41.787]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:41.787]         }
[13:37:41.787]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:41.787]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:41.787]             base::sink(type = "output", split = FALSE)
[13:37:41.787]             base::close(...future.stdout)
[13:37:41.787]         }, add = TRUE)
[13:37:41.787]     }
[13:37:41.787]     ...future.frame <- base::sys.nframe()
[13:37:41.787]     ...future.conditions <- base::list()
[13:37:41.787]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:41.787]     if (FALSE) {
[13:37:41.787]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:41.787]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:41.787]     }
[13:37:41.787]     ...future.result <- base::tryCatch({
[13:37:41.787]         base::withCallingHandlers({
[13:37:41.787]             ...future.value <- base::withVisible(base::local(1))
[13:37:41.787]             future::FutureResult(value = ...future.value$value, 
[13:37:41.787]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:41.787]                   ...future.rng), globalenv = if (FALSE) 
[13:37:41.787]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:41.787]                     ...future.globalenv.names))
[13:37:41.787]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:41.787]         }, condition = base::local({
[13:37:41.787]             c <- base::c
[13:37:41.787]             inherits <- base::inherits
[13:37:41.787]             invokeRestart <- base::invokeRestart
[13:37:41.787]             length <- base::length
[13:37:41.787]             list <- base::list
[13:37:41.787]             seq.int <- base::seq.int
[13:37:41.787]             signalCondition <- base::signalCondition
[13:37:41.787]             sys.calls <- base::sys.calls
[13:37:41.787]             `[[` <- base::`[[`
[13:37:41.787]             `+` <- base::`+`
[13:37:41.787]             `<<-` <- base::`<<-`
[13:37:41.787]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:41.787]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:41.787]                   3L)]
[13:37:41.787]             }
[13:37:41.787]             function(cond) {
[13:37:41.787]                 is_error <- inherits(cond, "error")
[13:37:41.787]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:41.787]                   NULL)
[13:37:41.787]                 if (is_error) {
[13:37:41.787]                   sessionInformation <- function() {
[13:37:41.787]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:41.787]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:41.787]                       search = base::search(), system = base::Sys.info())
[13:37:41.787]                   }
[13:37:41.787]                   ...future.conditions[[length(...future.conditions) + 
[13:37:41.787]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:41.787]                     cond$call), session = sessionInformation(), 
[13:37:41.787]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:41.787]                   signalCondition(cond)
[13:37:41.787]                 }
[13:37:41.787]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:41.787]                 "immediateCondition"))) {
[13:37:41.787]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:41.787]                   ...future.conditions[[length(...future.conditions) + 
[13:37:41.787]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:41.787]                   if (TRUE && !signal) {
[13:37:41.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:41.787]                     {
[13:37:41.787]                       inherits <- base::inherits
[13:37:41.787]                       invokeRestart <- base::invokeRestart
[13:37:41.787]                       is.null <- base::is.null
[13:37:41.787]                       muffled <- FALSE
[13:37:41.787]                       if (inherits(cond, "message")) {
[13:37:41.787]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:41.787]                         if (muffled) 
[13:37:41.787]                           invokeRestart("muffleMessage")
[13:37:41.787]                       }
[13:37:41.787]                       else if (inherits(cond, "warning")) {
[13:37:41.787]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:41.787]                         if (muffled) 
[13:37:41.787]                           invokeRestart("muffleWarning")
[13:37:41.787]                       }
[13:37:41.787]                       else if (inherits(cond, "condition")) {
[13:37:41.787]                         if (!is.null(pattern)) {
[13:37:41.787]                           computeRestarts <- base::computeRestarts
[13:37:41.787]                           grepl <- base::grepl
[13:37:41.787]                           restarts <- computeRestarts(cond)
[13:37:41.787]                           for (restart in restarts) {
[13:37:41.787]                             name <- restart$name
[13:37:41.787]                             if (is.null(name)) 
[13:37:41.787]                               next
[13:37:41.787]                             if (!grepl(pattern, name)) 
[13:37:41.787]                               next
[13:37:41.787]                             invokeRestart(restart)
[13:37:41.787]                             muffled <- TRUE
[13:37:41.787]                             break
[13:37:41.787]                           }
[13:37:41.787]                         }
[13:37:41.787]                       }
[13:37:41.787]                       invisible(muffled)
[13:37:41.787]                     }
[13:37:41.787]                     muffleCondition(cond, pattern = "^muffle")
[13:37:41.787]                   }
[13:37:41.787]                 }
[13:37:41.787]                 else {
[13:37:41.787]                   if (TRUE) {
[13:37:41.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:41.787]                     {
[13:37:41.787]                       inherits <- base::inherits
[13:37:41.787]                       invokeRestart <- base::invokeRestart
[13:37:41.787]                       is.null <- base::is.null
[13:37:41.787]                       muffled <- FALSE
[13:37:41.787]                       if (inherits(cond, "message")) {
[13:37:41.787]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:41.787]                         if (muffled) 
[13:37:41.787]                           invokeRestart("muffleMessage")
[13:37:41.787]                       }
[13:37:41.787]                       else if (inherits(cond, "warning")) {
[13:37:41.787]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:41.787]                         if (muffled) 
[13:37:41.787]                           invokeRestart("muffleWarning")
[13:37:41.787]                       }
[13:37:41.787]                       else if (inherits(cond, "condition")) {
[13:37:41.787]                         if (!is.null(pattern)) {
[13:37:41.787]                           computeRestarts <- base::computeRestarts
[13:37:41.787]                           grepl <- base::grepl
[13:37:41.787]                           restarts <- computeRestarts(cond)
[13:37:41.787]                           for (restart in restarts) {
[13:37:41.787]                             name <- restart$name
[13:37:41.787]                             if (is.null(name)) 
[13:37:41.787]                               next
[13:37:41.787]                             if (!grepl(pattern, name)) 
[13:37:41.787]                               next
[13:37:41.787]                             invokeRestart(restart)
[13:37:41.787]                             muffled <- TRUE
[13:37:41.787]                             break
[13:37:41.787]                           }
[13:37:41.787]                         }
[13:37:41.787]                       }
[13:37:41.787]                       invisible(muffled)
[13:37:41.787]                     }
[13:37:41.787]                     muffleCondition(cond, pattern = "^muffle")
[13:37:41.787]                   }
[13:37:41.787]                 }
[13:37:41.787]             }
[13:37:41.787]         }))
[13:37:41.787]     }, error = function(ex) {
[13:37:41.787]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:41.787]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:41.787]                 ...future.rng), started = ...future.startTime, 
[13:37:41.787]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:41.787]             version = "1.8"), class = "FutureResult")
[13:37:41.787]     }, finally = {
[13:37:41.787]         if (!identical(...future.workdir, getwd())) 
[13:37:41.787]             setwd(...future.workdir)
[13:37:41.787]         {
[13:37:41.787]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:41.787]                 ...future.oldOptions$nwarnings <- NULL
[13:37:41.787]             }
[13:37:41.787]             base::options(...future.oldOptions)
[13:37:41.787]             if (.Platform$OS.type == "windows") {
[13:37:41.787]                 old_names <- names(...future.oldEnvVars)
[13:37:41.787]                 envs <- base::Sys.getenv()
[13:37:41.787]                 names <- names(envs)
[13:37:41.787]                 common <- intersect(names, old_names)
[13:37:41.787]                 added <- setdiff(names, old_names)
[13:37:41.787]                 removed <- setdiff(old_names, names)
[13:37:41.787]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:41.787]                   envs[common]]
[13:37:41.787]                 NAMES <- toupper(changed)
[13:37:41.787]                 args <- list()
[13:37:41.787]                 for (kk in seq_along(NAMES)) {
[13:37:41.787]                   name <- changed[[kk]]
[13:37:41.787]                   NAME <- NAMES[[kk]]
[13:37:41.787]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:41.787]                     next
[13:37:41.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:41.787]                 }
[13:37:41.787]                 NAMES <- toupper(added)
[13:37:41.787]                 for (kk in seq_along(NAMES)) {
[13:37:41.787]                   name <- added[[kk]]
[13:37:41.787]                   NAME <- NAMES[[kk]]
[13:37:41.787]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:41.787]                     next
[13:37:41.787]                   args[[name]] <- ""
[13:37:41.787]                 }
[13:37:41.787]                 NAMES <- toupper(removed)
[13:37:41.787]                 for (kk in seq_along(NAMES)) {
[13:37:41.787]                   name <- removed[[kk]]
[13:37:41.787]                   NAME <- NAMES[[kk]]
[13:37:41.787]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:41.787]                     next
[13:37:41.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:41.787]                 }
[13:37:41.787]                 if (length(args) > 0) 
[13:37:41.787]                   base::do.call(base::Sys.setenv, args = args)
[13:37:41.787]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:41.787]             }
[13:37:41.787]             else {
[13:37:41.787]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:41.787]             }
[13:37:41.787]             {
[13:37:41.787]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:41.787]                   0L) {
[13:37:41.787]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:41.787]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:41.787]                   base::options(opts)
[13:37:41.787]                 }
[13:37:41.787]                 {
[13:37:41.787]                   {
[13:37:41.787]                     NULL
[13:37:41.787]                     RNGkind("Mersenne-Twister")
[13:37:41.787]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:37:41.787]                       inherits = FALSE)
[13:37:41.787]                   }
[13:37:41.787]                   options(future.plan = NULL)
[13:37:41.787]                   if (is.na(NA_character_)) 
[13:37:41.787]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:41.787]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:41.787]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:41.787]                     .init = FALSE)
[13:37:41.787]                 }
[13:37:41.787]             }
[13:37:41.787]         }
[13:37:41.787]     })
[13:37:41.787]     if (TRUE) {
[13:37:41.787]         base::sink(type = "output", split = FALSE)
[13:37:41.787]         if (TRUE) {
[13:37:41.787]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:41.787]         }
[13:37:41.787]         else {
[13:37:41.787]             ...future.result["stdout"] <- base::list(NULL)
[13:37:41.787]         }
[13:37:41.787]         base::close(...future.stdout)
[13:37:41.787]         ...future.stdout <- NULL
[13:37:41.787]     }
[13:37:41.787]     ...future.result$conditions <- ...future.conditions
[13:37:41.787]     ...future.result$finished <- base::Sys.time()
[13:37:41.787]     ...future.result
[13:37:41.787] }
[13:37:41.789] plan(): Setting new future strategy stack:
[13:37:41.789] List of future strategies:
[13:37:41.789] 1. sequential:
[13:37:41.789]    - args: function (..., envir = parent.frame())
[13:37:41.789]    - tweaked: FALSE
[13:37:41.789]    - call: NULL
[13:37:41.790] plan(): nbrOfWorkers() = 1
[13:37:41.791] plan(): Setting new future strategy stack:
[13:37:41.791] List of future strategies:
[13:37:41.791] 1. sequential:
[13:37:41.791]    - args: function (..., envir = parent.frame())
[13:37:41.791]    - tweaked: FALSE
[13:37:41.791]    - call: plan(strategy)
[13:37:41.791] plan(): nbrOfWorkers() = 1
[13:37:41.791] SequentialFuture started (and completed)
[13:37:41.791] - Launch lazy future ... done
[13:37:41.791] run() for ‘SequentialFuture’ ... done
[13:37:41.792] resolved() for ‘SequentialFuture’ ...
[13:37:41.792] - state: ‘finished’
[13:37:41.792] - run: TRUE
[13:37:41.792] - result: ‘FutureResult’
[13:37:41.792] resolved() for ‘SequentialFuture’ ... done
[13:37:41.792] Future #1
[13:37:41.792]  length: 2 (resolved future 1)
[13:37:41.792] run() for ‘Future’ ...
[13:37:41.792] - state: ‘created’
[13:37:41.793] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:37:41.793] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:37:41.793] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:37:41.793]   - Field: ‘label’
[13:37:41.793]   - Field: ‘local’
[13:37:41.793]   - Field: ‘owner’
[13:37:41.793]   - Field: ‘envir’
[13:37:41.793]   - Field: ‘packages’
[13:37:41.794]   - Field: ‘gc’
[13:37:41.794]   - Field: ‘conditions’
[13:37:41.794]   - Field: ‘expr’
[13:37:41.794]   - Field: ‘uuid’
[13:37:41.794]   - Field: ‘seed’
[13:37:41.794]   - Field: ‘version’
[13:37:41.794]   - Field: ‘result’
[13:37:41.794]   - Field: ‘asynchronous’
[13:37:41.794]   - Field: ‘calls’
[13:37:41.794]   - Field: ‘globals’
[13:37:41.795]   - Field: ‘stdout’
[13:37:41.795]   - Field: ‘earlySignal’
[13:37:41.795]   - Field: ‘lazy’
[13:37:41.795]   - Field: ‘state’
[13:37:41.795] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:37:41.795] - Launch lazy future ...
[13:37:41.795] Packages needed by the future expression (n = 0): <none>
[13:37:41.795] Packages needed by future strategies (n = 0): <none>
[13:37:41.798] {
[13:37:41.798]     {
[13:37:41.798]         {
[13:37:41.798]             ...future.startTime <- base::Sys.time()
[13:37:41.798]             {
[13:37:41.798]                 {
[13:37:41.798]                   {
[13:37:41.798]                     base::local({
[13:37:41.798]                       has_future <- base::requireNamespace("future", 
[13:37:41.798]                         quietly = TRUE)
[13:37:41.798]                       if (has_future) {
[13:37:41.798]                         ns <- base::getNamespace("future")
[13:37:41.798]                         version <- ns[[".package"]][["version"]]
[13:37:41.798]                         if (is.null(version)) 
[13:37:41.798]                           version <- utils::packageVersion("future")
[13:37:41.798]                       }
[13:37:41.798]                       else {
[13:37:41.798]                         version <- NULL
[13:37:41.798]                       }
[13:37:41.798]                       if (!has_future || version < "1.8.0") {
[13:37:41.798]                         info <- base::c(r_version = base::gsub("R version ", 
[13:37:41.798]                           "", base::R.version$version.string), 
[13:37:41.798]                           platform = base::sprintf("%s (%s-bit)", 
[13:37:41.798]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:41.798]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:41.798]                             "release", "version")], collapse = " "), 
[13:37:41.798]                           hostname = base::Sys.info()[["nodename"]])
[13:37:41.798]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:37:41.798]                           info)
[13:37:41.798]                         info <- base::paste(info, collapse = "; ")
[13:37:41.798]                         if (!has_future) {
[13:37:41.798]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:41.798]                             info)
[13:37:41.798]                         }
[13:37:41.798]                         else {
[13:37:41.798]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:41.798]                             info, version)
[13:37:41.798]                         }
[13:37:41.798]                         base::stop(msg)
[13:37:41.798]                       }
[13:37:41.798]                     })
[13:37:41.798]                   }
[13:37:41.798]                   ...future.strategy.old <- future::plan("list")
[13:37:41.798]                   options(future.plan = NULL)
[13:37:41.798]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:41.798]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:41.798]                 }
[13:37:41.798]                 ...future.workdir <- getwd()
[13:37:41.798]             }
[13:37:41.798]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:41.798]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:41.798]         }
[13:37:41.798]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:41.798]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:41.798]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:41.798]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:41.798]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:41.798]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:41.798]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:41.798]             base::names(...future.oldOptions))
[13:37:41.798]     }
[13:37:41.798]     if (FALSE) {
[13:37:41.798]     }
[13:37:41.798]     else {
[13:37:41.798]         if (TRUE) {
[13:37:41.798]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:41.798]                 open = "w")
[13:37:41.798]         }
[13:37:41.798]         else {
[13:37:41.798]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:41.798]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:41.798]         }
[13:37:41.798]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:41.798]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:41.798]             base::sink(type = "output", split = FALSE)
[13:37:41.798]             base::close(...future.stdout)
[13:37:41.798]         }, add = TRUE)
[13:37:41.798]     }
[13:37:41.798]     ...future.frame <- base::sys.nframe()
[13:37:41.798]     ...future.conditions <- base::list()
[13:37:41.798]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:41.798]     if (FALSE) {
[13:37:41.798]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:41.798]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:41.798]     }
[13:37:41.798]     ...future.result <- base::tryCatch({
[13:37:41.798]         base::withCallingHandlers({
[13:37:41.798]             ...future.value <- base::withVisible(base::local(2))
[13:37:41.798]             future::FutureResult(value = ...future.value$value, 
[13:37:41.798]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:41.798]                   ...future.rng), globalenv = if (FALSE) 
[13:37:41.798]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:41.798]                     ...future.globalenv.names))
[13:37:41.798]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:41.798]         }, condition = base::local({
[13:37:41.798]             c <- base::c
[13:37:41.798]             inherits <- base::inherits
[13:37:41.798]             invokeRestart <- base::invokeRestart
[13:37:41.798]             length <- base::length
[13:37:41.798]             list <- base::list
[13:37:41.798]             seq.int <- base::seq.int
[13:37:41.798]             signalCondition <- base::signalCondition
[13:37:41.798]             sys.calls <- base::sys.calls
[13:37:41.798]             `[[` <- base::`[[`
[13:37:41.798]             `+` <- base::`+`
[13:37:41.798]             `<<-` <- base::`<<-`
[13:37:41.798]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:41.798]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:41.798]                   3L)]
[13:37:41.798]             }
[13:37:41.798]             function(cond) {
[13:37:41.798]                 is_error <- inherits(cond, "error")
[13:37:41.798]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:41.798]                   NULL)
[13:37:41.798]                 if (is_error) {
[13:37:41.798]                   sessionInformation <- function() {
[13:37:41.798]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:41.798]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:41.798]                       search = base::search(), system = base::Sys.info())
[13:37:41.798]                   }
[13:37:41.798]                   ...future.conditions[[length(...future.conditions) + 
[13:37:41.798]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:41.798]                     cond$call), session = sessionInformation(), 
[13:37:41.798]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:41.798]                   signalCondition(cond)
[13:37:41.798]                 }
[13:37:41.798]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:41.798]                 "immediateCondition"))) {
[13:37:41.798]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:41.798]                   ...future.conditions[[length(...future.conditions) + 
[13:37:41.798]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:41.798]                   if (TRUE && !signal) {
[13:37:41.798]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:41.798]                     {
[13:37:41.798]                       inherits <- base::inherits
[13:37:41.798]                       invokeRestart <- base::invokeRestart
[13:37:41.798]                       is.null <- base::is.null
[13:37:41.798]                       muffled <- FALSE
[13:37:41.798]                       if (inherits(cond, "message")) {
[13:37:41.798]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:41.798]                         if (muffled) 
[13:37:41.798]                           invokeRestart("muffleMessage")
[13:37:41.798]                       }
[13:37:41.798]                       else if (inherits(cond, "warning")) {
[13:37:41.798]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:41.798]                         if (muffled) 
[13:37:41.798]                           invokeRestart("muffleWarning")
[13:37:41.798]                       }
[13:37:41.798]                       else if (inherits(cond, "condition")) {
[13:37:41.798]                         if (!is.null(pattern)) {
[13:37:41.798]                           computeRestarts <- base::computeRestarts
[13:37:41.798]                           grepl <- base::grepl
[13:37:41.798]                           restarts <- computeRestarts(cond)
[13:37:41.798]                           for (restart in restarts) {
[13:37:41.798]                             name <- restart$name
[13:37:41.798]                             if (is.null(name)) 
[13:37:41.798]                               next
[13:37:41.798]                             if (!grepl(pattern, name)) 
[13:37:41.798]                               next
[13:37:41.798]                             invokeRestart(restart)
[13:37:41.798]                             muffled <- TRUE
[13:37:41.798]                             break
[13:37:41.798]                           }
[13:37:41.798]                         }
[13:37:41.798]                       }
[13:37:41.798]                       invisible(muffled)
[13:37:41.798]                     }
[13:37:41.798]                     muffleCondition(cond, pattern = "^muffle")
[13:37:41.798]                   }
[13:37:41.798]                 }
[13:37:41.798]                 else {
[13:37:41.798]                   if (TRUE) {
[13:37:41.798]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:41.798]                     {
[13:37:41.798]                       inherits <- base::inherits
[13:37:41.798]                       invokeRestart <- base::invokeRestart
[13:37:41.798]                       is.null <- base::is.null
[13:37:41.798]                       muffled <- FALSE
[13:37:41.798]                       if (inherits(cond, "message")) {
[13:37:41.798]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:41.798]                         if (muffled) 
[13:37:41.798]                           invokeRestart("muffleMessage")
[13:37:41.798]                       }
[13:37:41.798]                       else if (inherits(cond, "warning")) {
[13:37:41.798]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:41.798]                         if (muffled) 
[13:37:41.798]                           invokeRestart("muffleWarning")
[13:37:41.798]                       }
[13:37:41.798]                       else if (inherits(cond, "condition")) {
[13:37:41.798]                         if (!is.null(pattern)) {
[13:37:41.798]                           computeRestarts <- base::computeRestarts
[13:37:41.798]                           grepl <- base::grepl
[13:37:41.798]                           restarts <- computeRestarts(cond)
[13:37:41.798]                           for (restart in restarts) {
[13:37:41.798]                             name <- restart$name
[13:37:41.798]                             if (is.null(name)) 
[13:37:41.798]                               next
[13:37:41.798]                             if (!grepl(pattern, name)) 
[13:37:41.798]                               next
[13:37:41.798]                             invokeRestart(restart)
[13:37:41.798]                             muffled <- TRUE
[13:37:41.798]                             break
[13:37:41.798]                           }
[13:37:41.798]                         }
[13:37:41.798]                       }
[13:37:41.798]                       invisible(muffled)
[13:37:41.798]                     }
[13:37:41.798]                     muffleCondition(cond, pattern = "^muffle")
[13:37:41.798]                   }
[13:37:41.798]                 }
[13:37:41.798]             }
[13:37:41.798]         }))
[13:37:41.798]     }, error = function(ex) {
[13:37:41.798]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:41.798]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:41.798]                 ...future.rng), started = ...future.startTime, 
[13:37:41.798]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:41.798]             version = "1.8"), class = "FutureResult")
[13:37:41.798]     }, finally = {
[13:37:41.798]         if (!identical(...future.workdir, getwd())) 
[13:37:41.798]             setwd(...future.workdir)
[13:37:41.798]         {
[13:37:41.798]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:41.798]                 ...future.oldOptions$nwarnings <- NULL
[13:37:41.798]             }
[13:37:41.798]             base::options(...future.oldOptions)
[13:37:41.798]             if (.Platform$OS.type == "windows") {
[13:37:41.798]                 old_names <- names(...future.oldEnvVars)
[13:37:41.798]                 envs <- base::Sys.getenv()
[13:37:41.798]                 names <- names(envs)
[13:37:41.798]                 common <- intersect(names, old_names)
[13:37:41.798]                 added <- setdiff(names, old_names)
[13:37:41.798]                 removed <- setdiff(old_names, names)
[13:37:41.798]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:41.798]                   envs[common]]
[13:37:41.798]                 NAMES <- toupper(changed)
[13:37:41.798]                 args <- list()
[13:37:41.798]                 for (kk in seq_along(NAMES)) {
[13:37:41.798]                   name <- changed[[kk]]
[13:37:41.798]                   NAME <- NAMES[[kk]]
[13:37:41.798]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:41.798]                     next
[13:37:41.798]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:41.798]                 }
[13:37:41.798]                 NAMES <- toupper(added)
[13:37:41.798]                 for (kk in seq_along(NAMES)) {
[13:37:41.798]                   name <- added[[kk]]
[13:37:41.798]                   NAME <- NAMES[[kk]]
[13:37:41.798]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:41.798]                     next
[13:37:41.798]                   args[[name]] <- ""
[13:37:41.798]                 }
[13:37:41.798]                 NAMES <- toupper(removed)
[13:37:41.798]                 for (kk in seq_along(NAMES)) {
[13:37:41.798]                   name <- removed[[kk]]
[13:37:41.798]                   NAME <- NAMES[[kk]]
[13:37:41.798]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:41.798]                     next
[13:37:41.798]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:41.798]                 }
[13:37:41.798]                 if (length(args) > 0) 
[13:37:41.798]                   base::do.call(base::Sys.setenv, args = args)
[13:37:41.798]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:41.798]             }
[13:37:41.798]             else {
[13:37:41.798]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:41.798]             }
[13:37:41.798]             {
[13:37:41.798]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:41.798]                   0L) {
[13:37:41.798]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:41.798]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:41.798]                   base::options(opts)
[13:37:41.798]                 }
[13:37:41.798]                 {
[13:37:41.798]                   {
[13:37:41.798]                     NULL
[13:37:41.798]                     RNGkind("Mersenne-Twister")
[13:37:41.798]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:37:41.798]                       inherits = FALSE)
[13:37:41.798]                   }
[13:37:41.798]                   options(future.plan = NULL)
[13:37:41.798]                   if (is.na(NA_character_)) 
[13:37:41.798]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:41.798]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:41.798]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:41.798]                     .init = FALSE)
[13:37:41.798]                 }
[13:37:41.798]             }
[13:37:41.798]         }
[13:37:41.798]     })
[13:37:41.798]     if (TRUE) {
[13:37:41.798]         base::sink(type = "output", split = FALSE)
[13:37:41.798]         if (TRUE) {
[13:37:41.798]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:41.798]         }
[13:37:41.798]         else {
[13:37:41.798]             ...future.result["stdout"] <- base::list(NULL)
[13:37:41.798]         }
[13:37:41.798]         base::close(...future.stdout)
[13:37:41.798]         ...future.stdout <- NULL
[13:37:41.798]     }
[13:37:41.798]     ...future.result$conditions <- ...future.conditions
[13:37:41.798]     ...future.result$finished <- base::Sys.time()
[13:37:41.798]     ...future.result
[13:37:41.798] }
[13:37:41.800] plan(): Setting new future strategy stack:
[13:37:41.800] List of future strategies:
[13:37:41.800] 1. sequential:
[13:37:41.800]    - args: function (..., envir = parent.frame())
[13:37:41.800]    - tweaked: FALSE
[13:37:41.800]    - call: NULL
[13:37:41.801] plan(): nbrOfWorkers() = 1
[13:37:41.802] plan(): Setting new future strategy stack:
[13:37:41.802] List of future strategies:
[13:37:41.802] 1. sequential:
[13:37:41.802]    - args: function (..., envir = parent.frame())
[13:37:41.802]    - tweaked: FALSE
[13:37:41.802]    - call: plan(strategy)
[13:37:41.802] plan(): nbrOfWorkers() = 1
[13:37:41.802] SequentialFuture started (and completed)
[13:37:41.802] - Launch lazy future ... done
[13:37:41.802] run() for ‘SequentialFuture’ ... done
[13:37:41.803] resolved() for ‘SequentialFuture’ ...
[13:37:41.803] - state: ‘finished’
[13:37:41.803] - run: TRUE
[13:37:41.803] - result: ‘FutureResult’
[13:37:41.803] resolved() for ‘SequentialFuture’ ... done
[13:37:41.803] Future #2
[13:37:41.803]  length: 1 (resolved future 2)
[13:37:41.803]  length: 0 (resolved future 3)
[13:37:41.803] resolve() on list ... DONE
[13:37:41.804] resolved() for ‘SequentialFuture’ ...
[13:37:41.804] - state: ‘finished’
[13:37:41.804] - run: TRUE
[13:37:41.804] - result: ‘FutureResult’
[13:37:41.804] resolved() for ‘SequentialFuture’ ... done
[13:37:41.804] resolved() for ‘SequentialFuture’ ...
[13:37:41.804] - state: ‘finished’
[13:37:41.804] - run: TRUE
[13:37:41.804] - result: ‘FutureResult’
[13:37:41.804] resolved() for ‘SequentialFuture’ ... done
[13:37:41.805] getGlobalsAndPackages() ...
[13:37:41.805] Searching for globals...
[13:37:41.805] 
[13:37:41.805] Searching for globals ... DONE
[13:37:41.805] - globals: [0] <none>
[13:37:41.805] getGlobalsAndPackages() ... DONE
[13:37:41.806] run() for ‘Future’ ...
[13:37:41.806] - state: ‘created’
[13:37:41.806] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:37:41.806] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:37:41.806] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:37:41.806]   - Field: ‘label’
[13:37:41.806]   - Field: ‘local’
[13:37:41.807]   - Field: ‘owner’
[13:37:41.807]   - Field: ‘envir’
[13:37:41.807]   - Field: ‘packages’
[13:37:41.807]   - Field: ‘gc’
[13:37:41.807]   - Field: ‘conditions’
[13:37:41.807]   - Field: ‘expr’
[13:37:41.807]   - Field: ‘uuid’
[13:37:41.807]   - Field: ‘seed’
[13:37:41.807]   - Field: ‘version’
[13:37:41.807]   - Field: ‘result’
[13:37:41.807]   - Field: ‘asynchronous’
[13:37:41.808]   - Field: ‘calls’
[13:37:41.808]   - Field: ‘globals’
[13:37:41.808]   - Field: ‘stdout’
[13:37:41.808]   - Field: ‘earlySignal’
[13:37:41.808]   - Field: ‘lazy’
[13:37:41.808]   - Field: ‘state’
[13:37:41.808] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:37:41.808] - Launch lazy future ...
[13:37:41.808] Packages needed by the future expression (n = 0): <none>
[13:37:41.808] Packages needed by future strategies (n = 0): <none>
[13:37:41.809] {
[13:37:41.809]     {
[13:37:41.809]         {
[13:37:41.809]             ...future.startTime <- base::Sys.time()
[13:37:41.809]             {
[13:37:41.809]                 {
[13:37:41.809]                   {
[13:37:41.809]                     base::local({
[13:37:41.809]                       has_future <- base::requireNamespace("future", 
[13:37:41.809]                         quietly = TRUE)
[13:37:41.809]                       if (has_future) {
[13:37:41.809]                         ns <- base::getNamespace("future")
[13:37:41.809]                         version <- ns[[".package"]][["version"]]
[13:37:41.809]                         if (is.null(version)) 
[13:37:41.809]                           version <- utils::packageVersion("future")
[13:37:41.809]                       }
[13:37:41.809]                       else {
[13:37:41.809]                         version <- NULL
[13:37:41.809]                       }
[13:37:41.809]                       if (!has_future || version < "1.8.0") {
[13:37:41.809]                         info <- base::c(r_version = base::gsub("R version ", 
[13:37:41.809]                           "", base::R.version$version.string), 
[13:37:41.809]                           platform = base::sprintf("%s (%s-bit)", 
[13:37:41.809]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:41.809]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:41.809]                             "release", "version")], collapse = " "), 
[13:37:41.809]                           hostname = base::Sys.info()[["nodename"]])
[13:37:41.809]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:37:41.809]                           info)
[13:37:41.809]                         info <- base::paste(info, collapse = "; ")
[13:37:41.809]                         if (!has_future) {
[13:37:41.809]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:41.809]                             info)
[13:37:41.809]                         }
[13:37:41.809]                         else {
[13:37:41.809]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:41.809]                             info, version)
[13:37:41.809]                         }
[13:37:41.809]                         base::stop(msg)
[13:37:41.809]                       }
[13:37:41.809]                     })
[13:37:41.809]                   }
[13:37:41.809]                   ...future.strategy.old <- future::plan("list")
[13:37:41.809]                   options(future.plan = NULL)
[13:37:41.809]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:41.809]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:41.809]                 }
[13:37:41.809]                 ...future.workdir <- getwd()
[13:37:41.809]             }
[13:37:41.809]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:41.809]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:41.809]         }
[13:37:41.809]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:41.809]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:41.809]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:41.809]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:41.809]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:41.809]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:41.809]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:41.809]             base::names(...future.oldOptions))
[13:37:41.809]     }
[13:37:41.809]     if (FALSE) {
[13:37:41.809]     }
[13:37:41.809]     else {
[13:37:41.809]         if (TRUE) {
[13:37:41.809]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:41.809]                 open = "w")
[13:37:41.809]         }
[13:37:41.809]         else {
[13:37:41.809]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:41.809]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:41.809]         }
[13:37:41.809]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:41.809]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:41.809]             base::sink(type = "output", split = FALSE)
[13:37:41.809]             base::close(...future.stdout)
[13:37:41.809]         }, add = TRUE)
[13:37:41.809]     }
[13:37:41.809]     ...future.frame <- base::sys.nframe()
[13:37:41.809]     ...future.conditions <- base::list()
[13:37:41.809]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:41.809]     if (FALSE) {
[13:37:41.809]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:41.809]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:41.809]     }
[13:37:41.809]     ...future.result <- base::tryCatch({
[13:37:41.809]         base::withCallingHandlers({
[13:37:41.809]             ...future.value <- base::withVisible(base::local(1))
[13:37:41.809]             future::FutureResult(value = ...future.value$value, 
[13:37:41.809]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:41.809]                   ...future.rng), globalenv = if (FALSE) 
[13:37:41.809]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:41.809]                     ...future.globalenv.names))
[13:37:41.809]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:41.809]         }, condition = base::local({
[13:37:41.809]             c <- base::c
[13:37:41.809]             inherits <- base::inherits
[13:37:41.809]             invokeRestart <- base::invokeRestart
[13:37:41.809]             length <- base::length
[13:37:41.809]             list <- base::list
[13:37:41.809]             seq.int <- base::seq.int
[13:37:41.809]             signalCondition <- base::signalCondition
[13:37:41.809]             sys.calls <- base::sys.calls
[13:37:41.809]             `[[` <- base::`[[`
[13:37:41.809]             `+` <- base::`+`
[13:37:41.809]             `<<-` <- base::`<<-`
[13:37:41.809]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:41.809]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:41.809]                   3L)]
[13:37:41.809]             }
[13:37:41.809]             function(cond) {
[13:37:41.809]                 is_error <- inherits(cond, "error")
[13:37:41.809]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:41.809]                   NULL)
[13:37:41.809]                 if (is_error) {
[13:37:41.809]                   sessionInformation <- function() {
[13:37:41.809]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:41.809]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:41.809]                       search = base::search(), system = base::Sys.info())
[13:37:41.809]                   }
[13:37:41.809]                   ...future.conditions[[length(...future.conditions) + 
[13:37:41.809]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:41.809]                     cond$call), session = sessionInformation(), 
[13:37:41.809]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:41.809]                   signalCondition(cond)
[13:37:41.809]                 }
[13:37:41.809]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:41.809]                 "immediateCondition"))) {
[13:37:41.809]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:41.809]                   ...future.conditions[[length(...future.conditions) + 
[13:37:41.809]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:41.809]                   if (TRUE && !signal) {
[13:37:41.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:41.809]                     {
[13:37:41.809]                       inherits <- base::inherits
[13:37:41.809]                       invokeRestart <- base::invokeRestart
[13:37:41.809]                       is.null <- base::is.null
[13:37:41.809]                       muffled <- FALSE
[13:37:41.809]                       if (inherits(cond, "message")) {
[13:37:41.809]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:41.809]                         if (muffled) 
[13:37:41.809]                           invokeRestart("muffleMessage")
[13:37:41.809]                       }
[13:37:41.809]                       else if (inherits(cond, "warning")) {
[13:37:41.809]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:41.809]                         if (muffled) 
[13:37:41.809]                           invokeRestart("muffleWarning")
[13:37:41.809]                       }
[13:37:41.809]                       else if (inherits(cond, "condition")) {
[13:37:41.809]                         if (!is.null(pattern)) {
[13:37:41.809]                           computeRestarts <- base::computeRestarts
[13:37:41.809]                           grepl <- base::grepl
[13:37:41.809]                           restarts <- computeRestarts(cond)
[13:37:41.809]                           for (restart in restarts) {
[13:37:41.809]                             name <- restart$name
[13:37:41.809]                             if (is.null(name)) 
[13:37:41.809]                               next
[13:37:41.809]                             if (!grepl(pattern, name)) 
[13:37:41.809]                               next
[13:37:41.809]                             invokeRestart(restart)
[13:37:41.809]                             muffled <- TRUE
[13:37:41.809]                             break
[13:37:41.809]                           }
[13:37:41.809]                         }
[13:37:41.809]                       }
[13:37:41.809]                       invisible(muffled)
[13:37:41.809]                     }
[13:37:41.809]                     muffleCondition(cond, pattern = "^muffle")
[13:37:41.809]                   }
[13:37:41.809]                 }
[13:37:41.809]                 else {
[13:37:41.809]                   if (TRUE) {
[13:37:41.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:41.809]                     {
[13:37:41.809]                       inherits <- base::inherits
[13:37:41.809]                       invokeRestart <- base::invokeRestart
[13:37:41.809]                       is.null <- base::is.null
[13:37:41.809]                       muffled <- FALSE
[13:37:41.809]                       if (inherits(cond, "message")) {
[13:37:41.809]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:41.809]                         if (muffled) 
[13:37:41.809]                           invokeRestart("muffleMessage")
[13:37:41.809]                       }
[13:37:41.809]                       else if (inherits(cond, "warning")) {
[13:37:41.809]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:41.809]                         if (muffled) 
[13:37:41.809]                           invokeRestart("muffleWarning")
[13:37:41.809]                       }
[13:37:41.809]                       else if (inherits(cond, "condition")) {
[13:37:41.809]                         if (!is.null(pattern)) {
[13:37:41.809]                           computeRestarts <- base::computeRestarts
[13:37:41.809]                           grepl <- base::grepl
[13:37:41.809]                           restarts <- computeRestarts(cond)
[13:37:41.809]                           for (restart in restarts) {
[13:37:41.809]                             name <- restart$name
[13:37:41.809]                             if (is.null(name)) 
[13:37:41.809]                               next
[13:37:41.809]                             if (!grepl(pattern, name)) 
[13:37:41.809]                               next
[13:37:41.809]                             invokeRestart(restart)
[13:37:41.809]                             muffled <- TRUE
[13:37:41.809]                             break
[13:37:41.809]                           }
[13:37:41.809]                         }
[13:37:41.809]                       }
[13:37:41.809]                       invisible(muffled)
[13:37:41.809]                     }
[13:37:41.809]                     muffleCondition(cond, pattern = "^muffle")
[13:37:41.809]                   }
[13:37:41.809]                 }
[13:37:41.809]             }
[13:37:41.809]         }))
[13:37:41.809]     }, error = function(ex) {
[13:37:41.809]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:41.809]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:41.809]                 ...future.rng), started = ...future.startTime, 
[13:37:41.809]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:41.809]             version = "1.8"), class = "FutureResult")
[13:37:41.809]     }, finally = {
[13:37:41.809]         if (!identical(...future.workdir, getwd())) 
[13:37:41.809]             setwd(...future.workdir)
[13:37:41.809]         {
[13:37:41.809]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:41.809]                 ...future.oldOptions$nwarnings <- NULL
[13:37:41.809]             }
[13:37:41.809]             base::options(...future.oldOptions)
[13:37:41.809]             if (.Platform$OS.type == "windows") {
[13:37:41.809]                 old_names <- names(...future.oldEnvVars)
[13:37:41.809]                 envs <- base::Sys.getenv()
[13:37:41.809]                 names <- names(envs)
[13:37:41.809]                 common <- intersect(names, old_names)
[13:37:41.809]                 added <- setdiff(names, old_names)
[13:37:41.809]                 removed <- setdiff(old_names, names)
[13:37:41.809]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:41.809]                   envs[common]]
[13:37:41.809]                 NAMES <- toupper(changed)
[13:37:41.809]                 args <- list()
[13:37:41.809]                 for (kk in seq_along(NAMES)) {
[13:37:41.809]                   name <- changed[[kk]]
[13:37:41.809]                   NAME <- NAMES[[kk]]
[13:37:41.809]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:41.809]                     next
[13:37:41.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:41.809]                 }
[13:37:41.809]                 NAMES <- toupper(added)
[13:37:41.809]                 for (kk in seq_along(NAMES)) {
[13:37:41.809]                   name <- added[[kk]]
[13:37:41.809]                   NAME <- NAMES[[kk]]
[13:37:41.809]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:41.809]                     next
[13:37:41.809]                   args[[name]] <- ""
[13:37:41.809]                 }
[13:37:41.809]                 NAMES <- toupper(removed)
[13:37:41.809]                 for (kk in seq_along(NAMES)) {
[13:37:41.809]                   name <- removed[[kk]]
[13:37:41.809]                   NAME <- NAMES[[kk]]
[13:37:41.809]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:41.809]                     next
[13:37:41.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:41.809]                 }
[13:37:41.809]                 if (length(args) > 0) 
[13:37:41.809]                   base::do.call(base::Sys.setenv, args = args)
[13:37:41.809]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:41.809]             }
[13:37:41.809]             else {
[13:37:41.809]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:41.809]             }
[13:37:41.809]             {
[13:37:41.809]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:41.809]                   0L) {
[13:37:41.809]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:41.809]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:41.809]                   base::options(opts)
[13:37:41.809]                 }
[13:37:41.809]                 {
[13:37:41.809]                   {
[13:37:41.809]                     NULL
[13:37:41.809]                     RNGkind("Mersenne-Twister")
[13:37:41.809]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:37:41.809]                       inherits = FALSE)
[13:37:41.809]                   }
[13:37:41.809]                   options(future.plan = NULL)
[13:37:41.809]                   if (is.na(NA_character_)) 
[13:37:41.809]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:41.809]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:41.809]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:41.809]                     .init = FALSE)
[13:37:41.809]                 }
[13:37:41.809]             }
[13:37:41.809]         }
[13:37:41.809]     })
[13:37:41.809]     if (TRUE) {
[13:37:41.809]         base::sink(type = "output", split = FALSE)
[13:37:41.809]         if (TRUE) {
[13:37:41.809]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:41.809]         }
[13:37:41.809]         else {
[13:37:41.809]             ...future.result["stdout"] <- base::list(NULL)
[13:37:41.809]         }
[13:37:41.809]         base::close(...future.stdout)
[13:37:41.809]         ...future.stdout <- NULL
[13:37:41.809]     }
[13:37:41.809]     ...future.result$conditions <- ...future.conditions
[13:37:41.809]     ...future.result$finished <- base::Sys.time()
[13:37:41.809]     ...future.result
[13:37:41.809] }
[13:37:41.811] plan(): Setting new future strategy stack:
[13:37:41.811] List of future strategies:
[13:37:41.811] 1. sequential:
[13:37:41.811]    - args: function (..., envir = parent.frame())
[13:37:41.811]    - tweaked: FALSE
[13:37:41.811]    - call: NULL
[13:37:41.811] plan(): nbrOfWorkers() = 1
[13:37:41.812] plan(): Setting new future strategy stack:
[13:37:41.812] List of future strategies:
[13:37:41.812] 1. sequential:
[13:37:41.812]    - args: function (..., envir = parent.frame())
[13:37:41.812]    - tweaked: FALSE
[13:37:41.812]    - call: plan(strategy)
[13:37:41.813] plan(): nbrOfWorkers() = 1
[13:37:41.813] SequentialFuture started (and completed)
[13:37:41.813] - Launch lazy future ... done
[13:37:41.813] run() for ‘SequentialFuture’ ... done
[13:37:41.813] getGlobalsAndPackages() ...
[13:37:41.813] Searching for globals...
[13:37:41.819] - globals found: [2] ‘{’, ‘Sys.sleep’
[13:37:41.819] Searching for globals ... DONE
[13:37:41.819] Resolving globals: FALSE
[13:37:41.819] 
[13:37:41.820] 
[13:37:41.820] getGlobalsAndPackages() ... DONE
[13:37:41.820] run() for ‘Future’ ...
[13:37:41.820] - state: ‘created’
[13:37:41.820] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:37:41.820] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:37:41.821] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:37:41.821]   - Field: ‘label’
[13:37:41.821]   - Field: ‘local’
[13:37:41.821]   - Field: ‘owner’
[13:37:41.821]   - Field: ‘envir’
[13:37:41.821]   - Field: ‘packages’
[13:37:41.821]   - Field: ‘gc’
[13:37:41.821]   - Field: ‘conditions’
[13:37:41.821]   - Field: ‘expr’
[13:37:41.821]   - Field: ‘uuid’
[13:37:41.822]   - Field: ‘seed’
[13:37:41.822]   - Field: ‘version’
[13:37:41.822]   - Field: ‘result’
[13:37:41.822]   - Field: ‘asynchronous’
[13:37:41.822]   - Field: ‘calls’
[13:37:41.822]   - Field: ‘globals’
[13:37:41.822]   - Field: ‘stdout’
[13:37:41.822]   - Field: ‘earlySignal’
[13:37:41.822]   - Field: ‘lazy’
[13:37:41.822]   - Field: ‘state’
[13:37:41.823] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:37:41.823] - Launch lazy future ...
[13:37:41.823] Packages needed by the future expression (n = 0): <none>
[13:37:41.823] Packages needed by future strategies (n = 0): <none>
[13:37:41.823] {
[13:37:41.823]     {
[13:37:41.823]         {
[13:37:41.823]             ...future.startTime <- base::Sys.time()
[13:37:41.823]             {
[13:37:41.823]                 {
[13:37:41.823]                   {
[13:37:41.823]                     base::local({
[13:37:41.823]                       has_future <- base::requireNamespace("future", 
[13:37:41.823]                         quietly = TRUE)
[13:37:41.823]                       if (has_future) {
[13:37:41.823]                         ns <- base::getNamespace("future")
[13:37:41.823]                         version <- ns[[".package"]][["version"]]
[13:37:41.823]                         if (is.null(version)) 
[13:37:41.823]                           version <- utils::packageVersion("future")
[13:37:41.823]                       }
[13:37:41.823]                       else {
[13:37:41.823]                         version <- NULL
[13:37:41.823]                       }
[13:37:41.823]                       if (!has_future || version < "1.8.0") {
[13:37:41.823]                         info <- base::c(r_version = base::gsub("R version ", 
[13:37:41.823]                           "", base::R.version$version.string), 
[13:37:41.823]                           platform = base::sprintf("%s (%s-bit)", 
[13:37:41.823]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:41.823]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:41.823]                             "release", "version")], collapse = " "), 
[13:37:41.823]                           hostname = base::Sys.info()[["nodename"]])
[13:37:41.823]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:37:41.823]                           info)
[13:37:41.823]                         info <- base::paste(info, collapse = "; ")
[13:37:41.823]                         if (!has_future) {
[13:37:41.823]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:41.823]                             info)
[13:37:41.823]                         }
[13:37:41.823]                         else {
[13:37:41.823]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:41.823]                             info, version)
[13:37:41.823]                         }
[13:37:41.823]                         base::stop(msg)
[13:37:41.823]                       }
[13:37:41.823]                     })
[13:37:41.823]                   }
[13:37:41.823]                   ...future.strategy.old <- future::plan("list")
[13:37:41.823]                   options(future.plan = NULL)
[13:37:41.823]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:41.823]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:41.823]                 }
[13:37:41.823]                 ...future.workdir <- getwd()
[13:37:41.823]             }
[13:37:41.823]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:41.823]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:41.823]         }
[13:37:41.823]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:41.823]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:41.823]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:41.823]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:41.823]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:41.823]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:41.823]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:41.823]             base::names(...future.oldOptions))
[13:37:41.823]     }
[13:37:41.823]     if (FALSE) {
[13:37:41.823]     }
[13:37:41.823]     else {
[13:37:41.823]         if (TRUE) {
[13:37:41.823]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:41.823]                 open = "w")
[13:37:41.823]         }
[13:37:41.823]         else {
[13:37:41.823]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:41.823]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:41.823]         }
[13:37:41.823]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:41.823]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:41.823]             base::sink(type = "output", split = FALSE)
[13:37:41.823]             base::close(...future.stdout)
[13:37:41.823]         }, add = TRUE)
[13:37:41.823]     }
[13:37:41.823]     ...future.frame <- base::sys.nframe()
[13:37:41.823]     ...future.conditions <- base::list()
[13:37:41.823]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:41.823]     if (FALSE) {
[13:37:41.823]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:41.823]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:41.823]     }
[13:37:41.823]     ...future.result <- base::tryCatch({
[13:37:41.823]         base::withCallingHandlers({
[13:37:41.823]             ...future.value <- base::withVisible(base::local({
[13:37:41.823]                 Sys.sleep(0.5)
[13:37:41.823]                 2
[13:37:41.823]             }))
[13:37:41.823]             future::FutureResult(value = ...future.value$value, 
[13:37:41.823]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:41.823]                   ...future.rng), globalenv = if (FALSE) 
[13:37:41.823]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:41.823]                     ...future.globalenv.names))
[13:37:41.823]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:41.823]         }, condition = base::local({
[13:37:41.823]             c <- base::c
[13:37:41.823]             inherits <- base::inherits
[13:37:41.823]             invokeRestart <- base::invokeRestart
[13:37:41.823]             length <- base::length
[13:37:41.823]             list <- base::list
[13:37:41.823]             seq.int <- base::seq.int
[13:37:41.823]             signalCondition <- base::signalCondition
[13:37:41.823]             sys.calls <- base::sys.calls
[13:37:41.823]             `[[` <- base::`[[`
[13:37:41.823]             `+` <- base::`+`
[13:37:41.823]             `<<-` <- base::`<<-`
[13:37:41.823]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:41.823]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:41.823]                   3L)]
[13:37:41.823]             }
[13:37:41.823]             function(cond) {
[13:37:41.823]                 is_error <- inherits(cond, "error")
[13:37:41.823]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:41.823]                   NULL)
[13:37:41.823]                 if (is_error) {
[13:37:41.823]                   sessionInformation <- function() {
[13:37:41.823]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:41.823]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:41.823]                       search = base::search(), system = base::Sys.info())
[13:37:41.823]                   }
[13:37:41.823]                   ...future.conditions[[length(...future.conditions) + 
[13:37:41.823]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:41.823]                     cond$call), session = sessionInformation(), 
[13:37:41.823]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:41.823]                   signalCondition(cond)
[13:37:41.823]                 }
[13:37:41.823]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:41.823]                 "immediateCondition"))) {
[13:37:41.823]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:41.823]                   ...future.conditions[[length(...future.conditions) + 
[13:37:41.823]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:41.823]                   if (TRUE && !signal) {
[13:37:41.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:41.823]                     {
[13:37:41.823]                       inherits <- base::inherits
[13:37:41.823]                       invokeRestart <- base::invokeRestart
[13:37:41.823]                       is.null <- base::is.null
[13:37:41.823]                       muffled <- FALSE
[13:37:41.823]                       if (inherits(cond, "message")) {
[13:37:41.823]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:41.823]                         if (muffled) 
[13:37:41.823]                           invokeRestart("muffleMessage")
[13:37:41.823]                       }
[13:37:41.823]                       else if (inherits(cond, "warning")) {
[13:37:41.823]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:41.823]                         if (muffled) 
[13:37:41.823]                           invokeRestart("muffleWarning")
[13:37:41.823]                       }
[13:37:41.823]                       else if (inherits(cond, "condition")) {
[13:37:41.823]                         if (!is.null(pattern)) {
[13:37:41.823]                           computeRestarts <- base::computeRestarts
[13:37:41.823]                           grepl <- base::grepl
[13:37:41.823]                           restarts <- computeRestarts(cond)
[13:37:41.823]                           for (restart in restarts) {
[13:37:41.823]                             name <- restart$name
[13:37:41.823]                             if (is.null(name)) 
[13:37:41.823]                               next
[13:37:41.823]                             if (!grepl(pattern, name)) 
[13:37:41.823]                               next
[13:37:41.823]                             invokeRestart(restart)
[13:37:41.823]                             muffled <- TRUE
[13:37:41.823]                             break
[13:37:41.823]                           }
[13:37:41.823]                         }
[13:37:41.823]                       }
[13:37:41.823]                       invisible(muffled)
[13:37:41.823]                     }
[13:37:41.823]                     muffleCondition(cond, pattern = "^muffle")
[13:37:41.823]                   }
[13:37:41.823]                 }
[13:37:41.823]                 else {
[13:37:41.823]                   if (TRUE) {
[13:37:41.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:41.823]                     {
[13:37:41.823]                       inherits <- base::inherits
[13:37:41.823]                       invokeRestart <- base::invokeRestart
[13:37:41.823]                       is.null <- base::is.null
[13:37:41.823]                       muffled <- FALSE
[13:37:41.823]                       if (inherits(cond, "message")) {
[13:37:41.823]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:41.823]                         if (muffled) 
[13:37:41.823]                           invokeRestart("muffleMessage")
[13:37:41.823]                       }
[13:37:41.823]                       else if (inherits(cond, "warning")) {
[13:37:41.823]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:41.823]                         if (muffled) 
[13:37:41.823]                           invokeRestart("muffleWarning")
[13:37:41.823]                       }
[13:37:41.823]                       else if (inherits(cond, "condition")) {
[13:37:41.823]                         if (!is.null(pattern)) {
[13:37:41.823]                           computeRestarts <- base::computeRestarts
[13:37:41.823]                           grepl <- base::grepl
[13:37:41.823]                           restarts <- computeRestarts(cond)
[13:37:41.823]                           for (restart in restarts) {
[13:37:41.823]                             name <- restart$name
[13:37:41.823]                             if (is.null(name)) 
[13:37:41.823]                               next
[13:37:41.823]                             if (!grepl(pattern, name)) 
[13:37:41.823]                               next
[13:37:41.823]                             invokeRestart(restart)
[13:37:41.823]                             muffled <- TRUE
[13:37:41.823]                             break
[13:37:41.823]                           }
[13:37:41.823]                         }
[13:37:41.823]                       }
[13:37:41.823]                       invisible(muffled)
[13:37:41.823]                     }
[13:37:41.823]                     muffleCondition(cond, pattern = "^muffle")
[13:37:41.823]                   }
[13:37:41.823]                 }
[13:37:41.823]             }
[13:37:41.823]         }))
[13:37:41.823]     }, error = function(ex) {
[13:37:41.823]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:41.823]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:41.823]                 ...future.rng), started = ...future.startTime, 
[13:37:41.823]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:41.823]             version = "1.8"), class = "FutureResult")
[13:37:41.823]     }, finally = {
[13:37:41.823]         if (!identical(...future.workdir, getwd())) 
[13:37:41.823]             setwd(...future.workdir)
[13:37:41.823]         {
[13:37:41.823]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:41.823]                 ...future.oldOptions$nwarnings <- NULL
[13:37:41.823]             }
[13:37:41.823]             base::options(...future.oldOptions)
[13:37:41.823]             if (.Platform$OS.type == "windows") {
[13:37:41.823]                 old_names <- names(...future.oldEnvVars)
[13:37:41.823]                 envs <- base::Sys.getenv()
[13:37:41.823]                 names <- names(envs)
[13:37:41.823]                 common <- intersect(names, old_names)
[13:37:41.823]                 added <- setdiff(names, old_names)
[13:37:41.823]                 removed <- setdiff(old_names, names)
[13:37:41.823]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:41.823]                   envs[common]]
[13:37:41.823]                 NAMES <- toupper(changed)
[13:37:41.823]                 args <- list()
[13:37:41.823]                 for (kk in seq_along(NAMES)) {
[13:37:41.823]                   name <- changed[[kk]]
[13:37:41.823]                   NAME <- NAMES[[kk]]
[13:37:41.823]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:41.823]                     next
[13:37:41.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:41.823]                 }
[13:37:41.823]                 NAMES <- toupper(added)
[13:37:41.823]                 for (kk in seq_along(NAMES)) {
[13:37:41.823]                   name <- added[[kk]]
[13:37:41.823]                   NAME <- NAMES[[kk]]
[13:37:41.823]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:41.823]                     next
[13:37:41.823]                   args[[name]] <- ""
[13:37:41.823]                 }
[13:37:41.823]                 NAMES <- toupper(removed)
[13:37:41.823]                 for (kk in seq_along(NAMES)) {
[13:37:41.823]                   name <- removed[[kk]]
[13:37:41.823]                   NAME <- NAMES[[kk]]
[13:37:41.823]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:41.823]                     next
[13:37:41.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:41.823]                 }
[13:37:41.823]                 if (length(args) > 0) 
[13:37:41.823]                   base::do.call(base::Sys.setenv, args = args)
[13:37:41.823]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:41.823]             }
[13:37:41.823]             else {
[13:37:41.823]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:41.823]             }
[13:37:41.823]             {
[13:37:41.823]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:41.823]                   0L) {
[13:37:41.823]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:41.823]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:41.823]                   base::options(opts)
[13:37:41.823]                 }
[13:37:41.823]                 {
[13:37:41.823]                   {
[13:37:41.823]                     NULL
[13:37:41.823]                     RNGkind("Mersenne-Twister")
[13:37:41.823]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:37:41.823]                       inherits = FALSE)
[13:37:41.823]                   }
[13:37:41.823]                   options(future.plan = NULL)
[13:37:41.823]                   if (is.na(NA_character_)) 
[13:37:41.823]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:41.823]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:41.823]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:41.823]                     .init = FALSE)
[13:37:41.823]                 }
[13:37:41.823]             }
[13:37:41.823]         }
[13:37:41.823]     })
[13:37:41.823]     if (TRUE) {
[13:37:41.823]         base::sink(type = "output", split = FALSE)
[13:37:41.823]         if (TRUE) {
[13:37:41.823]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:41.823]         }
[13:37:41.823]         else {
[13:37:41.823]             ...future.result["stdout"] <- base::list(NULL)
[13:37:41.823]         }
[13:37:41.823]         base::close(...future.stdout)
[13:37:41.823]         ...future.stdout <- NULL
[13:37:41.823]     }
[13:37:41.823]     ...future.result$conditions <- ...future.conditions
[13:37:41.823]     ...future.result$finished <- base::Sys.time()
[13:37:41.823]     ...future.result
[13:37:41.823] }
[13:37:41.825] plan(): Setting new future strategy stack:
[13:37:41.826] List of future strategies:
[13:37:41.826] 1. sequential:
[13:37:41.826]    - args: function (..., envir = parent.frame())
[13:37:41.826]    - tweaked: FALSE
[13:37:41.826]    - call: NULL
[13:37:41.826] plan(): nbrOfWorkers() = 1
[13:37:42.328] plan(): Setting new future strategy stack:
[13:37:42.328] List of future strategies:
[13:37:42.328] 1. sequential:
[13:37:42.328]    - args: function (..., envir = parent.frame())
[13:37:42.328]    - tweaked: FALSE
[13:37:42.328]    - call: plan(strategy)
[13:37:42.328] plan(): nbrOfWorkers() = 1
[13:37:42.329] SequentialFuture started (and completed)
[13:37:42.329] - Launch lazy future ... done
[13:37:42.329] run() for ‘SequentialFuture’ ... done
[13:37:42.329] resolve() on list ...
[13:37:42.330]  recursive: 0
[13:37:42.330]  length: 1
[13:37:42.330] 
[13:37:42.330] resolved() for ‘SequentialFuture’ ...
[13:37:42.330] - state: ‘finished’
[13:37:42.330] - run: TRUE
[13:37:42.330] - result: ‘FutureResult’
[13:37:42.330] resolved() for ‘SequentialFuture’ ... done
[13:37:42.330] Future #1
[13:37:42.330]  length: 0 (resolved future 1)
[13:37:42.331] resolve() on list ... DONE
[13:37:42.331] resolved() for ‘SequentialFuture’ ...
[13:37:42.331] - state: ‘finished’
[13:37:42.331] - run: TRUE
[13:37:42.331] - result: ‘FutureResult’
[13:37:42.331] resolved() for ‘SequentialFuture’ ... done
[13:37:42.331] resolve() on list ...
[13:37:42.331]  recursive: 0
[13:37:42.331]  length: 1
[13:37:42.331] 
[13:37:42.332] resolved() for ‘SequentialFuture’ ...
[13:37:42.332] - state: ‘finished’
[13:37:42.332] - run: TRUE
[13:37:42.332] - result: ‘FutureResult’
[13:37:42.332] resolved() for ‘SequentialFuture’ ... done
[13:37:42.332] Future #1
[13:37:42.332]  length: 0 (resolved future 1)
[13:37:42.332] resolve() on list ... DONE
[13:37:42.332] resolved() for ‘SequentialFuture’ ...
[13:37:42.332] - state: ‘finished’
[13:37:42.333] - run: TRUE
[13:37:42.333] - result: ‘FutureResult’
[13:37:42.333] resolved() for ‘SequentialFuture’ ... done
[13:37:42.333] resolve() on list ...
[13:37:42.333]  recursive: 0
[13:37:42.333]  length: 1
[13:37:42.333] 
[13:37:42.333]  length: 0 (resolved future 1)
[13:37:42.333] resolve() on list ... DONE
[13:37:42.333] resolve() on list ...
[13:37:42.334]  recursive: 0
[13:37:42.334]  length: 4
[13:37:42.334] 
[13:37:42.334] resolved() for ‘SequentialFuture’ ...
[13:37:42.336] - state: ‘finished’
[13:37:42.336] - run: TRUE
[13:37:42.336] - result: ‘FutureResult’
[13:37:42.337] resolved() for ‘SequentialFuture’ ... done
[13:37:42.337] Future #1
[13:37:42.337]  length: 3 (resolved future 1)
[13:37:42.337] resolved() for ‘SequentialFuture’ ...
[13:37:42.337] - state: ‘finished’
[13:37:42.337] - run: TRUE
[13:37:42.337] - result: ‘FutureResult’
[13:37:42.337] resolved() for ‘SequentialFuture’ ... done
[13:37:42.337] Future #2
[13:37:42.337]  length: 2 (resolved future 2)
[13:37:42.338]  length: 1 (resolved future 3)
[13:37:42.338]  length: 0 (resolved future 4)
[13:37:42.338] resolve() on list ... DONE
[13:37:42.338] resolve() on list ...
[13:37:42.338]  recursive: 0
[13:37:42.338]  length: 4
[13:37:42.338] 
[13:37:42.338] resolved() for ‘SequentialFuture’ ...
[13:37:42.338] - state: ‘finished’
[13:37:42.338] - run: TRUE
[13:37:42.339] - result: ‘FutureResult’
[13:37:42.339] resolved() for ‘SequentialFuture’ ... done
[13:37:42.339] Future #1
[13:37:42.339]  length: 3 (resolved future 1)
[13:37:42.339] resolved() for ‘SequentialFuture’ ...
[13:37:42.339] - state: ‘finished’
[13:37:42.339] - run: TRUE
[13:37:42.339] - result: ‘FutureResult’
[13:37:42.339] resolved() for ‘SequentialFuture’ ... done
[13:37:42.339] Future #2
[13:37:42.340]  length: 2 (resolved future 2)
[13:37:42.340]  length: 1 (resolved future 3)
[13:37:42.340]  length: 0 (resolved future 4)
[13:37:42.340] resolve() on list ... DONE
[13:37:42.340] resolve() on list ...
[13:37:42.340]  recursive: 0
[13:37:42.340]  length: 1
[13:37:42.340] 
[13:37:42.341]  length: 0 (resolved future 1)
[13:37:42.341] resolve() on list ... DONE
[13:37:42.341] getGlobalsAndPackages() ...
[13:37:42.341] Searching for globals...
[13:37:42.342] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:37:42.342] Searching for globals ... DONE
[13:37:42.342] Resolving globals: FALSE
[13:37:42.343] The total size of the 1 globals is 56 bytes (56 bytes)
[13:37:42.343] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:37:42.344] - globals: [1] ‘kk’
[13:37:42.344] 
[13:37:42.344] getGlobalsAndPackages() ... DONE
[13:37:42.344] run() for ‘Future’ ...
[13:37:42.344] - state: ‘created’
[13:37:42.344] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:37:42.345] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:37:42.345] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:37:42.345]   - Field: ‘label’
[13:37:42.345]   - Field: ‘local’
[13:37:42.345]   - Field: ‘owner’
[13:37:42.345]   - Field: ‘envir’
[13:37:42.345]   - Field: ‘packages’
[13:37:42.345]   - Field: ‘gc’
[13:37:42.345]   - Field: ‘conditions’
[13:37:42.345]   - Field: ‘expr’
[13:37:42.346]   - Field: ‘uuid’
[13:37:42.346]   - Field: ‘seed’
[13:37:42.346]   - Field: ‘version’
[13:37:42.346]   - Field: ‘result’
[13:37:42.346]   - Field: ‘asynchronous’
[13:37:42.346]   - Field: ‘calls’
[13:37:42.346]   - Field: ‘globals’
[13:37:42.346]   - Field: ‘stdout’
[13:37:42.346]   - Field: ‘earlySignal’
[13:37:42.346]   - Field: ‘lazy’
[13:37:42.347]   - Field: ‘state’
[13:37:42.347] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:37:42.347] - Launch lazy future ...
[13:37:42.347] Packages needed by the future expression (n = 0): <none>
[13:37:42.347] Packages needed by future strategies (n = 0): <none>
[13:37:42.348] {
[13:37:42.348]     {
[13:37:42.348]         {
[13:37:42.348]             ...future.startTime <- base::Sys.time()
[13:37:42.348]             {
[13:37:42.348]                 {
[13:37:42.348]                   {
[13:37:42.348]                     base::local({
[13:37:42.348]                       has_future <- base::requireNamespace("future", 
[13:37:42.348]                         quietly = TRUE)
[13:37:42.348]                       if (has_future) {
[13:37:42.348]                         ns <- base::getNamespace("future")
[13:37:42.348]                         version <- ns[[".package"]][["version"]]
[13:37:42.348]                         if (is.null(version)) 
[13:37:42.348]                           version <- utils::packageVersion("future")
[13:37:42.348]                       }
[13:37:42.348]                       else {
[13:37:42.348]                         version <- NULL
[13:37:42.348]                       }
[13:37:42.348]                       if (!has_future || version < "1.8.0") {
[13:37:42.348]                         info <- base::c(r_version = base::gsub("R version ", 
[13:37:42.348]                           "", base::R.version$version.string), 
[13:37:42.348]                           platform = base::sprintf("%s (%s-bit)", 
[13:37:42.348]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:42.348]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:42.348]                             "release", "version")], collapse = " "), 
[13:37:42.348]                           hostname = base::Sys.info()[["nodename"]])
[13:37:42.348]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:37:42.348]                           info)
[13:37:42.348]                         info <- base::paste(info, collapse = "; ")
[13:37:42.348]                         if (!has_future) {
[13:37:42.348]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:42.348]                             info)
[13:37:42.348]                         }
[13:37:42.348]                         else {
[13:37:42.348]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:42.348]                             info, version)
[13:37:42.348]                         }
[13:37:42.348]                         base::stop(msg)
[13:37:42.348]                       }
[13:37:42.348]                     })
[13:37:42.348]                   }
[13:37:42.348]                   ...future.strategy.old <- future::plan("list")
[13:37:42.348]                   options(future.plan = NULL)
[13:37:42.348]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:42.348]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:42.348]                 }
[13:37:42.348]                 ...future.workdir <- getwd()
[13:37:42.348]             }
[13:37:42.348]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:42.348]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:42.348]         }
[13:37:42.348]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:42.348]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:42.348]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:42.348]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:42.348]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:42.348]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:42.348]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:42.348]             base::names(...future.oldOptions))
[13:37:42.348]     }
[13:37:42.348]     if (FALSE) {
[13:37:42.348]     }
[13:37:42.348]     else {
[13:37:42.348]         if (TRUE) {
[13:37:42.348]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:42.348]                 open = "w")
[13:37:42.348]         }
[13:37:42.348]         else {
[13:37:42.348]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:42.348]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:42.348]         }
[13:37:42.348]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:42.348]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:42.348]             base::sink(type = "output", split = FALSE)
[13:37:42.348]             base::close(...future.stdout)
[13:37:42.348]         }, add = TRUE)
[13:37:42.348]     }
[13:37:42.348]     ...future.frame <- base::sys.nframe()
[13:37:42.348]     ...future.conditions <- base::list()
[13:37:42.348]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:42.348]     if (FALSE) {
[13:37:42.348]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:42.348]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:42.348]     }
[13:37:42.348]     ...future.result <- base::tryCatch({
[13:37:42.348]         base::withCallingHandlers({
[13:37:42.348]             ...future.value <- base::withVisible(base::local({
[13:37:42.348]                 Sys.sleep(0.1)
[13:37:42.348]                 kk
[13:37:42.348]             }))
[13:37:42.348]             future::FutureResult(value = ...future.value$value, 
[13:37:42.348]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:42.348]                   ...future.rng), globalenv = if (FALSE) 
[13:37:42.348]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:42.348]                     ...future.globalenv.names))
[13:37:42.348]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:42.348]         }, condition = base::local({
[13:37:42.348]             c <- base::c
[13:37:42.348]             inherits <- base::inherits
[13:37:42.348]             invokeRestart <- base::invokeRestart
[13:37:42.348]             length <- base::length
[13:37:42.348]             list <- base::list
[13:37:42.348]             seq.int <- base::seq.int
[13:37:42.348]             signalCondition <- base::signalCondition
[13:37:42.348]             sys.calls <- base::sys.calls
[13:37:42.348]             `[[` <- base::`[[`
[13:37:42.348]             `+` <- base::`+`
[13:37:42.348]             `<<-` <- base::`<<-`
[13:37:42.348]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:42.348]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:42.348]                   3L)]
[13:37:42.348]             }
[13:37:42.348]             function(cond) {
[13:37:42.348]                 is_error <- inherits(cond, "error")
[13:37:42.348]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:42.348]                   NULL)
[13:37:42.348]                 if (is_error) {
[13:37:42.348]                   sessionInformation <- function() {
[13:37:42.348]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:42.348]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:42.348]                       search = base::search(), system = base::Sys.info())
[13:37:42.348]                   }
[13:37:42.348]                   ...future.conditions[[length(...future.conditions) + 
[13:37:42.348]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:42.348]                     cond$call), session = sessionInformation(), 
[13:37:42.348]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:42.348]                   signalCondition(cond)
[13:37:42.348]                 }
[13:37:42.348]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:42.348]                 "immediateCondition"))) {
[13:37:42.348]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:42.348]                   ...future.conditions[[length(...future.conditions) + 
[13:37:42.348]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:42.348]                   if (TRUE && !signal) {
[13:37:42.348]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:42.348]                     {
[13:37:42.348]                       inherits <- base::inherits
[13:37:42.348]                       invokeRestart <- base::invokeRestart
[13:37:42.348]                       is.null <- base::is.null
[13:37:42.348]                       muffled <- FALSE
[13:37:42.348]                       if (inherits(cond, "message")) {
[13:37:42.348]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:42.348]                         if (muffled) 
[13:37:42.348]                           invokeRestart("muffleMessage")
[13:37:42.348]                       }
[13:37:42.348]                       else if (inherits(cond, "warning")) {
[13:37:42.348]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:42.348]                         if (muffled) 
[13:37:42.348]                           invokeRestart("muffleWarning")
[13:37:42.348]                       }
[13:37:42.348]                       else if (inherits(cond, "condition")) {
[13:37:42.348]                         if (!is.null(pattern)) {
[13:37:42.348]                           computeRestarts <- base::computeRestarts
[13:37:42.348]                           grepl <- base::grepl
[13:37:42.348]                           restarts <- computeRestarts(cond)
[13:37:42.348]                           for (restart in restarts) {
[13:37:42.348]                             name <- restart$name
[13:37:42.348]                             if (is.null(name)) 
[13:37:42.348]                               next
[13:37:42.348]                             if (!grepl(pattern, name)) 
[13:37:42.348]                               next
[13:37:42.348]                             invokeRestart(restart)
[13:37:42.348]                             muffled <- TRUE
[13:37:42.348]                             break
[13:37:42.348]                           }
[13:37:42.348]                         }
[13:37:42.348]                       }
[13:37:42.348]                       invisible(muffled)
[13:37:42.348]                     }
[13:37:42.348]                     muffleCondition(cond, pattern = "^muffle")
[13:37:42.348]                   }
[13:37:42.348]                 }
[13:37:42.348]                 else {
[13:37:42.348]                   if (TRUE) {
[13:37:42.348]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:42.348]                     {
[13:37:42.348]                       inherits <- base::inherits
[13:37:42.348]                       invokeRestart <- base::invokeRestart
[13:37:42.348]                       is.null <- base::is.null
[13:37:42.348]                       muffled <- FALSE
[13:37:42.348]                       if (inherits(cond, "message")) {
[13:37:42.348]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:42.348]                         if (muffled) 
[13:37:42.348]                           invokeRestart("muffleMessage")
[13:37:42.348]                       }
[13:37:42.348]                       else if (inherits(cond, "warning")) {
[13:37:42.348]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:42.348]                         if (muffled) 
[13:37:42.348]                           invokeRestart("muffleWarning")
[13:37:42.348]                       }
[13:37:42.348]                       else if (inherits(cond, "condition")) {
[13:37:42.348]                         if (!is.null(pattern)) {
[13:37:42.348]                           computeRestarts <- base::computeRestarts
[13:37:42.348]                           grepl <- base::grepl
[13:37:42.348]                           restarts <- computeRestarts(cond)
[13:37:42.348]                           for (restart in restarts) {
[13:37:42.348]                             name <- restart$name
[13:37:42.348]                             if (is.null(name)) 
[13:37:42.348]                               next
[13:37:42.348]                             if (!grepl(pattern, name)) 
[13:37:42.348]                               next
[13:37:42.348]                             invokeRestart(restart)
[13:37:42.348]                             muffled <- TRUE
[13:37:42.348]                             break
[13:37:42.348]                           }
[13:37:42.348]                         }
[13:37:42.348]                       }
[13:37:42.348]                       invisible(muffled)
[13:37:42.348]                     }
[13:37:42.348]                     muffleCondition(cond, pattern = "^muffle")
[13:37:42.348]                   }
[13:37:42.348]                 }
[13:37:42.348]             }
[13:37:42.348]         }))
[13:37:42.348]     }, error = function(ex) {
[13:37:42.348]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:42.348]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:42.348]                 ...future.rng), started = ...future.startTime, 
[13:37:42.348]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:42.348]             version = "1.8"), class = "FutureResult")
[13:37:42.348]     }, finally = {
[13:37:42.348]         if (!identical(...future.workdir, getwd())) 
[13:37:42.348]             setwd(...future.workdir)
[13:37:42.348]         {
[13:37:42.348]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:42.348]                 ...future.oldOptions$nwarnings <- NULL
[13:37:42.348]             }
[13:37:42.348]             base::options(...future.oldOptions)
[13:37:42.348]             if (.Platform$OS.type == "windows") {
[13:37:42.348]                 old_names <- names(...future.oldEnvVars)
[13:37:42.348]                 envs <- base::Sys.getenv()
[13:37:42.348]                 names <- names(envs)
[13:37:42.348]                 common <- intersect(names, old_names)
[13:37:42.348]                 added <- setdiff(names, old_names)
[13:37:42.348]                 removed <- setdiff(old_names, names)
[13:37:42.348]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:42.348]                   envs[common]]
[13:37:42.348]                 NAMES <- toupper(changed)
[13:37:42.348]                 args <- list()
[13:37:42.348]                 for (kk in seq_along(NAMES)) {
[13:37:42.348]                   name <- changed[[kk]]
[13:37:42.348]                   NAME <- NAMES[[kk]]
[13:37:42.348]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:42.348]                     next
[13:37:42.348]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:42.348]                 }
[13:37:42.348]                 NAMES <- toupper(added)
[13:37:42.348]                 for (kk in seq_along(NAMES)) {
[13:37:42.348]                   name <- added[[kk]]
[13:37:42.348]                   NAME <- NAMES[[kk]]
[13:37:42.348]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:42.348]                     next
[13:37:42.348]                   args[[name]] <- ""
[13:37:42.348]                 }
[13:37:42.348]                 NAMES <- toupper(removed)
[13:37:42.348]                 for (kk in seq_along(NAMES)) {
[13:37:42.348]                   name <- removed[[kk]]
[13:37:42.348]                   NAME <- NAMES[[kk]]
[13:37:42.348]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:42.348]                     next
[13:37:42.348]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:42.348]                 }
[13:37:42.348]                 if (length(args) > 0) 
[13:37:42.348]                   base::do.call(base::Sys.setenv, args = args)
[13:37:42.348]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:42.348]             }
[13:37:42.348]             else {
[13:37:42.348]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:42.348]             }
[13:37:42.348]             {
[13:37:42.348]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:42.348]                   0L) {
[13:37:42.348]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:42.348]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:42.348]                   base::options(opts)
[13:37:42.348]                 }
[13:37:42.348]                 {
[13:37:42.348]                   {
[13:37:42.348]                     NULL
[13:37:42.348]                     RNGkind("Mersenne-Twister")
[13:37:42.348]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:37:42.348]                       inherits = FALSE)
[13:37:42.348]                   }
[13:37:42.348]                   options(future.plan = NULL)
[13:37:42.348]                   if (is.na(NA_character_)) 
[13:37:42.348]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:42.348]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:42.348]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:42.348]                     .init = FALSE)
[13:37:42.348]                 }
[13:37:42.348]             }
[13:37:42.348]         }
[13:37:42.348]     })
[13:37:42.348]     if (TRUE) {
[13:37:42.348]         base::sink(type = "output", split = FALSE)
[13:37:42.348]         if (TRUE) {
[13:37:42.348]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:42.348]         }
[13:37:42.348]         else {
[13:37:42.348]             ...future.result["stdout"] <- base::list(NULL)
[13:37:42.348]         }
[13:37:42.348]         base::close(...future.stdout)
[13:37:42.348]         ...future.stdout <- NULL
[13:37:42.348]     }
[13:37:42.348]     ...future.result$conditions <- ...future.conditions
[13:37:42.348]     ...future.result$finished <- base::Sys.time()
[13:37:42.348]     ...future.result
[13:37:42.348] }
[13:37:42.349] assign_globals() ...
[13:37:42.350] List of 1
[13:37:42.350]  $ kk: int 1
[13:37:42.350]  - attr(*, "where")=List of 1
[13:37:42.350]   ..$ kk:<environment: R_EmptyEnv> 
[13:37:42.350]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:37:42.350]  - attr(*, "resolved")= logi FALSE
[13:37:42.350]  - attr(*, "total_size")= num 56
[13:37:42.350]  - attr(*, "already-done")= logi TRUE
[13:37:42.355] - copied ‘kk’ to environment
[13:37:42.355] assign_globals() ... done
[13:37:42.355] plan(): Setting new future strategy stack:
[13:37:42.355] List of future strategies:
[13:37:42.355] 1. sequential:
[13:37:42.355]    - args: function (..., envir = parent.frame())
[13:37:42.355]    - tweaked: FALSE
[13:37:42.355]    - call: NULL
[13:37:42.356] plan(): nbrOfWorkers() = 1
[13:37:42.457] plan(): Setting new future strategy stack:
[13:37:42.457] List of future strategies:
[13:37:42.457] 1. sequential:
[13:37:42.457]    - args: function (..., envir = parent.frame())
[13:37:42.457]    - tweaked: FALSE
[13:37:42.457]    - call: plan(strategy)
[13:37:42.457] plan(): nbrOfWorkers() = 1
[13:37:42.458] SequentialFuture started (and completed)
[13:37:42.458] - Launch lazy future ... done
[13:37:42.458] run() for ‘SequentialFuture’ ... done
[13:37:42.458] getGlobalsAndPackages() ...
[13:37:42.458] Searching for globals...
[13:37:42.459] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:37:42.459] Searching for globals ... DONE
[13:37:42.460] Resolving globals: FALSE
[13:37:42.460] The total size of the 1 globals is 56 bytes (56 bytes)
[13:37:42.460] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:37:42.460] - globals: [1] ‘kk’
[13:37:42.460] 
[13:37:42.461] getGlobalsAndPackages() ... DONE
[13:37:42.461] run() for ‘Future’ ...
[13:37:42.461] - state: ‘created’
[13:37:42.461] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:37:42.461] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:37:42.461] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:37:42.462]   - Field: ‘label’
[13:37:42.462]   - Field: ‘local’
[13:37:42.462]   - Field: ‘owner’
[13:37:42.462]   - Field: ‘envir’
[13:37:42.462]   - Field: ‘packages’
[13:37:42.462]   - Field: ‘gc’
[13:37:42.462]   - Field: ‘conditions’
[13:37:42.462]   - Field: ‘expr’
[13:37:42.462]   - Field: ‘uuid’
[13:37:42.462]   - Field: ‘seed’
[13:37:42.463]   - Field: ‘version’
[13:37:42.463]   - Field: ‘result’
[13:37:42.463]   - Field: ‘asynchronous’
[13:37:42.463]   - Field: ‘calls’
[13:37:42.463]   - Field: ‘globals’
[13:37:42.463]   - Field: ‘stdout’
[13:37:42.463]   - Field: ‘earlySignal’
[13:37:42.463]   - Field: ‘lazy’
[13:37:42.463]   - Field: ‘state’
[13:37:42.463] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:37:42.463] - Launch lazy future ...
[13:37:42.464] Packages needed by the future expression (n = 0): <none>
[13:37:42.464] Packages needed by future strategies (n = 0): <none>
[13:37:42.464] {
[13:37:42.464]     {
[13:37:42.464]         {
[13:37:42.464]             ...future.startTime <- base::Sys.time()
[13:37:42.464]             {
[13:37:42.464]                 {
[13:37:42.464]                   {
[13:37:42.464]                     base::local({
[13:37:42.464]                       has_future <- base::requireNamespace("future", 
[13:37:42.464]                         quietly = TRUE)
[13:37:42.464]                       if (has_future) {
[13:37:42.464]                         ns <- base::getNamespace("future")
[13:37:42.464]                         version <- ns[[".package"]][["version"]]
[13:37:42.464]                         if (is.null(version)) 
[13:37:42.464]                           version <- utils::packageVersion("future")
[13:37:42.464]                       }
[13:37:42.464]                       else {
[13:37:42.464]                         version <- NULL
[13:37:42.464]                       }
[13:37:42.464]                       if (!has_future || version < "1.8.0") {
[13:37:42.464]                         info <- base::c(r_version = base::gsub("R version ", 
[13:37:42.464]                           "", base::R.version$version.string), 
[13:37:42.464]                           platform = base::sprintf("%s (%s-bit)", 
[13:37:42.464]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:42.464]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:42.464]                             "release", "version")], collapse = " "), 
[13:37:42.464]                           hostname = base::Sys.info()[["nodename"]])
[13:37:42.464]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:37:42.464]                           info)
[13:37:42.464]                         info <- base::paste(info, collapse = "; ")
[13:37:42.464]                         if (!has_future) {
[13:37:42.464]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:42.464]                             info)
[13:37:42.464]                         }
[13:37:42.464]                         else {
[13:37:42.464]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:42.464]                             info, version)
[13:37:42.464]                         }
[13:37:42.464]                         base::stop(msg)
[13:37:42.464]                       }
[13:37:42.464]                     })
[13:37:42.464]                   }
[13:37:42.464]                   ...future.strategy.old <- future::plan("list")
[13:37:42.464]                   options(future.plan = NULL)
[13:37:42.464]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:42.464]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:42.464]                 }
[13:37:42.464]                 ...future.workdir <- getwd()
[13:37:42.464]             }
[13:37:42.464]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:42.464]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:42.464]         }
[13:37:42.464]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:42.464]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:42.464]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:42.464]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:42.464]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:42.464]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:42.464]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:42.464]             base::names(...future.oldOptions))
[13:37:42.464]     }
[13:37:42.464]     if (FALSE) {
[13:37:42.464]     }
[13:37:42.464]     else {
[13:37:42.464]         if (TRUE) {
[13:37:42.464]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:42.464]                 open = "w")
[13:37:42.464]         }
[13:37:42.464]         else {
[13:37:42.464]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:42.464]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:42.464]         }
[13:37:42.464]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:42.464]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:42.464]             base::sink(type = "output", split = FALSE)
[13:37:42.464]             base::close(...future.stdout)
[13:37:42.464]         }, add = TRUE)
[13:37:42.464]     }
[13:37:42.464]     ...future.frame <- base::sys.nframe()
[13:37:42.464]     ...future.conditions <- base::list()
[13:37:42.464]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:42.464]     if (FALSE) {
[13:37:42.464]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:42.464]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:42.464]     }
[13:37:42.464]     ...future.result <- base::tryCatch({
[13:37:42.464]         base::withCallingHandlers({
[13:37:42.464]             ...future.value <- base::withVisible(base::local({
[13:37:42.464]                 Sys.sleep(0.1)
[13:37:42.464]                 kk
[13:37:42.464]             }))
[13:37:42.464]             future::FutureResult(value = ...future.value$value, 
[13:37:42.464]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:42.464]                   ...future.rng), globalenv = if (FALSE) 
[13:37:42.464]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:42.464]                     ...future.globalenv.names))
[13:37:42.464]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:42.464]         }, condition = base::local({
[13:37:42.464]             c <- base::c
[13:37:42.464]             inherits <- base::inherits
[13:37:42.464]             invokeRestart <- base::invokeRestart
[13:37:42.464]             length <- base::length
[13:37:42.464]             list <- base::list
[13:37:42.464]             seq.int <- base::seq.int
[13:37:42.464]             signalCondition <- base::signalCondition
[13:37:42.464]             sys.calls <- base::sys.calls
[13:37:42.464]             `[[` <- base::`[[`
[13:37:42.464]             `+` <- base::`+`
[13:37:42.464]             `<<-` <- base::`<<-`
[13:37:42.464]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:42.464]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:42.464]                   3L)]
[13:37:42.464]             }
[13:37:42.464]             function(cond) {
[13:37:42.464]                 is_error <- inherits(cond, "error")
[13:37:42.464]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:42.464]                   NULL)
[13:37:42.464]                 if (is_error) {
[13:37:42.464]                   sessionInformation <- function() {
[13:37:42.464]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:42.464]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:42.464]                       search = base::search(), system = base::Sys.info())
[13:37:42.464]                   }
[13:37:42.464]                   ...future.conditions[[length(...future.conditions) + 
[13:37:42.464]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:42.464]                     cond$call), session = sessionInformation(), 
[13:37:42.464]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:42.464]                   signalCondition(cond)
[13:37:42.464]                 }
[13:37:42.464]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:42.464]                 "immediateCondition"))) {
[13:37:42.464]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:42.464]                   ...future.conditions[[length(...future.conditions) + 
[13:37:42.464]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:42.464]                   if (TRUE && !signal) {
[13:37:42.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:42.464]                     {
[13:37:42.464]                       inherits <- base::inherits
[13:37:42.464]                       invokeRestart <- base::invokeRestart
[13:37:42.464]                       is.null <- base::is.null
[13:37:42.464]                       muffled <- FALSE
[13:37:42.464]                       if (inherits(cond, "message")) {
[13:37:42.464]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:42.464]                         if (muffled) 
[13:37:42.464]                           invokeRestart("muffleMessage")
[13:37:42.464]                       }
[13:37:42.464]                       else if (inherits(cond, "warning")) {
[13:37:42.464]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:42.464]                         if (muffled) 
[13:37:42.464]                           invokeRestart("muffleWarning")
[13:37:42.464]                       }
[13:37:42.464]                       else if (inherits(cond, "condition")) {
[13:37:42.464]                         if (!is.null(pattern)) {
[13:37:42.464]                           computeRestarts <- base::computeRestarts
[13:37:42.464]                           grepl <- base::grepl
[13:37:42.464]                           restarts <- computeRestarts(cond)
[13:37:42.464]                           for (restart in restarts) {
[13:37:42.464]                             name <- restart$name
[13:37:42.464]                             if (is.null(name)) 
[13:37:42.464]                               next
[13:37:42.464]                             if (!grepl(pattern, name)) 
[13:37:42.464]                               next
[13:37:42.464]                             invokeRestart(restart)
[13:37:42.464]                             muffled <- TRUE
[13:37:42.464]                             break
[13:37:42.464]                           }
[13:37:42.464]                         }
[13:37:42.464]                       }
[13:37:42.464]                       invisible(muffled)
[13:37:42.464]                     }
[13:37:42.464]                     muffleCondition(cond, pattern = "^muffle")
[13:37:42.464]                   }
[13:37:42.464]                 }
[13:37:42.464]                 else {
[13:37:42.464]                   if (TRUE) {
[13:37:42.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:42.464]                     {
[13:37:42.464]                       inherits <- base::inherits
[13:37:42.464]                       invokeRestart <- base::invokeRestart
[13:37:42.464]                       is.null <- base::is.null
[13:37:42.464]                       muffled <- FALSE
[13:37:42.464]                       if (inherits(cond, "message")) {
[13:37:42.464]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:42.464]                         if (muffled) 
[13:37:42.464]                           invokeRestart("muffleMessage")
[13:37:42.464]                       }
[13:37:42.464]                       else if (inherits(cond, "warning")) {
[13:37:42.464]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:42.464]                         if (muffled) 
[13:37:42.464]                           invokeRestart("muffleWarning")
[13:37:42.464]                       }
[13:37:42.464]                       else if (inherits(cond, "condition")) {
[13:37:42.464]                         if (!is.null(pattern)) {
[13:37:42.464]                           computeRestarts <- base::computeRestarts
[13:37:42.464]                           grepl <- base::grepl
[13:37:42.464]                           restarts <- computeRestarts(cond)
[13:37:42.464]                           for (restart in restarts) {
[13:37:42.464]                             name <- restart$name
[13:37:42.464]                             if (is.null(name)) 
[13:37:42.464]                               next
[13:37:42.464]                             if (!grepl(pattern, name)) 
[13:37:42.464]                               next
[13:37:42.464]                             invokeRestart(restart)
[13:37:42.464]                             muffled <- TRUE
[13:37:42.464]                             break
[13:37:42.464]                           }
[13:37:42.464]                         }
[13:37:42.464]                       }
[13:37:42.464]                       invisible(muffled)
[13:37:42.464]                     }
[13:37:42.464]                     muffleCondition(cond, pattern = "^muffle")
[13:37:42.464]                   }
[13:37:42.464]                 }
[13:37:42.464]             }
[13:37:42.464]         }))
[13:37:42.464]     }, error = function(ex) {
[13:37:42.464]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:42.464]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:42.464]                 ...future.rng), started = ...future.startTime, 
[13:37:42.464]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:42.464]             version = "1.8"), class = "FutureResult")
[13:37:42.464]     }, finally = {
[13:37:42.464]         if (!identical(...future.workdir, getwd())) 
[13:37:42.464]             setwd(...future.workdir)
[13:37:42.464]         {
[13:37:42.464]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:42.464]                 ...future.oldOptions$nwarnings <- NULL
[13:37:42.464]             }
[13:37:42.464]             base::options(...future.oldOptions)
[13:37:42.464]             if (.Platform$OS.type == "windows") {
[13:37:42.464]                 old_names <- names(...future.oldEnvVars)
[13:37:42.464]                 envs <- base::Sys.getenv()
[13:37:42.464]                 names <- names(envs)
[13:37:42.464]                 common <- intersect(names, old_names)
[13:37:42.464]                 added <- setdiff(names, old_names)
[13:37:42.464]                 removed <- setdiff(old_names, names)
[13:37:42.464]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:42.464]                   envs[common]]
[13:37:42.464]                 NAMES <- toupper(changed)
[13:37:42.464]                 args <- list()
[13:37:42.464]                 for (kk in seq_along(NAMES)) {
[13:37:42.464]                   name <- changed[[kk]]
[13:37:42.464]                   NAME <- NAMES[[kk]]
[13:37:42.464]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:42.464]                     next
[13:37:42.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:42.464]                 }
[13:37:42.464]                 NAMES <- toupper(added)
[13:37:42.464]                 for (kk in seq_along(NAMES)) {
[13:37:42.464]                   name <- added[[kk]]
[13:37:42.464]                   NAME <- NAMES[[kk]]
[13:37:42.464]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:42.464]                     next
[13:37:42.464]                   args[[name]] <- ""
[13:37:42.464]                 }
[13:37:42.464]                 NAMES <- toupper(removed)
[13:37:42.464]                 for (kk in seq_along(NAMES)) {
[13:37:42.464]                   name <- removed[[kk]]
[13:37:42.464]                   NAME <- NAMES[[kk]]
[13:37:42.464]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:42.464]                     next
[13:37:42.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:42.464]                 }
[13:37:42.464]                 if (length(args) > 0) 
[13:37:42.464]                   base::do.call(base::Sys.setenv, args = args)
[13:37:42.464]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:42.464]             }
[13:37:42.464]             else {
[13:37:42.464]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:42.464]             }
[13:37:42.464]             {
[13:37:42.464]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:42.464]                   0L) {
[13:37:42.464]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:42.464]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:42.464]                   base::options(opts)
[13:37:42.464]                 }
[13:37:42.464]                 {
[13:37:42.464]                   {
[13:37:42.464]                     NULL
[13:37:42.464]                     RNGkind("Mersenne-Twister")
[13:37:42.464]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:37:42.464]                       inherits = FALSE)
[13:37:42.464]                   }
[13:37:42.464]                   options(future.plan = NULL)
[13:37:42.464]                   if (is.na(NA_character_)) 
[13:37:42.464]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:42.464]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:42.464]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:42.464]                     .init = FALSE)
[13:37:42.464]                 }
[13:37:42.464]             }
[13:37:42.464]         }
[13:37:42.464]     })
[13:37:42.464]     if (TRUE) {
[13:37:42.464]         base::sink(type = "output", split = FALSE)
[13:37:42.464]         if (TRUE) {
[13:37:42.464]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:42.464]         }
[13:37:42.464]         else {
[13:37:42.464]             ...future.result["stdout"] <- base::list(NULL)
[13:37:42.464]         }
[13:37:42.464]         base::close(...future.stdout)
[13:37:42.464]         ...future.stdout <- NULL
[13:37:42.464]     }
[13:37:42.464]     ...future.result$conditions <- ...future.conditions
[13:37:42.464]     ...future.result$finished <- base::Sys.time()
[13:37:42.464]     ...future.result
[13:37:42.464] }
[13:37:42.466] assign_globals() ...
[13:37:42.466] List of 1
[13:37:42.466]  $ kk: int 2
[13:37:42.466]  - attr(*, "where")=List of 1
[13:37:42.466]   ..$ kk:<environment: R_EmptyEnv> 
[13:37:42.466]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:37:42.466]  - attr(*, "resolved")= logi FALSE
[13:37:42.466]  - attr(*, "total_size")= num 56
[13:37:42.466]  - attr(*, "already-done")= logi TRUE
[13:37:42.471] - copied ‘kk’ to environment
[13:37:42.471] assign_globals() ... done
[13:37:42.471] plan(): Setting new future strategy stack:
[13:37:42.471] List of future strategies:
[13:37:42.471] 1. sequential:
[13:37:42.471]    - args: function (..., envir = parent.frame())
[13:37:42.471]    - tweaked: FALSE
[13:37:42.471]    - call: NULL
[13:37:42.472] plan(): nbrOfWorkers() = 1
[13:37:42.573] plan(): Setting new future strategy stack:
[13:37:42.573] List of future strategies:
[13:37:42.573] 1. sequential:
[13:37:42.573]    - args: function (..., envir = parent.frame())
[13:37:42.573]    - tweaked: FALSE
[13:37:42.573]    - call: plan(strategy)
[13:37:42.574] plan(): nbrOfWorkers() = 1
[13:37:42.574] SequentialFuture started (and completed)
[13:37:42.574] - Launch lazy future ... done
[13:37:42.574] run() for ‘SequentialFuture’ ... done
[13:37:42.574] getGlobalsAndPackages() ...
[13:37:42.574] Searching for globals...
[13:37:42.576] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:37:42.576] Searching for globals ... DONE
[13:37:42.576] Resolving globals: FALSE
[13:37:42.576] The total size of the 1 globals is 56 bytes (56 bytes)
[13:37:42.577] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:37:42.577] - globals: [1] ‘kk’
[13:37:42.577] 
[13:37:42.577] getGlobalsAndPackages() ... DONE
[13:37:42.577] run() for ‘Future’ ...
[13:37:42.577] - state: ‘created’
[13:37:42.577] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:37:42.578] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:37:42.578] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:37:42.578]   - Field: ‘label’
[13:37:42.578]   - Field: ‘local’
[13:37:42.578]   - Field: ‘owner’
[13:37:42.578]   - Field: ‘envir’
[13:37:42.578]   - Field: ‘packages’
[13:37:42.578]   - Field: ‘gc’
[13:37:42.578]   - Field: ‘conditions’
[13:37:42.579]   - Field: ‘expr’
[13:37:42.579]   - Field: ‘uuid’
[13:37:42.579]   - Field: ‘seed’
[13:37:42.579]   - Field: ‘version’
[13:37:42.579]   - Field: ‘result’
[13:37:42.579]   - Field: ‘asynchronous’
[13:37:42.579]   - Field: ‘calls’
[13:37:42.579]   - Field: ‘globals’
[13:37:42.579]   - Field: ‘stdout’
[13:37:42.579]   - Field: ‘earlySignal’
[13:37:42.580]   - Field: ‘lazy’
[13:37:42.580]   - Field: ‘state’
[13:37:42.580] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:37:42.580] - Launch lazy future ...
[13:37:42.580] Packages needed by the future expression (n = 0): <none>
[13:37:42.580] Packages needed by future strategies (n = 0): <none>
[13:37:42.581] {
[13:37:42.581]     {
[13:37:42.581]         {
[13:37:42.581]             ...future.startTime <- base::Sys.time()
[13:37:42.581]             {
[13:37:42.581]                 {
[13:37:42.581]                   {
[13:37:42.581]                     base::local({
[13:37:42.581]                       has_future <- base::requireNamespace("future", 
[13:37:42.581]                         quietly = TRUE)
[13:37:42.581]                       if (has_future) {
[13:37:42.581]                         ns <- base::getNamespace("future")
[13:37:42.581]                         version <- ns[[".package"]][["version"]]
[13:37:42.581]                         if (is.null(version)) 
[13:37:42.581]                           version <- utils::packageVersion("future")
[13:37:42.581]                       }
[13:37:42.581]                       else {
[13:37:42.581]                         version <- NULL
[13:37:42.581]                       }
[13:37:42.581]                       if (!has_future || version < "1.8.0") {
[13:37:42.581]                         info <- base::c(r_version = base::gsub("R version ", 
[13:37:42.581]                           "", base::R.version$version.string), 
[13:37:42.581]                           platform = base::sprintf("%s (%s-bit)", 
[13:37:42.581]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:42.581]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:42.581]                             "release", "version")], collapse = " "), 
[13:37:42.581]                           hostname = base::Sys.info()[["nodename"]])
[13:37:42.581]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:37:42.581]                           info)
[13:37:42.581]                         info <- base::paste(info, collapse = "; ")
[13:37:42.581]                         if (!has_future) {
[13:37:42.581]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:42.581]                             info)
[13:37:42.581]                         }
[13:37:42.581]                         else {
[13:37:42.581]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:42.581]                             info, version)
[13:37:42.581]                         }
[13:37:42.581]                         base::stop(msg)
[13:37:42.581]                       }
[13:37:42.581]                     })
[13:37:42.581]                   }
[13:37:42.581]                   ...future.strategy.old <- future::plan("list")
[13:37:42.581]                   options(future.plan = NULL)
[13:37:42.581]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:42.581]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:42.581]                 }
[13:37:42.581]                 ...future.workdir <- getwd()
[13:37:42.581]             }
[13:37:42.581]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:42.581]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:42.581]         }
[13:37:42.581]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:42.581]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:42.581]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:42.581]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:42.581]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:42.581]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:42.581]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:42.581]             base::names(...future.oldOptions))
[13:37:42.581]     }
[13:37:42.581]     if (FALSE) {
[13:37:42.581]     }
[13:37:42.581]     else {
[13:37:42.581]         if (TRUE) {
[13:37:42.581]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:42.581]                 open = "w")
[13:37:42.581]         }
[13:37:42.581]         else {
[13:37:42.581]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:42.581]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:42.581]         }
[13:37:42.581]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:42.581]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:42.581]             base::sink(type = "output", split = FALSE)
[13:37:42.581]             base::close(...future.stdout)
[13:37:42.581]         }, add = TRUE)
[13:37:42.581]     }
[13:37:42.581]     ...future.frame <- base::sys.nframe()
[13:37:42.581]     ...future.conditions <- base::list()
[13:37:42.581]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:42.581]     if (FALSE) {
[13:37:42.581]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:42.581]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:42.581]     }
[13:37:42.581]     ...future.result <- base::tryCatch({
[13:37:42.581]         base::withCallingHandlers({
[13:37:42.581]             ...future.value <- base::withVisible(base::local({
[13:37:42.581]                 Sys.sleep(0.1)
[13:37:42.581]                 kk
[13:37:42.581]             }))
[13:37:42.581]             future::FutureResult(value = ...future.value$value, 
[13:37:42.581]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:42.581]                   ...future.rng), globalenv = if (FALSE) 
[13:37:42.581]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:42.581]                     ...future.globalenv.names))
[13:37:42.581]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:42.581]         }, condition = base::local({
[13:37:42.581]             c <- base::c
[13:37:42.581]             inherits <- base::inherits
[13:37:42.581]             invokeRestart <- base::invokeRestart
[13:37:42.581]             length <- base::length
[13:37:42.581]             list <- base::list
[13:37:42.581]             seq.int <- base::seq.int
[13:37:42.581]             signalCondition <- base::signalCondition
[13:37:42.581]             sys.calls <- base::sys.calls
[13:37:42.581]             `[[` <- base::`[[`
[13:37:42.581]             `+` <- base::`+`
[13:37:42.581]             `<<-` <- base::`<<-`
[13:37:42.581]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:42.581]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:42.581]                   3L)]
[13:37:42.581]             }
[13:37:42.581]             function(cond) {
[13:37:42.581]                 is_error <- inherits(cond, "error")
[13:37:42.581]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:42.581]                   NULL)
[13:37:42.581]                 if (is_error) {
[13:37:42.581]                   sessionInformation <- function() {
[13:37:42.581]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:42.581]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:42.581]                       search = base::search(), system = base::Sys.info())
[13:37:42.581]                   }
[13:37:42.581]                   ...future.conditions[[length(...future.conditions) + 
[13:37:42.581]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:42.581]                     cond$call), session = sessionInformation(), 
[13:37:42.581]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:42.581]                   signalCondition(cond)
[13:37:42.581]                 }
[13:37:42.581]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:42.581]                 "immediateCondition"))) {
[13:37:42.581]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:42.581]                   ...future.conditions[[length(...future.conditions) + 
[13:37:42.581]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:42.581]                   if (TRUE && !signal) {
[13:37:42.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:42.581]                     {
[13:37:42.581]                       inherits <- base::inherits
[13:37:42.581]                       invokeRestart <- base::invokeRestart
[13:37:42.581]                       is.null <- base::is.null
[13:37:42.581]                       muffled <- FALSE
[13:37:42.581]                       if (inherits(cond, "message")) {
[13:37:42.581]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:42.581]                         if (muffled) 
[13:37:42.581]                           invokeRestart("muffleMessage")
[13:37:42.581]                       }
[13:37:42.581]                       else if (inherits(cond, "warning")) {
[13:37:42.581]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:42.581]                         if (muffled) 
[13:37:42.581]                           invokeRestart("muffleWarning")
[13:37:42.581]                       }
[13:37:42.581]                       else if (inherits(cond, "condition")) {
[13:37:42.581]                         if (!is.null(pattern)) {
[13:37:42.581]                           computeRestarts <- base::computeRestarts
[13:37:42.581]                           grepl <- base::grepl
[13:37:42.581]                           restarts <- computeRestarts(cond)
[13:37:42.581]                           for (restart in restarts) {
[13:37:42.581]                             name <- restart$name
[13:37:42.581]                             if (is.null(name)) 
[13:37:42.581]                               next
[13:37:42.581]                             if (!grepl(pattern, name)) 
[13:37:42.581]                               next
[13:37:42.581]                             invokeRestart(restart)
[13:37:42.581]                             muffled <- TRUE
[13:37:42.581]                             break
[13:37:42.581]                           }
[13:37:42.581]                         }
[13:37:42.581]                       }
[13:37:42.581]                       invisible(muffled)
[13:37:42.581]                     }
[13:37:42.581]                     muffleCondition(cond, pattern = "^muffle")
[13:37:42.581]                   }
[13:37:42.581]                 }
[13:37:42.581]                 else {
[13:37:42.581]                   if (TRUE) {
[13:37:42.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:42.581]                     {
[13:37:42.581]                       inherits <- base::inherits
[13:37:42.581]                       invokeRestart <- base::invokeRestart
[13:37:42.581]                       is.null <- base::is.null
[13:37:42.581]                       muffled <- FALSE
[13:37:42.581]                       if (inherits(cond, "message")) {
[13:37:42.581]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:42.581]                         if (muffled) 
[13:37:42.581]                           invokeRestart("muffleMessage")
[13:37:42.581]                       }
[13:37:42.581]                       else if (inherits(cond, "warning")) {
[13:37:42.581]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:42.581]                         if (muffled) 
[13:37:42.581]                           invokeRestart("muffleWarning")
[13:37:42.581]                       }
[13:37:42.581]                       else if (inherits(cond, "condition")) {
[13:37:42.581]                         if (!is.null(pattern)) {
[13:37:42.581]                           computeRestarts <- base::computeRestarts
[13:37:42.581]                           grepl <- base::grepl
[13:37:42.581]                           restarts <- computeRestarts(cond)
[13:37:42.581]                           for (restart in restarts) {
[13:37:42.581]                             name <- restart$name
[13:37:42.581]                             if (is.null(name)) 
[13:37:42.581]                               next
[13:37:42.581]                             if (!grepl(pattern, name)) 
[13:37:42.581]                               next
[13:37:42.581]                             invokeRestart(restart)
[13:37:42.581]                             muffled <- TRUE
[13:37:42.581]                             break
[13:37:42.581]                           }
[13:37:42.581]                         }
[13:37:42.581]                       }
[13:37:42.581]                       invisible(muffled)
[13:37:42.581]                     }
[13:37:42.581]                     muffleCondition(cond, pattern = "^muffle")
[13:37:42.581]                   }
[13:37:42.581]                 }
[13:37:42.581]             }
[13:37:42.581]         }))
[13:37:42.581]     }, error = function(ex) {
[13:37:42.581]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:42.581]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:42.581]                 ...future.rng), started = ...future.startTime, 
[13:37:42.581]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:42.581]             version = "1.8"), class = "FutureResult")
[13:37:42.581]     }, finally = {
[13:37:42.581]         if (!identical(...future.workdir, getwd())) 
[13:37:42.581]             setwd(...future.workdir)
[13:37:42.581]         {
[13:37:42.581]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:42.581]                 ...future.oldOptions$nwarnings <- NULL
[13:37:42.581]             }
[13:37:42.581]             base::options(...future.oldOptions)
[13:37:42.581]             if (.Platform$OS.type == "windows") {
[13:37:42.581]                 old_names <- names(...future.oldEnvVars)
[13:37:42.581]                 envs <- base::Sys.getenv()
[13:37:42.581]                 names <- names(envs)
[13:37:42.581]                 common <- intersect(names, old_names)
[13:37:42.581]                 added <- setdiff(names, old_names)
[13:37:42.581]                 removed <- setdiff(old_names, names)
[13:37:42.581]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:42.581]                   envs[common]]
[13:37:42.581]                 NAMES <- toupper(changed)
[13:37:42.581]                 args <- list()
[13:37:42.581]                 for (kk in seq_along(NAMES)) {
[13:37:42.581]                   name <- changed[[kk]]
[13:37:42.581]                   NAME <- NAMES[[kk]]
[13:37:42.581]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:42.581]                     next
[13:37:42.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:42.581]                 }
[13:37:42.581]                 NAMES <- toupper(added)
[13:37:42.581]                 for (kk in seq_along(NAMES)) {
[13:37:42.581]                   name <- added[[kk]]
[13:37:42.581]                   NAME <- NAMES[[kk]]
[13:37:42.581]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:42.581]                     next
[13:37:42.581]                   args[[name]] <- ""
[13:37:42.581]                 }
[13:37:42.581]                 NAMES <- toupper(removed)
[13:37:42.581]                 for (kk in seq_along(NAMES)) {
[13:37:42.581]                   name <- removed[[kk]]
[13:37:42.581]                   NAME <- NAMES[[kk]]
[13:37:42.581]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:42.581]                     next
[13:37:42.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:42.581]                 }
[13:37:42.581]                 if (length(args) > 0) 
[13:37:42.581]                   base::do.call(base::Sys.setenv, args = args)
[13:37:42.581]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:42.581]             }
[13:37:42.581]             else {
[13:37:42.581]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:42.581]             }
[13:37:42.581]             {
[13:37:42.581]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:42.581]                   0L) {
[13:37:42.581]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:42.581]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:42.581]                   base::options(opts)
[13:37:42.581]                 }
[13:37:42.581]                 {
[13:37:42.581]                   {
[13:37:42.581]                     NULL
[13:37:42.581]                     RNGkind("Mersenne-Twister")
[13:37:42.581]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:37:42.581]                       inherits = FALSE)
[13:37:42.581]                   }
[13:37:42.581]                   options(future.plan = NULL)
[13:37:42.581]                   if (is.na(NA_character_)) 
[13:37:42.581]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:42.581]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:42.581]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:42.581]                     .init = FALSE)
[13:37:42.581]                 }
[13:37:42.581]             }
[13:37:42.581]         }
[13:37:42.581]     })
[13:37:42.581]     if (TRUE) {
[13:37:42.581]         base::sink(type = "output", split = FALSE)
[13:37:42.581]         if (TRUE) {
[13:37:42.581]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:42.581]         }
[13:37:42.581]         else {
[13:37:42.581]             ...future.result["stdout"] <- base::list(NULL)
[13:37:42.581]         }
[13:37:42.581]         base::close(...future.stdout)
[13:37:42.581]         ...future.stdout <- NULL
[13:37:42.581]     }
[13:37:42.581]     ...future.result$conditions <- ...future.conditions
[13:37:42.581]     ...future.result$finished <- base::Sys.time()
[13:37:42.581]     ...future.result
[13:37:42.581] }
[13:37:42.582] assign_globals() ...
[13:37:42.582] List of 1
[13:37:42.582]  $ kk: int 3
[13:37:42.582]  - attr(*, "where")=List of 1
[13:37:42.582]   ..$ kk:<environment: R_EmptyEnv> 
[13:37:42.582]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:37:42.582]  - attr(*, "resolved")= logi FALSE
[13:37:42.582]  - attr(*, "total_size")= num 56
[13:37:42.582]  - attr(*, "already-done")= logi TRUE
[13:37:42.585] - copied ‘kk’ to environment
[13:37:42.585] assign_globals() ... done
[13:37:42.585] plan(): Setting new future strategy stack:
[13:37:42.585] List of future strategies:
[13:37:42.585] 1. sequential:
[13:37:42.585]    - args: function (..., envir = parent.frame())
[13:37:42.585]    - tweaked: FALSE
[13:37:42.585]    - call: NULL
[13:37:42.586] plan(): nbrOfWorkers() = 1
[13:37:42.687] plan(): Setting new future strategy stack:
[13:37:42.687] List of future strategies:
[13:37:42.687] 1. sequential:
[13:37:42.687]    - args: function (..., envir = parent.frame())
[13:37:42.687]    - tweaked: FALSE
[13:37:42.687]    - call: plan(strategy)
[13:37:42.688] plan(): nbrOfWorkers() = 1
[13:37:42.688] SequentialFuture started (and completed)
[13:37:42.688] - Launch lazy future ... done
[13:37:42.688] run() for ‘SequentialFuture’ ... done
[13:37:42.689] resolve() on list ...
[13:37:42.689]  recursive: 0
[13:37:42.689]  length: 3
[13:37:42.689] 
[13:37:42.689] resolved() for ‘SequentialFuture’ ...
[13:37:42.689] - state: ‘finished’
[13:37:42.689] - run: TRUE
[13:37:42.689] - result: ‘FutureResult’
[13:37:42.689] resolved() for ‘SequentialFuture’ ... done
[13:37:42.689] Future #1
[13:37:42.690]  length: 2 (resolved future 1)
[13:37:42.690] resolved() for ‘SequentialFuture’ ...
[13:37:42.690] - state: ‘finished’
[13:37:42.690] - run: TRUE
[13:37:42.690] - result: ‘FutureResult’
[13:37:42.690] resolved() for ‘SequentialFuture’ ... done
[13:37:42.690] Future #2
[13:37:42.690]  length: 1 (resolved future 2)
[13:37:42.690] resolved() for ‘SequentialFuture’ ...
[13:37:42.690] - state: ‘finished’
[13:37:42.691] - run: TRUE
[13:37:42.691] - result: ‘FutureResult’
[13:37:42.691] resolved() for ‘SequentialFuture’ ... done
[13:37:42.691] Future #3
[13:37:42.691]  length: 0 (resolved future 3)
[13:37:42.691] resolve() on list ... DONE
[13:37:42.691] getGlobalsAndPackages() ...
[13:37:42.691] Searching for globals...
[13:37:42.692] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:37:42.692] Searching for globals ... DONE
[13:37:42.693] Resolving globals: FALSE
[13:37:42.693] The total size of the 1 globals is 56 bytes (56 bytes)
[13:37:42.693] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:37:42.693] - globals: [1] ‘kk’
[13:37:42.694] 
[13:37:42.694] getGlobalsAndPackages() ... DONE
[13:37:42.694] getGlobalsAndPackages() ...
[13:37:42.694] Searching for globals...
[13:37:42.695] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:37:42.695] Searching for globals ... DONE
[13:37:42.695] Resolving globals: FALSE
[13:37:42.696] The total size of the 1 globals is 56 bytes (56 bytes)
[13:37:42.696] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:37:42.696] - globals: [1] ‘kk’
[13:37:42.696] 
[13:37:42.696] getGlobalsAndPackages() ... DONE
[13:37:42.697] getGlobalsAndPackages() ...
[13:37:42.697] Searching for globals...
[13:37:42.698] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:37:42.698] Searching for globals ... DONE
[13:37:42.698] Resolving globals: FALSE
[13:37:42.698] The total size of the 1 globals is 56 bytes (56 bytes)
[13:37:42.698] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:37:42.699] - globals: [1] ‘kk’
[13:37:42.699] 
[13:37:42.699] getGlobalsAndPackages() ... DONE
[13:37:42.701] resolve() on list ...
[13:37:42.701]  recursive: 0
[13:37:42.701]  length: 3
[13:37:42.701] 
[13:37:42.701] run() for ‘Future’ ...
[13:37:42.701] - state: ‘created’
[13:37:42.702] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:37:42.702] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:37:42.702] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:37:42.702]   - Field: ‘label’
[13:37:42.702]   - Field: ‘local’
[13:37:42.702]   - Field: ‘owner’
[13:37:42.702]   - Field: ‘envir’
[13:37:42.702]   - Field: ‘packages’
[13:37:42.703]   - Field: ‘gc’
[13:37:42.703]   - Field: ‘conditions’
[13:37:42.703]   - Field: ‘expr’
[13:37:42.703]   - Field: ‘uuid’
[13:37:42.703]   - Field: ‘seed’
[13:37:42.703]   - Field: ‘version’
[13:37:42.703]   - Field: ‘result’
[13:37:42.703]   - Field: ‘asynchronous’
[13:37:42.703]   - Field: ‘calls’
[13:37:42.703]   - Field: ‘globals’
[13:37:42.704]   - Field: ‘stdout’
[13:37:42.704]   - Field: ‘earlySignal’
[13:37:42.704]   - Field: ‘lazy’
[13:37:42.704]   - Field: ‘state’
[13:37:42.704] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:37:42.704] - Launch lazy future ...
[13:37:42.704] Packages needed by the future expression (n = 0): <none>
[13:37:42.704] Packages needed by future strategies (n = 0): <none>
[13:37:42.705] {
[13:37:42.705]     {
[13:37:42.705]         {
[13:37:42.705]             ...future.startTime <- base::Sys.time()
[13:37:42.705]             {
[13:37:42.705]                 {
[13:37:42.705]                   {
[13:37:42.705]                     base::local({
[13:37:42.705]                       has_future <- base::requireNamespace("future", 
[13:37:42.705]                         quietly = TRUE)
[13:37:42.705]                       if (has_future) {
[13:37:42.705]                         ns <- base::getNamespace("future")
[13:37:42.705]                         version <- ns[[".package"]][["version"]]
[13:37:42.705]                         if (is.null(version)) 
[13:37:42.705]                           version <- utils::packageVersion("future")
[13:37:42.705]                       }
[13:37:42.705]                       else {
[13:37:42.705]                         version <- NULL
[13:37:42.705]                       }
[13:37:42.705]                       if (!has_future || version < "1.8.0") {
[13:37:42.705]                         info <- base::c(r_version = base::gsub("R version ", 
[13:37:42.705]                           "", base::R.version$version.string), 
[13:37:42.705]                           platform = base::sprintf("%s (%s-bit)", 
[13:37:42.705]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:42.705]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:42.705]                             "release", "version")], collapse = " "), 
[13:37:42.705]                           hostname = base::Sys.info()[["nodename"]])
[13:37:42.705]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:37:42.705]                           info)
[13:37:42.705]                         info <- base::paste(info, collapse = "; ")
[13:37:42.705]                         if (!has_future) {
[13:37:42.705]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:42.705]                             info)
[13:37:42.705]                         }
[13:37:42.705]                         else {
[13:37:42.705]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:42.705]                             info, version)
[13:37:42.705]                         }
[13:37:42.705]                         base::stop(msg)
[13:37:42.705]                       }
[13:37:42.705]                     })
[13:37:42.705]                   }
[13:37:42.705]                   ...future.strategy.old <- future::plan("list")
[13:37:42.705]                   options(future.plan = NULL)
[13:37:42.705]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:42.705]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:42.705]                 }
[13:37:42.705]                 ...future.workdir <- getwd()
[13:37:42.705]             }
[13:37:42.705]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:42.705]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:42.705]         }
[13:37:42.705]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:42.705]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:42.705]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:42.705]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:42.705]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:42.705]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:42.705]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:42.705]             base::names(...future.oldOptions))
[13:37:42.705]     }
[13:37:42.705]     if (FALSE) {
[13:37:42.705]     }
[13:37:42.705]     else {
[13:37:42.705]         if (TRUE) {
[13:37:42.705]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:42.705]                 open = "w")
[13:37:42.705]         }
[13:37:42.705]         else {
[13:37:42.705]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:42.705]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:42.705]         }
[13:37:42.705]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:42.705]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:42.705]             base::sink(type = "output", split = FALSE)
[13:37:42.705]             base::close(...future.stdout)
[13:37:42.705]         }, add = TRUE)
[13:37:42.705]     }
[13:37:42.705]     ...future.frame <- base::sys.nframe()
[13:37:42.705]     ...future.conditions <- base::list()
[13:37:42.705]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:42.705]     if (FALSE) {
[13:37:42.705]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:42.705]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:42.705]     }
[13:37:42.705]     ...future.result <- base::tryCatch({
[13:37:42.705]         base::withCallingHandlers({
[13:37:42.705]             ...future.value <- base::withVisible(base::local({
[13:37:42.705]                 Sys.sleep(0.1)
[13:37:42.705]                 kk
[13:37:42.705]             }))
[13:37:42.705]             future::FutureResult(value = ...future.value$value, 
[13:37:42.705]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:42.705]                   ...future.rng), globalenv = if (FALSE) 
[13:37:42.705]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:42.705]                     ...future.globalenv.names))
[13:37:42.705]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:42.705]         }, condition = base::local({
[13:37:42.705]             c <- base::c
[13:37:42.705]             inherits <- base::inherits
[13:37:42.705]             invokeRestart <- base::invokeRestart
[13:37:42.705]             length <- base::length
[13:37:42.705]             list <- base::list
[13:37:42.705]             seq.int <- base::seq.int
[13:37:42.705]             signalCondition <- base::signalCondition
[13:37:42.705]             sys.calls <- base::sys.calls
[13:37:42.705]             `[[` <- base::`[[`
[13:37:42.705]             `+` <- base::`+`
[13:37:42.705]             `<<-` <- base::`<<-`
[13:37:42.705]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:42.705]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:42.705]                   3L)]
[13:37:42.705]             }
[13:37:42.705]             function(cond) {
[13:37:42.705]                 is_error <- inherits(cond, "error")
[13:37:42.705]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:42.705]                   NULL)
[13:37:42.705]                 if (is_error) {
[13:37:42.705]                   sessionInformation <- function() {
[13:37:42.705]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:42.705]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:42.705]                       search = base::search(), system = base::Sys.info())
[13:37:42.705]                   }
[13:37:42.705]                   ...future.conditions[[length(...future.conditions) + 
[13:37:42.705]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:42.705]                     cond$call), session = sessionInformation(), 
[13:37:42.705]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:42.705]                   signalCondition(cond)
[13:37:42.705]                 }
[13:37:42.705]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:42.705]                 "immediateCondition"))) {
[13:37:42.705]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:42.705]                   ...future.conditions[[length(...future.conditions) + 
[13:37:42.705]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:42.705]                   if (TRUE && !signal) {
[13:37:42.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:42.705]                     {
[13:37:42.705]                       inherits <- base::inherits
[13:37:42.705]                       invokeRestart <- base::invokeRestart
[13:37:42.705]                       is.null <- base::is.null
[13:37:42.705]                       muffled <- FALSE
[13:37:42.705]                       if (inherits(cond, "message")) {
[13:37:42.705]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:42.705]                         if (muffled) 
[13:37:42.705]                           invokeRestart("muffleMessage")
[13:37:42.705]                       }
[13:37:42.705]                       else if (inherits(cond, "warning")) {
[13:37:42.705]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:42.705]                         if (muffled) 
[13:37:42.705]                           invokeRestart("muffleWarning")
[13:37:42.705]                       }
[13:37:42.705]                       else if (inherits(cond, "condition")) {
[13:37:42.705]                         if (!is.null(pattern)) {
[13:37:42.705]                           computeRestarts <- base::computeRestarts
[13:37:42.705]                           grepl <- base::grepl
[13:37:42.705]                           restarts <- computeRestarts(cond)
[13:37:42.705]                           for (restart in restarts) {
[13:37:42.705]                             name <- restart$name
[13:37:42.705]                             if (is.null(name)) 
[13:37:42.705]                               next
[13:37:42.705]                             if (!grepl(pattern, name)) 
[13:37:42.705]                               next
[13:37:42.705]                             invokeRestart(restart)
[13:37:42.705]                             muffled <- TRUE
[13:37:42.705]                             break
[13:37:42.705]                           }
[13:37:42.705]                         }
[13:37:42.705]                       }
[13:37:42.705]                       invisible(muffled)
[13:37:42.705]                     }
[13:37:42.705]                     muffleCondition(cond, pattern = "^muffle")
[13:37:42.705]                   }
[13:37:42.705]                 }
[13:37:42.705]                 else {
[13:37:42.705]                   if (TRUE) {
[13:37:42.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:42.705]                     {
[13:37:42.705]                       inherits <- base::inherits
[13:37:42.705]                       invokeRestart <- base::invokeRestart
[13:37:42.705]                       is.null <- base::is.null
[13:37:42.705]                       muffled <- FALSE
[13:37:42.705]                       if (inherits(cond, "message")) {
[13:37:42.705]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:42.705]                         if (muffled) 
[13:37:42.705]                           invokeRestart("muffleMessage")
[13:37:42.705]                       }
[13:37:42.705]                       else if (inherits(cond, "warning")) {
[13:37:42.705]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:42.705]                         if (muffled) 
[13:37:42.705]                           invokeRestart("muffleWarning")
[13:37:42.705]                       }
[13:37:42.705]                       else if (inherits(cond, "condition")) {
[13:37:42.705]                         if (!is.null(pattern)) {
[13:37:42.705]                           computeRestarts <- base::computeRestarts
[13:37:42.705]                           grepl <- base::grepl
[13:37:42.705]                           restarts <- computeRestarts(cond)
[13:37:42.705]                           for (restart in restarts) {
[13:37:42.705]                             name <- restart$name
[13:37:42.705]                             if (is.null(name)) 
[13:37:42.705]                               next
[13:37:42.705]                             if (!grepl(pattern, name)) 
[13:37:42.705]                               next
[13:37:42.705]                             invokeRestart(restart)
[13:37:42.705]                             muffled <- TRUE
[13:37:42.705]                             break
[13:37:42.705]                           }
[13:37:42.705]                         }
[13:37:42.705]                       }
[13:37:42.705]                       invisible(muffled)
[13:37:42.705]                     }
[13:37:42.705]                     muffleCondition(cond, pattern = "^muffle")
[13:37:42.705]                   }
[13:37:42.705]                 }
[13:37:42.705]             }
[13:37:42.705]         }))
[13:37:42.705]     }, error = function(ex) {
[13:37:42.705]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:42.705]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:42.705]                 ...future.rng), started = ...future.startTime, 
[13:37:42.705]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:42.705]             version = "1.8"), class = "FutureResult")
[13:37:42.705]     }, finally = {
[13:37:42.705]         if (!identical(...future.workdir, getwd())) 
[13:37:42.705]             setwd(...future.workdir)
[13:37:42.705]         {
[13:37:42.705]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:42.705]                 ...future.oldOptions$nwarnings <- NULL
[13:37:42.705]             }
[13:37:42.705]             base::options(...future.oldOptions)
[13:37:42.705]             if (.Platform$OS.type == "windows") {
[13:37:42.705]                 old_names <- names(...future.oldEnvVars)
[13:37:42.705]                 envs <- base::Sys.getenv()
[13:37:42.705]                 names <- names(envs)
[13:37:42.705]                 common <- intersect(names, old_names)
[13:37:42.705]                 added <- setdiff(names, old_names)
[13:37:42.705]                 removed <- setdiff(old_names, names)
[13:37:42.705]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:42.705]                   envs[common]]
[13:37:42.705]                 NAMES <- toupper(changed)
[13:37:42.705]                 args <- list()
[13:37:42.705]                 for (kk in seq_along(NAMES)) {
[13:37:42.705]                   name <- changed[[kk]]
[13:37:42.705]                   NAME <- NAMES[[kk]]
[13:37:42.705]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:42.705]                     next
[13:37:42.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:42.705]                 }
[13:37:42.705]                 NAMES <- toupper(added)
[13:37:42.705]                 for (kk in seq_along(NAMES)) {
[13:37:42.705]                   name <- added[[kk]]
[13:37:42.705]                   NAME <- NAMES[[kk]]
[13:37:42.705]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:42.705]                     next
[13:37:42.705]                   args[[name]] <- ""
[13:37:42.705]                 }
[13:37:42.705]                 NAMES <- toupper(removed)
[13:37:42.705]                 for (kk in seq_along(NAMES)) {
[13:37:42.705]                   name <- removed[[kk]]
[13:37:42.705]                   NAME <- NAMES[[kk]]
[13:37:42.705]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:42.705]                     next
[13:37:42.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:42.705]                 }
[13:37:42.705]                 if (length(args) > 0) 
[13:37:42.705]                   base::do.call(base::Sys.setenv, args = args)
[13:37:42.705]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:42.705]             }
[13:37:42.705]             else {
[13:37:42.705]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:42.705]             }
[13:37:42.705]             {
[13:37:42.705]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:42.705]                   0L) {
[13:37:42.705]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:42.705]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:42.705]                   base::options(opts)
[13:37:42.705]                 }
[13:37:42.705]                 {
[13:37:42.705]                   {
[13:37:42.705]                     NULL
[13:37:42.705]                     RNGkind("Mersenne-Twister")
[13:37:42.705]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:37:42.705]                       inherits = FALSE)
[13:37:42.705]                   }
[13:37:42.705]                   options(future.plan = NULL)
[13:37:42.705]                   if (is.na(NA_character_)) 
[13:37:42.705]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:42.705]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:42.705]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:42.705]                     .init = FALSE)
[13:37:42.705]                 }
[13:37:42.705]             }
[13:37:42.705]         }
[13:37:42.705]     })
[13:37:42.705]     if (TRUE) {
[13:37:42.705]         base::sink(type = "output", split = FALSE)
[13:37:42.705]         if (TRUE) {
[13:37:42.705]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:42.705]         }
[13:37:42.705]         else {
[13:37:42.705]             ...future.result["stdout"] <- base::list(NULL)
[13:37:42.705]         }
[13:37:42.705]         base::close(...future.stdout)
[13:37:42.705]         ...future.stdout <- NULL
[13:37:42.705]     }
[13:37:42.705]     ...future.result$conditions <- ...future.conditions
[13:37:42.705]     ...future.result$finished <- base::Sys.time()
[13:37:42.705]     ...future.result
[13:37:42.705] }
[13:37:42.707] assign_globals() ...
[13:37:42.707] List of 1
[13:37:42.707]  $ kk: int 1
[13:37:42.707]  - attr(*, "where")=List of 1
[13:37:42.707]   ..$ kk:<environment: R_EmptyEnv> 
[13:37:42.707]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:37:42.707]  - attr(*, "resolved")= logi FALSE
[13:37:42.707]  - attr(*, "total_size")= num 56
[13:37:42.707]  - attr(*, "already-done")= logi TRUE
[13:37:42.709] - copied ‘kk’ to environment
[13:37:42.710] assign_globals() ... done
[13:37:42.710] plan(): Setting new future strategy stack:
[13:37:42.710] List of future strategies:
[13:37:42.710] 1. sequential:
[13:37:42.710]    - args: function (..., envir = parent.frame())
[13:37:42.710]    - tweaked: FALSE
[13:37:42.710]    - call: NULL
[13:37:42.710] plan(): nbrOfWorkers() = 1
[13:37:42.812] plan(): Setting new future strategy stack:
[13:37:42.812] List of future strategies:
[13:37:42.812] 1. sequential:
[13:37:42.812]    - args: function (..., envir = parent.frame())
[13:37:42.812]    - tweaked: FALSE
[13:37:42.812]    - call: plan(strategy)
[13:37:42.812] plan(): nbrOfWorkers() = 1
[13:37:42.813] SequentialFuture started (and completed)
[13:37:42.813] - Launch lazy future ... done
[13:37:42.813] run() for ‘SequentialFuture’ ... done
[13:37:42.813] resolved() for ‘SequentialFuture’ ...
[13:37:42.813] - state: ‘finished’
[13:37:42.813] - run: TRUE
[13:37:42.813] - result: ‘FutureResult’
[13:37:42.813] resolved() for ‘SequentialFuture’ ... done
[13:37:42.813] Future #1
[13:37:42.814]  length: 2 (resolved future 1)
[13:37:42.814] run() for ‘Future’ ...
[13:37:42.814] - state: ‘created’
[13:37:42.814] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:37:42.814] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:37:42.814] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:37:42.815]   - Field: ‘label’
[13:37:42.815]   - Field: ‘local’
[13:37:42.815]   - Field: ‘owner’
[13:37:42.815]   - Field: ‘envir’
[13:37:42.815]   - Field: ‘packages’
[13:37:42.815]   - Field: ‘gc’
[13:37:42.815]   - Field: ‘conditions’
[13:37:42.815]   - Field: ‘expr’
[13:37:42.815]   - Field: ‘uuid’
[13:37:42.815]   - Field: ‘seed’
[13:37:42.816]   - Field: ‘version’
[13:37:42.816]   - Field: ‘result’
[13:37:42.816]   - Field: ‘asynchronous’
[13:37:42.816]   - Field: ‘calls’
[13:37:42.816]   - Field: ‘globals’
[13:37:42.816]   - Field: ‘stdout’
[13:37:42.816]   - Field: ‘earlySignal’
[13:37:42.816]   - Field: ‘lazy’
[13:37:42.816]   - Field: ‘state’
[13:37:42.816] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:37:42.816] - Launch lazy future ...
[13:37:42.817] Packages needed by the future expression (n = 0): <none>
[13:37:42.817] Packages needed by future strategies (n = 0): <none>
[13:37:42.817] {
[13:37:42.817]     {
[13:37:42.817]         {
[13:37:42.817]             ...future.startTime <- base::Sys.time()
[13:37:42.817]             {
[13:37:42.817]                 {
[13:37:42.817]                   {
[13:37:42.817]                     base::local({
[13:37:42.817]                       has_future <- base::requireNamespace("future", 
[13:37:42.817]                         quietly = TRUE)
[13:37:42.817]                       if (has_future) {
[13:37:42.817]                         ns <- base::getNamespace("future")
[13:37:42.817]                         version <- ns[[".package"]][["version"]]
[13:37:42.817]                         if (is.null(version)) 
[13:37:42.817]                           version <- utils::packageVersion("future")
[13:37:42.817]                       }
[13:37:42.817]                       else {
[13:37:42.817]                         version <- NULL
[13:37:42.817]                       }
[13:37:42.817]                       if (!has_future || version < "1.8.0") {
[13:37:42.817]                         info <- base::c(r_version = base::gsub("R version ", 
[13:37:42.817]                           "", base::R.version$version.string), 
[13:37:42.817]                           platform = base::sprintf("%s (%s-bit)", 
[13:37:42.817]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:42.817]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:42.817]                             "release", "version")], collapse = " "), 
[13:37:42.817]                           hostname = base::Sys.info()[["nodename"]])
[13:37:42.817]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:37:42.817]                           info)
[13:37:42.817]                         info <- base::paste(info, collapse = "; ")
[13:37:42.817]                         if (!has_future) {
[13:37:42.817]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:42.817]                             info)
[13:37:42.817]                         }
[13:37:42.817]                         else {
[13:37:42.817]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:42.817]                             info, version)
[13:37:42.817]                         }
[13:37:42.817]                         base::stop(msg)
[13:37:42.817]                       }
[13:37:42.817]                     })
[13:37:42.817]                   }
[13:37:42.817]                   ...future.strategy.old <- future::plan("list")
[13:37:42.817]                   options(future.plan = NULL)
[13:37:42.817]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:42.817]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:42.817]                 }
[13:37:42.817]                 ...future.workdir <- getwd()
[13:37:42.817]             }
[13:37:42.817]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:42.817]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:42.817]         }
[13:37:42.817]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:42.817]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:42.817]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:42.817]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:42.817]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:42.817]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:42.817]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:42.817]             base::names(...future.oldOptions))
[13:37:42.817]     }
[13:37:42.817]     if (FALSE) {
[13:37:42.817]     }
[13:37:42.817]     else {
[13:37:42.817]         if (TRUE) {
[13:37:42.817]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:42.817]                 open = "w")
[13:37:42.817]         }
[13:37:42.817]         else {
[13:37:42.817]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:42.817]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:42.817]         }
[13:37:42.817]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:42.817]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:42.817]             base::sink(type = "output", split = FALSE)
[13:37:42.817]             base::close(...future.stdout)
[13:37:42.817]         }, add = TRUE)
[13:37:42.817]     }
[13:37:42.817]     ...future.frame <- base::sys.nframe()
[13:37:42.817]     ...future.conditions <- base::list()
[13:37:42.817]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:42.817]     if (FALSE) {
[13:37:42.817]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:42.817]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:42.817]     }
[13:37:42.817]     ...future.result <- base::tryCatch({
[13:37:42.817]         base::withCallingHandlers({
[13:37:42.817]             ...future.value <- base::withVisible(base::local({
[13:37:42.817]                 Sys.sleep(0.1)
[13:37:42.817]                 kk
[13:37:42.817]             }))
[13:37:42.817]             future::FutureResult(value = ...future.value$value, 
[13:37:42.817]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:42.817]                   ...future.rng), globalenv = if (FALSE) 
[13:37:42.817]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:42.817]                     ...future.globalenv.names))
[13:37:42.817]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:42.817]         }, condition = base::local({
[13:37:42.817]             c <- base::c
[13:37:42.817]             inherits <- base::inherits
[13:37:42.817]             invokeRestart <- base::invokeRestart
[13:37:42.817]             length <- base::length
[13:37:42.817]             list <- base::list
[13:37:42.817]             seq.int <- base::seq.int
[13:37:42.817]             signalCondition <- base::signalCondition
[13:37:42.817]             sys.calls <- base::sys.calls
[13:37:42.817]             `[[` <- base::`[[`
[13:37:42.817]             `+` <- base::`+`
[13:37:42.817]             `<<-` <- base::`<<-`
[13:37:42.817]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:42.817]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:42.817]                   3L)]
[13:37:42.817]             }
[13:37:42.817]             function(cond) {
[13:37:42.817]                 is_error <- inherits(cond, "error")
[13:37:42.817]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:42.817]                   NULL)
[13:37:42.817]                 if (is_error) {
[13:37:42.817]                   sessionInformation <- function() {
[13:37:42.817]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:42.817]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:42.817]                       search = base::search(), system = base::Sys.info())
[13:37:42.817]                   }
[13:37:42.817]                   ...future.conditions[[length(...future.conditions) + 
[13:37:42.817]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:42.817]                     cond$call), session = sessionInformation(), 
[13:37:42.817]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:42.817]                   signalCondition(cond)
[13:37:42.817]                 }
[13:37:42.817]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:42.817]                 "immediateCondition"))) {
[13:37:42.817]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:42.817]                   ...future.conditions[[length(...future.conditions) + 
[13:37:42.817]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:42.817]                   if (TRUE && !signal) {
[13:37:42.817]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:42.817]                     {
[13:37:42.817]                       inherits <- base::inherits
[13:37:42.817]                       invokeRestart <- base::invokeRestart
[13:37:42.817]                       is.null <- base::is.null
[13:37:42.817]                       muffled <- FALSE
[13:37:42.817]                       if (inherits(cond, "message")) {
[13:37:42.817]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:42.817]                         if (muffled) 
[13:37:42.817]                           invokeRestart("muffleMessage")
[13:37:42.817]                       }
[13:37:42.817]                       else if (inherits(cond, "warning")) {
[13:37:42.817]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:42.817]                         if (muffled) 
[13:37:42.817]                           invokeRestart("muffleWarning")
[13:37:42.817]                       }
[13:37:42.817]                       else if (inherits(cond, "condition")) {
[13:37:42.817]                         if (!is.null(pattern)) {
[13:37:42.817]                           computeRestarts <- base::computeRestarts
[13:37:42.817]                           grepl <- base::grepl
[13:37:42.817]                           restarts <- computeRestarts(cond)
[13:37:42.817]                           for (restart in restarts) {
[13:37:42.817]                             name <- restart$name
[13:37:42.817]                             if (is.null(name)) 
[13:37:42.817]                               next
[13:37:42.817]                             if (!grepl(pattern, name)) 
[13:37:42.817]                               next
[13:37:42.817]                             invokeRestart(restart)
[13:37:42.817]                             muffled <- TRUE
[13:37:42.817]                             break
[13:37:42.817]                           }
[13:37:42.817]                         }
[13:37:42.817]                       }
[13:37:42.817]                       invisible(muffled)
[13:37:42.817]                     }
[13:37:42.817]                     muffleCondition(cond, pattern = "^muffle")
[13:37:42.817]                   }
[13:37:42.817]                 }
[13:37:42.817]                 else {
[13:37:42.817]                   if (TRUE) {
[13:37:42.817]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:42.817]                     {
[13:37:42.817]                       inherits <- base::inherits
[13:37:42.817]                       invokeRestart <- base::invokeRestart
[13:37:42.817]                       is.null <- base::is.null
[13:37:42.817]                       muffled <- FALSE
[13:37:42.817]                       if (inherits(cond, "message")) {
[13:37:42.817]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:42.817]                         if (muffled) 
[13:37:42.817]                           invokeRestart("muffleMessage")
[13:37:42.817]                       }
[13:37:42.817]                       else if (inherits(cond, "warning")) {
[13:37:42.817]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:42.817]                         if (muffled) 
[13:37:42.817]                           invokeRestart("muffleWarning")
[13:37:42.817]                       }
[13:37:42.817]                       else if (inherits(cond, "condition")) {
[13:37:42.817]                         if (!is.null(pattern)) {
[13:37:42.817]                           computeRestarts <- base::computeRestarts
[13:37:42.817]                           grepl <- base::grepl
[13:37:42.817]                           restarts <- computeRestarts(cond)
[13:37:42.817]                           for (restart in restarts) {
[13:37:42.817]                             name <- restart$name
[13:37:42.817]                             if (is.null(name)) 
[13:37:42.817]                               next
[13:37:42.817]                             if (!grepl(pattern, name)) 
[13:37:42.817]                               next
[13:37:42.817]                             invokeRestart(restart)
[13:37:42.817]                             muffled <- TRUE
[13:37:42.817]                             break
[13:37:42.817]                           }
[13:37:42.817]                         }
[13:37:42.817]                       }
[13:37:42.817]                       invisible(muffled)
[13:37:42.817]                     }
[13:37:42.817]                     muffleCondition(cond, pattern = "^muffle")
[13:37:42.817]                   }
[13:37:42.817]                 }
[13:37:42.817]             }
[13:37:42.817]         }))
[13:37:42.817]     }, error = function(ex) {
[13:37:42.817]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:42.817]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:42.817]                 ...future.rng), started = ...future.startTime, 
[13:37:42.817]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:42.817]             version = "1.8"), class = "FutureResult")
[13:37:42.817]     }, finally = {
[13:37:42.817]         if (!identical(...future.workdir, getwd())) 
[13:37:42.817]             setwd(...future.workdir)
[13:37:42.817]         {
[13:37:42.817]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:42.817]                 ...future.oldOptions$nwarnings <- NULL
[13:37:42.817]             }
[13:37:42.817]             base::options(...future.oldOptions)
[13:37:42.817]             if (.Platform$OS.type == "windows") {
[13:37:42.817]                 old_names <- names(...future.oldEnvVars)
[13:37:42.817]                 envs <- base::Sys.getenv()
[13:37:42.817]                 names <- names(envs)
[13:37:42.817]                 common <- intersect(names, old_names)
[13:37:42.817]                 added <- setdiff(names, old_names)
[13:37:42.817]                 removed <- setdiff(old_names, names)
[13:37:42.817]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:42.817]                   envs[common]]
[13:37:42.817]                 NAMES <- toupper(changed)
[13:37:42.817]                 args <- list()
[13:37:42.817]                 for (kk in seq_along(NAMES)) {
[13:37:42.817]                   name <- changed[[kk]]
[13:37:42.817]                   NAME <- NAMES[[kk]]
[13:37:42.817]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:42.817]                     next
[13:37:42.817]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:42.817]                 }
[13:37:42.817]                 NAMES <- toupper(added)
[13:37:42.817]                 for (kk in seq_along(NAMES)) {
[13:37:42.817]                   name <- added[[kk]]
[13:37:42.817]                   NAME <- NAMES[[kk]]
[13:37:42.817]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:42.817]                     next
[13:37:42.817]                   args[[name]] <- ""
[13:37:42.817]                 }
[13:37:42.817]                 NAMES <- toupper(removed)
[13:37:42.817]                 for (kk in seq_along(NAMES)) {
[13:37:42.817]                   name <- removed[[kk]]
[13:37:42.817]                   NAME <- NAMES[[kk]]
[13:37:42.817]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:42.817]                     next
[13:37:42.817]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:42.817]                 }
[13:37:42.817]                 if (length(args) > 0) 
[13:37:42.817]                   base::do.call(base::Sys.setenv, args = args)
[13:37:42.817]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:42.817]             }
[13:37:42.817]             else {
[13:37:42.817]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:42.817]             }
[13:37:42.817]             {
[13:37:42.817]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:42.817]                   0L) {
[13:37:42.817]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:42.817]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:42.817]                   base::options(opts)
[13:37:42.817]                 }
[13:37:42.817]                 {
[13:37:42.817]                   {
[13:37:42.817]                     NULL
[13:37:42.817]                     RNGkind("Mersenne-Twister")
[13:37:42.817]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:37:42.817]                       inherits = FALSE)
[13:37:42.817]                   }
[13:37:42.817]                   options(future.plan = NULL)
[13:37:42.817]                   if (is.na(NA_character_)) 
[13:37:42.817]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:42.817]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:42.817]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:42.817]                     .init = FALSE)
[13:37:42.817]                 }
[13:37:42.817]             }
[13:37:42.817]         }
[13:37:42.817]     })
[13:37:42.817]     if (TRUE) {
[13:37:42.817]         base::sink(type = "output", split = FALSE)
[13:37:42.817]         if (TRUE) {
[13:37:42.817]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:42.817]         }
[13:37:42.817]         else {
[13:37:42.817]             ...future.result["stdout"] <- base::list(NULL)
[13:37:42.817]         }
[13:37:42.817]         base::close(...future.stdout)
[13:37:42.817]         ...future.stdout <- NULL
[13:37:42.817]     }
[13:37:42.817]     ...future.result$conditions <- ...future.conditions
[13:37:42.817]     ...future.result$finished <- base::Sys.time()
[13:37:42.817]     ...future.result
[13:37:42.817] }
[13:37:42.819] assign_globals() ...
[13:37:42.819] List of 1
[13:37:42.819]  $ kk: int 2
[13:37:42.819]  - attr(*, "where")=List of 1
[13:37:42.819]   ..$ kk:<environment: R_EmptyEnv> 
[13:37:42.819]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:37:42.819]  - attr(*, "resolved")= logi FALSE
[13:37:42.819]  - attr(*, "total_size")= num 56
[13:37:42.819]  - attr(*, "already-done")= logi TRUE
[13:37:42.822] - copied ‘kk’ to environment
[13:37:42.822] assign_globals() ... done
[13:37:42.822] plan(): Setting new future strategy stack:
[13:37:42.822] List of future strategies:
[13:37:42.822] 1. sequential:
[13:37:42.822]    - args: function (..., envir = parent.frame())
[13:37:42.822]    - tweaked: FALSE
[13:37:42.822]    - call: NULL
[13:37:42.823] plan(): nbrOfWorkers() = 1
[13:37:42.924] plan(): Setting new future strategy stack:
[13:37:42.924] List of future strategies:
[13:37:42.924] 1. sequential:
[13:37:42.924]    - args: function (..., envir = parent.frame())
[13:37:42.924]    - tweaked: FALSE
[13:37:42.924]    - call: plan(strategy)
[13:37:42.925] plan(): nbrOfWorkers() = 1
[13:37:42.925] SequentialFuture started (and completed)
[13:37:42.925] - Launch lazy future ... done
[13:37:42.925] run() for ‘SequentialFuture’ ... done
[13:37:42.925] resolved() for ‘SequentialFuture’ ...
[13:37:42.925] - state: ‘finished’
[13:37:42.925] - run: TRUE
[13:37:42.926] - result: ‘FutureResult’
[13:37:42.926] resolved() for ‘SequentialFuture’ ... done
[13:37:42.926] Future #2
[13:37:42.926]  length: 1 (resolved future 2)
[13:37:42.926] run() for ‘Future’ ...
[13:37:42.926] - state: ‘created’
[13:37:42.926] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:37:42.927] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:37:42.927] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:37:42.927]   - Field: ‘label’
[13:37:42.927]   - Field: ‘local’
[13:37:42.927]   - Field: ‘owner’
[13:37:42.927]   - Field: ‘envir’
[13:37:42.927]   - Field: ‘packages’
[13:37:42.927]   - Field: ‘gc’
[13:37:42.927]   - Field: ‘conditions’
[13:37:42.927]   - Field: ‘expr’
[13:37:42.927]   - Field: ‘uuid’
[13:37:42.928]   - Field: ‘seed’
[13:37:42.928]   - Field: ‘version’
[13:37:42.928]   - Field: ‘result’
[13:37:42.928]   - Field: ‘asynchronous’
[13:37:42.928]   - Field: ‘calls’
[13:37:42.928]   - Field: ‘globals’
[13:37:42.928]   - Field: ‘stdout’
[13:37:42.928]   - Field: ‘earlySignal’
[13:37:42.928]   - Field: ‘lazy’
[13:37:42.928]   - Field: ‘state’
[13:37:42.928] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:37:42.929] - Launch lazy future ...
[13:37:42.929] Packages needed by the future expression (n = 0): <none>
[13:37:42.929] Packages needed by future strategies (n = 0): <none>
[13:37:42.929] {
[13:37:42.929]     {
[13:37:42.929]         {
[13:37:42.929]             ...future.startTime <- base::Sys.time()
[13:37:42.929]             {
[13:37:42.929]                 {
[13:37:42.929]                   {
[13:37:42.929]                     base::local({
[13:37:42.929]                       has_future <- base::requireNamespace("future", 
[13:37:42.929]                         quietly = TRUE)
[13:37:42.929]                       if (has_future) {
[13:37:42.929]                         ns <- base::getNamespace("future")
[13:37:42.929]                         version <- ns[[".package"]][["version"]]
[13:37:42.929]                         if (is.null(version)) 
[13:37:42.929]                           version <- utils::packageVersion("future")
[13:37:42.929]                       }
[13:37:42.929]                       else {
[13:37:42.929]                         version <- NULL
[13:37:42.929]                       }
[13:37:42.929]                       if (!has_future || version < "1.8.0") {
[13:37:42.929]                         info <- base::c(r_version = base::gsub("R version ", 
[13:37:42.929]                           "", base::R.version$version.string), 
[13:37:42.929]                           platform = base::sprintf("%s (%s-bit)", 
[13:37:42.929]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:42.929]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:42.929]                             "release", "version")], collapse = " "), 
[13:37:42.929]                           hostname = base::Sys.info()[["nodename"]])
[13:37:42.929]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:37:42.929]                           info)
[13:37:42.929]                         info <- base::paste(info, collapse = "; ")
[13:37:42.929]                         if (!has_future) {
[13:37:42.929]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:42.929]                             info)
[13:37:42.929]                         }
[13:37:42.929]                         else {
[13:37:42.929]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:42.929]                             info, version)
[13:37:42.929]                         }
[13:37:42.929]                         base::stop(msg)
[13:37:42.929]                       }
[13:37:42.929]                     })
[13:37:42.929]                   }
[13:37:42.929]                   ...future.strategy.old <- future::plan("list")
[13:37:42.929]                   options(future.plan = NULL)
[13:37:42.929]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:42.929]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:42.929]                 }
[13:37:42.929]                 ...future.workdir <- getwd()
[13:37:42.929]             }
[13:37:42.929]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:42.929]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:42.929]         }
[13:37:42.929]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:42.929]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:42.929]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:42.929]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:42.929]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:42.929]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:42.929]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:42.929]             base::names(...future.oldOptions))
[13:37:42.929]     }
[13:37:42.929]     if (FALSE) {
[13:37:42.929]     }
[13:37:42.929]     else {
[13:37:42.929]         if (TRUE) {
[13:37:42.929]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:42.929]                 open = "w")
[13:37:42.929]         }
[13:37:42.929]         else {
[13:37:42.929]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:42.929]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:42.929]         }
[13:37:42.929]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:42.929]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:42.929]             base::sink(type = "output", split = FALSE)
[13:37:42.929]             base::close(...future.stdout)
[13:37:42.929]         }, add = TRUE)
[13:37:42.929]     }
[13:37:42.929]     ...future.frame <- base::sys.nframe()
[13:37:42.929]     ...future.conditions <- base::list()
[13:37:42.929]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:42.929]     if (FALSE) {
[13:37:42.929]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:42.929]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:42.929]     }
[13:37:42.929]     ...future.result <- base::tryCatch({
[13:37:42.929]         base::withCallingHandlers({
[13:37:42.929]             ...future.value <- base::withVisible(base::local({
[13:37:42.929]                 Sys.sleep(0.1)
[13:37:42.929]                 kk
[13:37:42.929]             }))
[13:37:42.929]             future::FutureResult(value = ...future.value$value, 
[13:37:42.929]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:42.929]                   ...future.rng), globalenv = if (FALSE) 
[13:37:42.929]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:42.929]                     ...future.globalenv.names))
[13:37:42.929]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:42.929]         }, condition = base::local({
[13:37:42.929]             c <- base::c
[13:37:42.929]             inherits <- base::inherits
[13:37:42.929]             invokeRestart <- base::invokeRestart
[13:37:42.929]             length <- base::length
[13:37:42.929]             list <- base::list
[13:37:42.929]             seq.int <- base::seq.int
[13:37:42.929]             signalCondition <- base::signalCondition
[13:37:42.929]             sys.calls <- base::sys.calls
[13:37:42.929]             `[[` <- base::`[[`
[13:37:42.929]             `+` <- base::`+`
[13:37:42.929]             `<<-` <- base::`<<-`
[13:37:42.929]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:42.929]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:42.929]                   3L)]
[13:37:42.929]             }
[13:37:42.929]             function(cond) {
[13:37:42.929]                 is_error <- inherits(cond, "error")
[13:37:42.929]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:42.929]                   NULL)
[13:37:42.929]                 if (is_error) {
[13:37:42.929]                   sessionInformation <- function() {
[13:37:42.929]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:42.929]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:42.929]                       search = base::search(), system = base::Sys.info())
[13:37:42.929]                   }
[13:37:42.929]                   ...future.conditions[[length(...future.conditions) + 
[13:37:42.929]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:42.929]                     cond$call), session = sessionInformation(), 
[13:37:42.929]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:42.929]                   signalCondition(cond)
[13:37:42.929]                 }
[13:37:42.929]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:42.929]                 "immediateCondition"))) {
[13:37:42.929]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:42.929]                   ...future.conditions[[length(...future.conditions) + 
[13:37:42.929]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:42.929]                   if (TRUE && !signal) {
[13:37:42.929]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:42.929]                     {
[13:37:42.929]                       inherits <- base::inherits
[13:37:42.929]                       invokeRestart <- base::invokeRestart
[13:37:42.929]                       is.null <- base::is.null
[13:37:42.929]                       muffled <- FALSE
[13:37:42.929]                       if (inherits(cond, "message")) {
[13:37:42.929]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:42.929]                         if (muffled) 
[13:37:42.929]                           invokeRestart("muffleMessage")
[13:37:42.929]                       }
[13:37:42.929]                       else if (inherits(cond, "warning")) {
[13:37:42.929]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:42.929]                         if (muffled) 
[13:37:42.929]                           invokeRestart("muffleWarning")
[13:37:42.929]                       }
[13:37:42.929]                       else if (inherits(cond, "condition")) {
[13:37:42.929]                         if (!is.null(pattern)) {
[13:37:42.929]                           computeRestarts <- base::computeRestarts
[13:37:42.929]                           grepl <- base::grepl
[13:37:42.929]                           restarts <- computeRestarts(cond)
[13:37:42.929]                           for (restart in restarts) {
[13:37:42.929]                             name <- restart$name
[13:37:42.929]                             if (is.null(name)) 
[13:37:42.929]                               next
[13:37:42.929]                             if (!grepl(pattern, name)) 
[13:37:42.929]                               next
[13:37:42.929]                             invokeRestart(restart)
[13:37:42.929]                             muffled <- TRUE
[13:37:42.929]                             break
[13:37:42.929]                           }
[13:37:42.929]                         }
[13:37:42.929]                       }
[13:37:42.929]                       invisible(muffled)
[13:37:42.929]                     }
[13:37:42.929]                     muffleCondition(cond, pattern = "^muffle")
[13:37:42.929]                   }
[13:37:42.929]                 }
[13:37:42.929]                 else {
[13:37:42.929]                   if (TRUE) {
[13:37:42.929]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:42.929]                     {
[13:37:42.929]                       inherits <- base::inherits
[13:37:42.929]                       invokeRestart <- base::invokeRestart
[13:37:42.929]                       is.null <- base::is.null
[13:37:42.929]                       muffled <- FALSE
[13:37:42.929]                       if (inherits(cond, "message")) {
[13:37:42.929]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:42.929]                         if (muffled) 
[13:37:42.929]                           invokeRestart("muffleMessage")
[13:37:42.929]                       }
[13:37:42.929]                       else if (inherits(cond, "warning")) {
[13:37:42.929]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:42.929]                         if (muffled) 
[13:37:42.929]                           invokeRestart("muffleWarning")
[13:37:42.929]                       }
[13:37:42.929]                       else if (inherits(cond, "condition")) {
[13:37:42.929]                         if (!is.null(pattern)) {
[13:37:42.929]                           computeRestarts <- base::computeRestarts
[13:37:42.929]                           grepl <- base::grepl
[13:37:42.929]                           restarts <- computeRestarts(cond)
[13:37:42.929]                           for (restart in restarts) {
[13:37:42.929]                             name <- restart$name
[13:37:42.929]                             if (is.null(name)) 
[13:37:42.929]                               next
[13:37:42.929]                             if (!grepl(pattern, name)) 
[13:37:42.929]                               next
[13:37:42.929]                             invokeRestart(restart)
[13:37:42.929]                             muffled <- TRUE
[13:37:42.929]                             break
[13:37:42.929]                           }
[13:37:42.929]                         }
[13:37:42.929]                       }
[13:37:42.929]                       invisible(muffled)
[13:37:42.929]                     }
[13:37:42.929]                     muffleCondition(cond, pattern = "^muffle")
[13:37:42.929]                   }
[13:37:42.929]                 }
[13:37:42.929]             }
[13:37:42.929]         }))
[13:37:42.929]     }, error = function(ex) {
[13:37:42.929]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:42.929]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:42.929]                 ...future.rng), started = ...future.startTime, 
[13:37:42.929]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:42.929]             version = "1.8"), class = "FutureResult")
[13:37:42.929]     }, finally = {
[13:37:42.929]         if (!identical(...future.workdir, getwd())) 
[13:37:42.929]             setwd(...future.workdir)
[13:37:42.929]         {
[13:37:42.929]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:42.929]                 ...future.oldOptions$nwarnings <- NULL
[13:37:42.929]             }
[13:37:42.929]             base::options(...future.oldOptions)
[13:37:42.929]             if (.Platform$OS.type == "windows") {
[13:37:42.929]                 old_names <- names(...future.oldEnvVars)
[13:37:42.929]                 envs <- base::Sys.getenv()
[13:37:42.929]                 names <- names(envs)
[13:37:42.929]                 common <- intersect(names, old_names)
[13:37:42.929]                 added <- setdiff(names, old_names)
[13:37:42.929]                 removed <- setdiff(old_names, names)
[13:37:42.929]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:42.929]                   envs[common]]
[13:37:42.929]                 NAMES <- toupper(changed)
[13:37:42.929]                 args <- list()
[13:37:42.929]                 for (kk in seq_along(NAMES)) {
[13:37:42.929]                   name <- changed[[kk]]
[13:37:42.929]                   NAME <- NAMES[[kk]]
[13:37:42.929]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:42.929]                     next
[13:37:42.929]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:42.929]                 }
[13:37:42.929]                 NAMES <- toupper(added)
[13:37:42.929]                 for (kk in seq_along(NAMES)) {
[13:37:42.929]                   name <- added[[kk]]
[13:37:42.929]                   NAME <- NAMES[[kk]]
[13:37:42.929]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:42.929]                     next
[13:37:42.929]                   args[[name]] <- ""
[13:37:42.929]                 }
[13:37:42.929]                 NAMES <- toupper(removed)
[13:37:42.929]                 for (kk in seq_along(NAMES)) {
[13:37:42.929]                   name <- removed[[kk]]
[13:37:42.929]                   NAME <- NAMES[[kk]]
[13:37:42.929]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:42.929]                     next
[13:37:42.929]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:42.929]                 }
[13:37:42.929]                 if (length(args) > 0) 
[13:37:42.929]                   base::do.call(base::Sys.setenv, args = args)
[13:37:42.929]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:42.929]             }
[13:37:42.929]             else {
[13:37:42.929]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:42.929]             }
[13:37:42.929]             {
[13:37:42.929]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:42.929]                   0L) {
[13:37:42.929]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:42.929]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:42.929]                   base::options(opts)
[13:37:42.929]                 }
[13:37:42.929]                 {
[13:37:42.929]                   {
[13:37:42.929]                     NULL
[13:37:42.929]                     RNGkind("Mersenne-Twister")
[13:37:42.929]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:37:42.929]                       inherits = FALSE)
[13:37:42.929]                   }
[13:37:42.929]                   options(future.plan = NULL)
[13:37:42.929]                   if (is.na(NA_character_)) 
[13:37:42.929]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:42.929]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:42.929]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:42.929]                     .init = FALSE)
[13:37:42.929]                 }
[13:37:42.929]             }
[13:37:42.929]         }
[13:37:42.929]     })
[13:37:42.929]     if (TRUE) {
[13:37:42.929]         base::sink(type = "output", split = FALSE)
[13:37:42.929]         if (TRUE) {
[13:37:42.929]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:42.929]         }
[13:37:42.929]         else {
[13:37:42.929]             ...future.result["stdout"] <- base::list(NULL)
[13:37:42.929]         }
[13:37:42.929]         base::close(...future.stdout)
[13:37:42.929]         ...future.stdout <- NULL
[13:37:42.929]     }
[13:37:42.929]     ...future.result$conditions <- ...future.conditions
[13:37:42.929]     ...future.result$finished <- base::Sys.time()
[13:37:42.929]     ...future.result
[13:37:42.929] }
[13:37:42.931] assign_globals() ...
[13:37:42.931] List of 1
[13:37:42.931]  $ kk: int 3
[13:37:42.931]  - attr(*, "where")=List of 1
[13:37:42.931]   ..$ kk:<environment: R_EmptyEnv> 
[13:37:42.931]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:37:42.931]  - attr(*, "resolved")= logi FALSE
[13:37:42.931]  - attr(*, "total_size")= num 56
[13:37:42.931]  - attr(*, "already-done")= logi TRUE
[13:37:42.936] - copied ‘kk’ to environment
[13:37:42.936] assign_globals() ... done
[13:37:42.936] plan(): Setting new future strategy stack:
[13:37:42.936] List of future strategies:
[13:37:42.936] 1. sequential:
[13:37:42.936]    - args: function (..., envir = parent.frame())
[13:37:42.936]    - tweaked: FALSE
[13:37:42.936]    - call: NULL
[13:37:42.937] plan(): nbrOfWorkers() = 1
[13:37:43.038] plan(): Setting new future strategy stack:
[13:37:43.038] List of future strategies:
[13:37:43.038] 1. sequential:
[13:37:43.038]    - args: function (..., envir = parent.frame())
[13:37:43.038]    - tweaked: FALSE
[13:37:43.038]    - call: plan(strategy)
[13:37:43.039] plan(): nbrOfWorkers() = 1
[13:37:43.039] SequentialFuture started (and completed)
[13:37:43.039] - Launch lazy future ... done
[13:37:43.039] run() for ‘SequentialFuture’ ... done
[13:37:43.039] resolved() for ‘SequentialFuture’ ...
[13:37:43.040] - state: ‘finished’
[13:37:43.040] - run: TRUE
[13:37:43.040] - result: ‘FutureResult’
[13:37:43.040] resolved() for ‘SequentialFuture’ ... done
[13:37:43.040] Future #3
[13:37:43.040]  length: 0 (resolved future 3)
[13:37:43.040] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[13:37:43.041] resolve() on environment ...
[13:37:43.041]  recursive: 0
[13:37:43.042]  elements: [2] ‘a’, ‘b’
[13:37:43.043]  length: 1 (resolved future 1)
[13:37:43.043]  length: 0 (resolved future 2)
[13:37:43.043] resolve() on environment ... DONE
[13:37:43.043] getGlobalsAndPackages() ...
[13:37:43.043] Searching for globals...
[13:37:43.044] 
[13:37:43.044] Searching for globals ... DONE
[13:37:43.044] - globals: [0] <none>
[13:37:43.044] getGlobalsAndPackages() ... DONE
[13:37:43.044] run() for ‘Future’ ...
[13:37:43.044] - state: ‘created’
[13:37:43.044] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:37:43.045] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:37:43.045] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:37:43.045]   - Field: ‘label’
[13:37:43.045]   - Field: ‘local’
[13:37:43.045]   - Field: ‘owner’
[13:37:43.045]   - Field: ‘envir’
[13:37:43.045]   - Field: ‘packages’
[13:37:43.045]   - Field: ‘gc’
[13:37:43.046]   - Field: ‘conditions’
[13:37:43.046]   - Field: ‘expr’
[13:37:43.046]   - Field: ‘uuid’
[13:37:43.046]   - Field: ‘seed’
[13:37:43.046]   - Field: ‘version’
[13:37:43.046]   - Field: ‘result’
[13:37:43.046]   - Field: ‘asynchronous’
[13:37:43.046]   - Field: ‘calls’
[13:37:43.046]   - Field: ‘globals’
[13:37:43.046]   - Field: ‘stdout’
[13:37:43.046]   - Field: ‘earlySignal’
[13:37:43.047]   - Field: ‘lazy’
[13:37:43.047]   - Field: ‘state’
[13:37:43.047] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:37:43.047] - Launch lazy future ...
[13:37:43.047] Packages needed by the future expression (n = 0): <none>
[13:37:43.047] Packages needed by future strategies (n = 0): <none>
[13:37:43.048] {
[13:37:43.048]     {
[13:37:43.048]         {
[13:37:43.048]             ...future.startTime <- base::Sys.time()
[13:37:43.048]             {
[13:37:43.048]                 {
[13:37:43.048]                   {
[13:37:43.048]                     base::local({
[13:37:43.048]                       has_future <- base::requireNamespace("future", 
[13:37:43.048]                         quietly = TRUE)
[13:37:43.048]                       if (has_future) {
[13:37:43.048]                         ns <- base::getNamespace("future")
[13:37:43.048]                         version <- ns[[".package"]][["version"]]
[13:37:43.048]                         if (is.null(version)) 
[13:37:43.048]                           version <- utils::packageVersion("future")
[13:37:43.048]                       }
[13:37:43.048]                       else {
[13:37:43.048]                         version <- NULL
[13:37:43.048]                       }
[13:37:43.048]                       if (!has_future || version < "1.8.0") {
[13:37:43.048]                         info <- base::c(r_version = base::gsub("R version ", 
[13:37:43.048]                           "", base::R.version$version.string), 
[13:37:43.048]                           platform = base::sprintf("%s (%s-bit)", 
[13:37:43.048]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:43.048]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:43.048]                             "release", "version")], collapse = " "), 
[13:37:43.048]                           hostname = base::Sys.info()[["nodename"]])
[13:37:43.048]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:37:43.048]                           info)
[13:37:43.048]                         info <- base::paste(info, collapse = "; ")
[13:37:43.048]                         if (!has_future) {
[13:37:43.048]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:43.048]                             info)
[13:37:43.048]                         }
[13:37:43.048]                         else {
[13:37:43.048]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:43.048]                             info, version)
[13:37:43.048]                         }
[13:37:43.048]                         base::stop(msg)
[13:37:43.048]                       }
[13:37:43.048]                     })
[13:37:43.048]                   }
[13:37:43.048]                   ...future.strategy.old <- future::plan("list")
[13:37:43.048]                   options(future.plan = NULL)
[13:37:43.048]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.048]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:43.048]                 }
[13:37:43.048]                 ...future.workdir <- getwd()
[13:37:43.048]             }
[13:37:43.048]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:43.048]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:43.048]         }
[13:37:43.048]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:43.048]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:43.048]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:43.048]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:43.048]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:43.048]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:43.048]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:43.048]             base::names(...future.oldOptions))
[13:37:43.048]     }
[13:37:43.048]     if (FALSE) {
[13:37:43.048]     }
[13:37:43.048]     else {
[13:37:43.048]         if (TRUE) {
[13:37:43.048]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:43.048]                 open = "w")
[13:37:43.048]         }
[13:37:43.048]         else {
[13:37:43.048]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:43.048]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:43.048]         }
[13:37:43.048]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:43.048]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:43.048]             base::sink(type = "output", split = FALSE)
[13:37:43.048]             base::close(...future.stdout)
[13:37:43.048]         }, add = TRUE)
[13:37:43.048]     }
[13:37:43.048]     ...future.frame <- base::sys.nframe()
[13:37:43.048]     ...future.conditions <- base::list()
[13:37:43.048]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:43.048]     if (FALSE) {
[13:37:43.048]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:43.048]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:43.048]     }
[13:37:43.048]     ...future.result <- base::tryCatch({
[13:37:43.048]         base::withCallingHandlers({
[13:37:43.048]             ...future.value <- base::withVisible(base::local(1))
[13:37:43.048]             future::FutureResult(value = ...future.value$value, 
[13:37:43.048]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.048]                   ...future.rng), globalenv = if (FALSE) 
[13:37:43.048]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:43.048]                     ...future.globalenv.names))
[13:37:43.048]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:43.048]         }, condition = base::local({
[13:37:43.048]             c <- base::c
[13:37:43.048]             inherits <- base::inherits
[13:37:43.048]             invokeRestart <- base::invokeRestart
[13:37:43.048]             length <- base::length
[13:37:43.048]             list <- base::list
[13:37:43.048]             seq.int <- base::seq.int
[13:37:43.048]             signalCondition <- base::signalCondition
[13:37:43.048]             sys.calls <- base::sys.calls
[13:37:43.048]             `[[` <- base::`[[`
[13:37:43.048]             `+` <- base::`+`
[13:37:43.048]             `<<-` <- base::`<<-`
[13:37:43.048]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:43.048]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:43.048]                   3L)]
[13:37:43.048]             }
[13:37:43.048]             function(cond) {
[13:37:43.048]                 is_error <- inherits(cond, "error")
[13:37:43.048]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:43.048]                   NULL)
[13:37:43.048]                 if (is_error) {
[13:37:43.048]                   sessionInformation <- function() {
[13:37:43.048]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:43.048]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:43.048]                       search = base::search(), system = base::Sys.info())
[13:37:43.048]                   }
[13:37:43.048]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.048]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:43.048]                     cond$call), session = sessionInformation(), 
[13:37:43.048]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:43.048]                   signalCondition(cond)
[13:37:43.048]                 }
[13:37:43.048]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:43.048]                 "immediateCondition"))) {
[13:37:43.048]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:43.048]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.048]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:43.048]                   if (TRUE && !signal) {
[13:37:43.048]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.048]                     {
[13:37:43.048]                       inherits <- base::inherits
[13:37:43.048]                       invokeRestart <- base::invokeRestart
[13:37:43.048]                       is.null <- base::is.null
[13:37:43.048]                       muffled <- FALSE
[13:37:43.048]                       if (inherits(cond, "message")) {
[13:37:43.048]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.048]                         if (muffled) 
[13:37:43.048]                           invokeRestart("muffleMessage")
[13:37:43.048]                       }
[13:37:43.048]                       else if (inherits(cond, "warning")) {
[13:37:43.048]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.048]                         if (muffled) 
[13:37:43.048]                           invokeRestart("muffleWarning")
[13:37:43.048]                       }
[13:37:43.048]                       else if (inherits(cond, "condition")) {
[13:37:43.048]                         if (!is.null(pattern)) {
[13:37:43.048]                           computeRestarts <- base::computeRestarts
[13:37:43.048]                           grepl <- base::grepl
[13:37:43.048]                           restarts <- computeRestarts(cond)
[13:37:43.048]                           for (restart in restarts) {
[13:37:43.048]                             name <- restart$name
[13:37:43.048]                             if (is.null(name)) 
[13:37:43.048]                               next
[13:37:43.048]                             if (!grepl(pattern, name)) 
[13:37:43.048]                               next
[13:37:43.048]                             invokeRestart(restart)
[13:37:43.048]                             muffled <- TRUE
[13:37:43.048]                             break
[13:37:43.048]                           }
[13:37:43.048]                         }
[13:37:43.048]                       }
[13:37:43.048]                       invisible(muffled)
[13:37:43.048]                     }
[13:37:43.048]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.048]                   }
[13:37:43.048]                 }
[13:37:43.048]                 else {
[13:37:43.048]                   if (TRUE) {
[13:37:43.048]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.048]                     {
[13:37:43.048]                       inherits <- base::inherits
[13:37:43.048]                       invokeRestart <- base::invokeRestart
[13:37:43.048]                       is.null <- base::is.null
[13:37:43.048]                       muffled <- FALSE
[13:37:43.048]                       if (inherits(cond, "message")) {
[13:37:43.048]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.048]                         if (muffled) 
[13:37:43.048]                           invokeRestart("muffleMessage")
[13:37:43.048]                       }
[13:37:43.048]                       else if (inherits(cond, "warning")) {
[13:37:43.048]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.048]                         if (muffled) 
[13:37:43.048]                           invokeRestart("muffleWarning")
[13:37:43.048]                       }
[13:37:43.048]                       else if (inherits(cond, "condition")) {
[13:37:43.048]                         if (!is.null(pattern)) {
[13:37:43.048]                           computeRestarts <- base::computeRestarts
[13:37:43.048]                           grepl <- base::grepl
[13:37:43.048]                           restarts <- computeRestarts(cond)
[13:37:43.048]                           for (restart in restarts) {
[13:37:43.048]                             name <- restart$name
[13:37:43.048]                             if (is.null(name)) 
[13:37:43.048]                               next
[13:37:43.048]                             if (!grepl(pattern, name)) 
[13:37:43.048]                               next
[13:37:43.048]                             invokeRestart(restart)
[13:37:43.048]                             muffled <- TRUE
[13:37:43.048]                             break
[13:37:43.048]                           }
[13:37:43.048]                         }
[13:37:43.048]                       }
[13:37:43.048]                       invisible(muffled)
[13:37:43.048]                     }
[13:37:43.048]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.048]                   }
[13:37:43.048]                 }
[13:37:43.048]             }
[13:37:43.048]         }))
[13:37:43.048]     }, error = function(ex) {
[13:37:43.048]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:43.048]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.048]                 ...future.rng), started = ...future.startTime, 
[13:37:43.048]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:43.048]             version = "1.8"), class = "FutureResult")
[13:37:43.048]     }, finally = {
[13:37:43.048]         if (!identical(...future.workdir, getwd())) 
[13:37:43.048]             setwd(...future.workdir)
[13:37:43.048]         {
[13:37:43.048]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:43.048]                 ...future.oldOptions$nwarnings <- NULL
[13:37:43.048]             }
[13:37:43.048]             base::options(...future.oldOptions)
[13:37:43.048]             if (.Platform$OS.type == "windows") {
[13:37:43.048]                 old_names <- names(...future.oldEnvVars)
[13:37:43.048]                 envs <- base::Sys.getenv()
[13:37:43.048]                 names <- names(envs)
[13:37:43.048]                 common <- intersect(names, old_names)
[13:37:43.048]                 added <- setdiff(names, old_names)
[13:37:43.048]                 removed <- setdiff(old_names, names)
[13:37:43.048]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:43.048]                   envs[common]]
[13:37:43.048]                 NAMES <- toupper(changed)
[13:37:43.048]                 args <- list()
[13:37:43.048]                 for (kk in seq_along(NAMES)) {
[13:37:43.048]                   name <- changed[[kk]]
[13:37:43.048]                   NAME <- NAMES[[kk]]
[13:37:43.048]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.048]                     next
[13:37:43.048]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.048]                 }
[13:37:43.048]                 NAMES <- toupper(added)
[13:37:43.048]                 for (kk in seq_along(NAMES)) {
[13:37:43.048]                   name <- added[[kk]]
[13:37:43.048]                   NAME <- NAMES[[kk]]
[13:37:43.048]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.048]                     next
[13:37:43.048]                   args[[name]] <- ""
[13:37:43.048]                 }
[13:37:43.048]                 NAMES <- toupper(removed)
[13:37:43.048]                 for (kk in seq_along(NAMES)) {
[13:37:43.048]                   name <- removed[[kk]]
[13:37:43.048]                   NAME <- NAMES[[kk]]
[13:37:43.048]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.048]                     next
[13:37:43.048]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.048]                 }
[13:37:43.048]                 if (length(args) > 0) 
[13:37:43.048]                   base::do.call(base::Sys.setenv, args = args)
[13:37:43.048]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:43.048]             }
[13:37:43.048]             else {
[13:37:43.048]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:43.048]             }
[13:37:43.048]             {
[13:37:43.048]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:43.048]                   0L) {
[13:37:43.048]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:43.048]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:43.048]                   base::options(opts)
[13:37:43.048]                 }
[13:37:43.048]                 {
[13:37:43.048]                   {
[13:37:43.048]                     NULL
[13:37:43.048]                     RNGkind("Mersenne-Twister")
[13:37:43.048]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:37:43.048]                       inherits = FALSE)
[13:37:43.048]                   }
[13:37:43.048]                   options(future.plan = NULL)
[13:37:43.048]                   if (is.na(NA_character_)) 
[13:37:43.048]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.048]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:43.048]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:43.048]                     .init = FALSE)
[13:37:43.048]                 }
[13:37:43.048]             }
[13:37:43.048]         }
[13:37:43.048]     })
[13:37:43.048]     if (TRUE) {
[13:37:43.048]         base::sink(type = "output", split = FALSE)
[13:37:43.048]         if (TRUE) {
[13:37:43.048]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:43.048]         }
[13:37:43.048]         else {
[13:37:43.048]             ...future.result["stdout"] <- base::list(NULL)
[13:37:43.048]         }
[13:37:43.048]         base::close(...future.stdout)
[13:37:43.048]         ...future.stdout <- NULL
[13:37:43.048]     }
[13:37:43.048]     ...future.result$conditions <- ...future.conditions
[13:37:43.048]     ...future.result$finished <- base::Sys.time()
[13:37:43.048]     ...future.result
[13:37:43.048] }
[13:37:43.049] plan(): Setting new future strategy stack:
[13:37:43.050] List of future strategies:
[13:37:43.050] 1. sequential:
[13:37:43.050]    - args: function (..., envir = parent.frame())
[13:37:43.050]    - tweaked: FALSE
[13:37:43.050]    - call: NULL
[13:37:43.050] plan(): nbrOfWorkers() = 1
[13:37:43.051] plan(): Setting new future strategy stack:
[13:37:43.051] List of future strategies:
[13:37:43.051] 1. sequential:
[13:37:43.051]    - args: function (..., envir = parent.frame())
[13:37:43.051]    - tweaked: FALSE
[13:37:43.051]    - call: plan(strategy)
[13:37:43.051] plan(): nbrOfWorkers() = 1
[13:37:43.051] SequentialFuture started (and completed)
[13:37:43.052] - Launch lazy future ... done
[13:37:43.052] run() for ‘SequentialFuture’ ... done
[13:37:43.052] getGlobalsAndPackages() ...
[13:37:43.052] Searching for globals...
[13:37:43.052] 
[13:37:43.052] Searching for globals ... DONE
[13:37:43.052] - globals: [0] <none>
[13:37:43.053] getGlobalsAndPackages() ... DONE
[13:37:43.053] run() for ‘Future’ ...
[13:37:43.053] - state: ‘created’
[13:37:43.053] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:37:43.053] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:37:43.053] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:37:43.053]   - Field: ‘label’
[13:37:43.054]   - Field: ‘local’
[13:37:43.054]   - Field: ‘owner’
[13:37:43.054]   - Field: ‘envir’
[13:37:43.054]   - Field: ‘packages’
[13:37:43.054]   - Field: ‘gc’
[13:37:43.054]   - Field: ‘conditions’
[13:37:43.054]   - Field: ‘expr’
[13:37:43.054]   - Field: ‘uuid’
[13:37:43.054]   - Field: ‘seed’
[13:37:43.054]   - Field: ‘version’
[13:37:43.054]   - Field: ‘result’
[13:37:43.055]   - Field: ‘asynchronous’
[13:37:43.055]   - Field: ‘calls’
[13:37:43.055]   - Field: ‘globals’
[13:37:43.055]   - Field: ‘stdout’
[13:37:43.055]   - Field: ‘earlySignal’
[13:37:43.055]   - Field: ‘lazy’
[13:37:43.055]   - Field: ‘state’
[13:37:43.055] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:37:43.055] - Launch lazy future ...
[13:37:43.055] Packages needed by the future expression (n = 0): <none>
[13:37:43.056] Packages needed by future strategies (n = 0): <none>
[13:37:43.056] {
[13:37:43.056]     {
[13:37:43.056]         {
[13:37:43.056]             ...future.startTime <- base::Sys.time()
[13:37:43.056]             {
[13:37:43.056]                 {
[13:37:43.056]                   {
[13:37:43.056]                     base::local({
[13:37:43.056]                       has_future <- base::requireNamespace("future", 
[13:37:43.056]                         quietly = TRUE)
[13:37:43.056]                       if (has_future) {
[13:37:43.056]                         ns <- base::getNamespace("future")
[13:37:43.056]                         version <- ns[[".package"]][["version"]]
[13:37:43.056]                         if (is.null(version)) 
[13:37:43.056]                           version <- utils::packageVersion("future")
[13:37:43.056]                       }
[13:37:43.056]                       else {
[13:37:43.056]                         version <- NULL
[13:37:43.056]                       }
[13:37:43.056]                       if (!has_future || version < "1.8.0") {
[13:37:43.056]                         info <- base::c(r_version = base::gsub("R version ", 
[13:37:43.056]                           "", base::R.version$version.string), 
[13:37:43.056]                           platform = base::sprintf("%s (%s-bit)", 
[13:37:43.056]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:43.056]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:43.056]                             "release", "version")], collapse = " "), 
[13:37:43.056]                           hostname = base::Sys.info()[["nodename"]])
[13:37:43.056]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:37:43.056]                           info)
[13:37:43.056]                         info <- base::paste(info, collapse = "; ")
[13:37:43.056]                         if (!has_future) {
[13:37:43.056]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:43.056]                             info)
[13:37:43.056]                         }
[13:37:43.056]                         else {
[13:37:43.056]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:43.056]                             info, version)
[13:37:43.056]                         }
[13:37:43.056]                         base::stop(msg)
[13:37:43.056]                       }
[13:37:43.056]                     })
[13:37:43.056]                   }
[13:37:43.056]                   ...future.strategy.old <- future::plan("list")
[13:37:43.056]                   options(future.plan = NULL)
[13:37:43.056]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.056]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:43.056]                 }
[13:37:43.056]                 ...future.workdir <- getwd()
[13:37:43.056]             }
[13:37:43.056]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:43.056]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:43.056]         }
[13:37:43.056]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:43.056]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:43.056]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:43.056]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:43.056]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:43.056]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:43.056]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:43.056]             base::names(...future.oldOptions))
[13:37:43.056]     }
[13:37:43.056]     if (FALSE) {
[13:37:43.056]     }
[13:37:43.056]     else {
[13:37:43.056]         if (TRUE) {
[13:37:43.056]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:43.056]                 open = "w")
[13:37:43.056]         }
[13:37:43.056]         else {
[13:37:43.056]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:43.056]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:43.056]         }
[13:37:43.056]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:43.056]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:43.056]             base::sink(type = "output", split = FALSE)
[13:37:43.056]             base::close(...future.stdout)
[13:37:43.056]         }, add = TRUE)
[13:37:43.056]     }
[13:37:43.056]     ...future.frame <- base::sys.nframe()
[13:37:43.056]     ...future.conditions <- base::list()
[13:37:43.056]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:43.056]     if (FALSE) {
[13:37:43.056]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:43.056]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:43.056]     }
[13:37:43.056]     ...future.result <- base::tryCatch({
[13:37:43.056]         base::withCallingHandlers({
[13:37:43.056]             ...future.value <- base::withVisible(base::local(2))
[13:37:43.056]             future::FutureResult(value = ...future.value$value, 
[13:37:43.056]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.056]                   ...future.rng), globalenv = if (FALSE) 
[13:37:43.056]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:43.056]                     ...future.globalenv.names))
[13:37:43.056]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:43.056]         }, condition = base::local({
[13:37:43.056]             c <- base::c
[13:37:43.056]             inherits <- base::inherits
[13:37:43.056]             invokeRestart <- base::invokeRestart
[13:37:43.056]             length <- base::length
[13:37:43.056]             list <- base::list
[13:37:43.056]             seq.int <- base::seq.int
[13:37:43.056]             signalCondition <- base::signalCondition
[13:37:43.056]             sys.calls <- base::sys.calls
[13:37:43.056]             `[[` <- base::`[[`
[13:37:43.056]             `+` <- base::`+`
[13:37:43.056]             `<<-` <- base::`<<-`
[13:37:43.056]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:43.056]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:43.056]                   3L)]
[13:37:43.056]             }
[13:37:43.056]             function(cond) {
[13:37:43.056]                 is_error <- inherits(cond, "error")
[13:37:43.056]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:43.056]                   NULL)
[13:37:43.056]                 if (is_error) {
[13:37:43.056]                   sessionInformation <- function() {
[13:37:43.056]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:43.056]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:43.056]                       search = base::search(), system = base::Sys.info())
[13:37:43.056]                   }
[13:37:43.056]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.056]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:43.056]                     cond$call), session = sessionInformation(), 
[13:37:43.056]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:43.056]                   signalCondition(cond)
[13:37:43.056]                 }
[13:37:43.056]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:43.056]                 "immediateCondition"))) {
[13:37:43.056]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:43.056]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.056]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:43.056]                   if (TRUE && !signal) {
[13:37:43.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.056]                     {
[13:37:43.056]                       inherits <- base::inherits
[13:37:43.056]                       invokeRestart <- base::invokeRestart
[13:37:43.056]                       is.null <- base::is.null
[13:37:43.056]                       muffled <- FALSE
[13:37:43.056]                       if (inherits(cond, "message")) {
[13:37:43.056]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.056]                         if (muffled) 
[13:37:43.056]                           invokeRestart("muffleMessage")
[13:37:43.056]                       }
[13:37:43.056]                       else if (inherits(cond, "warning")) {
[13:37:43.056]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.056]                         if (muffled) 
[13:37:43.056]                           invokeRestart("muffleWarning")
[13:37:43.056]                       }
[13:37:43.056]                       else if (inherits(cond, "condition")) {
[13:37:43.056]                         if (!is.null(pattern)) {
[13:37:43.056]                           computeRestarts <- base::computeRestarts
[13:37:43.056]                           grepl <- base::grepl
[13:37:43.056]                           restarts <- computeRestarts(cond)
[13:37:43.056]                           for (restart in restarts) {
[13:37:43.056]                             name <- restart$name
[13:37:43.056]                             if (is.null(name)) 
[13:37:43.056]                               next
[13:37:43.056]                             if (!grepl(pattern, name)) 
[13:37:43.056]                               next
[13:37:43.056]                             invokeRestart(restart)
[13:37:43.056]                             muffled <- TRUE
[13:37:43.056]                             break
[13:37:43.056]                           }
[13:37:43.056]                         }
[13:37:43.056]                       }
[13:37:43.056]                       invisible(muffled)
[13:37:43.056]                     }
[13:37:43.056]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.056]                   }
[13:37:43.056]                 }
[13:37:43.056]                 else {
[13:37:43.056]                   if (TRUE) {
[13:37:43.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.056]                     {
[13:37:43.056]                       inherits <- base::inherits
[13:37:43.056]                       invokeRestart <- base::invokeRestart
[13:37:43.056]                       is.null <- base::is.null
[13:37:43.056]                       muffled <- FALSE
[13:37:43.056]                       if (inherits(cond, "message")) {
[13:37:43.056]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.056]                         if (muffled) 
[13:37:43.056]                           invokeRestart("muffleMessage")
[13:37:43.056]                       }
[13:37:43.056]                       else if (inherits(cond, "warning")) {
[13:37:43.056]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.056]                         if (muffled) 
[13:37:43.056]                           invokeRestart("muffleWarning")
[13:37:43.056]                       }
[13:37:43.056]                       else if (inherits(cond, "condition")) {
[13:37:43.056]                         if (!is.null(pattern)) {
[13:37:43.056]                           computeRestarts <- base::computeRestarts
[13:37:43.056]                           grepl <- base::grepl
[13:37:43.056]                           restarts <- computeRestarts(cond)
[13:37:43.056]                           for (restart in restarts) {
[13:37:43.056]                             name <- restart$name
[13:37:43.056]                             if (is.null(name)) 
[13:37:43.056]                               next
[13:37:43.056]                             if (!grepl(pattern, name)) 
[13:37:43.056]                               next
[13:37:43.056]                             invokeRestart(restart)
[13:37:43.056]                             muffled <- TRUE
[13:37:43.056]                             break
[13:37:43.056]                           }
[13:37:43.056]                         }
[13:37:43.056]                       }
[13:37:43.056]                       invisible(muffled)
[13:37:43.056]                     }
[13:37:43.056]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.056]                   }
[13:37:43.056]                 }
[13:37:43.056]             }
[13:37:43.056]         }))
[13:37:43.056]     }, error = function(ex) {
[13:37:43.056]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:43.056]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.056]                 ...future.rng), started = ...future.startTime, 
[13:37:43.056]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:43.056]             version = "1.8"), class = "FutureResult")
[13:37:43.056]     }, finally = {
[13:37:43.056]         if (!identical(...future.workdir, getwd())) 
[13:37:43.056]             setwd(...future.workdir)
[13:37:43.056]         {
[13:37:43.056]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:43.056]                 ...future.oldOptions$nwarnings <- NULL
[13:37:43.056]             }
[13:37:43.056]             base::options(...future.oldOptions)
[13:37:43.056]             if (.Platform$OS.type == "windows") {
[13:37:43.056]                 old_names <- names(...future.oldEnvVars)
[13:37:43.056]                 envs <- base::Sys.getenv()
[13:37:43.056]                 names <- names(envs)
[13:37:43.056]                 common <- intersect(names, old_names)
[13:37:43.056]                 added <- setdiff(names, old_names)
[13:37:43.056]                 removed <- setdiff(old_names, names)
[13:37:43.056]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:43.056]                   envs[common]]
[13:37:43.056]                 NAMES <- toupper(changed)
[13:37:43.056]                 args <- list()
[13:37:43.056]                 for (kk in seq_along(NAMES)) {
[13:37:43.056]                   name <- changed[[kk]]
[13:37:43.056]                   NAME <- NAMES[[kk]]
[13:37:43.056]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.056]                     next
[13:37:43.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.056]                 }
[13:37:43.056]                 NAMES <- toupper(added)
[13:37:43.056]                 for (kk in seq_along(NAMES)) {
[13:37:43.056]                   name <- added[[kk]]
[13:37:43.056]                   NAME <- NAMES[[kk]]
[13:37:43.056]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.056]                     next
[13:37:43.056]                   args[[name]] <- ""
[13:37:43.056]                 }
[13:37:43.056]                 NAMES <- toupper(removed)
[13:37:43.056]                 for (kk in seq_along(NAMES)) {
[13:37:43.056]                   name <- removed[[kk]]
[13:37:43.056]                   NAME <- NAMES[[kk]]
[13:37:43.056]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.056]                     next
[13:37:43.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.056]                 }
[13:37:43.056]                 if (length(args) > 0) 
[13:37:43.056]                   base::do.call(base::Sys.setenv, args = args)
[13:37:43.056]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:43.056]             }
[13:37:43.056]             else {
[13:37:43.056]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:43.056]             }
[13:37:43.056]             {
[13:37:43.056]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:43.056]                   0L) {
[13:37:43.056]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:43.056]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:43.056]                   base::options(opts)
[13:37:43.056]                 }
[13:37:43.056]                 {
[13:37:43.056]                   {
[13:37:43.056]                     NULL
[13:37:43.056]                     RNGkind("Mersenne-Twister")
[13:37:43.056]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:37:43.056]                       inherits = FALSE)
[13:37:43.056]                   }
[13:37:43.056]                   options(future.plan = NULL)
[13:37:43.056]                   if (is.na(NA_character_)) 
[13:37:43.056]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.056]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:43.056]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:43.056]                     .init = FALSE)
[13:37:43.056]                 }
[13:37:43.056]             }
[13:37:43.056]         }
[13:37:43.056]     })
[13:37:43.056]     if (TRUE) {
[13:37:43.056]         base::sink(type = "output", split = FALSE)
[13:37:43.056]         if (TRUE) {
[13:37:43.056]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:43.056]         }
[13:37:43.056]         else {
[13:37:43.056]             ...future.result["stdout"] <- base::list(NULL)
[13:37:43.056]         }
[13:37:43.056]         base::close(...future.stdout)
[13:37:43.056]         ...future.stdout <- NULL
[13:37:43.056]     }
[13:37:43.056]     ...future.result$conditions <- ...future.conditions
[13:37:43.056]     ...future.result$finished <- base::Sys.time()
[13:37:43.056]     ...future.result
[13:37:43.056] }
[13:37:43.058] plan(): Setting new future strategy stack:
[13:37:43.058] List of future strategies:
[13:37:43.058] 1. sequential:
[13:37:43.058]    - args: function (..., envir = parent.frame())
[13:37:43.058]    - tweaked: FALSE
[13:37:43.058]    - call: NULL
[13:37:43.058] plan(): nbrOfWorkers() = 1
[13:37:43.059] plan(): Setting new future strategy stack:
[13:37:43.059] List of future strategies:
[13:37:43.059] 1. sequential:
[13:37:43.059]    - args: function (..., envir = parent.frame())
[13:37:43.059]    - tweaked: FALSE
[13:37:43.059]    - call: plan(strategy)
[13:37:43.059] plan(): nbrOfWorkers() = 1
[13:37:43.060] SequentialFuture started (and completed)
[13:37:43.060] - Launch lazy future ... done
[13:37:43.060] run() for ‘SequentialFuture’ ... done
[13:37:43.060] resolve() on environment ...
[13:37:43.060]  recursive: 0
[13:37:43.061]  elements: [3] ‘a’, ‘b’, ‘c’
[13:37:43.061] resolved() for ‘SequentialFuture’ ...
[13:37:43.061] - state: ‘finished’
[13:37:43.061] - run: TRUE
[13:37:43.061] - result: ‘FutureResult’
[13:37:43.061] resolved() for ‘SequentialFuture’ ... done
[13:37:43.062] Future #1
[13:37:43.062]  length: 2 (resolved future 1)
[13:37:43.062] resolved() for ‘SequentialFuture’ ...
[13:37:43.062] - state: ‘finished’
[13:37:43.062] - run: TRUE
[13:37:43.062] - result: ‘FutureResult’
[13:37:43.062] resolved() for ‘SequentialFuture’ ... done
[13:37:43.062] Future #2
[13:37:43.062]  length: 1 (resolved future 2)
[13:37:43.062]  length: 0 (resolved future 3)
[13:37:43.063] resolve() on environment ... DONE
[13:37:43.063] resolved() for ‘SequentialFuture’ ...
[13:37:43.063] - state: ‘finished’
[13:37:43.063] - run: TRUE
[13:37:43.063] - result: ‘FutureResult’
[13:37:43.063] resolved() for ‘SequentialFuture’ ... done
[13:37:43.063] resolved() for ‘SequentialFuture’ ...
[13:37:43.063] - state: ‘finished’
[13:37:43.063] - run: TRUE
[13:37:43.063] - result: ‘FutureResult’
[13:37:43.063] resolved() for ‘SequentialFuture’ ... done
[13:37:43.067] getGlobalsAndPackages() ...
[13:37:43.067] Searching for globals...
[13:37:43.068] - globals found: [1] ‘{’
[13:37:43.068] Searching for globals ... DONE
[13:37:43.068] Resolving globals: FALSE
[13:37:43.068] 
[13:37:43.068] 
[13:37:43.068] getGlobalsAndPackages() ... DONE
[13:37:43.069] run() for ‘Future’ ...
[13:37:43.069] - state: ‘created’
[13:37:43.069] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:37:43.069] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:37:43.069] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:37:43.069]   - Field: ‘label’
[13:37:43.069]   - Field: ‘local’
[13:37:43.069]   - Field: ‘owner’
[13:37:43.070]   - Field: ‘envir’
[13:37:43.070]   - Field: ‘packages’
[13:37:43.070]   - Field: ‘gc’
[13:37:43.070]   - Field: ‘conditions’
[13:37:43.070]   - Field: ‘expr’
[13:37:43.070]   - Field: ‘uuid’
[13:37:43.070]   - Field: ‘seed’
[13:37:43.070]   - Field: ‘version’
[13:37:43.070]   - Field: ‘result’
[13:37:43.070]   - Field: ‘asynchronous’
[13:37:43.071]   - Field: ‘calls’
[13:37:43.071]   - Field: ‘globals’
[13:37:43.071]   - Field: ‘stdout’
[13:37:43.071]   - Field: ‘earlySignal’
[13:37:43.071]   - Field: ‘lazy’
[13:37:43.071]   - Field: ‘state’
[13:37:43.071] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:37:43.071] - Launch lazy future ...
[13:37:43.071] Packages needed by the future expression (n = 0): <none>
[13:37:43.072] Packages needed by future strategies (n = 0): <none>
[13:37:43.072] {
[13:37:43.072]     {
[13:37:43.072]         {
[13:37:43.072]             ...future.startTime <- base::Sys.time()
[13:37:43.072]             {
[13:37:43.072]                 {
[13:37:43.072]                   {
[13:37:43.072]                     base::local({
[13:37:43.072]                       has_future <- base::requireNamespace("future", 
[13:37:43.072]                         quietly = TRUE)
[13:37:43.072]                       if (has_future) {
[13:37:43.072]                         ns <- base::getNamespace("future")
[13:37:43.072]                         version <- ns[[".package"]][["version"]]
[13:37:43.072]                         if (is.null(version)) 
[13:37:43.072]                           version <- utils::packageVersion("future")
[13:37:43.072]                       }
[13:37:43.072]                       else {
[13:37:43.072]                         version <- NULL
[13:37:43.072]                       }
[13:37:43.072]                       if (!has_future || version < "1.8.0") {
[13:37:43.072]                         info <- base::c(r_version = base::gsub("R version ", 
[13:37:43.072]                           "", base::R.version$version.string), 
[13:37:43.072]                           platform = base::sprintf("%s (%s-bit)", 
[13:37:43.072]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:43.072]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:43.072]                             "release", "version")], collapse = " "), 
[13:37:43.072]                           hostname = base::Sys.info()[["nodename"]])
[13:37:43.072]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:37:43.072]                           info)
[13:37:43.072]                         info <- base::paste(info, collapse = "; ")
[13:37:43.072]                         if (!has_future) {
[13:37:43.072]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:43.072]                             info)
[13:37:43.072]                         }
[13:37:43.072]                         else {
[13:37:43.072]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:43.072]                             info, version)
[13:37:43.072]                         }
[13:37:43.072]                         base::stop(msg)
[13:37:43.072]                       }
[13:37:43.072]                     })
[13:37:43.072]                   }
[13:37:43.072]                   ...future.strategy.old <- future::plan("list")
[13:37:43.072]                   options(future.plan = NULL)
[13:37:43.072]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.072]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:43.072]                 }
[13:37:43.072]                 ...future.workdir <- getwd()
[13:37:43.072]             }
[13:37:43.072]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:43.072]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:43.072]         }
[13:37:43.072]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:43.072]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:43.072]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:43.072]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:43.072]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:43.072]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:43.072]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:43.072]             base::names(...future.oldOptions))
[13:37:43.072]     }
[13:37:43.072]     if (FALSE) {
[13:37:43.072]     }
[13:37:43.072]     else {
[13:37:43.072]         if (TRUE) {
[13:37:43.072]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:43.072]                 open = "w")
[13:37:43.072]         }
[13:37:43.072]         else {
[13:37:43.072]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:43.072]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:43.072]         }
[13:37:43.072]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:43.072]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:43.072]             base::sink(type = "output", split = FALSE)
[13:37:43.072]             base::close(...future.stdout)
[13:37:43.072]         }, add = TRUE)
[13:37:43.072]     }
[13:37:43.072]     ...future.frame <- base::sys.nframe()
[13:37:43.072]     ...future.conditions <- base::list()
[13:37:43.072]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:43.072]     if (FALSE) {
[13:37:43.072]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:43.072]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:43.072]     }
[13:37:43.072]     ...future.result <- base::tryCatch({
[13:37:43.072]         base::withCallingHandlers({
[13:37:43.072]             ...future.value <- base::withVisible(base::local({
[13:37:43.072]                 1
[13:37:43.072]             }))
[13:37:43.072]             future::FutureResult(value = ...future.value$value, 
[13:37:43.072]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.072]                   ...future.rng), globalenv = if (FALSE) 
[13:37:43.072]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:43.072]                     ...future.globalenv.names))
[13:37:43.072]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:43.072]         }, condition = base::local({
[13:37:43.072]             c <- base::c
[13:37:43.072]             inherits <- base::inherits
[13:37:43.072]             invokeRestart <- base::invokeRestart
[13:37:43.072]             length <- base::length
[13:37:43.072]             list <- base::list
[13:37:43.072]             seq.int <- base::seq.int
[13:37:43.072]             signalCondition <- base::signalCondition
[13:37:43.072]             sys.calls <- base::sys.calls
[13:37:43.072]             `[[` <- base::`[[`
[13:37:43.072]             `+` <- base::`+`
[13:37:43.072]             `<<-` <- base::`<<-`
[13:37:43.072]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:43.072]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:43.072]                   3L)]
[13:37:43.072]             }
[13:37:43.072]             function(cond) {
[13:37:43.072]                 is_error <- inherits(cond, "error")
[13:37:43.072]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:43.072]                   NULL)
[13:37:43.072]                 if (is_error) {
[13:37:43.072]                   sessionInformation <- function() {
[13:37:43.072]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:43.072]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:43.072]                       search = base::search(), system = base::Sys.info())
[13:37:43.072]                   }
[13:37:43.072]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.072]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:43.072]                     cond$call), session = sessionInformation(), 
[13:37:43.072]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:43.072]                   signalCondition(cond)
[13:37:43.072]                 }
[13:37:43.072]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:43.072]                 "immediateCondition"))) {
[13:37:43.072]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:43.072]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.072]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:43.072]                   if (TRUE && !signal) {
[13:37:43.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.072]                     {
[13:37:43.072]                       inherits <- base::inherits
[13:37:43.072]                       invokeRestart <- base::invokeRestart
[13:37:43.072]                       is.null <- base::is.null
[13:37:43.072]                       muffled <- FALSE
[13:37:43.072]                       if (inherits(cond, "message")) {
[13:37:43.072]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.072]                         if (muffled) 
[13:37:43.072]                           invokeRestart("muffleMessage")
[13:37:43.072]                       }
[13:37:43.072]                       else if (inherits(cond, "warning")) {
[13:37:43.072]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.072]                         if (muffled) 
[13:37:43.072]                           invokeRestart("muffleWarning")
[13:37:43.072]                       }
[13:37:43.072]                       else if (inherits(cond, "condition")) {
[13:37:43.072]                         if (!is.null(pattern)) {
[13:37:43.072]                           computeRestarts <- base::computeRestarts
[13:37:43.072]                           grepl <- base::grepl
[13:37:43.072]                           restarts <- computeRestarts(cond)
[13:37:43.072]                           for (restart in restarts) {
[13:37:43.072]                             name <- restart$name
[13:37:43.072]                             if (is.null(name)) 
[13:37:43.072]                               next
[13:37:43.072]                             if (!grepl(pattern, name)) 
[13:37:43.072]                               next
[13:37:43.072]                             invokeRestart(restart)
[13:37:43.072]                             muffled <- TRUE
[13:37:43.072]                             break
[13:37:43.072]                           }
[13:37:43.072]                         }
[13:37:43.072]                       }
[13:37:43.072]                       invisible(muffled)
[13:37:43.072]                     }
[13:37:43.072]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.072]                   }
[13:37:43.072]                 }
[13:37:43.072]                 else {
[13:37:43.072]                   if (TRUE) {
[13:37:43.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.072]                     {
[13:37:43.072]                       inherits <- base::inherits
[13:37:43.072]                       invokeRestart <- base::invokeRestart
[13:37:43.072]                       is.null <- base::is.null
[13:37:43.072]                       muffled <- FALSE
[13:37:43.072]                       if (inherits(cond, "message")) {
[13:37:43.072]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.072]                         if (muffled) 
[13:37:43.072]                           invokeRestart("muffleMessage")
[13:37:43.072]                       }
[13:37:43.072]                       else if (inherits(cond, "warning")) {
[13:37:43.072]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.072]                         if (muffled) 
[13:37:43.072]                           invokeRestart("muffleWarning")
[13:37:43.072]                       }
[13:37:43.072]                       else if (inherits(cond, "condition")) {
[13:37:43.072]                         if (!is.null(pattern)) {
[13:37:43.072]                           computeRestarts <- base::computeRestarts
[13:37:43.072]                           grepl <- base::grepl
[13:37:43.072]                           restarts <- computeRestarts(cond)
[13:37:43.072]                           for (restart in restarts) {
[13:37:43.072]                             name <- restart$name
[13:37:43.072]                             if (is.null(name)) 
[13:37:43.072]                               next
[13:37:43.072]                             if (!grepl(pattern, name)) 
[13:37:43.072]                               next
[13:37:43.072]                             invokeRestart(restart)
[13:37:43.072]                             muffled <- TRUE
[13:37:43.072]                             break
[13:37:43.072]                           }
[13:37:43.072]                         }
[13:37:43.072]                       }
[13:37:43.072]                       invisible(muffled)
[13:37:43.072]                     }
[13:37:43.072]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.072]                   }
[13:37:43.072]                 }
[13:37:43.072]             }
[13:37:43.072]         }))
[13:37:43.072]     }, error = function(ex) {
[13:37:43.072]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:43.072]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.072]                 ...future.rng), started = ...future.startTime, 
[13:37:43.072]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:43.072]             version = "1.8"), class = "FutureResult")
[13:37:43.072]     }, finally = {
[13:37:43.072]         if (!identical(...future.workdir, getwd())) 
[13:37:43.072]             setwd(...future.workdir)
[13:37:43.072]         {
[13:37:43.072]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:43.072]                 ...future.oldOptions$nwarnings <- NULL
[13:37:43.072]             }
[13:37:43.072]             base::options(...future.oldOptions)
[13:37:43.072]             if (.Platform$OS.type == "windows") {
[13:37:43.072]                 old_names <- names(...future.oldEnvVars)
[13:37:43.072]                 envs <- base::Sys.getenv()
[13:37:43.072]                 names <- names(envs)
[13:37:43.072]                 common <- intersect(names, old_names)
[13:37:43.072]                 added <- setdiff(names, old_names)
[13:37:43.072]                 removed <- setdiff(old_names, names)
[13:37:43.072]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:43.072]                   envs[common]]
[13:37:43.072]                 NAMES <- toupper(changed)
[13:37:43.072]                 args <- list()
[13:37:43.072]                 for (kk in seq_along(NAMES)) {
[13:37:43.072]                   name <- changed[[kk]]
[13:37:43.072]                   NAME <- NAMES[[kk]]
[13:37:43.072]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.072]                     next
[13:37:43.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.072]                 }
[13:37:43.072]                 NAMES <- toupper(added)
[13:37:43.072]                 for (kk in seq_along(NAMES)) {
[13:37:43.072]                   name <- added[[kk]]
[13:37:43.072]                   NAME <- NAMES[[kk]]
[13:37:43.072]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.072]                     next
[13:37:43.072]                   args[[name]] <- ""
[13:37:43.072]                 }
[13:37:43.072]                 NAMES <- toupper(removed)
[13:37:43.072]                 for (kk in seq_along(NAMES)) {
[13:37:43.072]                   name <- removed[[kk]]
[13:37:43.072]                   NAME <- NAMES[[kk]]
[13:37:43.072]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.072]                     next
[13:37:43.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.072]                 }
[13:37:43.072]                 if (length(args) > 0) 
[13:37:43.072]                   base::do.call(base::Sys.setenv, args = args)
[13:37:43.072]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:43.072]             }
[13:37:43.072]             else {
[13:37:43.072]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:43.072]             }
[13:37:43.072]             {
[13:37:43.072]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:43.072]                   0L) {
[13:37:43.072]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:43.072]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:43.072]                   base::options(opts)
[13:37:43.072]                 }
[13:37:43.072]                 {
[13:37:43.072]                   {
[13:37:43.072]                     NULL
[13:37:43.072]                     RNGkind("Mersenne-Twister")
[13:37:43.072]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:37:43.072]                       inherits = FALSE)
[13:37:43.072]                   }
[13:37:43.072]                   options(future.plan = NULL)
[13:37:43.072]                   if (is.na(NA_character_)) 
[13:37:43.072]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.072]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:43.072]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:43.072]                     .init = FALSE)
[13:37:43.072]                 }
[13:37:43.072]             }
[13:37:43.072]         }
[13:37:43.072]     })
[13:37:43.072]     if (TRUE) {
[13:37:43.072]         base::sink(type = "output", split = FALSE)
[13:37:43.072]         if (TRUE) {
[13:37:43.072]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:43.072]         }
[13:37:43.072]         else {
[13:37:43.072]             ...future.result["stdout"] <- base::list(NULL)
[13:37:43.072]         }
[13:37:43.072]         base::close(...future.stdout)
[13:37:43.072]         ...future.stdout <- NULL
[13:37:43.072]     }
[13:37:43.072]     ...future.result$conditions <- ...future.conditions
[13:37:43.072]     ...future.result$finished <- base::Sys.time()
[13:37:43.072]     ...future.result
[13:37:43.072] }
[13:37:43.074] plan(): Setting new future strategy stack:
[13:37:43.074] List of future strategies:
[13:37:43.074] 1. sequential:
[13:37:43.074]    - args: function (..., envir = parent.frame())
[13:37:43.074]    - tweaked: FALSE
[13:37:43.074]    - call: NULL
[13:37:43.074] plan(): nbrOfWorkers() = 1
[13:37:43.075] plan(): Setting new future strategy stack:
[13:37:43.075] List of future strategies:
[13:37:43.075] 1. sequential:
[13:37:43.075]    - args: function (..., envir = parent.frame())
[13:37:43.075]    - tweaked: FALSE
[13:37:43.075]    - call: plan(strategy)
[13:37:43.076] plan(): nbrOfWorkers() = 1
[13:37:43.076] SequentialFuture started (and completed)
[13:37:43.076] - Launch lazy future ... done
[13:37:43.076] run() for ‘SequentialFuture’ ... done
[13:37:43.077] getGlobalsAndPackages() ...
[13:37:43.077] Searching for globals...
[13:37:43.077] - globals found: [1] ‘{’
[13:37:43.077] Searching for globals ... DONE
[13:37:43.078] Resolving globals: FALSE
[13:37:43.078] 
[13:37:43.078] 
[13:37:43.078] getGlobalsAndPackages() ... DONE
[13:37:43.078] run() for ‘Future’ ...
[13:37:43.078] - state: ‘created’
[13:37:43.079] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:37:43.079] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:37:43.079] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:37:43.079]   - Field: ‘label’
[13:37:43.079]   - Field: ‘local’
[13:37:43.079]   - Field: ‘owner’
[13:37:43.079]   - Field: ‘envir’
[13:37:43.079]   - Field: ‘packages’
[13:37:43.080]   - Field: ‘gc’
[13:37:43.080]   - Field: ‘conditions’
[13:37:43.080]   - Field: ‘expr’
[13:37:43.080]   - Field: ‘uuid’
[13:37:43.080]   - Field: ‘seed’
[13:37:43.080]   - Field: ‘version’
[13:37:43.080]   - Field: ‘result’
[13:37:43.080]   - Field: ‘asynchronous’
[13:37:43.080]   - Field: ‘calls’
[13:37:43.080]   - Field: ‘globals’
[13:37:43.080]   - Field: ‘stdout’
[13:37:43.081]   - Field: ‘earlySignal’
[13:37:43.081]   - Field: ‘lazy’
[13:37:43.081]   - Field: ‘state’
[13:37:43.081] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:37:43.081] - Launch lazy future ...
[13:37:43.081] Packages needed by the future expression (n = 0): <none>
[13:37:43.081] Packages needed by future strategies (n = 0): <none>
[13:37:43.082] {
[13:37:43.082]     {
[13:37:43.082]         {
[13:37:43.082]             ...future.startTime <- base::Sys.time()
[13:37:43.082]             {
[13:37:43.082]                 {
[13:37:43.082]                   {
[13:37:43.082]                     base::local({
[13:37:43.082]                       has_future <- base::requireNamespace("future", 
[13:37:43.082]                         quietly = TRUE)
[13:37:43.082]                       if (has_future) {
[13:37:43.082]                         ns <- base::getNamespace("future")
[13:37:43.082]                         version <- ns[[".package"]][["version"]]
[13:37:43.082]                         if (is.null(version)) 
[13:37:43.082]                           version <- utils::packageVersion("future")
[13:37:43.082]                       }
[13:37:43.082]                       else {
[13:37:43.082]                         version <- NULL
[13:37:43.082]                       }
[13:37:43.082]                       if (!has_future || version < "1.8.0") {
[13:37:43.082]                         info <- base::c(r_version = base::gsub("R version ", 
[13:37:43.082]                           "", base::R.version$version.string), 
[13:37:43.082]                           platform = base::sprintf("%s (%s-bit)", 
[13:37:43.082]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:43.082]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:43.082]                             "release", "version")], collapse = " "), 
[13:37:43.082]                           hostname = base::Sys.info()[["nodename"]])
[13:37:43.082]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:37:43.082]                           info)
[13:37:43.082]                         info <- base::paste(info, collapse = "; ")
[13:37:43.082]                         if (!has_future) {
[13:37:43.082]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:43.082]                             info)
[13:37:43.082]                         }
[13:37:43.082]                         else {
[13:37:43.082]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:43.082]                             info, version)
[13:37:43.082]                         }
[13:37:43.082]                         base::stop(msg)
[13:37:43.082]                       }
[13:37:43.082]                     })
[13:37:43.082]                   }
[13:37:43.082]                   ...future.strategy.old <- future::plan("list")
[13:37:43.082]                   options(future.plan = NULL)
[13:37:43.082]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.082]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:43.082]                 }
[13:37:43.082]                 ...future.workdir <- getwd()
[13:37:43.082]             }
[13:37:43.082]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:43.082]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:43.082]         }
[13:37:43.082]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:43.082]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:43.082]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:43.082]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:43.082]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:43.082]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:43.082]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:43.082]             base::names(...future.oldOptions))
[13:37:43.082]     }
[13:37:43.082]     if (FALSE) {
[13:37:43.082]     }
[13:37:43.082]     else {
[13:37:43.082]         if (TRUE) {
[13:37:43.082]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:43.082]                 open = "w")
[13:37:43.082]         }
[13:37:43.082]         else {
[13:37:43.082]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:43.082]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:43.082]         }
[13:37:43.082]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:43.082]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:43.082]             base::sink(type = "output", split = FALSE)
[13:37:43.082]             base::close(...future.stdout)
[13:37:43.082]         }, add = TRUE)
[13:37:43.082]     }
[13:37:43.082]     ...future.frame <- base::sys.nframe()
[13:37:43.082]     ...future.conditions <- base::list()
[13:37:43.082]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:43.082]     if (FALSE) {
[13:37:43.082]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:43.082]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:43.082]     }
[13:37:43.082]     ...future.result <- base::tryCatch({
[13:37:43.082]         base::withCallingHandlers({
[13:37:43.082]             ...future.value <- base::withVisible(base::local({
[13:37:43.082]                 2
[13:37:43.082]             }))
[13:37:43.082]             future::FutureResult(value = ...future.value$value, 
[13:37:43.082]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.082]                   ...future.rng), globalenv = if (FALSE) 
[13:37:43.082]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:43.082]                     ...future.globalenv.names))
[13:37:43.082]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:43.082]         }, condition = base::local({
[13:37:43.082]             c <- base::c
[13:37:43.082]             inherits <- base::inherits
[13:37:43.082]             invokeRestart <- base::invokeRestart
[13:37:43.082]             length <- base::length
[13:37:43.082]             list <- base::list
[13:37:43.082]             seq.int <- base::seq.int
[13:37:43.082]             signalCondition <- base::signalCondition
[13:37:43.082]             sys.calls <- base::sys.calls
[13:37:43.082]             `[[` <- base::`[[`
[13:37:43.082]             `+` <- base::`+`
[13:37:43.082]             `<<-` <- base::`<<-`
[13:37:43.082]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:43.082]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:43.082]                   3L)]
[13:37:43.082]             }
[13:37:43.082]             function(cond) {
[13:37:43.082]                 is_error <- inherits(cond, "error")
[13:37:43.082]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:43.082]                   NULL)
[13:37:43.082]                 if (is_error) {
[13:37:43.082]                   sessionInformation <- function() {
[13:37:43.082]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:43.082]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:43.082]                       search = base::search(), system = base::Sys.info())
[13:37:43.082]                   }
[13:37:43.082]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.082]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:43.082]                     cond$call), session = sessionInformation(), 
[13:37:43.082]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:43.082]                   signalCondition(cond)
[13:37:43.082]                 }
[13:37:43.082]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:43.082]                 "immediateCondition"))) {
[13:37:43.082]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:43.082]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.082]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:43.082]                   if (TRUE && !signal) {
[13:37:43.082]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.082]                     {
[13:37:43.082]                       inherits <- base::inherits
[13:37:43.082]                       invokeRestart <- base::invokeRestart
[13:37:43.082]                       is.null <- base::is.null
[13:37:43.082]                       muffled <- FALSE
[13:37:43.082]                       if (inherits(cond, "message")) {
[13:37:43.082]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.082]                         if (muffled) 
[13:37:43.082]                           invokeRestart("muffleMessage")
[13:37:43.082]                       }
[13:37:43.082]                       else if (inherits(cond, "warning")) {
[13:37:43.082]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.082]                         if (muffled) 
[13:37:43.082]                           invokeRestart("muffleWarning")
[13:37:43.082]                       }
[13:37:43.082]                       else if (inherits(cond, "condition")) {
[13:37:43.082]                         if (!is.null(pattern)) {
[13:37:43.082]                           computeRestarts <- base::computeRestarts
[13:37:43.082]                           grepl <- base::grepl
[13:37:43.082]                           restarts <- computeRestarts(cond)
[13:37:43.082]                           for (restart in restarts) {
[13:37:43.082]                             name <- restart$name
[13:37:43.082]                             if (is.null(name)) 
[13:37:43.082]                               next
[13:37:43.082]                             if (!grepl(pattern, name)) 
[13:37:43.082]                               next
[13:37:43.082]                             invokeRestart(restart)
[13:37:43.082]                             muffled <- TRUE
[13:37:43.082]                             break
[13:37:43.082]                           }
[13:37:43.082]                         }
[13:37:43.082]                       }
[13:37:43.082]                       invisible(muffled)
[13:37:43.082]                     }
[13:37:43.082]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.082]                   }
[13:37:43.082]                 }
[13:37:43.082]                 else {
[13:37:43.082]                   if (TRUE) {
[13:37:43.082]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.082]                     {
[13:37:43.082]                       inherits <- base::inherits
[13:37:43.082]                       invokeRestart <- base::invokeRestart
[13:37:43.082]                       is.null <- base::is.null
[13:37:43.082]                       muffled <- FALSE
[13:37:43.082]                       if (inherits(cond, "message")) {
[13:37:43.082]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.082]                         if (muffled) 
[13:37:43.082]                           invokeRestart("muffleMessage")
[13:37:43.082]                       }
[13:37:43.082]                       else if (inherits(cond, "warning")) {
[13:37:43.082]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.082]                         if (muffled) 
[13:37:43.082]                           invokeRestart("muffleWarning")
[13:37:43.082]                       }
[13:37:43.082]                       else if (inherits(cond, "condition")) {
[13:37:43.082]                         if (!is.null(pattern)) {
[13:37:43.082]                           computeRestarts <- base::computeRestarts
[13:37:43.082]                           grepl <- base::grepl
[13:37:43.082]                           restarts <- computeRestarts(cond)
[13:37:43.082]                           for (restart in restarts) {
[13:37:43.082]                             name <- restart$name
[13:37:43.082]                             if (is.null(name)) 
[13:37:43.082]                               next
[13:37:43.082]                             if (!grepl(pattern, name)) 
[13:37:43.082]                               next
[13:37:43.082]                             invokeRestart(restart)
[13:37:43.082]                             muffled <- TRUE
[13:37:43.082]                             break
[13:37:43.082]                           }
[13:37:43.082]                         }
[13:37:43.082]                       }
[13:37:43.082]                       invisible(muffled)
[13:37:43.082]                     }
[13:37:43.082]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.082]                   }
[13:37:43.082]                 }
[13:37:43.082]             }
[13:37:43.082]         }))
[13:37:43.082]     }, error = function(ex) {
[13:37:43.082]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:43.082]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.082]                 ...future.rng), started = ...future.startTime, 
[13:37:43.082]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:43.082]             version = "1.8"), class = "FutureResult")
[13:37:43.082]     }, finally = {
[13:37:43.082]         if (!identical(...future.workdir, getwd())) 
[13:37:43.082]             setwd(...future.workdir)
[13:37:43.082]         {
[13:37:43.082]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:43.082]                 ...future.oldOptions$nwarnings <- NULL
[13:37:43.082]             }
[13:37:43.082]             base::options(...future.oldOptions)
[13:37:43.082]             if (.Platform$OS.type == "windows") {
[13:37:43.082]                 old_names <- names(...future.oldEnvVars)
[13:37:43.082]                 envs <- base::Sys.getenv()
[13:37:43.082]                 names <- names(envs)
[13:37:43.082]                 common <- intersect(names, old_names)
[13:37:43.082]                 added <- setdiff(names, old_names)
[13:37:43.082]                 removed <- setdiff(old_names, names)
[13:37:43.082]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:43.082]                   envs[common]]
[13:37:43.082]                 NAMES <- toupper(changed)
[13:37:43.082]                 args <- list()
[13:37:43.082]                 for (kk in seq_along(NAMES)) {
[13:37:43.082]                   name <- changed[[kk]]
[13:37:43.082]                   NAME <- NAMES[[kk]]
[13:37:43.082]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.082]                     next
[13:37:43.082]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.082]                 }
[13:37:43.082]                 NAMES <- toupper(added)
[13:37:43.082]                 for (kk in seq_along(NAMES)) {
[13:37:43.082]                   name <- added[[kk]]
[13:37:43.082]                   NAME <- NAMES[[kk]]
[13:37:43.082]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.082]                     next
[13:37:43.082]                   args[[name]] <- ""
[13:37:43.082]                 }
[13:37:43.082]                 NAMES <- toupper(removed)
[13:37:43.082]                 for (kk in seq_along(NAMES)) {
[13:37:43.082]                   name <- removed[[kk]]
[13:37:43.082]                   NAME <- NAMES[[kk]]
[13:37:43.082]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.082]                     next
[13:37:43.082]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.082]                 }
[13:37:43.082]                 if (length(args) > 0) 
[13:37:43.082]                   base::do.call(base::Sys.setenv, args = args)
[13:37:43.082]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:43.082]             }
[13:37:43.082]             else {
[13:37:43.082]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:43.082]             }
[13:37:43.082]             {
[13:37:43.082]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:43.082]                   0L) {
[13:37:43.082]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:43.082]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:43.082]                   base::options(opts)
[13:37:43.082]                 }
[13:37:43.082]                 {
[13:37:43.082]                   {
[13:37:43.082]                     NULL
[13:37:43.082]                     RNGkind("Mersenne-Twister")
[13:37:43.082]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:37:43.082]                       inherits = FALSE)
[13:37:43.082]                   }
[13:37:43.082]                   options(future.plan = NULL)
[13:37:43.082]                   if (is.na(NA_character_)) 
[13:37:43.082]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.082]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:43.082]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:43.082]                     .init = FALSE)
[13:37:43.082]                 }
[13:37:43.082]             }
[13:37:43.082]         }
[13:37:43.082]     })
[13:37:43.082]     if (TRUE) {
[13:37:43.082]         base::sink(type = "output", split = FALSE)
[13:37:43.082]         if (TRUE) {
[13:37:43.082]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:43.082]         }
[13:37:43.082]         else {
[13:37:43.082]             ...future.result["stdout"] <- base::list(NULL)
[13:37:43.082]         }
[13:37:43.082]         base::close(...future.stdout)
[13:37:43.082]         ...future.stdout <- NULL
[13:37:43.082]     }
[13:37:43.082]     ...future.result$conditions <- ...future.conditions
[13:37:43.082]     ...future.result$finished <- base::Sys.time()
[13:37:43.082]     ...future.result
[13:37:43.082] }
[13:37:43.084] plan(): Setting new future strategy stack:
[13:37:43.084] List of future strategies:
[13:37:43.084] 1. sequential:
[13:37:43.084]    - args: function (..., envir = parent.frame())
[13:37:43.084]    - tweaked: FALSE
[13:37:43.084]    - call: NULL
[13:37:43.084] plan(): nbrOfWorkers() = 1
[13:37:43.085] plan(): Setting new future strategy stack:
[13:37:43.085] List of future strategies:
[13:37:43.085] 1. sequential:
[13:37:43.085]    - args: function (..., envir = parent.frame())
[13:37:43.085]    - tweaked: FALSE
[13:37:43.085]    - call: plan(strategy)
[13:37:43.085] plan(): nbrOfWorkers() = 1
[13:37:43.086] SequentialFuture started (and completed)
[13:37:43.086] - Launch lazy future ... done
[13:37:43.086] run() for ‘SequentialFuture’ ... done
[13:37:43.086] resolve() on environment ...
[13:37:43.086]  recursive: 0
[13:37:43.087]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[13:37:43.087] resolved() for ‘SequentialFuture’ ...
[13:37:43.087] - state: ‘finished’
[13:37:43.087] - run: TRUE
[13:37:43.087] - result: ‘FutureResult’
[13:37:43.087] resolved() for ‘SequentialFuture’ ... done
[13:37:43.088] Future #1
[13:37:43.088]  length: 2 (resolved future 1)
[13:37:43.088] resolved() for ‘SequentialFuture’ ...
[13:37:43.088] - state: ‘finished’
[13:37:43.088] - run: TRUE
[13:37:43.088] - result: ‘FutureResult’
[13:37:43.088] resolved() for ‘SequentialFuture’ ... done
[13:37:43.088] Future #2
[13:37:43.088]  length: 1 (resolved future 2)
[13:37:43.088]  length: 0 (resolved future 3)
[13:37:43.089] resolve() on environment ... DONE
[13:37:43.089] getGlobalsAndPackages() ...
[13:37:43.089] Searching for globals...
[13:37:43.090] - globals found: [1] ‘{’
[13:37:43.090] Searching for globals ... DONE
[13:37:43.090] Resolving globals: FALSE
[13:37:43.090] 
[13:37:43.090] 
[13:37:43.090] getGlobalsAndPackages() ... DONE
[13:37:43.091] run() for ‘Future’ ...
[13:37:43.091] - state: ‘created’
[13:37:43.091] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:37:43.091] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:37:43.091] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:37:43.091]   - Field: ‘label’
[13:37:43.091]   - Field: ‘local’
[13:37:43.092]   - Field: ‘owner’
[13:37:43.092]   - Field: ‘envir’
[13:37:43.092]   - Field: ‘packages’
[13:37:43.092]   - Field: ‘gc’
[13:37:43.092]   - Field: ‘conditions’
[13:37:43.092]   - Field: ‘expr’
[13:37:43.092]   - Field: ‘uuid’
[13:37:43.092]   - Field: ‘seed’
[13:37:43.092]   - Field: ‘version’
[13:37:43.092]   - Field: ‘result’
[13:37:43.093]   - Field: ‘asynchronous’
[13:37:43.093]   - Field: ‘calls’
[13:37:43.093]   - Field: ‘globals’
[13:37:43.093]   - Field: ‘stdout’
[13:37:43.093]   - Field: ‘earlySignal’
[13:37:43.093]   - Field: ‘lazy’
[13:37:43.093]   - Field: ‘state’
[13:37:43.093] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:37:43.093] - Launch lazy future ...
[13:37:43.093] Packages needed by the future expression (n = 0): <none>
[13:37:43.094] Packages needed by future strategies (n = 0): <none>
[13:37:43.096] {
[13:37:43.096]     {
[13:37:43.096]         {
[13:37:43.096]             ...future.startTime <- base::Sys.time()
[13:37:43.096]             {
[13:37:43.096]                 {
[13:37:43.096]                   {
[13:37:43.096]                     base::local({
[13:37:43.096]                       has_future <- base::requireNamespace("future", 
[13:37:43.096]                         quietly = TRUE)
[13:37:43.096]                       if (has_future) {
[13:37:43.096]                         ns <- base::getNamespace("future")
[13:37:43.096]                         version <- ns[[".package"]][["version"]]
[13:37:43.096]                         if (is.null(version)) 
[13:37:43.096]                           version <- utils::packageVersion("future")
[13:37:43.096]                       }
[13:37:43.096]                       else {
[13:37:43.096]                         version <- NULL
[13:37:43.096]                       }
[13:37:43.096]                       if (!has_future || version < "1.8.0") {
[13:37:43.096]                         info <- base::c(r_version = base::gsub("R version ", 
[13:37:43.096]                           "", base::R.version$version.string), 
[13:37:43.096]                           platform = base::sprintf("%s (%s-bit)", 
[13:37:43.096]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:43.096]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:43.096]                             "release", "version")], collapse = " "), 
[13:37:43.096]                           hostname = base::Sys.info()[["nodename"]])
[13:37:43.096]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:37:43.096]                           info)
[13:37:43.096]                         info <- base::paste(info, collapse = "; ")
[13:37:43.096]                         if (!has_future) {
[13:37:43.096]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:43.096]                             info)
[13:37:43.096]                         }
[13:37:43.096]                         else {
[13:37:43.096]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:43.096]                             info, version)
[13:37:43.096]                         }
[13:37:43.096]                         base::stop(msg)
[13:37:43.096]                       }
[13:37:43.096]                     })
[13:37:43.096]                   }
[13:37:43.096]                   ...future.strategy.old <- future::plan("list")
[13:37:43.096]                   options(future.plan = NULL)
[13:37:43.096]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.096]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:43.096]                 }
[13:37:43.096]                 ...future.workdir <- getwd()
[13:37:43.096]             }
[13:37:43.096]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:43.096]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:43.096]         }
[13:37:43.096]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:43.096]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:43.096]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:43.096]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:43.096]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:43.096]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:43.096]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:43.096]             base::names(...future.oldOptions))
[13:37:43.096]     }
[13:37:43.096]     if (FALSE) {
[13:37:43.096]     }
[13:37:43.096]     else {
[13:37:43.096]         if (TRUE) {
[13:37:43.096]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:43.096]                 open = "w")
[13:37:43.096]         }
[13:37:43.096]         else {
[13:37:43.096]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:43.096]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:43.096]         }
[13:37:43.096]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:43.096]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:43.096]             base::sink(type = "output", split = FALSE)
[13:37:43.096]             base::close(...future.stdout)
[13:37:43.096]         }, add = TRUE)
[13:37:43.096]     }
[13:37:43.096]     ...future.frame <- base::sys.nframe()
[13:37:43.096]     ...future.conditions <- base::list()
[13:37:43.096]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:43.096]     if (FALSE) {
[13:37:43.096]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:43.096]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:43.096]     }
[13:37:43.096]     ...future.result <- base::tryCatch({
[13:37:43.096]         base::withCallingHandlers({
[13:37:43.096]             ...future.value <- base::withVisible(base::local({
[13:37:43.096]                 1
[13:37:43.096]             }))
[13:37:43.096]             future::FutureResult(value = ...future.value$value, 
[13:37:43.096]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.096]                   ...future.rng), globalenv = if (FALSE) 
[13:37:43.096]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:43.096]                     ...future.globalenv.names))
[13:37:43.096]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:43.096]         }, condition = base::local({
[13:37:43.096]             c <- base::c
[13:37:43.096]             inherits <- base::inherits
[13:37:43.096]             invokeRestart <- base::invokeRestart
[13:37:43.096]             length <- base::length
[13:37:43.096]             list <- base::list
[13:37:43.096]             seq.int <- base::seq.int
[13:37:43.096]             signalCondition <- base::signalCondition
[13:37:43.096]             sys.calls <- base::sys.calls
[13:37:43.096]             `[[` <- base::`[[`
[13:37:43.096]             `+` <- base::`+`
[13:37:43.096]             `<<-` <- base::`<<-`
[13:37:43.096]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:43.096]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:43.096]                   3L)]
[13:37:43.096]             }
[13:37:43.096]             function(cond) {
[13:37:43.096]                 is_error <- inherits(cond, "error")
[13:37:43.096]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:43.096]                   NULL)
[13:37:43.096]                 if (is_error) {
[13:37:43.096]                   sessionInformation <- function() {
[13:37:43.096]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:43.096]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:43.096]                       search = base::search(), system = base::Sys.info())
[13:37:43.096]                   }
[13:37:43.096]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.096]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:43.096]                     cond$call), session = sessionInformation(), 
[13:37:43.096]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:43.096]                   signalCondition(cond)
[13:37:43.096]                 }
[13:37:43.096]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:43.096]                 "immediateCondition"))) {
[13:37:43.096]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:43.096]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.096]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:43.096]                   if (TRUE && !signal) {
[13:37:43.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.096]                     {
[13:37:43.096]                       inherits <- base::inherits
[13:37:43.096]                       invokeRestart <- base::invokeRestart
[13:37:43.096]                       is.null <- base::is.null
[13:37:43.096]                       muffled <- FALSE
[13:37:43.096]                       if (inherits(cond, "message")) {
[13:37:43.096]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.096]                         if (muffled) 
[13:37:43.096]                           invokeRestart("muffleMessage")
[13:37:43.096]                       }
[13:37:43.096]                       else if (inherits(cond, "warning")) {
[13:37:43.096]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.096]                         if (muffled) 
[13:37:43.096]                           invokeRestart("muffleWarning")
[13:37:43.096]                       }
[13:37:43.096]                       else if (inherits(cond, "condition")) {
[13:37:43.096]                         if (!is.null(pattern)) {
[13:37:43.096]                           computeRestarts <- base::computeRestarts
[13:37:43.096]                           grepl <- base::grepl
[13:37:43.096]                           restarts <- computeRestarts(cond)
[13:37:43.096]                           for (restart in restarts) {
[13:37:43.096]                             name <- restart$name
[13:37:43.096]                             if (is.null(name)) 
[13:37:43.096]                               next
[13:37:43.096]                             if (!grepl(pattern, name)) 
[13:37:43.096]                               next
[13:37:43.096]                             invokeRestart(restart)
[13:37:43.096]                             muffled <- TRUE
[13:37:43.096]                             break
[13:37:43.096]                           }
[13:37:43.096]                         }
[13:37:43.096]                       }
[13:37:43.096]                       invisible(muffled)
[13:37:43.096]                     }
[13:37:43.096]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.096]                   }
[13:37:43.096]                 }
[13:37:43.096]                 else {
[13:37:43.096]                   if (TRUE) {
[13:37:43.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.096]                     {
[13:37:43.096]                       inherits <- base::inherits
[13:37:43.096]                       invokeRestart <- base::invokeRestart
[13:37:43.096]                       is.null <- base::is.null
[13:37:43.096]                       muffled <- FALSE
[13:37:43.096]                       if (inherits(cond, "message")) {
[13:37:43.096]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.096]                         if (muffled) 
[13:37:43.096]                           invokeRestart("muffleMessage")
[13:37:43.096]                       }
[13:37:43.096]                       else if (inherits(cond, "warning")) {
[13:37:43.096]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.096]                         if (muffled) 
[13:37:43.096]                           invokeRestart("muffleWarning")
[13:37:43.096]                       }
[13:37:43.096]                       else if (inherits(cond, "condition")) {
[13:37:43.096]                         if (!is.null(pattern)) {
[13:37:43.096]                           computeRestarts <- base::computeRestarts
[13:37:43.096]                           grepl <- base::grepl
[13:37:43.096]                           restarts <- computeRestarts(cond)
[13:37:43.096]                           for (restart in restarts) {
[13:37:43.096]                             name <- restart$name
[13:37:43.096]                             if (is.null(name)) 
[13:37:43.096]                               next
[13:37:43.096]                             if (!grepl(pattern, name)) 
[13:37:43.096]                               next
[13:37:43.096]                             invokeRestart(restart)
[13:37:43.096]                             muffled <- TRUE
[13:37:43.096]                             break
[13:37:43.096]                           }
[13:37:43.096]                         }
[13:37:43.096]                       }
[13:37:43.096]                       invisible(muffled)
[13:37:43.096]                     }
[13:37:43.096]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.096]                   }
[13:37:43.096]                 }
[13:37:43.096]             }
[13:37:43.096]         }))
[13:37:43.096]     }, error = function(ex) {
[13:37:43.096]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:43.096]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.096]                 ...future.rng), started = ...future.startTime, 
[13:37:43.096]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:43.096]             version = "1.8"), class = "FutureResult")
[13:37:43.096]     }, finally = {
[13:37:43.096]         if (!identical(...future.workdir, getwd())) 
[13:37:43.096]             setwd(...future.workdir)
[13:37:43.096]         {
[13:37:43.096]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:43.096]                 ...future.oldOptions$nwarnings <- NULL
[13:37:43.096]             }
[13:37:43.096]             base::options(...future.oldOptions)
[13:37:43.096]             if (.Platform$OS.type == "windows") {
[13:37:43.096]                 old_names <- names(...future.oldEnvVars)
[13:37:43.096]                 envs <- base::Sys.getenv()
[13:37:43.096]                 names <- names(envs)
[13:37:43.096]                 common <- intersect(names, old_names)
[13:37:43.096]                 added <- setdiff(names, old_names)
[13:37:43.096]                 removed <- setdiff(old_names, names)
[13:37:43.096]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:43.096]                   envs[common]]
[13:37:43.096]                 NAMES <- toupper(changed)
[13:37:43.096]                 args <- list()
[13:37:43.096]                 for (kk in seq_along(NAMES)) {
[13:37:43.096]                   name <- changed[[kk]]
[13:37:43.096]                   NAME <- NAMES[[kk]]
[13:37:43.096]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.096]                     next
[13:37:43.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.096]                 }
[13:37:43.096]                 NAMES <- toupper(added)
[13:37:43.096]                 for (kk in seq_along(NAMES)) {
[13:37:43.096]                   name <- added[[kk]]
[13:37:43.096]                   NAME <- NAMES[[kk]]
[13:37:43.096]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.096]                     next
[13:37:43.096]                   args[[name]] <- ""
[13:37:43.096]                 }
[13:37:43.096]                 NAMES <- toupper(removed)
[13:37:43.096]                 for (kk in seq_along(NAMES)) {
[13:37:43.096]                   name <- removed[[kk]]
[13:37:43.096]                   NAME <- NAMES[[kk]]
[13:37:43.096]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.096]                     next
[13:37:43.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.096]                 }
[13:37:43.096]                 if (length(args) > 0) 
[13:37:43.096]                   base::do.call(base::Sys.setenv, args = args)
[13:37:43.096]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:43.096]             }
[13:37:43.096]             else {
[13:37:43.096]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:43.096]             }
[13:37:43.096]             {
[13:37:43.096]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:43.096]                   0L) {
[13:37:43.096]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:43.096]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:43.096]                   base::options(opts)
[13:37:43.096]                 }
[13:37:43.096]                 {
[13:37:43.096]                   {
[13:37:43.096]                     NULL
[13:37:43.096]                     RNGkind("Mersenne-Twister")
[13:37:43.096]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:37:43.096]                       inherits = FALSE)
[13:37:43.096]                   }
[13:37:43.096]                   options(future.plan = NULL)
[13:37:43.096]                   if (is.na(NA_character_)) 
[13:37:43.096]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.096]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:43.096]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:43.096]                     .init = FALSE)
[13:37:43.096]                 }
[13:37:43.096]             }
[13:37:43.096]         }
[13:37:43.096]     })
[13:37:43.096]     if (TRUE) {
[13:37:43.096]         base::sink(type = "output", split = FALSE)
[13:37:43.096]         if (TRUE) {
[13:37:43.096]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:43.096]         }
[13:37:43.096]         else {
[13:37:43.096]             ...future.result["stdout"] <- base::list(NULL)
[13:37:43.096]         }
[13:37:43.096]         base::close(...future.stdout)
[13:37:43.096]         ...future.stdout <- NULL
[13:37:43.096]     }
[13:37:43.096]     ...future.result$conditions <- ...future.conditions
[13:37:43.096]     ...future.result$finished <- base::Sys.time()
[13:37:43.096]     ...future.result
[13:37:43.096] }
[13:37:43.099] plan(): Setting new future strategy stack:
[13:37:43.099] List of future strategies:
[13:37:43.099] 1. sequential:
[13:37:43.099]    - args: function (..., envir = parent.frame())
[13:37:43.099]    - tweaked: FALSE
[13:37:43.099]    - call: NULL
[13:37:43.099] plan(): nbrOfWorkers() = 1
[13:37:43.100] plan(): Setting new future strategy stack:
[13:37:43.100] List of future strategies:
[13:37:43.100] 1. sequential:
[13:37:43.100]    - args: function (..., envir = parent.frame())
[13:37:43.100]    - tweaked: FALSE
[13:37:43.100]    - call: plan(strategy)
[13:37:43.100] plan(): nbrOfWorkers() = 1
[13:37:43.101] SequentialFuture started (and completed)
[13:37:43.101] - Launch lazy future ... done
[13:37:43.101] run() for ‘SequentialFuture’ ... done
[13:37:43.101] getGlobalsAndPackages() ...
[13:37:43.101] Searching for globals...
[13:37:43.102] - globals found: [1] ‘{’
[13:37:43.102] Searching for globals ... DONE
[13:37:43.102] Resolving globals: FALSE
[13:37:43.102] 
[13:37:43.103] 
[13:37:43.103] getGlobalsAndPackages() ... DONE
[13:37:43.103] run() for ‘Future’ ...
[13:37:43.103] - state: ‘created’
[13:37:43.103] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:37:43.103] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:37:43.104] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:37:43.104]   - Field: ‘label’
[13:37:43.104]   - Field: ‘local’
[13:37:43.104]   - Field: ‘owner’
[13:37:43.104]   - Field: ‘envir’
[13:37:43.104]   - Field: ‘packages’
[13:37:43.104]   - Field: ‘gc’
[13:37:43.104]   - Field: ‘conditions’
[13:37:43.104]   - Field: ‘expr’
[13:37:43.104]   - Field: ‘uuid’
[13:37:43.105]   - Field: ‘seed’
[13:37:43.105]   - Field: ‘version’
[13:37:43.105]   - Field: ‘result’
[13:37:43.105]   - Field: ‘asynchronous’
[13:37:43.105]   - Field: ‘calls’
[13:37:43.105]   - Field: ‘globals’
[13:37:43.105]   - Field: ‘stdout’
[13:37:43.105]   - Field: ‘earlySignal’
[13:37:43.105]   - Field: ‘lazy’
[13:37:43.105]   - Field: ‘state’
[13:37:43.105] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:37:43.106] - Launch lazy future ...
[13:37:43.106] Packages needed by the future expression (n = 0): <none>
[13:37:43.106] Packages needed by future strategies (n = 0): <none>
[13:37:43.106] {
[13:37:43.106]     {
[13:37:43.106]         {
[13:37:43.106]             ...future.startTime <- base::Sys.time()
[13:37:43.106]             {
[13:37:43.106]                 {
[13:37:43.106]                   {
[13:37:43.106]                     base::local({
[13:37:43.106]                       has_future <- base::requireNamespace("future", 
[13:37:43.106]                         quietly = TRUE)
[13:37:43.106]                       if (has_future) {
[13:37:43.106]                         ns <- base::getNamespace("future")
[13:37:43.106]                         version <- ns[[".package"]][["version"]]
[13:37:43.106]                         if (is.null(version)) 
[13:37:43.106]                           version <- utils::packageVersion("future")
[13:37:43.106]                       }
[13:37:43.106]                       else {
[13:37:43.106]                         version <- NULL
[13:37:43.106]                       }
[13:37:43.106]                       if (!has_future || version < "1.8.0") {
[13:37:43.106]                         info <- base::c(r_version = base::gsub("R version ", 
[13:37:43.106]                           "", base::R.version$version.string), 
[13:37:43.106]                           platform = base::sprintf("%s (%s-bit)", 
[13:37:43.106]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:43.106]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:43.106]                             "release", "version")], collapse = " "), 
[13:37:43.106]                           hostname = base::Sys.info()[["nodename"]])
[13:37:43.106]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:37:43.106]                           info)
[13:37:43.106]                         info <- base::paste(info, collapse = "; ")
[13:37:43.106]                         if (!has_future) {
[13:37:43.106]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:43.106]                             info)
[13:37:43.106]                         }
[13:37:43.106]                         else {
[13:37:43.106]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:43.106]                             info, version)
[13:37:43.106]                         }
[13:37:43.106]                         base::stop(msg)
[13:37:43.106]                       }
[13:37:43.106]                     })
[13:37:43.106]                   }
[13:37:43.106]                   ...future.strategy.old <- future::plan("list")
[13:37:43.106]                   options(future.plan = NULL)
[13:37:43.106]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.106]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:43.106]                 }
[13:37:43.106]                 ...future.workdir <- getwd()
[13:37:43.106]             }
[13:37:43.106]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:43.106]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:43.106]         }
[13:37:43.106]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:43.106]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:43.106]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:43.106]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:43.106]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:43.106]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:43.106]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:43.106]             base::names(...future.oldOptions))
[13:37:43.106]     }
[13:37:43.106]     if (FALSE) {
[13:37:43.106]     }
[13:37:43.106]     else {
[13:37:43.106]         if (TRUE) {
[13:37:43.106]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:43.106]                 open = "w")
[13:37:43.106]         }
[13:37:43.106]         else {
[13:37:43.106]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:43.106]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:43.106]         }
[13:37:43.106]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:43.106]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:43.106]             base::sink(type = "output", split = FALSE)
[13:37:43.106]             base::close(...future.stdout)
[13:37:43.106]         }, add = TRUE)
[13:37:43.106]     }
[13:37:43.106]     ...future.frame <- base::sys.nframe()
[13:37:43.106]     ...future.conditions <- base::list()
[13:37:43.106]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:43.106]     if (FALSE) {
[13:37:43.106]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:43.106]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:43.106]     }
[13:37:43.106]     ...future.result <- base::tryCatch({
[13:37:43.106]         base::withCallingHandlers({
[13:37:43.106]             ...future.value <- base::withVisible(base::local({
[13:37:43.106]                 2
[13:37:43.106]             }))
[13:37:43.106]             future::FutureResult(value = ...future.value$value, 
[13:37:43.106]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.106]                   ...future.rng), globalenv = if (FALSE) 
[13:37:43.106]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:43.106]                     ...future.globalenv.names))
[13:37:43.106]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:43.106]         }, condition = base::local({
[13:37:43.106]             c <- base::c
[13:37:43.106]             inherits <- base::inherits
[13:37:43.106]             invokeRestart <- base::invokeRestart
[13:37:43.106]             length <- base::length
[13:37:43.106]             list <- base::list
[13:37:43.106]             seq.int <- base::seq.int
[13:37:43.106]             signalCondition <- base::signalCondition
[13:37:43.106]             sys.calls <- base::sys.calls
[13:37:43.106]             `[[` <- base::`[[`
[13:37:43.106]             `+` <- base::`+`
[13:37:43.106]             `<<-` <- base::`<<-`
[13:37:43.106]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:43.106]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:43.106]                   3L)]
[13:37:43.106]             }
[13:37:43.106]             function(cond) {
[13:37:43.106]                 is_error <- inherits(cond, "error")
[13:37:43.106]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:43.106]                   NULL)
[13:37:43.106]                 if (is_error) {
[13:37:43.106]                   sessionInformation <- function() {
[13:37:43.106]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:43.106]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:43.106]                       search = base::search(), system = base::Sys.info())
[13:37:43.106]                   }
[13:37:43.106]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.106]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:43.106]                     cond$call), session = sessionInformation(), 
[13:37:43.106]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:43.106]                   signalCondition(cond)
[13:37:43.106]                 }
[13:37:43.106]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:43.106]                 "immediateCondition"))) {
[13:37:43.106]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:43.106]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.106]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:43.106]                   if (TRUE && !signal) {
[13:37:43.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.106]                     {
[13:37:43.106]                       inherits <- base::inherits
[13:37:43.106]                       invokeRestart <- base::invokeRestart
[13:37:43.106]                       is.null <- base::is.null
[13:37:43.106]                       muffled <- FALSE
[13:37:43.106]                       if (inherits(cond, "message")) {
[13:37:43.106]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.106]                         if (muffled) 
[13:37:43.106]                           invokeRestart("muffleMessage")
[13:37:43.106]                       }
[13:37:43.106]                       else if (inherits(cond, "warning")) {
[13:37:43.106]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.106]                         if (muffled) 
[13:37:43.106]                           invokeRestart("muffleWarning")
[13:37:43.106]                       }
[13:37:43.106]                       else if (inherits(cond, "condition")) {
[13:37:43.106]                         if (!is.null(pattern)) {
[13:37:43.106]                           computeRestarts <- base::computeRestarts
[13:37:43.106]                           grepl <- base::grepl
[13:37:43.106]                           restarts <- computeRestarts(cond)
[13:37:43.106]                           for (restart in restarts) {
[13:37:43.106]                             name <- restart$name
[13:37:43.106]                             if (is.null(name)) 
[13:37:43.106]                               next
[13:37:43.106]                             if (!grepl(pattern, name)) 
[13:37:43.106]                               next
[13:37:43.106]                             invokeRestart(restart)
[13:37:43.106]                             muffled <- TRUE
[13:37:43.106]                             break
[13:37:43.106]                           }
[13:37:43.106]                         }
[13:37:43.106]                       }
[13:37:43.106]                       invisible(muffled)
[13:37:43.106]                     }
[13:37:43.106]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.106]                   }
[13:37:43.106]                 }
[13:37:43.106]                 else {
[13:37:43.106]                   if (TRUE) {
[13:37:43.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.106]                     {
[13:37:43.106]                       inherits <- base::inherits
[13:37:43.106]                       invokeRestart <- base::invokeRestart
[13:37:43.106]                       is.null <- base::is.null
[13:37:43.106]                       muffled <- FALSE
[13:37:43.106]                       if (inherits(cond, "message")) {
[13:37:43.106]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.106]                         if (muffled) 
[13:37:43.106]                           invokeRestart("muffleMessage")
[13:37:43.106]                       }
[13:37:43.106]                       else if (inherits(cond, "warning")) {
[13:37:43.106]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.106]                         if (muffled) 
[13:37:43.106]                           invokeRestart("muffleWarning")
[13:37:43.106]                       }
[13:37:43.106]                       else if (inherits(cond, "condition")) {
[13:37:43.106]                         if (!is.null(pattern)) {
[13:37:43.106]                           computeRestarts <- base::computeRestarts
[13:37:43.106]                           grepl <- base::grepl
[13:37:43.106]                           restarts <- computeRestarts(cond)
[13:37:43.106]                           for (restart in restarts) {
[13:37:43.106]                             name <- restart$name
[13:37:43.106]                             if (is.null(name)) 
[13:37:43.106]                               next
[13:37:43.106]                             if (!grepl(pattern, name)) 
[13:37:43.106]                               next
[13:37:43.106]                             invokeRestart(restart)
[13:37:43.106]                             muffled <- TRUE
[13:37:43.106]                             break
[13:37:43.106]                           }
[13:37:43.106]                         }
[13:37:43.106]                       }
[13:37:43.106]                       invisible(muffled)
[13:37:43.106]                     }
[13:37:43.106]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.106]                   }
[13:37:43.106]                 }
[13:37:43.106]             }
[13:37:43.106]         }))
[13:37:43.106]     }, error = function(ex) {
[13:37:43.106]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:43.106]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.106]                 ...future.rng), started = ...future.startTime, 
[13:37:43.106]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:43.106]             version = "1.8"), class = "FutureResult")
[13:37:43.106]     }, finally = {
[13:37:43.106]         if (!identical(...future.workdir, getwd())) 
[13:37:43.106]             setwd(...future.workdir)
[13:37:43.106]         {
[13:37:43.106]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:43.106]                 ...future.oldOptions$nwarnings <- NULL
[13:37:43.106]             }
[13:37:43.106]             base::options(...future.oldOptions)
[13:37:43.106]             if (.Platform$OS.type == "windows") {
[13:37:43.106]                 old_names <- names(...future.oldEnvVars)
[13:37:43.106]                 envs <- base::Sys.getenv()
[13:37:43.106]                 names <- names(envs)
[13:37:43.106]                 common <- intersect(names, old_names)
[13:37:43.106]                 added <- setdiff(names, old_names)
[13:37:43.106]                 removed <- setdiff(old_names, names)
[13:37:43.106]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:43.106]                   envs[common]]
[13:37:43.106]                 NAMES <- toupper(changed)
[13:37:43.106]                 args <- list()
[13:37:43.106]                 for (kk in seq_along(NAMES)) {
[13:37:43.106]                   name <- changed[[kk]]
[13:37:43.106]                   NAME <- NAMES[[kk]]
[13:37:43.106]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.106]                     next
[13:37:43.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.106]                 }
[13:37:43.106]                 NAMES <- toupper(added)
[13:37:43.106]                 for (kk in seq_along(NAMES)) {
[13:37:43.106]                   name <- added[[kk]]
[13:37:43.106]                   NAME <- NAMES[[kk]]
[13:37:43.106]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.106]                     next
[13:37:43.106]                   args[[name]] <- ""
[13:37:43.106]                 }
[13:37:43.106]                 NAMES <- toupper(removed)
[13:37:43.106]                 for (kk in seq_along(NAMES)) {
[13:37:43.106]                   name <- removed[[kk]]
[13:37:43.106]                   NAME <- NAMES[[kk]]
[13:37:43.106]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.106]                     next
[13:37:43.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.106]                 }
[13:37:43.106]                 if (length(args) > 0) 
[13:37:43.106]                   base::do.call(base::Sys.setenv, args = args)
[13:37:43.106]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:43.106]             }
[13:37:43.106]             else {
[13:37:43.106]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:43.106]             }
[13:37:43.106]             {
[13:37:43.106]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:43.106]                   0L) {
[13:37:43.106]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:43.106]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:43.106]                   base::options(opts)
[13:37:43.106]                 }
[13:37:43.106]                 {
[13:37:43.106]                   {
[13:37:43.106]                     NULL
[13:37:43.106]                     RNGkind("Mersenne-Twister")
[13:37:43.106]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:37:43.106]                       inherits = FALSE)
[13:37:43.106]                   }
[13:37:43.106]                   options(future.plan = NULL)
[13:37:43.106]                   if (is.na(NA_character_)) 
[13:37:43.106]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.106]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:43.106]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:43.106]                     .init = FALSE)
[13:37:43.106]                 }
[13:37:43.106]             }
[13:37:43.106]         }
[13:37:43.106]     })
[13:37:43.106]     if (TRUE) {
[13:37:43.106]         base::sink(type = "output", split = FALSE)
[13:37:43.106]         if (TRUE) {
[13:37:43.106]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:43.106]         }
[13:37:43.106]         else {
[13:37:43.106]             ...future.result["stdout"] <- base::list(NULL)
[13:37:43.106]         }
[13:37:43.106]         base::close(...future.stdout)
[13:37:43.106]         ...future.stdout <- NULL
[13:37:43.106]     }
[13:37:43.106]     ...future.result$conditions <- ...future.conditions
[13:37:43.106]     ...future.result$finished <- base::Sys.time()
[13:37:43.106]     ...future.result
[13:37:43.106] }
[13:37:43.108] plan(): Setting new future strategy stack:
[13:37:43.108] List of future strategies:
[13:37:43.108] 1. sequential:
[13:37:43.108]    - args: function (..., envir = parent.frame())
[13:37:43.108]    - tweaked: FALSE
[13:37:43.108]    - call: NULL
[13:37:43.109] plan(): nbrOfWorkers() = 1
[13:37:43.110] plan(): Setting new future strategy stack:
[13:37:43.110] List of future strategies:
[13:37:43.110] 1. sequential:
[13:37:43.110]    - args: function (..., envir = parent.frame())
[13:37:43.110]    - tweaked: FALSE
[13:37:43.110]    - call: plan(strategy)
[13:37:43.110] plan(): nbrOfWorkers() = 1
[13:37:43.110] SequentialFuture started (and completed)
[13:37:43.110] - Launch lazy future ... done
[13:37:43.111] run() for ‘SequentialFuture’ ... done
[13:37:43.111] resolve() on environment ...
[13:37:43.111]  recursive: 0
[13:37:43.112]  elements: [3] ‘a’
[13:37:43.112] resolved() for ‘SequentialFuture’ ...
[13:37:43.112] - state: ‘finished’
[13:37:43.112] - run: TRUE
[13:37:43.112] - result: ‘FutureResult’
[13:37:43.112] resolved() for ‘SequentialFuture’ ... done
[13:37:43.112] Future #1
[13:37:43.112]  length: 2 (resolved future 1)
[13:37:43.113] resolved() for ‘SequentialFuture’ ...
[13:37:43.113] - state: ‘finished’
[13:37:43.113] - run: TRUE
[13:37:43.113] - result: ‘FutureResult’
[13:37:43.113] resolved() for ‘SequentialFuture’ ... done
[13:37:43.113] Future #2
[13:37:43.113]  length: 1 (resolved future 2)
[13:37:43.113]  length: 0 (resolved future 3)
[13:37:43.113] resolve() on environment ... DONE
[13:37:43.113] resolved() for ‘SequentialFuture’ ...
[13:37:43.114] - state: ‘finished’
[13:37:43.114] - run: TRUE
[13:37:43.114] - result: ‘FutureResult’
[13:37:43.114] resolved() for ‘SequentialFuture’ ... done
[13:37:43.114] resolve() on environment ...
[13:37:43.114]  recursive: 0
[13:37:43.115]  elements: [3] ‘b’
[13:37:43.115] resolved() for ‘SequentialFuture’ ...
[13:37:43.115] - state: ‘finished’
[13:37:43.115] - run: TRUE
[13:37:43.115] - result: ‘FutureResult’
[13:37:43.115] resolved() for ‘SequentialFuture’ ... done
[13:37:43.116] Future #1
[13:37:43.116]  length: 2 (resolved future 1)
[13:37:43.116] resolved() for ‘SequentialFuture’ ...
[13:37:43.116] - state: ‘finished’
[13:37:43.116] - run: TRUE
[13:37:43.116] - result: ‘FutureResult’
[13:37:43.116] resolved() for ‘SequentialFuture’ ... done
[13:37:43.116] Future #2
[13:37:43.116]  length: 1 (resolved future 2)
[13:37:43.116]  length: 0 (resolved future 3)
[13:37:43.117] resolve() on environment ... DONE
[13:37:43.117] resolve() on environment ...
[13:37:43.117]  recursive: 0
[13:37:43.117]  elements: [3] ‘c’
[13:37:43.118] resolved() for ‘SequentialFuture’ ...
[13:37:43.118] - state: ‘finished’
[13:37:43.118] - run: TRUE
[13:37:43.118] - result: ‘FutureResult’
[13:37:43.118] resolved() for ‘SequentialFuture’ ... done
[13:37:43.118] Future #1
[13:37:43.118]  length: 2 (resolved future 1)
[13:37:43.118] resolved() for ‘SequentialFuture’ ...
[13:37:43.118] - state: ‘finished’
[13:37:43.119] - run: TRUE
[13:37:43.119] - result: ‘FutureResult’
[13:37:43.119] resolved() for ‘SequentialFuture’ ... done
[13:37:43.119] Future #2
[13:37:43.119]  length: 1 (resolved future 2)
[13:37:43.119]  length: 0 (resolved future 3)
[13:37:43.119] resolve() on environment ... DONE
[13:37:43.120] resolve() on environment ...
[13:37:43.120]  recursive: 0
[13:37:43.120]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[13:37:43.120] resolved() for ‘SequentialFuture’ ...
[13:37:43.120] - state: ‘finished’
[13:37:43.120] - run: TRUE
[13:37:43.120] - result: ‘FutureResult’
[13:37:43.121] resolved() for ‘SequentialFuture’ ... done
[13:37:43.121] Future #1
[13:37:43.121]  length: 2 (resolved future 1)
[13:37:43.121] resolved() for ‘SequentialFuture’ ...
[13:37:43.121] - state: ‘finished’
[13:37:43.122] - run: TRUE
[13:37:43.122] - result: ‘FutureResult’
[13:37:43.122] resolved() for ‘SequentialFuture’ ... done
[13:37:43.122] Future #2
[13:37:43.122]  length: 1 (resolved future 2)
[13:37:43.122]  length: 0 (resolved future 3)
[13:37:43.122] resolve() on environment ... DONE
[13:37:43.123] resolve() on environment ...
[13:37:43.123]  recursive: 99
[13:37:43.123]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[13:37:43.123] resolved() for ‘SequentialFuture’ ...
[13:37:43.124] - state: ‘finished’
[13:37:43.124] - run: TRUE
[13:37:43.126] - result: ‘FutureResult’
[13:37:43.126] resolved() for ‘SequentialFuture’ ... done
[13:37:43.127] Future #1
[13:37:43.127] resolved() for ‘SequentialFuture’ ...
[13:37:43.127] - state: ‘finished’
[13:37:43.127] - run: TRUE
[13:37:43.127] - result: ‘FutureResult’
[13:37:43.127] resolved() for ‘SequentialFuture’ ... done
[13:37:43.127] A SequentialFuture was resolved
[13:37:43.128]  length: 2 (resolved future 1)
[13:37:43.128] resolved() for ‘SequentialFuture’ ...
[13:37:43.128] - state: ‘finished’
[13:37:43.128] - run: TRUE
[13:37:43.128] - result: ‘FutureResult’
[13:37:43.128] resolved() for ‘SequentialFuture’ ... done
[13:37:43.128] Future #2
[13:37:43.128] resolved() for ‘SequentialFuture’ ...
[13:37:43.128] - state: ‘finished’
[13:37:43.129] - run: TRUE
[13:37:43.129] - result: ‘FutureResult’
[13:37:43.129] resolved() for ‘SequentialFuture’ ... done
[13:37:43.129] A SequentialFuture was resolved
[13:37:43.129]  length: 1 (resolved future 2)
[13:37:43.129]  length: 0 (resolved future 3)
[13:37:43.129] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[13:37:43.131] resolve() on list environment ...
[13:37:43.131]  recursive: 0
[13:37:43.132]  length: 2
[13:37:43.132]  elements: ‘a’, ‘b’
[13:37:43.132]  length: 1 (resolved future 1)
[13:37:43.132]  length: 0 (resolved future 2)
[13:37:43.132] resolve() on list environment ... DONE
[13:37:43.132] getGlobalsAndPackages() ...
[13:37:43.132] Searching for globals...
[13:37:43.133] 
[13:37:43.133] Searching for globals ... DONE
[13:37:43.133] - globals: [0] <none>
[13:37:43.133] getGlobalsAndPackages() ... DONE
[13:37:43.133] run() for ‘Future’ ...
[13:37:43.133] - state: ‘created’
[13:37:43.133] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:37:43.134] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:37:43.134] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:37:43.134]   - Field: ‘label’
[13:37:43.134]   - Field: ‘local’
[13:37:43.134]   - Field: ‘owner’
[13:37:43.134]   - Field: ‘envir’
[13:37:43.134]   - Field: ‘packages’
[13:37:43.135]   - Field: ‘gc’
[13:37:43.135]   - Field: ‘conditions’
[13:37:43.135]   - Field: ‘expr’
[13:37:43.135]   - Field: ‘uuid’
[13:37:43.135]   - Field: ‘seed’
[13:37:43.135]   - Field: ‘version’
[13:37:43.135]   - Field: ‘result’
[13:37:43.135]   - Field: ‘asynchronous’
[13:37:43.135]   - Field: ‘calls’
[13:37:43.135]   - Field: ‘globals’
[13:37:43.136]   - Field: ‘stdout’
[13:37:43.136]   - Field: ‘earlySignal’
[13:37:43.136]   - Field: ‘lazy’
[13:37:43.136]   - Field: ‘state’
[13:37:43.136] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:37:43.136] - Launch lazy future ...
[13:37:43.136] Packages needed by the future expression (n = 0): <none>
[13:37:43.136] Packages needed by future strategies (n = 0): <none>
[13:37:43.137] {
[13:37:43.137]     {
[13:37:43.137]         {
[13:37:43.137]             ...future.startTime <- base::Sys.time()
[13:37:43.137]             {
[13:37:43.137]                 {
[13:37:43.137]                   {
[13:37:43.137]                     base::local({
[13:37:43.137]                       has_future <- base::requireNamespace("future", 
[13:37:43.137]                         quietly = TRUE)
[13:37:43.137]                       if (has_future) {
[13:37:43.137]                         ns <- base::getNamespace("future")
[13:37:43.137]                         version <- ns[[".package"]][["version"]]
[13:37:43.137]                         if (is.null(version)) 
[13:37:43.137]                           version <- utils::packageVersion("future")
[13:37:43.137]                       }
[13:37:43.137]                       else {
[13:37:43.137]                         version <- NULL
[13:37:43.137]                       }
[13:37:43.137]                       if (!has_future || version < "1.8.0") {
[13:37:43.137]                         info <- base::c(r_version = base::gsub("R version ", 
[13:37:43.137]                           "", base::R.version$version.string), 
[13:37:43.137]                           platform = base::sprintf("%s (%s-bit)", 
[13:37:43.137]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:43.137]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:43.137]                             "release", "version")], collapse = " "), 
[13:37:43.137]                           hostname = base::Sys.info()[["nodename"]])
[13:37:43.137]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:37:43.137]                           info)
[13:37:43.137]                         info <- base::paste(info, collapse = "; ")
[13:37:43.137]                         if (!has_future) {
[13:37:43.137]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:43.137]                             info)
[13:37:43.137]                         }
[13:37:43.137]                         else {
[13:37:43.137]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:43.137]                             info, version)
[13:37:43.137]                         }
[13:37:43.137]                         base::stop(msg)
[13:37:43.137]                       }
[13:37:43.137]                     })
[13:37:43.137]                   }
[13:37:43.137]                   ...future.strategy.old <- future::plan("list")
[13:37:43.137]                   options(future.plan = NULL)
[13:37:43.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:43.137]                 }
[13:37:43.137]                 ...future.workdir <- getwd()
[13:37:43.137]             }
[13:37:43.137]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:43.137]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:43.137]         }
[13:37:43.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:43.137]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:43.137]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:43.137]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:43.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:43.137]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:43.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:43.137]             base::names(...future.oldOptions))
[13:37:43.137]     }
[13:37:43.137]     if (FALSE) {
[13:37:43.137]     }
[13:37:43.137]     else {
[13:37:43.137]         if (TRUE) {
[13:37:43.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:43.137]                 open = "w")
[13:37:43.137]         }
[13:37:43.137]         else {
[13:37:43.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:43.137]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:43.137]         }
[13:37:43.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:43.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:43.137]             base::sink(type = "output", split = FALSE)
[13:37:43.137]             base::close(...future.stdout)
[13:37:43.137]         }, add = TRUE)
[13:37:43.137]     }
[13:37:43.137]     ...future.frame <- base::sys.nframe()
[13:37:43.137]     ...future.conditions <- base::list()
[13:37:43.137]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:43.137]     if (FALSE) {
[13:37:43.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:43.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:43.137]     }
[13:37:43.137]     ...future.result <- base::tryCatch({
[13:37:43.137]         base::withCallingHandlers({
[13:37:43.137]             ...future.value <- base::withVisible(base::local(1))
[13:37:43.137]             future::FutureResult(value = ...future.value$value, 
[13:37:43.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.137]                   ...future.rng), globalenv = if (FALSE) 
[13:37:43.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:43.137]                     ...future.globalenv.names))
[13:37:43.137]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:43.137]         }, condition = base::local({
[13:37:43.137]             c <- base::c
[13:37:43.137]             inherits <- base::inherits
[13:37:43.137]             invokeRestart <- base::invokeRestart
[13:37:43.137]             length <- base::length
[13:37:43.137]             list <- base::list
[13:37:43.137]             seq.int <- base::seq.int
[13:37:43.137]             signalCondition <- base::signalCondition
[13:37:43.137]             sys.calls <- base::sys.calls
[13:37:43.137]             `[[` <- base::`[[`
[13:37:43.137]             `+` <- base::`+`
[13:37:43.137]             `<<-` <- base::`<<-`
[13:37:43.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:43.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:43.137]                   3L)]
[13:37:43.137]             }
[13:37:43.137]             function(cond) {
[13:37:43.137]                 is_error <- inherits(cond, "error")
[13:37:43.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:43.137]                   NULL)
[13:37:43.137]                 if (is_error) {
[13:37:43.137]                   sessionInformation <- function() {
[13:37:43.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:43.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:43.137]                       search = base::search(), system = base::Sys.info())
[13:37:43.137]                   }
[13:37:43.137]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:43.137]                     cond$call), session = sessionInformation(), 
[13:37:43.137]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:43.137]                   signalCondition(cond)
[13:37:43.137]                 }
[13:37:43.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:43.137]                 "immediateCondition"))) {
[13:37:43.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:43.137]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:43.137]                   if (TRUE && !signal) {
[13:37:43.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.137]                     {
[13:37:43.137]                       inherits <- base::inherits
[13:37:43.137]                       invokeRestart <- base::invokeRestart
[13:37:43.137]                       is.null <- base::is.null
[13:37:43.137]                       muffled <- FALSE
[13:37:43.137]                       if (inherits(cond, "message")) {
[13:37:43.137]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.137]                         if (muffled) 
[13:37:43.137]                           invokeRestart("muffleMessage")
[13:37:43.137]                       }
[13:37:43.137]                       else if (inherits(cond, "warning")) {
[13:37:43.137]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.137]                         if (muffled) 
[13:37:43.137]                           invokeRestart("muffleWarning")
[13:37:43.137]                       }
[13:37:43.137]                       else if (inherits(cond, "condition")) {
[13:37:43.137]                         if (!is.null(pattern)) {
[13:37:43.137]                           computeRestarts <- base::computeRestarts
[13:37:43.137]                           grepl <- base::grepl
[13:37:43.137]                           restarts <- computeRestarts(cond)
[13:37:43.137]                           for (restart in restarts) {
[13:37:43.137]                             name <- restart$name
[13:37:43.137]                             if (is.null(name)) 
[13:37:43.137]                               next
[13:37:43.137]                             if (!grepl(pattern, name)) 
[13:37:43.137]                               next
[13:37:43.137]                             invokeRestart(restart)
[13:37:43.137]                             muffled <- TRUE
[13:37:43.137]                             break
[13:37:43.137]                           }
[13:37:43.137]                         }
[13:37:43.137]                       }
[13:37:43.137]                       invisible(muffled)
[13:37:43.137]                     }
[13:37:43.137]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.137]                   }
[13:37:43.137]                 }
[13:37:43.137]                 else {
[13:37:43.137]                   if (TRUE) {
[13:37:43.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.137]                     {
[13:37:43.137]                       inherits <- base::inherits
[13:37:43.137]                       invokeRestart <- base::invokeRestart
[13:37:43.137]                       is.null <- base::is.null
[13:37:43.137]                       muffled <- FALSE
[13:37:43.137]                       if (inherits(cond, "message")) {
[13:37:43.137]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.137]                         if (muffled) 
[13:37:43.137]                           invokeRestart("muffleMessage")
[13:37:43.137]                       }
[13:37:43.137]                       else if (inherits(cond, "warning")) {
[13:37:43.137]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.137]                         if (muffled) 
[13:37:43.137]                           invokeRestart("muffleWarning")
[13:37:43.137]                       }
[13:37:43.137]                       else if (inherits(cond, "condition")) {
[13:37:43.137]                         if (!is.null(pattern)) {
[13:37:43.137]                           computeRestarts <- base::computeRestarts
[13:37:43.137]                           grepl <- base::grepl
[13:37:43.137]                           restarts <- computeRestarts(cond)
[13:37:43.137]                           for (restart in restarts) {
[13:37:43.137]                             name <- restart$name
[13:37:43.137]                             if (is.null(name)) 
[13:37:43.137]                               next
[13:37:43.137]                             if (!grepl(pattern, name)) 
[13:37:43.137]                               next
[13:37:43.137]                             invokeRestart(restart)
[13:37:43.137]                             muffled <- TRUE
[13:37:43.137]                             break
[13:37:43.137]                           }
[13:37:43.137]                         }
[13:37:43.137]                       }
[13:37:43.137]                       invisible(muffled)
[13:37:43.137]                     }
[13:37:43.137]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.137]                   }
[13:37:43.137]                 }
[13:37:43.137]             }
[13:37:43.137]         }))
[13:37:43.137]     }, error = function(ex) {
[13:37:43.137]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:43.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.137]                 ...future.rng), started = ...future.startTime, 
[13:37:43.137]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:43.137]             version = "1.8"), class = "FutureResult")
[13:37:43.137]     }, finally = {
[13:37:43.137]         if (!identical(...future.workdir, getwd())) 
[13:37:43.137]             setwd(...future.workdir)
[13:37:43.137]         {
[13:37:43.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:43.137]                 ...future.oldOptions$nwarnings <- NULL
[13:37:43.137]             }
[13:37:43.137]             base::options(...future.oldOptions)
[13:37:43.137]             if (.Platform$OS.type == "windows") {
[13:37:43.137]                 old_names <- names(...future.oldEnvVars)
[13:37:43.137]                 envs <- base::Sys.getenv()
[13:37:43.137]                 names <- names(envs)
[13:37:43.137]                 common <- intersect(names, old_names)
[13:37:43.137]                 added <- setdiff(names, old_names)
[13:37:43.137]                 removed <- setdiff(old_names, names)
[13:37:43.137]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:43.137]                   envs[common]]
[13:37:43.137]                 NAMES <- toupper(changed)
[13:37:43.137]                 args <- list()
[13:37:43.137]                 for (kk in seq_along(NAMES)) {
[13:37:43.137]                   name <- changed[[kk]]
[13:37:43.137]                   NAME <- NAMES[[kk]]
[13:37:43.137]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.137]                     next
[13:37:43.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.137]                 }
[13:37:43.137]                 NAMES <- toupper(added)
[13:37:43.137]                 for (kk in seq_along(NAMES)) {
[13:37:43.137]                   name <- added[[kk]]
[13:37:43.137]                   NAME <- NAMES[[kk]]
[13:37:43.137]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.137]                     next
[13:37:43.137]                   args[[name]] <- ""
[13:37:43.137]                 }
[13:37:43.137]                 NAMES <- toupper(removed)
[13:37:43.137]                 for (kk in seq_along(NAMES)) {
[13:37:43.137]                   name <- removed[[kk]]
[13:37:43.137]                   NAME <- NAMES[[kk]]
[13:37:43.137]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.137]                     next
[13:37:43.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.137]                 }
[13:37:43.137]                 if (length(args) > 0) 
[13:37:43.137]                   base::do.call(base::Sys.setenv, args = args)
[13:37:43.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:43.137]             }
[13:37:43.137]             else {
[13:37:43.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:43.137]             }
[13:37:43.137]             {
[13:37:43.137]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:43.137]                   0L) {
[13:37:43.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:43.137]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:43.137]                   base::options(opts)
[13:37:43.137]                 }
[13:37:43.137]                 {
[13:37:43.137]                   {
[13:37:43.137]                     NULL
[13:37:43.137]                     RNGkind("Mersenne-Twister")
[13:37:43.137]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:37:43.137]                       inherits = FALSE)
[13:37:43.137]                   }
[13:37:43.137]                   options(future.plan = NULL)
[13:37:43.137]                   if (is.na(NA_character_)) 
[13:37:43.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:43.137]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:43.137]                     .init = FALSE)
[13:37:43.137]                 }
[13:37:43.137]             }
[13:37:43.137]         }
[13:37:43.137]     })
[13:37:43.137]     if (TRUE) {
[13:37:43.137]         base::sink(type = "output", split = FALSE)
[13:37:43.137]         if (TRUE) {
[13:37:43.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:43.137]         }
[13:37:43.137]         else {
[13:37:43.137]             ...future.result["stdout"] <- base::list(NULL)
[13:37:43.137]         }
[13:37:43.137]         base::close(...future.stdout)
[13:37:43.137]         ...future.stdout <- NULL
[13:37:43.137]     }
[13:37:43.137]     ...future.result$conditions <- ...future.conditions
[13:37:43.137]     ...future.result$finished <- base::Sys.time()
[13:37:43.137]     ...future.result
[13:37:43.137] }
[13:37:43.139] plan(): Setting new future strategy stack:
[13:37:43.139] List of future strategies:
[13:37:43.139] 1. sequential:
[13:37:43.139]    - args: function (..., envir = parent.frame())
[13:37:43.139]    - tweaked: FALSE
[13:37:43.139]    - call: NULL
[13:37:43.139] plan(): nbrOfWorkers() = 1
[13:37:43.140] plan(): Setting new future strategy stack:
[13:37:43.140] List of future strategies:
[13:37:43.140] 1. sequential:
[13:37:43.140]    - args: function (..., envir = parent.frame())
[13:37:43.140]    - tweaked: FALSE
[13:37:43.140]    - call: plan(strategy)
[13:37:43.141] plan(): nbrOfWorkers() = 1
[13:37:43.141] SequentialFuture started (and completed)
[13:37:43.141] - Launch lazy future ... done
[13:37:43.141] run() for ‘SequentialFuture’ ... done
[13:37:43.141] getGlobalsAndPackages() ...
[13:37:43.141] Searching for globals...
[13:37:43.142] 
[13:37:43.142] Searching for globals ... DONE
[13:37:43.142] - globals: [0] <none>
[13:37:43.142] getGlobalsAndPackages() ... DONE
[13:37:43.142] run() for ‘Future’ ...
[13:37:43.142] - state: ‘created’
[13:37:43.143] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:37:43.143] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:37:43.143] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:37:43.143]   - Field: ‘label’
[13:37:43.143]   - Field: ‘local’
[13:37:43.143]   - Field: ‘owner’
[13:37:43.143]   - Field: ‘envir’
[13:37:43.144]   - Field: ‘packages’
[13:37:43.144]   - Field: ‘gc’
[13:37:43.144]   - Field: ‘conditions’
[13:37:43.144]   - Field: ‘expr’
[13:37:43.144]   - Field: ‘uuid’
[13:37:43.144]   - Field: ‘seed’
[13:37:43.144]   - Field: ‘version’
[13:37:43.144]   - Field: ‘result’
[13:37:43.144]   - Field: ‘asynchronous’
[13:37:43.144]   - Field: ‘calls’
[13:37:43.144]   - Field: ‘globals’
[13:37:43.145]   - Field: ‘stdout’
[13:37:43.145]   - Field: ‘earlySignal’
[13:37:43.145]   - Field: ‘lazy’
[13:37:43.145]   - Field: ‘state’
[13:37:43.145] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:37:43.145] - Launch lazy future ...
[13:37:43.145] Packages needed by the future expression (n = 0): <none>
[13:37:43.145] Packages needed by future strategies (n = 0): <none>
[13:37:43.146] {
[13:37:43.146]     {
[13:37:43.146]         {
[13:37:43.146]             ...future.startTime <- base::Sys.time()
[13:37:43.146]             {
[13:37:43.146]                 {
[13:37:43.146]                   {
[13:37:43.146]                     base::local({
[13:37:43.146]                       has_future <- base::requireNamespace("future", 
[13:37:43.146]                         quietly = TRUE)
[13:37:43.146]                       if (has_future) {
[13:37:43.146]                         ns <- base::getNamespace("future")
[13:37:43.146]                         version <- ns[[".package"]][["version"]]
[13:37:43.146]                         if (is.null(version)) 
[13:37:43.146]                           version <- utils::packageVersion("future")
[13:37:43.146]                       }
[13:37:43.146]                       else {
[13:37:43.146]                         version <- NULL
[13:37:43.146]                       }
[13:37:43.146]                       if (!has_future || version < "1.8.0") {
[13:37:43.146]                         info <- base::c(r_version = base::gsub("R version ", 
[13:37:43.146]                           "", base::R.version$version.string), 
[13:37:43.146]                           platform = base::sprintf("%s (%s-bit)", 
[13:37:43.146]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:43.146]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:43.146]                             "release", "version")], collapse = " "), 
[13:37:43.146]                           hostname = base::Sys.info()[["nodename"]])
[13:37:43.146]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:37:43.146]                           info)
[13:37:43.146]                         info <- base::paste(info, collapse = "; ")
[13:37:43.146]                         if (!has_future) {
[13:37:43.146]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:43.146]                             info)
[13:37:43.146]                         }
[13:37:43.146]                         else {
[13:37:43.146]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:43.146]                             info, version)
[13:37:43.146]                         }
[13:37:43.146]                         base::stop(msg)
[13:37:43.146]                       }
[13:37:43.146]                     })
[13:37:43.146]                   }
[13:37:43.146]                   ...future.strategy.old <- future::plan("list")
[13:37:43.146]                   options(future.plan = NULL)
[13:37:43.146]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.146]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:43.146]                 }
[13:37:43.146]                 ...future.workdir <- getwd()
[13:37:43.146]             }
[13:37:43.146]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:43.146]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:43.146]         }
[13:37:43.146]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:43.146]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:43.146]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:43.146]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:43.146]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:43.146]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:43.146]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:43.146]             base::names(...future.oldOptions))
[13:37:43.146]     }
[13:37:43.146]     if (FALSE) {
[13:37:43.146]     }
[13:37:43.146]     else {
[13:37:43.146]         if (TRUE) {
[13:37:43.146]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:43.146]                 open = "w")
[13:37:43.146]         }
[13:37:43.146]         else {
[13:37:43.146]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:43.146]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:43.146]         }
[13:37:43.146]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:43.146]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:43.146]             base::sink(type = "output", split = FALSE)
[13:37:43.146]             base::close(...future.stdout)
[13:37:43.146]         }, add = TRUE)
[13:37:43.146]     }
[13:37:43.146]     ...future.frame <- base::sys.nframe()
[13:37:43.146]     ...future.conditions <- base::list()
[13:37:43.146]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:43.146]     if (FALSE) {
[13:37:43.146]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:43.146]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:43.146]     }
[13:37:43.146]     ...future.result <- base::tryCatch({
[13:37:43.146]         base::withCallingHandlers({
[13:37:43.146]             ...future.value <- base::withVisible(base::local(2))
[13:37:43.146]             future::FutureResult(value = ...future.value$value, 
[13:37:43.146]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.146]                   ...future.rng), globalenv = if (FALSE) 
[13:37:43.146]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:43.146]                     ...future.globalenv.names))
[13:37:43.146]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:43.146]         }, condition = base::local({
[13:37:43.146]             c <- base::c
[13:37:43.146]             inherits <- base::inherits
[13:37:43.146]             invokeRestart <- base::invokeRestart
[13:37:43.146]             length <- base::length
[13:37:43.146]             list <- base::list
[13:37:43.146]             seq.int <- base::seq.int
[13:37:43.146]             signalCondition <- base::signalCondition
[13:37:43.146]             sys.calls <- base::sys.calls
[13:37:43.146]             `[[` <- base::`[[`
[13:37:43.146]             `+` <- base::`+`
[13:37:43.146]             `<<-` <- base::`<<-`
[13:37:43.146]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:43.146]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:43.146]                   3L)]
[13:37:43.146]             }
[13:37:43.146]             function(cond) {
[13:37:43.146]                 is_error <- inherits(cond, "error")
[13:37:43.146]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:43.146]                   NULL)
[13:37:43.146]                 if (is_error) {
[13:37:43.146]                   sessionInformation <- function() {
[13:37:43.146]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:43.146]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:43.146]                       search = base::search(), system = base::Sys.info())
[13:37:43.146]                   }
[13:37:43.146]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.146]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:43.146]                     cond$call), session = sessionInformation(), 
[13:37:43.146]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:43.146]                   signalCondition(cond)
[13:37:43.146]                 }
[13:37:43.146]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:43.146]                 "immediateCondition"))) {
[13:37:43.146]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:43.146]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.146]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:43.146]                   if (TRUE && !signal) {
[13:37:43.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.146]                     {
[13:37:43.146]                       inherits <- base::inherits
[13:37:43.146]                       invokeRestart <- base::invokeRestart
[13:37:43.146]                       is.null <- base::is.null
[13:37:43.146]                       muffled <- FALSE
[13:37:43.146]                       if (inherits(cond, "message")) {
[13:37:43.146]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.146]                         if (muffled) 
[13:37:43.146]                           invokeRestart("muffleMessage")
[13:37:43.146]                       }
[13:37:43.146]                       else if (inherits(cond, "warning")) {
[13:37:43.146]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.146]                         if (muffled) 
[13:37:43.146]                           invokeRestart("muffleWarning")
[13:37:43.146]                       }
[13:37:43.146]                       else if (inherits(cond, "condition")) {
[13:37:43.146]                         if (!is.null(pattern)) {
[13:37:43.146]                           computeRestarts <- base::computeRestarts
[13:37:43.146]                           grepl <- base::grepl
[13:37:43.146]                           restarts <- computeRestarts(cond)
[13:37:43.146]                           for (restart in restarts) {
[13:37:43.146]                             name <- restart$name
[13:37:43.146]                             if (is.null(name)) 
[13:37:43.146]                               next
[13:37:43.146]                             if (!grepl(pattern, name)) 
[13:37:43.146]                               next
[13:37:43.146]                             invokeRestart(restart)
[13:37:43.146]                             muffled <- TRUE
[13:37:43.146]                             break
[13:37:43.146]                           }
[13:37:43.146]                         }
[13:37:43.146]                       }
[13:37:43.146]                       invisible(muffled)
[13:37:43.146]                     }
[13:37:43.146]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.146]                   }
[13:37:43.146]                 }
[13:37:43.146]                 else {
[13:37:43.146]                   if (TRUE) {
[13:37:43.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.146]                     {
[13:37:43.146]                       inherits <- base::inherits
[13:37:43.146]                       invokeRestart <- base::invokeRestart
[13:37:43.146]                       is.null <- base::is.null
[13:37:43.146]                       muffled <- FALSE
[13:37:43.146]                       if (inherits(cond, "message")) {
[13:37:43.146]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.146]                         if (muffled) 
[13:37:43.146]                           invokeRestart("muffleMessage")
[13:37:43.146]                       }
[13:37:43.146]                       else if (inherits(cond, "warning")) {
[13:37:43.146]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.146]                         if (muffled) 
[13:37:43.146]                           invokeRestart("muffleWarning")
[13:37:43.146]                       }
[13:37:43.146]                       else if (inherits(cond, "condition")) {
[13:37:43.146]                         if (!is.null(pattern)) {
[13:37:43.146]                           computeRestarts <- base::computeRestarts
[13:37:43.146]                           grepl <- base::grepl
[13:37:43.146]                           restarts <- computeRestarts(cond)
[13:37:43.146]                           for (restart in restarts) {
[13:37:43.146]                             name <- restart$name
[13:37:43.146]                             if (is.null(name)) 
[13:37:43.146]                               next
[13:37:43.146]                             if (!grepl(pattern, name)) 
[13:37:43.146]                               next
[13:37:43.146]                             invokeRestart(restart)
[13:37:43.146]                             muffled <- TRUE
[13:37:43.146]                             break
[13:37:43.146]                           }
[13:37:43.146]                         }
[13:37:43.146]                       }
[13:37:43.146]                       invisible(muffled)
[13:37:43.146]                     }
[13:37:43.146]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.146]                   }
[13:37:43.146]                 }
[13:37:43.146]             }
[13:37:43.146]         }))
[13:37:43.146]     }, error = function(ex) {
[13:37:43.146]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:43.146]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.146]                 ...future.rng), started = ...future.startTime, 
[13:37:43.146]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:43.146]             version = "1.8"), class = "FutureResult")
[13:37:43.146]     }, finally = {
[13:37:43.146]         if (!identical(...future.workdir, getwd())) 
[13:37:43.146]             setwd(...future.workdir)
[13:37:43.146]         {
[13:37:43.146]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:43.146]                 ...future.oldOptions$nwarnings <- NULL
[13:37:43.146]             }
[13:37:43.146]             base::options(...future.oldOptions)
[13:37:43.146]             if (.Platform$OS.type == "windows") {
[13:37:43.146]                 old_names <- names(...future.oldEnvVars)
[13:37:43.146]                 envs <- base::Sys.getenv()
[13:37:43.146]                 names <- names(envs)
[13:37:43.146]                 common <- intersect(names, old_names)
[13:37:43.146]                 added <- setdiff(names, old_names)
[13:37:43.146]                 removed <- setdiff(old_names, names)
[13:37:43.146]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:43.146]                   envs[common]]
[13:37:43.146]                 NAMES <- toupper(changed)
[13:37:43.146]                 args <- list()
[13:37:43.146]                 for (kk in seq_along(NAMES)) {
[13:37:43.146]                   name <- changed[[kk]]
[13:37:43.146]                   NAME <- NAMES[[kk]]
[13:37:43.146]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.146]                     next
[13:37:43.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.146]                 }
[13:37:43.146]                 NAMES <- toupper(added)
[13:37:43.146]                 for (kk in seq_along(NAMES)) {
[13:37:43.146]                   name <- added[[kk]]
[13:37:43.146]                   NAME <- NAMES[[kk]]
[13:37:43.146]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.146]                     next
[13:37:43.146]                   args[[name]] <- ""
[13:37:43.146]                 }
[13:37:43.146]                 NAMES <- toupper(removed)
[13:37:43.146]                 for (kk in seq_along(NAMES)) {
[13:37:43.146]                   name <- removed[[kk]]
[13:37:43.146]                   NAME <- NAMES[[kk]]
[13:37:43.146]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.146]                     next
[13:37:43.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.146]                 }
[13:37:43.146]                 if (length(args) > 0) 
[13:37:43.146]                   base::do.call(base::Sys.setenv, args = args)
[13:37:43.146]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:43.146]             }
[13:37:43.146]             else {
[13:37:43.146]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:43.146]             }
[13:37:43.146]             {
[13:37:43.146]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:43.146]                   0L) {
[13:37:43.146]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:43.146]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:43.146]                   base::options(opts)
[13:37:43.146]                 }
[13:37:43.146]                 {
[13:37:43.146]                   {
[13:37:43.146]                     NULL
[13:37:43.146]                     RNGkind("Mersenne-Twister")
[13:37:43.146]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:37:43.146]                       inherits = FALSE)
[13:37:43.146]                   }
[13:37:43.146]                   options(future.plan = NULL)
[13:37:43.146]                   if (is.na(NA_character_)) 
[13:37:43.146]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.146]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:43.146]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:43.146]                     .init = FALSE)
[13:37:43.146]                 }
[13:37:43.146]             }
[13:37:43.146]         }
[13:37:43.146]     })
[13:37:43.146]     if (TRUE) {
[13:37:43.146]         base::sink(type = "output", split = FALSE)
[13:37:43.146]         if (TRUE) {
[13:37:43.146]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:43.146]         }
[13:37:43.146]         else {
[13:37:43.146]             ...future.result["stdout"] <- base::list(NULL)
[13:37:43.146]         }
[13:37:43.146]         base::close(...future.stdout)
[13:37:43.146]         ...future.stdout <- NULL
[13:37:43.146]     }
[13:37:43.146]     ...future.result$conditions <- ...future.conditions
[13:37:43.146]     ...future.result$finished <- base::Sys.time()
[13:37:43.146]     ...future.result
[13:37:43.146] }
[13:37:43.148] plan(): Setting new future strategy stack:
[13:37:43.148] List of future strategies:
[13:37:43.148] 1. sequential:
[13:37:43.148]    - args: function (..., envir = parent.frame())
[13:37:43.148]    - tweaked: FALSE
[13:37:43.148]    - call: NULL
[13:37:43.148] plan(): nbrOfWorkers() = 1
[13:37:43.149] plan(): Setting new future strategy stack:
[13:37:43.149] List of future strategies:
[13:37:43.149] 1. sequential:
[13:37:43.149]    - args: function (..., envir = parent.frame())
[13:37:43.149]    - tweaked: FALSE
[13:37:43.149]    - call: plan(strategy)
[13:37:43.149] plan(): nbrOfWorkers() = 1
[13:37:43.150] SequentialFuture started (and completed)
[13:37:43.150] - Launch lazy future ... done
[13:37:43.150] run() for ‘SequentialFuture’ ... done
[13:37:43.151] resolve() on list environment ...
[13:37:43.151]  recursive: 0
[13:37:43.151]  length: 3
[13:37:43.151]  elements: ‘a’, ‘b’, ‘c’
[13:37:43.152] resolved() for ‘SequentialFuture’ ...
[13:37:43.152] - state: ‘finished’
[13:37:43.152] - run: TRUE
[13:37:43.152] - result: ‘FutureResult’
[13:37:43.152] resolved() for ‘SequentialFuture’ ... done
[13:37:43.152] Future #1
[13:37:43.152]  length: 2 (resolved future 1)
[13:37:43.152] resolved() for ‘SequentialFuture’ ...
[13:37:43.152] - state: ‘finished’
[13:37:43.153] - run: TRUE
[13:37:43.153] - result: ‘FutureResult’
[13:37:43.153] resolved() for ‘SequentialFuture’ ... done
[13:37:43.153] Future #2
[13:37:43.153]  length: 1 (resolved future 2)
[13:37:43.153]  length: 0 (resolved future 3)
[13:37:43.153] resolve() on list environment ... DONE
[13:37:43.154] getGlobalsAndPackages() ...
[13:37:43.154] Searching for globals...
[13:37:43.158] - globals found: [1] ‘{’
[13:37:43.158] Searching for globals ... DONE
[13:37:43.158] Resolving globals: FALSE
[13:37:43.158] 
[13:37:43.158] 
[13:37:43.159] getGlobalsAndPackages() ... DONE
[13:37:43.159] run() for ‘Future’ ...
[13:37:43.159] - state: ‘created’
[13:37:43.159] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:37:43.159] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:37:43.159] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:37:43.160]   - Field: ‘label’
[13:37:43.160]   - Field: ‘local’
[13:37:43.160]   - Field: ‘owner’
[13:37:43.160]   - Field: ‘envir’
[13:37:43.160]   - Field: ‘packages’
[13:37:43.160]   - Field: ‘gc’
[13:37:43.160]   - Field: ‘conditions’
[13:37:43.160]   - Field: ‘expr’
[13:37:43.160]   - Field: ‘uuid’
[13:37:43.161]   - Field: ‘seed’
[13:37:43.161]   - Field: ‘version’
[13:37:43.161]   - Field: ‘result’
[13:37:43.161]   - Field: ‘asynchronous’
[13:37:43.161]   - Field: ‘calls’
[13:37:43.161]   - Field: ‘globals’
[13:37:43.161]   - Field: ‘stdout’
[13:37:43.161]   - Field: ‘earlySignal’
[13:37:43.161]   - Field: ‘lazy’
[13:37:43.161]   - Field: ‘state’
[13:37:43.162] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:37:43.162] - Launch lazy future ...
[13:37:43.162] Packages needed by the future expression (n = 0): <none>
[13:37:43.162] Packages needed by future strategies (n = 0): <none>
[13:37:43.162] {
[13:37:43.162]     {
[13:37:43.162]         {
[13:37:43.162]             ...future.startTime <- base::Sys.time()
[13:37:43.162]             {
[13:37:43.162]                 {
[13:37:43.162]                   {
[13:37:43.162]                     base::local({
[13:37:43.162]                       has_future <- base::requireNamespace("future", 
[13:37:43.162]                         quietly = TRUE)
[13:37:43.162]                       if (has_future) {
[13:37:43.162]                         ns <- base::getNamespace("future")
[13:37:43.162]                         version <- ns[[".package"]][["version"]]
[13:37:43.162]                         if (is.null(version)) 
[13:37:43.162]                           version <- utils::packageVersion("future")
[13:37:43.162]                       }
[13:37:43.162]                       else {
[13:37:43.162]                         version <- NULL
[13:37:43.162]                       }
[13:37:43.162]                       if (!has_future || version < "1.8.0") {
[13:37:43.162]                         info <- base::c(r_version = base::gsub("R version ", 
[13:37:43.162]                           "", base::R.version$version.string), 
[13:37:43.162]                           platform = base::sprintf("%s (%s-bit)", 
[13:37:43.162]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:43.162]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:43.162]                             "release", "version")], collapse = " "), 
[13:37:43.162]                           hostname = base::Sys.info()[["nodename"]])
[13:37:43.162]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:37:43.162]                           info)
[13:37:43.162]                         info <- base::paste(info, collapse = "; ")
[13:37:43.162]                         if (!has_future) {
[13:37:43.162]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:43.162]                             info)
[13:37:43.162]                         }
[13:37:43.162]                         else {
[13:37:43.162]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:43.162]                             info, version)
[13:37:43.162]                         }
[13:37:43.162]                         base::stop(msg)
[13:37:43.162]                       }
[13:37:43.162]                     })
[13:37:43.162]                   }
[13:37:43.162]                   ...future.strategy.old <- future::plan("list")
[13:37:43.162]                   options(future.plan = NULL)
[13:37:43.162]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.162]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:43.162]                 }
[13:37:43.162]                 ...future.workdir <- getwd()
[13:37:43.162]             }
[13:37:43.162]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:43.162]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:43.162]         }
[13:37:43.162]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:43.162]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:43.162]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:43.162]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:43.162]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:43.162]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:43.162]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:43.162]             base::names(...future.oldOptions))
[13:37:43.162]     }
[13:37:43.162]     if (FALSE) {
[13:37:43.162]     }
[13:37:43.162]     else {
[13:37:43.162]         if (TRUE) {
[13:37:43.162]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:43.162]                 open = "w")
[13:37:43.162]         }
[13:37:43.162]         else {
[13:37:43.162]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:43.162]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:43.162]         }
[13:37:43.162]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:43.162]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:43.162]             base::sink(type = "output", split = FALSE)
[13:37:43.162]             base::close(...future.stdout)
[13:37:43.162]         }, add = TRUE)
[13:37:43.162]     }
[13:37:43.162]     ...future.frame <- base::sys.nframe()
[13:37:43.162]     ...future.conditions <- base::list()
[13:37:43.162]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:43.162]     if (FALSE) {
[13:37:43.162]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:43.162]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:43.162]     }
[13:37:43.162]     ...future.result <- base::tryCatch({
[13:37:43.162]         base::withCallingHandlers({
[13:37:43.162]             ...future.value <- base::withVisible(base::local({
[13:37:43.162]                 1
[13:37:43.162]             }))
[13:37:43.162]             future::FutureResult(value = ...future.value$value, 
[13:37:43.162]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.162]                   ...future.rng), globalenv = if (FALSE) 
[13:37:43.162]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:43.162]                     ...future.globalenv.names))
[13:37:43.162]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:43.162]         }, condition = base::local({
[13:37:43.162]             c <- base::c
[13:37:43.162]             inherits <- base::inherits
[13:37:43.162]             invokeRestart <- base::invokeRestart
[13:37:43.162]             length <- base::length
[13:37:43.162]             list <- base::list
[13:37:43.162]             seq.int <- base::seq.int
[13:37:43.162]             signalCondition <- base::signalCondition
[13:37:43.162]             sys.calls <- base::sys.calls
[13:37:43.162]             `[[` <- base::`[[`
[13:37:43.162]             `+` <- base::`+`
[13:37:43.162]             `<<-` <- base::`<<-`
[13:37:43.162]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:43.162]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:43.162]                   3L)]
[13:37:43.162]             }
[13:37:43.162]             function(cond) {
[13:37:43.162]                 is_error <- inherits(cond, "error")
[13:37:43.162]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:43.162]                   NULL)
[13:37:43.162]                 if (is_error) {
[13:37:43.162]                   sessionInformation <- function() {
[13:37:43.162]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:43.162]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:43.162]                       search = base::search(), system = base::Sys.info())
[13:37:43.162]                   }
[13:37:43.162]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.162]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:43.162]                     cond$call), session = sessionInformation(), 
[13:37:43.162]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:43.162]                   signalCondition(cond)
[13:37:43.162]                 }
[13:37:43.162]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:43.162]                 "immediateCondition"))) {
[13:37:43.162]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:43.162]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.162]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:43.162]                   if (TRUE && !signal) {
[13:37:43.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.162]                     {
[13:37:43.162]                       inherits <- base::inherits
[13:37:43.162]                       invokeRestart <- base::invokeRestart
[13:37:43.162]                       is.null <- base::is.null
[13:37:43.162]                       muffled <- FALSE
[13:37:43.162]                       if (inherits(cond, "message")) {
[13:37:43.162]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.162]                         if (muffled) 
[13:37:43.162]                           invokeRestart("muffleMessage")
[13:37:43.162]                       }
[13:37:43.162]                       else if (inherits(cond, "warning")) {
[13:37:43.162]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.162]                         if (muffled) 
[13:37:43.162]                           invokeRestart("muffleWarning")
[13:37:43.162]                       }
[13:37:43.162]                       else if (inherits(cond, "condition")) {
[13:37:43.162]                         if (!is.null(pattern)) {
[13:37:43.162]                           computeRestarts <- base::computeRestarts
[13:37:43.162]                           grepl <- base::grepl
[13:37:43.162]                           restarts <- computeRestarts(cond)
[13:37:43.162]                           for (restart in restarts) {
[13:37:43.162]                             name <- restart$name
[13:37:43.162]                             if (is.null(name)) 
[13:37:43.162]                               next
[13:37:43.162]                             if (!grepl(pattern, name)) 
[13:37:43.162]                               next
[13:37:43.162]                             invokeRestart(restart)
[13:37:43.162]                             muffled <- TRUE
[13:37:43.162]                             break
[13:37:43.162]                           }
[13:37:43.162]                         }
[13:37:43.162]                       }
[13:37:43.162]                       invisible(muffled)
[13:37:43.162]                     }
[13:37:43.162]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.162]                   }
[13:37:43.162]                 }
[13:37:43.162]                 else {
[13:37:43.162]                   if (TRUE) {
[13:37:43.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.162]                     {
[13:37:43.162]                       inherits <- base::inherits
[13:37:43.162]                       invokeRestart <- base::invokeRestart
[13:37:43.162]                       is.null <- base::is.null
[13:37:43.162]                       muffled <- FALSE
[13:37:43.162]                       if (inherits(cond, "message")) {
[13:37:43.162]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.162]                         if (muffled) 
[13:37:43.162]                           invokeRestart("muffleMessage")
[13:37:43.162]                       }
[13:37:43.162]                       else if (inherits(cond, "warning")) {
[13:37:43.162]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.162]                         if (muffled) 
[13:37:43.162]                           invokeRestart("muffleWarning")
[13:37:43.162]                       }
[13:37:43.162]                       else if (inherits(cond, "condition")) {
[13:37:43.162]                         if (!is.null(pattern)) {
[13:37:43.162]                           computeRestarts <- base::computeRestarts
[13:37:43.162]                           grepl <- base::grepl
[13:37:43.162]                           restarts <- computeRestarts(cond)
[13:37:43.162]                           for (restart in restarts) {
[13:37:43.162]                             name <- restart$name
[13:37:43.162]                             if (is.null(name)) 
[13:37:43.162]                               next
[13:37:43.162]                             if (!grepl(pattern, name)) 
[13:37:43.162]                               next
[13:37:43.162]                             invokeRestart(restart)
[13:37:43.162]                             muffled <- TRUE
[13:37:43.162]                             break
[13:37:43.162]                           }
[13:37:43.162]                         }
[13:37:43.162]                       }
[13:37:43.162]                       invisible(muffled)
[13:37:43.162]                     }
[13:37:43.162]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.162]                   }
[13:37:43.162]                 }
[13:37:43.162]             }
[13:37:43.162]         }))
[13:37:43.162]     }, error = function(ex) {
[13:37:43.162]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:43.162]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.162]                 ...future.rng), started = ...future.startTime, 
[13:37:43.162]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:43.162]             version = "1.8"), class = "FutureResult")
[13:37:43.162]     }, finally = {
[13:37:43.162]         if (!identical(...future.workdir, getwd())) 
[13:37:43.162]             setwd(...future.workdir)
[13:37:43.162]         {
[13:37:43.162]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:43.162]                 ...future.oldOptions$nwarnings <- NULL
[13:37:43.162]             }
[13:37:43.162]             base::options(...future.oldOptions)
[13:37:43.162]             if (.Platform$OS.type == "windows") {
[13:37:43.162]                 old_names <- names(...future.oldEnvVars)
[13:37:43.162]                 envs <- base::Sys.getenv()
[13:37:43.162]                 names <- names(envs)
[13:37:43.162]                 common <- intersect(names, old_names)
[13:37:43.162]                 added <- setdiff(names, old_names)
[13:37:43.162]                 removed <- setdiff(old_names, names)
[13:37:43.162]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:43.162]                   envs[common]]
[13:37:43.162]                 NAMES <- toupper(changed)
[13:37:43.162]                 args <- list()
[13:37:43.162]                 for (kk in seq_along(NAMES)) {
[13:37:43.162]                   name <- changed[[kk]]
[13:37:43.162]                   NAME <- NAMES[[kk]]
[13:37:43.162]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.162]                     next
[13:37:43.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.162]                 }
[13:37:43.162]                 NAMES <- toupper(added)
[13:37:43.162]                 for (kk in seq_along(NAMES)) {
[13:37:43.162]                   name <- added[[kk]]
[13:37:43.162]                   NAME <- NAMES[[kk]]
[13:37:43.162]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.162]                     next
[13:37:43.162]                   args[[name]] <- ""
[13:37:43.162]                 }
[13:37:43.162]                 NAMES <- toupper(removed)
[13:37:43.162]                 for (kk in seq_along(NAMES)) {
[13:37:43.162]                   name <- removed[[kk]]
[13:37:43.162]                   NAME <- NAMES[[kk]]
[13:37:43.162]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.162]                     next
[13:37:43.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.162]                 }
[13:37:43.162]                 if (length(args) > 0) 
[13:37:43.162]                   base::do.call(base::Sys.setenv, args = args)
[13:37:43.162]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:43.162]             }
[13:37:43.162]             else {
[13:37:43.162]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:43.162]             }
[13:37:43.162]             {
[13:37:43.162]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:43.162]                   0L) {
[13:37:43.162]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:43.162]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:43.162]                   base::options(opts)
[13:37:43.162]                 }
[13:37:43.162]                 {
[13:37:43.162]                   {
[13:37:43.162]                     NULL
[13:37:43.162]                     RNGkind("Mersenne-Twister")
[13:37:43.162]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:37:43.162]                       inherits = FALSE)
[13:37:43.162]                   }
[13:37:43.162]                   options(future.plan = NULL)
[13:37:43.162]                   if (is.na(NA_character_)) 
[13:37:43.162]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.162]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:43.162]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:43.162]                     .init = FALSE)
[13:37:43.162]                 }
[13:37:43.162]             }
[13:37:43.162]         }
[13:37:43.162]     })
[13:37:43.162]     if (TRUE) {
[13:37:43.162]         base::sink(type = "output", split = FALSE)
[13:37:43.162]         if (TRUE) {
[13:37:43.162]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:43.162]         }
[13:37:43.162]         else {
[13:37:43.162]             ...future.result["stdout"] <- base::list(NULL)
[13:37:43.162]         }
[13:37:43.162]         base::close(...future.stdout)
[13:37:43.162]         ...future.stdout <- NULL
[13:37:43.162]     }
[13:37:43.162]     ...future.result$conditions <- ...future.conditions
[13:37:43.162]     ...future.result$finished <- base::Sys.time()
[13:37:43.162]     ...future.result
[13:37:43.162] }
[13:37:43.164] plan(): Setting new future strategy stack:
[13:37:43.165] List of future strategies:
[13:37:43.165] 1. sequential:
[13:37:43.165]    - args: function (..., envir = parent.frame())
[13:37:43.165]    - tweaked: FALSE
[13:37:43.165]    - call: NULL
[13:37:43.165] plan(): nbrOfWorkers() = 1
[13:37:43.166] plan(): Setting new future strategy stack:
[13:37:43.166] List of future strategies:
[13:37:43.166] 1. sequential:
[13:37:43.166]    - args: function (..., envir = parent.frame())
[13:37:43.166]    - tweaked: FALSE
[13:37:43.166]    - call: plan(strategy)
[13:37:43.166] plan(): nbrOfWorkers() = 1
[13:37:43.167] SequentialFuture started (and completed)
[13:37:43.167] - Launch lazy future ... done
[13:37:43.167] run() for ‘SequentialFuture’ ... done
[13:37:43.167] getGlobalsAndPackages() ...
[13:37:43.167] Searching for globals...
[13:37:43.168] - globals found: [1] ‘{’
[13:37:43.168] Searching for globals ... DONE
[13:37:43.168] Resolving globals: FALSE
[13:37:43.168] 
[13:37:43.169] 
[13:37:43.169] getGlobalsAndPackages() ... DONE
[13:37:43.169] run() for ‘Future’ ...
[13:37:43.169] - state: ‘created’
[13:37:43.169] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:37:43.169] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:37:43.170] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:37:43.170]   - Field: ‘label’
[13:37:43.170]   - Field: ‘local’
[13:37:43.170]   - Field: ‘owner’
[13:37:43.170]   - Field: ‘envir’
[13:37:43.170]   - Field: ‘packages’
[13:37:43.170]   - Field: ‘gc’
[13:37:43.170]   - Field: ‘conditions’
[13:37:43.170]   - Field: ‘expr’
[13:37:43.170]   - Field: ‘uuid’
[13:37:43.171]   - Field: ‘seed’
[13:37:43.171]   - Field: ‘version’
[13:37:43.171]   - Field: ‘result’
[13:37:43.171]   - Field: ‘asynchronous’
[13:37:43.171]   - Field: ‘calls’
[13:37:43.171]   - Field: ‘globals’
[13:37:43.171]   - Field: ‘stdout’
[13:37:43.171]   - Field: ‘earlySignal’
[13:37:43.171]   - Field: ‘lazy’
[13:37:43.171]   - Field: ‘state’
[13:37:43.172] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:37:43.172] - Launch lazy future ...
[13:37:43.172] Packages needed by the future expression (n = 0): <none>
[13:37:43.172] Packages needed by future strategies (n = 0): <none>
[13:37:43.172] {
[13:37:43.172]     {
[13:37:43.172]         {
[13:37:43.172]             ...future.startTime <- base::Sys.time()
[13:37:43.172]             {
[13:37:43.172]                 {
[13:37:43.172]                   {
[13:37:43.172]                     base::local({
[13:37:43.172]                       has_future <- base::requireNamespace("future", 
[13:37:43.172]                         quietly = TRUE)
[13:37:43.172]                       if (has_future) {
[13:37:43.172]                         ns <- base::getNamespace("future")
[13:37:43.172]                         version <- ns[[".package"]][["version"]]
[13:37:43.172]                         if (is.null(version)) 
[13:37:43.172]                           version <- utils::packageVersion("future")
[13:37:43.172]                       }
[13:37:43.172]                       else {
[13:37:43.172]                         version <- NULL
[13:37:43.172]                       }
[13:37:43.172]                       if (!has_future || version < "1.8.0") {
[13:37:43.172]                         info <- base::c(r_version = base::gsub("R version ", 
[13:37:43.172]                           "", base::R.version$version.string), 
[13:37:43.172]                           platform = base::sprintf("%s (%s-bit)", 
[13:37:43.172]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:43.172]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:43.172]                             "release", "version")], collapse = " "), 
[13:37:43.172]                           hostname = base::Sys.info()[["nodename"]])
[13:37:43.172]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:37:43.172]                           info)
[13:37:43.172]                         info <- base::paste(info, collapse = "; ")
[13:37:43.172]                         if (!has_future) {
[13:37:43.172]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:43.172]                             info)
[13:37:43.172]                         }
[13:37:43.172]                         else {
[13:37:43.172]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:43.172]                             info, version)
[13:37:43.172]                         }
[13:37:43.172]                         base::stop(msg)
[13:37:43.172]                       }
[13:37:43.172]                     })
[13:37:43.172]                   }
[13:37:43.172]                   ...future.strategy.old <- future::plan("list")
[13:37:43.172]                   options(future.plan = NULL)
[13:37:43.172]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.172]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:43.172]                 }
[13:37:43.172]                 ...future.workdir <- getwd()
[13:37:43.172]             }
[13:37:43.172]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:43.172]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:43.172]         }
[13:37:43.172]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:43.172]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:43.172]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:43.172]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:43.172]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:43.172]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:43.172]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:43.172]             base::names(...future.oldOptions))
[13:37:43.172]     }
[13:37:43.172]     if (FALSE) {
[13:37:43.172]     }
[13:37:43.172]     else {
[13:37:43.172]         if (TRUE) {
[13:37:43.172]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:43.172]                 open = "w")
[13:37:43.172]         }
[13:37:43.172]         else {
[13:37:43.172]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:43.172]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:43.172]         }
[13:37:43.172]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:43.172]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:43.172]             base::sink(type = "output", split = FALSE)
[13:37:43.172]             base::close(...future.stdout)
[13:37:43.172]         }, add = TRUE)
[13:37:43.172]     }
[13:37:43.172]     ...future.frame <- base::sys.nframe()
[13:37:43.172]     ...future.conditions <- base::list()
[13:37:43.172]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:43.172]     if (FALSE) {
[13:37:43.172]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:43.172]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:43.172]     }
[13:37:43.172]     ...future.result <- base::tryCatch({
[13:37:43.172]         base::withCallingHandlers({
[13:37:43.172]             ...future.value <- base::withVisible(base::local({
[13:37:43.172]                 2
[13:37:43.172]             }))
[13:37:43.172]             future::FutureResult(value = ...future.value$value, 
[13:37:43.172]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.172]                   ...future.rng), globalenv = if (FALSE) 
[13:37:43.172]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:43.172]                     ...future.globalenv.names))
[13:37:43.172]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:43.172]         }, condition = base::local({
[13:37:43.172]             c <- base::c
[13:37:43.172]             inherits <- base::inherits
[13:37:43.172]             invokeRestart <- base::invokeRestart
[13:37:43.172]             length <- base::length
[13:37:43.172]             list <- base::list
[13:37:43.172]             seq.int <- base::seq.int
[13:37:43.172]             signalCondition <- base::signalCondition
[13:37:43.172]             sys.calls <- base::sys.calls
[13:37:43.172]             `[[` <- base::`[[`
[13:37:43.172]             `+` <- base::`+`
[13:37:43.172]             `<<-` <- base::`<<-`
[13:37:43.172]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:43.172]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:43.172]                   3L)]
[13:37:43.172]             }
[13:37:43.172]             function(cond) {
[13:37:43.172]                 is_error <- inherits(cond, "error")
[13:37:43.172]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:43.172]                   NULL)
[13:37:43.172]                 if (is_error) {
[13:37:43.172]                   sessionInformation <- function() {
[13:37:43.172]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:43.172]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:43.172]                       search = base::search(), system = base::Sys.info())
[13:37:43.172]                   }
[13:37:43.172]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.172]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:43.172]                     cond$call), session = sessionInformation(), 
[13:37:43.172]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:43.172]                   signalCondition(cond)
[13:37:43.172]                 }
[13:37:43.172]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:43.172]                 "immediateCondition"))) {
[13:37:43.172]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:43.172]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.172]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:43.172]                   if (TRUE && !signal) {
[13:37:43.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.172]                     {
[13:37:43.172]                       inherits <- base::inherits
[13:37:43.172]                       invokeRestart <- base::invokeRestart
[13:37:43.172]                       is.null <- base::is.null
[13:37:43.172]                       muffled <- FALSE
[13:37:43.172]                       if (inherits(cond, "message")) {
[13:37:43.172]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.172]                         if (muffled) 
[13:37:43.172]                           invokeRestart("muffleMessage")
[13:37:43.172]                       }
[13:37:43.172]                       else if (inherits(cond, "warning")) {
[13:37:43.172]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.172]                         if (muffled) 
[13:37:43.172]                           invokeRestart("muffleWarning")
[13:37:43.172]                       }
[13:37:43.172]                       else if (inherits(cond, "condition")) {
[13:37:43.172]                         if (!is.null(pattern)) {
[13:37:43.172]                           computeRestarts <- base::computeRestarts
[13:37:43.172]                           grepl <- base::grepl
[13:37:43.172]                           restarts <- computeRestarts(cond)
[13:37:43.172]                           for (restart in restarts) {
[13:37:43.172]                             name <- restart$name
[13:37:43.172]                             if (is.null(name)) 
[13:37:43.172]                               next
[13:37:43.172]                             if (!grepl(pattern, name)) 
[13:37:43.172]                               next
[13:37:43.172]                             invokeRestart(restart)
[13:37:43.172]                             muffled <- TRUE
[13:37:43.172]                             break
[13:37:43.172]                           }
[13:37:43.172]                         }
[13:37:43.172]                       }
[13:37:43.172]                       invisible(muffled)
[13:37:43.172]                     }
[13:37:43.172]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.172]                   }
[13:37:43.172]                 }
[13:37:43.172]                 else {
[13:37:43.172]                   if (TRUE) {
[13:37:43.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.172]                     {
[13:37:43.172]                       inherits <- base::inherits
[13:37:43.172]                       invokeRestart <- base::invokeRestart
[13:37:43.172]                       is.null <- base::is.null
[13:37:43.172]                       muffled <- FALSE
[13:37:43.172]                       if (inherits(cond, "message")) {
[13:37:43.172]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.172]                         if (muffled) 
[13:37:43.172]                           invokeRestart("muffleMessage")
[13:37:43.172]                       }
[13:37:43.172]                       else if (inherits(cond, "warning")) {
[13:37:43.172]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.172]                         if (muffled) 
[13:37:43.172]                           invokeRestart("muffleWarning")
[13:37:43.172]                       }
[13:37:43.172]                       else if (inherits(cond, "condition")) {
[13:37:43.172]                         if (!is.null(pattern)) {
[13:37:43.172]                           computeRestarts <- base::computeRestarts
[13:37:43.172]                           grepl <- base::grepl
[13:37:43.172]                           restarts <- computeRestarts(cond)
[13:37:43.172]                           for (restart in restarts) {
[13:37:43.172]                             name <- restart$name
[13:37:43.172]                             if (is.null(name)) 
[13:37:43.172]                               next
[13:37:43.172]                             if (!grepl(pattern, name)) 
[13:37:43.172]                               next
[13:37:43.172]                             invokeRestart(restart)
[13:37:43.172]                             muffled <- TRUE
[13:37:43.172]                             break
[13:37:43.172]                           }
[13:37:43.172]                         }
[13:37:43.172]                       }
[13:37:43.172]                       invisible(muffled)
[13:37:43.172]                     }
[13:37:43.172]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.172]                   }
[13:37:43.172]                 }
[13:37:43.172]             }
[13:37:43.172]         }))
[13:37:43.172]     }, error = function(ex) {
[13:37:43.172]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:43.172]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.172]                 ...future.rng), started = ...future.startTime, 
[13:37:43.172]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:43.172]             version = "1.8"), class = "FutureResult")
[13:37:43.172]     }, finally = {
[13:37:43.172]         if (!identical(...future.workdir, getwd())) 
[13:37:43.172]             setwd(...future.workdir)
[13:37:43.172]         {
[13:37:43.172]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:43.172]                 ...future.oldOptions$nwarnings <- NULL
[13:37:43.172]             }
[13:37:43.172]             base::options(...future.oldOptions)
[13:37:43.172]             if (.Platform$OS.type == "windows") {
[13:37:43.172]                 old_names <- names(...future.oldEnvVars)
[13:37:43.172]                 envs <- base::Sys.getenv()
[13:37:43.172]                 names <- names(envs)
[13:37:43.172]                 common <- intersect(names, old_names)
[13:37:43.172]                 added <- setdiff(names, old_names)
[13:37:43.172]                 removed <- setdiff(old_names, names)
[13:37:43.172]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:43.172]                   envs[common]]
[13:37:43.172]                 NAMES <- toupper(changed)
[13:37:43.172]                 args <- list()
[13:37:43.172]                 for (kk in seq_along(NAMES)) {
[13:37:43.172]                   name <- changed[[kk]]
[13:37:43.172]                   NAME <- NAMES[[kk]]
[13:37:43.172]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.172]                     next
[13:37:43.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.172]                 }
[13:37:43.172]                 NAMES <- toupper(added)
[13:37:43.172]                 for (kk in seq_along(NAMES)) {
[13:37:43.172]                   name <- added[[kk]]
[13:37:43.172]                   NAME <- NAMES[[kk]]
[13:37:43.172]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.172]                     next
[13:37:43.172]                   args[[name]] <- ""
[13:37:43.172]                 }
[13:37:43.172]                 NAMES <- toupper(removed)
[13:37:43.172]                 for (kk in seq_along(NAMES)) {
[13:37:43.172]                   name <- removed[[kk]]
[13:37:43.172]                   NAME <- NAMES[[kk]]
[13:37:43.172]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.172]                     next
[13:37:43.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.172]                 }
[13:37:43.172]                 if (length(args) > 0) 
[13:37:43.172]                   base::do.call(base::Sys.setenv, args = args)
[13:37:43.172]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:43.172]             }
[13:37:43.172]             else {
[13:37:43.172]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:43.172]             }
[13:37:43.172]             {
[13:37:43.172]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:43.172]                   0L) {
[13:37:43.172]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:43.172]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:43.172]                   base::options(opts)
[13:37:43.172]                 }
[13:37:43.172]                 {
[13:37:43.172]                   {
[13:37:43.172]                     NULL
[13:37:43.172]                     RNGkind("Mersenne-Twister")
[13:37:43.172]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:37:43.172]                       inherits = FALSE)
[13:37:43.172]                   }
[13:37:43.172]                   options(future.plan = NULL)
[13:37:43.172]                   if (is.na(NA_character_)) 
[13:37:43.172]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.172]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:43.172]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:43.172]                     .init = FALSE)
[13:37:43.172]                 }
[13:37:43.172]             }
[13:37:43.172]         }
[13:37:43.172]     })
[13:37:43.172]     if (TRUE) {
[13:37:43.172]         base::sink(type = "output", split = FALSE)
[13:37:43.172]         if (TRUE) {
[13:37:43.172]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:43.172]         }
[13:37:43.172]         else {
[13:37:43.172]             ...future.result["stdout"] <- base::list(NULL)
[13:37:43.172]         }
[13:37:43.172]         base::close(...future.stdout)
[13:37:43.172]         ...future.stdout <- NULL
[13:37:43.172]     }
[13:37:43.172]     ...future.result$conditions <- ...future.conditions
[13:37:43.172]     ...future.result$finished <- base::Sys.time()
[13:37:43.172]     ...future.result
[13:37:43.172] }
[13:37:43.174] plan(): Setting new future strategy stack:
[13:37:43.174] List of future strategies:
[13:37:43.174] 1. sequential:
[13:37:43.174]    - args: function (..., envir = parent.frame())
[13:37:43.174]    - tweaked: FALSE
[13:37:43.174]    - call: NULL
[13:37:43.175] plan(): nbrOfWorkers() = 1
[13:37:43.176] plan(): Setting new future strategy stack:
[13:37:43.176] List of future strategies:
[13:37:43.176] 1. sequential:
[13:37:43.176]    - args: function (..., envir = parent.frame())
[13:37:43.176]    - tweaked: FALSE
[13:37:43.176]    - call: plan(strategy)
[13:37:43.176] plan(): nbrOfWorkers() = 1
[13:37:43.176] SequentialFuture started (and completed)
[13:37:43.176] - Launch lazy future ... done
[13:37:43.176] run() for ‘SequentialFuture’ ... done
[13:37:43.177] resolve() on list environment ...
[13:37:43.177]  recursive: 0
[13:37:43.178]  length: 3
[13:37:43.178]  elements: ‘a’, ‘b’, ‘c’
[13:37:43.178] resolved() for ‘SequentialFuture’ ...
[13:37:43.178] - state: ‘finished’
[13:37:43.178] - run: TRUE
[13:37:43.178] - result: ‘FutureResult’
[13:37:43.178] resolved() for ‘SequentialFuture’ ... done
[13:37:43.178] Future #1
[13:37:43.179]  length: 2 (resolved future 1)
[13:37:43.179] resolved() for ‘SequentialFuture’ ...
[13:37:43.179] - state: ‘finished’
[13:37:43.179] - run: TRUE
[13:37:43.179] - result: ‘FutureResult’
[13:37:43.179] resolved() for ‘SequentialFuture’ ... done
[13:37:43.179] Future #2
[13:37:43.179]  length: 1 (resolved future 2)
[13:37:43.179]  length: 0 (resolved future 3)
[13:37:43.179] resolve() on list environment ... DONE
[13:37:43.180] getGlobalsAndPackages() ...
[13:37:43.180] Searching for globals...
[13:37:43.181] - globals found: [1] ‘{’
[13:37:43.181] Searching for globals ... DONE
[13:37:43.181] Resolving globals: FALSE
[13:37:43.181] 
[13:37:43.181] 
[13:37:43.181] getGlobalsAndPackages() ... DONE
[13:37:43.182] run() for ‘Future’ ...
[13:37:43.182] - state: ‘created’
[13:37:43.182] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:37:43.182] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:37:43.182] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:37:43.182]   - Field: ‘label’
[13:37:43.182]   - Field: ‘local’
[13:37:43.183]   - Field: ‘owner’
[13:37:43.183]   - Field: ‘envir’
[13:37:43.183]   - Field: ‘packages’
[13:37:43.183]   - Field: ‘gc’
[13:37:43.183]   - Field: ‘conditions’
[13:37:43.183]   - Field: ‘expr’
[13:37:43.183]   - Field: ‘uuid’
[13:37:43.183]   - Field: ‘seed’
[13:37:43.183]   - Field: ‘version’
[13:37:43.183]   - Field: ‘result’
[13:37:43.183]   - Field: ‘asynchronous’
[13:37:43.184]   - Field: ‘calls’
[13:37:43.184]   - Field: ‘globals’
[13:37:43.184]   - Field: ‘stdout’
[13:37:43.184]   - Field: ‘earlySignal’
[13:37:43.184]   - Field: ‘lazy’
[13:37:43.186]   - Field: ‘state’
[13:37:43.187] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:37:43.187] - Launch lazy future ...
[13:37:43.187] Packages needed by the future expression (n = 0): <none>
[13:37:43.187] Packages needed by future strategies (n = 0): <none>
[13:37:43.187] {
[13:37:43.187]     {
[13:37:43.187]         {
[13:37:43.187]             ...future.startTime <- base::Sys.time()
[13:37:43.187]             {
[13:37:43.187]                 {
[13:37:43.187]                   {
[13:37:43.187]                     base::local({
[13:37:43.187]                       has_future <- base::requireNamespace("future", 
[13:37:43.187]                         quietly = TRUE)
[13:37:43.187]                       if (has_future) {
[13:37:43.187]                         ns <- base::getNamespace("future")
[13:37:43.187]                         version <- ns[[".package"]][["version"]]
[13:37:43.187]                         if (is.null(version)) 
[13:37:43.187]                           version <- utils::packageVersion("future")
[13:37:43.187]                       }
[13:37:43.187]                       else {
[13:37:43.187]                         version <- NULL
[13:37:43.187]                       }
[13:37:43.187]                       if (!has_future || version < "1.8.0") {
[13:37:43.187]                         info <- base::c(r_version = base::gsub("R version ", 
[13:37:43.187]                           "", base::R.version$version.string), 
[13:37:43.187]                           platform = base::sprintf("%s (%s-bit)", 
[13:37:43.187]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:43.187]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:43.187]                             "release", "version")], collapse = " "), 
[13:37:43.187]                           hostname = base::Sys.info()[["nodename"]])
[13:37:43.187]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:37:43.187]                           info)
[13:37:43.187]                         info <- base::paste(info, collapse = "; ")
[13:37:43.187]                         if (!has_future) {
[13:37:43.187]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:43.187]                             info)
[13:37:43.187]                         }
[13:37:43.187]                         else {
[13:37:43.187]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:43.187]                             info, version)
[13:37:43.187]                         }
[13:37:43.187]                         base::stop(msg)
[13:37:43.187]                       }
[13:37:43.187]                     })
[13:37:43.187]                   }
[13:37:43.187]                   ...future.strategy.old <- future::plan("list")
[13:37:43.187]                   options(future.plan = NULL)
[13:37:43.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:43.187]                 }
[13:37:43.187]                 ...future.workdir <- getwd()
[13:37:43.187]             }
[13:37:43.187]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:43.187]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:43.187]         }
[13:37:43.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:43.187]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:43.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:43.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:43.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:43.187]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:43.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:43.187]             base::names(...future.oldOptions))
[13:37:43.187]     }
[13:37:43.187]     if (FALSE) {
[13:37:43.187]     }
[13:37:43.187]     else {
[13:37:43.187]         if (TRUE) {
[13:37:43.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:43.187]                 open = "w")
[13:37:43.187]         }
[13:37:43.187]         else {
[13:37:43.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:43.187]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:43.187]         }
[13:37:43.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:43.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:43.187]             base::sink(type = "output", split = FALSE)
[13:37:43.187]             base::close(...future.stdout)
[13:37:43.187]         }, add = TRUE)
[13:37:43.187]     }
[13:37:43.187]     ...future.frame <- base::sys.nframe()
[13:37:43.187]     ...future.conditions <- base::list()
[13:37:43.187]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:43.187]     if (FALSE) {
[13:37:43.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:43.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:43.187]     }
[13:37:43.187]     ...future.result <- base::tryCatch({
[13:37:43.187]         base::withCallingHandlers({
[13:37:43.187]             ...future.value <- base::withVisible(base::local({
[13:37:43.187]                 1
[13:37:43.187]             }))
[13:37:43.187]             future::FutureResult(value = ...future.value$value, 
[13:37:43.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.187]                   ...future.rng), globalenv = if (FALSE) 
[13:37:43.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:43.187]                     ...future.globalenv.names))
[13:37:43.187]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:43.187]         }, condition = base::local({
[13:37:43.187]             c <- base::c
[13:37:43.187]             inherits <- base::inherits
[13:37:43.187]             invokeRestart <- base::invokeRestart
[13:37:43.187]             length <- base::length
[13:37:43.187]             list <- base::list
[13:37:43.187]             seq.int <- base::seq.int
[13:37:43.187]             signalCondition <- base::signalCondition
[13:37:43.187]             sys.calls <- base::sys.calls
[13:37:43.187]             `[[` <- base::`[[`
[13:37:43.187]             `+` <- base::`+`
[13:37:43.187]             `<<-` <- base::`<<-`
[13:37:43.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:43.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:43.187]                   3L)]
[13:37:43.187]             }
[13:37:43.187]             function(cond) {
[13:37:43.187]                 is_error <- inherits(cond, "error")
[13:37:43.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:43.187]                   NULL)
[13:37:43.187]                 if (is_error) {
[13:37:43.187]                   sessionInformation <- function() {
[13:37:43.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:43.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:43.187]                       search = base::search(), system = base::Sys.info())
[13:37:43.187]                   }
[13:37:43.187]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:43.187]                     cond$call), session = sessionInformation(), 
[13:37:43.187]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:43.187]                   signalCondition(cond)
[13:37:43.187]                 }
[13:37:43.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:43.187]                 "immediateCondition"))) {
[13:37:43.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:43.187]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:43.187]                   if (TRUE && !signal) {
[13:37:43.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.187]                     {
[13:37:43.187]                       inherits <- base::inherits
[13:37:43.187]                       invokeRestart <- base::invokeRestart
[13:37:43.187]                       is.null <- base::is.null
[13:37:43.187]                       muffled <- FALSE
[13:37:43.187]                       if (inherits(cond, "message")) {
[13:37:43.187]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.187]                         if (muffled) 
[13:37:43.187]                           invokeRestart("muffleMessage")
[13:37:43.187]                       }
[13:37:43.187]                       else if (inherits(cond, "warning")) {
[13:37:43.187]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.187]                         if (muffled) 
[13:37:43.187]                           invokeRestart("muffleWarning")
[13:37:43.187]                       }
[13:37:43.187]                       else if (inherits(cond, "condition")) {
[13:37:43.187]                         if (!is.null(pattern)) {
[13:37:43.187]                           computeRestarts <- base::computeRestarts
[13:37:43.187]                           grepl <- base::grepl
[13:37:43.187]                           restarts <- computeRestarts(cond)
[13:37:43.187]                           for (restart in restarts) {
[13:37:43.187]                             name <- restart$name
[13:37:43.187]                             if (is.null(name)) 
[13:37:43.187]                               next
[13:37:43.187]                             if (!grepl(pattern, name)) 
[13:37:43.187]                               next
[13:37:43.187]                             invokeRestart(restart)
[13:37:43.187]                             muffled <- TRUE
[13:37:43.187]                             break
[13:37:43.187]                           }
[13:37:43.187]                         }
[13:37:43.187]                       }
[13:37:43.187]                       invisible(muffled)
[13:37:43.187]                     }
[13:37:43.187]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.187]                   }
[13:37:43.187]                 }
[13:37:43.187]                 else {
[13:37:43.187]                   if (TRUE) {
[13:37:43.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.187]                     {
[13:37:43.187]                       inherits <- base::inherits
[13:37:43.187]                       invokeRestart <- base::invokeRestart
[13:37:43.187]                       is.null <- base::is.null
[13:37:43.187]                       muffled <- FALSE
[13:37:43.187]                       if (inherits(cond, "message")) {
[13:37:43.187]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.187]                         if (muffled) 
[13:37:43.187]                           invokeRestart("muffleMessage")
[13:37:43.187]                       }
[13:37:43.187]                       else if (inherits(cond, "warning")) {
[13:37:43.187]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.187]                         if (muffled) 
[13:37:43.187]                           invokeRestart("muffleWarning")
[13:37:43.187]                       }
[13:37:43.187]                       else if (inherits(cond, "condition")) {
[13:37:43.187]                         if (!is.null(pattern)) {
[13:37:43.187]                           computeRestarts <- base::computeRestarts
[13:37:43.187]                           grepl <- base::grepl
[13:37:43.187]                           restarts <- computeRestarts(cond)
[13:37:43.187]                           for (restart in restarts) {
[13:37:43.187]                             name <- restart$name
[13:37:43.187]                             if (is.null(name)) 
[13:37:43.187]                               next
[13:37:43.187]                             if (!grepl(pattern, name)) 
[13:37:43.187]                               next
[13:37:43.187]                             invokeRestart(restart)
[13:37:43.187]                             muffled <- TRUE
[13:37:43.187]                             break
[13:37:43.187]                           }
[13:37:43.187]                         }
[13:37:43.187]                       }
[13:37:43.187]                       invisible(muffled)
[13:37:43.187]                     }
[13:37:43.187]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.187]                   }
[13:37:43.187]                 }
[13:37:43.187]             }
[13:37:43.187]         }))
[13:37:43.187]     }, error = function(ex) {
[13:37:43.187]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:43.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.187]                 ...future.rng), started = ...future.startTime, 
[13:37:43.187]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:43.187]             version = "1.8"), class = "FutureResult")
[13:37:43.187]     }, finally = {
[13:37:43.187]         if (!identical(...future.workdir, getwd())) 
[13:37:43.187]             setwd(...future.workdir)
[13:37:43.187]         {
[13:37:43.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:43.187]                 ...future.oldOptions$nwarnings <- NULL
[13:37:43.187]             }
[13:37:43.187]             base::options(...future.oldOptions)
[13:37:43.187]             if (.Platform$OS.type == "windows") {
[13:37:43.187]                 old_names <- names(...future.oldEnvVars)
[13:37:43.187]                 envs <- base::Sys.getenv()
[13:37:43.187]                 names <- names(envs)
[13:37:43.187]                 common <- intersect(names, old_names)
[13:37:43.187]                 added <- setdiff(names, old_names)
[13:37:43.187]                 removed <- setdiff(old_names, names)
[13:37:43.187]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:43.187]                   envs[common]]
[13:37:43.187]                 NAMES <- toupper(changed)
[13:37:43.187]                 args <- list()
[13:37:43.187]                 for (kk in seq_along(NAMES)) {
[13:37:43.187]                   name <- changed[[kk]]
[13:37:43.187]                   NAME <- NAMES[[kk]]
[13:37:43.187]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.187]                     next
[13:37:43.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.187]                 }
[13:37:43.187]                 NAMES <- toupper(added)
[13:37:43.187]                 for (kk in seq_along(NAMES)) {
[13:37:43.187]                   name <- added[[kk]]
[13:37:43.187]                   NAME <- NAMES[[kk]]
[13:37:43.187]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.187]                     next
[13:37:43.187]                   args[[name]] <- ""
[13:37:43.187]                 }
[13:37:43.187]                 NAMES <- toupper(removed)
[13:37:43.187]                 for (kk in seq_along(NAMES)) {
[13:37:43.187]                   name <- removed[[kk]]
[13:37:43.187]                   NAME <- NAMES[[kk]]
[13:37:43.187]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.187]                     next
[13:37:43.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.187]                 }
[13:37:43.187]                 if (length(args) > 0) 
[13:37:43.187]                   base::do.call(base::Sys.setenv, args = args)
[13:37:43.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:43.187]             }
[13:37:43.187]             else {
[13:37:43.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:43.187]             }
[13:37:43.187]             {
[13:37:43.187]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:43.187]                   0L) {
[13:37:43.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:43.187]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:43.187]                   base::options(opts)
[13:37:43.187]                 }
[13:37:43.187]                 {
[13:37:43.187]                   {
[13:37:43.187]                     NULL
[13:37:43.187]                     RNGkind("Mersenne-Twister")
[13:37:43.187]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:37:43.187]                       inherits = FALSE)
[13:37:43.187]                   }
[13:37:43.187]                   options(future.plan = NULL)
[13:37:43.187]                   if (is.na(NA_character_)) 
[13:37:43.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:43.187]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:43.187]                     .init = FALSE)
[13:37:43.187]                 }
[13:37:43.187]             }
[13:37:43.187]         }
[13:37:43.187]     })
[13:37:43.187]     if (TRUE) {
[13:37:43.187]         base::sink(type = "output", split = FALSE)
[13:37:43.187]         if (TRUE) {
[13:37:43.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:43.187]         }
[13:37:43.187]         else {
[13:37:43.187]             ...future.result["stdout"] <- base::list(NULL)
[13:37:43.187]         }
[13:37:43.187]         base::close(...future.stdout)
[13:37:43.187]         ...future.stdout <- NULL
[13:37:43.187]     }
[13:37:43.187]     ...future.result$conditions <- ...future.conditions
[13:37:43.187]     ...future.result$finished <- base::Sys.time()
[13:37:43.187]     ...future.result
[13:37:43.187] }
[13:37:43.189] plan(): Setting new future strategy stack:
[13:37:43.190] List of future strategies:
[13:37:43.190] 1. sequential:
[13:37:43.190]    - args: function (..., envir = parent.frame())
[13:37:43.190]    - tweaked: FALSE
[13:37:43.190]    - call: NULL
[13:37:43.190] plan(): nbrOfWorkers() = 1
[13:37:43.191] plan(): Setting new future strategy stack:
[13:37:43.191] List of future strategies:
[13:37:43.191] 1. sequential:
[13:37:43.191]    - args: function (..., envir = parent.frame())
[13:37:43.191]    - tweaked: FALSE
[13:37:43.191]    - call: plan(strategy)
[13:37:43.191] plan(): nbrOfWorkers() = 1
[13:37:43.191] SequentialFuture started (and completed)
[13:37:43.191] - Launch lazy future ... done
[13:37:43.192] run() for ‘SequentialFuture’ ... done
[13:37:43.192] getGlobalsAndPackages() ...
[13:37:43.192] Searching for globals...
[13:37:43.193] - globals found: [2] ‘{’, ‘Sys.sleep’
[13:37:43.193] Searching for globals ... DONE
[13:37:43.193] Resolving globals: FALSE
[13:37:43.194] 
[13:37:43.194] 
[13:37:43.194] getGlobalsAndPackages() ... DONE
[13:37:43.194] run() for ‘Future’ ...
[13:37:43.194] - state: ‘created’
[13:37:43.194] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:37:43.195] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:37:43.195] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:37:43.195]   - Field: ‘label’
[13:37:43.195]   - Field: ‘local’
[13:37:43.195]   - Field: ‘owner’
[13:37:43.195]   - Field: ‘envir’
[13:37:43.195]   - Field: ‘packages’
[13:37:43.195]   - Field: ‘gc’
[13:37:43.195]   - Field: ‘conditions’
[13:37:43.196]   - Field: ‘expr’
[13:37:43.196]   - Field: ‘uuid’
[13:37:43.196]   - Field: ‘seed’
[13:37:43.196]   - Field: ‘version’
[13:37:43.196]   - Field: ‘result’
[13:37:43.196]   - Field: ‘asynchronous’
[13:37:43.196]   - Field: ‘calls’
[13:37:43.196]   - Field: ‘globals’
[13:37:43.196]   - Field: ‘stdout’
[13:37:43.196]   - Field: ‘earlySignal’
[13:37:43.196]   - Field: ‘lazy’
[13:37:43.197]   - Field: ‘state’
[13:37:43.197] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:37:43.197] - Launch lazy future ...
[13:37:43.197] Packages needed by the future expression (n = 0): <none>
[13:37:43.197] Packages needed by future strategies (n = 0): <none>
[13:37:43.198] {
[13:37:43.198]     {
[13:37:43.198]         {
[13:37:43.198]             ...future.startTime <- base::Sys.time()
[13:37:43.198]             {
[13:37:43.198]                 {
[13:37:43.198]                   {
[13:37:43.198]                     base::local({
[13:37:43.198]                       has_future <- base::requireNamespace("future", 
[13:37:43.198]                         quietly = TRUE)
[13:37:43.198]                       if (has_future) {
[13:37:43.198]                         ns <- base::getNamespace("future")
[13:37:43.198]                         version <- ns[[".package"]][["version"]]
[13:37:43.198]                         if (is.null(version)) 
[13:37:43.198]                           version <- utils::packageVersion("future")
[13:37:43.198]                       }
[13:37:43.198]                       else {
[13:37:43.198]                         version <- NULL
[13:37:43.198]                       }
[13:37:43.198]                       if (!has_future || version < "1.8.0") {
[13:37:43.198]                         info <- base::c(r_version = base::gsub("R version ", 
[13:37:43.198]                           "", base::R.version$version.string), 
[13:37:43.198]                           platform = base::sprintf("%s (%s-bit)", 
[13:37:43.198]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:43.198]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:43.198]                             "release", "version")], collapse = " "), 
[13:37:43.198]                           hostname = base::Sys.info()[["nodename"]])
[13:37:43.198]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:37:43.198]                           info)
[13:37:43.198]                         info <- base::paste(info, collapse = "; ")
[13:37:43.198]                         if (!has_future) {
[13:37:43.198]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:43.198]                             info)
[13:37:43.198]                         }
[13:37:43.198]                         else {
[13:37:43.198]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:43.198]                             info, version)
[13:37:43.198]                         }
[13:37:43.198]                         base::stop(msg)
[13:37:43.198]                       }
[13:37:43.198]                     })
[13:37:43.198]                   }
[13:37:43.198]                   ...future.strategy.old <- future::plan("list")
[13:37:43.198]                   options(future.plan = NULL)
[13:37:43.198]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.198]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:43.198]                 }
[13:37:43.198]                 ...future.workdir <- getwd()
[13:37:43.198]             }
[13:37:43.198]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:43.198]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:43.198]         }
[13:37:43.198]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:43.198]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:43.198]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:43.198]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:43.198]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:43.198]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:43.198]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:43.198]             base::names(...future.oldOptions))
[13:37:43.198]     }
[13:37:43.198]     if (FALSE) {
[13:37:43.198]     }
[13:37:43.198]     else {
[13:37:43.198]         if (TRUE) {
[13:37:43.198]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:43.198]                 open = "w")
[13:37:43.198]         }
[13:37:43.198]         else {
[13:37:43.198]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:43.198]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:43.198]         }
[13:37:43.198]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:43.198]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:43.198]             base::sink(type = "output", split = FALSE)
[13:37:43.198]             base::close(...future.stdout)
[13:37:43.198]         }, add = TRUE)
[13:37:43.198]     }
[13:37:43.198]     ...future.frame <- base::sys.nframe()
[13:37:43.198]     ...future.conditions <- base::list()
[13:37:43.198]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:43.198]     if (FALSE) {
[13:37:43.198]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:43.198]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:43.198]     }
[13:37:43.198]     ...future.result <- base::tryCatch({
[13:37:43.198]         base::withCallingHandlers({
[13:37:43.198]             ...future.value <- base::withVisible(base::local({
[13:37:43.198]                 Sys.sleep(0.5)
[13:37:43.198]                 2
[13:37:43.198]             }))
[13:37:43.198]             future::FutureResult(value = ...future.value$value, 
[13:37:43.198]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.198]                   ...future.rng), globalenv = if (FALSE) 
[13:37:43.198]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:43.198]                     ...future.globalenv.names))
[13:37:43.198]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:43.198]         }, condition = base::local({
[13:37:43.198]             c <- base::c
[13:37:43.198]             inherits <- base::inherits
[13:37:43.198]             invokeRestart <- base::invokeRestart
[13:37:43.198]             length <- base::length
[13:37:43.198]             list <- base::list
[13:37:43.198]             seq.int <- base::seq.int
[13:37:43.198]             signalCondition <- base::signalCondition
[13:37:43.198]             sys.calls <- base::sys.calls
[13:37:43.198]             `[[` <- base::`[[`
[13:37:43.198]             `+` <- base::`+`
[13:37:43.198]             `<<-` <- base::`<<-`
[13:37:43.198]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:43.198]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:43.198]                   3L)]
[13:37:43.198]             }
[13:37:43.198]             function(cond) {
[13:37:43.198]                 is_error <- inherits(cond, "error")
[13:37:43.198]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:43.198]                   NULL)
[13:37:43.198]                 if (is_error) {
[13:37:43.198]                   sessionInformation <- function() {
[13:37:43.198]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:43.198]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:43.198]                       search = base::search(), system = base::Sys.info())
[13:37:43.198]                   }
[13:37:43.198]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.198]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:43.198]                     cond$call), session = sessionInformation(), 
[13:37:43.198]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:43.198]                   signalCondition(cond)
[13:37:43.198]                 }
[13:37:43.198]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:43.198]                 "immediateCondition"))) {
[13:37:43.198]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:43.198]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.198]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:43.198]                   if (TRUE && !signal) {
[13:37:43.198]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.198]                     {
[13:37:43.198]                       inherits <- base::inherits
[13:37:43.198]                       invokeRestart <- base::invokeRestart
[13:37:43.198]                       is.null <- base::is.null
[13:37:43.198]                       muffled <- FALSE
[13:37:43.198]                       if (inherits(cond, "message")) {
[13:37:43.198]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.198]                         if (muffled) 
[13:37:43.198]                           invokeRestart("muffleMessage")
[13:37:43.198]                       }
[13:37:43.198]                       else if (inherits(cond, "warning")) {
[13:37:43.198]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.198]                         if (muffled) 
[13:37:43.198]                           invokeRestart("muffleWarning")
[13:37:43.198]                       }
[13:37:43.198]                       else if (inherits(cond, "condition")) {
[13:37:43.198]                         if (!is.null(pattern)) {
[13:37:43.198]                           computeRestarts <- base::computeRestarts
[13:37:43.198]                           grepl <- base::grepl
[13:37:43.198]                           restarts <- computeRestarts(cond)
[13:37:43.198]                           for (restart in restarts) {
[13:37:43.198]                             name <- restart$name
[13:37:43.198]                             if (is.null(name)) 
[13:37:43.198]                               next
[13:37:43.198]                             if (!grepl(pattern, name)) 
[13:37:43.198]                               next
[13:37:43.198]                             invokeRestart(restart)
[13:37:43.198]                             muffled <- TRUE
[13:37:43.198]                             break
[13:37:43.198]                           }
[13:37:43.198]                         }
[13:37:43.198]                       }
[13:37:43.198]                       invisible(muffled)
[13:37:43.198]                     }
[13:37:43.198]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.198]                   }
[13:37:43.198]                 }
[13:37:43.198]                 else {
[13:37:43.198]                   if (TRUE) {
[13:37:43.198]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.198]                     {
[13:37:43.198]                       inherits <- base::inherits
[13:37:43.198]                       invokeRestart <- base::invokeRestart
[13:37:43.198]                       is.null <- base::is.null
[13:37:43.198]                       muffled <- FALSE
[13:37:43.198]                       if (inherits(cond, "message")) {
[13:37:43.198]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.198]                         if (muffled) 
[13:37:43.198]                           invokeRestart("muffleMessage")
[13:37:43.198]                       }
[13:37:43.198]                       else if (inherits(cond, "warning")) {
[13:37:43.198]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.198]                         if (muffled) 
[13:37:43.198]                           invokeRestart("muffleWarning")
[13:37:43.198]                       }
[13:37:43.198]                       else if (inherits(cond, "condition")) {
[13:37:43.198]                         if (!is.null(pattern)) {
[13:37:43.198]                           computeRestarts <- base::computeRestarts
[13:37:43.198]                           grepl <- base::grepl
[13:37:43.198]                           restarts <- computeRestarts(cond)
[13:37:43.198]                           for (restart in restarts) {
[13:37:43.198]                             name <- restart$name
[13:37:43.198]                             if (is.null(name)) 
[13:37:43.198]                               next
[13:37:43.198]                             if (!grepl(pattern, name)) 
[13:37:43.198]                               next
[13:37:43.198]                             invokeRestart(restart)
[13:37:43.198]                             muffled <- TRUE
[13:37:43.198]                             break
[13:37:43.198]                           }
[13:37:43.198]                         }
[13:37:43.198]                       }
[13:37:43.198]                       invisible(muffled)
[13:37:43.198]                     }
[13:37:43.198]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.198]                   }
[13:37:43.198]                 }
[13:37:43.198]             }
[13:37:43.198]         }))
[13:37:43.198]     }, error = function(ex) {
[13:37:43.198]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:43.198]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.198]                 ...future.rng), started = ...future.startTime, 
[13:37:43.198]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:43.198]             version = "1.8"), class = "FutureResult")
[13:37:43.198]     }, finally = {
[13:37:43.198]         if (!identical(...future.workdir, getwd())) 
[13:37:43.198]             setwd(...future.workdir)
[13:37:43.198]         {
[13:37:43.198]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:43.198]                 ...future.oldOptions$nwarnings <- NULL
[13:37:43.198]             }
[13:37:43.198]             base::options(...future.oldOptions)
[13:37:43.198]             if (.Platform$OS.type == "windows") {
[13:37:43.198]                 old_names <- names(...future.oldEnvVars)
[13:37:43.198]                 envs <- base::Sys.getenv()
[13:37:43.198]                 names <- names(envs)
[13:37:43.198]                 common <- intersect(names, old_names)
[13:37:43.198]                 added <- setdiff(names, old_names)
[13:37:43.198]                 removed <- setdiff(old_names, names)
[13:37:43.198]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:43.198]                   envs[common]]
[13:37:43.198]                 NAMES <- toupper(changed)
[13:37:43.198]                 args <- list()
[13:37:43.198]                 for (kk in seq_along(NAMES)) {
[13:37:43.198]                   name <- changed[[kk]]
[13:37:43.198]                   NAME <- NAMES[[kk]]
[13:37:43.198]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.198]                     next
[13:37:43.198]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.198]                 }
[13:37:43.198]                 NAMES <- toupper(added)
[13:37:43.198]                 for (kk in seq_along(NAMES)) {
[13:37:43.198]                   name <- added[[kk]]
[13:37:43.198]                   NAME <- NAMES[[kk]]
[13:37:43.198]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.198]                     next
[13:37:43.198]                   args[[name]] <- ""
[13:37:43.198]                 }
[13:37:43.198]                 NAMES <- toupper(removed)
[13:37:43.198]                 for (kk in seq_along(NAMES)) {
[13:37:43.198]                   name <- removed[[kk]]
[13:37:43.198]                   NAME <- NAMES[[kk]]
[13:37:43.198]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.198]                     next
[13:37:43.198]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.198]                 }
[13:37:43.198]                 if (length(args) > 0) 
[13:37:43.198]                   base::do.call(base::Sys.setenv, args = args)
[13:37:43.198]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:43.198]             }
[13:37:43.198]             else {
[13:37:43.198]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:43.198]             }
[13:37:43.198]             {
[13:37:43.198]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:43.198]                   0L) {
[13:37:43.198]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:43.198]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:43.198]                   base::options(opts)
[13:37:43.198]                 }
[13:37:43.198]                 {
[13:37:43.198]                   {
[13:37:43.198]                     NULL
[13:37:43.198]                     RNGkind("Mersenne-Twister")
[13:37:43.198]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:37:43.198]                       inherits = FALSE)
[13:37:43.198]                   }
[13:37:43.198]                   options(future.plan = NULL)
[13:37:43.198]                   if (is.na(NA_character_)) 
[13:37:43.198]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.198]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:43.198]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:43.198]                     .init = FALSE)
[13:37:43.198]                 }
[13:37:43.198]             }
[13:37:43.198]         }
[13:37:43.198]     })
[13:37:43.198]     if (TRUE) {
[13:37:43.198]         base::sink(type = "output", split = FALSE)
[13:37:43.198]         if (TRUE) {
[13:37:43.198]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:43.198]         }
[13:37:43.198]         else {
[13:37:43.198]             ...future.result["stdout"] <- base::list(NULL)
[13:37:43.198]         }
[13:37:43.198]         base::close(...future.stdout)
[13:37:43.198]         ...future.stdout <- NULL
[13:37:43.198]     }
[13:37:43.198]     ...future.result$conditions <- ...future.conditions
[13:37:43.198]     ...future.result$finished <- base::Sys.time()
[13:37:43.198]     ...future.result
[13:37:43.198] }
[13:37:43.199] plan(): Setting new future strategy stack:
[13:37:43.199] List of future strategies:
[13:37:43.199] 1. sequential:
[13:37:43.199]    - args: function (..., envir = parent.frame())
[13:37:43.199]    - tweaked: FALSE
[13:37:43.199]    - call: NULL
[13:37:43.200] plan(): nbrOfWorkers() = 1
[13:37:43.702] plan(): Setting new future strategy stack:
[13:37:43.702] List of future strategies:
[13:37:43.702] 1. sequential:
[13:37:43.702]    - args: function (..., envir = parent.frame())
[13:37:43.702]    - tweaked: FALSE
[13:37:43.702]    - call: plan(strategy)
[13:37:43.702] plan(): nbrOfWorkers() = 1
[13:37:43.702] SequentialFuture started (and completed)
[13:37:43.703] - Launch lazy future ... done
[13:37:43.703] run() for ‘SequentialFuture’ ... done
[13:37:43.703] getGlobalsAndPackages() ...
[13:37:43.703] Searching for globals...
[13:37:43.704] - globals found: [1] ‘{’
[13:37:43.704] Searching for globals ... DONE
[13:37:43.704] Resolving globals: FALSE
[13:37:43.704] 
[13:37:43.705] 
[13:37:43.705] getGlobalsAndPackages() ... DONE
[13:37:43.705] run() for ‘Future’ ...
[13:37:43.705] - state: ‘created’
[13:37:43.705] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:37:43.705] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:37:43.706] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:37:43.706]   - Field: ‘label’
[13:37:43.706]   - Field: ‘local’
[13:37:43.706]   - Field: ‘owner’
[13:37:43.706]   - Field: ‘envir’
[13:37:43.706]   - Field: ‘packages’
[13:37:43.706]   - Field: ‘gc’
[13:37:43.706]   - Field: ‘conditions’
[13:37:43.706]   - Field: ‘expr’
[13:37:43.706]   - Field: ‘uuid’
[13:37:43.707]   - Field: ‘seed’
[13:37:43.707]   - Field: ‘version’
[13:37:43.707]   - Field: ‘result’
[13:37:43.707]   - Field: ‘asynchronous’
[13:37:43.707]   - Field: ‘calls’
[13:37:43.707]   - Field: ‘globals’
[13:37:43.707]   - Field: ‘stdout’
[13:37:43.707]   - Field: ‘earlySignal’
[13:37:43.707]   - Field: ‘lazy’
[13:37:43.707]   - Field: ‘state’
[13:37:43.707] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:37:43.708] - Launch lazy future ...
[13:37:43.708] Packages needed by the future expression (n = 0): <none>
[13:37:43.708] Packages needed by future strategies (n = 0): <none>
[13:37:43.708] {
[13:37:43.708]     {
[13:37:43.708]         {
[13:37:43.708]             ...future.startTime <- base::Sys.time()
[13:37:43.708]             {
[13:37:43.708]                 {
[13:37:43.708]                   {
[13:37:43.708]                     base::local({
[13:37:43.708]                       has_future <- base::requireNamespace("future", 
[13:37:43.708]                         quietly = TRUE)
[13:37:43.708]                       if (has_future) {
[13:37:43.708]                         ns <- base::getNamespace("future")
[13:37:43.708]                         version <- ns[[".package"]][["version"]]
[13:37:43.708]                         if (is.null(version)) 
[13:37:43.708]                           version <- utils::packageVersion("future")
[13:37:43.708]                       }
[13:37:43.708]                       else {
[13:37:43.708]                         version <- NULL
[13:37:43.708]                       }
[13:37:43.708]                       if (!has_future || version < "1.8.0") {
[13:37:43.708]                         info <- base::c(r_version = base::gsub("R version ", 
[13:37:43.708]                           "", base::R.version$version.string), 
[13:37:43.708]                           platform = base::sprintf("%s (%s-bit)", 
[13:37:43.708]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:43.708]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:43.708]                             "release", "version")], collapse = " "), 
[13:37:43.708]                           hostname = base::Sys.info()[["nodename"]])
[13:37:43.708]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:37:43.708]                           info)
[13:37:43.708]                         info <- base::paste(info, collapse = "; ")
[13:37:43.708]                         if (!has_future) {
[13:37:43.708]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:43.708]                             info)
[13:37:43.708]                         }
[13:37:43.708]                         else {
[13:37:43.708]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:43.708]                             info, version)
[13:37:43.708]                         }
[13:37:43.708]                         base::stop(msg)
[13:37:43.708]                       }
[13:37:43.708]                     })
[13:37:43.708]                   }
[13:37:43.708]                   ...future.strategy.old <- future::plan("list")
[13:37:43.708]                   options(future.plan = NULL)
[13:37:43.708]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.708]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:43.708]                 }
[13:37:43.708]                 ...future.workdir <- getwd()
[13:37:43.708]             }
[13:37:43.708]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:43.708]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:43.708]         }
[13:37:43.708]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:43.708]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:43.708]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:43.708]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:43.708]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:43.708]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:43.708]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:43.708]             base::names(...future.oldOptions))
[13:37:43.708]     }
[13:37:43.708]     if (FALSE) {
[13:37:43.708]     }
[13:37:43.708]     else {
[13:37:43.708]         if (TRUE) {
[13:37:43.708]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:43.708]                 open = "w")
[13:37:43.708]         }
[13:37:43.708]         else {
[13:37:43.708]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:43.708]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:43.708]         }
[13:37:43.708]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:43.708]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:43.708]             base::sink(type = "output", split = FALSE)
[13:37:43.708]             base::close(...future.stdout)
[13:37:43.708]         }, add = TRUE)
[13:37:43.708]     }
[13:37:43.708]     ...future.frame <- base::sys.nframe()
[13:37:43.708]     ...future.conditions <- base::list()
[13:37:43.708]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:43.708]     if (FALSE) {
[13:37:43.708]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:43.708]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:43.708]     }
[13:37:43.708]     ...future.result <- base::tryCatch({
[13:37:43.708]         base::withCallingHandlers({
[13:37:43.708]             ...future.value <- base::withVisible(base::local({
[13:37:43.708]                 3
[13:37:43.708]             }))
[13:37:43.708]             future::FutureResult(value = ...future.value$value, 
[13:37:43.708]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.708]                   ...future.rng), globalenv = if (FALSE) 
[13:37:43.708]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:43.708]                     ...future.globalenv.names))
[13:37:43.708]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:43.708]         }, condition = base::local({
[13:37:43.708]             c <- base::c
[13:37:43.708]             inherits <- base::inherits
[13:37:43.708]             invokeRestart <- base::invokeRestart
[13:37:43.708]             length <- base::length
[13:37:43.708]             list <- base::list
[13:37:43.708]             seq.int <- base::seq.int
[13:37:43.708]             signalCondition <- base::signalCondition
[13:37:43.708]             sys.calls <- base::sys.calls
[13:37:43.708]             `[[` <- base::`[[`
[13:37:43.708]             `+` <- base::`+`
[13:37:43.708]             `<<-` <- base::`<<-`
[13:37:43.708]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:43.708]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:43.708]                   3L)]
[13:37:43.708]             }
[13:37:43.708]             function(cond) {
[13:37:43.708]                 is_error <- inherits(cond, "error")
[13:37:43.708]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:43.708]                   NULL)
[13:37:43.708]                 if (is_error) {
[13:37:43.708]                   sessionInformation <- function() {
[13:37:43.708]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:43.708]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:43.708]                       search = base::search(), system = base::Sys.info())
[13:37:43.708]                   }
[13:37:43.708]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.708]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:43.708]                     cond$call), session = sessionInformation(), 
[13:37:43.708]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:43.708]                   signalCondition(cond)
[13:37:43.708]                 }
[13:37:43.708]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:43.708]                 "immediateCondition"))) {
[13:37:43.708]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:43.708]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.708]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:43.708]                   if (TRUE && !signal) {
[13:37:43.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.708]                     {
[13:37:43.708]                       inherits <- base::inherits
[13:37:43.708]                       invokeRestart <- base::invokeRestart
[13:37:43.708]                       is.null <- base::is.null
[13:37:43.708]                       muffled <- FALSE
[13:37:43.708]                       if (inherits(cond, "message")) {
[13:37:43.708]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.708]                         if (muffled) 
[13:37:43.708]                           invokeRestart("muffleMessage")
[13:37:43.708]                       }
[13:37:43.708]                       else if (inherits(cond, "warning")) {
[13:37:43.708]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.708]                         if (muffled) 
[13:37:43.708]                           invokeRestart("muffleWarning")
[13:37:43.708]                       }
[13:37:43.708]                       else if (inherits(cond, "condition")) {
[13:37:43.708]                         if (!is.null(pattern)) {
[13:37:43.708]                           computeRestarts <- base::computeRestarts
[13:37:43.708]                           grepl <- base::grepl
[13:37:43.708]                           restarts <- computeRestarts(cond)
[13:37:43.708]                           for (restart in restarts) {
[13:37:43.708]                             name <- restart$name
[13:37:43.708]                             if (is.null(name)) 
[13:37:43.708]                               next
[13:37:43.708]                             if (!grepl(pattern, name)) 
[13:37:43.708]                               next
[13:37:43.708]                             invokeRestart(restart)
[13:37:43.708]                             muffled <- TRUE
[13:37:43.708]                             break
[13:37:43.708]                           }
[13:37:43.708]                         }
[13:37:43.708]                       }
[13:37:43.708]                       invisible(muffled)
[13:37:43.708]                     }
[13:37:43.708]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.708]                   }
[13:37:43.708]                 }
[13:37:43.708]                 else {
[13:37:43.708]                   if (TRUE) {
[13:37:43.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.708]                     {
[13:37:43.708]                       inherits <- base::inherits
[13:37:43.708]                       invokeRestart <- base::invokeRestart
[13:37:43.708]                       is.null <- base::is.null
[13:37:43.708]                       muffled <- FALSE
[13:37:43.708]                       if (inherits(cond, "message")) {
[13:37:43.708]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.708]                         if (muffled) 
[13:37:43.708]                           invokeRestart("muffleMessage")
[13:37:43.708]                       }
[13:37:43.708]                       else if (inherits(cond, "warning")) {
[13:37:43.708]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.708]                         if (muffled) 
[13:37:43.708]                           invokeRestart("muffleWarning")
[13:37:43.708]                       }
[13:37:43.708]                       else if (inherits(cond, "condition")) {
[13:37:43.708]                         if (!is.null(pattern)) {
[13:37:43.708]                           computeRestarts <- base::computeRestarts
[13:37:43.708]                           grepl <- base::grepl
[13:37:43.708]                           restarts <- computeRestarts(cond)
[13:37:43.708]                           for (restart in restarts) {
[13:37:43.708]                             name <- restart$name
[13:37:43.708]                             if (is.null(name)) 
[13:37:43.708]                               next
[13:37:43.708]                             if (!grepl(pattern, name)) 
[13:37:43.708]                               next
[13:37:43.708]                             invokeRestart(restart)
[13:37:43.708]                             muffled <- TRUE
[13:37:43.708]                             break
[13:37:43.708]                           }
[13:37:43.708]                         }
[13:37:43.708]                       }
[13:37:43.708]                       invisible(muffled)
[13:37:43.708]                     }
[13:37:43.708]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.708]                   }
[13:37:43.708]                 }
[13:37:43.708]             }
[13:37:43.708]         }))
[13:37:43.708]     }, error = function(ex) {
[13:37:43.708]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:43.708]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.708]                 ...future.rng), started = ...future.startTime, 
[13:37:43.708]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:43.708]             version = "1.8"), class = "FutureResult")
[13:37:43.708]     }, finally = {
[13:37:43.708]         if (!identical(...future.workdir, getwd())) 
[13:37:43.708]             setwd(...future.workdir)
[13:37:43.708]         {
[13:37:43.708]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:43.708]                 ...future.oldOptions$nwarnings <- NULL
[13:37:43.708]             }
[13:37:43.708]             base::options(...future.oldOptions)
[13:37:43.708]             if (.Platform$OS.type == "windows") {
[13:37:43.708]                 old_names <- names(...future.oldEnvVars)
[13:37:43.708]                 envs <- base::Sys.getenv()
[13:37:43.708]                 names <- names(envs)
[13:37:43.708]                 common <- intersect(names, old_names)
[13:37:43.708]                 added <- setdiff(names, old_names)
[13:37:43.708]                 removed <- setdiff(old_names, names)
[13:37:43.708]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:43.708]                   envs[common]]
[13:37:43.708]                 NAMES <- toupper(changed)
[13:37:43.708]                 args <- list()
[13:37:43.708]                 for (kk in seq_along(NAMES)) {
[13:37:43.708]                   name <- changed[[kk]]
[13:37:43.708]                   NAME <- NAMES[[kk]]
[13:37:43.708]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.708]                     next
[13:37:43.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.708]                 }
[13:37:43.708]                 NAMES <- toupper(added)
[13:37:43.708]                 for (kk in seq_along(NAMES)) {
[13:37:43.708]                   name <- added[[kk]]
[13:37:43.708]                   NAME <- NAMES[[kk]]
[13:37:43.708]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.708]                     next
[13:37:43.708]                   args[[name]] <- ""
[13:37:43.708]                 }
[13:37:43.708]                 NAMES <- toupper(removed)
[13:37:43.708]                 for (kk in seq_along(NAMES)) {
[13:37:43.708]                   name <- removed[[kk]]
[13:37:43.708]                   NAME <- NAMES[[kk]]
[13:37:43.708]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.708]                     next
[13:37:43.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.708]                 }
[13:37:43.708]                 if (length(args) > 0) 
[13:37:43.708]                   base::do.call(base::Sys.setenv, args = args)
[13:37:43.708]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:43.708]             }
[13:37:43.708]             else {
[13:37:43.708]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:43.708]             }
[13:37:43.708]             {
[13:37:43.708]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:43.708]                   0L) {
[13:37:43.708]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:43.708]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:43.708]                   base::options(opts)
[13:37:43.708]                 }
[13:37:43.708]                 {
[13:37:43.708]                   {
[13:37:43.708]                     NULL
[13:37:43.708]                     RNGkind("Mersenne-Twister")
[13:37:43.708]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:37:43.708]                       inherits = FALSE)
[13:37:43.708]                   }
[13:37:43.708]                   options(future.plan = NULL)
[13:37:43.708]                   if (is.na(NA_character_)) 
[13:37:43.708]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.708]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:43.708]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:43.708]                     .init = FALSE)
[13:37:43.708]                 }
[13:37:43.708]             }
[13:37:43.708]         }
[13:37:43.708]     })
[13:37:43.708]     if (TRUE) {
[13:37:43.708]         base::sink(type = "output", split = FALSE)
[13:37:43.708]         if (TRUE) {
[13:37:43.708]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:43.708]         }
[13:37:43.708]         else {
[13:37:43.708]             ...future.result["stdout"] <- base::list(NULL)
[13:37:43.708]         }
[13:37:43.708]         base::close(...future.stdout)
[13:37:43.708]         ...future.stdout <- NULL
[13:37:43.708]     }
[13:37:43.708]     ...future.result$conditions <- ...future.conditions
[13:37:43.708]     ...future.result$finished <- base::Sys.time()
[13:37:43.708]     ...future.result
[13:37:43.708] }
[13:37:43.710] plan(): Setting new future strategy stack:
[13:37:43.710] List of future strategies:
[13:37:43.710] 1. sequential:
[13:37:43.710]    - args: function (..., envir = parent.frame())
[13:37:43.710]    - tweaked: FALSE
[13:37:43.710]    - call: NULL
[13:37:43.711] plan(): nbrOfWorkers() = 1
[13:37:43.712] plan(): Setting new future strategy stack:
[13:37:43.712] List of future strategies:
[13:37:43.712] 1. sequential:
[13:37:43.712]    - args: function (..., envir = parent.frame())
[13:37:43.712]    - tweaked: FALSE
[13:37:43.712]    - call: plan(strategy)
[13:37:43.712] plan(): nbrOfWorkers() = 1
[13:37:43.712] SequentialFuture started (and completed)
[13:37:43.712] - Launch lazy future ... done
[13:37:43.712] run() for ‘SequentialFuture’ ... done
[13:37:43.713] resolve() on list environment ...
[13:37:43.713]  recursive: 0
[13:37:43.714]  length: 4
[13:37:43.714]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:37:43.714] resolved() for ‘SequentialFuture’ ...
[13:37:43.714] - state: ‘finished’
[13:37:43.714] - run: TRUE
[13:37:43.714] - result: ‘FutureResult’
[13:37:43.714] resolved() for ‘SequentialFuture’ ... done
[13:37:43.715] Future #1
[13:37:43.715]  length: 3 (resolved future 1)
[13:37:43.715] resolved() for ‘SequentialFuture’ ...
[13:37:43.715] - state: ‘finished’
[13:37:43.715] - run: TRUE
[13:37:43.715] - result: ‘FutureResult’
[13:37:43.715] resolved() for ‘SequentialFuture’ ... done
[13:37:43.715] Future #2
[13:37:43.718]  length: 2 (resolved future 2)
[13:37:43.718] resolved() for ‘SequentialFuture’ ...
[13:37:43.718] - state: ‘finished’
[13:37:43.718] - run: TRUE
[13:37:43.718] - result: ‘FutureResult’
[13:37:43.718] resolved() for ‘SequentialFuture’ ... done
[13:37:43.719] Future #3
[13:37:43.719]  length: 1 (resolved future 3)
[13:37:43.719]  length: 0 (resolved future 4)
[13:37:43.719] resolve() on list environment ... DONE
[13:37:43.719] resolved() for ‘SequentialFuture’ ...
[13:37:43.719] - state: ‘finished’
[13:37:43.719] - run: TRUE
[13:37:43.720] - result: ‘FutureResult’
[13:37:43.720] resolved() for ‘SequentialFuture’ ... done
[13:37:43.720] resolve() on list environment ...
[13:37:43.720]  recursive: 0
[13:37:43.721]  length: 4
[13:37:43.721]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:37:43.721] resolved() for ‘SequentialFuture’ ...
[13:37:43.721] - state: ‘finished’
[13:37:43.721] - run: TRUE
[13:37:43.721] - result: ‘FutureResult’
[13:37:43.721] resolved() for ‘SequentialFuture’ ... done
[13:37:43.721] Future #1
[13:37:43.721]  length: 3 (resolved future 1)
[13:37:43.722] resolved() for ‘SequentialFuture’ ...
[13:37:43.722] - state: ‘finished’
[13:37:43.722] - run: TRUE
[13:37:43.722] - result: ‘FutureResult’
[13:37:43.722] resolved() for ‘SequentialFuture’ ... done
[13:37:43.722] Future #2
[13:37:43.722]  length: 2 (resolved future 2)
[13:37:43.722] resolved() for ‘SequentialFuture’ ...
[13:37:43.722] - state: ‘finished’
[13:37:43.722] - run: TRUE
[13:37:43.722] - result: ‘FutureResult’
[13:37:43.723] resolved() for ‘SequentialFuture’ ... done
[13:37:43.723] Future #3
[13:37:43.723]  length: 1 (resolved future 3)
[13:37:43.723]  length: 0 (resolved future 4)
[13:37:43.723] resolve() on list environment ... DONE
[13:37:43.724] resolve() on list environment ...
[13:37:43.724]  recursive: 0
[13:37:43.724]  length: 4
[13:37:43.724]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:37:43.724] resolved() for ‘SequentialFuture’ ...
[13:37:43.725] - state: ‘finished’
[13:37:43.725] - run: TRUE
[13:37:43.725] - result: ‘FutureResult’
[13:37:43.725] resolved() for ‘SequentialFuture’ ... done
[13:37:43.725] Future #1
[13:37:43.725]  length: 3 (resolved future 1)
[13:37:43.725] resolved() for ‘SequentialFuture’ ...
[13:37:43.725] - state: ‘finished’
[13:37:43.725] - run: TRUE
[13:37:43.725] - result: ‘FutureResult’
[13:37:43.726] resolved() for ‘SequentialFuture’ ... done
[13:37:43.726] Future #2
[13:37:43.726]  length: 2 (resolved future 2)
[13:37:43.726] resolved() for ‘SequentialFuture’ ...
[13:37:43.726] - state: ‘finished’
[13:37:43.726] - run: TRUE
[13:37:43.726] - result: ‘FutureResult’
[13:37:43.726] resolved() for ‘SequentialFuture’ ... done
[13:37:43.726] Future #3
[13:37:43.726]  length: 1 (resolved future 3)
[13:37:43.727]  length: 0 (resolved future 4)
[13:37:43.727] resolve() on list environment ... DONE
[13:37:43.727] resolve() on list environment ...
[13:37:43.727]  recursive: 0
[13:37:43.728]  length: 4
[13:37:43.728]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:37:43.728] resolved() for ‘SequentialFuture’ ...
[13:37:43.728] - state: ‘finished’
[13:37:43.728] - run: TRUE
[13:37:43.728] - result: ‘FutureResult’
[13:37:43.728] resolved() for ‘SequentialFuture’ ... done
[13:37:43.729] Future #1
[13:37:43.729]  length: 3 (resolved future 1)
[13:37:43.729] resolved() for ‘SequentialFuture’ ...
[13:37:43.729] - state: ‘finished’
[13:37:43.729] - run: TRUE
[13:37:43.729] - result: ‘FutureResult’
[13:37:43.729] resolved() for ‘SequentialFuture’ ... done
[13:37:43.729] Future #2
[13:37:43.729]  length: 2 (resolved future 2)
[13:37:43.729] resolved() for ‘SequentialFuture’ ...
[13:37:43.730] - state: ‘finished’
[13:37:43.730] - run: TRUE
[13:37:43.730] - result: ‘FutureResult’
[13:37:43.730] resolved() for ‘SequentialFuture’ ... done
[13:37:43.730] Future #3
[13:37:43.730]  length: 1 (resolved future 3)
[13:37:43.730]  length: 0 (resolved future 4)
[13:37:43.730] resolve() on list environment ... DONE
[13:37:43.731] resolve() on list environment ...
[13:37:43.731]  recursive: 0
[13:37:43.731]  length: 4
[13:37:43.732]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:37:43.732] resolved() for ‘SequentialFuture’ ...
[13:37:43.732] - state: ‘finished’
[13:37:43.732] - run: TRUE
[13:37:43.732] - result: ‘FutureResult’
[13:37:43.732] resolved() for ‘SequentialFuture’ ... done
[13:37:43.732] Future #1
[13:37:43.732]  length: 3 (resolved future 1)
[13:37:43.732] resolved() for ‘SequentialFuture’ ...
[13:37:43.733] - state: ‘finished’
[13:37:43.733] - run: TRUE
[13:37:43.733] - result: ‘FutureResult’
[13:37:43.733] resolved() for ‘SequentialFuture’ ... done
[13:37:43.733] Future #2
[13:37:43.733]  length: 2 (resolved future 2)
[13:37:43.733] resolved() for ‘SequentialFuture’ ...
[13:37:43.733] - state: ‘finished’
[13:37:43.733] - run: TRUE
[13:37:43.733] - result: ‘FutureResult’
[13:37:43.734] resolved() for ‘SequentialFuture’ ... done
[13:37:43.734] Future #3
[13:37:43.734]  length: 1 (resolved future 3)
[13:37:43.734]  length: 0 (resolved future 4)
[13:37:43.734] resolve() on list environment ... DONE
[13:37:43.734] resolve() on list environment ...
[13:37:43.735]  recursive: 99
[13:37:43.735]  length: 4
[13:37:43.735]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:37:43.735] resolved() for ‘SequentialFuture’ ...
[13:37:43.736] - state: ‘finished’
[13:37:43.736] - run: TRUE
[13:37:43.736] - result: ‘FutureResult’
[13:37:43.736] resolved() for ‘SequentialFuture’ ... done
[13:37:43.736] Future #1
[13:37:43.736] resolved() for ‘SequentialFuture’ ...
[13:37:43.736] - state: ‘finished’
[13:37:43.736] - run: TRUE
[13:37:43.736] - result: ‘FutureResult’
[13:37:43.736] resolved() for ‘SequentialFuture’ ... done
[13:37:43.737] A SequentialFuture was resolved
[13:37:43.737]  length: 3 (resolved future 1)
[13:37:43.737] resolved() for ‘SequentialFuture’ ...
[13:37:43.737] - state: ‘finished’
[13:37:43.737] - run: TRUE
[13:37:43.737] - result: ‘FutureResult’
[13:37:43.737] resolved() for ‘SequentialFuture’ ... done
[13:37:43.737] Future #2
[13:37:43.737] resolved() for ‘SequentialFuture’ ...
[13:37:43.737] - state: ‘finished’
[13:37:43.738] - run: TRUE
[13:37:43.771] - result: ‘FutureResult’
[13:37:43.771] resolved() for ‘SequentialFuture’ ... done
[13:37:43.771] A SequentialFuture was resolved
[13:37:43.771]  length: 2 (resolved future 2)
[13:37:43.772] resolved() for ‘SequentialFuture’ ...
[13:37:43.772] - state: ‘finished’
[13:37:43.772] - run: TRUE
[13:37:43.772] - result: ‘FutureResult’
[13:37:43.772] resolved() for ‘SequentialFuture’ ... done
[13:37:43.772] Future #3
[13:37:43.772] resolved() for ‘SequentialFuture’ ...
[13:37:43.773] - state: ‘finished’
[13:37:43.773] - run: TRUE
[13:37:43.773] - result: ‘FutureResult’
[13:37:43.773] resolved() for ‘SequentialFuture’ ... done
[13:37:43.773] A SequentialFuture was resolved
[13:37:43.773]  length: 1 (resolved future 3)
[13:37:43.773]  length: 0 (resolved future 4)
[13:37:43.773] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('sequential') ...
- plan('multicore') ...
[13:37:43.774] plan(): Setting new future strategy stack:
[13:37:43.774] List of future strategies:
[13:37:43.774] 1. multicore:
[13:37:43.774]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:37:43.774]    - tweaked: FALSE
[13:37:43.774]    - call: plan(strategy)
[13:37:43.779] plan(): nbrOfWorkers() = 2
*** resolve() for lists ...
[13:37:43.779] resolve() on list ...
[13:37:43.779]  recursive: 0
[13:37:43.779]  length: 2
[13:37:43.779]  elements: ‘a’, ‘b’
[13:37:43.779]  length: 1 (resolved future 1)
[13:37:43.779]  length: 0 (resolved future 2)
[13:37:43.780] resolve() on list ... DONE
[13:37:43.780] getGlobalsAndPackages() ...
[13:37:43.780] Searching for globals...
[13:37:43.780] 
[13:37:43.780] Searching for globals ... DONE
[13:37:43.780] - globals: [0] <none>
[13:37:43.780] getGlobalsAndPackages() ... DONE
[13:37:43.781] run() for ‘Future’ ...
[13:37:43.781] - state: ‘created’
[13:37:43.781] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:37:43.785] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:43.785] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:37:43.785]   - Field: ‘label’
[13:37:43.785]   - Field: ‘local’
[13:37:43.785]   - Field: ‘owner’
[13:37:43.785]   - Field: ‘envir’
[13:37:43.786]   - Field: ‘workers’
[13:37:43.786]   - Field: ‘packages’
[13:37:43.786]   - Field: ‘gc’
[13:37:43.786]   - Field: ‘job’
[13:37:43.786]   - Field: ‘conditions’
[13:37:43.786]   - Field: ‘expr’
[13:37:43.786]   - Field: ‘uuid’
[13:37:43.786]   - Field: ‘seed’
[13:37:43.786]   - Field: ‘version’
[13:37:43.786]   - Field: ‘result’
[13:37:43.787]   - Field: ‘asynchronous’
[13:37:43.787]   - Field: ‘calls’
[13:37:43.787]   - Field: ‘globals’
[13:37:43.787]   - Field: ‘stdout’
[13:37:43.787]   - Field: ‘earlySignal’
[13:37:43.787]   - Field: ‘lazy’
[13:37:43.787]   - Field: ‘state’
[13:37:43.787] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:37:43.787] - Launch lazy future ...
[13:37:43.788] Packages needed by the future expression (n = 0): <none>
[13:37:43.789] Packages needed by future strategies (n = 0): <none>
[13:37:43.789] {
[13:37:43.789]     {
[13:37:43.789]         {
[13:37:43.789]             ...future.startTime <- base::Sys.time()
[13:37:43.789]             {
[13:37:43.789]                 {
[13:37:43.789]                   {
[13:37:43.789]                     {
[13:37:43.789]                       base::local({
[13:37:43.789]                         has_future <- base::requireNamespace("future", 
[13:37:43.789]                           quietly = TRUE)
[13:37:43.789]                         if (has_future) {
[13:37:43.789]                           ns <- base::getNamespace("future")
[13:37:43.789]                           version <- ns[[".package"]][["version"]]
[13:37:43.789]                           if (is.null(version)) 
[13:37:43.789]                             version <- utils::packageVersion("future")
[13:37:43.789]                         }
[13:37:43.789]                         else {
[13:37:43.789]                           version <- NULL
[13:37:43.789]                         }
[13:37:43.789]                         if (!has_future || version < "1.8.0") {
[13:37:43.789]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:43.789]                             "", base::R.version$version.string), 
[13:37:43.789]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:43.789]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:43.789]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:43.789]                               "release", "version")], collapse = " "), 
[13:37:43.789]                             hostname = base::Sys.info()[["nodename"]])
[13:37:43.789]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:43.789]                             info)
[13:37:43.789]                           info <- base::paste(info, collapse = "; ")
[13:37:43.789]                           if (!has_future) {
[13:37:43.789]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:43.789]                               info)
[13:37:43.789]                           }
[13:37:43.789]                           else {
[13:37:43.789]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:43.789]                               info, version)
[13:37:43.789]                           }
[13:37:43.789]                           base::stop(msg)
[13:37:43.789]                         }
[13:37:43.789]                       })
[13:37:43.789]                     }
[13:37:43.789]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:43.789]                     base::options(mc.cores = 1L)
[13:37:43.789]                   }
[13:37:43.789]                   ...future.strategy.old <- future::plan("list")
[13:37:43.789]                   options(future.plan = NULL)
[13:37:43.789]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.789]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:43.789]                 }
[13:37:43.789]                 ...future.workdir <- getwd()
[13:37:43.789]             }
[13:37:43.789]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:43.789]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:43.789]         }
[13:37:43.789]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:43.789]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:43.789]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:43.789]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:43.789]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:43.789]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:43.789]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:43.789]             base::names(...future.oldOptions))
[13:37:43.789]     }
[13:37:43.789]     if (FALSE) {
[13:37:43.789]     }
[13:37:43.789]     else {
[13:37:43.789]         if (TRUE) {
[13:37:43.789]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:43.789]                 open = "w")
[13:37:43.789]         }
[13:37:43.789]         else {
[13:37:43.789]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:43.789]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:43.789]         }
[13:37:43.789]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:43.789]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:43.789]             base::sink(type = "output", split = FALSE)
[13:37:43.789]             base::close(...future.stdout)
[13:37:43.789]         }, add = TRUE)
[13:37:43.789]     }
[13:37:43.789]     ...future.frame <- base::sys.nframe()
[13:37:43.789]     ...future.conditions <- base::list()
[13:37:43.789]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:43.789]     if (FALSE) {
[13:37:43.789]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:43.789]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:43.789]     }
[13:37:43.789]     ...future.result <- base::tryCatch({
[13:37:43.789]         base::withCallingHandlers({
[13:37:43.789]             ...future.value <- base::withVisible(base::local({
[13:37:43.789]                 withCallingHandlers({
[13:37:43.789]                   1
[13:37:43.789]                 }, immediateCondition = function(cond) {
[13:37:43.789]                   save_rds <- function (object, pathname, ...) 
[13:37:43.789]                   {
[13:37:43.789]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:37:43.789]                     if (file_test("-f", pathname_tmp)) {
[13:37:43.789]                       fi_tmp <- file.info(pathname_tmp)
[13:37:43.789]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:37:43.789]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:43.789]                         fi_tmp[["mtime"]])
[13:37:43.789]                     }
[13:37:43.789]                     tryCatch({
[13:37:43.789]                       saveRDS(object, file = pathname_tmp, ...)
[13:37:43.789]                     }, error = function(ex) {
[13:37:43.789]                       msg <- conditionMessage(ex)
[13:37:43.789]                       fi_tmp <- file.info(pathname_tmp)
[13:37:43.789]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:37:43.789]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:43.789]                         fi_tmp[["mtime"]], msg)
[13:37:43.789]                       ex$message <- msg
[13:37:43.789]                       stop(ex)
[13:37:43.789]                     })
[13:37:43.789]                     stopifnot(file_test("-f", pathname_tmp))
[13:37:43.789]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:37:43.789]                     if (!res || file_test("-f", pathname_tmp)) {
[13:37:43.789]                       fi_tmp <- file.info(pathname_tmp)
[13:37:43.789]                       fi <- file.info(pathname)
[13:37:43.789]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:37:43.789]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:43.789]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:37:43.789]                         fi[["size"]], fi[["mtime"]])
[13:37:43.789]                       stop(msg)
[13:37:43.789]                     }
[13:37:43.789]                     invisible(pathname)
[13:37:43.789]                   }
[13:37:43.789]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:37:43.789]                     rootPath = tempdir()) 
[13:37:43.789]                   {
[13:37:43.789]                     obj <- list(time = Sys.time(), condition = cond)
[13:37:43.789]                     file <- tempfile(pattern = class(cond)[1], 
[13:37:43.789]                       tmpdir = path, fileext = ".rds")
[13:37:43.789]                     save_rds(obj, file)
[13:37:43.789]                   }
[13:37:43.789]                   saveImmediateCondition(cond, path = "/tmp/RtmpLAMaHJ/.future/immediateConditions")
[13:37:43.789]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.789]                   {
[13:37:43.789]                     inherits <- base::inherits
[13:37:43.789]                     invokeRestart <- base::invokeRestart
[13:37:43.789]                     is.null <- base::is.null
[13:37:43.789]                     muffled <- FALSE
[13:37:43.789]                     if (inherits(cond, "message")) {
[13:37:43.789]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:43.789]                       if (muffled) 
[13:37:43.789]                         invokeRestart("muffleMessage")
[13:37:43.789]                     }
[13:37:43.789]                     else if (inherits(cond, "warning")) {
[13:37:43.789]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:43.789]                       if (muffled) 
[13:37:43.789]                         invokeRestart("muffleWarning")
[13:37:43.789]                     }
[13:37:43.789]                     else if (inherits(cond, "condition")) {
[13:37:43.789]                       if (!is.null(pattern)) {
[13:37:43.789]                         computeRestarts <- base::computeRestarts
[13:37:43.789]                         grepl <- base::grepl
[13:37:43.789]                         restarts <- computeRestarts(cond)
[13:37:43.789]                         for (restart in restarts) {
[13:37:43.789]                           name <- restart$name
[13:37:43.789]                           if (is.null(name)) 
[13:37:43.789]                             next
[13:37:43.789]                           if (!grepl(pattern, name)) 
[13:37:43.789]                             next
[13:37:43.789]                           invokeRestart(restart)
[13:37:43.789]                           muffled <- TRUE
[13:37:43.789]                           break
[13:37:43.789]                         }
[13:37:43.789]                       }
[13:37:43.789]                     }
[13:37:43.789]                     invisible(muffled)
[13:37:43.789]                   }
[13:37:43.789]                   muffleCondition(cond)
[13:37:43.789]                 })
[13:37:43.789]             }))
[13:37:43.789]             future::FutureResult(value = ...future.value$value, 
[13:37:43.789]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.789]                   ...future.rng), globalenv = if (FALSE) 
[13:37:43.789]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:43.789]                     ...future.globalenv.names))
[13:37:43.789]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:43.789]         }, condition = base::local({
[13:37:43.789]             c <- base::c
[13:37:43.789]             inherits <- base::inherits
[13:37:43.789]             invokeRestart <- base::invokeRestart
[13:37:43.789]             length <- base::length
[13:37:43.789]             list <- base::list
[13:37:43.789]             seq.int <- base::seq.int
[13:37:43.789]             signalCondition <- base::signalCondition
[13:37:43.789]             sys.calls <- base::sys.calls
[13:37:43.789]             `[[` <- base::`[[`
[13:37:43.789]             `+` <- base::`+`
[13:37:43.789]             `<<-` <- base::`<<-`
[13:37:43.789]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:43.789]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:43.789]                   3L)]
[13:37:43.789]             }
[13:37:43.789]             function(cond) {
[13:37:43.789]                 is_error <- inherits(cond, "error")
[13:37:43.789]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:43.789]                   NULL)
[13:37:43.789]                 if (is_error) {
[13:37:43.789]                   sessionInformation <- function() {
[13:37:43.789]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:43.789]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:43.789]                       search = base::search(), system = base::Sys.info())
[13:37:43.789]                   }
[13:37:43.789]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.789]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:43.789]                     cond$call), session = sessionInformation(), 
[13:37:43.789]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:43.789]                   signalCondition(cond)
[13:37:43.789]                 }
[13:37:43.789]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:43.789]                 "immediateCondition"))) {
[13:37:43.789]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:43.789]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.789]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:43.789]                   if (TRUE && !signal) {
[13:37:43.789]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.789]                     {
[13:37:43.789]                       inherits <- base::inherits
[13:37:43.789]                       invokeRestart <- base::invokeRestart
[13:37:43.789]                       is.null <- base::is.null
[13:37:43.789]                       muffled <- FALSE
[13:37:43.789]                       if (inherits(cond, "message")) {
[13:37:43.789]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.789]                         if (muffled) 
[13:37:43.789]                           invokeRestart("muffleMessage")
[13:37:43.789]                       }
[13:37:43.789]                       else if (inherits(cond, "warning")) {
[13:37:43.789]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.789]                         if (muffled) 
[13:37:43.789]                           invokeRestart("muffleWarning")
[13:37:43.789]                       }
[13:37:43.789]                       else if (inherits(cond, "condition")) {
[13:37:43.789]                         if (!is.null(pattern)) {
[13:37:43.789]                           computeRestarts <- base::computeRestarts
[13:37:43.789]                           grepl <- base::grepl
[13:37:43.789]                           restarts <- computeRestarts(cond)
[13:37:43.789]                           for (restart in restarts) {
[13:37:43.789]                             name <- restart$name
[13:37:43.789]                             if (is.null(name)) 
[13:37:43.789]                               next
[13:37:43.789]                             if (!grepl(pattern, name)) 
[13:37:43.789]                               next
[13:37:43.789]                             invokeRestart(restart)
[13:37:43.789]                             muffled <- TRUE
[13:37:43.789]                             break
[13:37:43.789]                           }
[13:37:43.789]                         }
[13:37:43.789]                       }
[13:37:43.789]                       invisible(muffled)
[13:37:43.789]                     }
[13:37:43.789]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.789]                   }
[13:37:43.789]                 }
[13:37:43.789]                 else {
[13:37:43.789]                   if (TRUE) {
[13:37:43.789]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.789]                     {
[13:37:43.789]                       inherits <- base::inherits
[13:37:43.789]                       invokeRestart <- base::invokeRestart
[13:37:43.789]                       is.null <- base::is.null
[13:37:43.789]                       muffled <- FALSE
[13:37:43.789]                       if (inherits(cond, "message")) {
[13:37:43.789]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.789]                         if (muffled) 
[13:37:43.789]                           invokeRestart("muffleMessage")
[13:37:43.789]                       }
[13:37:43.789]                       else if (inherits(cond, "warning")) {
[13:37:43.789]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.789]                         if (muffled) 
[13:37:43.789]                           invokeRestart("muffleWarning")
[13:37:43.789]                       }
[13:37:43.789]                       else if (inherits(cond, "condition")) {
[13:37:43.789]                         if (!is.null(pattern)) {
[13:37:43.789]                           computeRestarts <- base::computeRestarts
[13:37:43.789]                           grepl <- base::grepl
[13:37:43.789]                           restarts <- computeRestarts(cond)
[13:37:43.789]                           for (restart in restarts) {
[13:37:43.789]                             name <- restart$name
[13:37:43.789]                             if (is.null(name)) 
[13:37:43.789]                               next
[13:37:43.789]                             if (!grepl(pattern, name)) 
[13:37:43.789]                               next
[13:37:43.789]                             invokeRestart(restart)
[13:37:43.789]                             muffled <- TRUE
[13:37:43.789]                             break
[13:37:43.789]                           }
[13:37:43.789]                         }
[13:37:43.789]                       }
[13:37:43.789]                       invisible(muffled)
[13:37:43.789]                     }
[13:37:43.789]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.789]                   }
[13:37:43.789]                 }
[13:37:43.789]             }
[13:37:43.789]         }))
[13:37:43.789]     }, error = function(ex) {
[13:37:43.789]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:43.789]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.789]                 ...future.rng), started = ...future.startTime, 
[13:37:43.789]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:43.789]             version = "1.8"), class = "FutureResult")
[13:37:43.789]     }, finally = {
[13:37:43.789]         if (!identical(...future.workdir, getwd())) 
[13:37:43.789]             setwd(...future.workdir)
[13:37:43.789]         {
[13:37:43.789]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:43.789]                 ...future.oldOptions$nwarnings <- NULL
[13:37:43.789]             }
[13:37:43.789]             base::options(...future.oldOptions)
[13:37:43.789]             if (.Platform$OS.type == "windows") {
[13:37:43.789]                 old_names <- names(...future.oldEnvVars)
[13:37:43.789]                 envs <- base::Sys.getenv()
[13:37:43.789]                 names <- names(envs)
[13:37:43.789]                 common <- intersect(names, old_names)
[13:37:43.789]                 added <- setdiff(names, old_names)
[13:37:43.789]                 removed <- setdiff(old_names, names)
[13:37:43.789]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:43.789]                   envs[common]]
[13:37:43.789]                 NAMES <- toupper(changed)
[13:37:43.789]                 args <- list()
[13:37:43.789]                 for (kk in seq_along(NAMES)) {
[13:37:43.789]                   name <- changed[[kk]]
[13:37:43.789]                   NAME <- NAMES[[kk]]
[13:37:43.789]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.789]                     next
[13:37:43.789]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.789]                 }
[13:37:43.789]                 NAMES <- toupper(added)
[13:37:43.789]                 for (kk in seq_along(NAMES)) {
[13:37:43.789]                   name <- added[[kk]]
[13:37:43.789]                   NAME <- NAMES[[kk]]
[13:37:43.789]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.789]                     next
[13:37:43.789]                   args[[name]] <- ""
[13:37:43.789]                 }
[13:37:43.789]                 NAMES <- toupper(removed)
[13:37:43.789]                 for (kk in seq_along(NAMES)) {
[13:37:43.789]                   name <- removed[[kk]]
[13:37:43.789]                   NAME <- NAMES[[kk]]
[13:37:43.789]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.789]                     next
[13:37:43.789]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.789]                 }
[13:37:43.789]                 if (length(args) > 0) 
[13:37:43.789]                   base::do.call(base::Sys.setenv, args = args)
[13:37:43.789]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:43.789]             }
[13:37:43.789]             else {
[13:37:43.789]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:43.789]             }
[13:37:43.789]             {
[13:37:43.789]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:43.789]                   0L) {
[13:37:43.789]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:43.789]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:43.789]                   base::options(opts)
[13:37:43.789]                 }
[13:37:43.789]                 {
[13:37:43.789]                   {
[13:37:43.789]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:43.789]                     NULL
[13:37:43.789]                   }
[13:37:43.789]                   options(future.plan = NULL)
[13:37:43.789]                   if (is.na(NA_character_)) 
[13:37:43.789]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.789]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:43.789]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:43.789]                     .init = FALSE)
[13:37:43.789]                 }
[13:37:43.789]             }
[13:37:43.789]         }
[13:37:43.789]     })
[13:37:43.789]     if (TRUE) {
[13:37:43.789]         base::sink(type = "output", split = FALSE)
[13:37:43.789]         if (TRUE) {
[13:37:43.789]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:43.789]         }
[13:37:43.789]         else {
[13:37:43.789]             ...future.result["stdout"] <- base::list(NULL)
[13:37:43.789]         }
[13:37:43.789]         base::close(...future.stdout)
[13:37:43.789]         ...future.stdout <- NULL
[13:37:43.789]     }
[13:37:43.789]     ...future.result$conditions <- ...future.conditions
[13:37:43.789]     ...future.result$finished <- base::Sys.time()
[13:37:43.789]     ...future.result
[13:37:43.789] }
[13:37:43.791] requestCore(): workers = 2
[13:37:43.795] MulticoreFuture started
[13:37:43.795] - Launch lazy future ... done
[13:37:43.795] run() for ‘MulticoreFuture’ ... done
[13:37:43.796] plan(): Setting new future strategy stack:
[13:37:43.796] getGlobalsAndPackages() ...
[13:37:43.796] Searching for globals...
[13:37:43.796] List of future strategies:
[13:37:43.796] 1. sequential:
[13:37:43.796]    - args: function (..., envir = parent.frame())
[13:37:43.796]    - tweaked: FALSE
[13:37:43.796]    - call: NULL
[13:37:43.797] plan(): nbrOfWorkers() = 1
[13:37:43.797] 
[13:37:43.798] Searching for globals ... DONE
[13:37:43.798] - globals: [0] <none>
[13:37:43.798] getGlobalsAndPackages() ... DONE
[13:37:43.799] run() for ‘Future’ ...
[13:37:43.799] - state: ‘created’
[13:37:43.799] plan(): Setting new future strategy stack:
[13:37:43.799] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:37:43.799] List of future strategies:
[13:37:43.799] 1. multicore:
[13:37:43.799]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:37:43.799]    - tweaked: FALSE
[13:37:43.799]    - call: plan(strategy)
[13:37:43.804] plan(): nbrOfWorkers() = 2
[13:37:43.805] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:43.805] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:37:43.805]   - Field: ‘label’
[13:37:43.805]   - Field: ‘local’
[13:37:43.806]   - Field: ‘owner’
[13:37:43.806]   - Field: ‘envir’
[13:37:43.806]   - Field: ‘workers’
[13:37:43.806]   - Field: ‘packages’
[13:37:43.806]   - Field: ‘gc’
[13:37:43.806]   - Field: ‘job’
[13:37:43.806]   - Field: ‘conditions’
[13:37:43.807]   - Field: ‘expr’
[13:37:43.807]   - Field: ‘uuid’
[13:37:43.807]   - Field: ‘seed’
[13:37:43.807]   - Field: ‘version’
[13:37:43.807]   - Field: ‘result’
[13:37:43.807]   - Field: ‘asynchronous’
[13:37:43.808]   - Field: ‘calls’
[13:37:43.808]   - Field: ‘globals’
[13:37:43.808]   - Field: ‘stdout’
[13:37:43.808]   - Field: ‘earlySignal’
[13:37:43.808]   - Field: ‘lazy’
[13:37:43.808]   - Field: ‘state’
[13:37:43.808] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:37:43.809] - Launch lazy future ...
[13:37:43.809] Packages needed by the future expression (n = 0): <none>
[13:37:43.809] Packages needed by future strategies (n = 0): <none>
[13:37:43.810] {
[13:37:43.810]     {
[13:37:43.810]         {
[13:37:43.810]             ...future.startTime <- base::Sys.time()
[13:37:43.810]             {
[13:37:43.810]                 {
[13:37:43.810]                   {
[13:37:43.810]                     {
[13:37:43.810]                       base::local({
[13:37:43.810]                         has_future <- base::requireNamespace("future", 
[13:37:43.810]                           quietly = TRUE)
[13:37:43.810]                         if (has_future) {
[13:37:43.810]                           ns <- base::getNamespace("future")
[13:37:43.810]                           version <- ns[[".package"]][["version"]]
[13:37:43.810]                           if (is.null(version)) 
[13:37:43.810]                             version <- utils::packageVersion("future")
[13:37:43.810]                         }
[13:37:43.810]                         else {
[13:37:43.810]                           version <- NULL
[13:37:43.810]                         }
[13:37:43.810]                         if (!has_future || version < "1.8.0") {
[13:37:43.810]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:43.810]                             "", base::R.version$version.string), 
[13:37:43.810]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:43.810]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:43.810]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:43.810]                               "release", "version")], collapse = " "), 
[13:37:43.810]                             hostname = base::Sys.info()[["nodename"]])
[13:37:43.810]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:43.810]                             info)
[13:37:43.810]                           info <- base::paste(info, collapse = "; ")
[13:37:43.810]                           if (!has_future) {
[13:37:43.810]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:43.810]                               info)
[13:37:43.810]                           }
[13:37:43.810]                           else {
[13:37:43.810]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:43.810]                               info, version)
[13:37:43.810]                           }
[13:37:43.810]                           base::stop(msg)
[13:37:43.810]                         }
[13:37:43.810]                       })
[13:37:43.810]                     }
[13:37:43.810]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:43.810]                     base::options(mc.cores = 1L)
[13:37:43.810]                   }
[13:37:43.810]                   ...future.strategy.old <- future::plan("list")
[13:37:43.810]                   options(future.plan = NULL)
[13:37:43.810]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.810]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:43.810]                 }
[13:37:43.810]                 ...future.workdir <- getwd()
[13:37:43.810]             }
[13:37:43.810]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:43.810]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:43.810]         }
[13:37:43.810]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:43.810]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:43.810]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:43.810]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:43.810]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:43.810]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:43.810]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:43.810]             base::names(...future.oldOptions))
[13:37:43.810]     }
[13:37:43.810]     if (FALSE) {
[13:37:43.810]     }
[13:37:43.810]     else {
[13:37:43.810]         if (TRUE) {
[13:37:43.810]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:43.810]                 open = "w")
[13:37:43.810]         }
[13:37:43.810]         else {
[13:37:43.810]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:43.810]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:43.810]         }
[13:37:43.810]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:43.810]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:43.810]             base::sink(type = "output", split = FALSE)
[13:37:43.810]             base::close(...future.stdout)
[13:37:43.810]         }, add = TRUE)
[13:37:43.810]     }
[13:37:43.810]     ...future.frame <- base::sys.nframe()
[13:37:43.810]     ...future.conditions <- base::list()
[13:37:43.810]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:43.810]     if (FALSE) {
[13:37:43.810]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:43.810]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:43.810]     }
[13:37:43.810]     ...future.result <- base::tryCatch({
[13:37:43.810]         base::withCallingHandlers({
[13:37:43.810]             ...future.value <- base::withVisible(base::local({
[13:37:43.810]                 withCallingHandlers({
[13:37:43.810]                   2
[13:37:43.810]                 }, immediateCondition = function(cond) {
[13:37:43.810]                   save_rds <- function (object, pathname, ...) 
[13:37:43.810]                   {
[13:37:43.810]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:37:43.810]                     if (file_test("-f", pathname_tmp)) {
[13:37:43.810]                       fi_tmp <- file.info(pathname_tmp)
[13:37:43.810]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:37:43.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:43.810]                         fi_tmp[["mtime"]])
[13:37:43.810]                     }
[13:37:43.810]                     tryCatch({
[13:37:43.810]                       saveRDS(object, file = pathname_tmp, ...)
[13:37:43.810]                     }, error = function(ex) {
[13:37:43.810]                       msg <- conditionMessage(ex)
[13:37:43.810]                       fi_tmp <- file.info(pathname_tmp)
[13:37:43.810]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:37:43.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:43.810]                         fi_tmp[["mtime"]], msg)
[13:37:43.810]                       ex$message <- msg
[13:37:43.810]                       stop(ex)
[13:37:43.810]                     })
[13:37:43.810]                     stopifnot(file_test("-f", pathname_tmp))
[13:37:43.810]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:37:43.810]                     if (!res || file_test("-f", pathname_tmp)) {
[13:37:43.810]                       fi_tmp <- file.info(pathname_tmp)
[13:37:43.810]                       fi <- file.info(pathname)
[13:37:43.810]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:37:43.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:43.810]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:37:43.810]                         fi[["size"]], fi[["mtime"]])
[13:37:43.810]                       stop(msg)
[13:37:43.810]                     }
[13:37:43.810]                     invisible(pathname)
[13:37:43.810]                   }
[13:37:43.810]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:37:43.810]                     rootPath = tempdir()) 
[13:37:43.810]                   {
[13:37:43.810]                     obj <- list(time = Sys.time(), condition = cond)
[13:37:43.810]                     file <- tempfile(pattern = class(cond)[1], 
[13:37:43.810]                       tmpdir = path, fileext = ".rds")
[13:37:43.810]                     save_rds(obj, file)
[13:37:43.810]                   }
[13:37:43.810]                   saveImmediateCondition(cond, path = "/tmp/RtmpLAMaHJ/.future/immediateConditions")
[13:37:43.810]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.810]                   {
[13:37:43.810]                     inherits <- base::inherits
[13:37:43.810]                     invokeRestart <- base::invokeRestart
[13:37:43.810]                     is.null <- base::is.null
[13:37:43.810]                     muffled <- FALSE
[13:37:43.810]                     if (inherits(cond, "message")) {
[13:37:43.810]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:43.810]                       if (muffled) 
[13:37:43.810]                         invokeRestart("muffleMessage")
[13:37:43.810]                     }
[13:37:43.810]                     else if (inherits(cond, "warning")) {
[13:37:43.810]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:43.810]                       if (muffled) 
[13:37:43.810]                         invokeRestart("muffleWarning")
[13:37:43.810]                     }
[13:37:43.810]                     else if (inherits(cond, "condition")) {
[13:37:43.810]                       if (!is.null(pattern)) {
[13:37:43.810]                         computeRestarts <- base::computeRestarts
[13:37:43.810]                         grepl <- base::grepl
[13:37:43.810]                         restarts <- computeRestarts(cond)
[13:37:43.810]                         for (restart in restarts) {
[13:37:43.810]                           name <- restart$name
[13:37:43.810]                           if (is.null(name)) 
[13:37:43.810]                             next
[13:37:43.810]                           if (!grepl(pattern, name)) 
[13:37:43.810]                             next
[13:37:43.810]                           invokeRestart(restart)
[13:37:43.810]                           muffled <- TRUE
[13:37:43.810]                           break
[13:37:43.810]                         }
[13:37:43.810]                       }
[13:37:43.810]                     }
[13:37:43.810]                     invisible(muffled)
[13:37:43.810]                   }
[13:37:43.810]                   muffleCondition(cond)
[13:37:43.810]                 })
[13:37:43.810]             }))
[13:37:43.810]             future::FutureResult(value = ...future.value$value, 
[13:37:43.810]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.810]                   ...future.rng), globalenv = if (FALSE) 
[13:37:43.810]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:43.810]                     ...future.globalenv.names))
[13:37:43.810]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:43.810]         }, condition = base::local({
[13:37:43.810]             c <- base::c
[13:37:43.810]             inherits <- base::inherits
[13:37:43.810]             invokeRestart <- base::invokeRestart
[13:37:43.810]             length <- base::length
[13:37:43.810]             list <- base::list
[13:37:43.810]             seq.int <- base::seq.int
[13:37:43.810]             signalCondition <- base::signalCondition
[13:37:43.810]             sys.calls <- base::sys.calls
[13:37:43.810]             `[[` <- base::`[[`
[13:37:43.810]             `+` <- base::`+`
[13:37:43.810]             `<<-` <- base::`<<-`
[13:37:43.810]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:43.810]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:43.810]                   3L)]
[13:37:43.810]             }
[13:37:43.810]             function(cond) {
[13:37:43.810]                 is_error <- inherits(cond, "error")
[13:37:43.810]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:43.810]                   NULL)
[13:37:43.810]                 if (is_error) {
[13:37:43.810]                   sessionInformation <- function() {
[13:37:43.810]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:43.810]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:43.810]                       search = base::search(), system = base::Sys.info())
[13:37:43.810]                   }
[13:37:43.810]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.810]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:43.810]                     cond$call), session = sessionInformation(), 
[13:37:43.810]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:43.810]                   signalCondition(cond)
[13:37:43.810]                 }
[13:37:43.810]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:43.810]                 "immediateCondition"))) {
[13:37:43.810]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:43.810]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.810]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:43.810]                   if (TRUE && !signal) {
[13:37:43.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.810]                     {
[13:37:43.810]                       inherits <- base::inherits
[13:37:43.810]                       invokeRestart <- base::invokeRestart
[13:37:43.810]                       is.null <- base::is.null
[13:37:43.810]                       muffled <- FALSE
[13:37:43.810]                       if (inherits(cond, "message")) {
[13:37:43.810]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.810]                         if (muffled) 
[13:37:43.810]                           invokeRestart("muffleMessage")
[13:37:43.810]                       }
[13:37:43.810]                       else if (inherits(cond, "warning")) {
[13:37:43.810]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.810]                         if (muffled) 
[13:37:43.810]                           invokeRestart("muffleWarning")
[13:37:43.810]                       }
[13:37:43.810]                       else if (inherits(cond, "condition")) {
[13:37:43.810]                         if (!is.null(pattern)) {
[13:37:43.810]                           computeRestarts <- base::computeRestarts
[13:37:43.810]                           grepl <- base::grepl
[13:37:43.810]                           restarts <- computeRestarts(cond)
[13:37:43.810]                           for (restart in restarts) {
[13:37:43.810]                             name <- restart$name
[13:37:43.810]                             if (is.null(name)) 
[13:37:43.810]                               next
[13:37:43.810]                             if (!grepl(pattern, name)) 
[13:37:43.810]                               next
[13:37:43.810]                             invokeRestart(restart)
[13:37:43.810]                             muffled <- TRUE
[13:37:43.810]                             break
[13:37:43.810]                           }
[13:37:43.810]                         }
[13:37:43.810]                       }
[13:37:43.810]                       invisible(muffled)
[13:37:43.810]                     }
[13:37:43.810]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.810]                   }
[13:37:43.810]                 }
[13:37:43.810]                 else {
[13:37:43.810]                   if (TRUE) {
[13:37:43.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.810]                     {
[13:37:43.810]                       inherits <- base::inherits
[13:37:43.810]                       invokeRestart <- base::invokeRestart
[13:37:43.810]                       is.null <- base::is.null
[13:37:43.810]                       muffled <- FALSE
[13:37:43.810]                       if (inherits(cond, "message")) {
[13:37:43.810]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.810]                         if (muffled) 
[13:37:43.810]                           invokeRestart("muffleMessage")
[13:37:43.810]                       }
[13:37:43.810]                       else if (inherits(cond, "warning")) {
[13:37:43.810]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.810]                         if (muffled) 
[13:37:43.810]                           invokeRestart("muffleWarning")
[13:37:43.810]                       }
[13:37:43.810]                       else if (inherits(cond, "condition")) {
[13:37:43.810]                         if (!is.null(pattern)) {
[13:37:43.810]                           computeRestarts <- base::computeRestarts
[13:37:43.810]                           grepl <- base::grepl
[13:37:43.810]                           restarts <- computeRestarts(cond)
[13:37:43.810]                           for (restart in restarts) {
[13:37:43.810]                             name <- restart$name
[13:37:43.810]                             if (is.null(name)) 
[13:37:43.810]                               next
[13:37:43.810]                             if (!grepl(pattern, name)) 
[13:37:43.810]                               next
[13:37:43.810]                             invokeRestart(restart)
[13:37:43.810]                             muffled <- TRUE
[13:37:43.810]                             break
[13:37:43.810]                           }
[13:37:43.810]                         }
[13:37:43.810]                       }
[13:37:43.810]                       invisible(muffled)
[13:37:43.810]                     }
[13:37:43.810]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.810]                   }
[13:37:43.810]                 }
[13:37:43.810]             }
[13:37:43.810]         }))
[13:37:43.810]     }, error = function(ex) {
[13:37:43.810]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:43.810]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.810]                 ...future.rng), started = ...future.startTime, 
[13:37:43.810]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:43.810]             version = "1.8"), class = "FutureResult")
[13:37:43.810]     }, finally = {
[13:37:43.810]         if (!identical(...future.workdir, getwd())) 
[13:37:43.810]             setwd(...future.workdir)
[13:37:43.810]         {
[13:37:43.810]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:43.810]                 ...future.oldOptions$nwarnings <- NULL
[13:37:43.810]             }
[13:37:43.810]             base::options(...future.oldOptions)
[13:37:43.810]             if (.Platform$OS.type == "windows") {
[13:37:43.810]                 old_names <- names(...future.oldEnvVars)
[13:37:43.810]                 envs <- base::Sys.getenv()
[13:37:43.810]                 names <- names(envs)
[13:37:43.810]                 common <- intersect(names, old_names)
[13:37:43.810]                 added <- setdiff(names, old_names)
[13:37:43.810]                 removed <- setdiff(old_names, names)
[13:37:43.810]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:43.810]                   envs[common]]
[13:37:43.810]                 NAMES <- toupper(changed)
[13:37:43.810]                 args <- list()
[13:37:43.810]                 for (kk in seq_along(NAMES)) {
[13:37:43.810]                   name <- changed[[kk]]
[13:37:43.810]                   NAME <- NAMES[[kk]]
[13:37:43.810]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.810]                     next
[13:37:43.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.810]                 }
[13:37:43.810]                 NAMES <- toupper(added)
[13:37:43.810]                 for (kk in seq_along(NAMES)) {
[13:37:43.810]                   name <- added[[kk]]
[13:37:43.810]                   NAME <- NAMES[[kk]]
[13:37:43.810]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.810]                     next
[13:37:43.810]                   args[[name]] <- ""
[13:37:43.810]                 }
[13:37:43.810]                 NAMES <- toupper(removed)
[13:37:43.810]                 for (kk in seq_along(NAMES)) {
[13:37:43.810]                   name <- removed[[kk]]
[13:37:43.810]                   NAME <- NAMES[[kk]]
[13:37:43.810]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.810]                     next
[13:37:43.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.810]                 }
[13:37:43.810]                 if (length(args) > 0) 
[13:37:43.810]                   base::do.call(base::Sys.setenv, args = args)
[13:37:43.810]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:43.810]             }
[13:37:43.810]             else {
[13:37:43.810]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:43.810]             }
[13:37:43.810]             {
[13:37:43.810]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:43.810]                   0L) {
[13:37:43.810]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:43.810]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:43.810]                   base::options(opts)
[13:37:43.810]                 }
[13:37:43.810]                 {
[13:37:43.810]                   {
[13:37:43.810]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:43.810]                     NULL
[13:37:43.810]                   }
[13:37:43.810]                   options(future.plan = NULL)
[13:37:43.810]                   if (is.na(NA_character_)) 
[13:37:43.810]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.810]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:43.810]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:43.810]                     .init = FALSE)
[13:37:43.810]                 }
[13:37:43.810]             }
[13:37:43.810]         }
[13:37:43.810]     })
[13:37:43.810]     if (TRUE) {
[13:37:43.810]         base::sink(type = "output", split = FALSE)
[13:37:43.810]         if (TRUE) {
[13:37:43.810]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:43.810]         }
[13:37:43.810]         else {
[13:37:43.810]             ...future.result["stdout"] <- base::list(NULL)
[13:37:43.810]         }
[13:37:43.810]         base::close(...future.stdout)
[13:37:43.810]         ...future.stdout <- NULL
[13:37:43.810]     }
[13:37:43.810]     ...future.result$conditions <- ...future.conditions
[13:37:43.810]     ...future.result$finished <- base::Sys.time()
[13:37:43.810]     ...future.result
[13:37:43.810] }
[13:37:43.813] requestCore(): workers = 2
[13:37:43.820] MulticoreFuture started
[13:37:43.820] - Launch lazy future ... done
[13:37:43.821] run() for ‘MulticoreFuture’ ... done
[13:37:43.821] resolve() on list ...
[13:37:43.821]  recursive: 0
[13:37:43.821]  length: 3
[13:37:43.821] plan(): Setting new future strategy stack:
[13:37:43.821]  elements: ‘a’, ‘b’, ‘’
[13:37:43.822] List of future strategies:
[13:37:43.822] 1. sequential:
[13:37:43.822]    - args: function (..., envir = parent.frame())
[13:37:43.822]    - tweaked: FALSE
[13:37:43.822]    - call: NULL
[13:37:43.823] plan(): nbrOfWorkers() = 1
[13:37:43.824] Future #1
[13:37:43.824]  length: 2 (resolved future 1)
[13:37:43.825] plan(): Setting new future strategy stack:
[13:37:43.825] List of future strategies:
[13:37:43.825] 1. multicore:
[13:37:43.825]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:37:43.825]    - tweaked: FALSE
[13:37:43.825]    - call: plan(strategy)
[13:37:43.830] plan(): nbrOfWorkers() = 2
[13:37:43.831] Future #2
[13:37:43.831]  length: 1 (resolved future 2)
[13:37:43.831]  length: 0 (resolved future 3)
[13:37:43.831] resolve() on list ... DONE
[13:37:43.832] getGlobalsAndPackages() ...
[13:37:43.832] Searching for globals...
[13:37:43.833] 
[13:37:43.833] Searching for globals ... DONE
[13:37:43.833] - globals: [0] <none>
[13:37:43.833] getGlobalsAndPackages() ... DONE
[13:37:43.834] getGlobalsAndPackages() ...
[13:37:43.834] Searching for globals...
[13:37:43.835] 
[13:37:43.835] Searching for globals ... DONE
[13:37:43.835] - globals: [0] <none>
[13:37:43.835] getGlobalsAndPackages() ... DONE
[13:37:43.835] run() for ‘Future’ ...
[13:37:43.836] - state: ‘created’
[13:37:43.836] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:37:43.848] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:43.848] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:37:43.848]   - Field: ‘label’
[13:37:43.849]   - Field: ‘local’
[13:37:43.849]   - Field: ‘owner’
[13:37:43.849]   - Field: ‘envir’
[13:37:43.849]   - Field: ‘workers’
[13:37:43.849]   - Field: ‘packages’
[13:37:43.850]   - Field: ‘gc’
[13:37:43.850]   - Field: ‘job’
[13:37:43.850]   - Field: ‘conditions’
[13:37:43.850]   - Field: ‘expr’
[13:37:43.850]   - Field: ‘uuid’
[13:37:43.851]   - Field: ‘seed’
[13:37:43.851]   - Field: ‘version’
[13:37:43.851]   - Field: ‘result’
[13:37:43.851]   - Field: ‘asynchronous’
[13:37:43.851]   - Field: ‘calls’
[13:37:43.851]   - Field: ‘globals’
[13:37:43.852]   - Field: ‘stdout’
[13:37:43.852]   - Field: ‘earlySignal’
[13:37:43.852]   - Field: ‘lazy’
[13:37:43.852]   - Field: ‘state’
[13:37:43.852] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:37:43.852] - Launch lazy future ...
[13:37:43.853] Packages needed by the future expression (n = 0): <none>
[13:37:43.853] Packages needed by future strategies (n = 0): <none>
[13:37:43.854] {
[13:37:43.854]     {
[13:37:43.854]         {
[13:37:43.854]             ...future.startTime <- base::Sys.time()
[13:37:43.854]             {
[13:37:43.854]                 {
[13:37:43.854]                   {
[13:37:43.854]                     {
[13:37:43.854]                       base::local({
[13:37:43.854]                         has_future <- base::requireNamespace("future", 
[13:37:43.854]                           quietly = TRUE)
[13:37:43.854]                         if (has_future) {
[13:37:43.854]                           ns <- base::getNamespace("future")
[13:37:43.854]                           version <- ns[[".package"]][["version"]]
[13:37:43.854]                           if (is.null(version)) 
[13:37:43.854]                             version <- utils::packageVersion("future")
[13:37:43.854]                         }
[13:37:43.854]                         else {
[13:37:43.854]                           version <- NULL
[13:37:43.854]                         }
[13:37:43.854]                         if (!has_future || version < "1.8.0") {
[13:37:43.854]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:43.854]                             "", base::R.version$version.string), 
[13:37:43.854]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:43.854]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:43.854]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:43.854]                               "release", "version")], collapse = " "), 
[13:37:43.854]                             hostname = base::Sys.info()[["nodename"]])
[13:37:43.854]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:43.854]                             info)
[13:37:43.854]                           info <- base::paste(info, collapse = "; ")
[13:37:43.854]                           if (!has_future) {
[13:37:43.854]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:43.854]                               info)
[13:37:43.854]                           }
[13:37:43.854]                           else {
[13:37:43.854]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:43.854]                               info, version)
[13:37:43.854]                           }
[13:37:43.854]                           base::stop(msg)
[13:37:43.854]                         }
[13:37:43.854]                       })
[13:37:43.854]                     }
[13:37:43.854]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:43.854]                     base::options(mc.cores = 1L)
[13:37:43.854]                   }
[13:37:43.854]                   ...future.strategy.old <- future::plan("list")
[13:37:43.854]                   options(future.plan = NULL)
[13:37:43.854]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.854]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:43.854]                 }
[13:37:43.854]                 ...future.workdir <- getwd()
[13:37:43.854]             }
[13:37:43.854]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:43.854]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:43.854]         }
[13:37:43.854]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:43.854]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:43.854]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:43.854]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:43.854]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:43.854]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:43.854]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:43.854]             base::names(...future.oldOptions))
[13:37:43.854]     }
[13:37:43.854]     if (FALSE) {
[13:37:43.854]     }
[13:37:43.854]     else {
[13:37:43.854]         if (TRUE) {
[13:37:43.854]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:43.854]                 open = "w")
[13:37:43.854]         }
[13:37:43.854]         else {
[13:37:43.854]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:43.854]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:43.854]         }
[13:37:43.854]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:43.854]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:43.854]             base::sink(type = "output", split = FALSE)
[13:37:43.854]             base::close(...future.stdout)
[13:37:43.854]         }, add = TRUE)
[13:37:43.854]     }
[13:37:43.854]     ...future.frame <- base::sys.nframe()
[13:37:43.854]     ...future.conditions <- base::list()
[13:37:43.854]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:43.854]     if (FALSE) {
[13:37:43.854]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:43.854]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:43.854]     }
[13:37:43.854]     ...future.result <- base::tryCatch({
[13:37:43.854]         base::withCallingHandlers({
[13:37:43.854]             ...future.value <- base::withVisible(base::local({
[13:37:43.854]                 withCallingHandlers({
[13:37:43.854]                   2
[13:37:43.854]                 }, immediateCondition = function(cond) {
[13:37:43.854]                   save_rds <- function (object, pathname, ...) 
[13:37:43.854]                   {
[13:37:43.854]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:37:43.854]                     if (file_test("-f", pathname_tmp)) {
[13:37:43.854]                       fi_tmp <- file.info(pathname_tmp)
[13:37:43.854]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:37:43.854]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:43.854]                         fi_tmp[["mtime"]])
[13:37:43.854]                     }
[13:37:43.854]                     tryCatch({
[13:37:43.854]                       saveRDS(object, file = pathname_tmp, ...)
[13:37:43.854]                     }, error = function(ex) {
[13:37:43.854]                       msg <- conditionMessage(ex)
[13:37:43.854]                       fi_tmp <- file.info(pathname_tmp)
[13:37:43.854]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:37:43.854]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:43.854]                         fi_tmp[["mtime"]], msg)
[13:37:43.854]                       ex$message <- msg
[13:37:43.854]                       stop(ex)
[13:37:43.854]                     })
[13:37:43.854]                     stopifnot(file_test("-f", pathname_tmp))
[13:37:43.854]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:37:43.854]                     if (!res || file_test("-f", pathname_tmp)) {
[13:37:43.854]                       fi_tmp <- file.info(pathname_tmp)
[13:37:43.854]                       fi <- file.info(pathname)
[13:37:43.854]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:37:43.854]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:43.854]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:37:43.854]                         fi[["size"]], fi[["mtime"]])
[13:37:43.854]                       stop(msg)
[13:37:43.854]                     }
[13:37:43.854]                     invisible(pathname)
[13:37:43.854]                   }
[13:37:43.854]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:37:43.854]                     rootPath = tempdir()) 
[13:37:43.854]                   {
[13:37:43.854]                     obj <- list(time = Sys.time(), condition = cond)
[13:37:43.854]                     file <- tempfile(pattern = class(cond)[1], 
[13:37:43.854]                       tmpdir = path, fileext = ".rds")
[13:37:43.854]                     save_rds(obj, file)
[13:37:43.854]                   }
[13:37:43.854]                   saveImmediateCondition(cond, path = "/tmp/RtmpLAMaHJ/.future/immediateConditions")
[13:37:43.854]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.854]                   {
[13:37:43.854]                     inherits <- base::inherits
[13:37:43.854]                     invokeRestart <- base::invokeRestart
[13:37:43.854]                     is.null <- base::is.null
[13:37:43.854]                     muffled <- FALSE
[13:37:43.854]                     if (inherits(cond, "message")) {
[13:37:43.854]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:43.854]                       if (muffled) 
[13:37:43.854]                         invokeRestart("muffleMessage")
[13:37:43.854]                     }
[13:37:43.854]                     else if (inherits(cond, "warning")) {
[13:37:43.854]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:43.854]                       if (muffled) 
[13:37:43.854]                         invokeRestart("muffleWarning")
[13:37:43.854]                     }
[13:37:43.854]                     else if (inherits(cond, "condition")) {
[13:37:43.854]                       if (!is.null(pattern)) {
[13:37:43.854]                         computeRestarts <- base::computeRestarts
[13:37:43.854]                         grepl <- base::grepl
[13:37:43.854]                         restarts <- computeRestarts(cond)
[13:37:43.854]                         for (restart in restarts) {
[13:37:43.854]                           name <- restart$name
[13:37:43.854]                           if (is.null(name)) 
[13:37:43.854]                             next
[13:37:43.854]                           if (!grepl(pattern, name)) 
[13:37:43.854]                             next
[13:37:43.854]                           invokeRestart(restart)
[13:37:43.854]                           muffled <- TRUE
[13:37:43.854]                           break
[13:37:43.854]                         }
[13:37:43.854]                       }
[13:37:43.854]                     }
[13:37:43.854]                     invisible(muffled)
[13:37:43.854]                   }
[13:37:43.854]                   muffleCondition(cond)
[13:37:43.854]                 })
[13:37:43.854]             }))
[13:37:43.854]             future::FutureResult(value = ...future.value$value, 
[13:37:43.854]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.854]                   ...future.rng), globalenv = if (FALSE) 
[13:37:43.854]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:43.854]                     ...future.globalenv.names))
[13:37:43.854]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:43.854]         }, condition = base::local({
[13:37:43.854]             c <- base::c
[13:37:43.854]             inherits <- base::inherits
[13:37:43.854]             invokeRestart <- base::invokeRestart
[13:37:43.854]             length <- base::length
[13:37:43.854]             list <- base::list
[13:37:43.854]             seq.int <- base::seq.int
[13:37:43.854]             signalCondition <- base::signalCondition
[13:37:43.854]             sys.calls <- base::sys.calls
[13:37:43.854]             `[[` <- base::`[[`
[13:37:43.854]             `+` <- base::`+`
[13:37:43.854]             `<<-` <- base::`<<-`
[13:37:43.854]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:43.854]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:43.854]                   3L)]
[13:37:43.854]             }
[13:37:43.854]             function(cond) {
[13:37:43.854]                 is_error <- inherits(cond, "error")
[13:37:43.854]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:43.854]                   NULL)
[13:37:43.854]                 if (is_error) {
[13:37:43.854]                   sessionInformation <- function() {
[13:37:43.854]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:43.854]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:43.854]                       search = base::search(), system = base::Sys.info())
[13:37:43.854]                   }
[13:37:43.854]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.854]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:43.854]                     cond$call), session = sessionInformation(), 
[13:37:43.854]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:43.854]                   signalCondition(cond)
[13:37:43.854]                 }
[13:37:43.854]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:43.854]                 "immediateCondition"))) {
[13:37:43.854]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:43.854]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.854]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:43.854]                   if (TRUE && !signal) {
[13:37:43.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.854]                     {
[13:37:43.854]                       inherits <- base::inherits
[13:37:43.854]                       invokeRestart <- base::invokeRestart
[13:37:43.854]                       is.null <- base::is.null
[13:37:43.854]                       muffled <- FALSE
[13:37:43.854]                       if (inherits(cond, "message")) {
[13:37:43.854]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.854]                         if (muffled) 
[13:37:43.854]                           invokeRestart("muffleMessage")
[13:37:43.854]                       }
[13:37:43.854]                       else if (inherits(cond, "warning")) {
[13:37:43.854]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.854]                         if (muffled) 
[13:37:43.854]                           invokeRestart("muffleWarning")
[13:37:43.854]                       }
[13:37:43.854]                       else if (inherits(cond, "condition")) {
[13:37:43.854]                         if (!is.null(pattern)) {
[13:37:43.854]                           computeRestarts <- base::computeRestarts
[13:37:43.854]                           grepl <- base::grepl
[13:37:43.854]                           restarts <- computeRestarts(cond)
[13:37:43.854]                           for (restart in restarts) {
[13:37:43.854]                             name <- restart$name
[13:37:43.854]                             if (is.null(name)) 
[13:37:43.854]                               next
[13:37:43.854]                             if (!grepl(pattern, name)) 
[13:37:43.854]                               next
[13:37:43.854]                             invokeRestart(restart)
[13:37:43.854]                             muffled <- TRUE
[13:37:43.854]                             break
[13:37:43.854]                           }
[13:37:43.854]                         }
[13:37:43.854]                       }
[13:37:43.854]                       invisible(muffled)
[13:37:43.854]                     }
[13:37:43.854]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.854]                   }
[13:37:43.854]                 }
[13:37:43.854]                 else {
[13:37:43.854]                   if (TRUE) {
[13:37:43.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.854]                     {
[13:37:43.854]                       inherits <- base::inherits
[13:37:43.854]                       invokeRestart <- base::invokeRestart
[13:37:43.854]                       is.null <- base::is.null
[13:37:43.854]                       muffled <- FALSE
[13:37:43.854]                       if (inherits(cond, "message")) {
[13:37:43.854]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.854]                         if (muffled) 
[13:37:43.854]                           invokeRestart("muffleMessage")
[13:37:43.854]                       }
[13:37:43.854]                       else if (inherits(cond, "warning")) {
[13:37:43.854]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.854]                         if (muffled) 
[13:37:43.854]                           invokeRestart("muffleWarning")
[13:37:43.854]                       }
[13:37:43.854]                       else if (inherits(cond, "condition")) {
[13:37:43.854]                         if (!is.null(pattern)) {
[13:37:43.854]                           computeRestarts <- base::computeRestarts
[13:37:43.854]                           grepl <- base::grepl
[13:37:43.854]                           restarts <- computeRestarts(cond)
[13:37:43.854]                           for (restart in restarts) {
[13:37:43.854]                             name <- restart$name
[13:37:43.854]                             if (is.null(name)) 
[13:37:43.854]                               next
[13:37:43.854]                             if (!grepl(pattern, name)) 
[13:37:43.854]                               next
[13:37:43.854]                             invokeRestart(restart)
[13:37:43.854]                             muffled <- TRUE
[13:37:43.854]                             break
[13:37:43.854]                           }
[13:37:43.854]                         }
[13:37:43.854]                       }
[13:37:43.854]                       invisible(muffled)
[13:37:43.854]                     }
[13:37:43.854]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.854]                   }
[13:37:43.854]                 }
[13:37:43.854]             }
[13:37:43.854]         }))
[13:37:43.854]     }, error = function(ex) {
[13:37:43.854]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:43.854]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.854]                 ...future.rng), started = ...future.startTime, 
[13:37:43.854]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:43.854]             version = "1.8"), class = "FutureResult")
[13:37:43.854]     }, finally = {
[13:37:43.854]         if (!identical(...future.workdir, getwd())) 
[13:37:43.854]             setwd(...future.workdir)
[13:37:43.854]         {
[13:37:43.854]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:43.854]                 ...future.oldOptions$nwarnings <- NULL
[13:37:43.854]             }
[13:37:43.854]             base::options(...future.oldOptions)
[13:37:43.854]             if (.Platform$OS.type == "windows") {
[13:37:43.854]                 old_names <- names(...future.oldEnvVars)
[13:37:43.854]                 envs <- base::Sys.getenv()
[13:37:43.854]                 names <- names(envs)
[13:37:43.854]                 common <- intersect(names, old_names)
[13:37:43.854]                 added <- setdiff(names, old_names)
[13:37:43.854]                 removed <- setdiff(old_names, names)
[13:37:43.854]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:43.854]                   envs[common]]
[13:37:43.854]                 NAMES <- toupper(changed)
[13:37:43.854]                 args <- list()
[13:37:43.854]                 for (kk in seq_along(NAMES)) {
[13:37:43.854]                   name <- changed[[kk]]
[13:37:43.854]                   NAME <- NAMES[[kk]]
[13:37:43.854]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.854]                     next
[13:37:43.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.854]                 }
[13:37:43.854]                 NAMES <- toupper(added)
[13:37:43.854]                 for (kk in seq_along(NAMES)) {
[13:37:43.854]                   name <- added[[kk]]
[13:37:43.854]                   NAME <- NAMES[[kk]]
[13:37:43.854]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.854]                     next
[13:37:43.854]                   args[[name]] <- ""
[13:37:43.854]                 }
[13:37:43.854]                 NAMES <- toupper(removed)
[13:37:43.854]                 for (kk in seq_along(NAMES)) {
[13:37:43.854]                   name <- removed[[kk]]
[13:37:43.854]                   NAME <- NAMES[[kk]]
[13:37:43.854]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.854]                     next
[13:37:43.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.854]                 }
[13:37:43.854]                 if (length(args) > 0) 
[13:37:43.854]                   base::do.call(base::Sys.setenv, args = args)
[13:37:43.854]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:43.854]             }
[13:37:43.854]             else {
[13:37:43.854]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:43.854]             }
[13:37:43.854]             {
[13:37:43.854]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:43.854]                   0L) {
[13:37:43.854]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:43.854]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:43.854]                   base::options(opts)
[13:37:43.854]                 }
[13:37:43.854]                 {
[13:37:43.854]                   {
[13:37:43.854]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:43.854]                     NULL
[13:37:43.854]                   }
[13:37:43.854]                   options(future.plan = NULL)
[13:37:43.854]                   if (is.na(NA_character_)) 
[13:37:43.854]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.854]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:43.854]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:43.854]                     .init = FALSE)
[13:37:43.854]                 }
[13:37:43.854]             }
[13:37:43.854]         }
[13:37:43.854]     })
[13:37:43.854]     if (TRUE) {
[13:37:43.854]         base::sink(type = "output", split = FALSE)
[13:37:43.854]         if (TRUE) {
[13:37:43.854]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:43.854]         }
[13:37:43.854]         else {
[13:37:43.854]             ...future.result["stdout"] <- base::list(NULL)
[13:37:43.854]         }
[13:37:43.854]         base::close(...future.stdout)
[13:37:43.854]         ...future.stdout <- NULL
[13:37:43.854]     }
[13:37:43.854]     ...future.result$conditions <- ...future.conditions
[13:37:43.854]     ...future.result$finished <- base::Sys.time()
[13:37:43.854]     ...future.result
[13:37:43.854] }
[13:37:43.857] requestCore(): workers = 2
[13:37:43.857] Poll #1 (0): usedCores() = 2, workers = 2
[13:37:43.868] result() for MulticoreFuture ...
[13:37:43.870] result() for MulticoreFuture ...
[13:37:43.870] result() for MulticoreFuture ... done
[13:37:43.870] result() for MulticoreFuture ... done
[13:37:43.870] result() for MulticoreFuture ...
[13:37:43.871] result() for MulticoreFuture ... done
[13:37:43.873] MulticoreFuture started
[13:37:43.874] - Launch lazy future ... done
[13:37:43.874] run() for ‘MulticoreFuture’ ... done
[13:37:43.875] resolve() on list ...
[13:37:43.875]  recursive: 0
[13:37:43.875] plan(): Setting new future strategy stack:
[13:37:43.875]  length: 3
[13:37:43.875]  elements: ‘a’, ‘b’, ‘’
[13:37:43.875] run() for ‘Future’ ...
[13:37:43.876] - state: ‘created’
[13:37:43.875] List of future strategies:
[13:37:43.875] 1. sequential:
[13:37:43.875]    - args: function (..., envir = parent.frame())
[13:37:43.875]    - tweaked: FALSE
[13:37:43.875]    - call: NULL
[13:37:43.876] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:37:43.876] plan(): nbrOfWorkers() = 1
[13:37:43.878] plan(): Setting new future strategy stack:
[13:37:43.879] List of future strategies:
[13:37:43.879] 1. multicore:
[13:37:43.879]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:37:43.879]    - tweaked: FALSE
[13:37:43.879]    - call: plan(strategy)
[13:37:43.881] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:43.882] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:37:43.882]   - Field: ‘label’
[13:37:43.882]   - Field: ‘local’
[13:37:43.882]   - Field: ‘owner’
[13:37:43.883]   - Field: ‘envir’
[13:37:43.883]   - Field: ‘workers’
[13:37:43.883]   - Field: ‘packages’
[13:37:43.883]   - Field: ‘gc’
[13:37:43.883]   - Field: ‘job’
[13:37:43.883]   - Field: ‘conditions’
[13:37:43.884]   - Field: ‘expr’
[13:37:43.884] plan(): nbrOfWorkers() = 2
[13:37:43.884]   - Field: ‘uuid’
[13:37:43.884]   - Field: ‘seed’
[13:37:43.884]   - Field: ‘version’
[13:37:43.884]   - Field: ‘result’
[13:37:43.884]   - Field: ‘asynchronous’
[13:37:43.885]   - Field: ‘calls’
[13:37:43.885]   - Field: ‘globals’
[13:37:43.885]   - Field: ‘stdout’
[13:37:43.885]   - Field: ‘earlySignal’
[13:37:43.885]   - Field: ‘lazy’
[13:37:43.885]   - Field: ‘state’
[13:37:43.886] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:37:43.886] - Launch lazy future ...
[13:37:43.886] Packages needed by the future expression (n = 0): <none>
[13:37:43.887] Packages needed by future strategies (n = 0): <none>
[13:37:43.887] {
[13:37:43.887]     {
[13:37:43.887]         {
[13:37:43.887]             ...future.startTime <- base::Sys.time()
[13:37:43.887]             {
[13:37:43.887]                 {
[13:37:43.887]                   {
[13:37:43.887]                     {
[13:37:43.887]                       base::local({
[13:37:43.887]                         has_future <- base::requireNamespace("future", 
[13:37:43.887]                           quietly = TRUE)
[13:37:43.887]                         if (has_future) {
[13:37:43.887]                           ns <- base::getNamespace("future")
[13:37:43.887]                           version <- ns[[".package"]][["version"]]
[13:37:43.887]                           if (is.null(version)) 
[13:37:43.887]                             version <- utils::packageVersion("future")
[13:37:43.887]                         }
[13:37:43.887]                         else {
[13:37:43.887]                           version <- NULL
[13:37:43.887]                         }
[13:37:43.887]                         if (!has_future || version < "1.8.0") {
[13:37:43.887]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:43.887]                             "", base::R.version$version.string), 
[13:37:43.887]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:43.887]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:43.887]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:43.887]                               "release", "version")], collapse = " "), 
[13:37:43.887]                             hostname = base::Sys.info()[["nodename"]])
[13:37:43.887]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:43.887]                             info)
[13:37:43.887]                           info <- base::paste(info, collapse = "; ")
[13:37:43.887]                           if (!has_future) {
[13:37:43.887]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:43.887]                               info)
[13:37:43.887]                           }
[13:37:43.887]                           else {
[13:37:43.887]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:43.887]                               info, version)
[13:37:43.887]                           }
[13:37:43.887]                           base::stop(msg)
[13:37:43.887]                         }
[13:37:43.887]                       })
[13:37:43.887]                     }
[13:37:43.887]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:43.887]                     base::options(mc.cores = 1L)
[13:37:43.887]                   }
[13:37:43.887]                   ...future.strategy.old <- future::plan("list")
[13:37:43.887]                   options(future.plan = NULL)
[13:37:43.887]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.887]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:43.887]                 }
[13:37:43.887]                 ...future.workdir <- getwd()
[13:37:43.887]             }
[13:37:43.887]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:43.887]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:43.887]         }
[13:37:43.887]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:43.887]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:43.887]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:43.887]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:43.887]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:43.887]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:43.887]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:43.887]             base::names(...future.oldOptions))
[13:37:43.887]     }
[13:37:43.887]     if (FALSE) {
[13:37:43.887]     }
[13:37:43.887]     else {
[13:37:43.887]         if (TRUE) {
[13:37:43.887]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:43.887]                 open = "w")
[13:37:43.887]         }
[13:37:43.887]         else {
[13:37:43.887]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:43.887]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:43.887]         }
[13:37:43.887]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:43.887]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:43.887]             base::sink(type = "output", split = FALSE)
[13:37:43.887]             base::close(...future.stdout)
[13:37:43.887]         }, add = TRUE)
[13:37:43.887]     }
[13:37:43.887]     ...future.frame <- base::sys.nframe()
[13:37:43.887]     ...future.conditions <- base::list()
[13:37:43.887]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:43.887]     if (FALSE) {
[13:37:43.887]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:43.887]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:43.887]     }
[13:37:43.887]     ...future.result <- base::tryCatch({
[13:37:43.887]         base::withCallingHandlers({
[13:37:43.887]             ...future.value <- base::withVisible(base::local({
[13:37:43.887]                 withCallingHandlers({
[13:37:43.887]                   1
[13:37:43.887]                 }, immediateCondition = function(cond) {
[13:37:43.887]                   save_rds <- function (object, pathname, ...) 
[13:37:43.887]                   {
[13:37:43.887]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:37:43.887]                     if (file_test("-f", pathname_tmp)) {
[13:37:43.887]                       fi_tmp <- file.info(pathname_tmp)
[13:37:43.887]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:37:43.887]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:43.887]                         fi_tmp[["mtime"]])
[13:37:43.887]                     }
[13:37:43.887]                     tryCatch({
[13:37:43.887]                       saveRDS(object, file = pathname_tmp, ...)
[13:37:43.887]                     }, error = function(ex) {
[13:37:43.887]                       msg <- conditionMessage(ex)
[13:37:43.887]                       fi_tmp <- file.info(pathname_tmp)
[13:37:43.887]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:37:43.887]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:43.887]                         fi_tmp[["mtime"]], msg)
[13:37:43.887]                       ex$message <- msg
[13:37:43.887]                       stop(ex)
[13:37:43.887]                     })
[13:37:43.887]                     stopifnot(file_test("-f", pathname_tmp))
[13:37:43.887]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:37:43.887]                     if (!res || file_test("-f", pathname_tmp)) {
[13:37:43.887]                       fi_tmp <- file.info(pathname_tmp)
[13:37:43.887]                       fi <- file.info(pathname)
[13:37:43.887]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:37:43.887]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:43.887]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:37:43.887]                         fi[["size"]], fi[["mtime"]])
[13:37:43.887]                       stop(msg)
[13:37:43.887]                     }
[13:37:43.887]                     invisible(pathname)
[13:37:43.887]                   }
[13:37:43.887]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:37:43.887]                     rootPath = tempdir()) 
[13:37:43.887]                   {
[13:37:43.887]                     obj <- list(time = Sys.time(), condition = cond)
[13:37:43.887]                     file <- tempfile(pattern = class(cond)[1], 
[13:37:43.887]                       tmpdir = path, fileext = ".rds")
[13:37:43.887]                     save_rds(obj, file)
[13:37:43.887]                   }
[13:37:43.887]                   saveImmediateCondition(cond, path = "/tmp/RtmpLAMaHJ/.future/immediateConditions")
[13:37:43.887]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.887]                   {
[13:37:43.887]                     inherits <- base::inherits
[13:37:43.887]                     invokeRestart <- base::invokeRestart
[13:37:43.887]                     is.null <- base::is.null
[13:37:43.887]                     muffled <- FALSE
[13:37:43.887]                     if (inherits(cond, "message")) {
[13:37:43.887]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:43.887]                       if (muffled) 
[13:37:43.887]                         invokeRestart("muffleMessage")
[13:37:43.887]                     }
[13:37:43.887]                     else if (inherits(cond, "warning")) {
[13:37:43.887]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:43.887]                       if (muffled) 
[13:37:43.887]                         invokeRestart("muffleWarning")
[13:37:43.887]                     }
[13:37:43.887]                     else if (inherits(cond, "condition")) {
[13:37:43.887]                       if (!is.null(pattern)) {
[13:37:43.887]                         computeRestarts <- base::computeRestarts
[13:37:43.887]                         grepl <- base::grepl
[13:37:43.887]                         restarts <- computeRestarts(cond)
[13:37:43.887]                         for (restart in restarts) {
[13:37:43.887]                           name <- restart$name
[13:37:43.887]                           if (is.null(name)) 
[13:37:43.887]                             next
[13:37:43.887]                           if (!grepl(pattern, name)) 
[13:37:43.887]                             next
[13:37:43.887]                           invokeRestart(restart)
[13:37:43.887]                           muffled <- TRUE
[13:37:43.887]                           break
[13:37:43.887]                         }
[13:37:43.887]                       }
[13:37:43.887]                     }
[13:37:43.887]                     invisible(muffled)
[13:37:43.887]                   }
[13:37:43.887]                   muffleCondition(cond)
[13:37:43.887]                 })
[13:37:43.887]             }))
[13:37:43.887]             future::FutureResult(value = ...future.value$value, 
[13:37:43.887]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.887]                   ...future.rng), globalenv = if (FALSE) 
[13:37:43.887]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:43.887]                     ...future.globalenv.names))
[13:37:43.887]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:43.887]         }, condition = base::local({
[13:37:43.887]             c <- base::c
[13:37:43.887]             inherits <- base::inherits
[13:37:43.887]             invokeRestart <- base::invokeRestart
[13:37:43.887]             length <- base::length
[13:37:43.887]             list <- base::list
[13:37:43.887]             seq.int <- base::seq.int
[13:37:43.887]             signalCondition <- base::signalCondition
[13:37:43.887]             sys.calls <- base::sys.calls
[13:37:43.887]             `[[` <- base::`[[`
[13:37:43.887]             `+` <- base::`+`
[13:37:43.887]             `<<-` <- base::`<<-`
[13:37:43.887]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:43.887]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:43.887]                   3L)]
[13:37:43.887]             }
[13:37:43.887]             function(cond) {
[13:37:43.887]                 is_error <- inherits(cond, "error")
[13:37:43.887]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:43.887]                   NULL)
[13:37:43.887]                 if (is_error) {
[13:37:43.887]                   sessionInformation <- function() {
[13:37:43.887]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:43.887]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:43.887]                       search = base::search(), system = base::Sys.info())
[13:37:43.887]                   }
[13:37:43.887]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.887]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:43.887]                     cond$call), session = sessionInformation(), 
[13:37:43.887]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:43.887]                   signalCondition(cond)
[13:37:43.887]                 }
[13:37:43.887]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:43.887]                 "immediateCondition"))) {
[13:37:43.887]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:43.887]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.887]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:43.887]                   if (TRUE && !signal) {
[13:37:43.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.887]                     {
[13:37:43.887]                       inherits <- base::inherits
[13:37:43.887]                       invokeRestart <- base::invokeRestart
[13:37:43.887]                       is.null <- base::is.null
[13:37:43.887]                       muffled <- FALSE
[13:37:43.887]                       if (inherits(cond, "message")) {
[13:37:43.887]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.887]                         if (muffled) 
[13:37:43.887]                           invokeRestart("muffleMessage")
[13:37:43.887]                       }
[13:37:43.887]                       else if (inherits(cond, "warning")) {
[13:37:43.887]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.887]                         if (muffled) 
[13:37:43.887]                           invokeRestart("muffleWarning")
[13:37:43.887]                       }
[13:37:43.887]                       else if (inherits(cond, "condition")) {
[13:37:43.887]                         if (!is.null(pattern)) {
[13:37:43.887]                           computeRestarts <- base::computeRestarts
[13:37:43.887]                           grepl <- base::grepl
[13:37:43.887]                           restarts <- computeRestarts(cond)
[13:37:43.887]                           for (restart in restarts) {
[13:37:43.887]                             name <- restart$name
[13:37:43.887]                             if (is.null(name)) 
[13:37:43.887]                               next
[13:37:43.887]                             if (!grepl(pattern, name)) 
[13:37:43.887]                               next
[13:37:43.887]                             invokeRestart(restart)
[13:37:43.887]                             muffled <- TRUE
[13:37:43.887]                             break
[13:37:43.887]                           }
[13:37:43.887]                         }
[13:37:43.887]                       }
[13:37:43.887]                       invisible(muffled)
[13:37:43.887]                     }
[13:37:43.887]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.887]                   }
[13:37:43.887]                 }
[13:37:43.887]                 else {
[13:37:43.887]                   if (TRUE) {
[13:37:43.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.887]                     {
[13:37:43.887]                       inherits <- base::inherits
[13:37:43.887]                       invokeRestart <- base::invokeRestart
[13:37:43.887]                       is.null <- base::is.null
[13:37:43.887]                       muffled <- FALSE
[13:37:43.887]                       if (inherits(cond, "message")) {
[13:37:43.887]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.887]                         if (muffled) 
[13:37:43.887]                           invokeRestart("muffleMessage")
[13:37:43.887]                       }
[13:37:43.887]                       else if (inherits(cond, "warning")) {
[13:37:43.887]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.887]                         if (muffled) 
[13:37:43.887]                           invokeRestart("muffleWarning")
[13:37:43.887]                       }
[13:37:43.887]                       else if (inherits(cond, "condition")) {
[13:37:43.887]                         if (!is.null(pattern)) {
[13:37:43.887]                           computeRestarts <- base::computeRestarts
[13:37:43.887]                           grepl <- base::grepl
[13:37:43.887]                           restarts <- computeRestarts(cond)
[13:37:43.887]                           for (restart in restarts) {
[13:37:43.887]                             name <- restart$name
[13:37:43.887]                             if (is.null(name)) 
[13:37:43.887]                               next
[13:37:43.887]                             if (!grepl(pattern, name)) 
[13:37:43.887]                               next
[13:37:43.887]                             invokeRestart(restart)
[13:37:43.887]                             muffled <- TRUE
[13:37:43.887]                             break
[13:37:43.887]                           }
[13:37:43.887]                         }
[13:37:43.887]                       }
[13:37:43.887]                       invisible(muffled)
[13:37:43.887]                     }
[13:37:43.887]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.887]                   }
[13:37:43.887]                 }
[13:37:43.887]             }
[13:37:43.887]         }))
[13:37:43.887]     }, error = function(ex) {
[13:37:43.887]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:43.887]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.887]                 ...future.rng), started = ...future.startTime, 
[13:37:43.887]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:43.887]             version = "1.8"), class = "FutureResult")
[13:37:43.887]     }, finally = {
[13:37:43.887]         if (!identical(...future.workdir, getwd())) 
[13:37:43.887]             setwd(...future.workdir)
[13:37:43.887]         {
[13:37:43.887]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:43.887]                 ...future.oldOptions$nwarnings <- NULL
[13:37:43.887]             }
[13:37:43.887]             base::options(...future.oldOptions)
[13:37:43.887]             if (.Platform$OS.type == "windows") {
[13:37:43.887]                 old_names <- names(...future.oldEnvVars)
[13:37:43.887]                 envs <- base::Sys.getenv()
[13:37:43.887]                 names <- names(envs)
[13:37:43.887]                 common <- intersect(names, old_names)
[13:37:43.887]                 added <- setdiff(names, old_names)
[13:37:43.887]                 removed <- setdiff(old_names, names)
[13:37:43.887]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:43.887]                   envs[common]]
[13:37:43.887]                 NAMES <- toupper(changed)
[13:37:43.887]                 args <- list()
[13:37:43.887]                 for (kk in seq_along(NAMES)) {
[13:37:43.887]                   name <- changed[[kk]]
[13:37:43.887]                   NAME <- NAMES[[kk]]
[13:37:43.887]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.887]                     next
[13:37:43.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.887]                 }
[13:37:43.887]                 NAMES <- toupper(added)
[13:37:43.887]                 for (kk in seq_along(NAMES)) {
[13:37:43.887]                   name <- added[[kk]]
[13:37:43.887]                   NAME <- NAMES[[kk]]
[13:37:43.887]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.887]                     next
[13:37:43.887]                   args[[name]] <- ""
[13:37:43.887]                 }
[13:37:43.887]                 NAMES <- toupper(removed)
[13:37:43.887]                 for (kk in seq_along(NAMES)) {
[13:37:43.887]                   name <- removed[[kk]]
[13:37:43.887]                   NAME <- NAMES[[kk]]
[13:37:43.887]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.887]                     next
[13:37:43.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.887]                 }
[13:37:43.887]                 if (length(args) > 0) 
[13:37:43.887]                   base::do.call(base::Sys.setenv, args = args)
[13:37:43.887]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:43.887]             }
[13:37:43.887]             else {
[13:37:43.887]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:43.887]             }
[13:37:43.887]             {
[13:37:43.887]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:43.887]                   0L) {
[13:37:43.887]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:43.887]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:43.887]                   base::options(opts)
[13:37:43.887]                 }
[13:37:43.887]                 {
[13:37:43.887]                   {
[13:37:43.887]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:43.887]                     NULL
[13:37:43.887]                   }
[13:37:43.887]                   options(future.plan = NULL)
[13:37:43.887]                   if (is.na(NA_character_)) 
[13:37:43.887]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.887]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:43.887]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:43.887]                     .init = FALSE)
[13:37:43.887]                 }
[13:37:43.887]             }
[13:37:43.887]         }
[13:37:43.887]     })
[13:37:43.887]     if (TRUE) {
[13:37:43.887]         base::sink(type = "output", split = FALSE)
[13:37:43.887]         if (TRUE) {
[13:37:43.887]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:43.887]         }
[13:37:43.887]         else {
[13:37:43.887]             ...future.result["stdout"] <- base::list(NULL)
[13:37:43.887]         }
[13:37:43.887]         base::close(...future.stdout)
[13:37:43.887]         ...future.stdout <- NULL
[13:37:43.887]     }
[13:37:43.887]     ...future.result$conditions <- ...future.conditions
[13:37:43.887]     ...future.result$finished <- base::Sys.time()
[13:37:43.887]     ...future.result
[13:37:43.887] }
[13:37:43.891] requestCore(): workers = 2
[13:37:43.891] Poll #1 (0): usedCores() = 2, workers = 2
[13:37:43.916] result() for MulticoreFuture ...
[13:37:43.917] result() for MulticoreFuture ...
[13:37:43.917] result() for MulticoreFuture ... done
[13:37:43.917] result() for MulticoreFuture ... done
[13:37:43.921] result() for MulticoreFuture ...
[13:37:43.921] result() for MulticoreFuture ... done
[13:37:43.924] MulticoreFuture started
[13:37:43.925] - Launch lazy future ... done
[13:37:43.925] run() for ‘MulticoreFuture’ ... done
[13:37:43.926] plan(): Setting new future strategy stack:
[13:37:43.926] List of future strategies:
[13:37:43.926] 1. sequential:
[13:37:43.926]    - args: function (..., envir = parent.frame())
[13:37:43.926]    - tweaked: FALSE
[13:37:43.926]    - call: NULL
[13:37:43.928] plan(): nbrOfWorkers() = 1
[13:37:43.931] plan(): Setting new future strategy stack:
[13:37:43.932] List of future strategies:
[13:37:43.932] 1. multicore:
[13:37:43.932]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:37:43.932]    - tweaked: FALSE
[13:37:43.932]    - call: plan(strategy)
[13:37:43.937] Future #2
[13:37:43.937]  length: 2 (resolved future 2)
[13:37:43.938] plan(): nbrOfWorkers() = 2
[13:37:43.938]  length: 1 (resolved future 3)
[13:37:43.949] Future #1
[13:37:43.949]  length: 0 (resolved future 1)
[13:37:43.949] resolve() on list ... DONE
[13:37:43.950] getGlobalsAndPackages() ...
[13:37:43.950] Searching for globals...
[13:37:43.951] 
[13:37:43.951] Searching for globals ... DONE
[13:37:43.952] - globals: [0] <none>
[13:37:43.952] getGlobalsAndPackages() ... DONE
[13:37:43.952] getGlobalsAndPackages() ...
[13:37:43.952] Searching for globals...
[13:37:43.953] 
[13:37:43.953] Searching for globals ... DONE
[13:37:43.953] - globals: [0] <none>
[13:37:43.954] getGlobalsAndPackages() ... DONE
[13:37:43.954] resolve() on list ...
[13:37:43.954]  recursive: 0
[13:37:43.954]  length: 3
[13:37:43.954]  elements: ‘a’, ‘b’, ‘’
[13:37:43.955] run() for ‘Future’ ...
[13:37:43.955] - state: ‘created’
[13:37:43.955] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:37:43.961] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:43.961] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:37:43.961]   - Field: ‘label’
[13:37:43.961]   - Field: ‘local’
[13:37:43.962]   - Field: ‘owner’
[13:37:43.962]   - Field: ‘envir’
[13:37:43.962]   - Field: ‘workers’
[13:37:43.962]   - Field: ‘packages’
[13:37:43.962]   - Field: ‘gc’
[13:37:43.962]   - Field: ‘job’
[13:37:43.963]   - Field: ‘conditions’
[13:37:43.963]   - Field: ‘expr’
[13:37:43.963]   - Field: ‘uuid’
[13:37:43.963]   - Field: ‘seed’
[13:37:43.963]   - Field: ‘version’
[13:37:43.963]   - Field: ‘result’
[13:37:43.964]   - Field: ‘asynchronous’
[13:37:43.964]   - Field: ‘calls’
[13:37:43.964]   - Field: ‘globals’
[13:37:43.964]   - Field: ‘stdout’
[13:37:43.964]   - Field: ‘earlySignal’
[13:37:43.964]   - Field: ‘lazy’
[13:37:43.964]   - Field: ‘state’
[13:37:43.965] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:37:43.965] - Launch lazy future ...
[13:37:43.965] Packages needed by the future expression (n = 0): <none>
[13:37:43.965] Packages needed by future strategies (n = 0): <none>
[13:37:43.966] {
[13:37:43.966]     {
[13:37:43.966]         {
[13:37:43.966]             ...future.startTime <- base::Sys.time()
[13:37:43.966]             {
[13:37:43.966]                 {
[13:37:43.966]                   {
[13:37:43.966]                     {
[13:37:43.966]                       base::local({
[13:37:43.966]                         has_future <- base::requireNamespace("future", 
[13:37:43.966]                           quietly = TRUE)
[13:37:43.966]                         if (has_future) {
[13:37:43.966]                           ns <- base::getNamespace("future")
[13:37:43.966]                           version <- ns[[".package"]][["version"]]
[13:37:43.966]                           if (is.null(version)) 
[13:37:43.966]                             version <- utils::packageVersion("future")
[13:37:43.966]                         }
[13:37:43.966]                         else {
[13:37:43.966]                           version <- NULL
[13:37:43.966]                         }
[13:37:43.966]                         if (!has_future || version < "1.8.0") {
[13:37:43.966]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:43.966]                             "", base::R.version$version.string), 
[13:37:43.966]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:43.966]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:43.966]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:43.966]                               "release", "version")], collapse = " "), 
[13:37:43.966]                             hostname = base::Sys.info()[["nodename"]])
[13:37:43.966]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:43.966]                             info)
[13:37:43.966]                           info <- base::paste(info, collapse = "; ")
[13:37:43.966]                           if (!has_future) {
[13:37:43.966]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:43.966]                               info)
[13:37:43.966]                           }
[13:37:43.966]                           else {
[13:37:43.966]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:43.966]                               info, version)
[13:37:43.966]                           }
[13:37:43.966]                           base::stop(msg)
[13:37:43.966]                         }
[13:37:43.966]                       })
[13:37:43.966]                     }
[13:37:43.966]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:43.966]                     base::options(mc.cores = 1L)
[13:37:43.966]                   }
[13:37:43.966]                   ...future.strategy.old <- future::plan("list")
[13:37:43.966]                   options(future.plan = NULL)
[13:37:43.966]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.966]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:43.966]                 }
[13:37:43.966]                 ...future.workdir <- getwd()
[13:37:43.966]             }
[13:37:43.966]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:43.966]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:43.966]         }
[13:37:43.966]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:43.966]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:43.966]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:43.966]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:43.966]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:43.966]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:43.966]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:43.966]             base::names(...future.oldOptions))
[13:37:43.966]     }
[13:37:43.966]     if (FALSE) {
[13:37:43.966]     }
[13:37:43.966]     else {
[13:37:43.966]         if (TRUE) {
[13:37:43.966]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:43.966]                 open = "w")
[13:37:43.966]         }
[13:37:43.966]         else {
[13:37:43.966]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:43.966]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:43.966]         }
[13:37:43.966]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:43.966]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:43.966]             base::sink(type = "output", split = FALSE)
[13:37:43.966]             base::close(...future.stdout)
[13:37:43.966]         }, add = TRUE)
[13:37:43.966]     }
[13:37:43.966]     ...future.frame <- base::sys.nframe()
[13:37:43.966]     ...future.conditions <- base::list()
[13:37:43.966]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:43.966]     if (FALSE) {
[13:37:43.966]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:43.966]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:43.966]     }
[13:37:43.966]     ...future.result <- base::tryCatch({
[13:37:43.966]         base::withCallingHandlers({
[13:37:43.966]             ...future.value <- base::withVisible(base::local({
[13:37:43.966]                 withCallingHandlers({
[13:37:43.966]                   1
[13:37:43.966]                 }, immediateCondition = function(cond) {
[13:37:43.966]                   save_rds <- function (object, pathname, ...) 
[13:37:43.966]                   {
[13:37:43.966]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:37:43.966]                     if (file_test("-f", pathname_tmp)) {
[13:37:43.966]                       fi_tmp <- file.info(pathname_tmp)
[13:37:43.966]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:37:43.966]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:43.966]                         fi_tmp[["mtime"]])
[13:37:43.966]                     }
[13:37:43.966]                     tryCatch({
[13:37:43.966]                       saveRDS(object, file = pathname_tmp, ...)
[13:37:43.966]                     }, error = function(ex) {
[13:37:43.966]                       msg <- conditionMessage(ex)
[13:37:43.966]                       fi_tmp <- file.info(pathname_tmp)
[13:37:43.966]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:37:43.966]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:43.966]                         fi_tmp[["mtime"]], msg)
[13:37:43.966]                       ex$message <- msg
[13:37:43.966]                       stop(ex)
[13:37:43.966]                     })
[13:37:43.966]                     stopifnot(file_test("-f", pathname_tmp))
[13:37:43.966]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:37:43.966]                     if (!res || file_test("-f", pathname_tmp)) {
[13:37:43.966]                       fi_tmp <- file.info(pathname_tmp)
[13:37:43.966]                       fi <- file.info(pathname)
[13:37:43.966]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:37:43.966]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:43.966]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:37:43.966]                         fi[["size"]], fi[["mtime"]])
[13:37:43.966]                       stop(msg)
[13:37:43.966]                     }
[13:37:43.966]                     invisible(pathname)
[13:37:43.966]                   }
[13:37:43.966]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:37:43.966]                     rootPath = tempdir()) 
[13:37:43.966]                   {
[13:37:43.966]                     obj <- list(time = Sys.time(), condition = cond)
[13:37:43.966]                     file <- tempfile(pattern = class(cond)[1], 
[13:37:43.966]                       tmpdir = path, fileext = ".rds")
[13:37:43.966]                     save_rds(obj, file)
[13:37:43.966]                   }
[13:37:43.966]                   saveImmediateCondition(cond, path = "/tmp/RtmpLAMaHJ/.future/immediateConditions")
[13:37:43.966]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.966]                   {
[13:37:43.966]                     inherits <- base::inherits
[13:37:43.966]                     invokeRestart <- base::invokeRestart
[13:37:43.966]                     is.null <- base::is.null
[13:37:43.966]                     muffled <- FALSE
[13:37:43.966]                     if (inherits(cond, "message")) {
[13:37:43.966]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:43.966]                       if (muffled) 
[13:37:43.966]                         invokeRestart("muffleMessage")
[13:37:43.966]                     }
[13:37:43.966]                     else if (inherits(cond, "warning")) {
[13:37:43.966]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:43.966]                       if (muffled) 
[13:37:43.966]                         invokeRestart("muffleWarning")
[13:37:43.966]                     }
[13:37:43.966]                     else if (inherits(cond, "condition")) {
[13:37:43.966]                       if (!is.null(pattern)) {
[13:37:43.966]                         computeRestarts <- base::computeRestarts
[13:37:43.966]                         grepl <- base::grepl
[13:37:43.966]                         restarts <- computeRestarts(cond)
[13:37:43.966]                         for (restart in restarts) {
[13:37:43.966]                           name <- restart$name
[13:37:43.966]                           if (is.null(name)) 
[13:37:43.966]                             next
[13:37:43.966]                           if (!grepl(pattern, name)) 
[13:37:43.966]                             next
[13:37:43.966]                           invokeRestart(restart)
[13:37:43.966]                           muffled <- TRUE
[13:37:43.966]                           break
[13:37:43.966]                         }
[13:37:43.966]                       }
[13:37:43.966]                     }
[13:37:43.966]                     invisible(muffled)
[13:37:43.966]                   }
[13:37:43.966]                   muffleCondition(cond)
[13:37:43.966]                 })
[13:37:43.966]             }))
[13:37:43.966]             future::FutureResult(value = ...future.value$value, 
[13:37:43.966]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.966]                   ...future.rng), globalenv = if (FALSE) 
[13:37:43.966]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:43.966]                     ...future.globalenv.names))
[13:37:43.966]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:43.966]         }, condition = base::local({
[13:37:43.966]             c <- base::c
[13:37:43.966]             inherits <- base::inherits
[13:37:43.966]             invokeRestart <- base::invokeRestart
[13:37:43.966]             length <- base::length
[13:37:43.966]             list <- base::list
[13:37:43.966]             seq.int <- base::seq.int
[13:37:43.966]             signalCondition <- base::signalCondition
[13:37:43.966]             sys.calls <- base::sys.calls
[13:37:43.966]             `[[` <- base::`[[`
[13:37:43.966]             `+` <- base::`+`
[13:37:43.966]             `<<-` <- base::`<<-`
[13:37:43.966]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:43.966]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:43.966]                   3L)]
[13:37:43.966]             }
[13:37:43.966]             function(cond) {
[13:37:43.966]                 is_error <- inherits(cond, "error")
[13:37:43.966]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:43.966]                   NULL)
[13:37:43.966]                 if (is_error) {
[13:37:43.966]                   sessionInformation <- function() {
[13:37:43.966]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:43.966]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:43.966]                       search = base::search(), system = base::Sys.info())
[13:37:43.966]                   }
[13:37:43.966]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.966]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:43.966]                     cond$call), session = sessionInformation(), 
[13:37:43.966]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:43.966]                   signalCondition(cond)
[13:37:43.966]                 }
[13:37:43.966]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:43.966]                 "immediateCondition"))) {
[13:37:43.966]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:43.966]                   ...future.conditions[[length(...future.conditions) + 
[13:37:43.966]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:43.966]                   if (TRUE && !signal) {
[13:37:43.966]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.966]                     {
[13:37:43.966]                       inherits <- base::inherits
[13:37:43.966]                       invokeRestart <- base::invokeRestart
[13:37:43.966]                       is.null <- base::is.null
[13:37:43.966]                       muffled <- FALSE
[13:37:43.966]                       if (inherits(cond, "message")) {
[13:37:43.966]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.966]                         if (muffled) 
[13:37:43.966]                           invokeRestart("muffleMessage")
[13:37:43.966]                       }
[13:37:43.966]                       else if (inherits(cond, "warning")) {
[13:37:43.966]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.966]                         if (muffled) 
[13:37:43.966]                           invokeRestart("muffleWarning")
[13:37:43.966]                       }
[13:37:43.966]                       else if (inherits(cond, "condition")) {
[13:37:43.966]                         if (!is.null(pattern)) {
[13:37:43.966]                           computeRestarts <- base::computeRestarts
[13:37:43.966]                           grepl <- base::grepl
[13:37:43.966]                           restarts <- computeRestarts(cond)
[13:37:43.966]                           for (restart in restarts) {
[13:37:43.966]                             name <- restart$name
[13:37:43.966]                             if (is.null(name)) 
[13:37:43.966]                               next
[13:37:43.966]                             if (!grepl(pattern, name)) 
[13:37:43.966]                               next
[13:37:43.966]                             invokeRestart(restart)
[13:37:43.966]                             muffled <- TRUE
[13:37:43.966]                             break
[13:37:43.966]                           }
[13:37:43.966]                         }
[13:37:43.966]                       }
[13:37:43.966]                       invisible(muffled)
[13:37:43.966]                     }
[13:37:43.966]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.966]                   }
[13:37:43.966]                 }
[13:37:43.966]                 else {
[13:37:43.966]                   if (TRUE) {
[13:37:43.966]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:43.966]                     {
[13:37:43.966]                       inherits <- base::inherits
[13:37:43.966]                       invokeRestart <- base::invokeRestart
[13:37:43.966]                       is.null <- base::is.null
[13:37:43.966]                       muffled <- FALSE
[13:37:43.966]                       if (inherits(cond, "message")) {
[13:37:43.966]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:43.966]                         if (muffled) 
[13:37:43.966]                           invokeRestart("muffleMessage")
[13:37:43.966]                       }
[13:37:43.966]                       else if (inherits(cond, "warning")) {
[13:37:43.966]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:43.966]                         if (muffled) 
[13:37:43.966]                           invokeRestart("muffleWarning")
[13:37:43.966]                       }
[13:37:43.966]                       else if (inherits(cond, "condition")) {
[13:37:43.966]                         if (!is.null(pattern)) {
[13:37:43.966]                           computeRestarts <- base::computeRestarts
[13:37:43.966]                           grepl <- base::grepl
[13:37:43.966]                           restarts <- computeRestarts(cond)
[13:37:43.966]                           for (restart in restarts) {
[13:37:43.966]                             name <- restart$name
[13:37:43.966]                             if (is.null(name)) 
[13:37:43.966]                               next
[13:37:43.966]                             if (!grepl(pattern, name)) 
[13:37:43.966]                               next
[13:37:43.966]                             invokeRestart(restart)
[13:37:43.966]                             muffled <- TRUE
[13:37:43.966]                             break
[13:37:43.966]                           }
[13:37:43.966]                         }
[13:37:43.966]                       }
[13:37:43.966]                       invisible(muffled)
[13:37:43.966]                     }
[13:37:43.966]                     muffleCondition(cond, pattern = "^muffle")
[13:37:43.966]                   }
[13:37:43.966]                 }
[13:37:43.966]             }
[13:37:43.966]         }))
[13:37:43.966]     }, error = function(ex) {
[13:37:43.966]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:43.966]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:43.966]                 ...future.rng), started = ...future.startTime, 
[13:37:43.966]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:43.966]             version = "1.8"), class = "FutureResult")
[13:37:43.966]     }, finally = {
[13:37:43.966]         if (!identical(...future.workdir, getwd())) 
[13:37:43.966]             setwd(...future.workdir)
[13:37:43.966]         {
[13:37:43.966]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:43.966]                 ...future.oldOptions$nwarnings <- NULL
[13:37:43.966]             }
[13:37:43.966]             base::options(...future.oldOptions)
[13:37:43.966]             if (.Platform$OS.type == "windows") {
[13:37:43.966]                 old_names <- names(...future.oldEnvVars)
[13:37:43.966]                 envs <- base::Sys.getenv()
[13:37:43.966]                 names <- names(envs)
[13:37:43.966]                 common <- intersect(names, old_names)
[13:37:43.966]                 added <- setdiff(names, old_names)
[13:37:43.966]                 removed <- setdiff(old_names, names)
[13:37:43.966]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:43.966]                   envs[common]]
[13:37:43.966]                 NAMES <- toupper(changed)
[13:37:43.966]                 args <- list()
[13:37:43.966]                 for (kk in seq_along(NAMES)) {
[13:37:43.966]                   name <- changed[[kk]]
[13:37:43.966]                   NAME <- NAMES[[kk]]
[13:37:43.966]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.966]                     next
[13:37:43.966]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.966]                 }
[13:37:43.966]                 NAMES <- toupper(added)
[13:37:43.966]                 for (kk in seq_along(NAMES)) {
[13:37:43.966]                   name <- added[[kk]]
[13:37:43.966]                   NAME <- NAMES[[kk]]
[13:37:43.966]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.966]                     next
[13:37:43.966]                   args[[name]] <- ""
[13:37:43.966]                 }
[13:37:43.966]                 NAMES <- toupper(removed)
[13:37:43.966]                 for (kk in seq_along(NAMES)) {
[13:37:43.966]                   name <- removed[[kk]]
[13:37:43.966]                   NAME <- NAMES[[kk]]
[13:37:43.966]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:43.966]                     next
[13:37:43.966]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:43.966]                 }
[13:37:43.966]                 if (length(args) > 0) 
[13:37:43.966]                   base::do.call(base::Sys.setenv, args = args)
[13:37:43.966]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:43.966]             }
[13:37:43.966]             else {
[13:37:43.966]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:43.966]             }
[13:37:43.966]             {
[13:37:43.966]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:43.966]                   0L) {
[13:37:43.966]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:43.966]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:43.966]                   base::options(opts)
[13:37:43.966]                 }
[13:37:43.966]                 {
[13:37:43.966]                   {
[13:37:43.966]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:43.966]                     NULL
[13:37:43.966]                   }
[13:37:43.966]                   options(future.plan = NULL)
[13:37:43.966]                   if (is.na(NA_character_)) 
[13:37:43.966]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:43.966]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:43.966]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:43.966]                     .init = FALSE)
[13:37:43.966]                 }
[13:37:43.966]             }
[13:37:43.966]         }
[13:37:43.966]     })
[13:37:43.966]     if (TRUE) {
[13:37:43.966]         base::sink(type = "output", split = FALSE)
[13:37:43.966]         if (TRUE) {
[13:37:43.966]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:43.966]         }
[13:37:43.966]         else {
[13:37:43.966]             ...future.result["stdout"] <- base::list(NULL)
[13:37:43.966]         }
[13:37:43.966]         base::close(...future.stdout)
[13:37:43.966]         ...future.stdout <- NULL
[13:37:43.966]     }
[13:37:43.966]     ...future.result$conditions <- ...future.conditions
[13:37:43.966]     ...future.result$finished <- base::Sys.time()
[13:37:43.966]     ...future.result
[13:37:43.966] }
[13:37:43.970] requestCore(): workers = 2
[13:37:43.970] Poll #1 (0): usedCores() = 2, workers = 2
[13:37:43.981] result() for MulticoreFuture ...
[13:37:43.982] result() for MulticoreFuture ...
[13:37:43.982] result() for MulticoreFuture ... done
[13:37:43.982] result() for MulticoreFuture ... done
[13:37:43.982] result() for MulticoreFuture ...
[13:37:43.982] result() for MulticoreFuture ... done
[13:37:43.985] MulticoreFuture started
[13:37:43.986] - Launch lazy future ... done
[13:37:43.986] run() for ‘MulticoreFuture’ ... done
[13:37:43.987] plan(): Setting new future strategy stack:
[13:37:43.987] List of future strategies:
[13:37:43.987] 1. sequential:
[13:37:43.987]    - args: function (..., envir = parent.frame())
[13:37:43.987]    - tweaked: FALSE
[13:37:43.987]    - call: NULL
[13:37:43.988] plan(): nbrOfWorkers() = 1
[13:37:43.991] plan(): Setting new future strategy stack:
[13:37:43.991] List of future strategies:
[13:37:43.991] 1. multicore:
[13:37:43.991]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:37:43.991]    - tweaked: FALSE
[13:37:43.991]    - call: plan(strategy)
[13:37:43.996] plan(): nbrOfWorkers() = 2
[13:37:43.997] run() for ‘Future’ ...
[13:37:43.997] - state: ‘created’
[13:37:43.997] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:37:44.003] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:44.003] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:37:44.003]   - Field: ‘label’
[13:37:44.003]   - Field: ‘local’
[13:37:44.003]   - Field: ‘owner’
[13:37:44.004]   - Field: ‘envir’
[13:37:44.004]   - Field: ‘workers’
[13:37:44.004]   - Field: ‘packages’
[13:37:44.004]   - Field: ‘gc’
[13:37:44.004]   - Field: ‘job’
[13:37:44.004]   - Field: ‘conditions’
[13:37:44.005]   - Field: ‘expr’
[13:37:44.005]   - Field: ‘uuid’
[13:37:44.005]   - Field: ‘seed’
[13:37:44.005]   - Field: ‘version’
[13:37:44.005]   - Field: ‘result’
[13:37:44.005]   - Field: ‘asynchronous’
[13:37:44.006]   - Field: ‘calls’
[13:37:44.006]   - Field: ‘globals’
[13:37:44.006]   - Field: ‘stdout’
[13:37:44.006]   - Field: ‘earlySignal’
[13:37:44.006]   - Field: ‘lazy’
[13:37:44.006]   - Field: ‘state’
[13:37:44.007] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:37:44.007] - Launch lazy future ...
[13:37:44.007] Packages needed by the future expression (n = 0): <none>
[13:37:44.007] Packages needed by future strategies (n = 0): <none>
[13:37:44.008] {
[13:37:44.008]     {
[13:37:44.008]         {
[13:37:44.008]             ...future.startTime <- base::Sys.time()
[13:37:44.008]             {
[13:37:44.008]                 {
[13:37:44.008]                   {
[13:37:44.008]                     {
[13:37:44.008]                       base::local({
[13:37:44.008]                         has_future <- base::requireNamespace("future", 
[13:37:44.008]                           quietly = TRUE)
[13:37:44.008]                         if (has_future) {
[13:37:44.008]                           ns <- base::getNamespace("future")
[13:37:44.008]                           version <- ns[[".package"]][["version"]]
[13:37:44.008]                           if (is.null(version)) 
[13:37:44.008]                             version <- utils::packageVersion("future")
[13:37:44.008]                         }
[13:37:44.008]                         else {
[13:37:44.008]                           version <- NULL
[13:37:44.008]                         }
[13:37:44.008]                         if (!has_future || version < "1.8.0") {
[13:37:44.008]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:44.008]                             "", base::R.version$version.string), 
[13:37:44.008]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:44.008]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:44.008]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:44.008]                               "release", "version")], collapse = " "), 
[13:37:44.008]                             hostname = base::Sys.info()[["nodename"]])
[13:37:44.008]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:44.008]                             info)
[13:37:44.008]                           info <- base::paste(info, collapse = "; ")
[13:37:44.008]                           if (!has_future) {
[13:37:44.008]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:44.008]                               info)
[13:37:44.008]                           }
[13:37:44.008]                           else {
[13:37:44.008]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:44.008]                               info, version)
[13:37:44.008]                           }
[13:37:44.008]                           base::stop(msg)
[13:37:44.008]                         }
[13:37:44.008]                       })
[13:37:44.008]                     }
[13:37:44.008]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:44.008]                     base::options(mc.cores = 1L)
[13:37:44.008]                   }
[13:37:44.008]                   ...future.strategy.old <- future::plan("list")
[13:37:44.008]                   options(future.plan = NULL)
[13:37:44.008]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:44.008]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:44.008]                 }
[13:37:44.008]                 ...future.workdir <- getwd()
[13:37:44.008]             }
[13:37:44.008]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:44.008]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:44.008]         }
[13:37:44.008]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:44.008]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:44.008]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:44.008]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:44.008]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:44.008]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:44.008]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:44.008]             base::names(...future.oldOptions))
[13:37:44.008]     }
[13:37:44.008]     if (FALSE) {
[13:37:44.008]     }
[13:37:44.008]     else {
[13:37:44.008]         if (TRUE) {
[13:37:44.008]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:44.008]                 open = "w")
[13:37:44.008]         }
[13:37:44.008]         else {
[13:37:44.008]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:44.008]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:44.008]         }
[13:37:44.008]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:44.008]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:44.008]             base::sink(type = "output", split = FALSE)
[13:37:44.008]             base::close(...future.stdout)
[13:37:44.008]         }, add = TRUE)
[13:37:44.008]     }
[13:37:44.008]     ...future.frame <- base::sys.nframe()
[13:37:44.008]     ...future.conditions <- base::list()
[13:37:44.008]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:44.008]     if (FALSE) {
[13:37:44.008]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:44.008]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:44.008]     }
[13:37:44.008]     ...future.result <- base::tryCatch({
[13:37:44.008]         base::withCallingHandlers({
[13:37:44.008]             ...future.value <- base::withVisible(base::local({
[13:37:44.008]                 withCallingHandlers({
[13:37:44.008]                   2
[13:37:44.008]                 }, immediateCondition = function(cond) {
[13:37:44.008]                   save_rds <- function (object, pathname, ...) 
[13:37:44.008]                   {
[13:37:44.008]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:37:44.008]                     if (file_test("-f", pathname_tmp)) {
[13:37:44.008]                       fi_tmp <- file.info(pathname_tmp)
[13:37:44.008]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:37:44.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:44.008]                         fi_tmp[["mtime"]])
[13:37:44.008]                     }
[13:37:44.008]                     tryCatch({
[13:37:44.008]                       saveRDS(object, file = pathname_tmp, ...)
[13:37:44.008]                     }, error = function(ex) {
[13:37:44.008]                       msg <- conditionMessage(ex)
[13:37:44.008]                       fi_tmp <- file.info(pathname_tmp)
[13:37:44.008]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:37:44.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:44.008]                         fi_tmp[["mtime"]], msg)
[13:37:44.008]                       ex$message <- msg
[13:37:44.008]                       stop(ex)
[13:37:44.008]                     })
[13:37:44.008]                     stopifnot(file_test("-f", pathname_tmp))
[13:37:44.008]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:37:44.008]                     if (!res || file_test("-f", pathname_tmp)) {
[13:37:44.008]                       fi_tmp <- file.info(pathname_tmp)
[13:37:44.008]                       fi <- file.info(pathname)
[13:37:44.008]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:37:44.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:44.008]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:37:44.008]                         fi[["size"]], fi[["mtime"]])
[13:37:44.008]                       stop(msg)
[13:37:44.008]                     }
[13:37:44.008]                     invisible(pathname)
[13:37:44.008]                   }
[13:37:44.008]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:37:44.008]                     rootPath = tempdir()) 
[13:37:44.008]                   {
[13:37:44.008]                     obj <- list(time = Sys.time(), condition = cond)
[13:37:44.008]                     file <- tempfile(pattern = class(cond)[1], 
[13:37:44.008]                       tmpdir = path, fileext = ".rds")
[13:37:44.008]                     save_rds(obj, file)
[13:37:44.008]                   }
[13:37:44.008]                   saveImmediateCondition(cond, path = "/tmp/RtmpLAMaHJ/.future/immediateConditions")
[13:37:44.008]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:44.008]                   {
[13:37:44.008]                     inherits <- base::inherits
[13:37:44.008]                     invokeRestart <- base::invokeRestart
[13:37:44.008]                     is.null <- base::is.null
[13:37:44.008]                     muffled <- FALSE
[13:37:44.008]                     if (inherits(cond, "message")) {
[13:37:44.008]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:44.008]                       if (muffled) 
[13:37:44.008]                         invokeRestart("muffleMessage")
[13:37:44.008]                     }
[13:37:44.008]                     else if (inherits(cond, "warning")) {
[13:37:44.008]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:44.008]                       if (muffled) 
[13:37:44.008]                         invokeRestart("muffleWarning")
[13:37:44.008]                     }
[13:37:44.008]                     else if (inherits(cond, "condition")) {
[13:37:44.008]                       if (!is.null(pattern)) {
[13:37:44.008]                         computeRestarts <- base::computeRestarts
[13:37:44.008]                         grepl <- base::grepl
[13:37:44.008]                         restarts <- computeRestarts(cond)
[13:37:44.008]                         for (restart in restarts) {
[13:37:44.008]                           name <- restart$name
[13:37:44.008]                           if (is.null(name)) 
[13:37:44.008]                             next
[13:37:44.008]                           if (!grepl(pattern, name)) 
[13:37:44.008]                             next
[13:37:44.008]                           invokeRestart(restart)
[13:37:44.008]                           muffled <- TRUE
[13:37:44.008]                           break
[13:37:44.008]                         }
[13:37:44.008]                       }
[13:37:44.008]                     }
[13:37:44.008]                     invisible(muffled)
[13:37:44.008]                   }
[13:37:44.008]                   muffleCondition(cond)
[13:37:44.008]                 })
[13:37:44.008]             }))
[13:37:44.008]             future::FutureResult(value = ...future.value$value, 
[13:37:44.008]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:44.008]                   ...future.rng), globalenv = if (FALSE) 
[13:37:44.008]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:44.008]                     ...future.globalenv.names))
[13:37:44.008]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:44.008]         }, condition = base::local({
[13:37:44.008]             c <- base::c
[13:37:44.008]             inherits <- base::inherits
[13:37:44.008]             invokeRestart <- base::invokeRestart
[13:37:44.008]             length <- base::length
[13:37:44.008]             list <- base::list
[13:37:44.008]             seq.int <- base::seq.int
[13:37:44.008]             signalCondition <- base::signalCondition
[13:37:44.008]             sys.calls <- base::sys.calls
[13:37:44.008]             `[[` <- base::`[[`
[13:37:44.008]             `+` <- base::`+`
[13:37:44.008]             `<<-` <- base::`<<-`
[13:37:44.008]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:44.008]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:44.008]                   3L)]
[13:37:44.008]             }
[13:37:44.008]             function(cond) {
[13:37:44.008]                 is_error <- inherits(cond, "error")
[13:37:44.008]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:44.008]                   NULL)
[13:37:44.008]                 if (is_error) {
[13:37:44.008]                   sessionInformation <- function() {
[13:37:44.008]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:44.008]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:44.008]                       search = base::search(), system = base::Sys.info())
[13:37:44.008]                   }
[13:37:44.008]                   ...future.conditions[[length(...future.conditions) + 
[13:37:44.008]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:44.008]                     cond$call), session = sessionInformation(), 
[13:37:44.008]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:44.008]                   signalCondition(cond)
[13:37:44.008]                 }
[13:37:44.008]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:44.008]                 "immediateCondition"))) {
[13:37:44.008]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:44.008]                   ...future.conditions[[length(...future.conditions) + 
[13:37:44.008]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:44.008]                   if (TRUE && !signal) {
[13:37:44.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:44.008]                     {
[13:37:44.008]                       inherits <- base::inherits
[13:37:44.008]                       invokeRestart <- base::invokeRestart
[13:37:44.008]                       is.null <- base::is.null
[13:37:44.008]                       muffled <- FALSE
[13:37:44.008]                       if (inherits(cond, "message")) {
[13:37:44.008]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:44.008]                         if (muffled) 
[13:37:44.008]                           invokeRestart("muffleMessage")
[13:37:44.008]                       }
[13:37:44.008]                       else if (inherits(cond, "warning")) {
[13:37:44.008]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:44.008]                         if (muffled) 
[13:37:44.008]                           invokeRestart("muffleWarning")
[13:37:44.008]                       }
[13:37:44.008]                       else if (inherits(cond, "condition")) {
[13:37:44.008]                         if (!is.null(pattern)) {
[13:37:44.008]                           computeRestarts <- base::computeRestarts
[13:37:44.008]                           grepl <- base::grepl
[13:37:44.008]                           restarts <- computeRestarts(cond)
[13:37:44.008]                           for (restart in restarts) {
[13:37:44.008]                             name <- restart$name
[13:37:44.008]                             if (is.null(name)) 
[13:37:44.008]                               next
[13:37:44.008]                             if (!grepl(pattern, name)) 
[13:37:44.008]                               next
[13:37:44.008]                             invokeRestart(restart)
[13:37:44.008]                             muffled <- TRUE
[13:37:44.008]                             break
[13:37:44.008]                           }
[13:37:44.008]                         }
[13:37:44.008]                       }
[13:37:44.008]                       invisible(muffled)
[13:37:44.008]                     }
[13:37:44.008]                     muffleCondition(cond, pattern = "^muffle")
[13:37:44.008]                   }
[13:37:44.008]                 }
[13:37:44.008]                 else {
[13:37:44.008]                   if (TRUE) {
[13:37:44.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:44.008]                     {
[13:37:44.008]                       inherits <- base::inherits
[13:37:44.008]                       invokeRestart <- base::invokeRestart
[13:37:44.008]                       is.null <- base::is.null
[13:37:44.008]                       muffled <- FALSE
[13:37:44.008]                       if (inherits(cond, "message")) {
[13:37:44.008]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:44.008]                         if (muffled) 
[13:37:44.008]                           invokeRestart("muffleMessage")
[13:37:44.008]                       }
[13:37:44.008]                       else if (inherits(cond, "warning")) {
[13:37:44.008]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:44.008]                         if (muffled) 
[13:37:44.008]                           invokeRestart("muffleWarning")
[13:37:44.008]                       }
[13:37:44.008]                       else if (inherits(cond, "condition")) {
[13:37:44.008]                         if (!is.null(pattern)) {
[13:37:44.008]                           computeRestarts <- base::computeRestarts
[13:37:44.008]                           grepl <- base::grepl
[13:37:44.008]                           restarts <- computeRestarts(cond)
[13:37:44.008]                           for (restart in restarts) {
[13:37:44.008]                             name <- restart$name
[13:37:44.008]                             if (is.null(name)) 
[13:37:44.008]                               next
[13:37:44.008]                             if (!grepl(pattern, name)) 
[13:37:44.008]                               next
[13:37:44.008]                             invokeRestart(restart)
[13:37:44.008]                             muffled <- TRUE
[13:37:44.008]                             break
[13:37:44.008]                           }
[13:37:44.008]                         }
[13:37:44.008]                       }
[13:37:44.008]                       invisible(muffled)
[13:37:44.008]                     }
[13:37:44.008]                     muffleCondition(cond, pattern = "^muffle")
[13:37:44.008]                   }
[13:37:44.008]                 }
[13:37:44.008]             }
[13:37:44.008]         }))
[13:37:44.008]     }, error = function(ex) {
[13:37:44.008]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:44.008]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:44.008]                 ...future.rng), started = ...future.startTime, 
[13:37:44.008]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:44.008]             version = "1.8"), class = "FutureResult")
[13:37:44.008]     }, finally = {
[13:37:44.008]         if (!identical(...future.workdir, getwd())) 
[13:37:44.008]             setwd(...future.workdir)
[13:37:44.008]         {
[13:37:44.008]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:44.008]                 ...future.oldOptions$nwarnings <- NULL
[13:37:44.008]             }
[13:37:44.008]             base::options(...future.oldOptions)
[13:37:44.008]             if (.Platform$OS.type == "windows") {
[13:37:44.008]                 old_names <- names(...future.oldEnvVars)
[13:37:44.008]                 envs <- base::Sys.getenv()
[13:37:44.008]                 names <- names(envs)
[13:37:44.008]                 common <- intersect(names, old_names)
[13:37:44.008]                 added <- setdiff(names, old_names)
[13:37:44.008]                 removed <- setdiff(old_names, names)
[13:37:44.008]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:44.008]                   envs[common]]
[13:37:44.008]                 NAMES <- toupper(changed)
[13:37:44.008]                 args <- list()
[13:37:44.008]                 for (kk in seq_along(NAMES)) {
[13:37:44.008]                   name <- changed[[kk]]
[13:37:44.008]                   NAME <- NAMES[[kk]]
[13:37:44.008]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:44.008]                     next
[13:37:44.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:44.008]                 }
[13:37:44.008]                 NAMES <- toupper(added)
[13:37:44.008]                 for (kk in seq_along(NAMES)) {
[13:37:44.008]                   name <- added[[kk]]
[13:37:44.008]                   NAME <- NAMES[[kk]]
[13:37:44.008]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:44.008]                     next
[13:37:44.008]                   args[[name]] <- ""
[13:37:44.008]                 }
[13:37:44.008]                 NAMES <- toupper(removed)
[13:37:44.008]                 for (kk in seq_along(NAMES)) {
[13:37:44.008]                   name <- removed[[kk]]
[13:37:44.008]                   NAME <- NAMES[[kk]]
[13:37:44.008]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:44.008]                     next
[13:37:44.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:44.008]                 }
[13:37:44.008]                 if (length(args) > 0) 
[13:37:44.008]                   base::do.call(base::Sys.setenv, args = args)
[13:37:44.008]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:44.008]             }
[13:37:44.008]             else {
[13:37:44.008]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:44.008]             }
[13:37:44.008]             {
[13:37:44.008]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:44.008]                   0L) {
[13:37:44.008]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:44.008]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:44.008]                   base::options(opts)
[13:37:44.008]                 }
[13:37:44.008]                 {
[13:37:44.008]                   {
[13:37:44.008]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:44.008]                     NULL
[13:37:44.008]                   }
[13:37:44.008]                   options(future.plan = NULL)
[13:37:44.008]                   if (is.na(NA_character_)) 
[13:37:44.008]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:44.008]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:44.008]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:44.008]                     .init = FALSE)
[13:37:44.008]                 }
[13:37:44.008]             }
[13:37:44.008]         }
[13:37:44.008]     })
[13:37:44.008]     if (TRUE) {
[13:37:44.008]         base::sink(type = "output", split = FALSE)
[13:37:44.008]         if (TRUE) {
[13:37:44.008]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:44.008]         }
[13:37:44.008]         else {
[13:37:44.008]             ...future.result["stdout"] <- base::list(NULL)
[13:37:44.008]         }
[13:37:44.008]         base::close(...future.stdout)
[13:37:44.008]         ...future.stdout <- NULL
[13:37:44.008]     }
[13:37:44.008]     ...future.result$conditions <- ...future.conditions
[13:37:44.008]     ...future.result$finished <- base::Sys.time()
[13:37:44.008]     ...future.result
[13:37:44.008] }
[13:37:44.012] requestCore(): workers = 2
[13:37:44.012] Poll #1 (0): usedCores() = 2, workers = 2
[13:37:44.023] result() for MulticoreFuture ...
[13:37:44.024] result() for MulticoreFuture ...
[13:37:44.024] result() for MulticoreFuture ... done
[13:37:44.024] result() for MulticoreFuture ... done
[13:37:44.024] result() for MulticoreFuture ...
[13:37:44.024] result() for MulticoreFuture ... done
[13:37:44.027] MulticoreFuture started
[13:37:44.027] - Launch lazy future ... done
[13:37:44.028] run() for ‘MulticoreFuture’ ... done
[13:37:44.028] plan(): Setting new future strategy stack:
[13:37:44.029] List of future strategies:
[13:37:44.029] 1. sequential:
[13:37:44.029]    - args: function (..., envir = parent.frame())
[13:37:44.029]    - tweaked: FALSE
[13:37:44.029]    - call: NULL
[13:37:44.030] plan(): nbrOfWorkers() = 1
[13:37:44.032] plan(): Setting new future strategy stack:
[13:37:44.032] List of future strategies:
[13:37:44.032] 1. multicore:
[13:37:44.032]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:37:44.032]    - tweaked: FALSE
[13:37:44.032]    - call: plan(strategy)
[13:37:44.038] plan(): nbrOfWorkers() = 2
[13:37:44.038] Future #2
[13:37:44.039]  length: 2 (resolved future 2)
[13:37:44.039]  length: 1 (resolved future 3)
[13:37:44.049] Future #1
[13:37:44.049]  length: 0 (resolved future 1)
[13:37:44.050] resolve() on list ... DONE
[13:37:44.050] getGlobalsAndPackages() ...
[13:37:44.051] Searching for globals...
[13:37:44.051] 
[13:37:44.052] Searching for globals ... DONE
[13:37:44.052] - globals: [0] <none>
[13:37:44.052] getGlobalsAndPackages() ... DONE
[13:37:44.052] run() for ‘Future’ ...
[13:37:44.053] - state: ‘created’
[13:37:44.053] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:37:44.058] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:44.058] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:37:44.058]   - Field: ‘label’
[13:37:44.058]   - Field: ‘local’
[13:37:44.059]   - Field: ‘owner’
[13:37:44.059]   - Field: ‘envir’
[13:37:44.059]   - Field: ‘workers’
[13:37:44.059]   - Field: ‘packages’
[13:37:44.059]   - Field: ‘gc’
[13:37:44.059]   - Field: ‘job’
[13:37:44.060]   - Field: ‘conditions’
[13:37:44.060]   - Field: ‘expr’
[13:37:44.060]   - Field: ‘uuid’
[13:37:44.060]   - Field: ‘seed’
[13:37:44.060]   - Field: ‘version’
[13:37:44.060]   - Field: ‘result’
[13:37:44.060]   - Field: ‘asynchronous’
[13:37:44.061]   - Field: ‘calls’
[13:37:44.061]   - Field: ‘globals’
[13:37:44.061]   - Field: ‘stdout’
[13:37:44.061]   - Field: ‘earlySignal’
[13:37:44.061]   - Field: ‘lazy’
[13:37:44.061]   - Field: ‘state’
[13:37:44.061] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:37:44.062] - Launch lazy future ...
[13:37:44.067] Packages needed by the future expression (n = 0): <none>
[13:37:44.067] Packages needed by future strategies (n = 0): <none>
[13:37:44.069] {
[13:37:44.069]     {
[13:37:44.069]         {
[13:37:44.069]             ...future.startTime <- base::Sys.time()
[13:37:44.069]             {
[13:37:44.069]                 {
[13:37:44.069]                   {
[13:37:44.069]                     {
[13:37:44.069]                       base::local({
[13:37:44.069]                         has_future <- base::requireNamespace("future", 
[13:37:44.069]                           quietly = TRUE)
[13:37:44.069]                         if (has_future) {
[13:37:44.069]                           ns <- base::getNamespace("future")
[13:37:44.069]                           version <- ns[[".package"]][["version"]]
[13:37:44.069]                           if (is.null(version)) 
[13:37:44.069]                             version <- utils::packageVersion("future")
[13:37:44.069]                         }
[13:37:44.069]                         else {
[13:37:44.069]                           version <- NULL
[13:37:44.069]                         }
[13:37:44.069]                         if (!has_future || version < "1.8.0") {
[13:37:44.069]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:44.069]                             "", base::R.version$version.string), 
[13:37:44.069]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:44.069]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:44.069]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:44.069]                               "release", "version")], collapse = " "), 
[13:37:44.069]                             hostname = base::Sys.info()[["nodename"]])
[13:37:44.069]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:44.069]                             info)
[13:37:44.069]                           info <- base::paste(info, collapse = "; ")
[13:37:44.069]                           if (!has_future) {
[13:37:44.069]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:44.069]                               info)
[13:37:44.069]                           }
[13:37:44.069]                           else {
[13:37:44.069]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:44.069]                               info, version)
[13:37:44.069]                           }
[13:37:44.069]                           base::stop(msg)
[13:37:44.069]                         }
[13:37:44.069]                       })
[13:37:44.069]                     }
[13:37:44.069]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:44.069]                     base::options(mc.cores = 1L)
[13:37:44.069]                   }
[13:37:44.069]                   ...future.strategy.old <- future::plan("list")
[13:37:44.069]                   options(future.plan = NULL)
[13:37:44.069]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:44.069]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:44.069]                 }
[13:37:44.069]                 ...future.workdir <- getwd()
[13:37:44.069]             }
[13:37:44.069]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:44.069]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:44.069]         }
[13:37:44.069]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:44.069]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:44.069]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:44.069]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:44.069]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:44.069]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:44.069]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:44.069]             base::names(...future.oldOptions))
[13:37:44.069]     }
[13:37:44.069]     if (FALSE) {
[13:37:44.069]     }
[13:37:44.069]     else {
[13:37:44.069]         if (TRUE) {
[13:37:44.069]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:44.069]                 open = "w")
[13:37:44.069]         }
[13:37:44.069]         else {
[13:37:44.069]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:44.069]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:44.069]         }
[13:37:44.069]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:44.069]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:44.069]             base::sink(type = "output", split = FALSE)
[13:37:44.069]             base::close(...future.stdout)
[13:37:44.069]         }, add = TRUE)
[13:37:44.069]     }
[13:37:44.069]     ...future.frame <- base::sys.nframe()
[13:37:44.069]     ...future.conditions <- base::list()
[13:37:44.069]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:44.069]     if (FALSE) {
[13:37:44.069]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:44.069]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:44.069]     }
[13:37:44.069]     ...future.result <- base::tryCatch({
[13:37:44.069]         base::withCallingHandlers({
[13:37:44.069]             ...future.value <- base::withVisible(base::local({
[13:37:44.069]                 withCallingHandlers({
[13:37:44.069]                   1
[13:37:44.069]                 }, immediateCondition = function(cond) {
[13:37:44.069]                   save_rds <- function (object, pathname, ...) 
[13:37:44.069]                   {
[13:37:44.069]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:37:44.069]                     if (file_test("-f", pathname_tmp)) {
[13:37:44.069]                       fi_tmp <- file.info(pathname_tmp)
[13:37:44.069]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:37:44.069]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:44.069]                         fi_tmp[["mtime"]])
[13:37:44.069]                     }
[13:37:44.069]                     tryCatch({
[13:37:44.069]                       saveRDS(object, file = pathname_tmp, ...)
[13:37:44.069]                     }, error = function(ex) {
[13:37:44.069]                       msg <- conditionMessage(ex)
[13:37:44.069]                       fi_tmp <- file.info(pathname_tmp)
[13:37:44.069]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:37:44.069]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:44.069]                         fi_tmp[["mtime"]], msg)
[13:37:44.069]                       ex$message <- msg
[13:37:44.069]                       stop(ex)
[13:37:44.069]                     })
[13:37:44.069]                     stopifnot(file_test("-f", pathname_tmp))
[13:37:44.069]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:37:44.069]                     if (!res || file_test("-f", pathname_tmp)) {
[13:37:44.069]                       fi_tmp <- file.info(pathname_tmp)
[13:37:44.069]                       fi <- file.info(pathname)
[13:37:44.069]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:37:44.069]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:44.069]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:37:44.069]                         fi[["size"]], fi[["mtime"]])
[13:37:44.069]                       stop(msg)
[13:37:44.069]                     }
[13:37:44.069]                     invisible(pathname)
[13:37:44.069]                   }
[13:37:44.069]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:37:44.069]                     rootPath = tempdir()) 
[13:37:44.069]                   {
[13:37:44.069]                     obj <- list(time = Sys.time(), condition = cond)
[13:37:44.069]                     file <- tempfile(pattern = class(cond)[1], 
[13:37:44.069]                       tmpdir = path, fileext = ".rds")
[13:37:44.069]                     save_rds(obj, file)
[13:37:44.069]                   }
[13:37:44.069]                   saveImmediateCondition(cond, path = "/tmp/RtmpLAMaHJ/.future/immediateConditions")
[13:37:44.069]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:44.069]                   {
[13:37:44.069]                     inherits <- base::inherits
[13:37:44.069]                     invokeRestart <- base::invokeRestart
[13:37:44.069]                     is.null <- base::is.null
[13:37:44.069]                     muffled <- FALSE
[13:37:44.069]                     if (inherits(cond, "message")) {
[13:37:44.069]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:44.069]                       if (muffled) 
[13:37:44.069]                         invokeRestart("muffleMessage")
[13:37:44.069]                     }
[13:37:44.069]                     else if (inherits(cond, "warning")) {
[13:37:44.069]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:44.069]                       if (muffled) 
[13:37:44.069]                         invokeRestart("muffleWarning")
[13:37:44.069]                     }
[13:37:44.069]                     else if (inherits(cond, "condition")) {
[13:37:44.069]                       if (!is.null(pattern)) {
[13:37:44.069]                         computeRestarts <- base::computeRestarts
[13:37:44.069]                         grepl <- base::grepl
[13:37:44.069]                         restarts <- computeRestarts(cond)
[13:37:44.069]                         for (restart in restarts) {
[13:37:44.069]                           name <- restart$name
[13:37:44.069]                           if (is.null(name)) 
[13:37:44.069]                             next
[13:37:44.069]                           if (!grepl(pattern, name)) 
[13:37:44.069]                             next
[13:37:44.069]                           invokeRestart(restart)
[13:37:44.069]                           muffled <- TRUE
[13:37:44.069]                           break
[13:37:44.069]                         }
[13:37:44.069]                       }
[13:37:44.069]                     }
[13:37:44.069]                     invisible(muffled)
[13:37:44.069]                   }
[13:37:44.069]                   muffleCondition(cond)
[13:37:44.069]                 })
[13:37:44.069]             }))
[13:37:44.069]             future::FutureResult(value = ...future.value$value, 
[13:37:44.069]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:44.069]                   ...future.rng), globalenv = if (FALSE) 
[13:37:44.069]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:44.069]                     ...future.globalenv.names))
[13:37:44.069]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:44.069]         }, condition = base::local({
[13:37:44.069]             c <- base::c
[13:37:44.069]             inherits <- base::inherits
[13:37:44.069]             invokeRestart <- base::invokeRestart
[13:37:44.069]             length <- base::length
[13:37:44.069]             list <- base::list
[13:37:44.069]             seq.int <- base::seq.int
[13:37:44.069]             signalCondition <- base::signalCondition
[13:37:44.069]             sys.calls <- base::sys.calls
[13:37:44.069]             `[[` <- base::`[[`
[13:37:44.069]             `+` <- base::`+`
[13:37:44.069]             `<<-` <- base::`<<-`
[13:37:44.069]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:44.069]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:44.069]                   3L)]
[13:37:44.069]             }
[13:37:44.069]             function(cond) {
[13:37:44.069]                 is_error <- inherits(cond, "error")
[13:37:44.069]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:44.069]                   NULL)
[13:37:44.069]                 if (is_error) {
[13:37:44.069]                   sessionInformation <- function() {
[13:37:44.069]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:44.069]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:44.069]                       search = base::search(), system = base::Sys.info())
[13:37:44.069]                   }
[13:37:44.069]                   ...future.conditions[[length(...future.conditions) + 
[13:37:44.069]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:44.069]                     cond$call), session = sessionInformation(), 
[13:37:44.069]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:44.069]                   signalCondition(cond)
[13:37:44.069]                 }
[13:37:44.069]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:44.069]                 "immediateCondition"))) {
[13:37:44.069]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:44.069]                   ...future.conditions[[length(...future.conditions) + 
[13:37:44.069]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:44.069]                   if (TRUE && !signal) {
[13:37:44.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:44.069]                     {
[13:37:44.069]                       inherits <- base::inherits
[13:37:44.069]                       invokeRestart <- base::invokeRestart
[13:37:44.069]                       is.null <- base::is.null
[13:37:44.069]                       muffled <- FALSE
[13:37:44.069]                       if (inherits(cond, "message")) {
[13:37:44.069]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:44.069]                         if (muffled) 
[13:37:44.069]                           invokeRestart("muffleMessage")
[13:37:44.069]                       }
[13:37:44.069]                       else if (inherits(cond, "warning")) {
[13:37:44.069]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:44.069]                         if (muffled) 
[13:37:44.069]                           invokeRestart("muffleWarning")
[13:37:44.069]                       }
[13:37:44.069]                       else if (inherits(cond, "condition")) {
[13:37:44.069]                         if (!is.null(pattern)) {
[13:37:44.069]                           computeRestarts <- base::computeRestarts
[13:37:44.069]                           grepl <- base::grepl
[13:37:44.069]                           restarts <- computeRestarts(cond)
[13:37:44.069]                           for (restart in restarts) {
[13:37:44.069]                             name <- restart$name
[13:37:44.069]                             if (is.null(name)) 
[13:37:44.069]                               next
[13:37:44.069]                             if (!grepl(pattern, name)) 
[13:37:44.069]                               next
[13:37:44.069]                             invokeRestart(restart)
[13:37:44.069]                             muffled <- TRUE
[13:37:44.069]                             break
[13:37:44.069]                           }
[13:37:44.069]                         }
[13:37:44.069]                       }
[13:37:44.069]                       invisible(muffled)
[13:37:44.069]                     }
[13:37:44.069]                     muffleCondition(cond, pattern = "^muffle")
[13:37:44.069]                   }
[13:37:44.069]                 }
[13:37:44.069]                 else {
[13:37:44.069]                   if (TRUE) {
[13:37:44.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:44.069]                     {
[13:37:44.069]                       inherits <- base::inherits
[13:37:44.069]                       invokeRestart <- base::invokeRestart
[13:37:44.069]                       is.null <- base::is.null
[13:37:44.069]                       muffled <- FALSE
[13:37:44.069]                       if (inherits(cond, "message")) {
[13:37:44.069]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:44.069]                         if (muffled) 
[13:37:44.069]                           invokeRestart("muffleMessage")
[13:37:44.069]                       }
[13:37:44.069]                       else if (inherits(cond, "warning")) {
[13:37:44.069]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:44.069]                         if (muffled) 
[13:37:44.069]                           invokeRestart("muffleWarning")
[13:37:44.069]                       }
[13:37:44.069]                       else if (inherits(cond, "condition")) {
[13:37:44.069]                         if (!is.null(pattern)) {
[13:37:44.069]                           computeRestarts <- base::computeRestarts
[13:37:44.069]                           grepl <- base::grepl
[13:37:44.069]                           restarts <- computeRestarts(cond)
[13:37:44.069]                           for (restart in restarts) {
[13:37:44.069]                             name <- restart$name
[13:37:44.069]                             if (is.null(name)) 
[13:37:44.069]                               next
[13:37:44.069]                             if (!grepl(pattern, name)) 
[13:37:44.069]                               next
[13:37:44.069]                             invokeRestart(restart)
[13:37:44.069]                             muffled <- TRUE
[13:37:44.069]                             break
[13:37:44.069]                           }
[13:37:44.069]                         }
[13:37:44.069]                       }
[13:37:44.069]                       invisible(muffled)
[13:37:44.069]                     }
[13:37:44.069]                     muffleCondition(cond, pattern = "^muffle")
[13:37:44.069]                   }
[13:37:44.069]                 }
[13:37:44.069]             }
[13:37:44.069]         }))
[13:37:44.069]     }, error = function(ex) {
[13:37:44.069]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:44.069]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:44.069]                 ...future.rng), started = ...future.startTime, 
[13:37:44.069]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:44.069]             version = "1.8"), class = "FutureResult")
[13:37:44.069]     }, finally = {
[13:37:44.069]         if (!identical(...future.workdir, getwd())) 
[13:37:44.069]             setwd(...future.workdir)
[13:37:44.069]         {
[13:37:44.069]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:44.069]                 ...future.oldOptions$nwarnings <- NULL
[13:37:44.069]             }
[13:37:44.069]             base::options(...future.oldOptions)
[13:37:44.069]             if (.Platform$OS.type == "windows") {
[13:37:44.069]                 old_names <- names(...future.oldEnvVars)
[13:37:44.069]                 envs <- base::Sys.getenv()
[13:37:44.069]                 names <- names(envs)
[13:37:44.069]                 common <- intersect(names, old_names)
[13:37:44.069]                 added <- setdiff(names, old_names)
[13:37:44.069]                 removed <- setdiff(old_names, names)
[13:37:44.069]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:44.069]                   envs[common]]
[13:37:44.069]                 NAMES <- toupper(changed)
[13:37:44.069]                 args <- list()
[13:37:44.069]                 for (kk in seq_along(NAMES)) {
[13:37:44.069]                   name <- changed[[kk]]
[13:37:44.069]                   NAME <- NAMES[[kk]]
[13:37:44.069]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:44.069]                     next
[13:37:44.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:44.069]                 }
[13:37:44.069]                 NAMES <- toupper(added)
[13:37:44.069]                 for (kk in seq_along(NAMES)) {
[13:37:44.069]                   name <- added[[kk]]
[13:37:44.069]                   NAME <- NAMES[[kk]]
[13:37:44.069]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:44.069]                     next
[13:37:44.069]                   args[[name]] <- ""
[13:37:44.069]                 }
[13:37:44.069]                 NAMES <- toupper(removed)
[13:37:44.069]                 for (kk in seq_along(NAMES)) {
[13:37:44.069]                   name <- removed[[kk]]
[13:37:44.069]                   NAME <- NAMES[[kk]]
[13:37:44.069]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:44.069]                     next
[13:37:44.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:44.069]                 }
[13:37:44.069]                 if (length(args) > 0) 
[13:37:44.069]                   base::do.call(base::Sys.setenv, args = args)
[13:37:44.069]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:44.069]             }
[13:37:44.069]             else {
[13:37:44.069]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:44.069]             }
[13:37:44.069]             {
[13:37:44.069]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:44.069]                   0L) {
[13:37:44.069]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:44.069]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:44.069]                   base::options(opts)
[13:37:44.069]                 }
[13:37:44.069]                 {
[13:37:44.069]                   {
[13:37:44.069]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:44.069]                     NULL
[13:37:44.069]                   }
[13:37:44.069]                   options(future.plan = NULL)
[13:37:44.069]                   if (is.na(NA_character_)) 
[13:37:44.069]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:44.069]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:44.069]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:44.069]                     .init = FALSE)
[13:37:44.069]                 }
[13:37:44.069]             }
[13:37:44.069]         }
[13:37:44.069]     })
[13:37:44.069]     if (TRUE) {
[13:37:44.069]         base::sink(type = "output", split = FALSE)
[13:37:44.069]         if (TRUE) {
[13:37:44.069]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:44.069]         }
[13:37:44.069]         else {
[13:37:44.069]             ...future.result["stdout"] <- base::list(NULL)
[13:37:44.069]         }
[13:37:44.069]         base::close(...future.stdout)
[13:37:44.069]         ...future.stdout <- NULL
[13:37:44.069]     }
[13:37:44.069]     ...future.result$conditions <- ...future.conditions
[13:37:44.069]     ...future.result$finished <- base::Sys.time()
[13:37:44.069]     ...future.result
[13:37:44.069] }
[13:37:44.072] requestCore(): workers = 2
[13:37:44.072] Poll #1 (0): usedCores() = 2, workers = 2
[13:37:44.084] result() for MulticoreFuture ...
[13:37:44.085] result() for MulticoreFuture ...
[13:37:44.085] result() for MulticoreFuture ... done
[13:37:44.085] result() for MulticoreFuture ... done
[13:37:44.086] result() for MulticoreFuture ...
[13:37:44.086] result() for MulticoreFuture ... done
[13:37:44.089] MulticoreFuture started
[13:37:44.090] - Launch lazy future ... done
[13:37:44.090] run() for ‘MulticoreFuture’ ... done
[13:37:44.090] plan(): Setting new future strategy stack:
[13:37:44.091] getGlobalsAndPackages() ...
[13:37:44.091] Searching for globals...
[13:37:44.091] List of future strategies:
[13:37:44.091] 1. sequential:
[13:37:44.091]    - args: function (..., envir = parent.frame())
[13:37:44.091]    - tweaked: FALSE
[13:37:44.091]    - call: NULL
[13:37:44.092] plan(): nbrOfWorkers() = 1
[13:37:44.094] - globals found: [2] ‘{’, ‘Sys.sleep’
[13:37:44.094] Searching for globals ... DONE
[13:37:44.095] plan(): Setting new future strategy stack:
[13:37:44.094] Resolving globals: FALSE
[13:37:44.095] List of future strategies:
[13:37:44.095] 1. multicore:
[13:37:44.095]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:37:44.095]    - tweaked: FALSE
[13:37:44.095]    - call: plan(strategy)
[13:37:44.095] 
[13:37:44.096] 
[13:37:44.096] getGlobalsAndPackages() ... DONE
[13:37:44.096] run() for ‘Future’ ...
[13:37:44.097] - state: ‘created’
[13:37:44.097] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:37:44.101] plan(): nbrOfWorkers() = 2
[13:37:44.102] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:44.102] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:37:44.102]   - Field: ‘label’
[13:37:44.103]   - Field: ‘local’
[13:37:44.103]   - Field: ‘owner’
[13:37:44.103]   - Field: ‘envir’
[13:37:44.103]   - Field: ‘workers’
[13:37:44.103]   - Field: ‘packages’
[13:37:44.103]   - Field: ‘gc’
[13:37:44.104]   - Field: ‘job’
[13:37:44.104]   - Field: ‘conditions’
[13:37:44.104]   - Field: ‘expr’
[13:37:44.104]   - Field: ‘uuid’
[13:37:44.104]   - Field: ‘seed’
[13:37:44.104]   - Field: ‘version’
[13:37:44.105]   - Field: ‘result’
[13:37:44.105]   - Field: ‘asynchronous’
[13:37:44.105]   - Field: ‘calls’
[13:37:44.105]   - Field: ‘globals’
[13:37:44.105]   - Field: ‘stdout’
[13:37:44.105]   - Field: ‘earlySignal’
[13:37:44.105]   - Field: ‘lazy’
[13:37:44.106]   - Field: ‘state’
[13:37:44.106] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:37:44.106] - Launch lazy future ...
[13:37:44.106] Packages needed by the future expression (n = 0): <none>
[13:37:44.107] Packages needed by future strategies (n = 0): <none>
[13:37:44.107] {
[13:37:44.107]     {
[13:37:44.107]         {
[13:37:44.107]             ...future.startTime <- base::Sys.time()
[13:37:44.107]             {
[13:37:44.107]                 {
[13:37:44.107]                   {
[13:37:44.107]                     {
[13:37:44.107]                       base::local({
[13:37:44.107]                         has_future <- base::requireNamespace("future", 
[13:37:44.107]                           quietly = TRUE)
[13:37:44.107]                         if (has_future) {
[13:37:44.107]                           ns <- base::getNamespace("future")
[13:37:44.107]                           version <- ns[[".package"]][["version"]]
[13:37:44.107]                           if (is.null(version)) 
[13:37:44.107]                             version <- utils::packageVersion("future")
[13:37:44.107]                         }
[13:37:44.107]                         else {
[13:37:44.107]                           version <- NULL
[13:37:44.107]                         }
[13:37:44.107]                         if (!has_future || version < "1.8.0") {
[13:37:44.107]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:44.107]                             "", base::R.version$version.string), 
[13:37:44.107]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:44.107]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:44.107]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:44.107]                               "release", "version")], collapse = " "), 
[13:37:44.107]                             hostname = base::Sys.info()[["nodename"]])
[13:37:44.107]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:44.107]                             info)
[13:37:44.107]                           info <- base::paste(info, collapse = "; ")
[13:37:44.107]                           if (!has_future) {
[13:37:44.107]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:44.107]                               info)
[13:37:44.107]                           }
[13:37:44.107]                           else {
[13:37:44.107]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:44.107]                               info, version)
[13:37:44.107]                           }
[13:37:44.107]                           base::stop(msg)
[13:37:44.107]                         }
[13:37:44.107]                       })
[13:37:44.107]                     }
[13:37:44.107]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:44.107]                     base::options(mc.cores = 1L)
[13:37:44.107]                   }
[13:37:44.107]                   ...future.strategy.old <- future::plan("list")
[13:37:44.107]                   options(future.plan = NULL)
[13:37:44.107]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:44.107]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:44.107]                 }
[13:37:44.107]                 ...future.workdir <- getwd()
[13:37:44.107]             }
[13:37:44.107]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:44.107]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:44.107]         }
[13:37:44.107]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:44.107]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:44.107]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:44.107]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:44.107]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:44.107]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:44.107]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:44.107]             base::names(...future.oldOptions))
[13:37:44.107]     }
[13:37:44.107]     if (FALSE) {
[13:37:44.107]     }
[13:37:44.107]     else {
[13:37:44.107]         if (TRUE) {
[13:37:44.107]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:44.107]                 open = "w")
[13:37:44.107]         }
[13:37:44.107]         else {
[13:37:44.107]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:44.107]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:44.107]         }
[13:37:44.107]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:44.107]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:44.107]             base::sink(type = "output", split = FALSE)
[13:37:44.107]             base::close(...future.stdout)
[13:37:44.107]         }, add = TRUE)
[13:37:44.107]     }
[13:37:44.107]     ...future.frame <- base::sys.nframe()
[13:37:44.107]     ...future.conditions <- base::list()
[13:37:44.107]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:44.107]     if (FALSE) {
[13:37:44.107]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:44.107]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:44.107]     }
[13:37:44.107]     ...future.result <- base::tryCatch({
[13:37:44.107]         base::withCallingHandlers({
[13:37:44.107]             ...future.value <- base::withVisible(base::local({
[13:37:44.107]                 withCallingHandlers({
[13:37:44.107]                   {
[13:37:44.107]                     Sys.sleep(0.5)
[13:37:44.107]                     2
[13:37:44.107]                   }
[13:37:44.107]                 }, immediateCondition = function(cond) {
[13:37:44.107]                   save_rds <- function (object, pathname, ...) 
[13:37:44.107]                   {
[13:37:44.107]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:37:44.107]                     if (file_test("-f", pathname_tmp)) {
[13:37:44.107]                       fi_tmp <- file.info(pathname_tmp)
[13:37:44.107]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:37:44.107]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:44.107]                         fi_tmp[["mtime"]])
[13:37:44.107]                     }
[13:37:44.107]                     tryCatch({
[13:37:44.107]                       saveRDS(object, file = pathname_tmp, ...)
[13:37:44.107]                     }, error = function(ex) {
[13:37:44.107]                       msg <- conditionMessage(ex)
[13:37:44.107]                       fi_tmp <- file.info(pathname_tmp)
[13:37:44.107]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:37:44.107]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:44.107]                         fi_tmp[["mtime"]], msg)
[13:37:44.107]                       ex$message <- msg
[13:37:44.107]                       stop(ex)
[13:37:44.107]                     })
[13:37:44.107]                     stopifnot(file_test("-f", pathname_tmp))
[13:37:44.107]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:37:44.107]                     if (!res || file_test("-f", pathname_tmp)) {
[13:37:44.107]                       fi_tmp <- file.info(pathname_tmp)
[13:37:44.107]                       fi <- file.info(pathname)
[13:37:44.107]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:37:44.107]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:44.107]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:37:44.107]                         fi[["size"]], fi[["mtime"]])
[13:37:44.107]                       stop(msg)
[13:37:44.107]                     }
[13:37:44.107]                     invisible(pathname)
[13:37:44.107]                   }
[13:37:44.107]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:37:44.107]                     rootPath = tempdir()) 
[13:37:44.107]                   {
[13:37:44.107]                     obj <- list(time = Sys.time(), condition = cond)
[13:37:44.107]                     file <- tempfile(pattern = class(cond)[1], 
[13:37:44.107]                       tmpdir = path, fileext = ".rds")
[13:37:44.107]                     save_rds(obj, file)
[13:37:44.107]                   }
[13:37:44.107]                   saveImmediateCondition(cond, path = "/tmp/RtmpLAMaHJ/.future/immediateConditions")
[13:37:44.107]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:44.107]                   {
[13:37:44.107]                     inherits <- base::inherits
[13:37:44.107]                     invokeRestart <- base::invokeRestart
[13:37:44.107]                     is.null <- base::is.null
[13:37:44.107]                     muffled <- FALSE
[13:37:44.107]                     if (inherits(cond, "message")) {
[13:37:44.107]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:44.107]                       if (muffled) 
[13:37:44.107]                         invokeRestart("muffleMessage")
[13:37:44.107]                     }
[13:37:44.107]                     else if (inherits(cond, "warning")) {
[13:37:44.107]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:44.107]                       if (muffled) 
[13:37:44.107]                         invokeRestart("muffleWarning")
[13:37:44.107]                     }
[13:37:44.107]                     else if (inherits(cond, "condition")) {
[13:37:44.107]                       if (!is.null(pattern)) {
[13:37:44.107]                         computeRestarts <- base::computeRestarts
[13:37:44.107]                         grepl <- base::grepl
[13:37:44.107]                         restarts <- computeRestarts(cond)
[13:37:44.107]                         for (restart in restarts) {
[13:37:44.107]                           name <- restart$name
[13:37:44.107]                           if (is.null(name)) 
[13:37:44.107]                             next
[13:37:44.107]                           if (!grepl(pattern, name)) 
[13:37:44.107]                             next
[13:37:44.107]                           invokeRestart(restart)
[13:37:44.107]                           muffled <- TRUE
[13:37:44.107]                           break
[13:37:44.107]                         }
[13:37:44.107]                       }
[13:37:44.107]                     }
[13:37:44.107]                     invisible(muffled)
[13:37:44.107]                   }
[13:37:44.107]                   muffleCondition(cond)
[13:37:44.107]                 })
[13:37:44.107]             }))
[13:37:44.107]             future::FutureResult(value = ...future.value$value, 
[13:37:44.107]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:44.107]                   ...future.rng), globalenv = if (FALSE) 
[13:37:44.107]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:44.107]                     ...future.globalenv.names))
[13:37:44.107]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:44.107]         }, condition = base::local({
[13:37:44.107]             c <- base::c
[13:37:44.107]             inherits <- base::inherits
[13:37:44.107]             invokeRestart <- base::invokeRestart
[13:37:44.107]             length <- base::length
[13:37:44.107]             list <- base::list
[13:37:44.107]             seq.int <- base::seq.int
[13:37:44.107]             signalCondition <- base::signalCondition
[13:37:44.107]             sys.calls <- base::sys.calls
[13:37:44.107]             `[[` <- base::`[[`
[13:37:44.107]             `+` <- base::`+`
[13:37:44.107]             `<<-` <- base::`<<-`
[13:37:44.107]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:44.107]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:44.107]                   3L)]
[13:37:44.107]             }
[13:37:44.107]             function(cond) {
[13:37:44.107]                 is_error <- inherits(cond, "error")
[13:37:44.107]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:44.107]                   NULL)
[13:37:44.107]                 if (is_error) {
[13:37:44.107]                   sessionInformation <- function() {
[13:37:44.107]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:44.107]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:44.107]                       search = base::search(), system = base::Sys.info())
[13:37:44.107]                   }
[13:37:44.107]                   ...future.conditions[[length(...future.conditions) + 
[13:37:44.107]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:44.107]                     cond$call), session = sessionInformation(), 
[13:37:44.107]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:44.107]                   signalCondition(cond)
[13:37:44.107]                 }
[13:37:44.107]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:44.107]                 "immediateCondition"))) {
[13:37:44.107]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:44.107]                   ...future.conditions[[length(...future.conditions) + 
[13:37:44.107]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:44.107]                   if (TRUE && !signal) {
[13:37:44.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:44.107]                     {
[13:37:44.107]                       inherits <- base::inherits
[13:37:44.107]                       invokeRestart <- base::invokeRestart
[13:37:44.107]                       is.null <- base::is.null
[13:37:44.107]                       muffled <- FALSE
[13:37:44.107]                       if (inherits(cond, "message")) {
[13:37:44.107]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:44.107]                         if (muffled) 
[13:37:44.107]                           invokeRestart("muffleMessage")
[13:37:44.107]                       }
[13:37:44.107]                       else if (inherits(cond, "warning")) {
[13:37:44.107]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:44.107]                         if (muffled) 
[13:37:44.107]                           invokeRestart("muffleWarning")
[13:37:44.107]                       }
[13:37:44.107]                       else if (inherits(cond, "condition")) {
[13:37:44.107]                         if (!is.null(pattern)) {
[13:37:44.107]                           computeRestarts <- base::computeRestarts
[13:37:44.107]                           grepl <- base::grepl
[13:37:44.107]                           restarts <- computeRestarts(cond)
[13:37:44.107]                           for (restart in restarts) {
[13:37:44.107]                             name <- restart$name
[13:37:44.107]                             if (is.null(name)) 
[13:37:44.107]                               next
[13:37:44.107]                             if (!grepl(pattern, name)) 
[13:37:44.107]                               next
[13:37:44.107]                             invokeRestart(restart)
[13:37:44.107]                             muffled <- TRUE
[13:37:44.107]                             break
[13:37:44.107]                           }
[13:37:44.107]                         }
[13:37:44.107]                       }
[13:37:44.107]                       invisible(muffled)
[13:37:44.107]                     }
[13:37:44.107]                     muffleCondition(cond, pattern = "^muffle")
[13:37:44.107]                   }
[13:37:44.107]                 }
[13:37:44.107]                 else {
[13:37:44.107]                   if (TRUE) {
[13:37:44.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:44.107]                     {
[13:37:44.107]                       inherits <- base::inherits
[13:37:44.107]                       invokeRestart <- base::invokeRestart
[13:37:44.107]                       is.null <- base::is.null
[13:37:44.107]                       muffled <- FALSE
[13:37:44.107]                       if (inherits(cond, "message")) {
[13:37:44.107]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:44.107]                         if (muffled) 
[13:37:44.107]                           invokeRestart("muffleMessage")
[13:37:44.107]                       }
[13:37:44.107]                       else if (inherits(cond, "warning")) {
[13:37:44.107]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:44.107]                         if (muffled) 
[13:37:44.107]                           invokeRestart("muffleWarning")
[13:37:44.107]                       }
[13:37:44.107]                       else if (inherits(cond, "condition")) {
[13:37:44.107]                         if (!is.null(pattern)) {
[13:37:44.107]                           computeRestarts <- base::computeRestarts
[13:37:44.107]                           grepl <- base::grepl
[13:37:44.107]                           restarts <- computeRestarts(cond)
[13:37:44.107]                           for (restart in restarts) {
[13:37:44.107]                             name <- restart$name
[13:37:44.107]                             if (is.null(name)) 
[13:37:44.107]                               next
[13:37:44.107]                             if (!grepl(pattern, name)) 
[13:37:44.107]                               next
[13:37:44.107]                             invokeRestart(restart)
[13:37:44.107]                             muffled <- TRUE
[13:37:44.107]                             break
[13:37:44.107]                           }
[13:37:44.107]                         }
[13:37:44.107]                       }
[13:37:44.107]                       invisible(muffled)
[13:37:44.107]                     }
[13:37:44.107]                     muffleCondition(cond, pattern = "^muffle")
[13:37:44.107]                   }
[13:37:44.107]                 }
[13:37:44.107]             }
[13:37:44.107]         }))
[13:37:44.107]     }, error = function(ex) {
[13:37:44.107]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:44.107]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:44.107]                 ...future.rng), started = ...future.startTime, 
[13:37:44.107]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:44.107]             version = "1.8"), class = "FutureResult")
[13:37:44.107]     }, finally = {
[13:37:44.107]         if (!identical(...future.workdir, getwd())) 
[13:37:44.107]             setwd(...future.workdir)
[13:37:44.107]         {
[13:37:44.107]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:44.107]                 ...future.oldOptions$nwarnings <- NULL
[13:37:44.107]             }
[13:37:44.107]             base::options(...future.oldOptions)
[13:37:44.107]             if (.Platform$OS.type == "windows") {
[13:37:44.107]                 old_names <- names(...future.oldEnvVars)
[13:37:44.107]                 envs <- base::Sys.getenv()
[13:37:44.107]                 names <- names(envs)
[13:37:44.107]                 common <- intersect(names, old_names)
[13:37:44.107]                 added <- setdiff(names, old_names)
[13:37:44.107]                 removed <- setdiff(old_names, names)
[13:37:44.107]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:44.107]                   envs[common]]
[13:37:44.107]                 NAMES <- toupper(changed)
[13:37:44.107]                 args <- list()
[13:37:44.107]                 for (kk in seq_along(NAMES)) {
[13:37:44.107]                   name <- changed[[kk]]
[13:37:44.107]                   NAME <- NAMES[[kk]]
[13:37:44.107]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:44.107]                     next
[13:37:44.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:44.107]                 }
[13:37:44.107]                 NAMES <- toupper(added)
[13:37:44.107]                 for (kk in seq_along(NAMES)) {
[13:37:44.107]                   name <- added[[kk]]
[13:37:44.107]                   NAME <- NAMES[[kk]]
[13:37:44.107]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:44.107]                     next
[13:37:44.107]                   args[[name]] <- ""
[13:37:44.107]                 }
[13:37:44.107]                 NAMES <- toupper(removed)
[13:37:44.107]                 for (kk in seq_along(NAMES)) {
[13:37:44.107]                   name <- removed[[kk]]
[13:37:44.107]                   NAME <- NAMES[[kk]]
[13:37:44.107]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:44.107]                     next
[13:37:44.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:44.107]                 }
[13:37:44.107]                 if (length(args) > 0) 
[13:37:44.107]                   base::do.call(base::Sys.setenv, args = args)
[13:37:44.107]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:44.107]             }
[13:37:44.107]             else {
[13:37:44.107]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:44.107]             }
[13:37:44.107]             {
[13:37:44.107]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:44.107]                   0L) {
[13:37:44.107]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:44.107]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:44.107]                   base::options(opts)
[13:37:44.107]                 }
[13:37:44.107]                 {
[13:37:44.107]                   {
[13:37:44.107]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:44.107]                     NULL
[13:37:44.107]                   }
[13:37:44.107]                   options(future.plan = NULL)
[13:37:44.107]                   if (is.na(NA_character_)) 
[13:37:44.107]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:44.107]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:44.107]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:44.107]                     .init = FALSE)
[13:37:44.107]                 }
[13:37:44.107]             }
[13:37:44.107]         }
[13:37:44.107]     })
[13:37:44.107]     if (TRUE) {
[13:37:44.107]         base::sink(type = "output", split = FALSE)
[13:37:44.107]         if (TRUE) {
[13:37:44.107]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:44.107]         }
[13:37:44.107]         else {
[13:37:44.107]             ...future.result["stdout"] <- base::list(NULL)
[13:37:44.107]         }
[13:37:44.107]         base::close(...future.stdout)
[13:37:44.107]         ...future.stdout <- NULL
[13:37:44.107]     }
[13:37:44.107]     ...future.result$conditions <- ...future.conditions
[13:37:44.107]     ...future.result$finished <- base::Sys.time()
[13:37:44.107]     ...future.result
[13:37:44.107] }
[13:37:44.111] requestCore(): workers = 2
[13:37:44.111] Poll #1 (0): usedCores() = 2, workers = 2
[13:37:44.122] result() for MulticoreFuture ...
[13:37:44.123] result() for MulticoreFuture ...
[13:37:44.123] result() for MulticoreFuture ... done
[13:37:44.124] result() for MulticoreFuture ... done
[13:37:44.124] result() for MulticoreFuture ...
[13:37:44.124] result() for MulticoreFuture ... done
[13:37:44.127] MulticoreFuture started
[13:37:44.127] - Launch lazy future ... done
[13:37:44.127] run() for ‘MulticoreFuture’ ... done
[13:37:44.128] plan(): Setting new future strategy stack:
[13:37:44.128] resolve() on list ...
[13:37:44.129]  recursive: 0
[13:37:44.129]  length: 1
[13:37:44.129] 
[13:37:44.129] List of future strategies:
[13:37:44.129] 1. sequential:
[13:37:44.129]    - args: function (..., envir = parent.frame())
[13:37:44.129]    - tweaked: FALSE
[13:37:44.129]    - call: NULL
[13:37:44.130] Future #1
[13:37:44.130] plan(): nbrOfWorkers() = 1
[13:37:44.130]  length: 0 (resolved future 1)
[13:37:44.131] resolve() on list ... DONE
[13:37:44.131] resolve() on list ...
[13:37:44.132]  recursive: 0
[13:37:44.132]  length: 1
[13:37:44.132] 
[13:37:44.634] plan(): Setting new future strategy stack:
[13:37:44.634] List of future strategies:
[13:37:44.634] 1. multicore:
[13:37:44.634]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:37:44.634]    - tweaked: FALSE
[13:37:44.634]    - call: plan(strategy)
[13:37:44.639] plan(): nbrOfWorkers() = 2
[13:37:44.646] Future #1
[13:37:44.646]  length: 0 (resolved future 1)
[13:37:44.646] resolve() on list ... DONE
[13:37:44.647] resolve() on list ...
[13:37:44.647]  recursive: 0
[13:37:44.647]  length: 1
[13:37:44.647] 
[13:37:44.647]  length: 0 (resolved future 1)
[13:37:44.647] resolve() on list ... DONE
[13:37:44.648] resolve() on list ...
[13:37:44.648]  recursive: 0
[13:37:44.648]  length: 4
[13:37:44.648] 
[13:37:44.649] Future #1
[13:37:44.649]  length: 3 (resolved future 1)
[13:37:44.649] Future #2
[13:37:44.649]  length: 2 (resolved future 2)
[13:37:44.649]  length: 1 (resolved future 3)
[13:37:44.649]  length: 0 (resolved future 4)
[13:37:44.650] resolve() on list ... DONE
[13:37:44.650] resolve() on list ...
[13:37:44.650]  recursive: 0
[13:37:44.650]  length: 4
[13:37:44.650] 
[13:37:44.651] Future #1
[13:37:44.651]  length: 3 (resolved future 1)
[13:37:44.651] Future #2
[13:37:44.651]  length: 2 (resolved future 2)
[13:37:44.651]  length: 1 (resolved future 3)
[13:37:44.652]  length: 0 (resolved future 4)
[13:37:44.652] resolve() on list ... DONE
[13:37:44.652] resolve() on list ...
[13:37:44.652]  recursive: 0
[13:37:44.652]  length: 1
[13:37:44.653] 
[13:37:44.653]  length: 0 (resolved future 1)
[13:37:44.653] resolve() on list ... DONE
[13:37:44.653] getGlobalsAndPackages() ...
[13:37:44.653] Searching for globals...
[13:37:44.655] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:37:44.655] Searching for globals ... DONE
[13:37:44.656] Resolving globals: FALSE
[13:37:44.656] The total size of the 1 globals is 56 bytes (56 bytes)
[13:37:44.657] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:37:44.657] - globals: [1] ‘kk’
[13:37:44.657] 
[13:37:44.657] getGlobalsAndPackages() ... DONE
[13:37:44.658] run() for ‘Future’ ...
[13:37:44.658] - state: ‘created’
[13:37:44.658] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:37:44.667] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:44.668] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:37:44.668]   - Field: ‘label’
[13:37:44.668]   - Field: ‘local’
[13:37:44.669]   - Field: ‘owner’
[13:37:44.669]   - Field: ‘envir’
[13:37:44.669]   - Field: ‘workers’
[13:37:44.669]   - Field: ‘packages’
[13:37:44.670]   - Field: ‘gc’
[13:37:44.670]   - Field: ‘job’
[13:37:44.670]   - Field: ‘conditions’
[13:37:44.670]   - Field: ‘expr’
[13:37:44.671]   - Field: ‘uuid’
[13:37:44.671]   - Field: ‘seed’
[13:37:44.671]   - Field: ‘version’
[13:37:44.671]   - Field: ‘result’
[13:37:44.671]   - Field: ‘asynchronous’
[13:37:44.671]   - Field: ‘calls’
[13:37:44.672]   - Field: ‘globals’
[13:37:44.672]   - Field: ‘stdout’
[13:37:44.672]   - Field: ‘earlySignal’
[13:37:44.672]   - Field: ‘lazy’
[13:37:44.672]   - Field: ‘state’
[13:37:44.672] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:37:44.673] - Launch lazy future ...
[13:37:44.673] Packages needed by the future expression (n = 0): <none>
[13:37:44.673] Packages needed by future strategies (n = 0): <none>
[13:37:44.674] {
[13:37:44.674]     {
[13:37:44.674]         {
[13:37:44.674]             ...future.startTime <- base::Sys.time()
[13:37:44.674]             {
[13:37:44.674]                 {
[13:37:44.674]                   {
[13:37:44.674]                     {
[13:37:44.674]                       base::local({
[13:37:44.674]                         has_future <- base::requireNamespace("future", 
[13:37:44.674]                           quietly = TRUE)
[13:37:44.674]                         if (has_future) {
[13:37:44.674]                           ns <- base::getNamespace("future")
[13:37:44.674]                           version <- ns[[".package"]][["version"]]
[13:37:44.674]                           if (is.null(version)) 
[13:37:44.674]                             version <- utils::packageVersion("future")
[13:37:44.674]                         }
[13:37:44.674]                         else {
[13:37:44.674]                           version <- NULL
[13:37:44.674]                         }
[13:37:44.674]                         if (!has_future || version < "1.8.0") {
[13:37:44.674]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:44.674]                             "", base::R.version$version.string), 
[13:37:44.674]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:44.674]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:44.674]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:44.674]                               "release", "version")], collapse = " "), 
[13:37:44.674]                             hostname = base::Sys.info()[["nodename"]])
[13:37:44.674]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:44.674]                             info)
[13:37:44.674]                           info <- base::paste(info, collapse = "; ")
[13:37:44.674]                           if (!has_future) {
[13:37:44.674]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:44.674]                               info)
[13:37:44.674]                           }
[13:37:44.674]                           else {
[13:37:44.674]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:44.674]                               info, version)
[13:37:44.674]                           }
[13:37:44.674]                           base::stop(msg)
[13:37:44.674]                         }
[13:37:44.674]                       })
[13:37:44.674]                     }
[13:37:44.674]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:44.674]                     base::options(mc.cores = 1L)
[13:37:44.674]                   }
[13:37:44.674]                   ...future.strategy.old <- future::plan("list")
[13:37:44.674]                   options(future.plan = NULL)
[13:37:44.674]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:44.674]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:44.674]                 }
[13:37:44.674]                 ...future.workdir <- getwd()
[13:37:44.674]             }
[13:37:44.674]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:44.674]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:44.674]         }
[13:37:44.674]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:44.674]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:44.674]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:44.674]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:44.674]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:44.674]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:44.674]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:44.674]             base::names(...future.oldOptions))
[13:37:44.674]     }
[13:37:44.674]     if (FALSE) {
[13:37:44.674]     }
[13:37:44.674]     else {
[13:37:44.674]         if (TRUE) {
[13:37:44.674]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:44.674]                 open = "w")
[13:37:44.674]         }
[13:37:44.674]         else {
[13:37:44.674]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:44.674]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:44.674]         }
[13:37:44.674]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:44.674]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:44.674]             base::sink(type = "output", split = FALSE)
[13:37:44.674]             base::close(...future.stdout)
[13:37:44.674]         }, add = TRUE)
[13:37:44.674]     }
[13:37:44.674]     ...future.frame <- base::sys.nframe()
[13:37:44.674]     ...future.conditions <- base::list()
[13:37:44.674]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:44.674]     if (FALSE) {
[13:37:44.674]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:44.674]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:44.674]     }
[13:37:44.674]     ...future.result <- base::tryCatch({
[13:37:44.674]         base::withCallingHandlers({
[13:37:44.674]             ...future.value <- base::withVisible(base::local({
[13:37:44.674]                 withCallingHandlers({
[13:37:44.674]                   {
[13:37:44.674]                     Sys.sleep(0.1)
[13:37:44.674]                     kk
[13:37:44.674]                   }
[13:37:44.674]                 }, immediateCondition = function(cond) {
[13:37:44.674]                   save_rds <- function (object, pathname, ...) 
[13:37:44.674]                   {
[13:37:44.674]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:37:44.674]                     if (file_test("-f", pathname_tmp)) {
[13:37:44.674]                       fi_tmp <- file.info(pathname_tmp)
[13:37:44.674]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:37:44.674]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:44.674]                         fi_tmp[["mtime"]])
[13:37:44.674]                     }
[13:37:44.674]                     tryCatch({
[13:37:44.674]                       saveRDS(object, file = pathname_tmp, ...)
[13:37:44.674]                     }, error = function(ex) {
[13:37:44.674]                       msg <- conditionMessage(ex)
[13:37:44.674]                       fi_tmp <- file.info(pathname_tmp)
[13:37:44.674]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:37:44.674]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:44.674]                         fi_tmp[["mtime"]], msg)
[13:37:44.674]                       ex$message <- msg
[13:37:44.674]                       stop(ex)
[13:37:44.674]                     })
[13:37:44.674]                     stopifnot(file_test("-f", pathname_tmp))
[13:37:44.674]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:37:44.674]                     if (!res || file_test("-f", pathname_tmp)) {
[13:37:44.674]                       fi_tmp <- file.info(pathname_tmp)
[13:37:44.674]                       fi <- file.info(pathname)
[13:37:44.674]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:37:44.674]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:44.674]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:37:44.674]                         fi[["size"]], fi[["mtime"]])
[13:37:44.674]                       stop(msg)
[13:37:44.674]                     }
[13:37:44.674]                     invisible(pathname)
[13:37:44.674]                   }
[13:37:44.674]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:37:44.674]                     rootPath = tempdir()) 
[13:37:44.674]                   {
[13:37:44.674]                     obj <- list(time = Sys.time(), condition = cond)
[13:37:44.674]                     file <- tempfile(pattern = class(cond)[1], 
[13:37:44.674]                       tmpdir = path, fileext = ".rds")
[13:37:44.674]                     save_rds(obj, file)
[13:37:44.674]                   }
[13:37:44.674]                   saveImmediateCondition(cond, path = "/tmp/RtmpLAMaHJ/.future/immediateConditions")
[13:37:44.674]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:44.674]                   {
[13:37:44.674]                     inherits <- base::inherits
[13:37:44.674]                     invokeRestart <- base::invokeRestart
[13:37:44.674]                     is.null <- base::is.null
[13:37:44.674]                     muffled <- FALSE
[13:37:44.674]                     if (inherits(cond, "message")) {
[13:37:44.674]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:44.674]                       if (muffled) 
[13:37:44.674]                         invokeRestart("muffleMessage")
[13:37:44.674]                     }
[13:37:44.674]                     else if (inherits(cond, "warning")) {
[13:37:44.674]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:44.674]                       if (muffled) 
[13:37:44.674]                         invokeRestart("muffleWarning")
[13:37:44.674]                     }
[13:37:44.674]                     else if (inherits(cond, "condition")) {
[13:37:44.674]                       if (!is.null(pattern)) {
[13:37:44.674]                         computeRestarts <- base::computeRestarts
[13:37:44.674]                         grepl <- base::grepl
[13:37:44.674]                         restarts <- computeRestarts(cond)
[13:37:44.674]                         for (restart in restarts) {
[13:37:44.674]                           name <- restart$name
[13:37:44.674]                           if (is.null(name)) 
[13:37:44.674]                             next
[13:37:44.674]                           if (!grepl(pattern, name)) 
[13:37:44.674]                             next
[13:37:44.674]                           invokeRestart(restart)
[13:37:44.674]                           muffled <- TRUE
[13:37:44.674]                           break
[13:37:44.674]                         }
[13:37:44.674]                       }
[13:37:44.674]                     }
[13:37:44.674]                     invisible(muffled)
[13:37:44.674]                   }
[13:37:44.674]                   muffleCondition(cond)
[13:37:44.674]                 })
[13:37:44.674]             }))
[13:37:44.674]             future::FutureResult(value = ...future.value$value, 
[13:37:44.674]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:44.674]                   ...future.rng), globalenv = if (FALSE) 
[13:37:44.674]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:44.674]                     ...future.globalenv.names))
[13:37:44.674]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:44.674]         }, condition = base::local({
[13:37:44.674]             c <- base::c
[13:37:44.674]             inherits <- base::inherits
[13:37:44.674]             invokeRestart <- base::invokeRestart
[13:37:44.674]             length <- base::length
[13:37:44.674]             list <- base::list
[13:37:44.674]             seq.int <- base::seq.int
[13:37:44.674]             signalCondition <- base::signalCondition
[13:37:44.674]             sys.calls <- base::sys.calls
[13:37:44.674]             `[[` <- base::`[[`
[13:37:44.674]             `+` <- base::`+`
[13:37:44.674]             `<<-` <- base::`<<-`
[13:37:44.674]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:44.674]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:44.674]                   3L)]
[13:37:44.674]             }
[13:37:44.674]             function(cond) {
[13:37:44.674]                 is_error <- inherits(cond, "error")
[13:37:44.674]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:44.674]                   NULL)
[13:37:44.674]                 if (is_error) {
[13:37:44.674]                   sessionInformation <- function() {
[13:37:44.674]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:44.674]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:44.674]                       search = base::search(), system = base::Sys.info())
[13:37:44.674]                   }
[13:37:44.674]                   ...future.conditions[[length(...future.conditions) + 
[13:37:44.674]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:44.674]                     cond$call), session = sessionInformation(), 
[13:37:44.674]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:44.674]                   signalCondition(cond)
[13:37:44.674]                 }
[13:37:44.674]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:44.674]                 "immediateCondition"))) {
[13:37:44.674]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:44.674]                   ...future.conditions[[length(...future.conditions) + 
[13:37:44.674]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:44.674]                   if (TRUE && !signal) {
[13:37:44.674]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:44.674]                     {
[13:37:44.674]                       inherits <- base::inherits
[13:37:44.674]                       invokeRestart <- base::invokeRestart
[13:37:44.674]                       is.null <- base::is.null
[13:37:44.674]                       muffled <- FALSE
[13:37:44.674]                       if (inherits(cond, "message")) {
[13:37:44.674]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:44.674]                         if (muffled) 
[13:37:44.674]                           invokeRestart("muffleMessage")
[13:37:44.674]                       }
[13:37:44.674]                       else if (inherits(cond, "warning")) {
[13:37:44.674]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:44.674]                         if (muffled) 
[13:37:44.674]                           invokeRestart("muffleWarning")
[13:37:44.674]                       }
[13:37:44.674]                       else if (inherits(cond, "condition")) {
[13:37:44.674]                         if (!is.null(pattern)) {
[13:37:44.674]                           computeRestarts <- base::computeRestarts
[13:37:44.674]                           grepl <- base::grepl
[13:37:44.674]                           restarts <- computeRestarts(cond)
[13:37:44.674]                           for (restart in restarts) {
[13:37:44.674]                             name <- restart$name
[13:37:44.674]                             if (is.null(name)) 
[13:37:44.674]                               next
[13:37:44.674]                             if (!grepl(pattern, name)) 
[13:37:44.674]                               next
[13:37:44.674]                             invokeRestart(restart)
[13:37:44.674]                             muffled <- TRUE
[13:37:44.674]                             break
[13:37:44.674]                           }
[13:37:44.674]                         }
[13:37:44.674]                       }
[13:37:44.674]                       invisible(muffled)
[13:37:44.674]                     }
[13:37:44.674]                     muffleCondition(cond, pattern = "^muffle")
[13:37:44.674]                   }
[13:37:44.674]                 }
[13:37:44.674]                 else {
[13:37:44.674]                   if (TRUE) {
[13:37:44.674]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:44.674]                     {
[13:37:44.674]                       inherits <- base::inherits
[13:37:44.674]                       invokeRestart <- base::invokeRestart
[13:37:44.674]                       is.null <- base::is.null
[13:37:44.674]                       muffled <- FALSE
[13:37:44.674]                       if (inherits(cond, "message")) {
[13:37:44.674]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:44.674]                         if (muffled) 
[13:37:44.674]                           invokeRestart("muffleMessage")
[13:37:44.674]                       }
[13:37:44.674]                       else if (inherits(cond, "warning")) {
[13:37:44.674]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:44.674]                         if (muffled) 
[13:37:44.674]                           invokeRestart("muffleWarning")
[13:37:44.674]                       }
[13:37:44.674]                       else if (inherits(cond, "condition")) {
[13:37:44.674]                         if (!is.null(pattern)) {
[13:37:44.674]                           computeRestarts <- base::computeRestarts
[13:37:44.674]                           grepl <- base::grepl
[13:37:44.674]                           restarts <- computeRestarts(cond)
[13:37:44.674]                           for (restart in restarts) {
[13:37:44.674]                             name <- restart$name
[13:37:44.674]                             if (is.null(name)) 
[13:37:44.674]                               next
[13:37:44.674]                             if (!grepl(pattern, name)) 
[13:37:44.674]                               next
[13:37:44.674]                             invokeRestart(restart)
[13:37:44.674]                             muffled <- TRUE
[13:37:44.674]                             break
[13:37:44.674]                           }
[13:37:44.674]                         }
[13:37:44.674]                       }
[13:37:44.674]                       invisible(muffled)
[13:37:44.674]                     }
[13:37:44.674]                     muffleCondition(cond, pattern = "^muffle")
[13:37:44.674]                   }
[13:37:44.674]                 }
[13:37:44.674]             }
[13:37:44.674]         }))
[13:37:44.674]     }, error = function(ex) {
[13:37:44.674]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:44.674]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:44.674]                 ...future.rng), started = ...future.startTime, 
[13:37:44.674]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:44.674]             version = "1.8"), class = "FutureResult")
[13:37:44.674]     }, finally = {
[13:37:44.674]         if (!identical(...future.workdir, getwd())) 
[13:37:44.674]             setwd(...future.workdir)
[13:37:44.674]         {
[13:37:44.674]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:44.674]                 ...future.oldOptions$nwarnings <- NULL
[13:37:44.674]             }
[13:37:44.674]             base::options(...future.oldOptions)
[13:37:44.674]             if (.Platform$OS.type == "windows") {
[13:37:44.674]                 old_names <- names(...future.oldEnvVars)
[13:37:44.674]                 envs <- base::Sys.getenv()
[13:37:44.674]                 names <- names(envs)
[13:37:44.674]                 common <- intersect(names, old_names)
[13:37:44.674]                 added <- setdiff(names, old_names)
[13:37:44.674]                 removed <- setdiff(old_names, names)
[13:37:44.674]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:44.674]                   envs[common]]
[13:37:44.674]                 NAMES <- toupper(changed)
[13:37:44.674]                 args <- list()
[13:37:44.674]                 for (kk in seq_along(NAMES)) {
[13:37:44.674]                   name <- changed[[kk]]
[13:37:44.674]                   NAME <- NAMES[[kk]]
[13:37:44.674]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:44.674]                     next
[13:37:44.674]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:44.674]                 }
[13:37:44.674]                 NAMES <- toupper(added)
[13:37:44.674]                 for (kk in seq_along(NAMES)) {
[13:37:44.674]                   name <- added[[kk]]
[13:37:44.674]                   NAME <- NAMES[[kk]]
[13:37:44.674]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:44.674]                     next
[13:37:44.674]                   args[[name]] <- ""
[13:37:44.674]                 }
[13:37:44.674]                 NAMES <- toupper(removed)
[13:37:44.674]                 for (kk in seq_along(NAMES)) {
[13:37:44.674]                   name <- removed[[kk]]
[13:37:44.674]                   NAME <- NAMES[[kk]]
[13:37:44.674]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:44.674]                     next
[13:37:44.674]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:44.674]                 }
[13:37:44.674]                 if (length(args) > 0) 
[13:37:44.674]                   base::do.call(base::Sys.setenv, args = args)
[13:37:44.674]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:44.674]             }
[13:37:44.674]             else {
[13:37:44.674]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:44.674]             }
[13:37:44.674]             {
[13:37:44.674]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:44.674]                   0L) {
[13:37:44.674]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:44.674]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:44.674]                   base::options(opts)
[13:37:44.674]                 }
[13:37:44.674]                 {
[13:37:44.674]                   {
[13:37:44.674]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:44.674]                     NULL
[13:37:44.674]                   }
[13:37:44.674]                   options(future.plan = NULL)
[13:37:44.674]                   if (is.na(NA_character_)) 
[13:37:44.674]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:44.674]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:44.674]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:44.674]                     .init = FALSE)
[13:37:44.674]                 }
[13:37:44.674]             }
[13:37:44.674]         }
[13:37:44.674]     })
[13:37:44.674]     if (TRUE) {
[13:37:44.674]         base::sink(type = "output", split = FALSE)
[13:37:44.674]         if (TRUE) {
[13:37:44.674]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:44.674]         }
[13:37:44.674]         else {
[13:37:44.674]             ...future.result["stdout"] <- base::list(NULL)
[13:37:44.674]         }
[13:37:44.674]         base::close(...future.stdout)
[13:37:44.674]         ...future.stdout <- NULL
[13:37:44.674]     }
[13:37:44.674]     ...future.result$conditions <- ...future.conditions
[13:37:44.674]     ...future.result$finished <- base::Sys.time()
[13:37:44.674]     ...future.result
[13:37:44.674] }
[13:37:44.677] assign_globals() ...
[13:37:44.677] List of 1
[13:37:44.677]  $ kk: int 1
[13:37:44.677]  - attr(*, "where")=List of 1
[13:37:44.677]   ..$ kk:<environment: R_EmptyEnv> 
[13:37:44.677]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:37:44.677]  - attr(*, "resolved")= logi FALSE
[13:37:44.677]  - attr(*, "total_size")= num 56
[13:37:44.677]  - attr(*, "already-done")= logi TRUE
[13:37:44.682] - copied ‘kk’ to environment
[13:37:44.682] assign_globals() ... done
[13:37:44.682] requestCore(): workers = 2
[13:37:44.682] Poll #1 (0): usedCores() = 2, workers = 2
[13:37:44.693] result() for MulticoreFuture ...
[13:37:44.694] result() for MulticoreFuture ...
[13:37:44.694] result() for MulticoreFuture ... done
[13:37:44.694] result() for MulticoreFuture ... done
[13:37:44.694] result() for MulticoreFuture ...
[13:37:44.695] result() for MulticoreFuture ... done
[13:37:44.697] MulticoreFuture started
[13:37:44.698] - Launch lazy future ... done
[13:37:44.698] run() for ‘MulticoreFuture’ ... done
[13:37:44.698] getGlobalsAndPackages() ...
[13:37:44.699] Searching for globals...
[13:37:44.699] plan(): Setting new future strategy stack:
[13:37:44.699] List of future strategies:
[13:37:44.699] 1. sequential:
[13:37:44.699]    - args: function (..., envir = parent.frame())
[13:37:44.699]    - tweaked: FALSE
[13:37:44.699]    - call: NULL
[13:37:44.700] plan(): nbrOfWorkers() = 1
[13:37:44.702] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:37:44.703] Searching for globals ... DONE
[13:37:44.703] Resolving globals: FALSE
[13:37:44.704] The total size of the 1 globals is 56 bytes (56 bytes)
[13:37:44.704] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:37:44.705] - globals: [1] ‘kk’
[13:37:44.705] 
[13:37:44.705] getGlobalsAndPackages() ... DONE
[13:37:44.706] run() for ‘Future’ ...
[13:37:44.706] - state: ‘created’
[13:37:44.706] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:37:44.711] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:44.712] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:37:44.712]   - Field: ‘label’
[13:37:44.712]   - Field: ‘local’
[13:37:44.712]   - Field: ‘owner’
[13:37:44.712]   - Field: ‘envir’
[13:37:44.712]   - Field: ‘workers’
[13:37:44.713]   - Field: ‘packages’
[13:37:44.713]   - Field: ‘gc’
[13:37:44.713]   - Field: ‘job’
[13:37:44.713]   - Field: ‘conditions’
[13:37:44.713]   - Field: ‘expr’
[13:37:44.713]   - Field: ‘uuid’
[13:37:44.714]   - Field: ‘seed’
[13:37:44.714]   - Field: ‘version’
[13:37:44.714]   - Field: ‘result’
[13:37:44.714]   - Field: ‘asynchronous’
[13:37:44.714]   - Field: ‘calls’
[13:37:44.714]   - Field: ‘globals’
[13:37:44.714]   - Field: ‘stdout’
[13:37:44.715]   - Field: ‘earlySignal’
[13:37:44.715]   - Field: ‘lazy’
[13:37:44.715]   - Field: ‘state’
[13:37:44.715] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:37:44.715] - Launch lazy future ...
[13:37:44.716] Packages needed by the future expression (n = 0): <none>
[13:37:44.716] Packages needed by future strategies (n = 0): <none>
[13:37:44.716] {
[13:37:44.716]     {
[13:37:44.716]         {
[13:37:44.716]             ...future.startTime <- base::Sys.time()
[13:37:44.716]             {
[13:37:44.716]                 {
[13:37:44.716]                   {
[13:37:44.716]                     {
[13:37:44.716]                       base::local({
[13:37:44.716]                         has_future <- base::requireNamespace("future", 
[13:37:44.716]                           quietly = TRUE)
[13:37:44.716]                         if (has_future) {
[13:37:44.716]                           ns <- base::getNamespace("future")
[13:37:44.716]                           version <- ns[[".package"]][["version"]]
[13:37:44.716]                           if (is.null(version)) 
[13:37:44.716]                             version <- utils::packageVersion("future")
[13:37:44.716]                         }
[13:37:44.716]                         else {
[13:37:44.716]                           version <- NULL
[13:37:44.716]                         }
[13:37:44.716]                         if (!has_future || version < "1.8.0") {
[13:37:44.716]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:44.716]                             "", base::R.version$version.string), 
[13:37:44.716]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:44.716]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:44.716]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:44.716]                               "release", "version")], collapse = " "), 
[13:37:44.716]                             hostname = base::Sys.info()[["nodename"]])
[13:37:44.716]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:44.716]                             info)
[13:37:44.716]                           info <- base::paste(info, collapse = "; ")
[13:37:44.716]                           if (!has_future) {
[13:37:44.716]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:44.716]                               info)
[13:37:44.716]                           }
[13:37:44.716]                           else {
[13:37:44.716]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:44.716]                               info, version)
[13:37:44.716]                           }
[13:37:44.716]                           base::stop(msg)
[13:37:44.716]                         }
[13:37:44.716]                       })
[13:37:44.716]                     }
[13:37:44.716]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:44.716]                     base::options(mc.cores = 1L)
[13:37:44.716]                   }
[13:37:44.716]                   ...future.strategy.old <- future::plan("list")
[13:37:44.716]                   options(future.plan = NULL)
[13:37:44.716]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:44.716]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:44.716]                 }
[13:37:44.716]                 ...future.workdir <- getwd()
[13:37:44.716]             }
[13:37:44.716]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:44.716]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:44.716]         }
[13:37:44.716]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:44.716]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:44.716]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:44.716]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:44.716]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:44.716]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:44.716]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:44.716]             base::names(...future.oldOptions))
[13:37:44.716]     }
[13:37:44.716]     if (FALSE) {
[13:37:44.716]     }
[13:37:44.716]     else {
[13:37:44.716]         if (TRUE) {
[13:37:44.716]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:44.716]                 open = "w")
[13:37:44.716]         }
[13:37:44.716]         else {
[13:37:44.716]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:44.716]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:44.716]         }
[13:37:44.716]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:44.716]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:44.716]             base::sink(type = "output", split = FALSE)
[13:37:44.716]             base::close(...future.stdout)
[13:37:44.716]         }, add = TRUE)
[13:37:44.716]     }
[13:37:44.716]     ...future.frame <- base::sys.nframe()
[13:37:44.716]     ...future.conditions <- base::list()
[13:37:44.716]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:44.716]     if (FALSE) {
[13:37:44.716]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:44.716]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:44.716]     }
[13:37:44.716]     ...future.result <- base::tryCatch({
[13:37:44.716]         base::withCallingHandlers({
[13:37:44.716]             ...future.value <- base::withVisible(base::local({
[13:37:44.716]                 withCallingHandlers({
[13:37:44.716]                   {
[13:37:44.716]                     Sys.sleep(0.1)
[13:37:44.716]                     kk
[13:37:44.716]                   }
[13:37:44.716]                 }, immediateCondition = function(cond) {
[13:37:44.716]                   save_rds <- function (object, pathname, ...) 
[13:37:44.716]                   {
[13:37:44.716]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:37:44.716]                     if (file_test("-f", pathname_tmp)) {
[13:37:44.716]                       fi_tmp <- file.info(pathname_tmp)
[13:37:44.716]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:37:44.716]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:44.716]                         fi_tmp[["mtime"]])
[13:37:44.716]                     }
[13:37:44.716]                     tryCatch({
[13:37:44.716]                       saveRDS(object, file = pathname_tmp, ...)
[13:37:44.716]                     }, error = function(ex) {
[13:37:44.716]                       msg <- conditionMessage(ex)
[13:37:44.716]                       fi_tmp <- file.info(pathname_tmp)
[13:37:44.716]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:37:44.716]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:44.716]                         fi_tmp[["mtime"]], msg)
[13:37:44.716]                       ex$message <- msg
[13:37:44.716]                       stop(ex)
[13:37:44.716]                     })
[13:37:44.716]                     stopifnot(file_test("-f", pathname_tmp))
[13:37:44.716]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:37:44.716]                     if (!res || file_test("-f", pathname_tmp)) {
[13:37:44.716]                       fi_tmp <- file.info(pathname_tmp)
[13:37:44.716]                       fi <- file.info(pathname)
[13:37:44.716]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:37:44.716]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:44.716]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:37:44.716]                         fi[["size"]], fi[["mtime"]])
[13:37:44.716]                       stop(msg)
[13:37:44.716]                     }
[13:37:44.716]                     invisible(pathname)
[13:37:44.716]                   }
[13:37:44.716]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:37:44.716]                     rootPath = tempdir()) 
[13:37:44.716]                   {
[13:37:44.716]                     obj <- list(time = Sys.time(), condition = cond)
[13:37:44.716]                     file <- tempfile(pattern = class(cond)[1], 
[13:37:44.716]                       tmpdir = path, fileext = ".rds")
[13:37:44.716]                     save_rds(obj, file)
[13:37:44.716]                   }
[13:37:44.716]                   saveImmediateCondition(cond, path = "/tmp/RtmpLAMaHJ/.future/immediateConditions")
[13:37:44.716]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:44.716]                   {
[13:37:44.716]                     inherits <- base::inherits
[13:37:44.716]                     invokeRestart <- base::invokeRestart
[13:37:44.716]                     is.null <- base::is.null
[13:37:44.716]                     muffled <- FALSE
[13:37:44.716]                     if (inherits(cond, "message")) {
[13:37:44.716]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:44.716]                       if (muffled) 
[13:37:44.716]                         invokeRestart("muffleMessage")
[13:37:44.716]                     }
[13:37:44.716]                     else if (inherits(cond, "warning")) {
[13:37:44.716]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:44.716]                       if (muffled) 
[13:37:44.716]                         invokeRestart("muffleWarning")
[13:37:44.716]                     }
[13:37:44.716]                     else if (inherits(cond, "condition")) {
[13:37:44.716]                       if (!is.null(pattern)) {
[13:37:44.716]                         computeRestarts <- base::computeRestarts
[13:37:44.716]                         grepl <- base::grepl
[13:37:44.716]                         restarts <- computeRestarts(cond)
[13:37:44.716]                         for (restart in restarts) {
[13:37:44.716]                           name <- restart$name
[13:37:44.716]                           if (is.null(name)) 
[13:37:44.716]                             next
[13:37:44.716]                           if (!grepl(pattern, name)) 
[13:37:44.716]                             next
[13:37:44.716]                           invokeRestart(restart)
[13:37:44.716]                           muffled <- TRUE
[13:37:44.716]                           break
[13:37:44.716]                         }
[13:37:44.716]                       }
[13:37:44.716]                     }
[13:37:44.716]                     invisible(muffled)
[13:37:44.716]                   }
[13:37:44.716]                   muffleCondition(cond)
[13:37:44.716]                 })
[13:37:44.716]             }))
[13:37:44.716]             future::FutureResult(value = ...future.value$value, 
[13:37:44.716]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:44.716]                   ...future.rng), globalenv = if (FALSE) 
[13:37:44.716]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:44.716]                     ...future.globalenv.names))
[13:37:44.716]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:44.716]         }, condition = base::local({
[13:37:44.716]             c <- base::c
[13:37:44.716]             inherits <- base::inherits
[13:37:44.716]             invokeRestart <- base::invokeRestart
[13:37:44.716]             length <- base::length
[13:37:44.716]             list <- base::list
[13:37:44.716]             seq.int <- base::seq.int
[13:37:44.716]             signalCondition <- base::signalCondition
[13:37:44.716]             sys.calls <- base::sys.calls
[13:37:44.716]             `[[` <- base::`[[`
[13:37:44.716]             `+` <- base::`+`
[13:37:44.716]             `<<-` <- base::`<<-`
[13:37:44.716]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:44.716]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:44.716]                   3L)]
[13:37:44.716]             }
[13:37:44.716]             function(cond) {
[13:37:44.716]                 is_error <- inherits(cond, "error")
[13:37:44.716]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:44.716]                   NULL)
[13:37:44.716]                 if (is_error) {
[13:37:44.716]                   sessionInformation <- function() {
[13:37:44.716]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:44.716]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:44.716]                       search = base::search(), system = base::Sys.info())
[13:37:44.716]                   }
[13:37:44.716]                   ...future.conditions[[length(...future.conditions) + 
[13:37:44.716]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:44.716]                     cond$call), session = sessionInformation(), 
[13:37:44.716]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:44.716]                   signalCondition(cond)
[13:37:44.716]                 }
[13:37:44.716]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:44.716]                 "immediateCondition"))) {
[13:37:44.716]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:44.716]                   ...future.conditions[[length(...future.conditions) + 
[13:37:44.716]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:44.716]                   if (TRUE && !signal) {
[13:37:44.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:44.716]                     {
[13:37:44.716]                       inherits <- base::inherits
[13:37:44.716]                       invokeRestart <- base::invokeRestart
[13:37:44.716]                       is.null <- base::is.null
[13:37:44.716]                       muffled <- FALSE
[13:37:44.716]                       if (inherits(cond, "message")) {
[13:37:44.716]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:44.716]                         if (muffled) 
[13:37:44.716]                           invokeRestart("muffleMessage")
[13:37:44.716]                       }
[13:37:44.716]                       else if (inherits(cond, "warning")) {
[13:37:44.716]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:44.716]                         if (muffled) 
[13:37:44.716]                           invokeRestart("muffleWarning")
[13:37:44.716]                       }
[13:37:44.716]                       else if (inherits(cond, "condition")) {
[13:37:44.716]                         if (!is.null(pattern)) {
[13:37:44.716]                           computeRestarts <- base::computeRestarts
[13:37:44.716]                           grepl <- base::grepl
[13:37:44.716]                           restarts <- computeRestarts(cond)
[13:37:44.716]                           for (restart in restarts) {
[13:37:44.716]                             name <- restart$name
[13:37:44.716]                             if (is.null(name)) 
[13:37:44.716]                               next
[13:37:44.716]                             if (!grepl(pattern, name)) 
[13:37:44.716]                               next
[13:37:44.716]                             invokeRestart(restart)
[13:37:44.716]                             muffled <- TRUE
[13:37:44.716]                             break
[13:37:44.716]                           }
[13:37:44.716]                         }
[13:37:44.716]                       }
[13:37:44.716]                       invisible(muffled)
[13:37:44.716]                     }
[13:37:44.716]                     muffleCondition(cond, pattern = "^muffle")
[13:37:44.716]                   }
[13:37:44.716]                 }
[13:37:44.716]                 else {
[13:37:44.716]                   if (TRUE) {
[13:37:44.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:44.716]                     {
[13:37:44.716]                       inherits <- base::inherits
[13:37:44.716]                       invokeRestart <- base::invokeRestart
[13:37:44.716]                       is.null <- base::is.null
[13:37:44.716]                       muffled <- FALSE
[13:37:44.716]                       if (inherits(cond, "message")) {
[13:37:44.716]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:44.716]                         if (muffled) 
[13:37:44.716]                           invokeRestart("muffleMessage")
[13:37:44.716]                       }
[13:37:44.716]                       else if (inherits(cond, "warning")) {
[13:37:44.716]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:44.716]                         if (muffled) 
[13:37:44.716]                           invokeRestart("muffleWarning")
[13:37:44.716]                       }
[13:37:44.716]                       else if (inherits(cond, "condition")) {
[13:37:44.716]                         if (!is.null(pattern)) {
[13:37:44.716]                           computeRestarts <- base::computeRestarts
[13:37:44.716]                           grepl <- base::grepl
[13:37:44.716]                           restarts <- computeRestarts(cond)
[13:37:44.716]                           for (restart in restarts) {
[13:37:44.716]                             name <- restart$name
[13:37:44.716]                             if (is.null(name)) 
[13:37:44.716]                               next
[13:37:44.716]                             if (!grepl(pattern, name)) 
[13:37:44.716]                               next
[13:37:44.716]                             invokeRestart(restart)
[13:37:44.716]                             muffled <- TRUE
[13:37:44.716]                             break
[13:37:44.716]                           }
[13:37:44.716]                         }
[13:37:44.716]                       }
[13:37:44.716]                       invisible(muffled)
[13:37:44.716]                     }
[13:37:44.716]                     muffleCondition(cond, pattern = "^muffle")
[13:37:44.716]                   }
[13:37:44.716]                 }
[13:37:44.716]             }
[13:37:44.716]         }))
[13:37:44.716]     }, error = function(ex) {
[13:37:44.716]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:44.716]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:44.716]                 ...future.rng), started = ...future.startTime, 
[13:37:44.716]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:44.716]             version = "1.8"), class = "FutureResult")
[13:37:44.716]     }, finally = {
[13:37:44.716]         if (!identical(...future.workdir, getwd())) 
[13:37:44.716]             setwd(...future.workdir)
[13:37:44.716]         {
[13:37:44.716]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:44.716]                 ...future.oldOptions$nwarnings <- NULL
[13:37:44.716]             }
[13:37:44.716]             base::options(...future.oldOptions)
[13:37:44.716]             if (.Platform$OS.type == "windows") {
[13:37:44.716]                 old_names <- names(...future.oldEnvVars)
[13:37:44.716]                 envs <- base::Sys.getenv()
[13:37:44.716]                 names <- names(envs)
[13:37:44.716]                 common <- intersect(names, old_names)
[13:37:44.716]                 added <- setdiff(names, old_names)
[13:37:44.716]                 removed <- setdiff(old_names, names)
[13:37:44.716]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:44.716]                   envs[common]]
[13:37:44.716]                 NAMES <- toupper(changed)
[13:37:44.716]                 args <- list()
[13:37:44.716]                 for (kk in seq_along(NAMES)) {
[13:37:44.716]                   name <- changed[[kk]]
[13:37:44.716]                   NAME <- NAMES[[kk]]
[13:37:44.716]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:44.716]                     next
[13:37:44.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:44.716]                 }
[13:37:44.716]                 NAMES <- toupper(added)
[13:37:44.716]                 for (kk in seq_along(NAMES)) {
[13:37:44.716]                   name <- added[[kk]]
[13:37:44.716]                   NAME <- NAMES[[kk]]
[13:37:44.716]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:44.716]                     next
[13:37:44.716]                   args[[name]] <- ""
[13:37:44.716]                 }
[13:37:44.716]                 NAMES <- toupper(removed)
[13:37:44.716]                 for (kk in seq_along(NAMES)) {
[13:37:44.716]                   name <- removed[[kk]]
[13:37:44.716]                   NAME <- NAMES[[kk]]
[13:37:44.716]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:44.716]                     next
[13:37:44.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:44.716]                 }
[13:37:44.716]                 if (length(args) > 0) 
[13:37:44.716]                   base::do.call(base::Sys.setenv, args = args)
[13:37:44.716]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:44.716]             }
[13:37:44.716]             else {
[13:37:44.716]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:44.716]             }
[13:37:44.716]             {
[13:37:44.716]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:44.716]                   0L) {
[13:37:44.716]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:44.716]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:44.716]                   base::options(opts)
[13:37:44.716]                 }
[13:37:44.716]                 {
[13:37:44.716]                   {
[13:37:44.716]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:44.716]                     NULL
[13:37:44.716]                   }
[13:37:44.716]                   options(future.plan = NULL)
[13:37:44.716]                   if (is.na(NA_character_)) 
[13:37:44.716]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:44.716]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:44.716]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:44.716]                     .init = FALSE)
[13:37:44.716]                 }
[13:37:44.716]             }
[13:37:44.716]         }
[13:37:44.716]     })
[13:37:44.716]     if (TRUE) {
[13:37:44.716]         base::sink(type = "output", split = FALSE)
[13:37:44.716]         if (TRUE) {
[13:37:44.716]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:44.716]         }
[13:37:44.716]         else {
[13:37:44.716]             ...future.result["stdout"] <- base::list(NULL)
[13:37:44.716]         }
[13:37:44.716]         base::close(...future.stdout)
[13:37:44.716]         ...future.stdout <- NULL
[13:37:44.716]     }
[13:37:44.716]     ...future.result$conditions <- ...future.conditions
[13:37:44.716]     ...future.result$finished <- base::Sys.time()
[13:37:44.716]     ...future.result
[13:37:44.716] }
[13:37:44.720] assign_globals() ...
[13:37:44.720] List of 1
[13:37:44.720]  $ kk: int 2
[13:37:44.720]  - attr(*, "where")=List of 1
[13:37:44.720]   ..$ kk:<environment: R_EmptyEnv> 
[13:37:44.720]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:37:44.720]  - attr(*, "resolved")= logi FALSE
[13:37:44.720]  - attr(*, "total_size")= num 56
[13:37:44.720]  - attr(*, "already-done")= logi TRUE
[13:37:44.724] - copied ‘kk’ to environment
[13:37:44.725] assign_globals() ... done
[13:37:44.725] requestCore(): workers = 2
[13:37:44.725] Poll #1 (0): usedCores() = 2, workers = 2
[13:37:44.736] result() for MulticoreFuture ...
[13:37:44.737] result() for MulticoreFuture ...
[13:37:44.737] result() for MulticoreFuture ... done
[13:37:44.737] result() for MulticoreFuture ... done
[13:37:44.738] result() for MulticoreFuture ...
[13:37:44.738] result() for MulticoreFuture ... done
[13:37:44.741] MulticoreFuture started
[13:37:44.742] - Launch lazy future ... done
[13:37:44.742] run() for ‘MulticoreFuture’ ... done
[13:37:44.743] getGlobalsAndPackages() ...
[13:37:44.743] plan(): Setting new future strategy stack:
[13:37:44.743] Searching for globals...
[13:37:44.743] List of future strategies:
[13:37:44.743] 1. sequential:
[13:37:44.743]    - args: function (..., envir = parent.frame())
[13:37:44.743]    - tweaked: FALSE
[13:37:44.743]    - call: NULL
[13:37:44.744] plan(): nbrOfWorkers() = 1
[13:37:44.745] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:37:44.746] Searching for globals ... DONE
[13:37:44.746] Resolving globals: FALSE
[13:37:44.747] The total size of the 1 globals is 56 bytes (56 bytes)
[13:37:44.747] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:37:44.748] - globals: [1] ‘kk’
[13:37:44.753] 
[13:37:44.753] getGlobalsAndPackages() ... DONE
[13:37:44.754] run() for ‘Future’ ...
[13:37:44.755] - state: ‘created’
[13:37:44.755] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:37:44.763] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:44.763] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:37:44.763]   - Field: ‘label’
[13:37:44.763]   - Field: ‘local’
[13:37:44.764]   - Field: ‘owner’
[13:37:44.764]   - Field: ‘envir’
[13:37:44.764]   - Field: ‘workers’
[13:37:44.764]   - Field: ‘packages’
[13:37:44.764]   - Field: ‘gc’
[13:37:44.765]   - Field: ‘job’
[13:37:44.765]   - Field: ‘conditions’
[13:37:44.765]   - Field: ‘expr’
[13:37:44.765]   - Field: ‘uuid’
[13:37:44.765]   - Field: ‘seed’
[13:37:44.765]   - Field: ‘version’
[13:37:44.766]   - Field: ‘result’
[13:37:44.766]   - Field: ‘asynchronous’
[13:37:44.766]   - Field: ‘calls’
[13:37:44.766]   - Field: ‘globals’
[13:37:44.766]   - Field: ‘stdout’
[13:37:44.766]   - Field: ‘earlySignal’
[13:37:44.767]   - Field: ‘lazy’
[13:37:44.767]   - Field: ‘state’
[13:37:44.767] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:37:44.767] - Launch lazy future ...
[13:37:44.768] Packages needed by the future expression (n = 0): <none>
[13:37:44.768] Packages needed by future strategies (n = 0): <none>
[13:37:44.769] {
[13:37:44.769]     {
[13:37:44.769]         {
[13:37:44.769]             ...future.startTime <- base::Sys.time()
[13:37:44.769]             {
[13:37:44.769]                 {
[13:37:44.769]                   {
[13:37:44.769]                     {
[13:37:44.769]                       base::local({
[13:37:44.769]                         has_future <- base::requireNamespace("future", 
[13:37:44.769]                           quietly = TRUE)
[13:37:44.769]                         if (has_future) {
[13:37:44.769]                           ns <- base::getNamespace("future")
[13:37:44.769]                           version <- ns[[".package"]][["version"]]
[13:37:44.769]                           if (is.null(version)) 
[13:37:44.769]                             version <- utils::packageVersion("future")
[13:37:44.769]                         }
[13:37:44.769]                         else {
[13:37:44.769]                           version <- NULL
[13:37:44.769]                         }
[13:37:44.769]                         if (!has_future || version < "1.8.0") {
[13:37:44.769]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:44.769]                             "", base::R.version$version.string), 
[13:37:44.769]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:44.769]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:44.769]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:44.769]                               "release", "version")], collapse = " "), 
[13:37:44.769]                             hostname = base::Sys.info()[["nodename"]])
[13:37:44.769]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:44.769]                             info)
[13:37:44.769]                           info <- base::paste(info, collapse = "; ")
[13:37:44.769]                           if (!has_future) {
[13:37:44.769]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:44.769]                               info)
[13:37:44.769]                           }
[13:37:44.769]                           else {
[13:37:44.769]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:44.769]                               info, version)
[13:37:44.769]                           }
[13:37:44.769]                           base::stop(msg)
[13:37:44.769]                         }
[13:37:44.769]                       })
[13:37:44.769]                     }
[13:37:44.769]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:44.769]                     base::options(mc.cores = 1L)
[13:37:44.769]                   }
[13:37:44.769]                   ...future.strategy.old <- future::plan("list")
[13:37:44.769]                   options(future.plan = NULL)
[13:37:44.769]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:44.769]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:44.769]                 }
[13:37:44.769]                 ...future.workdir <- getwd()
[13:37:44.769]             }
[13:37:44.769]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:44.769]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:44.769]         }
[13:37:44.769]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:44.769]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:44.769]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:44.769]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:44.769]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:44.769]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:44.769]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:44.769]             base::names(...future.oldOptions))
[13:37:44.769]     }
[13:37:44.769]     if (FALSE) {
[13:37:44.769]     }
[13:37:44.769]     else {
[13:37:44.769]         if (TRUE) {
[13:37:44.769]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:44.769]                 open = "w")
[13:37:44.769]         }
[13:37:44.769]         else {
[13:37:44.769]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:44.769]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:44.769]         }
[13:37:44.769]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:44.769]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:44.769]             base::sink(type = "output", split = FALSE)
[13:37:44.769]             base::close(...future.stdout)
[13:37:44.769]         }, add = TRUE)
[13:37:44.769]     }
[13:37:44.769]     ...future.frame <- base::sys.nframe()
[13:37:44.769]     ...future.conditions <- base::list()
[13:37:44.769]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:44.769]     if (FALSE) {
[13:37:44.769]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:44.769]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:44.769]     }
[13:37:44.769]     ...future.result <- base::tryCatch({
[13:37:44.769]         base::withCallingHandlers({
[13:37:44.769]             ...future.value <- base::withVisible(base::local({
[13:37:44.769]                 withCallingHandlers({
[13:37:44.769]                   {
[13:37:44.769]                     Sys.sleep(0.1)
[13:37:44.769]                     kk
[13:37:44.769]                   }
[13:37:44.769]                 }, immediateCondition = function(cond) {
[13:37:44.769]                   save_rds <- function (object, pathname, ...) 
[13:37:44.769]                   {
[13:37:44.769]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:37:44.769]                     if (file_test("-f", pathname_tmp)) {
[13:37:44.769]                       fi_tmp <- file.info(pathname_tmp)
[13:37:44.769]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:37:44.769]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:44.769]                         fi_tmp[["mtime"]])
[13:37:44.769]                     }
[13:37:44.769]                     tryCatch({
[13:37:44.769]                       saveRDS(object, file = pathname_tmp, ...)
[13:37:44.769]                     }, error = function(ex) {
[13:37:44.769]                       msg <- conditionMessage(ex)
[13:37:44.769]                       fi_tmp <- file.info(pathname_tmp)
[13:37:44.769]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:37:44.769]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:44.769]                         fi_tmp[["mtime"]], msg)
[13:37:44.769]                       ex$message <- msg
[13:37:44.769]                       stop(ex)
[13:37:44.769]                     })
[13:37:44.769]                     stopifnot(file_test("-f", pathname_tmp))
[13:37:44.769]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:37:44.769]                     if (!res || file_test("-f", pathname_tmp)) {
[13:37:44.769]                       fi_tmp <- file.info(pathname_tmp)
[13:37:44.769]                       fi <- file.info(pathname)
[13:37:44.769]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:37:44.769]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:44.769]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:37:44.769]                         fi[["size"]], fi[["mtime"]])
[13:37:44.769]                       stop(msg)
[13:37:44.769]                     }
[13:37:44.769]                     invisible(pathname)
[13:37:44.769]                   }
[13:37:44.769]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:37:44.769]                     rootPath = tempdir()) 
[13:37:44.769]                   {
[13:37:44.769]                     obj <- list(time = Sys.time(), condition = cond)
[13:37:44.769]                     file <- tempfile(pattern = class(cond)[1], 
[13:37:44.769]                       tmpdir = path, fileext = ".rds")
[13:37:44.769]                     save_rds(obj, file)
[13:37:44.769]                   }
[13:37:44.769]                   saveImmediateCondition(cond, path = "/tmp/RtmpLAMaHJ/.future/immediateConditions")
[13:37:44.769]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:44.769]                   {
[13:37:44.769]                     inherits <- base::inherits
[13:37:44.769]                     invokeRestart <- base::invokeRestart
[13:37:44.769]                     is.null <- base::is.null
[13:37:44.769]                     muffled <- FALSE
[13:37:44.769]                     if (inherits(cond, "message")) {
[13:37:44.769]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:44.769]                       if (muffled) 
[13:37:44.769]                         invokeRestart("muffleMessage")
[13:37:44.769]                     }
[13:37:44.769]                     else if (inherits(cond, "warning")) {
[13:37:44.769]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:44.769]                       if (muffled) 
[13:37:44.769]                         invokeRestart("muffleWarning")
[13:37:44.769]                     }
[13:37:44.769]                     else if (inherits(cond, "condition")) {
[13:37:44.769]                       if (!is.null(pattern)) {
[13:37:44.769]                         computeRestarts <- base::computeRestarts
[13:37:44.769]                         grepl <- base::grepl
[13:37:44.769]                         restarts <- computeRestarts(cond)
[13:37:44.769]                         for (restart in restarts) {
[13:37:44.769]                           name <- restart$name
[13:37:44.769]                           if (is.null(name)) 
[13:37:44.769]                             next
[13:37:44.769]                           if (!grepl(pattern, name)) 
[13:37:44.769]                             next
[13:37:44.769]                           invokeRestart(restart)
[13:37:44.769]                           muffled <- TRUE
[13:37:44.769]                           break
[13:37:44.769]                         }
[13:37:44.769]                       }
[13:37:44.769]                     }
[13:37:44.769]                     invisible(muffled)
[13:37:44.769]                   }
[13:37:44.769]                   muffleCondition(cond)
[13:37:44.769]                 })
[13:37:44.769]             }))
[13:37:44.769]             future::FutureResult(value = ...future.value$value, 
[13:37:44.769]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:44.769]                   ...future.rng), globalenv = if (FALSE) 
[13:37:44.769]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:44.769]                     ...future.globalenv.names))
[13:37:44.769]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:44.769]         }, condition = base::local({
[13:37:44.769]             c <- base::c
[13:37:44.769]             inherits <- base::inherits
[13:37:44.769]             invokeRestart <- base::invokeRestart
[13:37:44.769]             length <- base::length
[13:37:44.769]             list <- base::list
[13:37:44.769]             seq.int <- base::seq.int
[13:37:44.769]             signalCondition <- base::signalCondition
[13:37:44.769]             sys.calls <- base::sys.calls
[13:37:44.769]             `[[` <- base::`[[`
[13:37:44.769]             `+` <- base::`+`
[13:37:44.769]             `<<-` <- base::`<<-`
[13:37:44.769]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:44.769]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:44.769]                   3L)]
[13:37:44.769]             }
[13:37:44.769]             function(cond) {
[13:37:44.769]                 is_error <- inherits(cond, "error")
[13:37:44.769]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:44.769]                   NULL)
[13:37:44.769]                 if (is_error) {
[13:37:44.769]                   sessionInformation <- function() {
[13:37:44.769]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:44.769]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:44.769]                       search = base::search(), system = base::Sys.info())
[13:37:44.769]                   }
[13:37:44.769]                   ...future.conditions[[length(...future.conditions) + 
[13:37:44.769]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:44.769]                     cond$call), session = sessionInformation(), 
[13:37:44.769]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:44.769]                   signalCondition(cond)
[13:37:44.769]                 }
[13:37:44.769]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:44.769]                 "immediateCondition"))) {
[13:37:44.769]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:44.769]                   ...future.conditions[[length(...future.conditions) + 
[13:37:44.769]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:44.769]                   if (TRUE && !signal) {
[13:37:44.769]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:44.769]                     {
[13:37:44.769]                       inherits <- base::inherits
[13:37:44.769]                       invokeRestart <- base::invokeRestart
[13:37:44.769]                       is.null <- base::is.null
[13:37:44.769]                       muffled <- FALSE
[13:37:44.769]                       if (inherits(cond, "message")) {
[13:37:44.769]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:44.769]                         if (muffled) 
[13:37:44.769]                           invokeRestart("muffleMessage")
[13:37:44.769]                       }
[13:37:44.769]                       else if (inherits(cond, "warning")) {
[13:37:44.769]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:44.769]                         if (muffled) 
[13:37:44.769]                           invokeRestart("muffleWarning")
[13:37:44.769]                       }
[13:37:44.769]                       else if (inherits(cond, "condition")) {
[13:37:44.769]                         if (!is.null(pattern)) {
[13:37:44.769]                           computeRestarts <- base::computeRestarts
[13:37:44.769]                           grepl <- base::grepl
[13:37:44.769]                           restarts <- computeRestarts(cond)
[13:37:44.769]                           for (restart in restarts) {
[13:37:44.769]                             name <- restart$name
[13:37:44.769]                             if (is.null(name)) 
[13:37:44.769]                               next
[13:37:44.769]                             if (!grepl(pattern, name)) 
[13:37:44.769]                               next
[13:37:44.769]                             invokeRestart(restart)
[13:37:44.769]                             muffled <- TRUE
[13:37:44.769]                             break
[13:37:44.769]                           }
[13:37:44.769]                         }
[13:37:44.769]                       }
[13:37:44.769]                       invisible(muffled)
[13:37:44.769]                     }
[13:37:44.769]                     muffleCondition(cond, pattern = "^muffle")
[13:37:44.769]                   }
[13:37:44.769]                 }
[13:37:44.769]                 else {
[13:37:44.769]                   if (TRUE) {
[13:37:44.769]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:44.769]                     {
[13:37:44.769]                       inherits <- base::inherits
[13:37:44.769]                       invokeRestart <- base::invokeRestart
[13:37:44.769]                       is.null <- base::is.null
[13:37:44.769]                       muffled <- FALSE
[13:37:44.769]                       if (inherits(cond, "message")) {
[13:37:44.769]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:44.769]                         if (muffled) 
[13:37:44.769]                           invokeRestart("muffleMessage")
[13:37:44.769]                       }
[13:37:44.769]                       else if (inherits(cond, "warning")) {
[13:37:44.769]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:44.769]                         if (muffled) 
[13:37:44.769]                           invokeRestart("muffleWarning")
[13:37:44.769]                       }
[13:37:44.769]                       else if (inherits(cond, "condition")) {
[13:37:44.769]                         if (!is.null(pattern)) {
[13:37:44.769]                           computeRestarts <- base::computeRestarts
[13:37:44.769]                           grepl <- base::grepl
[13:37:44.769]                           restarts <- computeRestarts(cond)
[13:37:44.769]                           for (restart in restarts) {
[13:37:44.769]                             name <- restart$name
[13:37:44.769]                             if (is.null(name)) 
[13:37:44.769]                               next
[13:37:44.769]                             if (!grepl(pattern, name)) 
[13:37:44.769]                               next
[13:37:44.769]                             invokeRestart(restart)
[13:37:44.769]                             muffled <- TRUE
[13:37:44.769]                             break
[13:37:44.769]                           }
[13:37:44.769]                         }
[13:37:44.769]                       }
[13:37:44.769]                       invisible(muffled)
[13:37:44.769]                     }
[13:37:44.769]                     muffleCondition(cond, pattern = "^muffle")
[13:37:44.769]                   }
[13:37:44.769]                 }
[13:37:44.769]             }
[13:37:44.769]         }))
[13:37:44.769]     }, error = function(ex) {
[13:37:44.769]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:44.769]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:44.769]                 ...future.rng), started = ...future.startTime, 
[13:37:44.769]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:44.769]             version = "1.8"), class = "FutureResult")
[13:37:44.769]     }, finally = {
[13:37:44.769]         if (!identical(...future.workdir, getwd())) 
[13:37:44.769]             setwd(...future.workdir)
[13:37:44.769]         {
[13:37:44.769]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:44.769]                 ...future.oldOptions$nwarnings <- NULL
[13:37:44.769]             }
[13:37:44.769]             base::options(...future.oldOptions)
[13:37:44.769]             if (.Platform$OS.type == "windows") {
[13:37:44.769]                 old_names <- names(...future.oldEnvVars)
[13:37:44.769]                 envs <- base::Sys.getenv()
[13:37:44.769]                 names <- names(envs)
[13:37:44.769]                 common <- intersect(names, old_names)
[13:37:44.769]                 added <- setdiff(names, old_names)
[13:37:44.769]                 removed <- setdiff(old_names, names)
[13:37:44.769]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:44.769]                   envs[common]]
[13:37:44.769]                 NAMES <- toupper(changed)
[13:37:44.769]                 args <- list()
[13:37:44.769]                 for (kk in seq_along(NAMES)) {
[13:37:44.769]                   name <- changed[[kk]]
[13:37:44.769]                   NAME <- NAMES[[kk]]
[13:37:44.769]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:44.769]                     next
[13:37:44.769]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:44.769]                 }
[13:37:44.769]                 NAMES <- toupper(added)
[13:37:44.769]                 for (kk in seq_along(NAMES)) {
[13:37:44.769]                   name <- added[[kk]]
[13:37:44.769]                   NAME <- NAMES[[kk]]
[13:37:44.769]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:44.769]                     next
[13:37:44.769]                   args[[name]] <- ""
[13:37:44.769]                 }
[13:37:44.769]                 NAMES <- toupper(removed)
[13:37:44.769]                 for (kk in seq_along(NAMES)) {
[13:37:44.769]                   name <- removed[[kk]]
[13:37:44.769]                   NAME <- NAMES[[kk]]
[13:37:44.769]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:44.769]                     next
[13:37:44.769]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:44.769]                 }
[13:37:44.769]                 if (length(args) > 0) 
[13:37:44.769]                   base::do.call(base::Sys.setenv, args = args)
[13:37:44.769]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:44.769]             }
[13:37:44.769]             else {
[13:37:44.769]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:44.769]             }
[13:37:44.769]             {
[13:37:44.769]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:44.769]                   0L) {
[13:37:44.769]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:44.769]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:44.769]                   base::options(opts)
[13:37:44.769]                 }
[13:37:44.769]                 {
[13:37:44.769]                   {
[13:37:44.769]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:44.769]                     NULL
[13:37:44.769]                   }
[13:37:44.769]                   options(future.plan = NULL)
[13:37:44.769]                   if (is.na(NA_character_)) 
[13:37:44.769]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:44.769]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:44.769]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:44.769]                     .init = FALSE)
[13:37:44.769]                 }
[13:37:44.769]             }
[13:37:44.769]         }
[13:37:44.769]     })
[13:37:44.769]     if (TRUE) {
[13:37:44.769]         base::sink(type = "output", split = FALSE)
[13:37:44.769]         if (TRUE) {
[13:37:44.769]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:44.769]         }
[13:37:44.769]         else {
[13:37:44.769]             ...future.result["stdout"] <- base::list(NULL)
[13:37:44.769]         }
[13:37:44.769]         base::close(...future.stdout)
[13:37:44.769]         ...future.stdout <- NULL
[13:37:44.769]     }
[13:37:44.769]     ...future.result$conditions <- ...future.conditions
[13:37:44.769]     ...future.result$finished <- base::Sys.time()
[13:37:44.769]     ...future.result
[13:37:44.769] }
[13:37:44.772] assign_globals() ...
[13:37:44.772] List of 1
[13:37:44.772]  $ kk: int 3
[13:37:44.772]  - attr(*, "where")=List of 1
[13:37:44.772]   ..$ kk:<environment: R_EmptyEnv> 
[13:37:44.772]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:37:44.772]  - attr(*, "resolved")= logi FALSE
[13:37:44.772]  - attr(*, "total_size")= num 56
[13:37:44.772]  - attr(*, "already-done")= logi TRUE
[13:37:44.776] - copied ‘kk’ to environment
[13:37:44.776] assign_globals() ... done
[13:37:44.777] requestCore(): workers = 2
[13:37:44.777] Poll #1 (0): usedCores() = 2, workers = 2
[13:37:44.804] plan(): Setting new future strategy stack:
[13:37:44.804] List of future strategies:
[13:37:44.804] 1. multicore:
[13:37:44.804]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:37:44.804]    - tweaked: FALSE
[13:37:44.804]    - call: plan(strategy)
[13:37:44.808] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[13:37:44.809] plan(): nbrOfWorkers() = 2
[13:37:44.819] result() for MulticoreFuture ...
[13:37:44.820] result() for MulticoreFuture ...
[13:37:44.821] result() for MulticoreFuture ... done
[13:37:44.821] result() for MulticoreFuture ... done
[13:37:44.821] result() for MulticoreFuture ...
[13:37:44.821] result() for MulticoreFuture ... done
[13:37:44.824] MulticoreFuture started
[13:37:44.824] - Launch lazy future ... done
[13:37:44.825] run() for ‘MulticoreFuture’ ... done
[13:37:44.825] resolve() on list ...
[13:37:44.825]  recursive: 0
[13:37:44.825] plan(): Setting new future strategy stack:
[13:37:44.826]  length: 3
[13:37:44.826] 
[13:37:44.826] Future #1
[13:37:44.827]  length: 2 (resolved future 1)
[13:37:44.826] List of future strategies:
[13:37:44.826] 1. sequential:
[13:37:44.826]    - args: function (..., envir = parent.frame())
[13:37:44.826]    - tweaked: FALSE
[13:37:44.826]    - call: NULL
[13:37:44.827] plan(): nbrOfWorkers() = 1
[13:37:44.846] plan(): Setting new future strategy stack:
[13:37:44.847] List of future strategies:
[13:37:44.847] 1. multicore:
[13:37:44.847]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:37:44.847]    - tweaked: FALSE
[13:37:44.847]    - call: plan(strategy)
[13:37:44.852] plan(): nbrOfWorkers() = 2
[13:37:44.858] Future #2
[13:37:44.859]  length: 1 (resolved future 2)
[13:37:44.930] plan(): Setting new future strategy stack:
[13:37:44.930] List of future strategies:
[13:37:44.930] 1. multicore:
[13:37:44.930]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:37:44.930]    - tweaked: FALSE
[13:37:44.930]    - call: plan(strategy)
[13:37:44.936] plan(): nbrOfWorkers() = 2
[13:37:44.941] Future #3
[13:37:44.941]  length: 0 (resolved future 3)
[13:37:44.942] resolve() on list ... DONE
[13:37:44.942] getGlobalsAndPackages() ...
[13:37:44.942] Searching for globals...
[13:37:44.944] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:37:44.945] Searching for globals ... DONE
[13:37:44.945] Resolving globals: FALSE
[13:37:44.945] The total size of the 1 globals is 56 bytes (56 bytes)
[13:37:44.946] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:37:44.946] - globals: [1] ‘kk’
[13:37:44.947] 
[13:37:44.947] getGlobalsAndPackages() ... DONE
[13:37:44.947] getGlobalsAndPackages() ...
[13:37:44.947] Searching for globals...
[13:37:44.949] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:37:44.949] Searching for globals ... DONE
[13:37:44.949] Resolving globals: FALSE
[13:37:44.950] The total size of the 1 globals is 56 bytes (56 bytes)
[13:37:44.950] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:37:44.951] - globals: [1] ‘kk’
[13:37:44.951] 
[13:37:44.951] getGlobalsAndPackages() ... DONE
[13:37:44.951] getGlobalsAndPackages() ...
[13:37:44.951] Searching for globals...
[13:37:44.953] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:37:44.953] Searching for globals ... DONE
[13:37:44.953] Resolving globals: FALSE
[13:37:44.954] The total size of the 1 globals is 56 bytes (56 bytes)
[13:37:44.954] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:37:44.955] - globals: [1] ‘kk’
[13:37:44.955] 
[13:37:44.955] getGlobalsAndPackages() ... DONE
[13:37:44.955] resolve() on list ...
[13:37:44.955]  recursive: 0
[13:37:44.956]  length: 3
[13:37:44.956] 
[13:37:44.956] run() for ‘Future’ ...
[13:37:44.956] - state: ‘created’
[13:37:44.956] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:37:44.961] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:44.961] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:37:44.962]   - Field: ‘label’
[13:37:44.962]   - Field: ‘local’
[13:37:44.962]   - Field: ‘owner’
[13:37:44.962]   - Field: ‘envir’
[13:37:44.962]   - Field: ‘workers’
[13:37:44.962]   - Field: ‘packages’
[13:37:44.963]   - Field: ‘gc’
[13:37:44.963]   - Field: ‘job’
[13:37:44.963]   - Field: ‘conditions’
[13:37:44.966]   - Field: ‘expr’
[13:37:44.967]   - Field: ‘uuid’
[13:37:44.967]   - Field: ‘seed’
[13:37:44.967]   - Field: ‘version’
[13:37:44.968]   - Field: ‘result’
[13:37:44.968]   - Field: ‘asynchronous’
[13:37:44.968]   - Field: ‘calls’
[13:37:44.968]   - Field: ‘globals’
[13:37:44.969]   - Field: ‘stdout’
[13:37:44.969]   - Field: ‘earlySignal’
[13:37:44.969]   - Field: ‘lazy’
[13:37:44.969]   - Field: ‘state’
[13:37:44.970] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:37:44.970] - Launch lazy future ...
[13:37:44.971] Packages needed by the future expression (n = 0): <none>
[13:37:44.971] Packages needed by future strategies (n = 0): <none>
[13:37:44.972] {
[13:37:44.972]     {
[13:37:44.972]         {
[13:37:44.972]             ...future.startTime <- base::Sys.time()
[13:37:44.972]             {
[13:37:44.972]                 {
[13:37:44.972]                   {
[13:37:44.972]                     {
[13:37:44.972]                       base::local({
[13:37:44.972]                         has_future <- base::requireNamespace("future", 
[13:37:44.972]                           quietly = TRUE)
[13:37:44.972]                         if (has_future) {
[13:37:44.972]                           ns <- base::getNamespace("future")
[13:37:44.972]                           version <- ns[[".package"]][["version"]]
[13:37:44.972]                           if (is.null(version)) 
[13:37:44.972]                             version <- utils::packageVersion("future")
[13:37:44.972]                         }
[13:37:44.972]                         else {
[13:37:44.972]                           version <- NULL
[13:37:44.972]                         }
[13:37:44.972]                         if (!has_future || version < "1.8.0") {
[13:37:44.972]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:44.972]                             "", base::R.version$version.string), 
[13:37:44.972]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:44.972]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:44.972]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:44.972]                               "release", "version")], collapse = " "), 
[13:37:44.972]                             hostname = base::Sys.info()[["nodename"]])
[13:37:44.972]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:44.972]                             info)
[13:37:44.972]                           info <- base::paste(info, collapse = "; ")
[13:37:44.972]                           if (!has_future) {
[13:37:44.972]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:44.972]                               info)
[13:37:44.972]                           }
[13:37:44.972]                           else {
[13:37:44.972]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:44.972]                               info, version)
[13:37:44.972]                           }
[13:37:44.972]                           base::stop(msg)
[13:37:44.972]                         }
[13:37:44.972]                       })
[13:37:44.972]                     }
[13:37:44.972]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:44.972]                     base::options(mc.cores = 1L)
[13:37:44.972]                   }
[13:37:44.972]                   ...future.strategy.old <- future::plan("list")
[13:37:44.972]                   options(future.plan = NULL)
[13:37:44.972]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:44.972]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:44.972]                 }
[13:37:44.972]                 ...future.workdir <- getwd()
[13:37:44.972]             }
[13:37:44.972]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:44.972]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:44.972]         }
[13:37:44.972]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:44.972]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:44.972]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:44.972]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:44.972]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:44.972]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:44.972]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:44.972]             base::names(...future.oldOptions))
[13:37:44.972]     }
[13:37:44.972]     if (FALSE) {
[13:37:44.972]     }
[13:37:44.972]     else {
[13:37:44.972]         if (TRUE) {
[13:37:44.972]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:44.972]                 open = "w")
[13:37:44.972]         }
[13:37:44.972]         else {
[13:37:44.972]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:44.972]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:44.972]         }
[13:37:44.972]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:44.972]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:44.972]             base::sink(type = "output", split = FALSE)
[13:37:44.972]             base::close(...future.stdout)
[13:37:44.972]         }, add = TRUE)
[13:37:44.972]     }
[13:37:44.972]     ...future.frame <- base::sys.nframe()
[13:37:44.972]     ...future.conditions <- base::list()
[13:37:44.972]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:44.972]     if (FALSE) {
[13:37:44.972]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:44.972]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:44.972]     }
[13:37:44.972]     ...future.result <- base::tryCatch({
[13:37:44.972]         base::withCallingHandlers({
[13:37:44.972]             ...future.value <- base::withVisible(base::local({
[13:37:44.972]                 withCallingHandlers({
[13:37:44.972]                   {
[13:37:44.972]                     Sys.sleep(0.1)
[13:37:44.972]                     kk
[13:37:44.972]                   }
[13:37:44.972]                 }, immediateCondition = function(cond) {
[13:37:44.972]                   save_rds <- function (object, pathname, ...) 
[13:37:44.972]                   {
[13:37:44.972]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:37:44.972]                     if (file_test("-f", pathname_tmp)) {
[13:37:44.972]                       fi_tmp <- file.info(pathname_tmp)
[13:37:44.972]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:37:44.972]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:44.972]                         fi_tmp[["mtime"]])
[13:37:44.972]                     }
[13:37:44.972]                     tryCatch({
[13:37:44.972]                       saveRDS(object, file = pathname_tmp, ...)
[13:37:44.972]                     }, error = function(ex) {
[13:37:44.972]                       msg <- conditionMessage(ex)
[13:37:44.972]                       fi_tmp <- file.info(pathname_tmp)
[13:37:44.972]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:37:44.972]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:44.972]                         fi_tmp[["mtime"]], msg)
[13:37:44.972]                       ex$message <- msg
[13:37:44.972]                       stop(ex)
[13:37:44.972]                     })
[13:37:44.972]                     stopifnot(file_test("-f", pathname_tmp))
[13:37:44.972]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:37:44.972]                     if (!res || file_test("-f", pathname_tmp)) {
[13:37:44.972]                       fi_tmp <- file.info(pathname_tmp)
[13:37:44.972]                       fi <- file.info(pathname)
[13:37:44.972]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:37:44.972]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:44.972]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:37:44.972]                         fi[["size"]], fi[["mtime"]])
[13:37:44.972]                       stop(msg)
[13:37:44.972]                     }
[13:37:44.972]                     invisible(pathname)
[13:37:44.972]                   }
[13:37:44.972]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:37:44.972]                     rootPath = tempdir()) 
[13:37:44.972]                   {
[13:37:44.972]                     obj <- list(time = Sys.time(), condition = cond)
[13:37:44.972]                     file <- tempfile(pattern = class(cond)[1], 
[13:37:44.972]                       tmpdir = path, fileext = ".rds")
[13:37:44.972]                     save_rds(obj, file)
[13:37:44.972]                   }
[13:37:44.972]                   saveImmediateCondition(cond, path = "/tmp/RtmpLAMaHJ/.future/immediateConditions")
[13:37:44.972]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:44.972]                   {
[13:37:44.972]                     inherits <- base::inherits
[13:37:44.972]                     invokeRestart <- base::invokeRestart
[13:37:44.972]                     is.null <- base::is.null
[13:37:44.972]                     muffled <- FALSE
[13:37:44.972]                     if (inherits(cond, "message")) {
[13:37:44.972]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:44.972]                       if (muffled) 
[13:37:44.972]                         invokeRestart("muffleMessage")
[13:37:44.972]                     }
[13:37:44.972]                     else if (inherits(cond, "warning")) {
[13:37:44.972]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:44.972]                       if (muffled) 
[13:37:44.972]                         invokeRestart("muffleWarning")
[13:37:44.972]                     }
[13:37:44.972]                     else if (inherits(cond, "condition")) {
[13:37:44.972]                       if (!is.null(pattern)) {
[13:37:44.972]                         computeRestarts <- base::computeRestarts
[13:37:44.972]                         grepl <- base::grepl
[13:37:44.972]                         restarts <- computeRestarts(cond)
[13:37:44.972]                         for (restart in restarts) {
[13:37:44.972]                           name <- restart$name
[13:37:44.972]                           if (is.null(name)) 
[13:37:44.972]                             next
[13:37:44.972]                           if (!grepl(pattern, name)) 
[13:37:44.972]                             next
[13:37:44.972]                           invokeRestart(restart)
[13:37:44.972]                           muffled <- TRUE
[13:37:44.972]                           break
[13:37:44.972]                         }
[13:37:44.972]                       }
[13:37:44.972]                     }
[13:37:44.972]                     invisible(muffled)
[13:37:44.972]                   }
[13:37:44.972]                   muffleCondition(cond)
[13:37:44.972]                 })
[13:37:44.972]             }))
[13:37:44.972]             future::FutureResult(value = ...future.value$value, 
[13:37:44.972]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:44.972]                   ...future.rng), globalenv = if (FALSE) 
[13:37:44.972]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:44.972]                     ...future.globalenv.names))
[13:37:44.972]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:44.972]         }, condition = base::local({
[13:37:44.972]             c <- base::c
[13:37:44.972]             inherits <- base::inherits
[13:37:44.972]             invokeRestart <- base::invokeRestart
[13:37:44.972]             length <- base::length
[13:37:44.972]             list <- base::list
[13:37:44.972]             seq.int <- base::seq.int
[13:37:44.972]             signalCondition <- base::signalCondition
[13:37:44.972]             sys.calls <- base::sys.calls
[13:37:44.972]             `[[` <- base::`[[`
[13:37:44.972]             `+` <- base::`+`
[13:37:44.972]             `<<-` <- base::`<<-`
[13:37:44.972]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:44.972]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:44.972]                   3L)]
[13:37:44.972]             }
[13:37:44.972]             function(cond) {
[13:37:44.972]                 is_error <- inherits(cond, "error")
[13:37:44.972]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:44.972]                   NULL)
[13:37:44.972]                 if (is_error) {
[13:37:44.972]                   sessionInformation <- function() {
[13:37:44.972]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:44.972]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:44.972]                       search = base::search(), system = base::Sys.info())
[13:37:44.972]                   }
[13:37:44.972]                   ...future.conditions[[length(...future.conditions) + 
[13:37:44.972]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:44.972]                     cond$call), session = sessionInformation(), 
[13:37:44.972]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:44.972]                   signalCondition(cond)
[13:37:44.972]                 }
[13:37:44.972]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:44.972]                 "immediateCondition"))) {
[13:37:44.972]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:44.972]                   ...future.conditions[[length(...future.conditions) + 
[13:37:44.972]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:44.972]                   if (TRUE && !signal) {
[13:37:44.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:44.972]                     {
[13:37:44.972]                       inherits <- base::inherits
[13:37:44.972]                       invokeRestart <- base::invokeRestart
[13:37:44.972]                       is.null <- base::is.null
[13:37:44.972]                       muffled <- FALSE
[13:37:44.972]                       if (inherits(cond, "message")) {
[13:37:44.972]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:44.972]                         if (muffled) 
[13:37:44.972]                           invokeRestart("muffleMessage")
[13:37:44.972]                       }
[13:37:44.972]                       else if (inherits(cond, "warning")) {
[13:37:44.972]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:44.972]                         if (muffled) 
[13:37:44.972]                           invokeRestart("muffleWarning")
[13:37:44.972]                       }
[13:37:44.972]                       else if (inherits(cond, "condition")) {
[13:37:44.972]                         if (!is.null(pattern)) {
[13:37:44.972]                           computeRestarts <- base::computeRestarts
[13:37:44.972]                           grepl <- base::grepl
[13:37:44.972]                           restarts <- computeRestarts(cond)
[13:37:44.972]                           for (restart in restarts) {
[13:37:44.972]                             name <- restart$name
[13:37:44.972]                             if (is.null(name)) 
[13:37:44.972]                               next
[13:37:44.972]                             if (!grepl(pattern, name)) 
[13:37:44.972]                               next
[13:37:44.972]                             invokeRestart(restart)
[13:37:44.972]                             muffled <- TRUE
[13:37:44.972]                             break
[13:37:44.972]                           }
[13:37:44.972]                         }
[13:37:44.972]                       }
[13:37:44.972]                       invisible(muffled)
[13:37:44.972]                     }
[13:37:44.972]                     muffleCondition(cond, pattern = "^muffle")
[13:37:44.972]                   }
[13:37:44.972]                 }
[13:37:44.972]                 else {
[13:37:44.972]                   if (TRUE) {
[13:37:44.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:44.972]                     {
[13:37:44.972]                       inherits <- base::inherits
[13:37:44.972]                       invokeRestart <- base::invokeRestart
[13:37:44.972]                       is.null <- base::is.null
[13:37:44.972]                       muffled <- FALSE
[13:37:44.972]                       if (inherits(cond, "message")) {
[13:37:44.972]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:44.972]                         if (muffled) 
[13:37:44.972]                           invokeRestart("muffleMessage")
[13:37:44.972]                       }
[13:37:44.972]                       else if (inherits(cond, "warning")) {
[13:37:44.972]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:44.972]                         if (muffled) 
[13:37:44.972]                           invokeRestart("muffleWarning")
[13:37:44.972]                       }
[13:37:44.972]                       else if (inherits(cond, "condition")) {
[13:37:44.972]                         if (!is.null(pattern)) {
[13:37:44.972]                           computeRestarts <- base::computeRestarts
[13:37:44.972]                           grepl <- base::grepl
[13:37:44.972]                           restarts <- computeRestarts(cond)
[13:37:44.972]                           for (restart in restarts) {
[13:37:44.972]                             name <- restart$name
[13:37:44.972]                             if (is.null(name)) 
[13:37:44.972]                               next
[13:37:44.972]                             if (!grepl(pattern, name)) 
[13:37:44.972]                               next
[13:37:44.972]                             invokeRestart(restart)
[13:37:44.972]                             muffled <- TRUE
[13:37:44.972]                             break
[13:37:44.972]                           }
[13:37:44.972]                         }
[13:37:44.972]                       }
[13:37:44.972]                       invisible(muffled)
[13:37:44.972]                     }
[13:37:44.972]                     muffleCondition(cond, pattern = "^muffle")
[13:37:44.972]                   }
[13:37:44.972]                 }
[13:37:44.972]             }
[13:37:44.972]         }))
[13:37:44.972]     }, error = function(ex) {
[13:37:44.972]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:44.972]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:44.972]                 ...future.rng), started = ...future.startTime, 
[13:37:44.972]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:44.972]             version = "1.8"), class = "FutureResult")
[13:37:44.972]     }, finally = {
[13:37:44.972]         if (!identical(...future.workdir, getwd())) 
[13:37:44.972]             setwd(...future.workdir)
[13:37:44.972]         {
[13:37:44.972]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:44.972]                 ...future.oldOptions$nwarnings <- NULL
[13:37:44.972]             }
[13:37:44.972]             base::options(...future.oldOptions)
[13:37:44.972]             if (.Platform$OS.type == "windows") {
[13:37:44.972]                 old_names <- names(...future.oldEnvVars)
[13:37:44.972]                 envs <- base::Sys.getenv()
[13:37:44.972]                 names <- names(envs)
[13:37:44.972]                 common <- intersect(names, old_names)
[13:37:44.972]                 added <- setdiff(names, old_names)
[13:37:44.972]                 removed <- setdiff(old_names, names)
[13:37:44.972]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:44.972]                   envs[common]]
[13:37:44.972]                 NAMES <- toupper(changed)
[13:37:44.972]                 args <- list()
[13:37:44.972]                 for (kk in seq_along(NAMES)) {
[13:37:44.972]                   name <- changed[[kk]]
[13:37:44.972]                   NAME <- NAMES[[kk]]
[13:37:44.972]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:44.972]                     next
[13:37:44.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:44.972]                 }
[13:37:44.972]                 NAMES <- toupper(added)
[13:37:44.972]                 for (kk in seq_along(NAMES)) {
[13:37:44.972]                   name <- added[[kk]]
[13:37:44.972]                   NAME <- NAMES[[kk]]
[13:37:44.972]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:44.972]                     next
[13:37:44.972]                   args[[name]] <- ""
[13:37:44.972]                 }
[13:37:44.972]                 NAMES <- toupper(removed)
[13:37:44.972]                 for (kk in seq_along(NAMES)) {
[13:37:44.972]                   name <- removed[[kk]]
[13:37:44.972]                   NAME <- NAMES[[kk]]
[13:37:44.972]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:44.972]                     next
[13:37:44.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:44.972]                 }
[13:37:44.972]                 if (length(args) > 0) 
[13:37:44.972]                   base::do.call(base::Sys.setenv, args = args)
[13:37:44.972]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:44.972]             }
[13:37:44.972]             else {
[13:37:44.972]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:44.972]             }
[13:37:44.972]             {
[13:37:44.972]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:44.972]                   0L) {
[13:37:44.972]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:44.972]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:44.972]                   base::options(opts)
[13:37:44.972]                 }
[13:37:44.972]                 {
[13:37:44.972]                   {
[13:37:44.972]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:44.972]                     NULL
[13:37:44.972]                   }
[13:37:44.972]                   options(future.plan = NULL)
[13:37:44.972]                   if (is.na(NA_character_)) 
[13:37:44.972]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:44.972]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:44.972]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:44.972]                     .init = FALSE)
[13:37:44.972]                 }
[13:37:44.972]             }
[13:37:44.972]         }
[13:37:44.972]     })
[13:37:44.972]     if (TRUE) {
[13:37:44.972]         base::sink(type = "output", split = FALSE)
[13:37:44.972]         if (TRUE) {
[13:37:44.972]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:44.972]         }
[13:37:44.972]         else {
[13:37:44.972]             ...future.result["stdout"] <- base::list(NULL)
[13:37:44.972]         }
[13:37:44.972]         base::close(...future.stdout)
[13:37:44.972]         ...future.stdout <- NULL
[13:37:44.972]     }
[13:37:44.972]     ...future.result$conditions <- ...future.conditions
[13:37:44.972]     ...future.result$finished <- base::Sys.time()
[13:37:44.972]     ...future.result
[13:37:44.972] }
[13:37:44.974] assign_globals() ...
[13:37:44.975] List of 1
[13:37:44.975]  $ kk: int 1
[13:37:44.975]  - attr(*, "where")=List of 1
[13:37:44.975]   ..$ kk:<environment: R_EmptyEnv> 
[13:37:44.975]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:37:44.975]  - attr(*, "resolved")= logi FALSE
[13:37:44.975]  - attr(*, "total_size")= num 56
[13:37:44.975]  - attr(*, "already-done")= logi TRUE
[13:37:44.979] - copied ‘kk’ to environment
[13:37:44.979] assign_globals() ... done
[13:37:44.980] requestCore(): workers = 2
[13:37:44.980] Poll #1 (0): usedCores() = 2, workers = 2
[13:37:44.991] result() for MulticoreFuture ...
[13:37:44.992] result() for MulticoreFuture ...
[13:37:44.992] result() for MulticoreFuture ... done
[13:37:44.992] result() for MulticoreFuture ... done
[13:37:44.992] result() for MulticoreFuture ...
[13:37:44.992] result() for MulticoreFuture ... done
[13:37:44.995] MulticoreFuture started
[13:37:44.996] - Launch lazy future ... done
[13:37:44.996] run() for ‘MulticoreFuture’ ... done
[13:37:44.997] plan(): Setting new future strategy stack:
[13:37:44.997] List of future strategies:
[13:37:44.997] 1. sequential:
[13:37:44.997]    - args: function (..., envir = parent.frame())
[13:37:44.997]    - tweaked: FALSE
[13:37:44.997]    - call: NULL
[13:37:44.998] plan(): nbrOfWorkers() = 1
[13:37:45.007] run() for ‘Future’ ...
[13:37:45.007] - state: ‘created’
[13:37:45.007] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:37:45.013] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:45.014] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:37:45.014]   - Field: ‘label’
[13:37:45.014]   - Field: ‘local’
[13:37:45.014]   - Field: ‘owner’
[13:37:45.014]   - Field: ‘envir’
[13:37:45.015]   - Field: ‘workers’
[13:37:45.015]   - Field: ‘packages’
[13:37:45.015]   - Field: ‘gc’
[13:37:45.015]   - Field: ‘job’
[13:37:45.015]   - Field: ‘conditions’
[13:37:45.015]   - Field: ‘expr’
[13:37:45.016]   - Field: ‘uuid’
[13:37:45.016]   - Field: ‘seed’
[13:37:45.016]   - Field: ‘version’
[13:37:45.016]   - Field: ‘result’
[13:37:45.016]   - Field: ‘asynchronous’
[13:37:45.017]   - Field: ‘calls’
[13:37:45.017]   - Field: ‘globals’
[13:37:45.017]   - Field: ‘stdout’
[13:37:45.017]   - Field: ‘earlySignal’
[13:37:45.017]   - Field: ‘lazy’
[13:37:45.017]   - Field: ‘state’
[13:37:45.018] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:37:45.018] - Launch lazy future ...
[13:37:45.018] Packages needed by the future expression (n = 0): <none>
[13:37:45.019] Packages needed by future strategies (n = 0): <none>
[13:37:45.019] {
[13:37:45.019]     {
[13:37:45.019]         {
[13:37:45.019]             ...future.startTime <- base::Sys.time()
[13:37:45.019]             {
[13:37:45.019]                 {
[13:37:45.019]                   {
[13:37:45.019]                     {
[13:37:45.019]                       base::local({
[13:37:45.019]                         has_future <- base::requireNamespace("future", 
[13:37:45.019]                           quietly = TRUE)
[13:37:45.019]                         if (has_future) {
[13:37:45.019]                           ns <- base::getNamespace("future")
[13:37:45.019]                           version <- ns[[".package"]][["version"]]
[13:37:45.019]                           if (is.null(version)) 
[13:37:45.019]                             version <- utils::packageVersion("future")
[13:37:45.019]                         }
[13:37:45.019]                         else {
[13:37:45.019]                           version <- NULL
[13:37:45.019]                         }
[13:37:45.019]                         if (!has_future || version < "1.8.0") {
[13:37:45.019]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:45.019]                             "", base::R.version$version.string), 
[13:37:45.019]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:45.019]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:45.019]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:45.019]                               "release", "version")], collapse = " "), 
[13:37:45.019]                             hostname = base::Sys.info()[["nodename"]])
[13:37:45.019]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:45.019]                             info)
[13:37:45.019]                           info <- base::paste(info, collapse = "; ")
[13:37:45.019]                           if (!has_future) {
[13:37:45.019]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:45.019]                               info)
[13:37:45.019]                           }
[13:37:45.019]                           else {
[13:37:45.019]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:45.019]                               info, version)
[13:37:45.019]                           }
[13:37:45.019]                           base::stop(msg)
[13:37:45.019]                         }
[13:37:45.019]                       })
[13:37:45.019]                     }
[13:37:45.019]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:45.019]                     base::options(mc.cores = 1L)
[13:37:45.019]                   }
[13:37:45.019]                   ...future.strategy.old <- future::plan("list")
[13:37:45.019]                   options(future.plan = NULL)
[13:37:45.019]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.019]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:45.019]                 }
[13:37:45.019]                 ...future.workdir <- getwd()
[13:37:45.019]             }
[13:37:45.019]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:45.019]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:45.019]         }
[13:37:45.019]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:45.019]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:45.019]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:45.019]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:45.019]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:45.019]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:45.019]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:45.019]             base::names(...future.oldOptions))
[13:37:45.019]     }
[13:37:45.019]     if (FALSE) {
[13:37:45.019]     }
[13:37:45.019]     else {
[13:37:45.019]         if (TRUE) {
[13:37:45.019]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:45.019]                 open = "w")
[13:37:45.019]         }
[13:37:45.019]         else {
[13:37:45.019]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:45.019]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:45.019]         }
[13:37:45.019]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:45.019]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:45.019]             base::sink(type = "output", split = FALSE)
[13:37:45.019]             base::close(...future.stdout)
[13:37:45.019]         }, add = TRUE)
[13:37:45.019]     }
[13:37:45.019]     ...future.frame <- base::sys.nframe()
[13:37:45.019]     ...future.conditions <- base::list()
[13:37:45.019]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:45.019]     if (FALSE) {
[13:37:45.019]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:45.019]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:45.019]     }
[13:37:45.019]     ...future.result <- base::tryCatch({
[13:37:45.019]         base::withCallingHandlers({
[13:37:45.019]             ...future.value <- base::withVisible(base::local({
[13:37:45.019]                 withCallingHandlers({
[13:37:45.019]                   {
[13:37:45.019]                     Sys.sleep(0.1)
[13:37:45.019]                     kk
[13:37:45.019]                   }
[13:37:45.019]                 }, immediateCondition = function(cond) {
[13:37:45.019]                   save_rds <- function (object, pathname, ...) 
[13:37:45.019]                   {
[13:37:45.019]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:37:45.019]                     if (file_test("-f", pathname_tmp)) {
[13:37:45.019]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.019]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:37:45.019]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.019]                         fi_tmp[["mtime"]])
[13:37:45.019]                     }
[13:37:45.019]                     tryCatch({
[13:37:45.019]                       saveRDS(object, file = pathname_tmp, ...)
[13:37:45.019]                     }, error = function(ex) {
[13:37:45.019]                       msg <- conditionMessage(ex)
[13:37:45.019]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.019]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:37:45.019]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.019]                         fi_tmp[["mtime"]], msg)
[13:37:45.019]                       ex$message <- msg
[13:37:45.019]                       stop(ex)
[13:37:45.019]                     })
[13:37:45.019]                     stopifnot(file_test("-f", pathname_tmp))
[13:37:45.019]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:37:45.019]                     if (!res || file_test("-f", pathname_tmp)) {
[13:37:45.019]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.019]                       fi <- file.info(pathname)
[13:37:45.019]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:37:45.019]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.019]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:37:45.019]                         fi[["size"]], fi[["mtime"]])
[13:37:45.019]                       stop(msg)
[13:37:45.019]                     }
[13:37:45.019]                     invisible(pathname)
[13:37:45.019]                   }
[13:37:45.019]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:37:45.019]                     rootPath = tempdir()) 
[13:37:45.019]                   {
[13:37:45.019]                     obj <- list(time = Sys.time(), condition = cond)
[13:37:45.019]                     file <- tempfile(pattern = class(cond)[1], 
[13:37:45.019]                       tmpdir = path, fileext = ".rds")
[13:37:45.019]                     save_rds(obj, file)
[13:37:45.019]                   }
[13:37:45.019]                   saveImmediateCondition(cond, path = "/tmp/RtmpLAMaHJ/.future/immediateConditions")
[13:37:45.019]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.019]                   {
[13:37:45.019]                     inherits <- base::inherits
[13:37:45.019]                     invokeRestart <- base::invokeRestart
[13:37:45.019]                     is.null <- base::is.null
[13:37:45.019]                     muffled <- FALSE
[13:37:45.019]                     if (inherits(cond, "message")) {
[13:37:45.019]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:45.019]                       if (muffled) 
[13:37:45.019]                         invokeRestart("muffleMessage")
[13:37:45.019]                     }
[13:37:45.019]                     else if (inherits(cond, "warning")) {
[13:37:45.019]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:45.019]                       if (muffled) 
[13:37:45.019]                         invokeRestart("muffleWarning")
[13:37:45.019]                     }
[13:37:45.019]                     else if (inherits(cond, "condition")) {
[13:37:45.019]                       if (!is.null(pattern)) {
[13:37:45.019]                         computeRestarts <- base::computeRestarts
[13:37:45.019]                         grepl <- base::grepl
[13:37:45.019]                         restarts <- computeRestarts(cond)
[13:37:45.019]                         for (restart in restarts) {
[13:37:45.019]                           name <- restart$name
[13:37:45.019]                           if (is.null(name)) 
[13:37:45.019]                             next
[13:37:45.019]                           if (!grepl(pattern, name)) 
[13:37:45.019]                             next
[13:37:45.019]                           invokeRestart(restart)
[13:37:45.019]                           muffled <- TRUE
[13:37:45.019]                           break
[13:37:45.019]                         }
[13:37:45.019]                       }
[13:37:45.019]                     }
[13:37:45.019]                     invisible(muffled)
[13:37:45.019]                   }
[13:37:45.019]                   muffleCondition(cond)
[13:37:45.019]                 })
[13:37:45.019]             }))
[13:37:45.019]             future::FutureResult(value = ...future.value$value, 
[13:37:45.019]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.019]                   ...future.rng), globalenv = if (FALSE) 
[13:37:45.019]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:45.019]                     ...future.globalenv.names))
[13:37:45.019]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:45.019]         }, condition = base::local({
[13:37:45.019]             c <- base::c
[13:37:45.019]             inherits <- base::inherits
[13:37:45.019]             invokeRestart <- base::invokeRestart
[13:37:45.019]             length <- base::length
[13:37:45.019]             list <- base::list
[13:37:45.019]             seq.int <- base::seq.int
[13:37:45.019]             signalCondition <- base::signalCondition
[13:37:45.019]             sys.calls <- base::sys.calls
[13:37:45.019]             `[[` <- base::`[[`
[13:37:45.019]             `+` <- base::`+`
[13:37:45.019]             `<<-` <- base::`<<-`
[13:37:45.019]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:45.019]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:45.019]                   3L)]
[13:37:45.019]             }
[13:37:45.019]             function(cond) {
[13:37:45.019]                 is_error <- inherits(cond, "error")
[13:37:45.019]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:45.019]                   NULL)
[13:37:45.019]                 if (is_error) {
[13:37:45.019]                   sessionInformation <- function() {
[13:37:45.019]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:45.019]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:45.019]                       search = base::search(), system = base::Sys.info())
[13:37:45.019]                   }
[13:37:45.019]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.019]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:45.019]                     cond$call), session = sessionInformation(), 
[13:37:45.019]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:45.019]                   signalCondition(cond)
[13:37:45.019]                 }
[13:37:45.019]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:45.019]                 "immediateCondition"))) {
[13:37:45.019]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:45.019]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.019]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:45.019]                   if (TRUE && !signal) {
[13:37:45.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.019]                     {
[13:37:45.019]                       inherits <- base::inherits
[13:37:45.019]                       invokeRestart <- base::invokeRestart
[13:37:45.019]                       is.null <- base::is.null
[13:37:45.019]                       muffled <- FALSE
[13:37:45.019]                       if (inherits(cond, "message")) {
[13:37:45.019]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.019]                         if (muffled) 
[13:37:45.019]                           invokeRestart("muffleMessage")
[13:37:45.019]                       }
[13:37:45.019]                       else if (inherits(cond, "warning")) {
[13:37:45.019]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.019]                         if (muffled) 
[13:37:45.019]                           invokeRestart("muffleWarning")
[13:37:45.019]                       }
[13:37:45.019]                       else if (inherits(cond, "condition")) {
[13:37:45.019]                         if (!is.null(pattern)) {
[13:37:45.019]                           computeRestarts <- base::computeRestarts
[13:37:45.019]                           grepl <- base::grepl
[13:37:45.019]                           restarts <- computeRestarts(cond)
[13:37:45.019]                           for (restart in restarts) {
[13:37:45.019]                             name <- restart$name
[13:37:45.019]                             if (is.null(name)) 
[13:37:45.019]                               next
[13:37:45.019]                             if (!grepl(pattern, name)) 
[13:37:45.019]                               next
[13:37:45.019]                             invokeRestart(restart)
[13:37:45.019]                             muffled <- TRUE
[13:37:45.019]                             break
[13:37:45.019]                           }
[13:37:45.019]                         }
[13:37:45.019]                       }
[13:37:45.019]                       invisible(muffled)
[13:37:45.019]                     }
[13:37:45.019]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.019]                   }
[13:37:45.019]                 }
[13:37:45.019]                 else {
[13:37:45.019]                   if (TRUE) {
[13:37:45.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.019]                     {
[13:37:45.019]                       inherits <- base::inherits
[13:37:45.019]                       invokeRestart <- base::invokeRestart
[13:37:45.019]                       is.null <- base::is.null
[13:37:45.019]                       muffled <- FALSE
[13:37:45.019]                       if (inherits(cond, "message")) {
[13:37:45.019]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.019]                         if (muffled) 
[13:37:45.019]                           invokeRestart("muffleMessage")
[13:37:45.019]                       }
[13:37:45.019]                       else if (inherits(cond, "warning")) {
[13:37:45.019]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.019]                         if (muffled) 
[13:37:45.019]                           invokeRestart("muffleWarning")
[13:37:45.019]                       }
[13:37:45.019]                       else if (inherits(cond, "condition")) {
[13:37:45.019]                         if (!is.null(pattern)) {
[13:37:45.019]                           computeRestarts <- base::computeRestarts
[13:37:45.019]                           grepl <- base::grepl
[13:37:45.019]                           restarts <- computeRestarts(cond)
[13:37:45.019]                           for (restart in restarts) {
[13:37:45.019]                             name <- restart$name
[13:37:45.019]                             if (is.null(name)) 
[13:37:45.019]                               next
[13:37:45.019]                             if (!grepl(pattern, name)) 
[13:37:45.019]                               next
[13:37:45.019]                             invokeRestart(restart)
[13:37:45.019]                             muffled <- TRUE
[13:37:45.019]                             break
[13:37:45.019]                           }
[13:37:45.019]                         }
[13:37:45.019]                       }
[13:37:45.019]                       invisible(muffled)
[13:37:45.019]                     }
[13:37:45.019]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.019]                   }
[13:37:45.019]                 }
[13:37:45.019]             }
[13:37:45.019]         }))
[13:37:45.019]     }, error = function(ex) {
[13:37:45.019]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:45.019]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.019]                 ...future.rng), started = ...future.startTime, 
[13:37:45.019]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:45.019]             version = "1.8"), class = "FutureResult")
[13:37:45.019]     }, finally = {
[13:37:45.019]         if (!identical(...future.workdir, getwd())) 
[13:37:45.019]             setwd(...future.workdir)
[13:37:45.019]         {
[13:37:45.019]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:45.019]                 ...future.oldOptions$nwarnings <- NULL
[13:37:45.019]             }
[13:37:45.019]             base::options(...future.oldOptions)
[13:37:45.019]             if (.Platform$OS.type == "windows") {
[13:37:45.019]                 old_names <- names(...future.oldEnvVars)
[13:37:45.019]                 envs <- base::Sys.getenv()
[13:37:45.019]                 names <- names(envs)
[13:37:45.019]                 common <- intersect(names, old_names)
[13:37:45.019]                 added <- setdiff(names, old_names)
[13:37:45.019]                 removed <- setdiff(old_names, names)
[13:37:45.019]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:45.019]                   envs[common]]
[13:37:45.019]                 NAMES <- toupper(changed)
[13:37:45.019]                 args <- list()
[13:37:45.019]                 for (kk in seq_along(NAMES)) {
[13:37:45.019]                   name <- changed[[kk]]
[13:37:45.019]                   NAME <- NAMES[[kk]]
[13:37:45.019]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.019]                     next
[13:37:45.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.019]                 }
[13:37:45.019]                 NAMES <- toupper(added)
[13:37:45.019]                 for (kk in seq_along(NAMES)) {
[13:37:45.019]                   name <- added[[kk]]
[13:37:45.019]                   NAME <- NAMES[[kk]]
[13:37:45.019]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.019]                     next
[13:37:45.019]                   args[[name]] <- ""
[13:37:45.019]                 }
[13:37:45.019]                 NAMES <- toupper(removed)
[13:37:45.019]                 for (kk in seq_along(NAMES)) {
[13:37:45.019]                   name <- removed[[kk]]
[13:37:45.019]                   NAME <- NAMES[[kk]]
[13:37:45.019]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.019]                     next
[13:37:45.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.019]                 }
[13:37:45.019]                 if (length(args) > 0) 
[13:37:45.019]                   base::do.call(base::Sys.setenv, args = args)
[13:37:45.019]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:45.019]             }
[13:37:45.019]             else {
[13:37:45.019]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:45.019]             }
[13:37:45.019]             {
[13:37:45.019]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:45.019]                   0L) {
[13:37:45.019]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:45.019]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:45.019]                   base::options(opts)
[13:37:45.019]                 }
[13:37:45.019]                 {
[13:37:45.019]                   {
[13:37:45.019]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:45.019]                     NULL
[13:37:45.019]                   }
[13:37:45.019]                   options(future.plan = NULL)
[13:37:45.019]                   if (is.na(NA_character_)) 
[13:37:45.019]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.019]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:45.019]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:45.019]                     .init = FALSE)
[13:37:45.019]                 }
[13:37:45.019]             }
[13:37:45.019]         }
[13:37:45.019]     })
[13:37:45.019]     if (TRUE) {
[13:37:45.019]         base::sink(type = "output", split = FALSE)
[13:37:45.019]         if (TRUE) {
[13:37:45.019]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:45.019]         }
[13:37:45.019]         else {
[13:37:45.019]             ...future.result["stdout"] <- base::list(NULL)
[13:37:45.019]         }
[13:37:45.019]         base::close(...future.stdout)
[13:37:45.019]         ...future.stdout <- NULL
[13:37:45.019]     }
[13:37:45.019]     ...future.result$conditions <- ...future.conditions
[13:37:45.019]     ...future.result$finished <- base::Sys.time()
[13:37:45.019]     ...future.result
[13:37:45.019] }
[13:37:45.023] assign_globals() ...
[13:37:45.023] List of 1
[13:37:45.023]  $ kk: int 2
[13:37:45.023]  - attr(*, "where")=List of 1
[13:37:45.023]   ..$ kk:<environment: R_EmptyEnv> 
[13:37:45.023]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:37:45.023]  - attr(*, "resolved")= logi FALSE
[13:37:45.023]  - attr(*, "total_size")= num 56
[13:37:45.023]  - attr(*, "already-done")= logi TRUE
[13:37:45.028] - copied ‘kk’ to environment
[13:37:45.028] assign_globals() ... done
[13:37:45.028] requestCore(): workers = 2
[13:37:45.029] Poll #1 (0): usedCores() = 2, workers = 2
[13:37:45.039] result() for MulticoreFuture ...
[13:37:45.040] result() for MulticoreFuture ...
[13:37:45.040] result() for MulticoreFuture ... done
[13:37:45.041] result() for MulticoreFuture ... done
[13:37:45.041] result() for MulticoreFuture ...
[13:37:45.041] result() for MulticoreFuture ... done
[13:37:45.044] MulticoreFuture started
[13:37:45.044] - Launch lazy future ... done
[13:37:45.045] run() for ‘MulticoreFuture’ ... done
[13:37:45.046] plan(): Setting new future strategy stack:
[13:37:45.046] List of future strategies:
[13:37:45.046] 1. sequential:
[13:37:45.046]    - args: function (..., envir = parent.frame())
[13:37:45.046]    - tweaked: FALSE
[13:37:45.046]    - call: NULL
[13:37:45.047] plan(): nbrOfWorkers() = 1
[13:37:45.056] run() for ‘Future’ ...
[13:37:45.056] - state: ‘created’
[13:37:45.056] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:37:45.063] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:45.064] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:37:45.064]   - Field: ‘label’
[13:37:45.064]   - Field: ‘local’
[13:37:45.064]   - Field: ‘owner’
[13:37:45.064]   - Field: ‘envir’
[13:37:45.064]   - Field: ‘workers’
[13:37:45.065]   - Field: ‘packages’
[13:37:45.065]   - Field: ‘gc’
[13:37:45.065]   - Field: ‘job’
[13:37:45.065]   - Field: ‘conditions’
[13:37:45.065]   - Field: ‘expr’
[13:37:45.065]   - Field: ‘uuid’
[13:37:45.066]   - Field: ‘seed’
[13:37:45.066]   - Field: ‘version’
[13:37:45.066]   - Field: ‘result’
[13:37:45.066]   - Field: ‘asynchronous’
[13:37:45.066]   - Field: ‘calls’
[13:37:45.066]   - Field: ‘globals’
[13:37:45.067]   - Field: ‘stdout’
[13:37:45.067]   - Field: ‘earlySignal’
[13:37:45.067]   - Field: ‘lazy’
[13:37:45.067]   - Field: ‘state’
[13:37:45.067] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:37:45.067] - Launch lazy future ...
[13:37:45.068] Packages needed by the future expression (n = 0): <none>
[13:37:45.068] Packages needed by future strategies (n = 0): <none>
[13:37:45.069] {
[13:37:45.069]     {
[13:37:45.069]         {
[13:37:45.069]             ...future.startTime <- base::Sys.time()
[13:37:45.069]             {
[13:37:45.069]                 {
[13:37:45.069]                   {
[13:37:45.069]                     {
[13:37:45.069]                       base::local({
[13:37:45.069]                         has_future <- base::requireNamespace("future", 
[13:37:45.069]                           quietly = TRUE)
[13:37:45.069]                         if (has_future) {
[13:37:45.069]                           ns <- base::getNamespace("future")
[13:37:45.069]                           version <- ns[[".package"]][["version"]]
[13:37:45.069]                           if (is.null(version)) 
[13:37:45.069]                             version <- utils::packageVersion("future")
[13:37:45.069]                         }
[13:37:45.069]                         else {
[13:37:45.069]                           version <- NULL
[13:37:45.069]                         }
[13:37:45.069]                         if (!has_future || version < "1.8.0") {
[13:37:45.069]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:45.069]                             "", base::R.version$version.string), 
[13:37:45.069]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:45.069]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:45.069]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:45.069]                               "release", "version")], collapse = " "), 
[13:37:45.069]                             hostname = base::Sys.info()[["nodename"]])
[13:37:45.069]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:45.069]                             info)
[13:37:45.069]                           info <- base::paste(info, collapse = "; ")
[13:37:45.069]                           if (!has_future) {
[13:37:45.069]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:45.069]                               info)
[13:37:45.069]                           }
[13:37:45.069]                           else {
[13:37:45.069]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:45.069]                               info, version)
[13:37:45.069]                           }
[13:37:45.069]                           base::stop(msg)
[13:37:45.069]                         }
[13:37:45.069]                       })
[13:37:45.069]                     }
[13:37:45.069]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:45.069]                     base::options(mc.cores = 1L)
[13:37:45.069]                   }
[13:37:45.069]                   ...future.strategy.old <- future::plan("list")
[13:37:45.069]                   options(future.plan = NULL)
[13:37:45.069]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.069]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:45.069]                 }
[13:37:45.069]                 ...future.workdir <- getwd()
[13:37:45.069]             }
[13:37:45.069]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:45.069]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:45.069]         }
[13:37:45.069]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:45.069]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:45.069]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:45.069]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:45.069]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:45.069]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:45.069]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:45.069]             base::names(...future.oldOptions))
[13:37:45.069]     }
[13:37:45.069]     if (FALSE) {
[13:37:45.069]     }
[13:37:45.069]     else {
[13:37:45.069]         if (TRUE) {
[13:37:45.069]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:45.069]                 open = "w")
[13:37:45.069]         }
[13:37:45.069]         else {
[13:37:45.069]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:45.069]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:45.069]         }
[13:37:45.069]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:45.069]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:45.069]             base::sink(type = "output", split = FALSE)
[13:37:45.069]             base::close(...future.stdout)
[13:37:45.069]         }, add = TRUE)
[13:37:45.069]     }
[13:37:45.069]     ...future.frame <- base::sys.nframe()
[13:37:45.069]     ...future.conditions <- base::list()
[13:37:45.069]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:45.069]     if (FALSE) {
[13:37:45.069]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:45.069]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:45.069]     }
[13:37:45.069]     ...future.result <- base::tryCatch({
[13:37:45.069]         base::withCallingHandlers({
[13:37:45.069]             ...future.value <- base::withVisible(base::local({
[13:37:45.069]                 withCallingHandlers({
[13:37:45.069]                   {
[13:37:45.069]                     Sys.sleep(0.1)
[13:37:45.069]                     kk
[13:37:45.069]                   }
[13:37:45.069]                 }, immediateCondition = function(cond) {
[13:37:45.069]                   save_rds <- function (object, pathname, ...) 
[13:37:45.069]                   {
[13:37:45.069]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:37:45.069]                     if (file_test("-f", pathname_tmp)) {
[13:37:45.069]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.069]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:37:45.069]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.069]                         fi_tmp[["mtime"]])
[13:37:45.069]                     }
[13:37:45.069]                     tryCatch({
[13:37:45.069]                       saveRDS(object, file = pathname_tmp, ...)
[13:37:45.069]                     }, error = function(ex) {
[13:37:45.069]                       msg <- conditionMessage(ex)
[13:37:45.069]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.069]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:37:45.069]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.069]                         fi_tmp[["mtime"]], msg)
[13:37:45.069]                       ex$message <- msg
[13:37:45.069]                       stop(ex)
[13:37:45.069]                     })
[13:37:45.069]                     stopifnot(file_test("-f", pathname_tmp))
[13:37:45.069]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:37:45.069]                     if (!res || file_test("-f", pathname_tmp)) {
[13:37:45.069]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.069]                       fi <- file.info(pathname)
[13:37:45.069]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:37:45.069]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.069]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:37:45.069]                         fi[["size"]], fi[["mtime"]])
[13:37:45.069]                       stop(msg)
[13:37:45.069]                     }
[13:37:45.069]                     invisible(pathname)
[13:37:45.069]                   }
[13:37:45.069]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:37:45.069]                     rootPath = tempdir()) 
[13:37:45.069]                   {
[13:37:45.069]                     obj <- list(time = Sys.time(), condition = cond)
[13:37:45.069]                     file <- tempfile(pattern = class(cond)[1], 
[13:37:45.069]                       tmpdir = path, fileext = ".rds")
[13:37:45.069]                     save_rds(obj, file)
[13:37:45.069]                   }
[13:37:45.069]                   saveImmediateCondition(cond, path = "/tmp/RtmpLAMaHJ/.future/immediateConditions")
[13:37:45.069]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.069]                   {
[13:37:45.069]                     inherits <- base::inherits
[13:37:45.069]                     invokeRestart <- base::invokeRestart
[13:37:45.069]                     is.null <- base::is.null
[13:37:45.069]                     muffled <- FALSE
[13:37:45.069]                     if (inherits(cond, "message")) {
[13:37:45.069]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:45.069]                       if (muffled) 
[13:37:45.069]                         invokeRestart("muffleMessage")
[13:37:45.069]                     }
[13:37:45.069]                     else if (inherits(cond, "warning")) {
[13:37:45.069]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:45.069]                       if (muffled) 
[13:37:45.069]                         invokeRestart("muffleWarning")
[13:37:45.069]                     }
[13:37:45.069]                     else if (inherits(cond, "condition")) {
[13:37:45.069]                       if (!is.null(pattern)) {
[13:37:45.069]                         computeRestarts <- base::computeRestarts
[13:37:45.069]                         grepl <- base::grepl
[13:37:45.069]                         restarts <- computeRestarts(cond)
[13:37:45.069]                         for (restart in restarts) {
[13:37:45.069]                           name <- restart$name
[13:37:45.069]                           if (is.null(name)) 
[13:37:45.069]                             next
[13:37:45.069]                           if (!grepl(pattern, name)) 
[13:37:45.069]                             next
[13:37:45.069]                           invokeRestart(restart)
[13:37:45.069]                           muffled <- TRUE
[13:37:45.069]                           break
[13:37:45.069]                         }
[13:37:45.069]                       }
[13:37:45.069]                     }
[13:37:45.069]                     invisible(muffled)
[13:37:45.069]                   }
[13:37:45.069]                   muffleCondition(cond)
[13:37:45.069]                 })
[13:37:45.069]             }))
[13:37:45.069]             future::FutureResult(value = ...future.value$value, 
[13:37:45.069]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.069]                   ...future.rng), globalenv = if (FALSE) 
[13:37:45.069]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:45.069]                     ...future.globalenv.names))
[13:37:45.069]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:45.069]         }, condition = base::local({
[13:37:45.069]             c <- base::c
[13:37:45.069]             inherits <- base::inherits
[13:37:45.069]             invokeRestart <- base::invokeRestart
[13:37:45.069]             length <- base::length
[13:37:45.069]             list <- base::list
[13:37:45.069]             seq.int <- base::seq.int
[13:37:45.069]             signalCondition <- base::signalCondition
[13:37:45.069]             sys.calls <- base::sys.calls
[13:37:45.069]             `[[` <- base::`[[`
[13:37:45.069]             `+` <- base::`+`
[13:37:45.069]             `<<-` <- base::`<<-`
[13:37:45.069]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:45.069]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:45.069]                   3L)]
[13:37:45.069]             }
[13:37:45.069]             function(cond) {
[13:37:45.069]                 is_error <- inherits(cond, "error")
[13:37:45.069]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:45.069]                   NULL)
[13:37:45.069]                 if (is_error) {
[13:37:45.069]                   sessionInformation <- function() {
[13:37:45.069]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:45.069]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:45.069]                       search = base::search(), system = base::Sys.info())
[13:37:45.069]                   }
[13:37:45.069]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.069]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:45.069]                     cond$call), session = sessionInformation(), 
[13:37:45.069]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:45.069]                   signalCondition(cond)
[13:37:45.069]                 }
[13:37:45.069]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:45.069]                 "immediateCondition"))) {
[13:37:45.069]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:45.069]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.069]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:45.069]                   if (TRUE && !signal) {
[13:37:45.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.069]                     {
[13:37:45.069]                       inherits <- base::inherits
[13:37:45.069]                       invokeRestart <- base::invokeRestart
[13:37:45.069]                       is.null <- base::is.null
[13:37:45.069]                       muffled <- FALSE
[13:37:45.069]                       if (inherits(cond, "message")) {
[13:37:45.069]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.069]                         if (muffled) 
[13:37:45.069]                           invokeRestart("muffleMessage")
[13:37:45.069]                       }
[13:37:45.069]                       else if (inherits(cond, "warning")) {
[13:37:45.069]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.069]                         if (muffled) 
[13:37:45.069]                           invokeRestart("muffleWarning")
[13:37:45.069]                       }
[13:37:45.069]                       else if (inherits(cond, "condition")) {
[13:37:45.069]                         if (!is.null(pattern)) {
[13:37:45.069]                           computeRestarts <- base::computeRestarts
[13:37:45.069]                           grepl <- base::grepl
[13:37:45.069]                           restarts <- computeRestarts(cond)
[13:37:45.069]                           for (restart in restarts) {
[13:37:45.069]                             name <- restart$name
[13:37:45.069]                             if (is.null(name)) 
[13:37:45.069]                               next
[13:37:45.069]                             if (!grepl(pattern, name)) 
[13:37:45.069]                               next
[13:37:45.069]                             invokeRestart(restart)
[13:37:45.069]                             muffled <- TRUE
[13:37:45.069]                             break
[13:37:45.069]                           }
[13:37:45.069]                         }
[13:37:45.069]                       }
[13:37:45.069]                       invisible(muffled)
[13:37:45.069]                     }
[13:37:45.069]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.069]                   }
[13:37:45.069]                 }
[13:37:45.069]                 else {
[13:37:45.069]                   if (TRUE) {
[13:37:45.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.069]                     {
[13:37:45.069]                       inherits <- base::inherits
[13:37:45.069]                       invokeRestart <- base::invokeRestart
[13:37:45.069]                       is.null <- base::is.null
[13:37:45.069]                       muffled <- FALSE
[13:37:45.069]                       if (inherits(cond, "message")) {
[13:37:45.069]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.069]                         if (muffled) 
[13:37:45.069]                           invokeRestart("muffleMessage")
[13:37:45.069]                       }
[13:37:45.069]                       else if (inherits(cond, "warning")) {
[13:37:45.069]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.069]                         if (muffled) 
[13:37:45.069]                           invokeRestart("muffleWarning")
[13:37:45.069]                       }
[13:37:45.069]                       else if (inherits(cond, "condition")) {
[13:37:45.069]                         if (!is.null(pattern)) {
[13:37:45.069]                           computeRestarts <- base::computeRestarts
[13:37:45.069]                           grepl <- base::grepl
[13:37:45.069]                           restarts <- computeRestarts(cond)
[13:37:45.069]                           for (restart in restarts) {
[13:37:45.069]                             name <- restart$name
[13:37:45.069]                             if (is.null(name)) 
[13:37:45.069]                               next
[13:37:45.069]                             if (!grepl(pattern, name)) 
[13:37:45.069]                               next
[13:37:45.069]                             invokeRestart(restart)
[13:37:45.069]                             muffled <- TRUE
[13:37:45.069]                             break
[13:37:45.069]                           }
[13:37:45.069]                         }
[13:37:45.069]                       }
[13:37:45.069]                       invisible(muffled)
[13:37:45.069]                     }
[13:37:45.069]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.069]                   }
[13:37:45.069]                 }
[13:37:45.069]             }
[13:37:45.069]         }))
[13:37:45.069]     }, error = function(ex) {
[13:37:45.069]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:45.069]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.069]                 ...future.rng), started = ...future.startTime, 
[13:37:45.069]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:45.069]             version = "1.8"), class = "FutureResult")
[13:37:45.069]     }, finally = {
[13:37:45.069]         if (!identical(...future.workdir, getwd())) 
[13:37:45.069]             setwd(...future.workdir)
[13:37:45.069]         {
[13:37:45.069]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:45.069]                 ...future.oldOptions$nwarnings <- NULL
[13:37:45.069]             }
[13:37:45.069]             base::options(...future.oldOptions)
[13:37:45.069]             if (.Platform$OS.type == "windows") {
[13:37:45.069]                 old_names <- names(...future.oldEnvVars)
[13:37:45.069]                 envs <- base::Sys.getenv()
[13:37:45.069]                 names <- names(envs)
[13:37:45.069]                 common <- intersect(names, old_names)
[13:37:45.069]                 added <- setdiff(names, old_names)
[13:37:45.069]                 removed <- setdiff(old_names, names)
[13:37:45.069]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:45.069]                   envs[common]]
[13:37:45.069]                 NAMES <- toupper(changed)
[13:37:45.069]                 args <- list()
[13:37:45.069]                 for (kk in seq_along(NAMES)) {
[13:37:45.069]                   name <- changed[[kk]]
[13:37:45.069]                   NAME <- NAMES[[kk]]
[13:37:45.069]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.069]                     next
[13:37:45.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.069]                 }
[13:37:45.069]                 NAMES <- toupper(added)
[13:37:45.069]                 for (kk in seq_along(NAMES)) {
[13:37:45.069]                   name <- added[[kk]]
[13:37:45.069]                   NAME <- NAMES[[kk]]
[13:37:45.069]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.069]                     next
[13:37:45.069]                   args[[name]] <- ""
[13:37:45.069]                 }
[13:37:45.069]                 NAMES <- toupper(removed)
[13:37:45.069]                 for (kk in seq_along(NAMES)) {
[13:37:45.069]                   name <- removed[[kk]]
[13:37:45.069]                   NAME <- NAMES[[kk]]
[13:37:45.069]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.069]                     next
[13:37:45.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.069]                 }
[13:37:45.069]                 if (length(args) > 0) 
[13:37:45.069]                   base::do.call(base::Sys.setenv, args = args)
[13:37:45.069]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:45.069]             }
[13:37:45.069]             else {
[13:37:45.069]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:45.069]             }
[13:37:45.069]             {
[13:37:45.069]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:45.069]                   0L) {
[13:37:45.069]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:45.069]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:45.069]                   base::options(opts)
[13:37:45.069]                 }
[13:37:45.069]                 {
[13:37:45.069]                   {
[13:37:45.069]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:45.069]                     NULL
[13:37:45.069]                   }
[13:37:45.069]                   options(future.plan = NULL)
[13:37:45.069]                   if (is.na(NA_character_)) 
[13:37:45.069]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.069]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:45.069]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:45.069]                     .init = FALSE)
[13:37:45.069]                 }
[13:37:45.069]             }
[13:37:45.069]         }
[13:37:45.069]     })
[13:37:45.069]     if (TRUE) {
[13:37:45.069]         base::sink(type = "output", split = FALSE)
[13:37:45.069]         if (TRUE) {
[13:37:45.069]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:45.069]         }
[13:37:45.069]         else {
[13:37:45.069]             ...future.result["stdout"] <- base::list(NULL)
[13:37:45.069]         }
[13:37:45.069]         base::close(...future.stdout)
[13:37:45.069]         ...future.stdout <- NULL
[13:37:45.069]     }
[13:37:45.069]     ...future.result$conditions <- ...future.conditions
[13:37:45.069]     ...future.result$finished <- base::Sys.time()
[13:37:45.069]     ...future.result
[13:37:45.069] }
[13:37:45.073] assign_globals() ...
[13:37:45.073] List of 1
[13:37:45.073]  $ kk: int 3
[13:37:45.073]  - attr(*, "where")=List of 1
[13:37:45.073]   ..$ kk:<environment: R_EmptyEnv> 
[13:37:45.073]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:37:45.073]  - attr(*, "resolved")= logi FALSE
[13:37:45.073]  - attr(*, "total_size")= num 56
[13:37:45.073]  - attr(*, "already-done")= logi TRUE
[13:37:45.084] - copied ‘kk’ to environment
[13:37:45.084] assign_globals() ... done
[13:37:45.084] requestCore(): workers = 2
[13:37:45.085] Poll #1 (0): usedCores() = 2, workers = 2
[13:37:45.100] plan(): Setting new future strategy stack:
[13:37:45.101] List of future strategies:
[13:37:45.101] 1. multicore:
[13:37:45.101]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:37:45.101]    - tweaked: FALSE
[13:37:45.101]    - call: plan(strategy)
[13:37:45.106] plan(): nbrOfWorkers() = 2
[13:37:45.117] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[13:37:45.128] result() for MulticoreFuture ...
[13:37:45.129] result() for MulticoreFuture ...
[13:37:45.129] result() for MulticoreFuture ... done
[13:37:45.129] result() for MulticoreFuture ... done
[13:37:45.129] result() for MulticoreFuture ...
[13:37:45.130] result() for MulticoreFuture ... done
[13:37:45.133] MulticoreFuture started
[13:37:45.133] - Launch lazy future ... done
[13:37:45.134] run() for ‘MulticoreFuture’ ... done
[13:37:45.134] plan(): Setting new future strategy stack:
[13:37:45.135] List of future strategies:
[13:37:45.135] 1. sequential:
[13:37:45.135]    - args: function (..., envir = parent.frame())
[13:37:45.135]    - tweaked: FALSE
[13:37:45.135]    - call: NULL
[13:37:45.136] plan(): nbrOfWorkers() = 1
[13:37:45.149] plan(): Setting new future strategy stack:
[13:37:45.150] List of future strategies:
[13:37:45.150] 1. multicore:
[13:37:45.150]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:37:45.150]    - tweaked: FALSE
[13:37:45.150]    - call: plan(strategy)
[13:37:45.154] plan(): nbrOfWorkers() = 2
[13:37:45.155] Future #1
[13:37:45.155]  length: 2 (resolved future 1)
[13:37:45.156] Future #2
[13:37:45.156]  length: 1 (resolved future 2)
[13:37:45.239] plan(): Setting new future strategy stack:
[13:37:45.240] List of future strategies:
[13:37:45.240] 1. multicore:
[13:37:45.240]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:37:45.240]    - tweaked: FALSE
[13:37:45.240]    - call: plan(strategy)
[13:37:45.245] plan(): nbrOfWorkers() = 2
[13:37:45.246] Future #3
[13:37:45.246]  length: 0 (resolved future 3)
[13:37:45.246] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[13:37:45.248] resolve() on environment ...
[13:37:45.248]  recursive: 0
[13:37:45.249]  elements: [2] ‘a’, ‘b’
[13:37:45.249]  length: 1 (resolved future 1)
[13:37:45.249]  length: 0 (resolved future 2)
[13:37:45.249] resolve() on environment ... DONE
[13:37:45.250] getGlobalsAndPackages() ...
[13:37:45.250] Searching for globals...
[13:37:45.251] 
[13:37:45.251] Searching for globals ... DONE
[13:37:45.251] - globals: [0] <none>
[13:37:45.251] getGlobalsAndPackages() ... DONE
[13:37:45.252] run() for ‘Future’ ...
[13:37:45.252] - state: ‘created’
[13:37:45.252] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:37:45.257] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:45.258] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:37:45.258]   - Field: ‘label’
[13:37:45.258]   - Field: ‘local’
[13:37:45.258]   - Field: ‘owner’
[13:37:45.258]   - Field: ‘envir’
[13:37:45.258]   - Field: ‘workers’
[13:37:45.259]   - Field: ‘packages’
[13:37:45.259]   - Field: ‘gc’
[13:37:45.259]   - Field: ‘job’
[13:37:45.259]   - Field: ‘conditions’
[13:37:45.259]   - Field: ‘expr’
[13:37:45.259]   - Field: ‘uuid’
[13:37:45.260]   - Field: ‘seed’
[13:37:45.260]   - Field: ‘version’
[13:37:45.260]   - Field: ‘result’
[13:37:45.260]   - Field: ‘asynchronous’
[13:37:45.260]   - Field: ‘calls’
[13:37:45.260]   - Field: ‘globals’
[13:37:45.261]   - Field: ‘stdout’
[13:37:45.261]   - Field: ‘earlySignal’
[13:37:45.261]   - Field: ‘lazy’
[13:37:45.261]   - Field: ‘state’
[13:37:45.261] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:37:45.261] - Launch lazy future ...
[13:37:45.262] Packages needed by the future expression (n = 0): <none>
[13:37:45.262] Packages needed by future strategies (n = 0): <none>
[13:37:45.263] {
[13:37:45.263]     {
[13:37:45.263]         {
[13:37:45.263]             ...future.startTime <- base::Sys.time()
[13:37:45.263]             {
[13:37:45.263]                 {
[13:37:45.263]                   {
[13:37:45.263]                     {
[13:37:45.263]                       base::local({
[13:37:45.263]                         has_future <- base::requireNamespace("future", 
[13:37:45.263]                           quietly = TRUE)
[13:37:45.263]                         if (has_future) {
[13:37:45.263]                           ns <- base::getNamespace("future")
[13:37:45.263]                           version <- ns[[".package"]][["version"]]
[13:37:45.263]                           if (is.null(version)) 
[13:37:45.263]                             version <- utils::packageVersion("future")
[13:37:45.263]                         }
[13:37:45.263]                         else {
[13:37:45.263]                           version <- NULL
[13:37:45.263]                         }
[13:37:45.263]                         if (!has_future || version < "1.8.0") {
[13:37:45.263]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:45.263]                             "", base::R.version$version.string), 
[13:37:45.263]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:45.263]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:45.263]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:45.263]                               "release", "version")], collapse = " "), 
[13:37:45.263]                             hostname = base::Sys.info()[["nodename"]])
[13:37:45.263]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:45.263]                             info)
[13:37:45.263]                           info <- base::paste(info, collapse = "; ")
[13:37:45.263]                           if (!has_future) {
[13:37:45.263]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:45.263]                               info)
[13:37:45.263]                           }
[13:37:45.263]                           else {
[13:37:45.263]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:45.263]                               info, version)
[13:37:45.263]                           }
[13:37:45.263]                           base::stop(msg)
[13:37:45.263]                         }
[13:37:45.263]                       })
[13:37:45.263]                     }
[13:37:45.263]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:45.263]                     base::options(mc.cores = 1L)
[13:37:45.263]                   }
[13:37:45.263]                   ...future.strategy.old <- future::plan("list")
[13:37:45.263]                   options(future.plan = NULL)
[13:37:45.263]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.263]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:45.263]                 }
[13:37:45.263]                 ...future.workdir <- getwd()
[13:37:45.263]             }
[13:37:45.263]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:45.263]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:45.263]         }
[13:37:45.263]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:45.263]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:45.263]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:45.263]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:45.263]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:45.263]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:45.263]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:45.263]             base::names(...future.oldOptions))
[13:37:45.263]     }
[13:37:45.263]     if (FALSE) {
[13:37:45.263]     }
[13:37:45.263]     else {
[13:37:45.263]         if (TRUE) {
[13:37:45.263]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:45.263]                 open = "w")
[13:37:45.263]         }
[13:37:45.263]         else {
[13:37:45.263]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:45.263]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:45.263]         }
[13:37:45.263]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:45.263]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:45.263]             base::sink(type = "output", split = FALSE)
[13:37:45.263]             base::close(...future.stdout)
[13:37:45.263]         }, add = TRUE)
[13:37:45.263]     }
[13:37:45.263]     ...future.frame <- base::sys.nframe()
[13:37:45.263]     ...future.conditions <- base::list()
[13:37:45.263]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:45.263]     if (FALSE) {
[13:37:45.263]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:45.263]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:45.263]     }
[13:37:45.263]     ...future.result <- base::tryCatch({
[13:37:45.263]         base::withCallingHandlers({
[13:37:45.263]             ...future.value <- base::withVisible(base::local({
[13:37:45.263]                 withCallingHandlers({
[13:37:45.263]                   1
[13:37:45.263]                 }, immediateCondition = function(cond) {
[13:37:45.263]                   save_rds <- function (object, pathname, ...) 
[13:37:45.263]                   {
[13:37:45.263]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:37:45.263]                     if (file_test("-f", pathname_tmp)) {
[13:37:45.263]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.263]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:37:45.263]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.263]                         fi_tmp[["mtime"]])
[13:37:45.263]                     }
[13:37:45.263]                     tryCatch({
[13:37:45.263]                       saveRDS(object, file = pathname_tmp, ...)
[13:37:45.263]                     }, error = function(ex) {
[13:37:45.263]                       msg <- conditionMessage(ex)
[13:37:45.263]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.263]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:37:45.263]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.263]                         fi_tmp[["mtime"]], msg)
[13:37:45.263]                       ex$message <- msg
[13:37:45.263]                       stop(ex)
[13:37:45.263]                     })
[13:37:45.263]                     stopifnot(file_test("-f", pathname_tmp))
[13:37:45.263]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:37:45.263]                     if (!res || file_test("-f", pathname_tmp)) {
[13:37:45.263]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.263]                       fi <- file.info(pathname)
[13:37:45.263]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:37:45.263]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.263]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:37:45.263]                         fi[["size"]], fi[["mtime"]])
[13:37:45.263]                       stop(msg)
[13:37:45.263]                     }
[13:37:45.263]                     invisible(pathname)
[13:37:45.263]                   }
[13:37:45.263]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:37:45.263]                     rootPath = tempdir()) 
[13:37:45.263]                   {
[13:37:45.263]                     obj <- list(time = Sys.time(), condition = cond)
[13:37:45.263]                     file <- tempfile(pattern = class(cond)[1], 
[13:37:45.263]                       tmpdir = path, fileext = ".rds")
[13:37:45.263]                     save_rds(obj, file)
[13:37:45.263]                   }
[13:37:45.263]                   saveImmediateCondition(cond, path = "/tmp/RtmpLAMaHJ/.future/immediateConditions")
[13:37:45.263]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.263]                   {
[13:37:45.263]                     inherits <- base::inherits
[13:37:45.263]                     invokeRestart <- base::invokeRestart
[13:37:45.263]                     is.null <- base::is.null
[13:37:45.263]                     muffled <- FALSE
[13:37:45.263]                     if (inherits(cond, "message")) {
[13:37:45.263]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:45.263]                       if (muffled) 
[13:37:45.263]                         invokeRestart("muffleMessage")
[13:37:45.263]                     }
[13:37:45.263]                     else if (inherits(cond, "warning")) {
[13:37:45.263]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:45.263]                       if (muffled) 
[13:37:45.263]                         invokeRestart("muffleWarning")
[13:37:45.263]                     }
[13:37:45.263]                     else if (inherits(cond, "condition")) {
[13:37:45.263]                       if (!is.null(pattern)) {
[13:37:45.263]                         computeRestarts <- base::computeRestarts
[13:37:45.263]                         grepl <- base::grepl
[13:37:45.263]                         restarts <- computeRestarts(cond)
[13:37:45.263]                         for (restart in restarts) {
[13:37:45.263]                           name <- restart$name
[13:37:45.263]                           if (is.null(name)) 
[13:37:45.263]                             next
[13:37:45.263]                           if (!grepl(pattern, name)) 
[13:37:45.263]                             next
[13:37:45.263]                           invokeRestart(restart)
[13:37:45.263]                           muffled <- TRUE
[13:37:45.263]                           break
[13:37:45.263]                         }
[13:37:45.263]                       }
[13:37:45.263]                     }
[13:37:45.263]                     invisible(muffled)
[13:37:45.263]                   }
[13:37:45.263]                   muffleCondition(cond)
[13:37:45.263]                 })
[13:37:45.263]             }))
[13:37:45.263]             future::FutureResult(value = ...future.value$value, 
[13:37:45.263]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.263]                   ...future.rng), globalenv = if (FALSE) 
[13:37:45.263]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:45.263]                     ...future.globalenv.names))
[13:37:45.263]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:45.263]         }, condition = base::local({
[13:37:45.263]             c <- base::c
[13:37:45.263]             inherits <- base::inherits
[13:37:45.263]             invokeRestart <- base::invokeRestart
[13:37:45.263]             length <- base::length
[13:37:45.263]             list <- base::list
[13:37:45.263]             seq.int <- base::seq.int
[13:37:45.263]             signalCondition <- base::signalCondition
[13:37:45.263]             sys.calls <- base::sys.calls
[13:37:45.263]             `[[` <- base::`[[`
[13:37:45.263]             `+` <- base::`+`
[13:37:45.263]             `<<-` <- base::`<<-`
[13:37:45.263]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:45.263]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:45.263]                   3L)]
[13:37:45.263]             }
[13:37:45.263]             function(cond) {
[13:37:45.263]                 is_error <- inherits(cond, "error")
[13:37:45.263]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:45.263]                   NULL)
[13:37:45.263]                 if (is_error) {
[13:37:45.263]                   sessionInformation <- function() {
[13:37:45.263]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:45.263]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:45.263]                       search = base::search(), system = base::Sys.info())
[13:37:45.263]                   }
[13:37:45.263]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.263]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:45.263]                     cond$call), session = sessionInformation(), 
[13:37:45.263]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:45.263]                   signalCondition(cond)
[13:37:45.263]                 }
[13:37:45.263]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:45.263]                 "immediateCondition"))) {
[13:37:45.263]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:45.263]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.263]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:45.263]                   if (TRUE && !signal) {
[13:37:45.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.263]                     {
[13:37:45.263]                       inherits <- base::inherits
[13:37:45.263]                       invokeRestart <- base::invokeRestart
[13:37:45.263]                       is.null <- base::is.null
[13:37:45.263]                       muffled <- FALSE
[13:37:45.263]                       if (inherits(cond, "message")) {
[13:37:45.263]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.263]                         if (muffled) 
[13:37:45.263]                           invokeRestart("muffleMessage")
[13:37:45.263]                       }
[13:37:45.263]                       else if (inherits(cond, "warning")) {
[13:37:45.263]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.263]                         if (muffled) 
[13:37:45.263]                           invokeRestart("muffleWarning")
[13:37:45.263]                       }
[13:37:45.263]                       else if (inherits(cond, "condition")) {
[13:37:45.263]                         if (!is.null(pattern)) {
[13:37:45.263]                           computeRestarts <- base::computeRestarts
[13:37:45.263]                           grepl <- base::grepl
[13:37:45.263]                           restarts <- computeRestarts(cond)
[13:37:45.263]                           for (restart in restarts) {
[13:37:45.263]                             name <- restart$name
[13:37:45.263]                             if (is.null(name)) 
[13:37:45.263]                               next
[13:37:45.263]                             if (!grepl(pattern, name)) 
[13:37:45.263]                               next
[13:37:45.263]                             invokeRestart(restart)
[13:37:45.263]                             muffled <- TRUE
[13:37:45.263]                             break
[13:37:45.263]                           }
[13:37:45.263]                         }
[13:37:45.263]                       }
[13:37:45.263]                       invisible(muffled)
[13:37:45.263]                     }
[13:37:45.263]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.263]                   }
[13:37:45.263]                 }
[13:37:45.263]                 else {
[13:37:45.263]                   if (TRUE) {
[13:37:45.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.263]                     {
[13:37:45.263]                       inherits <- base::inherits
[13:37:45.263]                       invokeRestart <- base::invokeRestart
[13:37:45.263]                       is.null <- base::is.null
[13:37:45.263]                       muffled <- FALSE
[13:37:45.263]                       if (inherits(cond, "message")) {
[13:37:45.263]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.263]                         if (muffled) 
[13:37:45.263]                           invokeRestart("muffleMessage")
[13:37:45.263]                       }
[13:37:45.263]                       else if (inherits(cond, "warning")) {
[13:37:45.263]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.263]                         if (muffled) 
[13:37:45.263]                           invokeRestart("muffleWarning")
[13:37:45.263]                       }
[13:37:45.263]                       else if (inherits(cond, "condition")) {
[13:37:45.263]                         if (!is.null(pattern)) {
[13:37:45.263]                           computeRestarts <- base::computeRestarts
[13:37:45.263]                           grepl <- base::grepl
[13:37:45.263]                           restarts <- computeRestarts(cond)
[13:37:45.263]                           for (restart in restarts) {
[13:37:45.263]                             name <- restart$name
[13:37:45.263]                             if (is.null(name)) 
[13:37:45.263]                               next
[13:37:45.263]                             if (!grepl(pattern, name)) 
[13:37:45.263]                               next
[13:37:45.263]                             invokeRestart(restart)
[13:37:45.263]                             muffled <- TRUE
[13:37:45.263]                             break
[13:37:45.263]                           }
[13:37:45.263]                         }
[13:37:45.263]                       }
[13:37:45.263]                       invisible(muffled)
[13:37:45.263]                     }
[13:37:45.263]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.263]                   }
[13:37:45.263]                 }
[13:37:45.263]             }
[13:37:45.263]         }))
[13:37:45.263]     }, error = function(ex) {
[13:37:45.263]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:45.263]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.263]                 ...future.rng), started = ...future.startTime, 
[13:37:45.263]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:45.263]             version = "1.8"), class = "FutureResult")
[13:37:45.263]     }, finally = {
[13:37:45.263]         if (!identical(...future.workdir, getwd())) 
[13:37:45.263]             setwd(...future.workdir)
[13:37:45.263]         {
[13:37:45.263]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:45.263]                 ...future.oldOptions$nwarnings <- NULL
[13:37:45.263]             }
[13:37:45.263]             base::options(...future.oldOptions)
[13:37:45.263]             if (.Platform$OS.type == "windows") {
[13:37:45.263]                 old_names <- names(...future.oldEnvVars)
[13:37:45.263]                 envs <- base::Sys.getenv()
[13:37:45.263]                 names <- names(envs)
[13:37:45.263]                 common <- intersect(names, old_names)
[13:37:45.263]                 added <- setdiff(names, old_names)
[13:37:45.263]                 removed <- setdiff(old_names, names)
[13:37:45.263]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:45.263]                   envs[common]]
[13:37:45.263]                 NAMES <- toupper(changed)
[13:37:45.263]                 args <- list()
[13:37:45.263]                 for (kk in seq_along(NAMES)) {
[13:37:45.263]                   name <- changed[[kk]]
[13:37:45.263]                   NAME <- NAMES[[kk]]
[13:37:45.263]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.263]                     next
[13:37:45.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.263]                 }
[13:37:45.263]                 NAMES <- toupper(added)
[13:37:45.263]                 for (kk in seq_along(NAMES)) {
[13:37:45.263]                   name <- added[[kk]]
[13:37:45.263]                   NAME <- NAMES[[kk]]
[13:37:45.263]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.263]                     next
[13:37:45.263]                   args[[name]] <- ""
[13:37:45.263]                 }
[13:37:45.263]                 NAMES <- toupper(removed)
[13:37:45.263]                 for (kk in seq_along(NAMES)) {
[13:37:45.263]                   name <- removed[[kk]]
[13:37:45.263]                   NAME <- NAMES[[kk]]
[13:37:45.263]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.263]                     next
[13:37:45.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.263]                 }
[13:37:45.263]                 if (length(args) > 0) 
[13:37:45.263]                   base::do.call(base::Sys.setenv, args = args)
[13:37:45.263]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:45.263]             }
[13:37:45.263]             else {
[13:37:45.263]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:45.263]             }
[13:37:45.263]             {
[13:37:45.263]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:45.263]                   0L) {
[13:37:45.263]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:45.263]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:45.263]                   base::options(opts)
[13:37:45.263]                 }
[13:37:45.263]                 {
[13:37:45.263]                   {
[13:37:45.263]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:45.263]                     NULL
[13:37:45.263]                   }
[13:37:45.263]                   options(future.plan = NULL)
[13:37:45.263]                   if (is.na(NA_character_)) 
[13:37:45.263]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.263]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:45.263]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:45.263]                     .init = FALSE)
[13:37:45.263]                 }
[13:37:45.263]             }
[13:37:45.263]         }
[13:37:45.263]     })
[13:37:45.263]     if (TRUE) {
[13:37:45.263]         base::sink(type = "output", split = FALSE)
[13:37:45.263]         if (TRUE) {
[13:37:45.263]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:45.263]         }
[13:37:45.263]         else {
[13:37:45.263]             ...future.result["stdout"] <- base::list(NULL)
[13:37:45.263]         }
[13:37:45.263]         base::close(...future.stdout)
[13:37:45.263]         ...future.stdout <- NULL
[13:37:45.263]     }
[13:37:45.263]     ...future.result$conditions <- ...future.conditions
[13:37:45.263]     ...future.result$finished <- base::Sys.time()
[13:37:45.263]     ...future.result
[13:37:45.263] }
[13:37:45.267] requestCore(): workers = 2
[13:37:45.267] Poll #1 (0): usedCores() = 2, workers = 2
[13:37:45.278] result() for MulticoreFuture ...
[13:37:45.279] result() for MulticoreFuture ...
[13:37:45.279] result() for MulticoreFuture ... done
[13:37:45.279] result() for MulticoreFuture ... done
[13:37:45.280] result() for MulticoreFuture ...
[13:37:45.280] result() for MulticoreFuture ... done
[13:37:45.283] MulticoreFuture started
[13:37:45.284] - Launch lazy future ... done
[13:37:45.284] run() for ‘MulticoreFuture’ ... done
[13:37:45.284] getGlobalsAndPackages() ...
[13:37:45.285] plan(): Setting new future strategy stack:
[13:37:45.285] Searching for globals...
[13:37:45.285] List of future strategies:
[13:37:45.285] 1. sequential:
[13:37:45.285]    - args: function (..., envir = parent.frame())
[13:37:45.285]    - tweaked: FALSE
[13:37:45.285]    - call: NULL
[13:37:45.286] 
[13:37:45.286] Searching for globals ... DONE
[13:37:45.286] plan(): nbrOfWorkers() = 1
[13:37:45.286] - globals: [0] <none>
[13:37:45.286] getGlobalsAndPackages() ... DONE
[13:37:45.287] run() for ‘Future’ ...
[13:37:45.287] - state: ‘created’
[13:37:45.287] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:37:45.288] plan(): Setting new future strategy stack:
[13:37:45.288] List of future strategies:
[13:37:45.288] 1. multicore:
[13:37:45.288]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:37:45.288]    - tweaked: FALSE
[13:37:45.288]    - call: plan(strategy)
[13:37:45.293] plan(): nbrOfWorkers() = 2
[13:37:45.293] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:45.294] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:37:45.294]   - Field: ‘label’
[13:37:45.294]   - Field: ‘local’
[13:37:45.294]   - Field: ‘owner’
[13:37:45.294]   - Field: ‘envir’
[13:37:45.295]   - Field: ‘workers’
[13:37:45.295]   - Field: ‘packages’
[13:37:45.295]   - Field: ‘gc’
[13:37:45.295]   - Field: ‘job’
[13:37:45.295]   - Field: ‘conditions’
[13:37:45.295]   - Field: ‘expr’
[13:37:45.296]   - Field: ‘uuid’
[13:37:45.296]   - Field: ‘seed’
[13:37:45.296]   - Field: ‘version’
[13:37:45.296]   - Field: ‘result’
[13:37:45.296]   - Field: ‘asynchronous’
[13:37:45.296]   - Field: ‘calls’
[13:37:45.297]   - Field: ‘globals’
[13:37:45.297]   - Field: ‘stdout’
[13:37:45.297]   - Field: ‘earlySignal’
[13:37:45.297]   - Field: ‘lazy’
[13:37:45.297]   - Field: ‘state’
[13:37:45.297] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:37:45.297] - Launch lazy future ...
[13:37:45.298] Packages needed by the future expression (n = 0): <none>
[13:37:45.298] Packages needed by future strategies (n = 0): <none>
[13:37:45.299] {
[13:37:45.299]     {
[13:37:45.299]         {
[13:37:45.299]             ...future.startTime <- base::Sys.time()
[13:37:45.299]             {
[13:37:45.299]                 {
[13:37:45.299]                   {
[13:37:45.299]                     {
[13:37:45.299]                       base::local({
[13:37:45.299]                         has_future <- base::requireNamespace("future", 
[13:37:45.299]                           quietly = TRUE)
[13:37:45.299]                         if (has_future) {
[13:37:45.299]                           ns <- base::getNamespace("future")
[13:37:45.299]                           version <- ns[[".package"]][["version"]]
[13:37:45.299]                           if (is.null(version)) 
[13:37:45.299]                             version <- utils::packageVersion("future")
[13:37:45.299]                         }
[13:37:45.299]                         else {
[13:37:45.299]                           version <- NULL
[13:37:45.299]                         }
[13:37:45.299]                         if (!has_future || version < "1.8.0") {
[13:37:45.299]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:45.299]                             "", base::R.version$version.string), 
[13:37:45.299]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:45.299]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:45.299]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:45.299]                               "release", "version")], collapse = " "), 
[13:37:45.299]                             hostname = base::Sys.info()[["nodename"]])
[13:37:45.299]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:45.299]                             info)
[13:37:45.299]                           info <- base::paste(info, collapse = "; ")
[13:37:45.299]                           if (!has_future) {
[13:37:45.299]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:45.299]                               info)
[13:37:45.299]                           }
[13:37:45.299]                           else {
[13:37:45.299]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:45.299]                               info, version)
[13:37:45.299]                           }
[13:37:45.299]                           base::stop(msg)
[13:37:45.299]                         }
[13:37:45.299]                       })
[13:37:45.299]                     }
[13:37:45.299]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:45.299]                     base::options(mc.cores = 1L)
[13:37:45.299]                   }
[13:37:45.299]                   ...future.strategy.old <- future::plan("list")
[13:37:45.299]                   options(future.plan = NULL)
[13:37:45.299]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.299]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:45.299]                 }
[13:37:45.299]                 ...future.workdir <- getwd()
[13:37:45.299]             }
[13:37:45.299]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:45.299]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:45.299]         }
[13:37:45.299]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:45.299]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:45.299]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:45.299]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:45.299]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:45.299]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:45.299]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:45.299]             base::names(...future.oldOptions))
[13:37:45.299]     }
[13:37:45.299]     if (FALSE) {
[13:37:45.299]     }
[13:37:45.299]     else {
[13:37:45.299]         if (TRUE) {
[13:37:45.299]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:45.299]                 open = "w")
[13:37:45.299]         }
[13:37:45.299]         else {
[13:37:45.299]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:45.299]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:45.299]         }
[13:37:45.299]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:45.299]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:45.299]             base::sink(type = "output", split = FALSE)
[13:37:45.299]             base::close(...future.stdout)
[13:37:45.299]         }, add = TRUE)
[13:37:45.299]     }
[13:37:45.299]     ...future.frame <- base::sys.nframe()
[13:37:45.299]     ...future.conditions <- base::list()
[13:37:45.299]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:45.299]     if (FALSE) {
[13:37:45.299]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:45.299]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:45.299]     }
[13:37:45.299]     ...future.result <- base::tryCatch({
[13:37:45.299]         base::withCallingHandlers({
[13:37:45.299]             ...future.value <- base::withVisible(base::local({
[13:37:45.299]                 withCallingHandlers({
[13:37:45.299]                   2
[13:37:45.299]                 }, immediateCondition = function(cond) {
[13:37:45.299]                   save_rds <- function (object, pathname, ...) 
[13:37:45.299]                   {
[13:37:45.299]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:37:45.299]                     if (file_test("-f", pathname_tmp)) {
[13:37:45.299]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.299]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:37:45.299]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.299]                         fi_tmp[["mtime"]])
[13:37:45.299]                     }
[13:37:45.299]                     tryCatch({
[13:37:45.299]                       saveRDS(object, file = pathname_tmp, ...)
[13:37:45.299]                     }, error = function(ex) {
[13:37:45.299]                       msg <- conditionMessage(ex)
[13:37:45.299]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.299]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:37:45.299]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.299]                         fi_tmp[["mtime"]], msg)
[13:37:45.299]                       ex$message <- msg
[13:37:45.299]                       stop(ex)
[13:37:45.299]                     })
[13:37:45.299]                     stopifnot(file_test("-f", pathname_tmp))
[13:37:45.299]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:37:45.299]                     if (!res || file_test("-f", pathname_tmp)) {
[13:37:45.299]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.299]                       fi <- file.info(pathname)
[13:37:45.299]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:37:45.299]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.299]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:37:45.299]                         fi[["size"]], fi[["mtime"]])
[13:37:45.299]                       stop(msg)
[13:37:45.299]                     }
[13:37:45.299]                     invisible(pathname)
[13:37:45.299]                   }
[13:37:45.299]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:37:45.299]                     rootPath = tempdir()) 
[13:37:45.299]                   {
[13:37:45.299]                     obj <- list(time = Sys.time(), condition = cond)
[13:37:45.299]                     file <- tempfile(pattern = class(cond)[1], 
[13:37:45.299]                       tmpdir = path, fileext = ".rds")
[13:37:45.299]                     save_rds(obj, file)
[13:37:45.299]                   }
[13:37:45.299]                   saveImmediateCondition(cond, path = "/tmp/RtmpLAMaHJ/.future/immediateConditions")
[13:37:45.299]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.299]                   {
[13:37:45.299]                     inherits <- base::inherits
[13:37:45.299]                     invokeRestart <- base::invokeRestart
[13:37:45.299]                     is.null <- base::is.null
[13:37:45.299]                     muffled <- FALSE
[13:37:45.299]                     if (inherits(cond, "message")) {
[13:37:45.299]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:45.299]                       if (muffled) 
[13:37:45.299]                         invokeRestart("muffleMessage")
[13:37:45.299]                     }
[13:37:45.299]                     else if (inherits(cond, "warning")) {
[13:37:45.299]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:45.299]                       if (muffled) 
[13:37:45.299]                         invokeRestart("muffleWarning")
[13:37:45.299]                     }
[13:37:45.299]                     else if (inherits(cond, "condition")) {
[13:37:45.299]                       if (!is.null(pattern)) {
[13:37:45.299]                         computeRestarts <- base::computeRestarts
[13:37:45.299]                         grepl <- base::grepl
[13:37:45.299]                         restarts <- computeRestarts(cond)
[13:37:45.299]                         for (restart in restarts) {
[13:37:45.299]                           name <- restart$name
[13:37:45.299]                           if (is.null(name)) 
[13:37:45.299]                             next
[13:37:45.299]                           if (!grepl(pattern, name)) 
[13:37:45.299]                             next
[13:37:45.299]                           invokeRestart(restart)
[13:37:45.299]                           muffled <- TRUE
[13:37:45.299]                           break
[13:37:45.299]                         }
[13:37:45.299]                       }
[13:37:45.299]                     }
[13:37:45.299]                     invisible(muffled)
[13:37:45.299]                   }
[13:37:45.299]                   muffleCondition(cond)
[13:37:45.299]                 })
[13:37:45.299]             }))
[13:37:45.299]             future::FutureResult(value = ...future.value$value, 
[13:37:45.299]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.299]                   ...future.rng), globalenv = if (FALSE) 
[13:37:45.299]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:45.299]                     ...future.globalenv.names))
[13:37:45.299]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:45.299]         }, condition = base::local({
[13:37:45.299]             c <- base::c
[13:37:45.299]             inherits <- base::inherits
[13:37:45.299]             invokeRestart <- base::invokeRestart
[13:37:45.299]             length <- base::length
[13:37:45.299]             list <- base::list
[13:37:45.299]             seq.int <- base::seq.int
[13:37:45.299]             signalCondition <- base::signalCondition
[13:37:45.299]             sys.calls <- base::sys.calls
[13:37:45.299]             `[[` <- base::`[[`
[13:37:45.299]             `+` <- base::`+`
[13:37:45.299]             `<<-` <- base::`<<-`
[13:37:45.299]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:45.299]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:45.299]                   3L)]
[13:37:45.299]             }
[13:37:45.299]             function(cond) {
[13:37:45.299]                 is_error <- inherits(cond, "error")
[13:37:45.299]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:45.299]                   NULL)
[13:37:45.299]                 if (is_error) {
[13:37:45.299]                   sessionInformation <- function() {
[13:37:45.299]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:45.299]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:45.299]                       search = base::search(), system = base::Sys.info())
[13:37:45.299]                   }
[13:37:45.299]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.299]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:45.299]                     cond$call), session = sessionInformation(), 
[13:37:45.299]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:45.299]                   signalCondition(cond)
[13:37:45.299]                 }
[13:37:45.299]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:45.299]                 "immediateCondition"))) {
[13:37:45.299]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:45.299]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.299]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:45.299]                   if (TRUE && !signal) {
[13:37:45.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.299]                     {
[13:37:45.299]                       inherits <- base::inherits
[13:37:45.299]                       invokeRestart <- base::invokeRestart
[13:37:45.299]                       is.null <- base::is.null
[13:37:45.299]                       muffled <- FALSE
[13:37:45.299]                       if (inherits(cond, "message")) {
[13:37:45.299]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.299]                         if (muffled) 
[13:37:45.299]                           invokeRestart("muffleMessage")
[13:37:45.299]                       }
[13:37:45.299]                       else if (inherits(cond, "warning")) {
[13:37:45.299]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.299]                         if (muffled) 
[13:37:45.299]                           invokeRestart("muffleWarning")
[13:37:45.299]                       }
[13:37:45.299]                       else if (inherits(cond, "condition")) {
[13:37:45.299]                         if (!is.null(pattern)) {
[13:37:45.299]                           computeRestarts <- base::computeRestarts
[13:37:45.299]                           grepl <- base::grepl
[13:37:45.299]                           restarts <- computeRestarts(cond)
[13:37:45.299]                           for (restart in restarts) {
[13:37:45.299]                             name <- restart$name
[13:37:45.299]                             if (is.null(name)) 
[13:37:45.299]                               next
[13:37:45.299]                             if (!grepl(pattern, name)) 
[13:37:45.299]                               next
[13:37:45.299]                             invokeRestart(restart)
[13:37:45.299]                             muffled <- TRUE
[13:37:45.299]                             break
[13:37:45.299]                           }
[13:37:45.299]                         }
[13:37:45.299]                       }
[13:37:45.299]                       invisible(muffled)
[13:37:45.299]                     }
[13:37:45.299]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.299]                   }
[13:37:45.299]                 }
[13:37:45.299]                 else {
[13:37:45.299]                   if (TRUE) {
[13:37:45.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.299]                     {
[13:37:45.299]                       inherits <- base::inherits
[13:37:45.299]                       invokeRestart <- base::invokeRestart
[13:37:45.299]                       is.null <- base::is.null
[13:37:45.299]                       muffled <- FALSE
[13:37:45.299]                       if (inherits(cond, "message")) {
[13:37:45.299]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.299]                         if (muffled) 
[13:37:45.299]                           invokeRestart("muffleMessage")
[13:37:45.299]                       }
[13:37:45.299]                       else if (inherits(cond, "warning")) {
[13:37:45.299]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.299]                         if (muffled) 
[13:37:45.299]                           invokeRestart("muffleWarning")
[13:37:45.299]                       }
[13:37:45.299]                       else if (inherits(cond, "condition")) {
[13:37:45.299]                         if (!is.null(pattern)) {
[13:37:45.299]                           computeRestarts <- base::computeRestarts
[13:37:45.299]                           grepl <- base::grepl
[13:37:45.299]                           restarts <- computeRestarts(cond)
[13:37:45.299]                           for (restart in restarts) {
[13:37:45.299]                             name <- restart$name
[13:37:45.299]                             if (is.null(name)) 
[13:37:45.299]                               next
[13:37:45.299]                             if (!grepl(pattern, name)) 
[13:37:45.299]                               next
[13:37:45.299]                             invokeRestart(restart)
[13:37:45.299]                             muffled <- TRUE
[13:37:45.299]                             break
[13:37:45.299]                           }
[13:37:45.299]                         }
[13:37:45.299]                       }
[13:37:45.299]                       invisible(muffled)
[13:37:45.299]                     }
[13:37:45.299]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.299]                   }
[13:37:45.299]                 }
[13:37:45.299]             }
[13:37:45.299]         }))
[13:37:45.299]     }, error = function(ex) {
[13:37:45.299]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:45.299]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.299]                 ...future.rng), started = ...future.startTime, 
[13:37:45.299]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:45.299]             version = "1.8"), class = "FutureResult")
[13:37:45.299]     }, finally = {
[13:37:45.299]         if (!identical(...future.workdir, getwd())) 
[13:37:45.299]             setwd(...future.workdir)
[13:37:45.299]         {
[13:37:45.299]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:45.299]                 ...future.oldOptions$nwarnings <- NULL
[13:37:45.299]             }
[13:37:45.299]             base::options(...future.oldOptions)
[13:37:45.299]             if (.Platform$OS.type == "windows") {
[13:37:45.299]                 old_names <- names(...future.oldEnvVars)
[13:37:45.299]                 envs <- base::Sys.getenv()
[13:37:45.299]                 names <- names(envs)
[13:37:45.299]                 common <- intersect(names, old_names)
[13:37:45.299]                 added <- setdiff(names, old_names)
[13:37:45.299]                 removed <- setdiff(old_names, names)
[13:37:45.299]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:45.299]                   envs[common]]
[13:37:45.299]                 NAMES <- toupper(changed)
[13:37:45.299]                 args <- list()
[13:37:45.299]                 for (kk in seq_along(NAMES)) {
[13:37:45.299]                   name <- changed[[kk]]
[13:37:45.299]                   NAME <- NAMES[[kk]]
[13:37:45.299]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.299]                     next
[13:37:45.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.299]                 }
[13:37:45.299]                 NAMES <- toupper(added)
[13:37:45.299]                 for (kk in seq_along(NAMES)) {
[13:37:45.299]                   name <- added[[kk]]
[13:37:45.299]                   NAME <- NAMES[[kk]]
[13:37:45.299]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.299]                     next
[13:37:45.299]                   args[[name]] <- ""
[13:37:45.299]                 }
[13:37:45.299]                 NAMES <- toupper(removed)
[13:37:45.299]                 for (kk in seq_along(NAMES)) {
[13:37:45.299]                   name <- removed[[kk]]
[13:37:45.299]                   NAME <- NAMES[[kk]]
[13:37:45.299]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.299]                     next
[13:37:45.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.299]                 }
[13:37:45.299]                 if (length(args) > 0) 
[13:37:45.299]                   base::do.call(base::Sys.setenv, args = args)
[13:37:45.299]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:45.299]             }
[13:37:45.299]             else {
[13:37:45.299]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:45.299]             }
[13:37:45.299]             {
[13:37:45.299]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:45.299]                   0L) {
[13:37:45.299]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:45.299]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:45.299]                   base::options(opts)
[13:37:45.299]                 }
[13:37:45.299]                 {
[13:37:45.299]                   {
[13:37:45.299]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:45.299]                     NULL
[13:37:45.299]                   }
[13:37:45.299]                   options(future.plan = NULL)
[13:37:45.299]                   if (is.na(NA_character_)) 
[13:37:45.299]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.299]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:45.299]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:45.299]                     .init = FALSE)
[13:37:45.299]                 }
[13:37:45.299]             }
[13:37:45.299]         }
[13:37:45.299]     })
[13:37:45.299]     if (TRUE) {
[13:37:45.299]         base::sink(type = "output", split = FALSE)
[13:37:45.299]         if (TRUE) {
[13:37:45.299]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:45.299]         }
[13:37:45.299]         else {
[13:37:45.299]             ...future.result["stdout"] <- base::list(NULL)
[13:37:45.299]         }
[13:37:45.299]         base::close(...future.stdout)
[13:37:45.299]         ...future.stdout <- NULL
[13:37:45.299]     }
[13:37:45.299]     ...future.result$conditions <- ...future.conditions
[13:37:45.299]     ...future.result$finished <- base::Sys.time()
[13:37:45.299]     ...future.result
[13:37:45.299] }
[13:37:45.303] requestCore(): workers = 2
[13:37:45.303] Poll #1 (0): usedCores() = 2, workers = 2
[13:37:45.314] result() for MulticoreFuture ...
[13:37:45.316] result() for MulticoreFuture ...
[13:37:45.316] result() for MulticoreFuture ... done
[13:37:45.316] result() for MulticoreFuture ... done
[13:37:45.316] result() for MulticoreFuture ...
[13:37:45.316] result() for MulticoreFuture ... done
[13:37:45.319] MulticoreFuture started
[13:37:45.327] - Launch lazy future ... done
[13:37:45.327] plan(): Setting new future strategy stack:
[13:37:45.327] run() for ‘MulticoreFuture’ ... done
[13:37:45.328] List of future strategies:
[13:37:45.328] 1. sequential:
[13:37:45.328]    - args: function (..., envir = parent.frame())
[13:37:45.328]    - tweaked: FALSE
[13:37:45.328]    - call: NULL
[13:37:45.330] plan(): nbrOfWorkers() = 1
[13:37:45.331] resolve() on environment ...
[13:37:45.331]  recursive: 0
[13:37:45.334] plan(): Setting new future strategy stack:
[13:37:45.334]  elements: [3] ‘a’, ‘b’, ‘c’
[13:37:45.335] Future #1
[13:37:45.334] List of future strategies:
[13:37:45.334] 1. multicore:
[13:37:45.334]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:37:45.334]    - tweaked: FALSE
[13:37:45.334]    - call: plan(strategy)
[13:37:45.336]  length: 2 (resolved future 1)
[13:37:45.341] plan(): nbrOfWorkers() = 2
[13:37:45.342] Future #2
[13:37:45.342]  length: 1 (resolved future 2)
[13:37:45.343]  length: 0 (resolved future 3)
[13:37:45.343] resolve() on environment ... DONE
[13:37:45.344] getGlobalsAndPackages() ...
[13:37:45.345] Searching for globals...
[13:37:45.346] - globals found: [1] ‘{’
[13:37:45.346] Searching for globals ... DONE
[13:37:45.347] Resolving globals: FALSE
[13:37:45.347] 
[13:37:45.348] 
[13:37:45.348] getGlobalsAndPackages() ... DONE
[13:37:45.348] run() for ‘Future’ ...
[13:37:45.348] - state: ‘created’
[13:37:45.349] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:37:45.353] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:45.354] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:37:45.354]   - Field: ‘label’
[13:37:45.354]   - Field: ‘local’
[13:37:45.354]   - Field: ‘owner’
[13:37:45.354]   - Field: ‘envir’
[13:37:45.354]   - Field: ‘workers’
[13:37:45.355]   - Field: ‘packages’
[13:37:45.355]   - Field: ‘gc’
[13:37:45.355]   - Field: ‘job’
[13:37:45.355]   - Field: ‘conditions’
[13:37:45.355]   - Field: ‘expr’
[13:37:45.355]   - Field: ‘uuid’
[13:37:45.356]   - Field: ‘seed’
[13:37:45.356]   - Field: ‘version’
[13:37:45.356]   - Field: ‘result’
[13:37:45.356]   - Field: ‘asynchronous’
[13:37:45.356]   - Field: ‘calls’
[13:37:45.356]   - Field: ‘globals’
[13:37:45.356]   - Field: ‘stdout’
[13:37:45.356]   - Field: ‘earlySignal’
[13:37:45.357]   - Field: ‘lazy’
[13:37:45.357]   - Field: ‘state’
[13:37:45.357] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:37:45.357] - Launch lazy future ...
[13:37:45.357] Packages needed by the future expression (n = 0): <none>
[13:37:45.358] Packages needed by future strategies (n = 0): <none>
[13:37:45.358] {
[13:37:45.358]     {
[13:37:45.358]         {
[13:37:45.358]             ...future.startTime <- base::Sys.time()
[13:37:45.358]             {
[13:37:45.358]                 {
[13:37:45.358]                   {
[13:37:45.358]                     {
[13:37:45.358]                       base::local({
[13:37:45.358]                         has_future <- base::requireNamespace("future", 
[13:37:45.358]                           quietly = TRUE)
[13:37:45.358]                         if (has_future) {
[13:37:45.358]                           ns <- base::getNamespace("future")
[13:37:45.358]                           version <- ns[[".package"]][["version"]]
[13:37:45.358]                           if (is.null(version)) 
[13:37:45.358]                             version <- utils::packageVersion("future")
[13:37:45.358]                         }
[13:37:45.358]                         else {
[13:37:45.358]                           version <- NULL
[13:37:45.358]                         }
[13:37:45.358]                         if (!has_future || version < "1.8.0") {
[13:37:45.358]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:45.358]                             "", base::R.version$version.string), 
[13:37:45.358]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:45.358]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:45.358]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:45.358]                               "release", "version")], collapse = " "), 
[13:37:45.358]                             hostname = base::Sys.info()[["nodename"]])
[13:37:45.358]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:45.358]                             info)
[13:37:45.358]                           info <- base::paste(info, collapse = "; ")
[13:37:45.358]                           if (!has_future) {
[13:37:45.358]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:45.358]                               info)
[13:37:45.358]                           }
[13:37:45.358]                           else {
[13:37:45.358]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:45.358]                               info, version)
[13:37:45.358]                           }
[13:37:45.358]                           base::stop(msg)
[13:37:45.358]                         }
[13:37:45.358]                       })
[13:37:45.358]                     }
[13:37:45.358]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:45.358]                     base::options(mc.cores = 1L)
[13:37:45.358]                   }
[13:37:45.358]                   ...future.strategy.old <- future::plan("list")
[13:37:45.358]                   options(future.plan = NULL)
[13:37:45.358]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.358]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:45.358]                 }
[13:37:45.358]                 ...future.workdir <- getwd()
[13:37:45.358]             }
[13:37:45.358]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:45.358]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:45.358]         }
[13:37:45.358]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:45.358]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:45.358]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:45.358]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:45.358]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:45.358]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:45.358]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:45.358]             base::names(...future.oldOptions))
[13:37:45.358]     }
[13:37:45.358]     if (FALSE) {
[13:37:45.358]     }
[13:37:45.358]     else {
[13:37:45.358]         if (TRUE) {
[13:37:45.358]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:45.358]                 open = "w")
[13:37:45.358]         }
[13:37:45.358]         else {
[13:37:45.358]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:45.358]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:45.358]         }
[13:37:45.358]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:45.358]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:45.358]             base::sink(type = "output", split = FALSE)
[13:37:45.358]             base::close(...future.stdout)
[13:37:45.358]         }, add = TRUE)
[13:37:45.358]     }
[13:37:45.358]     ...future.frame <- base::sys.nframe()
[13:37:45.358]     ...future.conditions <- base::list()
[13:37:45.358]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:45.358]     if (FALSE) {
[13:37:45.358]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:45.358]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:45.358]     }
[13:37:45.358]     ...future.result <- base::tryCatch({
[13:37:45.358]         base::withCallingHandlers({
[13:37:45.358]             ...future.value <- base::withVisible(base::local({
[13:37:45.358]                 withCallingHandlers({
[13:37:45.358]                   {
[13:37:45.358]                     1
[13:37:45.358]                   }
[13:37:45.358]                 }, immediateCondition = function(cond) {
[13:37:45.358]                   save_rds <- function (object, pathname, ...) 
[13:37:45.358]                   {
[13:37:45.358]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:37:45.358]                     if (file_test("-f", pathname_tmp)) {
[13:37:45.358]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.358]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:37:45.358]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.358]                         fi_tmp[["mtime"]])
[13:37:45.358]                     }
[13:37:45.358]                     tryCatch({
[13:37:45.358]                       saveRDS(object, file = pathname_tmp, ...)
[13:37:45.358]                     }, error = function(ex) {
[13:37:45.358]                       msg <- conditionMessage(ex)
[13:37:45.358]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.358]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:37:45.358]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.358]                         fi_tmp[["mtime"]], msg)
[13:37:45.358]                       ex$message <- msg
[13:37:45.358]                       stop(ex)
[13:37:45.358]                     })
[13:37:45.358]                     stopifnot(file_test("-f", pathname_tmp))
[13:37:45.358]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:37:45.358]                     if (!res || file_test("-f", pathname_tmp)) {
[13:37:45.358]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.358]                       fi <- file.info(pathname)
[13:37:45.358]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:37:45.358]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.358]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:37:45.358]                         fi[["size"]], fi[["mtime"]])
[13:37:45.358]                       stop(msg)
[13:37:45.358]                     }
[13:37:45.358]                     invisible(pathname)
[13:37:45.358]                   }
[13:37:45.358]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:37:45.358]                     rootPath = tempdir()) 
[13:37:45.358]                   {
[13:37:45.358]                     obj <- list(time = Sys.time(), condition = cond)
[13:37:45.358]                     file <- tempfile(pattern = class(cond)[1], 
[13:37:45.358]                       tmpdir = path, fileext = ".rds")
[13:37:45.358]                     save_rds(obj, file)
[13:37:45.358]                   }
[13:37:45.358]                   saveImmediateCondition(cond, path = "/tmp/RtmpLAMaHJ/.future/immediateConditions")
[13:37:45.358]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.358]                   {
[13:37:45.358]                     inherits <- base::inherits
[13:37:45.358]                     invokeRestart <- base::invokeRestart
[13:37:45.358]                     is.null <- base::is.null
[13:37:45.358]                     muffled <- FALSE
[13:37:45.358]                     if (inherits(cond, "message")) {
[13:37:45.358]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:45.358]                       if (muffled) 
[13:37:45.358]                         invokeRestart("muffleMessage")
[13:37:45.358]                     }
[13:37:45.358]                     else if (inherits(cond, "warning")) {
[13:37:45.358]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:45.358]                       if (muffled) 
[13:37:45.358]                         invokeRestart("muffleWarning")
[13:37:45.358]                     }
[13:37:45.358]                     else if (inherits(cond, "condition")) {
[13:37:45.358]                       if (!is.null(pattern)) {
[13:37:45.358]                         computeRestarts <- base::computeRestarts
[13:37:45.358]                         grepl <- base::grepl
[13:37:45.358]                         restarts <- computeRestarts(cond)
[13:37:45.358]                         for (restart in restarts) {
[13:37:45.358]                           name <- restart$name
[13:37:45.358]                           if (is.null(name)) 
[13:37:45.358]                             next
[13:37:45.358]                           if (!grepl(pattern, name)) 
[13:37:45.358]                             next
[13:37:45.358]                           invokeRestart(restart)
[13:37:45.358]                           muffled <- TRUE
[13:37:45.358]                           break
[13:37:45.358]                         }
[13:37:45.358]                       }
[13:37:45.358]                     }
[13:37:45.358]                     invisible(muffled)
[13:37:45.358]                   }
[13:37:45.358]                   muffleCondition(cond)
[13:37:45.358]                 })
[13:37:45.358]             }))
[13:37:45.358]             future::FutureResult(value = ...future.value$value, 
[13:37:45.358]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.358]                   ...future.rng), globalenv = if (FALSE) 
[13:37:45.358]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:45.358]                     ...future.globalenv.names))
[13:37:45.358]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:45.358]         }, condition = base::local({
[13:37:45.358]             c <- base::c
[13:37:45.358]             inherits <- base::inherits
[13:37:45.358]             invokeRestart <- base::invokeRestart
[13:37:45.358]             length <- base::length
[13:37:45.358]             list <- base::list
[13:37:45.358]             seq.int <- base::seq.int
[13:37:45.358]             signalCondition <- base::signalCondition
[13:37:45.358]             sys.calls <- base::sys.calls
[13:37:45.358]             `[[` <- base::`[[`
[13:37:45.358]             `+` <- base::`+`
[13:37:45.358]             `<<-` <- base::`<<-`
[13:37:45.358]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:45.358]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:45.358]                   3L)]
[13:37:45.358]             }
[13:37:45.358]             function(cond) {
[13:37:45.358]                 is_error <- inherits(cond, "error")
[13:37:45.358]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:45.358]                   NULL)
[13:37:45.358]                 if (is_error) {
[13:37:45.358]                   sessionInformation <- function() {
[13:37:45.358]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:45.358]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:45.358]                       search = base::search(), system = base::Sys.info())
[13:37:45.358]                   }
[13:37:45.358]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.358]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:45.358]                     cond$call), session = sessionInformation(), 
[13:37:45.358]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:45.358]                   signalCondition(cond)
[13:37:45.358]                 }
[13:37:45.358]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:45.358]                 "immediateCondition"))) {
[13:37:45.358]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:45.358]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.358]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:45.358]                   if (TRUE && !signal) {
[13:37:45.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.358]                     {
[13:37:45.358]                       inherits <- base::inherits
[13:37:45.358]                       invokeRestart <- base::invokeRestart
[13:37:45.358]                       is.null <- base::is.null
[13:37:45.358]                       muffled <- FALSE
[13:37:45.358]                       if (inherits(cond, "message")) {
[13:37:45.358]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.358]                         if (muffled) 
[13:37:45.358]                           invokeRestart("muffleMessage")
[13:37:45.358]                       }
[13:37:45.358]                       else if (inherits(cond, "warning")) {
[13:37:45.358]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.358]                         if (muffled) 
[13:37:45.358]                           invokeRestart("muffleWarning")
[13:37:45.358]                       }
[13:37:45.358]                       else if (inherits(cond, "condition")) {
[13:37:45.358]                         if (!is.null(pattern)) {
[13:37:45.358]                           computeRestarts <- base::computeRestarts
[13:37:45.358]                           grepl <- base::grepl
[13:37:45.358]                           restarts <- computeRestarts(cond)
[13:37:45.358]                           for (restart in restarts) {
[13:37:45.358]                             name <- restart$name
[13:37:45.358]                             if (is.null(name)) 
[13:37:45.358]                               next
[13:37:45.358]                             if (!grepl(pattern, name)) 
[13:37:45.358]                               next
[13:37:45.358]                             invokeRestart(restart)
[13:37:45.358]                             muffled <- TRUE
[13:37:45.358]                             break
[13:37:45.358]                           }
[13:37:45.358]                         }
[13:37:45.358]                       }
[13:37:45.358]                       invisible(muffled)
[13:37:45.358]                     }
[13:37:45.358]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.358]                   }
[13:37:45.358]                 }
[13:37:45.358]                 else {
[13:37:45.358]                   if (TRUE) {
[13:37:45.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.358]                     {
[13:37:45.358]                       inherits <- base::inherits
[13:37:45.358]                       invokeRestart <- base::invokeRestart
[13:37:45.358]                       is.null <- base::is.null
[13:37:45.358]                       muffled <- FALSE
[13:37:45.358]                       if (inherits(cond, "message")) {
[13:37:45.358]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.358]                         if (muffled) 
[13:37:45.358]                           invokeRestart("muffleMessage")
[13:37:45.358]                       }
[13:37:45.358]                       else if (inherits(cond, "warning")) {
[13:37:45.358]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.358]                         if (muffled) 
[13:37:45.358]                           invokeRestart("muffleWarning")
[13:37:45.358]                       }
[13:37:45.358]                       else if (inherits(cond, "condition")) {
[13:37:45.358]                         if (!is.null(pattern)) {
[13:37:45.358]                           computeRestarts <- base::computeRestarts
[13:37:45.358]                           grepl <- base::grepl
[13:37:45.358]                           restarts <- computeRestarts(cond)
[13:37:45.358]                           for (restart in restarts) {
[13:37:45.358]                             name <- restart$name
[13:37:45.358]                             if (is.null(name)) 
[13:37:45.358]                               next
[13:37:45.358]                             if (!grepl(pattern, name)) 
[13:37:45.358]                               next
[13:37:45.358]                             invokeRestart(restart)
[13:37:45.358]                             muffled <- TRUE
[13:37:45.358]                             break
[13:37:45.358]                           }
[13:37:45.358]                         }
[13:37:45.358]                       }
[13:37:45.358]                       invisible(muffled)
[13:37:45.358]                     }
[13:37:45.358]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.358]                   }
[13:37:45.358]                 }
[13:37:45.358]             }
[13:37:45.358]         }))
[13:37:45.358]     }, error = function(ex) {
[13:37:45.358]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:45.358]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.358]                 ...future.rng), started = ...future.startTime, 
[13:37:45.358]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:45.358]             version = "1.8"), class = "FutureResult")
[13:37:45.358]     }, finally = {
[13:37:45.358]         if (!identical(...future.workdir, getwd())) 
[13:37:45.358]             setwd(...future.workdir)
[13:37:45.358]         {
[13:37:45.358]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:45.358]                 ...future.oldOptions$nwarnings <- NULL
[13:37:45.358]             }
[13:37:45.358]             base::options(...future.oldOptions)
[13:37:45.358]             if (.Platform$OS.type == "windows") {
[13:37:45.358]                 old_names <- names(...future.oldEnvVars)
[13:37:45.358]                 envs <- base::Sys.getenv()
[13:37:45.358]                 names <- names(envs)
[13:37:45.358]                 common <- intersect(names, old_names)
[13:37:45.358]                 added <- setdiff(names, old_names)
[13:37:45.358]                 removed <- setdiff(old_names, names)
[13:37:45.358]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:45.358]                   envs[common]]
[13:37:45.358]                 NAMES <- toupper(changed)
[13:37:45.358]                 args <- list()
[13:37:45.358]                 for (kk in seq_along(NAMES)) {
[13:37:45.358]                   name <- changed[[kk]]
[13:37:45.358]                   NAME <- NAMES[[kk]]
[13:37:45.358]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.358]                     next
[13:37:45.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.358]                 }
[13:37:45.358]                 NAMES <- toupper(added)
[13:37:45.358]                 for (kk in seq_along(NAMES)) {
[13:37:45.358]                   name <- added[[kk]]
[13:37:45.358]                   NAME <- NAMES[[kk]]
[13:37:45.358]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.358]                     next
[13:37:45.358]                   args[[name]] <- ""
[13:37:45.358]                 }
[13:37:45.358]                 NAMES <- toupper(removed)
[13:37:45.358]                 for (kk in seq_along(NAMES)) {
[13:37:45.358]                   name <- removed[[kk]]
[13:37:45.358]                   NAME <- NAMES[[kk]]
[13:37:45.358]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.358]                     next
[13:37:45.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.358]                 }
[13:37:45.358]                 if (length(args) > 0) 
[13:37:45.358]                   base::do.call(base::Sys.setenv, args = args)
[13:37:45.358]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:45.358]             }
[13:37:45.358]             else {
[13:37:45.358]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:45.358]             }
[13:37:45.358]             {
[13:37:45.358]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:45.358]                   0L) {
[13:37:45.358]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:45.358]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:45.358]                   base::options(opts)
[13:37:45.358]                 }
[13:37:45.358]                 {
[13:37:45.358]                   {
[13:37:45.358]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:45.358]                     NULL
[13:37:45.358]                   }
[13:37:45.358]                   options(future.plan = NULL)
[13:37:45.358]                   if (is.na(NA_character_)) 
[13:37:45.358]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.358]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:45.358]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:45.358]                     .init = FALSE)
[13:37:45.358]                 }
[13:37:45.358]             }
[13:37:45.358]         }
[13:37:45.358]     })
[13:37:45.358]     if (TRUE) {
[13:37:45.358]         base::sink(type = "output", split = FALSE)
[13:37:45.358]         if (TRUE) {
[13:37:45.358]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:45.358]         }
[13:37:45.358]         else {
[13:37:45.358]             ...future.result["stdout"] <- base::list(NULL)
[13:37:45.358]         }
[13:37:45.358]         base::close(...future.stdout)
[13:37:45.358]         ...future.stdout <- NULL
[13:37:45.358]     }
[13:37:45.358]     ...future.result$conditions <- ...future.conditions
[13:37:45.358]     ...future.result$finished <- base::Sys.time()
[13:37:45.358]     ...future.result
[13:37:45.358] }
[13:37:45.361] requestCore(): workers = 2
[13:37:45.361] Poll #1 (0): usedCores() = 2, workers = 2
[13:37:45.372] result() for MulticoreFuture ...
[13:37:45.373] result() for MulticoreFuture ...
[13:37:45.373] result() for MulticoreFuture ... done
[13:37:45.373] result() for MulticoreFuture ... done
[13:37:45.374] result() for MulticoreFuture ...
[13:37:45.374] result() for MulticoreFuture ... done
[13:37:45.376] MulticoreFuture started
[13:37:45.377] - Launch lazy future ... done
[13:37:45.377] run() for ‘MulticoreFuture’ ... done
[13:37:45.378] plan(): Setting new future strategy stack:
[13:37:45.379] getGlobalsAndPackages() ...
[13:37:45.379] Searching for globals...
[13:37:45.378] List of future strategies:
[13:37:45.378] 1. sequential:
[13:37:45.378]    - args: function (..., envir = parent.frame())
[13:37:45.378]    - tweaked: FALSE
[13:37:45.378]    - call: NULL
[13:37:45.380] plan(): nbrOfWorkers() = 1
[13:37:45.381] - globals found: [1] ‘{’
[13:37:45.381] Searching for globals ... DONE
[13:37:45.382] Resolving globals: FALSE
[13:37:45.382] 
[13:37:45.383] plan(): Setting new future strategy stack:
[13:37:45.383] 
[13:37:45.383] getGlobalsAndPackages() ... DONE
[13:37:45.383] List of future strategies:
[13:37:45.383] 1. multicore:
[13:37:45.383]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:37:45.383]    - tweaked: FALSE
[13:37:45.383]    - call: plan(strategy)
[13:37:45.384] run() for ‘Future’ ...
[13:37:45.384] - state: ‘created’
[13:37:45.384] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:37:45.389] plan(): nbrOfWorkers() = 2
[13:37:45.390] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:45.390] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:37:45.390]   - Field: ‘label’
[13:37:45.390]   - Field: ‘local’
[13:37:45.390]   - Field: ‘owner’
[13:37:45.391]   - Field: ‘envir’
[13:37:45.391]   - Field: ‘workers’
[13:37:45.391]   - Field: ‘packages’
[13:37:45.391]   - Field: ‘gc’
[13:37:45.391]   - Field: ‘job’
[13:37:45.391]   - Field: ‘conditions’
[13:37:45.391]   - Field: ‘expr’
[13:37:45.392]   - Field: ‘uuid’
[13:37:45.392]   - Field: ‘seed’
[13:37:45.392]   - Field: ‘version’
[13:37:45.392]   - Field: ‘result’
[13:37:45.392]   - Field: ‘asynchronous’
[13:37:45.392]   - Field: ‘calls’
[13:37:45.392]   - Field: ‘globals’
[13:37:45.393]   - Field: ‘stdout’
[13:37:45.393]   - Field: ‘earlySignal’
[13:37:45.393]   - Field: ‘lazy’
[13:37:45.393]   - Field: ‘state’
[13:37:45.393] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:37:45.393] - Launch lazy future ...
[13:37:45.394] Packages needed by the future expression (n = 0): <none>
[13:37:45.394] Packages needed by future strategies (n = 0): <none>
[13:37:45.395] {
[13:37:45.395]     {
[13:37:45.395]         {
[13:37:45.395]             ...future.startTime <- base::Sys.time()
[13:37:45.395]             {
[13:37:45.395]                 {
[13:37:45.395]                   {
[13:37:45.395]                     {
[13:37:45.395]                       base::local({
[13:37:45.395]                         has_future <- base::requireNamespace("future", 
[13:37:45.395]                           quietly = TRUE)
[13:37:45.395]                         if (has_future) {
[13:37:45.395]                           ns <- base::getNamespace("future")
[13:37:45.395]                           version <- ns[[".package"]][["version"]]
[13:37:45.395]                           if (is.null(version)) 
[13:37:45.395]                             version <- utils::packageVersion("future")
[13:37:45.395]                         }
[13:37:45.395]                         else {
[13:37:45.395]                           version <- NULL
[13:37:45.395]                         }
[13:37:45.395]                         if (!has_future || version < "1.8.0") {
[13:37:45.395]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:45.395]                             "", base::R.version$version.string), 
[13:37:45.395]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:45.395]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:45.395]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:45.395]                               "release", "version")], collapse = " "), 
[13:37:45.395]                             hostname = base::Sys.info()[["nodename"]])
[13:37:45.395]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:45.395]                             info)
[13:37:45.395]                           info <- base::paste(info, collapse = "; ")
[13:37:45.395]                           if (!has_future) {
[13:37:45.395]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:45.395]                               info)
[13:37:45.395]                           }
[13:37:45.395]                           else {
[13:37:45.395]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:45.395]                               info, version)
[13:37:45.395]                           }
[13:37:45.395]                           base::stop(msg)
[13:37:45.395]                         }
[13:37:45.395]                       })
[13:37:45.395]                     }
[13:37:45.395]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:45.395]                     base::options(mc.cores = 1L)
[13:37:45.395]                   }
[13:37:45.395]                   ...future.strategy.old <- future::plan("list")
[13:37:45.395]                   options(future.plan = NULL)
[13:37:45.395]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.395]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:45.395]                 }
[13:37:45.395]                 ...future.workdir <- getwd()
[13:37:45.395]             }
[13:37:45.395]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:45.395]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:45.395]         }
[13:37:45.395]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:45.395]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:45.395]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:45.395]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:45.395]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:45.395]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:45.395]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:45.395]             base::names(...future.oldOptions))
[13:37:45.395]     }
[13:37:45.395]     if (FALSE) {
[13:37:45.395]     }
[13:37:45.395]     else {
[13:37:45.395]         if (TRUE) {
[13:37:45.395]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:45.395]                 open = "w")
[13:37:45.395]         }
[13:37:45.395]         else {
[13:37:45.395]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:45.395]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:45.395]         }
[13:37:45.395]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:45.395]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:45.395]             base::sink(type = "output", split = FALSE)
[13:37:45.395]             base::close(...future.stdout)
[13:37:45.395]         }, add = TRUE)
[13:37:45.395]     }
[13:37:45.395]     ...future.frame <- base::sys.nframe()
[13:37:45.395]     ...future.conditions <- base::list()
[13:37:45.395]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:45.395]     if (FALSE) {
[13:37:45.395]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:45.395]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:45.395]     }
[13:37:45.395]     ...future.result <- base::tryCatch({
[13:37:45.395]         base::withCallingHandlers({
[13:37:45.395]             ...future.value <- base::withVisible(base::local({
[13:37:45.395]                 withCallingHandlers({
[13:37:45.395]                   {
[13:37:45.395]                     2
[13:37:45.395]                   }
[13:37:45.395]                 }, immediateCondition = function(cond) {
[13:37:45.395]                   save_rds <- function (object, pathname, ...) 
[13:37:45.395]                   {
[13:37:45.395]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:37:45.395]                     if (file_test("-f", pathname_tmp)) {
[13:37:45.395]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.395]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:37:45.395]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.395]                         fi_tmp[["mtime"]])
[13:37:45.395]                     }
[13:37:45.395]                     tryCatch({
[13:37:45.395]                       saveRDS(object, file = pathname_tmp, ...)
[13:37:45.395]                     }, error = function(ex) {
[13:37:45.395]                       msg <- conditionMessage(ex)
[13:37:45.395]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.395]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:37:45.395]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.395]                         fi_tmp[["mtime"]], msg)
[13:37:45.395]                       ex$message <- msg
[13:37:45.395]                       stop(ex)
[13:37:45.395]                     })
[13:37:45.395]                     stopifnot(file_test("-f", pathname_tmp))
[13:37:45.395]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:37:45.395]                     if (!res || file_test("-f", pathname_tmp)) {
[13:37:45.395]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.395]                       fi <- file.info(pathname)
[13:37:45.395]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:37:45.395]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.395]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:37:45.395]                         fi[["size"]], fi[["mtime"]])
[13:37:45.395]                       stop(msg)
[13:37:45.395]                     }
[13:37:45.395]                     invisible(pathname)
[13:37:45.395]                   }
[13:37:45.395]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:37:45.395]                     rootPath = tempdir()) 
[13:37:45.395]                   {
[13:37:45.395]                     obj <- list(time = Sys.time(), condition = cond)
[13:37:45.395]                     file <- tempfile(pattern = class(cond)[1], 
[13:37:45.395]                       tmpdir = path, fileext = ".rds")
[13:37:45.395]                     save_rds(obj, file)
[13:37:45.395]                   }
[13:37:45.395]                   saveImmediateCondition(cond, path = "/tmp/RtmpLAMaHJ/.future/immediateConditions")
[13:37:45.395]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.395]                   {
[13:37:45.395]                     inherits <- base::inherits
[13:37:45.395]                     invokeRestart <- base::invokeRestart
[13:37:45.395]                     is.null <- base::is.null
[13:37:45.395]                     muffled <- FALSE
[13:37:45.395]                     if (inherits(cond, "message")) {
[13:37:45.395]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:45.395]                       if (muffled) 
[13:37:45.395]                         invokeRestart("muffleMessage")
[13:37:45.395]                     }
[13:37:45.395]                     else if (inherits(cond, "warning")) {
[13:37:45.395]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:45.395]                       if (muffled) 
[13:37:45.395]                         invokeRestart("muffleWarning")
[13:37:45.395]                     }
[13:37:45.395]                     else if (inherits(cond, "condition")) {
[13:37:45.395]                       if (!is.null(pattern)) {
[13:37:45.395]                         computeRestarts <- base::computeRestarts
[13:37:45.395]                         grepl <- base::grepl
[13:37:45.395]                         restarts <- computeRestarts(cond)
[13:37:45.395]                         for (restart in restarts) {
[13:37:45.395]                           name <- restart$name
[13:37:45.395]                           if (is.null(name)) 
[13:37:45.395]                             next
[13:37:45.395]                           if (!grepl(pattern, name)) 
[13:37:45.395]                             next
[13:37:45.395]                           invokeRestart(restart)
[13:37:45.395]                           muffled <- TRUE
[13:37:45.395]                           break
[13:37:45.395]                         }
[13:37:45.395]                       }
[13:37:45.395]                     }
[13:37:45.395]                     invisible(muffled)
[13:37:45.395]                   }
[13:37:45.395]                   muffleCondition(cond)
[13:37:45.395]                 })
[13:37:45.395]             }))
[13:37:45.395]             future::FutureResult(value = ...future.value$value, 
[13:37:45.395]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.395]                   ...future.rng), globalenv = if (FALSE) 
[13:37:45.395]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:45.395]                     ...future.globalenv.names))
[13:37:45.395]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:45.395]         }, condition = base::local({
[13:37:45.395]             c <- base::c
[13:37:45.395]             inherits <- base::inherits
[13:37:45.395]             invokeRestart <- base::invokeRestart
[13:37:45.395]             length <- base::length
[13:37:45.395]             list <- base::list
[13:37:45.395]             seq.int <- base::seq.int
[13:37:45.395]             signalCondition <- base::signalCondition
[13:37:45.395]             sys.calls <- base::sys.calls
[13:37:45.395]             `[[` <- base::`[[`
[13:37:45.395]             `+` <- base::`+`
[13:37:45.395]             `<<-` <- base::`<<-`
[13:37:45.395]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:45.395]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:45.395]                   3L)]
[13:37:45.395]             }
[13:37:45.395]             function(cond) {
[13:37:45.395]                 is_error <- inherits(cond, "error")
[13:37:45.395]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:45.395]                   NULL)
[13:37:45.395]                 if (is_error) {
[13:37:45.395]                   sessionInformation <- function() {
[13:37:45.395]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:45.395]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:45.395]                       search = base::search(), system = base::Sys.info())
[13:37:45.395]                   }
[13:37:45.395]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.395]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:45.395]                     cond$call), session = sessionInformation(), 
[13:37:45.395]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:45.395]                   signalCondition(cond)
[13:37:45.395]                 }
[13:37:45.395]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:45.395]                 "immediateCondition"))) {
[13:37:45.395]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:45.395]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.395]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:45.395]                   if (TRUE && !signal) {
[13:37:45.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.395]                     {
[13:37:45.395]                       inherits <- base::inherits
[13:37:45.395]                       invokeRestart <- base::invokeRestart
[13:37:45.395]                       is.null <- base::is.null
[13:37:45.395]                       muffled <- FALSE
[13:37:45.395]                       if (inherits(cond, "message")) {
[13:37:45.395]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.395]                         if (muffled) 
[13:37:45.395]                           invokeRestart("muffleMessage")
[13:37:45.395]                       }
[13:37:45.395]                       else if (inherits(cond, "warning")) {
[13:37:45.395]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.395]                         if (muffled) 
[13:37:45.395]                           invokeRestart("muffleWarning")
[13:37:45.395]                       }
[13:37:45.395]                       else if (inherits(cond, "condition")) {
[13:37:45.395]                         if (!is.null(pattern)) {
[13:37:45.395]                           computeRestarts <- base::computeRestarts
[13:37:45.395]                           grepl <- base::grepl
[13:37:45.395]                           restarts <- computeRestarts(cond)
[13:37:45.395]                           for (restart in restarts) {
[13:37:45.395]                             name <- restart$name
[13:37:45.395]                             if (is.null(name)) 
[13:37:45.395]                               next
[13:37:45.395]                             if (!grepl(pattern, name)) 
[13:37:45.395]                               next
[13:37:45.395]                             invokeRestart(restart)
[13:37:45.395]                             muffled <- TRUE
[13:37:45.395]                             break
[13:37:45.395]                           }
[13:37:45.395]                         }
[13:37:45.395]                       }
[13:37:45.395]                       invisible(muffled)
[13:37:45.395]                     }
[13:37:45.395]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.395]                   }
[13:37:45.395]                 }
[13:37:45.395]                 else {
[13:37:45.395]                   if (TRUE) {
[13:37:45.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.395]                     {
[13:37:45.395]                       inherits <- base::inherits
[13:37:45.395]                       invokeRestart <- base::invokeRestart
[13:37:45.395]                       is.null <- base::is.null
[13:37:45.395]                       muffled <- FALSE
[13:37:45.395]                       if (inherits(cond, "message")) {
[13:37:45.395]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.395]                         if (muffled) 
[13:37:45.395]                           invokeRestart("muffleMessage")
[13:37:45.395]                       }
[13:37:45.395]                       else if (inherits(cond, "warning")) {
[13:37:45.395]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.395]                         if (muffled) 
[13:37:45.395]                           invokeRestart("muffleWarning")
[13:37:45.395]                       }
[13:37:45.395]                       else if (inherits(cond, "condition")) {
[13:37:45.395]                         if (!is.null(pattern)) {
[13:37:45.395]                           computeRestarts <- base::computeRestarts
[13:37:45.395]                           grepl <- base::grepl
[13:37:45.395]                           restarts <- computeRestarts(cond)
[13:37:45.395]                           for (restart in restarts) {
[13:37:45.395]                             name <- restart$name
[13:37:45.395]                             if (is.null(name)) 
[13:37:45.395]                               next
[13:37:45.395]                             if (!grepl(pattern, name)) 
[13:37:45.395]                               next
[13:37:45.395]                             invokeRestart(restart)
[13:37:45.395]                             muffled <- TRUE
[13:37:45.395]                             break
[13:37:45.395]                           }
[13:37:45.395]                         }
[13:37:45.395]                       }
[13:37:45.395]                       invisible(muffled)
[13:37:45.395]                     }
[13:37:45.395]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.395]                   }
[13:37:45.395]                 }
[13:37:45.395]             }
[13:37:45.395]         }))
[13:37:45.395]     }, error = function(ex) {
[13:37:45.395]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:45.395]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.395]                 ...future.rng), started = ...future.startTime, 
[13:37:45.395]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:45.395]             version = "1.8"), class = "FutureResult")
[13:37:45.395]     }, finally = {
[13:37:45.395]         if (!identical(...future.workdir, getwd())) 
[13:37:45.395]             setwd(...future.workdir)
[13:37:45.395]         {
[13:37:45.395]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:45.395]                 ...future.oldOptions$nwarnings <- NULL
[13:37:45.395]             }
[13:37:45.395]             base::options(...future.oldOptions)
[13:37:45.395]             if (.Platform$OS.type == "windows") {
[13:37:45.395]                 old_names <- names(...future.oldEnvVars)
[13:37:45.395]                 envs <- base::Sys.getenv()
[13:37:45.395]                 names <- names(envs)
[13:37:45.395]                 common <- intersect(names, old_names)
[13:37:45.395]                 added <- setdiff(names, old_names)
[13:37:45.395]                 removed <- setdiff(old_names, names)
[13:37:45.395]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:45.395]                   envs[common]]
[13:37:45.395]                 NAMES <- toupper(changed)
[13:37:45.395]                 args <- list()
[13:37:45.395]                 for (kk in seq_along(NAMES)) {
[13:37:45.395]                   name <- changed[[kk]]
[13:37:45.395]                   NAME <- NAMES[[kk]]
[13:37:45.395]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.395]                     next
[13:37:45.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.395]                 }
[13:37:45.395]                 NAMES <- toupper(added)
[13:37:45.395]                 for (kk in seq_along(NAMES)) {
[13:37:45.395]                   name <- added[[kk]]
[13:37:45.395]                   NAME <- NAMES[[kk]]
[13:37:45.395]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.395]                     next
[13:37:45.395]                   args[[name]] <- ""
[13:37:45.395]                 }
[13:37:45.395]                 NAMES <- toupper(removed)
[13:37:45.395]                 for (kk in seq_along(NAMES)) {
[13:37:45.395]                   name <- removed[[kk]]
[13:37:45.395]                   NAME <- NAMES[[kk]]
[13:37:45.395]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.395]                     next
[13:37:45.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.395]                 }
[13:37:45.395]                 if (length(args) > 0) 
[13:37:45.395]                   base::do.call(base::Sys.setenv, args = args)
[13:37:45.395]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:45.395]             }
[13:37:45.395]             else {
[13:37:45.395]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:45.395]             }
[13:37:45.395]             {
[13:37:45.395]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:45.395]                   0L) {
[13:37:45.395]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:45.395]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:45.395]                   base::options(opts)
[13:37:45.395]                 }
[13:37:45.395]                 {
[13:37:45.395]                   {
[13:37:45.395]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:45.395]                     NULL
[13:37:45.395]                   }
[13:37:45.395]                   options(future.plan = NULL)
[13:37:45.395]                   if (is.na(NA_character_)) 
[13:37:45.395]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.395]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:45.395]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:45.395]                     .init = FALSE)
[13:37:45.395]                 }
[13:37:45.395]             }
[13:37:45.395]         }
[13:37:45.395]     })
[13:37:45.395]     if (TRUE) {
[13:37:45.395]         base::sink(type = "output", split = FALSE)
[13:37:45.395]         if (TRUE) {
[13:37:45.395]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:45.395]         }
[13:37:45.395]         else {
[13:37:45.395]             ...future.result["stdout"] <- base::list(NULL)
[13:37:45.395]         }
[13:37:45.395]         base::close(...future.stdout)
[13:37:45.395]         ...future.stdout <- NULL
[13:37:45.395]     }
[13:37:45.395]     ...future.result$conditions <- ...future.conditions
[13:37:45.395]     ...future.result$finished <- base::Sys.time()
[13:37:45.395]     ...future.result
[13:37:45.395] }
[13:37:45.398] requestCore(): workers = 2
[13:37:45.399] Poll #1 (0): usedCores() = 2, workers = 2
[13:37:45.410] result() for MulticoreFuture ...
[13:37:45.411] result() for MulticoreFuture ...
[13:37:45.411] result() for MulticoreFuture ... done
[13:37:45.411] result() for MulticoreFuture ... done
[13:37:45.411] result() for MulticoreFuture ...
[13:37:45.412] result() for MulticoreFuture ... done
[13:37:45.415] MulticoreFuture started
[13:37:45.415] - Launch lazy future ... done
[13:37:45.416] run() for ‘MulticoreFuture’ ... done
[13:37:45.416] plan(): Setting new future strategy stack:
[13:37:45.416] List of future strategies:
[13:37:45.416] 1. sequential:
[13:37:45.416]    - args: function (..., envir = parent.frame())
[13:37:45.416]    - tweaked: FALSE
[13:37:45.416]    - call: NULL
[13:37:45.417] plan(): nbrOfWorkers() = 1
[13:37:45.417] resolve() on environment ...
[13:37:45.417]  recursive: 0
[13:37:45.418]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[13:37:45.419] Future #1
[13:37:45.419]  length: 2 (resolved future 1)
[13:37:45.419] plan(): Setting new future strategy stack:
[13:37:45.420] List of future strategies:
[13:37:45.420] 1. multicore:
[13:37:45.420]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:37:45.420]    - tweaked: FALSE
[13:37:45.420]    - call: plan(strategy)
[13:37:45.425] plan(): nbrOfWorkers() = 2
[13:37:45.426] Future #2
[13:37:45.426]  length: 1 (resolved future 2)
[13:37:45.427]  length: 0 (resolved future 3)
[13:37:45.427] resolve() on environment ... DONE
[13:37:45.428] getGlobalsAndPackages() ...
[13:37:45.428] Searching for globals...
[13:37:45.435] - globals found: [1] ‘{’
[13:37:45.435] Searching for globals ... DONE
[13:37:45.436] Resolving globals: FALSE
[13:37:45.437] 
[13:37:45.437] 
[13:37:45.437] getGlobalsAndPackages() ... DONE
[13:37:45.438] run() for ‘Future’ ...
[13:37:45.438] - state: ‘created’
[13:37:45.439] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:37:45.444] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:45.444] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:37:45.444]   - Field: ‘label’
[13:37:45.445]   - Field: ‘local’
[13:37:45.445]   - Field: ‘owner’
[13:37:45.445]   - Field: ‘envir’
[13:37:45.445]   - Field: ‘workers’
[13:37:45.445]   - Field: ‘packages’
[13:37:45.445]   - Field: ‘gc’
[13:37:45.446]   - Field: ‘job’
[13:37:45.446]   - Field: ‘conditions’
[13:37:45.446]   - Field: ‘expr’
[13:37:45.446]   - Field: ‘uuid’
[13:37:45.447]   - Field: ‘seed’
[13:37:45.447]   - Field: ‘version’
[13:37:45.447]   - Field: ‘result’
[13:37:45.447]   - Field: ‘asynchronous’
[13:37:45.447]   - Field: ‘calls’
[13:37:45.448]   - Field: ‘globals’
[13:37:45.448]   - Field: ‘stdout’
[13:37:45.448]   - Field: ‘earlySignal’
[13:37:45.448]   - Field: ‘lazy’
[13:37:45.448]   - Field: ‘state’
[13:37:45.448] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:37:45.449] - Launch lazy future ...
[13:37:45.449] Packages needed by the future expression (n = 0): <none>
[13:37:45.449] Packages needed by future strategies (n = 0): <none>
[13:37:45.450] {
[13:37:45.450]     {
[13:37:45.450]         {
[13:37:45.450]             ...future.startTime <- base::Sys.time()
[13:37:45.450]             {
[13:37:45.450]                 {
[13:37:45.450]                   {
[13:37:45.450]                     {
[13:37:45.450]                       base::local({
[13:37:45.450]                         has_future <- base::requireNamespace("future", 
[13:37:45.450]                           quietly = TRUE)
[13:37:45.450]                         if (has_future) {
[13:37:45.450]                           ns <- base::getNamespace("future")
[13:37:45.450]                           version <- ns[[".package"]][["version"]]
[13:37:45.450]                           if (is.null(version)) 
[13:37:45.450]                             version <- utils::packageVersion("future")
[13:37:45.450]                         }
[13:37:45.450]                         else {
[13:37:45.450]                           version <- NULL
[13:37:45.450]                         }
[13:37:45.450]                         if (!has_future || version < "1.8.0") {
[13:37:45.450]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:45.450]                             "", base::R.version$version.string), 
[13:37:45.450]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:45.450]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:45.450]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:45.450]                               "release", "version")], collapse = " "), 
[13:37:45.450]                             hostname = base::Sys.info()[["nodename"]])
[13:37:45.450]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:45.450]                             info)
[13:37:45.450]                           info <- base::paste(info, collapse = "; ")
[13:37:45.450]                           if (!has_future) {
[13:37:45.450]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:45.450]                               info)
[13:37:45.450]                           }
[13:37:45.450]                           else {
[13:37:45.450]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:45.450]                               info, version)
[13:37:45.450]                           }
[13:37:45.450]                           base::stop(msg)
[13:37:45.450]                         }
[13:37:45.450]                       })
[13:37:45.450]                     }
[13:37:45.450]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:45.450]                     base::options(mc.cores = 1L)
[13:37:45.450]                   }
[13:37:45.450]                   ...future.strategy.old <- future::plan("list")
[13:37:45.450]                   options(future.plan = NULL)
[13:37:45.450]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.450]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:45.450]                 }
[13:37:45.450]                 ...future.workdir <- getwd()
[13:37:45.450]             }
[13:37:45.450]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:45.450]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:45.450]         }
[13:37:45.450]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:45.450]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:45.450]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:45.450]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:45.450]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:45.450]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:45.450]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:45.450]             base::names(...future.oldOptions))
[13:37:45.450]     }
[13:37:45.450]     if (FALSE) {
[13:37:45.450]     }
[13:37:45.450]     else {
[13:37:45.450]         if (TRUE) {
[13:37:45.450]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:45.450]                 open = "w")
[13:37:45.450]         }
[13:37:45.450]         else {
[13:37:45.450]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:45.450]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:45.450]         }
[13:37:45.450]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:45.450]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:45.450]             base::sink(type = "output", split = FALSE)
[13:37:45.450]             base::close(...future.stdout)
[13:37:45.450]         }, add = TRUE)
[13:37:45.450]     }
[13:37:45.450]     ...future.frame <- base::sys.nframe()
[13:37:45.450]     ...future.conditions <- base::list()
[13:37:45.450]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:45.450]     if (FALSE) {
[13:37:45.450]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:45.450]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:45.450]     }
[13:37:45.450]     ...future.result <- base::tryCatch({
[13:37:45.450]         base::withCallingHandlers({
[13:37:45.450]             ...future.value <- base::withVisible(base::local({
[13:37:45.450]                 withCallingHandlers({
[13:37:45.450]                   {
[13:37:45.450]                     1
[13:37:45.450]                   }
[13:37:45.450]                 }, immediateCondition = function(cond) {
[13:37:45.450]                   save_rds <- function (object, pathname, ...) 
[13:37:45.450]                   {
[13:37:45.450]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:37:45.450]                     if (file_test("-f", pathname_tmp)) {
[13:37:45.450]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.450]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:37:45.450]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.450]                         fi_tmp[["mtime"]])
[13:37:45.450]                     }
[13:37:45.450]                     tryCatch({
[13:37:45.450]                       saveRDS(object, file = pathname_tmp, ...)
[13:37:45.450]                     }, error = function(ex) {
[13:37:45.450]                       msg <- conditionMessage(ex)
[13:37:45.450]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.450]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:37:45.450]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.450]                         fi_tmp[["mtime"]], msg)
[13:37:45.450]                       ex$message <- msg
[13:37:45.450]                       stop(ex)
[13:37:45.450]                     })
[13:37:45.450]                     stopifnot(file_test("-f", pathname_tmp))
[13:37:45.450]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:37:45.450]                     if (!res || file_test("-f", pathname_tmp)) {
[13:37:45.450]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.450]                       fi <- file.info(pathname)
[13:37:45.450]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:37:45.450]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.450]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:37:45.450]                         fi[["size"]], fi[["mtime"]])
[13:37:45.450]                       stop(msg)
[13:37:45.450]                     }
[13:37:45.450]                     invisible(pathname)
[13:37:45.450]                   }
[13:37:45.450]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:37:45.450]                     rootPath = tempdir()) 
[13:37:45.450]                   {
[13:37:45.450]                     obj <- list(time = Sys.time(), condition = cond)
[13:37:45.450]                     file <- tempfile(pattern = class(cond)[1], 
[13:37:45.450]                       tmpdir = path, fileext = ".rds")
[13:37:45.450]                     save_rds(obj, file)
[13:37:45.450]                   }
[13:37:45.450]                   saveImmediateCondition(cond, path = "/tmp/RtmpLAMaHJ/.future/immediateConditions")
[13:37:45.450]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.450]                   {
[13:37:45.450]                     inherits <- base::inherits
[13:37:45.450]                     invokeRestart <- base::invokeRestart
[13:37:45.450]                     is.null <- base::is.null
[13:37:45.450]                     muffled <- FALSE
[13:37:45.450]                     if (inherits(cond, "message")) {
[13:37:45.450]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:45.450]                       if (muffled) 
[13:37:45.450]                         invokeRestart("muffleMessage")
[13:37:45.450]                     }
[13:37:45.450]                     else if (inherits(cond, "warning")) {
[13:37:45.450]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:45.450]                       if (muffled) 
[13:37:45.450]                         invokeRestart("muffleWarning")
[13:37:45.450]                     }
[13:37:45.450]                     else if (inherits(cond, "condition")) {
[13:37:45.450]                       if (!is.null(pattern)) {
[13:37:45.450]                         computeRestarts <- base::computeRestarts
[13:37:45.450]                         grepl <- base::grepl
[13:37:45.450]                         restarts <- computeRestarts(cond)
[13:37:45.450]                         for (restart in restarts) {
[13:37:45.450]                           name <- restart$name
[13:37:45.450]                           if (is.null(name)) 
[13:37:45.450]                             next
[13:37:45.450]                           if (!grepl(pattern, name)) 
[13:37:45.450]                             next
[13:37:45.450]                           invokeRestart(restart)
[13:37:45.450]                           muffled <- TRUE
[13:37:45.450]                           break
[13:37:45.450]                         }
[13:37:45.450]                       }
[13:37:45.450]                     }
[13:37:45.450]                     invisible(muffled)
[13:37:45.450]                   }
[13:37:45.450]                   muffleCondition(cond)
[13:37:45.450]                 })
[13:37:45.450]             }))
[13:37:45.450]             future::FutureResult(value = ...future.value$value, 
[13:37:45.450]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.450]                   ...future.rng), globalenv = if (FALSE) 
[13:37:45.450]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:45.450]                     ...future.globalenv.names))
[13:37:45.450]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:45.450]         }, condition = base::local({
[13:37:45.450]             c <- base::c
[13:37:45.450]             inherits <- base::inherits
[13:37:45.450]             invokeRestart <- base::invokeRestart
[13:37:45.450]             length <- base::length
[13:37:45.450]             list <- base::list
[13:37:45.450]             seq.int <- base::seq.int
[13:37:45.450]             signalCondition <- base::signalCondition
[13:37:45.450]             sys.calls <- base::sys.calls
[13:37:45.450]             `[[` <- base::`[[`
[13:37:45.450]             `+` <- base::`+`
[13:37:45.450]             `<<-` <- base::`<<-`
[13:37:45.450]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:45.450]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:45.450]                   3L)]
[13:37:45.450]             }
[13:37:45.450]             function(cond) {
[13:37:45.450]                 is_error <- inherits(cond, "error")
[13:37:45.450]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:45.450]                   NULL)
[13:37:45.450]                 if (is_error) {
[13:37:45.450]                   sessionInformation <- function() {
[13:37:45.450]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:45.450]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:45.450]                       search = base::search(), system = base::Sys.info())
[13:37:45.450]                   }
[13:37:45.450]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.450]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:45.450]                     cond$call), session = sessionInformation(), 
[13:37:45.450]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:45.450]                   signalCondition(cond)
[13:37:45.450]                 }
[13:37:45.450]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:45.450]                 "immediateCondition"))) {
[13:37:45.450]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:45.450]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.450]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:45.450]                   if (TRUE && !signal) {
[13:37:45.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.450]                     {
[13:37:45.450]                       inherits <- base::inherits
[13:37:45.450]                       invokeRestart <- base::invokeRestart
[13:37:45.450]                       is.null <- base::is.null
[13:37:45.450]                       muffled <- FALSE
[13:37:45.450]                       if (inherits(cond, "message")) {
[13:37:45.450]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.450]                         if (muffled) 
[13:37:45.450]                           invokeRestart("muffleMessage")
[13:37:45.450]                       }
[13:37:45.450]                       else if (inherits(cond, "warning")) {
[13:37:45.450]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.450]                         if (muffled) 
[13:37:45.450]                           invokeRestart("muffleWarning")
[13:37:45.450]                       }
[13:37:45.450]                       else if (inherits(cond, "condition")) {
[13:37:45.450]                         if (!is.null(pattern)) {
[13:37:45.450]                           computeRestarts <- base::computeRestarts
[13:37:45.450]                           grepl <- base::grepl
[13:37:45.450]                           restarts <- computeRestarts(cond)
[13:37:45.450]                           for (restart in restarts) {
[13:37:45.450]                             name <- restart$name
[13:37:45.450]                             if (is.null(name)) 
[13:37:45.450]                               next
[13:37:45.450]                             if (!grepl(pattern, name)) 
[13:37:45.450]                               next
[13:37:45.450]                             invokeRestart(restart)
[13:37:45.450]                             muffled <- TRUE
[13:37:45.450]                             break
[13:37:45.450]                           }
[13:37:45.450]                         }
[13:37:45.450]                       }
[13:37:45.450]                       invisible(muffled)
[13:37:45.450]                     }
[13:37:45.450]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.450]                   }
[13:37:45.450]                 }
[13:37:45.450]                 else {
[13:37:45.450]                   if (TRUE) {
[13:37:45.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.450]                     {
[13:37:45.450]                       inherits <- base::inherits
[13:37:45.450]                       invokeRestart <- base::invokeRestart
[13:37:45.450]                       is.null <- base::is.null
[13:37:45.450]                       muffled <- FALSE
[13:37:45.450]                       if (inherits(cond, "message")) {
[13:37:45.450]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.450]                         if (muffled) 
[13:37:45.450]                           invokeRestart("muffleMessage")
[13:37:45.450]                       }
[13:37:45.450]                       else if (inherits(cond, "warning")) {
[13:37:45.450]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.450]                         if (muffled) 
[13:37:45.450]                           invokeRestart("muffleWarning")
[13:37:45.450]                       }
[13:37:45.450]                       else if (inherits(cond, "condition")) {
[13:37:45.450]                         if (!is.null(pattern)) {
[13:37:45.450]                           computeRestarts <- base::computeRestarts
[13:37:45.450]                           grepl <- base::grepl
[13:37:45.450]                           restarts <- computeRestarts(cond)
[13:37:45.450]                           for (restart in restarts) {
[13:37:45.450]                             name <- restart$name
[13:37:45.450]                             if (is.null(name)) 
[13:37:45.450]                               next
[13:37:45.450]                             if (!grepl(pattern, name)) 
[13:37:45.450]                               next
[13:37:45.450]                             invokeRestart(restart)
[13:37:45.450]                             muffled <- TRUE
[13:37:45.450]                             break
[13:37:45.450]                           }
[13:37:45.450]                         }
[13:37:45.450]                       }
[13:37:45.450]                       invisible(muffled)
[13:37:45.450]                     }
[13:37:45.450]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.450]                   }
[13:37:45.450]                 }
[13:37:45.450]             }
[13:37:45.450]         }))
[13:37:45.450]     }, error = function(ex) {
[13:37:45.450]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:45.450]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.450]                 ...future.rng), started = ...future.startTime, 
[13:37:45.450]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:45.450]             version = "1.8"), class = "FutureResult")
[13:37:45.450]     }, finally = {
[13:37:45.450]         if (!identical(...future.workdir, getwd())) 
[13:37:45.450]             setwd(...future.workdir)
[13:37:45.450]         {
[13:37:45.450]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:45.450]                 ...future.oldOptions$nwarnings <- NULL
[13:37:45.450]             }
[13:37:45.450]             base::options(...future.oldOptions)
[13:37:45.450]             if (.Platform$OS.type == "windows") {
[13:37:45.450]                 old_names <- names(...future.oldEnvVars)
[13:37:45.450]                 envs <- base::Sys.getenv()
[13:37:45.450]                 names <- names(envs)
[13:37:45.450]                 common <- intersect(names, old_names)
[13:37:45.450]                 added <- setdiff(names, old_names)
[13:37:45.450]                 removed <- setdiff(old_names, names)
[13:37:45.450]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:45.450]                   envs[common]]
[13:37:45.450]                 NAMES <- toupper(changed)
[13:37:45.450]                 args <- list()
[13:37:45.450]                 for (kk in seq_along(NAMES)) {
[13:37:45.450]                   name <- changed[[kk]]
[13:37:45.450]                   NAME <- NAMES[[kk]]
[13:37:45.450]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.450]                     next
[13:37:45.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.450]                 }
[13:37:45.450]                 NAMES <- toupper(added)
[13:37:45.450]                 for (kk in seq_along(NAMES)) {
[13:37:45.450]                   name <- added[[kk]]
[13:37:45.450]                   NAME <- NAMES[[kk]]
[13:37:45.450]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.450]                     next
[13:37:45.450]                   args[[name]] <- ""
[13:37:45.450]                 }
[13:37:45.450]                 NAMES <- toupper(removed)
[13:37:45.450]                 for (kk in seq_along(NAMES)) {
[13:37:45.450]                   name <- removed[[kk]]
[13:37:45.450]                   NAME <- NAMES[[kk]]
[13:37:45.450]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.450]                     next
[13:37:45.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.450]                 }
[13:37:45.450]                 if (length(args) > 0) 
[13:37:45.450]                   base::do.call(base::Sys.setenv, args = args)
[13:37:45.450]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:45.450]             }
[13:37:45.450]             else {
[13:37:45.450]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:45.450]             }
[13:37:45.450]             {
[13:37:45.450]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:45.450]                   0L) {
[13:37:45.450]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:45.450]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:45.450]                   base::options(opts)
[13:37:45.450]                 }
[13:37:45.450]                 {
[13:37:45.450]                   {
[13:37:45.450]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:45.450]                     NULL
[13:37:45.450]                   }
[13:37:45.450]                   options(future.plan = NULL)
[13:37:45.450]                   if (is.na(NA_character_)) 
[13:37:45.450]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.450]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:45.450]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:45.450]                     .init = FALSE)
[13:37:45.450]                 }
[13:37:45.450]             }
[13:37:45.450]         }
[13:37:45.450]     })
[13:37:45.450]     if (TRUE) {
[13:37:45.450]         base::sink(type = "output", split = FALSE)
[13:37:45.450]         if (TRUE) {
[13:37:45.450]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:45.450]         }
[13:37:45.450]         else {
[13:37:45.450]             ...future.result["stdout"] <- base::list(NULL)
[13:37:45.450]         }
[13:37:45.450]         base::close(...future.stdout)
[13:37:45.450]         ...future.stdout <- NULL
[13:37:45.450]     }
[13:37:45.450]     ...future.result$conditions <- ...future.conditions
[13:37:45.450]     ...future.result$finished <- base::Sys.time()
[13:37:45.450]     ...future.result
[13:37:45.450] }
[13:37:45.453] requestCore(): workers = 2
[13:37:45.453] Poll #1 (0): usedCores() = 2, workers = 2
[13:37:45.464] result() for MulticoreFuture ...
[13:37:45.465] result() for MulticoreFuture ...
[13:37:45.465] result() for MulticoreFuture ... done
[13:37:45.465] result() for MulticoreFuture ... done
[13:37:45.465] result() for MulticoreFuture ...
[13:37:45.466] result() for MulticoreFuture ... done
[13:37:45.468] MulticoreFuture started
[13:37:45.469] - Launch lazy future ... done
[13:37:45.469] run() for ‘MulticoreFuture’ ... done
[13:37:45.470] plan(): Setting new future strategy stack:
[13:37:45.470] getGlobalsAndPackages() ...
[13:37:45.471] Searching for globals...
[13:37:45.470] List of future strategies:
[13:37:45.470] 1. sequential:
[13:37:45.470]    - args: function (..., envir = parent.frame())
[13:37:45.470]    - tweaked: FALSE
[13:37:45.470]    - call: NULL
[13:37:45.471] plan(): nbrOfWorkers() = 1
[13:37:45.473] - globals found: [1] ‘{’
[13:37:45.473] Searching for globals ... DONE
[13:37:45.473] Resolving globals: FALSE
[13:37:45.474] 
[13:37:45.474] 
[13:37:45.474] plan(): Setting new future strategy stack:
[13:37:45.475] getGlobalsAndPackages() ... DONE
[13:37:45.475] List of future strategies:
[13:37:45.475] 1. multicore:
[13:37:45.475]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:37:45.475]    - tweaked: FALSE
[13:37:45.475]    - call: plan(strategy)
[13:37:45.475] run() for ‘Future’ ...
[13:37:45.476] - state: ‘created’
[13:37:45.476] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:37:45.481] plan(): nbrOfWorkers() = 2
[13:37:45.481] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:45.481] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:37:45.482]   - Field: ‘label’
[13:37:45.482]   - Field: ‘local’
[13:37:45.482]   - Field: ‘owner’
[13:37:45.482]   - Field: ‘envir’
[13:37:45.482]   - Field: ‘workers’
[13:37:45.482]   - Field: ‘packages’
[13:37:45.483]   - Field: ‘gc’
[13:37:45.483]   - Field: ‘job’
[13:37:45.483]   - Field: ‘conditions’
[13:37:45.483]   - Field: ‘expr’
[13:37:45.483]   - Field: ‘uuid’
[13:37:45.483]   - Field: ‘seed’
[13:37:45.484]   - Field: ‘version’
[13:37:45.484]   - Field: ‘result’
[13:37:45.484]   - Field: ‘asynchronous’
[13:37:45.484]   - Field: ‘calls’
[13:37:45.484]   - Field: ‘globals’
[13:37:45.484]   - Field: ‘stdout’
[13:37:45.484]   - Field: ‘earlySignal’
[13:37:45.485]   - Field: ‘lazy’
[13:37:45.485]   - Field: ‘state’
[13:37:45.485] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:37:45.485] - Launch lazy future ...
[13:37:45.485] Packages needed by the future expression (n = 0): <none>
[13:37:45.486] Packages needed by future strategies (n = 0): <none>
[13:37:45.486] {
[13:37:45.486]     {
[13:37:45.486]         {
[13:37:45.486]             ...future.startTime <- base::Sys.time()
[13:37:45.486]             {
[13:37:45.486]                 {
[13:37:45.486]                   {
[13:37:45.486]                     {
[13:37:45.486]                       base::local({
[13:37:45.486]                         has_future <- base::requireNamespace("future", 
[13:37:45.486]                           quietly = TRUE)
[13:37:45.486]                         if (has_future) {
[13:37:45.486]                           ns <- base::getNamespace("future")
[13:37:45.486]                           version <- ns[[".package"]][["version"]]
[13:37:45.486]                           if (is.null(version)) 
[13:37:45.486]                             version <- utils::packageVersion("future")
[13:37:45.486]                         }
[13:37:45.486]                         else {
[13:37:45.486]                           version <- NULL
[13:37:45.486]                         }
[13:37:45.486]                         if (!has_future || version < "1.8.0") {
[13:37:45.486]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:45.486]                             "", base::R.version$version.string), 
[13:37:45.486]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:45.486]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:45.486]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:45.486]                               "release", "version")], collapse = " "), 
[13:37:45.486]                             hostname = base::Sys.info()[["nodename"]])
[13:37:45.486]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:45.486]                             info)
[13:37:45.486]                           info <- base::paste(info, collapse = "; ")
[13:37:45.486]                           if (!has_future) {
[13:37:45.486]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:45.486]                               info)
[13:37:45.486]                           }
[13:37:45.486]                           else {
[13:37:45.486]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:45.486]                               info, version)
[13:37:45.486]                           }
[13:37:45.486]                           base::stop(msg)
[13:37:45.486]                         }
[13:37:45.486]                       })
[13:37:45.486]                     }
[13:37:45.486]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:45.486]                     base::options(mc.cores = 1L)
[13:37:45.486]                   }
[13:37:45.486]                   ...future.strategy.old <- future::plan("list")
[13:37:45.486]                   options(future.plan = NULL)
[13:37:45.486]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.486]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:45.486]                 }
[13:37:45.486]                 ...future.workdir <- getwd()
[13:37:45.486]             }
[13:37:45.486]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:45.486]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:45.486]         }
[13:37:45.486]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:45.486]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:45.486]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:45.486]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:45.486]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:45.486]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:45.486]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:45.486]             base::names(...future.oldOptions))
[13:37:45.486]     }
[13:37:45.486]     if (FALSE) {
[13:37:45.486]     }
[13:37:45.486]     else {
[13:37:45.486]         if (TRUE) {
[13:37:45.486]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:45.486]                 open = "w")
[13:37:45.486]         }
[13:37:45.486]         else {
[13:37:45.486]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:45.486]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:45.486]         }
[13:37:45.486]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:45.486]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:45.486]             base::sink(type = "output", split = FALSE)
[13:37:45.486]             base::close(...future.stdout)
[13:37:45.486]         }, add = TRUE)
[13:37:45.486]     }
[13:37:45.486]     ...future.frame <- base::sys.nframe()
[13:37:45.486]     ...future.conditions <- base::list()
[13:37:45.486]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:45.486]     if (FALSE) {
[13:37:45.486]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:45.486]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:45.486]     }
[13:37:45.486]     ...future.result <- base::tryCatch({
[13:37:45.486]         base::withCallingHandlers({
[13:37:45.486]             ...future.value <- base::withVisible(base::local({
[13:37:45.486]                 withCallingHandlers({
[13:37:45.486]                   {
[13:37:45.486]                     2
[13:37:45.486]                   }
[13:37:45.486]                 }, immediateCondition = function(cond) {
[13:37:45.486]                   save_rds <- function (object, pathname, ...) 
[13:37:45.486]                   {
[13:37:45.486]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:37:45.486]                     if (file_test("-f", pathname_tmp)) {
[13:37:45.486]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.486]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:37:45.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.486]                         fi_tmp[["mtime"]])
[13:37:45.486]                     }
[13:37:45.486]                     tryCatch({
[13:37:45.486]                       saveRDS(object, file = pathname_tmp, ...)
[13:37:45.486]                     }, error = function(ex) {
[13:37:45.486]                       msg <- conditionMessage(ex)
[13:37:45.486]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.486]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:37:45.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.486]                         fi_tmp[["mtime"]], msg)
[13:37:45.486]                       ex$message <- msg
[13:37:45.486]                       stop(ex)
[13:37:45.486]                     })
[13:37:45.486]                     stopifnot(file_test("-f", pathname_tmp))
[13:37:45.486]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:37:45.486]                     if (!res || file_test("-f", pathname_tmp)) {
[13:37:45.486]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.486]                       fi <- file.info(pathname)
[13:37:45.486]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:37:45.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.486]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:37:45.486]                         fi[["size"]], fi[["mtime"]])
[13:37:45.486]                       stop(msg)
[13:37:45.486]                     }
[13:37:45.486]                     invisible(pathname)
[13:37:45.486]                   }
[13:37:45.486]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:37:45.486]                     rootPath = tempdir()) 
[13:37:45.486]                   {
[13:37:45.486]                     obj <- list(time = Sys.time(), condition = cond)
[13:37:45.486]                     file <- tempfile(pattern = class(cond)[1], 
[13:37:45.486]                       tmpdir = path, fileext = ".rds")
[13:37:45.486]                     save_rds(obj, file)
[13:37:45.486]                   }
[13:37:45.486]                   saveImmediateCondition(cond, path = "/tmp/RtmpLAMaHJ/.future/immediateConditions")
[13:37:45.486]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.486]                   {
[13:37:45.486]                     inherits <- base::inherits
[13:37:45.486]                     invokeRestart <- base::invokeRestart
[13:37:45.486]                     is.null <- base::is.null
[13:37:45.486]                     muffled <- FALSE
[13:37:45.486]                     if (inherits(cond, "message")) {
[13:37:45.486]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:45.486]                       if (muffled) 
[13:37:45.486]                         invokeRestart("muffleMessage")
[13:37:45.486]                     }
[13:37:45.486]                     else if (inherits(cond, "warning")) {
[13:37:45.486]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:45.486]                       if (muffled) 
[13:37:45.486]                         invokeRestart("muffleWarning")
[13:37:45.486]                     }
[13:37:45.486]                     else if (inherits(cond, "condition")) {
[13:37:45.486]                       if (!is.null(pattern)) {
[13:37:45.486]                         computeRestarts <- base::computeRestarts
[13:37:45.486]                         grepl <- base::grepl
[13:37:45.486]                         restarts <- computeRestarts(cond)
[13:37:45.486]                         for (restart in restarts) {
[13:37:45.486]                           name <- restart$name
[13:37:45.486]                           if (is.null(name)) 
[13:37:45.486]                             next
[13:37:45.486]                           if (!grepl(pattern, name)) 
[13:37:45.486]                             next
[13:37:45.486]                           invokeRestart(restart)
[13:37:45.486]                           muffled <- TRUE
[13:37:45.486]                           break
[13:37:45.486]                         }
[13:37:45.486]                       }
[13:37:45.486]                     }
[13:37:45.486]                     invisible(muffled)
[13:37:45.486]                   }
[13:37:45.486]                   muffleCondition(cond)
[13:37:45.486]                 })
[13:37:45.486]             }))
[13:37:45.486]             future::FutureResult(value = ...future.value$value, 
[13:37:45.486]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.486]                   ...future.rng), globalenv = if (FALSE) 
[13:37:45.486]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:45.486]                     ...future.globalenv.names))
[13:37:45.486]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:45.486]         }, condition = base::local({
[13:37:45.486]             c <- base::c
[13:37:45.486]             inherits <- base::inherits
[13:37:45.486]             invokeRestart <- base::invokeRestart
[13:37:45.486]             length <- base::length
[13:37:45.486]             list <- base::list
[13:37:45.486]             seq.int <- base::seq.int
[13:37:45.486]             signalCondition <- base::signalCondition
[13:37:45.486]             sys.calls <- base::sys.calls
[13:37:45.486]             `[[` <- base::`[[`
[13:37:45.486]             `+` <- base::`+`
[13:37:45.486]             `<<-` <- base::`<<-`
[13:37:45.486]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:45.486]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:45.486]                   3L)]
[13:37:45.486]             }
[13:37:45.486]             function(cond) {
[13:37:45.486]                 is_error <- inherits(cond, "error")
[13:37:45.486]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:45.486]                   NULL)
[13:37:45.486]                 if (is_error) {
[13:37:45.486]                   sessionInformation <- function() {
[13:37:45.486]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:45.486]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:45.486]                       search = base::search(), system = base::Sys.info())
[13:37:45.486]                   }
[13:37:45.486]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.486]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:45.486]                     cond$call), session = sessionInformation(), 
[13:37:45.486]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:45.486]                   signalCondition(cond)
[13:37:45.486]                 }
[13:37:45.486]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:45.486]                 "immediateCondition"))) {
[13:37:45.486]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:45.486]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.486]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:45.486]                   if (TRUE && !signal) {
[13:37:45.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.486]                     {
[13:37:45.486]                       inherits <- base::inherits
[13:37:45.486]                       invokeRestart <- base::invokeRestart
[13:37:45.486]                       is.null <- base::is.null
[13:37:45.486]                       muffled <- FALSE
[13:37:45.486]                       if (inherits(cond, "message")) {
[13:37:45.486]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.486]                         if (muffled) 
[13:37:45.486]                           invokeRestart("muffleMessage")
[13:37:45.486]                       }
[13:37:45.486]                       else if (inherits(cond, "warning")) {
[13:37:45.486]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.486]                         if (muffled) 
[13:37:45.486]                           invokeRestart("muffleWarning")
[13:37:45.486]                       }
[13:37:45.486]                       else if (inherits(cond, "condition")) {
[13:37:45.486]                         if (!is.null(pattern)) {
[13:37:45.486]                           computeRestarts <- base::computeRestarts
[13:37:45.486]                           grepl <- base::grepl
[13:37:45.486]                           restarts <- computeRestarts(cond)
[13:37:45.486]                           for (restart in restarts) {
[13:37:45.486]                             name <- restart$name
[13:37:45.486]                             if (is.null(name)) 
[13:37:45.486]                               next
[13:37:45.486]                             if (!grepl(pattern, name)) 
[13:37:45.486]                               next
[13:37:45.486]                             invokeRestart(restart)
[13:37:45.486]                             muffled <- TRUE
[13:37:45.486]                             break
[13:37:45.486]                           }
[13:37:45.486]                         }
[13:37:45.486]                       }
[13:37:45.486]                       invisible(muffled)
[13:37:45.486]                     }
[13:37:45.486]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.486]                   }
[13:37:45.486]                 }
[13:37:45.486]                 else {
[13:37:45.486]                   if (TRUE) {
[13:37:45.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.486]                     {
[13:37:45.486]                       inherits <- base::inherits
[13:37:45.486]                       invokeRestart <- base::invokeRestart
[13:37:45.486]                       is.null <- base::is.null
[13:37:45.486]                       muffled <- FALSE
[13:37:45.486]                       if (inherits(cond, "message")) {
[13:37:45.486]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.486]                         if (muffled) 
[13:37:45.486]                           invokeRestart("muffleMessage")
[13:37:45.486]                       }
[13:37:45.486]                       else if (inherits(cond, "warning")) {
[13:37:45.486]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.486]                         if (muffled) 
[13:37:45.486]                           invokeRestart("muffleWarning")
[13:37:45.486]                       }
[13:37:45.486]                       else if (inherits(cond, "condition")) {
[13:37:45.486]                         if (!is.null(pattern)) {
[13:37:45.486]                           computeRestarts <- base::computeRestarts
[13:37:45.486]                           grepl <- base::grepl
[13:37:45.486]                           restarts <- computeRestarts(cond)
[13:37:45.486]                           for (restart in restarts) {
[13:37:45.486]                             name <- restart$name
[13:37:45.486]                             if (is.null(name)) 
[13:37:45.486]                               next
[13:37:45.486]                             if (!grepl(pattern, name)) 
[13:37:45.486]                               next
[13:37:45.486]                             invokeRestart(restart)
[13:37:45.486]                             muffled <- TRUE
[13:37:45.486]                             break
[13:37:45.486]                           }
[13:37:45.486]                         }
[13:37:45.486]                       }
[13:37:45.486]                       invisible(muffled)
[13:37:45.486]                     }
[13:37:45.486]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.486]                   }
[13:37:45.486]                 }
[13:37:45.486]             }
[13:37:45.486]         }))
[13:37:45.486]     }, error = function(ex) {
[13:37:45.486]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:45.486]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.486]                 ...future.rng), started = ...future.startTime, 
[13:37:45.486]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:45.486]             version = "1.8"), class = "FutureResult")
[13:37:45.486]     }, finally = {
[13:37:45.486]         if (!identical(...future.workdir, getwd())) 
[13:37:45.486]             setwd(...future.workdir)
[13:37:45.486]         {
[13:37:45.486]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:45.486]                 ...future.oldOptions$nwarnings <- NULL
[13:37:45.486]             }
[13:37:45.486]             base::options(...future.oldOptions)
[13:37:45.486]             if (.Platform$OS.type == "windows") {
[13:37:45.486]                 old_names <- names(...future.oldEnvVars)
[13:37:45.486]                 envs <- base::Sys.getenv()
[13:37:45.486]                 names <- names(envs)
[13:37:45.486]                 common <- intersect(names, old_names)
[13:37:45.486]                 added <- setdiff(names, old_names)
[13:37:45.486]                 removed <- setdiff(old_names, names)
[13:37:45.486]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:45.486]                   envs[common]]
[13:37:45.486]                 NAMES <- toupper(changed)
[13:37:45.486]                 args <- list()
[13:37:45.486]                 for (kk in seq_along(NAMES)) {
[13:37:45.486]                   name <- changed[[kk]]
[13:37:45.486]                   NAME <- NAMES[[kk]]
[13:37:45.486]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.486]                     next
[13:37:45.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.486]                 }
[13:37:45.486]                 NAMES <- toupper(added)
[13:37:45.486]                 for (kk in seq_along(NAMES)) {
[13:37:45.486]                   name <- added[[kk]]
[13:37:45.486]                   NAME <- NAMES[[kk]]
[13:37:45.486]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.486]                     next
[13:37:45.486]                   args[[name]] <- ""
[13:37:45.486]                 }
[13:37:45.486]                 NAMES <- toupper(removed)
[13:37:45.486]                 for (kk in seq_along(NAMES)) {
[13:37:45.486]                   name <- removed[[kk]]
[13:37:45.486]                   NAME <- NAMES[[kk]]
[13:37:45.486]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.486]                     next
[13:37:45.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.486]                 }
[13:37:45.486]                 if (length(args) > 0) 
[13:37:45.486]                   base::do.call(base::Sys.setenv, args = args)
[13:37:45.486]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:45.486]             }
[13:37:45.486]             else {
[13:37:45.486]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:45.486]             }
[13:37:45.486]             {
[13:37:45.486]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:45.486]                   0L) {
[13:37:45.486]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:45.486]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:45.486]                   base::options(opts)
[13:37:45.486]                 }
[13:37:45.486]                 {
[13:37:45.486]                   {
[13:37:45.486]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:45.486]                     NULL
[13:37:45.486]                   }
[13:37:45.486]                   options(future.plan = NULL)
[13:37:45.486]                   if (is.na(NA_character_)) 
[13:37:45.486]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.486]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:45.486]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:45.486]                     .init = FALSE)
[13:37:45.486]                 }
[13:37:45.486]             }
[13:37:45.486]         }
[13:37:45.486]     })
[13:37:45.486]     if (TRUE) {
[13:37:45.486]         base::sink(type = "output", split = FALSE)
[13:37:45.486]         if (TRUE) {
[13:37:45.486]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:45.486]         }
[13:37:45.486]         else {
[13:37:45.486]             ...future.result["stdout"] <- base::list(NULL)
[13:37:45.486]         }
[13:37:45.486]         base::close(...future.stdout)
[13:37:45.486]         ...future.stdout <- NULL
[13:37:45.486]     }
[13:37:45.486]     ...future.result$conditions <- ...future.conditions
[13:37:45.486]     ...future.result$finished <- base::Sys.time()
[13:37:45.486]     ...future.result
[13:37:45.486] }
[13:37:45.490] requestCore(): workers = 2
[13:37:45.490] Poll #1 (0): usedCores() = 2, workers = 2
[13:37:45.501] result() for MulticoreFuture ...
[13:37:45.502] result() for MulticoreFuture ...
[13:37:45.502] result() for MulticoreFuture ... done
[13:37:45.503] result() for MulticoreFuture ... done
[13:37:45.503] result() for MulticoreFuture ...
[13:37:45.503] result() for MulticoreFuture ... done
[13:37:45.505] MulticoreFuture started
[13:37:45.506] - Launch lazy future ... done
[13:37:45.506] run() for ‘MulticoreFuture’ ... done
[13:37:45.507] plan(): Setting new future strategy stack:
[13:37:45.507] List of future strategies:
[13:37:45.507] 1. sequential:
[13:37:45.507]    - args: function (..., envir = parent.frame())
[13:37:45.507]    - tweaked: FALSE
[13:37:45.507]    - call: NULL
[13:37:45.508] resolve() on environment ...
[13:37:45.509]  recursive: 0
[13:37:45.509] plan(): nbrOfWorkers() = 1
[13:37:45.510]  elements: [3] ‘a’
[13:37:45.510] Future #1
[13:37:45.511]  length: 2 (resolved future 1)
[13:37:45.512] plan(): Setting new future strategy stack:
[13:37:45.512] List of future strategies:
[13:37:45.512] 1. multicore:
[13:37:45.512]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:37:45.512]    - tweaked: FALSE
[13:37:45.512]    - call: plan(strategy)
[13:37:45.517] plan(): nbrOfWorkers() = 2
[13:37:45.518] Future #2
[13:37:45.518]  length: 1 (resolved future 2)
[13:37:45.518]  length: 0 (resolved future 3)
[13:37:45.518] resolve() on environment ... DONE
[13:37:45.519] resolve() on environment ...
[13:37:45.520]  recursive: 0
[13:37:45.520]  elements: [3] ‘b’
[13:37:45.521] Future #1
[13:37:45.521]  length: 2 (resolved future 1)
[13:37:45.521] Future #2
[13:37:45.521]  length: 1 (resolved future 2)
[13:37:45.522]  length: 0 (resolved future 3)
[13:37:45.522] resolve() on environment ... DONE
[13:37:45.522] resolve() on environment ...
[13:37:45.523]  recursive: 0
[13:37:45.523]  elements: [3] ‘c’
[13:37:45.524] Future #1
[13:37:45.524]  length: 2 (resolved future 1)
[13:37:45.529] Future #2
[13:37:45.529]  length: 1 (resolved future 2)
[13:37:45.529]  length: 0 (resolved future 3)
[13:37:45.530] resolve() on environment ... DONE
[13:37:45.532] resolve() on environment ...
[13:37:45.532]  recursive: 0
[13:37:45.533]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[13:37:45.534] Future #1
[13:37:45.534] result() for MulticoreFuture ...
[13:37:45.535] result() for MulticoreFuture ...
[13:37:45.535] result() for MulticoreFuture ... done
[13:37:45.535] result() for MulticoreFuture ... done
[13:37:45.536] result() for MulticoreFuture ...
[13:37:45.536] result() for MulticoreFuture ... done
[13:37:45.536]  length: 2 (resolved future 1)
[13:37:45.536] Future #2
[13:37:45.537] result() for MulticoreFuture ...
[13:37:45.537] result() for MulticoreFuture ...
[13:37:45.538] result() for MulticoreFuture ... done
[13:37:45.538] result() for MulticoreFuture ... done
[13:37:45.538] result() for MulticoreFuture ...
[13:37:45.538] result() for MulticoreFuture ... done
[13:37:45.539]  length: 1 (resolved future 2)
[13:37:45.539]  length: 0 (resolved future 3)
[13:37:45.539] resolve() on environment ... DONE
[13:37:45.540] resolve() on environment ...
[13:37:45.540]  recursive: 99
[13:37:45.541]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[13:37:45.541] Future #1
[13:37:45.541] result() for MulticoreFuture ...
[13:37:45.542] result() for MulticoreFuture ... done
[13:37:45.542] result() for MulticoreFuture ...
[13:37:45.542] result() for MulticoreFuture ... done
[13:37:45.542] A MulticoreFuture was resolved
[13:37:45.542]  length: 2 (resolved future 1)
[13:37:45.542] Future #2
[13:37:45.542] result() for MulticoreFuture ...
[13:37:45.542] result() for MulticoreFuture ... done
[13:37:45.543] result() for MulticoreFuture ...
[13:37:45.543] result() for MulticoreFuture ... done
[13:37:45.543] A MulticoreFuture was resolved
[13:37:45.543]  length: 1 (resolved future 2)
[13:37:45.543]  length: 0 (resolved future 3)
[13:37:45.543] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[13:37:45.544] resolve() on list environment ...
[13:37:45.544]  recursive: 0
[13:37:45.545]  length: 2
[13:37:45.545]  elements: ‘a’, ‘b’
[13:37:45.545]  length: 1 (resolved future 1)
[13:37:45.545]  length: 0 (resolved future 2)
[13:37:45.545] resolve() on list environment ... DONE
[13:37:45.545] getGlobalsAndPackages() ...
[13:37:45.546] Searching for globals...
[13:37:45.546] 
[13:37:45.546] Searching for globals ... DONE
[13:37:45.546] - globals: [0] <none>
[13:37:45.546] getGlobalsAndPackages() ... DONE
[13:37:45.547] run() for ‘Future’ ...
[13:37:45.547] - state: ‘created’
[13:37:45.547] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:37:45.551] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:45.552] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:37:45.552]   - Field: ‘label’
[13:37:45.552]   - Field: ‘local’
[13:37:45.552]   - Field: ‘owner’
[13:37:45.552]   - Field: ‘envir’
[13:37:45.552]   - Field: ‘workers’
[13:37:45.552]   - Field: ‘packages’
[13:37:45.552]   - Field: ‘gc’
[13:37:45.553]   - Field: ‘job’
[13:37:45.553]   - Field: ‘conditions’
[13:37:45.553]   - Field: ‘expr’
[13:37:45.553]   - Field: ‘uuid’
[13:37:45.553]   - Field: ‘seed’
[13:37:45.553]   - Field: ‘version’
[13:37:45.553]   - Field: ‘result’
[13:37:45.553]   - Field: ‘asynchronous’
[13:37:45.553]   - Field: ‘calls’
[13:37:45.553]   - Field: ‘globals’
[13:37:45.554]   - Field: ‘stdout’
[13:37:45.554]   - Field: ‘earlySignal’
[13:37:45.554]   - Field: ‘lazy’
[13:37:45.554]   - Field: ‘state’
[13:37:45.554] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:37:45.554] - Launch lazy future ...
[13:37:45.554] Packages needed by the future expression (n = 0): <none>
[13:37:45.555] Packages needed by future strategies (n = 0): <none>
[13:37:45.555] {
[13:37:45.555]     {
[13:37:45.555]         {
[13:37:45.555]             ...future.startTime <- base::Sys.time()
[13:37:45.555]             {
[13:37:45.555]                 {
[13:37:45.555]                   {
[13:37:45.555]                     {
[13:37:45.555]                       base::local({
[13:37:45.555]                         has_future <- base::requireNamespace("future", 
[13:37:45.555]                           quietly = TRUE)
[13:37:45.555]                         if (has_future) {
[13:37:45.555]                           ns <- base::getNamespace("future")
[13:37:45.555]                           version <- ns[[".package"]][["version"]]
[13:37:45.555]                           if (is.null(version)) 
[13:37:45.555]                             version <- utils::packageVersion("future")
[13:37:45.555]                         }
[13:37:45.555]                         else {
[13:37:45.555]                           version <- NULL
[13:37:45.555]                         }
[13:37:45.555]                         if (!has_future || version < "1.8.0") {
[13:37:45.555]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:45.555]                             "", base::R.version$version.string), 
[13:37:45.555]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:45.555]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:45.555]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:45.555]                               "release", "version")], collapse = " "), 
[13:37:45.555]                             hostname = base::Sys.info()[["nodename"]])
[13:37:45.555]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:45.555]                             info)
[13:37:45.555]                           info <- base::paste(info, collapse = "; ")
[13:37:45.555]                           if (!has_future) {
[13:37:45.555]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:45.555]                               info)
[13:37:45.555]                           }
[13:37:45.555]                           else {
[13:37:45.555]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:45.555]                               info, version)
[13:37:45.555]                           }
[13:37:45.555]                           base::stop(msg)
[13:37:45.555]                         }
[13:37:45.555]                       })
[13:37:45.555]                     }
[13:37:45.555]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:45.555]                     base::options(mc.cores = 1L)
[13:37:45.555]                   }
[13:37:45.555]                   ...future.strategy.old <- future::plan("list")
[13:37:45.555]                   options(future.plan = NULL)
[13:37:45.555]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.555]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:45.555]                 }
[13:37:45.555]                 ...future.workdir <- getwd()
[13:37:45.555]             }
[13:37:45.555]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:45.555]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:45.555]         }
[13:37:45.555]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:45.555]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:45.555]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:45.555]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:45.555]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:45.555]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:45.555]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:45.555]             base::names(...future.oldOptions))
[13:37:45.555]     }
[13:37:45.555]     if (FALSE) {
[13:37:45.555]     }
[13:37:45.555]     else {
[13:37:45.555]         if (TRUE) {
[13:37:45.555]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:45.555]                 open = "w")
[13:37:45.555]         }
[13:37:45.555]         else {
[13:37:45.555]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:45.555]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:45.555]         }
[13:37:45.555]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:45.555]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:45.555]             base::sink(type = "output", split = FALSE)
[13:37:45.555]             base::close(...future.stdout)
[13:37:45.555]         }, add = TRUE)
[13:37:45.555]     }
[13:37:45.555]     ...future.frame <- base::sys.nframe()
[13:37:45.555]     ...future.conditions <- base::list()
[13:37:45.555]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:45.555]     if (FALSE) {
[13:37:45.555]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:45.555]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:45.555]     }
[13:37:45.555]     ...future.result <- base::tryCatch({
[13:37:45.555]         base::withCallingHandlers({
[13:37:45.555]             ...future.value <- base::withVisible(base::local({
[13:37:45.555]                 withCallingHandlers({
[13:37:45.555]                   1
[13:37:45.555]                 }, immediateCondition = function(cond) {
[13:37:45.555]                   save_rds <- function (object, pathname, ...) 
[13:37:45.555]                   {
[13:37:45.555]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:37:45.555]                     if (file_test("-f", pathname_tmp)) {
[13:37:45.555]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.555]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:37:45.555]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.555]                         fi_tmp[["mtime"]])
[13:37:45.555]                     }
[13:37:45.555]                     tryCatch({
[13:37:45.555]                       saveRDS(object, file = pathname_tmp, ...)
[13:37:45.555]                     }, error = function(ex) {
[13:37:45.555]                       msg <- conditionMessage(ex)
[13:37:45.555]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.555]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:37:45.555]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.555]                         fi_tmp[["mtime"]], msg)
[13:37:45.555]                       ex$message <- msg
[13:37:45.555]                       stop(ex)
[13:37:45.555]                     })
[13:37:45.555]                     stopifnot(file_test("-f", pathname_tmp))
[13:37:45.555]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:37:45.555]                     if (!res || file_test("-f", pathname_tmp)) {
[13:37:45.555]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.555]                       fi <- file.info(pathname)
[13:37:45.555]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:37:45.555]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.555]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:37:45.555]                         fi[["size"]], fi[["mtime"]])
[13:37:45.555]                       stop(msg)
[13:37:45.555]                     }
[13:37:45.555]                     invisible(pathname)
[13:37:45.555]                   }
[13:37:45.555]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:37:45.555]                     rootPath = tempdir()) 
[13:37:45.555]                   {
[13:37:45.555]                     obj <- list(time = Sys.time(), condition = cond)
[13:37:45.555]                     file <- tempfile(pattern = class(cond)[1], 
[13:37:45.555]                       tmpdir = path, fileext = ".rds")
[13:37:45.555]                     save_rds(obj, file)
[13:37:45.555]                   }
[13:37:45.555]                   saveImmediateCondition(cond, path = "/tmp/RtmpLAMaHJ/.future/immediateConditions")
[13:37:45.555]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.555]                   {
[13:37:45.555]                     inherits <- base::inherits
[13:37:45.555]                     invokeRestart <- base::invokeRestart
[13:37:45.555]                     is.null <- base::is.null
[13:37:45.555]                     muffled <- FALSE
[13:37:45.555]                     if (inherits(cond, "message")) {
[13:37:45.555]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:45.555]                       if (muffled) 
[13:37:45.555]                         invokeRestart("muffleMessage")
[13:37:45.555]                     }
[13:37:45.555]                     else if (inherits(cond, "warning")) {
[13:37:45.555]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:45.555]                       if (muffled) 
[13:37:45.555]                         invokeRestart("muffleWarning")
[13:37:45.555]                     }
[13:37:45.555]                     else if (inherits(cond, "condition")) {
[13:37:45.555]                       if (!is.null(pattern)) {
[13:37:45.555]                         computeRestarts <- base::computeRestarts
[13:37:45.555]                         grepl <- base::grepl
[13:37:45.555]                         restarts <- computeRestarts(cond)
[13:37:45.555]                         for (restart in restarts) {
[13:37:45.555]                           name <- restart$name
[13:37:45.555]                           if (is.null(name)) 
[13:37:45.555]                             next
[13:37:45.555]                           if (!grepl(pattern, name)) 
[13:37:45.555]                             next
[13:37:45.555]                           invokeRestart(restart)
[13:37:45.555]                           muffled <- TRUE
[13:37:45.555]                           break
[13:37:45.555]                         }
[13:37:45.555]                       }
[13:37:45.555]                     }
[13:37:45.555]                     invisible(muffled)
[13:37:45.555]                   }
[13:37:45.555]                   muffleCondition(cond)
[13:37:45.555]                 })
[13:37:45.555]             }))
[13:37:45.555]             future::FutureResult(value = ...future.value$value, 
[13:37:45.555]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.555]                   ...future.rng), globalenv = if (FALSE) 
[13:37:45.555]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:45.555]                     ...future.globalenv.names))
[13:37:45.555]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:45.555]         }, condition = base::local({
[13:37:45.555]             c <- base::c
[13:37:45.555]             inherits <- base::inherits
[13:37:45.555]             invokeRestart <- base::invokeRestart
[13:37:45.555]             length <- base::length
[13:37:45.555]             list <- base::list
[13:37:45.555]             seq.int <- base::seq.int
[13:37:45.555]             signalCondition <- base::signalCondition
[13:37:45.555]             sys.calls <- base::sys.calls
[13:37:45.555]             `[[` <- base::`[[`
[13:37:45.555]             `+` <- base::`+`
[13:37:45.555]             `<<-` <- base::`<<-`
[13:37:45.555]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:45.555]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:45.555]                   3L)]
[13:37:45.555]             }
[13:37:45.555]             function(cond) {
[13:37:45.555]                 is_error <- inherits(cond, "error")
[13:37:45.555]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:45.555]                   NULL)
[13:37:45.555]                 if (is_error) {
[13:37:45.555]                   sessionInformation <- function() {
[13:37:45.555]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:45.555]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:45.555]                       search = base::search(), system = base::Sys.info())
[13:37:45.555]                   }
[13:37:45.555]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.555]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:45.555]                     cond$call), session = sessionInformation(), 
[13:37:45.555]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:45.555]                   signalCondition(cond)
[13:37:45.555]                 }
[13:37:45.555]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:45.555]                 "immediateCondition"))) {
[13:37:45.555]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:45.555]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.555]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:45.555]                   if (TRUE && !signal) {
[13:37:45.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.555]                     {
[13:37:45.555]                       inherits <- base::inherits
[13:37:45.555]                       invokeRestart <- base::invokeRestart
[13:37:45.555]                       is.null <- base::is.null
[13:37:45.555]                       muffled <- FALSE
[13:37:45.555]                       if (inherits(cond, "message")) {
[13:37:45.555]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.555]                         if (muffled) 
[13:37:45.555]                           invokeRestart("muffleMessage")
[13:37:45.555]                       }
[13:37:45.555]                       else if (inherits(cond, "warning")) {
[13:37:45.555]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.555]                         if (muffled) 
[13:37:45.555]                           invokeRestart("muffleWarning")
[13:37:45.555]                       }
[13:37:45.555]                       else if (inherits(cond, "condition")) {
[13:37:45.555]                         if (!is.null(pattern)) {
[13:37:45.555]                           computeRestarts <- base::computeRestarts
[13:37:45.555]                           grepl <- base::grepl
[13:37:45.555]                           restarts <- computeRestarts(cond)
[13:37:45.555]                           for (restart in restarts) {
[13:37:45.555]                             name <- restart$name
[13:37:45.555]                             if (is.null(name)) 
[13:37:45.555]                               next
[13:37:45.555]                             if (!grepl(pattern, name)) 
[13:37:45.555]                               next
[13:37:45.555]                             invokeRestart(restart)
[13:37:45.555]                             muffled <- TRUE
[13:37:45.555]                             break
[13:37:45.555]                           }
[13:37:45.555]                         }
[13:37:45.555]                       }
[13:37:45.555]                       invisible(muffled)
[13:37:45.555]                     }
[13:37:45.555]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.555]                   }
[13:37:45.555]                 }
[13:37:45.555]                 else {
[13:37:45.555]                   if (TRUE) {
[13:37:45.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.555]                     {
[13:37:45.555]                       inherits <- base::inherits
[13:37:45.555]                       invokeRestart <- base::invokeRestart
[13:37:45.555]                       is.null <- base::is.null
[13:37:45.555]                       muffled <- FALSE
[13:37:45.555]                       if (inherits(cond, "message")) {
[13:37:45.555]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.555]                         if (muffled) 
[13:37:45.555]                           invokeRestart("muffleMessage")
[13:37:45.555]                       }
[13:37:45.555]                       else if (inherits(cond, "warning")) {
[13:37:45.555]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.555]                         if (muffled) 
[13:37:45.555]                           invokeRestart("muffleWarning")
[13:37:45.555]                       }
[13:37:45.555]                       else if (inherits(cond, "condition")) {
[13:37:45.555]                         if (!is.null(pattern)) {
[13:37:45.555]                           computeRestarts <- base::computeRestarts
[13:37:45.555]                           grepl <- base::grepl
[13:37:45.555]                           restarts <- computeRestarts(cond)
[13:37:45.555]                           for (restart in restarts) {
[13:37:45.555]                             name <- restart$name
[13:37:45.555]                             if (is.null(name)) 
[13:37:45.555]                               next
[13:37:45.555]                             if (!grepl(pattern, name)) 
[13:37:45.555]                               next
[13:37:45.555]                             invokeRestart(restart)
[13:37:45.555]                             muffled <- TRUE
[13:37:45.555]                             break
[13:37:45.555]                           }
[13:37:45.555]                         }
[13:37:45.555]                       }
[13:37:45.555]                       invisible(muffled)
[13:37:45.555]                     }
[13:37:45.555]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.555]                   }
[13:37:45.555]                 }
[13:37:45.555]             }
[13:37:45.555]         }))
[13:37:45.555]     }, error = function(ex) {
[13:37:45.555]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:45.555]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.555]                 ...future.rng), started = ...future.startTime, 
[13:37:45.555]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:45.555]             version = "1.8"), class = "FutureResult")
[13:37:45.555]     }, finally = {
[13:37:45.555]         if (!identical(...future.workdir, getwd())) 
[13:37:45.555]             setwd(...future.workdir)
[13:37:45.555]         {
[13:37:45.555]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:45.555]                 ...future.oldOptions$nwarnings <- NULL
[13:37:45.555]             }
[13:37:45.555]             base::options(...future.oldOptions)
[13:37:45.555]             if (.Platform$OS.type == "windows") {
[13:37:45.555]                 old_names <- names(...future.oldEnvVars)
[13:37:45.555]                 envs <- base::Sys.getenv()
[13:37:45.555]                 names <- names(envs)
[13:37:45.555]                 common <- intersect(names, old_names)
[13:37:45.555]                 added <- setdiff(names, old_names)
[13:37:45.555]                 removed <- setdiff(old_names, names)
[13:37:45.555]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:45.555]                   envs[common]]
[13:37:45.555]                 NAMES <- toupper(changed)
[13:37:45.555]                 args <- list()
[13:37:45.555]                 for (kk in seq_along(NAMES)) {
[13:37:45.555]                   name <- changed[[kk]]
[13:37:45.555]                   NAME <- NAMES[[kk]]
[13:37:45.555]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.555]                     next
[13:37:45.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.555]                 }
[13:37:45.555]                 NAMES <- toupper(added)
[13:37:45.555]                 for (kk in seq_along(NAMES)) {
[13:37:45.555]                   name <- added[[kk]]
[13:37:45.555]                   NAME <- NAMES[[kk]]
[13:37:45.555]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.555]                     next
[13:37:45.555]                   args[[name]] <- ""
[13:37:45.555]                 }
[13:37:45.555]                 NAMES <- toupper(removed)
[13:37:45.555]                 for (kk in seq_along(NAMES)) {
[13:37:45.555]                   name <- removed[[kk]]
[13:37:45.555]                   NAME <- NAMES[[kk]]
[13:37:45.555]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.555]                     next
[13:37:45.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.555]                 }
[13:37:45.555]                 if (length(args) > 0) 
[13:37:45.555]                   base::do.call(base::Sys.setenv, args = args)
[13:37:45.555]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:45.555]             }
[13:37:45.555]             else {
[13:37:45.555]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:45.555]             }
[13:37:45.555]             {
[13:37:45.555]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:45.555]                   0L) {
[13:37:45.555]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:45.555]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:45.555]                   base::options(opts)
[13:37:45.555]                 }
[13:37:45.555]                 {
[13:37:45.555]                   {
[13:37:45.555]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:45.555]                     NULL
[13:37:45.555]                   }
[13:37:45.555]                   options(future.plan = NULL)
[13:37:45.555]                   if (is.na(NA_character_)) 
[13:37:45.555]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.555]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:45.555]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:45.555]                     .init = FALSE)
[13:37:45.555]                 }
[13:37:45.555]             }
[13:37:45.555]         }
[13:37:45.555]     })
[13:37:45.555]     if (TRUE) {
[13:37:45.555]         base::sink(type = "output", split = FALSE)
[13:37:45.555]         if (TRUE) {
[13:37:45.555]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:45.555]         }
[13:37:45.555]         else {
[13:37:45.555]             ...future.result["stdout"] <- base::list(NULL)
[13:37:45.555]         }
[13:37:45.555]         base::close(...future.stdout)
[13:37:45.555]         ...future.stdout <- NULL
[13:37:45.555]     }
[13:37:45.555]     ...future.result$conditions <- ...future.conditions
[13:37:45.555]     ...future.result$finished <- base::Sys.time()
[13:37:45.555]     ...future.result
[13:37:45.555] }
[13:37:45.558] requestCore(): workers = 2
[13:37:45.560] MulticoreFuture started
[13:37:45.560] - Launch lazy future ... done
[13:37:45.560] run() for ‘MulticoreFuture’ ... done
[13:37:45.561] getGlobalsAndPackages() ...
[13:37:45.561] Searching for globals...
[13:37:45.561] plan(): Setting new future strategy stack:
[13:37:45.562] 
[13:37:45.561] List of future strategies:
[13:37:45.561] 1. sequential:
[13:37:45.561]    - args: function (..., envir = parent.frame())
[13:37:45.561]    - tweaked: FALSE
[13:37:45.561]    - call: NULL
[13:37:45.562] Searching for globals ... DONE
[13:37:45.562] plan(): nbrOfWorkers() = 1
[13:37:45.562] - globals: [0] <none>
[13:37:45.562] getGlobalsAndPackages() ... DONE
[13:37:45.563] run() for ‘Future’ ...
[13:37:45.563] - state: ‘created’
[13:37:45.563] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:37:45.564] plan(): Setting new future strategy stack:
[13:37:45.564] List of future strategies:
[13:37:45.564] 1. multicore:
[13:37:45.564]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:37:45.564]    - tweaked: FALSE
[13:37:45.564]    - call: plan(strategy)
[13:37:45.569] plan(): nbrOfWorkers() = 2
[13:37:45.569] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:45.569] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:37:45.569]   - Field: ‘label’
[13:37:45.570]   - Field: ‘local’
[13:37:45.570]   - Field: ‘owner’
[13:37:45.570]   - Field: ‘envir’
[13:37:45.570]   - Field: ‘workers’
[13:37:45.570]   - Field: ‘packages’
[13:37:45.570]   - Field: ‘gc’
[13:37:45.571]   - Field: ‘job’
[13:37:45.571]   - Field: ‘conditions’
[13:37:45.571]   - Field: ‘expr’
[13:37:45.571]   - Field: ‘uuid’
[13:37:45.571]   - Field: ‘seed’
[13:37:45.571]   - Field: ‘version’
[13:37:45.572]   - Field: ‘result’
[13:37:45.572]   - Field: ‘asynchronous’
[13:37:45.572]   - Field: ‘calls’
[13:37:45.572]   - Field: ‘globals’
[13:37:45.572]   - Field: ‘stdout’
[13:37:45.572]   - Field: ‘earlySignal’
[13:37:45.573]   - Field: ‘lazy’
[13:37:45.573]   - Field: ‘state’
[13:37:45.573] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:37:45.573] - Launch lazy future ...
[13:37:45.573] Packages needed by the future expression (n = 0): <none>
[13:37:45.574] Packages needed by future strategies (n = 0): <none>
[13:37:45.574] {
[13:37:45.574]     {
[13:37:45.574]         {
[13:37:45.574]             ...future.startTime <- base::Sys.time()
[13:37:45.574]             {
[13:37:45.574]                 {
[13:37:45.574]                   {
[13:37:45.574]                     {
[13:37:45.574]                       base::local({
[13:37:45.574]                         has_future <- base::requireNamespace("future", 
[13:37:45.574]                           quietly = TRUE)
[13:37:45.574]                         if (has_future) {
[13:37:45.574]                           ns <- base::getNamespace("future")
[13:37:45.574]                           version <- ns[[".package"]][["version"]]
[13:37:45.574]                           if (is.null(version)) 
[13:37:45.574]                             version <- utils::packageVersion("future")
[13:37:45.574]                         }
[13:37:45.574]                         else {
[13:37:45.574]                           version <- NULL
[13:37:45.574]                         }
[13:37:45.574]                         if (!has_future || version < "1.8.0") {
[13:37:45.574]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:45.574]                             "", base::R.version$version.string), 
[13:37:45.574]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:45.574]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:45.574]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:45.574]                               "release", "version")], collapse = " "), 
[13:37:45.574]                             hostname = base::Sys.info()[["nodename"]])
[13:37:45.574]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:45.574]                             info)
[13:37:45.574]                           info <- base::paste(info, collapse = "; ")
[13:37:45.574]                           if (!has_future) {
[13:37:45.574]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:45.574]                               info)
[13:37:45.574]                           }
[13:37:45.574]                           else {
[13:37:45.574]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:45.574]                               info, version)
[13:37:45.574]                           }
[13:37:45.574]                           base::stop(msg)
[13:37:45.574]                         }
[13:37:45.574]                       })
[13:37:45.574]                     }
[13:37:45.574]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:45.574]                     base::options(mc.cores = 1L)
[13:37:45.574]                   }
[13:37:45.574]                   ...future.strategy.old <- future::plan("list")
[13:37:45.574]                   options(future.plan = NULL)
[13:37:45.574]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.574]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:45.574]                 }
[13:37:45.574]                 ...future.workdir <- getwd()
[13:37:45.574]             }
[13:37:45.574]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:45.574]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:45.574]         }
[13:37:45.574]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:45.574]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:45.574]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:45.574]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:45.574]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:45.574]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:45.574]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:45.574]             base::names(...future.oldOptions))
[13:37:45.574]     }
[13:37:45.574]     if (FALSE) {
[13:37:45.574]     }
[13:37:45.574]     else {
[13:37:45.574]         if (TRUE) {
[13:37:45.574]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:45.574]                 open = "w")
[13:37:45.574]         }
[13:37:45.574]         else {
[13:37:45.574]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:45.574]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:45.574]         }
[13:37:45.574]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:45.574]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:45.574]             base::sink(type = "output", split = FALSE)
[13:37:45.574]             base::close(...future.stdout)
[13:37:45.574]         }, add = TRUE)
[13:37:45.574]     }
[13:37:45.574]     ...future.frame <- base::sys.nframe()
[13:37:45.574]     ...future.conditions <- base::list()
[13:37:45.574]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:45.574]     if (FALSE) {
[13:37:45.574]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:45.574]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:45.574]     }
[13:37:45.574]     ...future.result <- base::tryCatch({
[13:37:45.574]         base::withCallingHandlers({
[13:37:45.574]             ...future.value <- base::withVisible(base::local({
[13:37:45.574]                 withCallingHandlers({
[13:37:45.574]                   2
[13:37:45.574]                 }, immediateCondition = function(cond) {
[13:37:45.574]                   save_rds <- function (object, pathname, ...) 
[13:37:45.574]                   {
[13:37:45.574]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:37:45.574]                     if (file_test("-f", pathname_tmp)) {
[13:37:45.574]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.574]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:37:45.574]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.574]                         fi_tmp[["mtime"]])
[13:37:45.574]                     }
[13:37:45.574]                     tryCatch({
[13:37:45.574]                       saveRDS(object, file = pathname_tmp, ...)
[13:37:45.574]                     }, error = function(ex) {
[13:37:45.574]                       msg <- conditionMessage(ex)
[13:37:45.574]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.574]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:37:45.574]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.574]                         fi_tmp[["mtime"]], msg)
[13:37:45.574]                       ex$message <- msg
[13:37:45.574]                       stop(ex)
[13:37:45.574]                     })
[13:37:45.574]                     stopifnot(file_test("-f", pathname_tmp))
[13:37:45.574]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:37:45.574]                     if (!res || file_test("-f", pathname_tmp)) {
[13:37:45.574]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.574]                       fi <- file.info(pathname)
[13:37:45.574]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:37:45.574]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.574]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:37:45.574]                         fi[["size"]], fi[["mtime"]])
[13:37:45.574]                       stop(msg)
[13:37:45.574]                     }
[13:37:45.574]                     invisible(pathname)
[13:37:45.574]                   }
[13:37:45.574]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:37:45.574]                     rootPath = tempdir()) 
[13:37:45.574]                   {
[13:37:45.574]                     obj <- list(time = Sys.time(), condition = cond)
[13:37:45.574]                     file <- tempfile(pattern = class(cond)[1], 
[13:37:45.574]                       tmpdir = path, fileext = ".rds")
[13:37:45.574]                     save_rds(obj, file)
[13:37:45.574]                   }
[13:37:45.574]                   saveImmediateCondition(cond, path = "/tmp/RtmpLAMaHJ/.future/immediateConditions")
[13:37:45.574]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.574]                   {
[13:37:45.574]                     inherits <- base::inherits
[13:37:45.574]                     invokeRestart <- base::invokeRestart
[13:37:45.574]                     is.null <- base::is.null
[13:37:45.574]                     muffled <- FALSE
[13:37:45.574]                     if (inherits(cond, "message")) {
[13:37:45.574]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:45.574]                       if (muffled) 
[13:37:45.574]                         invokeRestart("muffleMessage")
[13:37:45.574]                     }
[13:37:45.574]                     else if (inherits(cond, "warning")) {
[13:37:45.574]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:45.574]                       if (muffled) 
[13:37:45.574]                         invokeRestart("muffleWarning")
[13:37:45.574]                     }
[13:37:45.574]                     else if (inherits(cond, "condition")) {
[13:37:45.574]                       if (!is.null(pattern)) {
[13:37:45.574]                         computeRestarts <- base::computeRestarts
[13:37:45.574]                         grepl <- base::grepl
[13:37:45.574]                         restarts <- computeRestarts(cond)
[13:37:45.574]                         for (restart in restarts) {
[13:37:45.574]                           name <- restart$name
[13:37:45.574]                           if (is.null(name)) 
[13:37:45.574]                             next
[13:37:45.574]                           if (!grepl(pattern, name)) 
[13:37:45.574]                             next
[13:37:45.574]                           invokeRestart(restart)
[13:37:45.574]                           muffled <- TRUE
[13:37:45.574]                           break
[13:37:45.574]                         }
[13:37:45.574]                       }
[13:37:45.574]                     }
[13:37:45.574]                     invisible(muffled)
[13:37:45.574]                   }
[13:37:45.574]                   muffleCondition(cond)
[13:37:45.574]                 })
[13:37:45.574]             }))
[13:37:45.574]             future::FutureResult(value = ...future.value$value, 
[13:37:45.574]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.574]                   ...future.rng), globalenv = if (FALSE) 
[13:37:45.574]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:45.574]                     ...future.globalenv.names))
[13:37:45.574]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:45.574]         }, condition = base::local({
[13:37:45.574]             c <- base::c
[13:37:45.574]             inherits <- base::inherits
[13:37:45.574]             invokeRestart <- base::invokeRestart
[13:37:45.574]             length <- base::length
[13:37:45.574]             list <- base::list
[13:37:45.574]             seq.int <- base::seq.int
[13:37:45.574]             signalCondition <- base::signalCondition
[13:37:45.574]             sys.calls <- base::sys.calls
[13:37:45.574]             `[[` <- base::`[[`
[13:37:45.574]             `+` <- base::`+`
[13:37:45.574]             `<<-` <- base::`<<-`
[13:37:45.574]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:45.574]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:45.574]                   3L)]
[13:37:45.574]             }
[13:37:45.574]             function(cond) {
[13:37:45.574]                 is_error <- inherits(cond, "error")
[13:37:45.574]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:45.574]                   NULL)
[13:37:45.574]                 if (is_error) {
[13:37:45.574]                   sessionInformation <- function() {
[13:37:45.574]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:45.574]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:45.574]                       search = base::search(), system = base::Sys.info())
[13:37:45.574]                   }
[13:37:45.574]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.574]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:45.574]                     cond$call), session = sessionInformation(), 
[13:37:45.574]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:45.574]                   signalCondition(cond)
[13:37:45.574]                 }
[13:37:45.574]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:45.574]                 "immediateCondition"))) {
[13:37:45.574]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:45.574]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.574]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:45.574]                   if (TRUE && !signal) {
[13:37:45.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.574]                     {
[13:37:45.574]                       inherits <- base::inherits
[13:37:45.574]                       invokeRestart <- base::invokeRestart
[13:37:45.574]                       is.null <- base::is.null
[13:37:45.574]                       muffled <- FALSE
[13:37:45.574]                       if (inherits(cond, "message")) {
[13:37:45.574]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.574]                         if (muffled) 
[13:37:45.574]                           invokeRestart("muffleMessage")
[13:37:45.574]                       }
[13:37:45.574]                       else if (inherits(cond, "warning")) {
[13:37:45.574]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.574]                         if (muffled) 
[13:37:45.574]                           invokeRestart("muffleWarning")
[13:37:45.574]                       }
[13:37:45.574]                       else if (inherits(cond, "condition")) {
[13:37:45.574]                         if (!is.null(pattern)) {
[13:37:45.574]                           computeRestarts <- base::computeRestarts
[13:37:45.574]                           grepl <- base::grepl
[13:37:45.574]                           restarts <- computeRestarts(cond)
[13:37:45.574]                           for (restart in restarts) {
[13:37:45.574]                             name <- restart$name
[13:37:45.574]                             if (is.null(name)) 
[13:37:45.574]                               next
[13:37:45.574]                             if (!grepl(pattern, name)) 
[13:37:45.574]                               next
[13:37:45.574]                             invokeRestart(restart)
[13:37:45.574]                             muffled <- TRUE
[13:37:45.574]                             break
[13:37:45.574]                           }
[13:37:45.574]                         }
[13:37:45.574]                       }
[13:37:45.574]                       invisible(muffled)
[13:37:45.574]                     }
[13:37:45.574]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.574]                   }
[13:37:45.574]                 }
[13:37:45.574]                 else {
[13:37:45.574]                   if (TRUE) {
[13:37:45.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.574]                     {
[13:37:45.574]                       inherits <- base::inherits
[13:37:45.574]                       invokeRestart <- base::invokeRestart
[13:37:45.574]                       is.null <- base::is.null
[13:37:45.574]                       muffled <- FALSE
[13:37:45.574]                       if (inherits(cond, "message")) {
[13:37:45.574]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.574]                         if (muffled) 
[13:37:45.574]                           invokeRestart("muffleMessage")
[13:37:45.574]                       }
[13:37:45.574]                       else if (inherits(cond, "warning")) {
[13:37:45.574]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.574]                         if (muffled) 
[13:37:45.574]                           invokeRestart("muffleWarning")
[13:37:45.574]                       }
[13:37:45.574]                       else if (inherits(cond, "condition")) {
[13:37:45.574]                         if (!is.null(pattern)) {
[13:37:45.574]                           computeRestarts <- base::computeRestarts
[13:37:45.574]                           grepl <- base::grepl
[13:37:45.574]                           restarts <- computeRestarts(cond)
[13:37:45.574]                           for (restart in restarts) {
[13:37:45.574]                             name <- restart$name
[13:37:45.574]                             if (is.null(name)) 
[13:37:45.574]                               next
[13:37:45.574]                             if (!grepl(pattern, name)) 
[13:37:45.574]                               next
[13:37:45.574]                             invokeRestart(restart)
[13:37:45.574]                             muffled <- TRUE
[13:37:45.574]                             break
[13:37:45.574]                           }
[13:37:45.574]                         }
[13:37:45.574]                       }
[13:37:45.574]                       invisible(muffled)
[13:37:45.574]                     }
[13:37:45.574]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.574]                   }
[13:37:45.574]                 }
[13:37:45.574]             }
[13:37:45.574]         }))
[13:37:45.574]     }, error = function(ex) {
[13:37:45.574]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:45.574]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.574]                 ...future.rng), started = ...future.startTime, 
[13:37:45.574]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:45.574]             version = "1.8"), class = "FutureResult")
[13:37:45.574]     }, finally = {
[13:37:45.574]         if (!identical(...future.workdir, getwd())) 
[13:37:45.574]             setwd(...future.workdir)
[13:37:45.574]         {
[13:37:45.574]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:45.574]                 ...future.oldOptions$nwarnings <- NULL
[13:37:45.574]             }
[13:37:45.574]             base::options(...future.oldOptions)
[13:37:45.574]             if (.Platform$OS.type == "windows") {
[13:37:45.574]                 old_names <- names(...future.oldEnvVars)
[13:37:45.574]                 envs <- base::Sys.getenv()
[13:37:45.574]                 names <- names(envs)
[13:37:45.574]                 common <- intersect(names, old_names)
[13:37:45.574]                 added <- setdiff(names, old_names)
[13:37:45.574]                 removed <- setdiff(old_names, names)
[13:37:45.574]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:45.574]                   envs[common]]
[13:37:45.574]                 NAMES <- toupper(changed)
[13:37:45.574]                 args <- list()
[13:37:45.574]                 for (kk in seq_along(NAMES)) {
[13:37:45.574]                   name <- changed[[kk]]
[13:37:45.574]                   NAME <- NAMES[[kk]]
[13:37:45.574]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.574]                     next
[13:37:45.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.574]                 }
[13:37:45.574]                 NAMES <- toupper(added)
[13:37:45.574]                 for (kk in seq_along(NAMES)) {
[13:37:45.574]                   name <- added[[kk]]
[13:37:45.574]                   NAME <- NAMES[[kk]]
[13:37:45.574]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.574]                     next
[13:37:45.574]                   args[[name]] <- ""
[13:37:45.574]                 }
[13:37:45.574]                 NAMES <- toupper(removed)
[13:37:45.574]                 for (kk in seq_along(NAMES)) {
[13:37:45.574]                   name <- removed[[kk]]
[13:37:45.574]                   NAME <- NAMES[[kk]]
[13:37:45.574]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.574]                     next
[13:37:45.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.574]                 }
[13:37:45.574]                 if (length(args) > 0) 
[13:37:45.574]                   base::do.call(base::Sys.setenv, args = args)
[13:37:45.574]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:45.574]             }
[13:37:45.574]             else {
[13:37:45.574]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:45.574]             }
[13:37:45.574]             {
[13:37:45.574]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:45.574]                   0L) {
[13:37:45.574]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:45.574]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:45.574]                   base::options(opts)
[13:37:45.574]                 }
[13:37:45.574]                 {
[13:37:45.574]                   {
[13:37:45.574]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:45.574]                     NULL
[13:37:45.574]                   }
[13:37:45.574]                   options(future.plan = NULL)
[13:37:45.574]                   if (is.na(NA_character_)) 
[13:37:45.574]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.574]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:45.574]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:45.574]                     .init = FALSE)
[13:37:45.574]                 }
[13:37:45.574]             }
[13:37:45.574]         }
[13:37:45.574]     })
[13:37:45.574]     if (TRUE) {
[13:37:45.574]         base::sink(type = "output", split = FALSE)
[13:37:45.574]         if (TRUE) {
[13:37:45.574]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:45.574]         }
[13:37:45.574]         else {
[13:37:45.574]             ...future.result["stdout"] <- base::list(NULL)
[13:37:45.574]         }
[13:37:45.574]         base::close(...future.stdout)
[13:37:45.574]         ...future.stdout <- NULL
[13:37:45.574]     }
[13:37:45.574]     ...future.result$conditions <- ...future.conditions
[13:37:45.574]     ...future.result$finished <- base::Sys.time()
[13:37:45.574]     ...future.result
[13:37:45.574] }
[13:37:45.578] requestCore(): workers = 2
[13:37:45.581] MulticoreFuture started
[13:37:45.581] - Launch lazy future ... done
[13:37:45.581] run() for ‘MulticoreFuture’ ... done
[13:37:45.582] plan(): Setting new future strategy stack:
[13:37:45.582] List of future strategies:
[13:37:45.582] 1. sequential:
[13:37:45.582]    - args: function (..., envir = parent.frame())
[13:37:45.582]    - tweaked: FALSE
[13:37:45.582]    - call: NULL
[13:37:45.588] plan(): nbrOfWorkers() = 1
[13:37:45.589] resolve() on list environment ...
[13:37:45.589]  recursive: 0
[13:37:45.591] plan(): Setting new future strategy stack:
[13:37:45.591]  length: 3
[13:37:45.591] List of future strategies:
[13:37:45.591] 1. multicore:
[13:37:45.591]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:37:45.591]    - tweaked: FALSE
[13:37:45.591]    - call: plan(strategy)
[13:37:45.592]  elements: ‘a’, ‘b’, ‘c’
[13:37:45.593] Future #1
[13:37:45.593]  length: 2 (resolved future 1)
[13:37:45.597] plan(): nbrOfWorkers() = 2
[13:37:45.598] Future #2
[13:37:45.598]  length: 1 (resolved future 2)
[13:37:45.598]  length: 0 (resolved future 3)
[13:37:45.598] resolve() on list environment ... DONE
[13:37:45.600] getGlobalsAndPackages() ...
[13:37:45.600] Searching for globals...
[13:37:45.601] - globals found: [1] ‘{’
[13:37:45.601] Searching for globals ... DONE
[13:37:45.602] Resolving globals: FALSE
[13:37:45.602] 
[13:37:45.603] 
[13:37:45.603] getGlobalsAndPackages() ... DONE
[13:37:45.603] run() for ‘Future’ ...
[13:37:45.603] - state: ‘created’
[13:37:45.604] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:37:45.608] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:45.608] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:37:45.609]   - Field: ‘label’
[13:37:45.609]   - Field: ‘local’
[13:37:45.609]   - Field: ‘owner’
[13:37:45.609]   - Field: ‘envir’
[13:37:45.609]   - Field: ‘workers’
[13:37:45.609]   - Field: ‘packages’
[13:37:45.610]   - Field: ‘gc’
[13:37:45.610]   - Field: ‘job’
[13:37:45.610]   - Field: ‘conditions’
[13:37:45.610]   - Field: ‘expr’
[13:37:45.610]   - Field: ‘uuid’
[13:37:45.610]   - Field: ‘seed’
[13:37:45.610]   - Field: ‘version’
[13:37:45.611]   - Field: ‘result’
[13:37:45.611]   - Field: ‘asynchronous’
[13:37:45.611]   - Field: ‘calls’
[13:37:45.611]   - Field: ‘globals’
[13:37:45.611]   - Field: ‘stdout’
[13:37:45.611]   - Field: ‘earlySignal’
[13:37:45.611]   - Field: ‘lazy’
[13:37:45.611]   - Field: ‘state’
[13:37:45.612] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:37:45.612] - Launch lazy future ...
[13:37:45.612] Packages needed by the future expression (n = 0): <none>
[13:37:45.612] Packages needed by future strategies (n = 0): <none>
[13:37:45.613] {
[13:37:45.613]     {
[13:37:45.613]         {
[13:37:45.613]             ...future.startTime <- base::Sys.time()
[13:37:45.613]             {
[13:37:45.613]                 {
[13:37:45.613]                   {
[13:37:45.613]                     {
[13:37:45.613]                       base::local({
[13:37:45.613]                         has_future <- base::requireNamespace("future", 
[13:37:45.613]                           quietly = TRUE)
[13:37:45.613]                         if (has_future) {
[13:37:45.613]                           ns <- base::getNamespace("future")
[13:37:45.613]                           version <- ns[[".package"]][["version"]]
[13:37:45.613]                           if (is.null(version)) 
[13:37:45.613]                             version <- utils::packageVersion("future")
[13:37:45.613]                         }
[13:37:45.613]                         else {
[13:37:45.613]                           version <- NULL
[13:37:45.613]                         }
[13:37:45.613]                         if (!has_future || version < "1.8.0") {
[13:37:45.613]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:45.613]                             "", base::R.version$version.string), 
[13:37:45.613]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:45.613]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:45.613]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:45.613]                               "release", "version")], collapse = " "), 
[13:37:45.613]                             hostname = base::Sys.info()[["nodename"]])
[13:37:45.613]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:45.613]                             info)
[13:37:45.613]                           info <- base::paste(info, collapse = "; ")
[13:37:45.613]                           if (!has_future) {
[13:37:45.613]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:45.613]                               info)
[13:37:45.613]                           }
[13:37:45.613]                           else {
[13:37:45.613]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:45.613]                               info, version)
[13:37:45.613]                           }
[13:37:45.613]                           base::stop(msg)
[13:37:45.613]                         }
[13:37:45.613]                       })
[13:37:45.613]                     }
[13:37:45.613]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:45.613]                     base::options(mc.cores = 1L)
[13:37:45.613]                   }
[13:37:45.613]                   ...future.strategy.old <- future::plan("list")
[13:37:45.613]                   options(future.plan = NULL)
[13:37:45.613]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.613]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:45.613]                 }
[13:37:45.613]                 ...future.workdir <- getwd()
[13:37:45.613]             }
[13:37:45.613]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:45.613]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:45.613]         }
[13:37:45.613]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:45.613]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:45.613]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:45.613]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:45.613]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:45.613]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:45.613]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:45.613]             base::names(...future.oldOptions))
[13:37:45.613]     }
[13:37:45.613]     if (FALSE) {
[13:37:45.613]     }
[13:37:45.613]     else {
[13:37:45.613]         if (TRUE) {
[13:37:45.613]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:45.613]                 open = "w")
[13:37:45.613]         }
[13:37:45.613]         else {
[13:37:45.613]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:45.613]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:45.613]         }
[13:37:45.613]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:45.613]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:45.613]             base::sink(type = "output", split = FALSE)
[13:37:45.613]             base::close(...future.stdout)
[13:37:45.613]         }, add = TRUE)
[13:37:45.613]     }
[13:37:45.613]     ...future.frame <- base::sys.nframe()
[13:37:45.613]     ...future.conditions <- base::list()
[13:37:45.613]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:45.613]     if (FALSE) {
[13:37:45.613]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:45.613]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:45.613]     }
[13:37:45.613]     ...future.result <- base::tryCatch({
[13:37:45.613]         base::withCallingHandlers({
[13:37:45.613]             ...future.value <- base::withVisible(base::local({
[13:37:45.613]                 withCallingHandlers({
[13:37:45.613]                   {
[13:37:45.613]                     1
[13:37:45.613]                   }
[13:37:45.613]                 }, immediateCondition = function(cond) {
[13:37:45.613]                   save_rds <- function (object, pathname, ...) 
[13:37:45.613]                   {
[13:37:45.613]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:37:45.613]                     if (file_test("-f", pathname_tmp)) {
[13:37:45.613]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.613]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:37:45.613]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.613]                         fi_tmp[["mtime"]])
[13:37:45.613]                     }
[13:37:45.613]                     tryCatch({
[13:37:45.613]                       saveRDS(object, file = pathname_tmp, ...)
[13:37:45.613]                     }, error = function(ex) {
[13:37:45.613]                       msg <- conditionMessage(ex)
[13:37:45.613]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.613]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:37:45.613]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.613]                         fi_tmp[["mtime"]], msg)
[13:37:45.613]                       ex$message <- msg
[13:37:45.613]                       stop(ex)
[13:37:45.613]                     })
[13:37:45.613]                     stopifnot(file_test("-f", pathname_tmp))
[13:37:45.613]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:37:45.613]                     if (!res || file_test("-f", pathname_tmp)) {
[13:37:45.613]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.613]                       fi <- file.info(pathname)
[13:37:45.613]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:37:45.613]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.613]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:37:45.613]                         fi[["size"]], fi[["mtime"]])
[13:37:45.613]                       stop(msg)
[13:37:45.613]                     }
[13:37:45.613]                     invisible(pathname)
[13:37:45.613]                   }
[13:37:45.613]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:37:45.613]                     rootPath = tempdir()) 
[13:37:45.613]                   {
[13:37:45.613]                     obj <- list(time = Sys.time(), condition = cond)
[13:37:45.613]                     file <- tempfile(pattern = class(cond)[1], 
[13:37:45.613]                       tmpdir = path, fileext = ".rds")
[13:37:45.613]                     save_rds(obj, file)
[13:37:45.613]                   }
[13:37:45.613]                   saveImmediateCondition(cond, path = "/tmp/RtmpLAMaHJ/.future/immediateConditions")
[13:37:45.613]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.613]                   {
[13:37:45.613]                     inherits <- base::inherits
[13:37:45.613]                     invokeRestart <- base::invokeRestart
[13:37:45.613]                     is.null <- base::is.null
[13:37:45.613]                     muffled <- FALSE
[13:37:45.613]                     if (inherits(cond, "message")) {
[13:37:45.613]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:45.613]                       if (muffled) 
[13:37:45.613]                         invokeRestart("muffleMessage")
[13:37:45.613]                     }
[13:37:45.613]                     else if (inherits(cond, "warning")) {
[13:37:45.613]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:45.613]                       if (muffled) 
[13:37:45.613]                         invokeRestart("muffleWarning")
[13:37:45.613]                     }
[13:37:45.613]                     else if (inherits(cond, "condition")) {
[13:37:45.613]                       if (!is.null(pattern)) {
[13:37:45.613]                         computeRestarts <- base::computeRestarts
[13:37:45.613]                         grepl <- base::grepl
[13:37:45.613]                         restarts <- computeRestarts(cond)
[13:37:45.613]                         for (restart in restarts) {
[13:37:45.613]                           name <- restart$name
[13:37:45.613]                           if (is.null(name)) 
[13:37:45.613]                             next
[13:37:45.613]                           if (!grepl(pattern, name)) 
[13:37:45.613]                             next
[13:37:45.613]                           invokeRestart(restart)
[13:37:45.613]                           muffled <- TRUE
[13:37:45.613]                           break
[13:37:45.613]                         }
[13:37:45.613]                       }
[13:37:45.613]                     }
[13:37:45.613]                     invisible(muffled)
[13:37:45.613]                   }
[13:37:45.613]                   muffleCondition(cond)
[13:37:45.613]                 })
[13:37:45.613]             }))
[13:37:45.613]             future::FutureResult(value = ...future.value$value, 
[13:37:45.613]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.613]                   ...future.rng), globalenv = if (FALSE) 
[13:37:45.613]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:45.613]                     ...future.globalenv.names))
[13:37:45.613]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:45.613]         }, condition = base::local({
[13:37:45.613]             c <- base::c
[13:37:45.613]             inherits <- base::inherits
[13:37:45.613]             invokeRestart <- base::invokeRestart
[13:37:45.613]             length <- base::length
[13:37:45.613]             list <- base::list
[13:37:45.613]             seq.int <- base::seq.int
[13:37:45.613]             signalCondition <- base::signalCondition
[13:37:45.613]             sys.calls <- base::sys.calls
[13:37:45.613]             `[[` <- base::`[[`
[13:37:45.613]             `+` <- base::`+`
[13:37:45.613]             `<<-` <- base::`<<-`
[13:37:45.613]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:45.613]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:45.613]                   3L)]
[13:37:45.613]             }
[13:37:45.613]             function(cond) {
[13:37:45.613]                 is_error <- inherits(cond, "error")
[13:37:45.613]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:45.613]                   NULL)
[13:37:45.613]                 if (is_error) {
[13:37:45.613]                   sessionInformation <- function() {
[13:37:45.613]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:45.613]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:45.613]                       search = base::search(), system = base::Sys.info())
[13:37:45.613]                   }
[13:37:45.613]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.613]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:45.613]                     cond$call), session = sessionInformation(), 
[13:37:45.613]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:45.613]                   signalCondition(cond)
[13:37:45.613]                 }
[13:37:45.613]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:45.613]                 "immediateCondition"))) {
[13:37:45.613]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:45.613]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.613]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:45.613]                   if (TRUE && !signal) {
[13:37:45.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.613]                     {
[13:37:45.613]                       inherits <- base::inherits
[13:37:45.613]                       invokeRestart <- base::invokeRestart
[13:37:45.613]                       is.null <- base::is.null
[13:37:45.613]                       muffled <- FALSE
[13:37:45.613]                       if (inherits(cond, "message")) {
[13:37:45.613]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.613]                         if (muffled) 
[13:37:45.613]                           invokeRestart("muffleMessage")
[13:37:45.613]                       }
[13:37:45.613]                       else if (inherits(cond, "warning")) {
[13:37:45.613]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.613]                         if (muffled) 
[13:37:45.613]                           invokeRestart("muffleWarning")
[13:37:45.613]                       }
[13:37:45.613]                       else if (inherits(cond, "condition")) {
[13:37:45.613]                         if (!is.null(pattern)) {
[13:37:45.613]                           computeRestarts <- base::computeRestarts
[13:37:45.613]                           grepl <- base::grepl
[13:37:45.613]                           restarts <- computeRestarts(cond)
[13:37:45.613]                           for (restart in restarts) {
[13:37:45.613]                             name <- restart$name
[13:37:45.613]                             if (is.null(name)) 
[13:37:45.613]                               next
[13:37:45.613]                             if (!grepl(pattern, name)) 
[13:37:45.613]                               next
[13:37:45.613]                             invokeRestart(restart)
[13:37:45.613]                             muffled <- TRUE
[13:37:45.613]                             break
[13:37:45.613]                           }
[13:37:45.613]                         }
[13:37:45.613]                       }
[13:37:45.613]                       invisible(muffled)
[13:37:45.613]                     }
[13:37:45.613]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.613]                   }
[13:37:45.613]                 }
[13:37:45.613]                 else {
[13:37:45.613]                   if (TRUE) {
[13:37:45.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.613]                     {
[13:37:45.613]                       inherits <- base::inherits
[13:37:45.613]                       invokeRestart <- base::invokeRestart
[13:37:45.613]                       is.null <- base::is.null
[13:37:45.613]                       muffled <- FALSE
[13:37:45.613]                       if (inherits(cond, "message")) {
[13:37:45.613]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.613]                         if (muffled) 
[13:37:45.613]                           invokeRestart("muffleMessage")
[13:37:45.613]                       }
[13:37:45.613]                       else if (inherits(cond, "warning")) {
[13:37:45.613]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.613]                         if (muffled) 
[13:37:45.613]                           invokeRestart("muffleWarning")
[13:37:45.613]                       }
[13:37:45.613]                       else if (inherits(cond, "condition")) {
[13:37:45.613]                         if (!is.null(pattern)) {
[13:37:45.613]                           computeRestarts <- base::computeRestarts
[13:37:45.613]                           grepl <- base::grepl
[13:37:45.613]                           restarts <- computeRestarts(cond)
[13:37:45.613]                           for (restart in restarts) {
[13:37:45.613]                             name <- restart$name
[13:37:45.613]                             if (is.null(name)) 
[13:37:45.613]                               next
[13:37:45.613]                             if (!grepl(pattern, name)) 
[13:37:45.613]                               next
[13:37:45.613]                             invokeRestart(restart)
[13:37:45.613]                             muffled <- TRUE
[13:37:45.613]                             break
[13:37:45.613]                           }
[13:37:45.613]                         }
[13:37:45.613]                       }
[13:37:45.613]                       invisible(muffled)
[13:37:45.613]                     }
[13:37:45.613]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.613]                   }
[13:37:45.613]                 }
[13:37:45.613]             }
[13:37:45.613]         }))
[13:37:45.613]     }, error = function(ex) {
[13:37:45.613]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:45.613]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.613]                 ...future.rng), started = ...future.startTime, 
[13:37:45.613]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:45.613]             version = "1.8"), class = "FutureResult")
[13:37:45.613]     }, finally = {
[13:37:45.613]         if (!identical(...future.workdir, getwd())) 
[13:37:45.613]             setwd(...future.workdir)
[13:37:45.613]         {
[13:37:45.613]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:45.613]                 ...future.oldOptions$nwarnings <- NULL
[13:37:45.613]             }
[13:37:45.613]             base::options(...future.oldOptions)
[13:37:45.613]             if (.Platform$OS.type == "windows") {
[13:37:45.613]                 old_names <- names(...future.oldEnvVars)
[13:37:45.613]                 envs <- base::Sys.getenv()
[13:37:45.613]                 names <- names(envs)
[13:37:45.613]                 common <- intersect(names, old_names)
[13:37:45.613]                 added <- setdiff(names, old_names)
[13:37:45.613]                 removed <- setdiff(old_names, names)
[13:37:45.613]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:45.613]                   envs[common]]
[13:37:45.613]                 NAMES <- toupper(changed)
[13:37:45.613]                 args <- list()
[13:37:45.613]                 for (kk in seq_along(NAMES)) {
[13:37:45.613]                   name <- changed[[kk]]
[13:37:45.613]                   NAME <- NAMES[[kk]]
[13:37:45.613]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.613]                     next
[13:37:45.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.613]                 }
[13:37:45.613]                 NAMES <- toupper(added)
[13:37:45.613]                 for (kk in seq_along(NAMES)) {
[13:37:45.613]                   name <- added[[kk]]
[13:37:45.613]                   NAME <- NAMES[[kk]]
[13:37:45.613]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.613]                     next
[13:37:45.613]                   args[[name]] <- ""
[13:37:45.613]                 }
[13:37:45.613]                 NAMES <- toupper(removed)
[13:37:45.613]                 for (kk in seq_along(NAMES)) {
[13:37:45.613]                   name <- removed[[kk]]
[13:37:45.613]                   NAME <- NAMES[[kk]]
[13:37:45.613]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.613]                     next
[13:37:45.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.613]                 }
[13:37:45.613]                 if (length(args) > 0) 
[13:37:45.613]                   base::do.call(base::Sys.setenv, args = args)
[13:37:45.613]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:45.613]             }
[13:37:45.613]             else {
[13:37:45.613]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:45.613]             }
[13:37:45.613]             {
[13:37:45.613]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:45.613]                   0L) {
[13:37:45.613]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:45.613]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:45.613]                   base::options(opts)
[13:37:45.613]                 }
[13:37:45.613]                 {
[13:37:45.613]                   {
[13:37:45.613]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:45.613]                     NULL
[13:37:45.613]                   }
[13:37:45.613]                   options(future.plan = NULL)
[13:37:45.613]                   if (is.na(NA_character_)) 
[13:37:45.613]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.613]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:45.613]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:45.613]                     .init = FALSE)
[13:37:45.613]                 }
[13:37:45.613]             }
[13:37:45.613]         }
[13:37:45.613]     })
[13:37:45.613]     if (TRUE) {
[13:37:45.613]         base::sink(type = "output", split = FALSE)
[13:37:45.613]         if (TRUE) {
[13:37:45.613]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:45.613]         }
[13:37:45.613]         else {
[13:37:45.613]             ...future.result["stdout"] <- base::list(NULL)
[13:37:45.613]         }
[13:37:45.613]         base::close(...future.stdout)
[13:37:45.613]         ...future.stdout <- NULL
[13:37:45.613]     }
[13:37:45.613]     ...future.result$conditions <- ...future.conditions
[13:37:45.613]     ...future.result$finished <- base::Sys.time()
[13:37:45.613]     ...future.result
[13:37:45.613] }
[13:37:45.616] requestCore(): workers = 2
[13:37:45.616] Poll #1 (0): usedCores() = 2, workers = 2
[13:37:45.627] result() for MulticoreFuture ...
[13:37:45.628] result() for MulticoreFuture ...
[13:37:45.628] result() for MulticoreFuture ... done
[13:37:45.628] result() for MulticoreFuture ... done
[13:37:45.628] result() for MulticoreFuture ...
[13:37:45.628] result() for MulticoreFuture ... done
[13:37:45.631] MulticoreFuture started
[13:37:45.631] - Launch lazy future ... done
[13:37:45.632] run() for ‘MulticoreFuture’ ... done
[13:37:45.632] plan(): Setting new future strategy stack:
[13:37:45.633] getGlobalsAndPackages() ...
[13:37:45.633] Searching for globals...
[13:37:45.633] List of future strategies:
[13:37:45.633] 1. sequential:
[13:37:45.633]    - args: function (..., envir = parent.frame())
[13:37:45.633]    - tweaked: FALSE
[13:37:45.633]    - call: NULL
[13:37:45.634] plan(): nbrOfWorkers() = 1
[13:37:45.635] - globals found: [1] ‘{’
[13:37:45.636] Searching for globals ... DONE
[13:37:45.636] Resolving globals: FALSE
[13:37:45.637] 
[13:37:45.637] plan(): Setting new future strategy stack:
[13:37:45.637] 
[13:37:45.637] getGlobalsAndPackages() ... DONE
[13:37:45.637] List of future strategies:
[13:37:45.637] 1. multicore:
[13:37:45.637]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:37:45.637]    - tweaked: FALSE
[13:37:45.637]    - call: plan(strategy)
[13:37:45.638] run() for ‘Future’ ...
[13:37:45.638] - state: ‘created’
[13:37:45.638] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:37:45.643] plan(): nbrOfWorkers() = 2
[13:37:45.644] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:45.644] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:37:45.644]   - Field: ‘label’
[13:37:45.644]   - Field: ‘local’
[13:37:45.644]   - Field: ‘owner’
[13:37:45.645]   - Field: ‘envir’
[13:37:45.645]   - Field: ‘workers’
[13:37:45.645]   - Field: ‘packages’
[13:37:45.645]   - Field: ‘gc’
[13:37:45.645]   - Field: ‘job’
[13:37:45.645]   - Field: ‘conditions’
[13:37:45.645]   - Field: ‘expr’
[13:37:45.646]   - Field: ‘uuid’
[13:37:45.646]   - Field: ‘seed’
[13:37:45.646]   - Field: ‘version’
[13:37:45.646]   - Field: ‘result’
[13:37:45.646]   - Field: ‘asynchronous’
[13:37:45.646]   - Field: ‘calls’
[13:37:45.646]   - Field: ‘globals’
[13:37:45.647]   - Field: ‘stdout’
[13:37:45.647]   - Field: ‘earlySignal’
[13:37:45.647]   - Field: ‘lazy’
[13:37:45.647]   - Field: ‘state’
[13:37:45.647] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:37:45.647] - Launch lazy future ...
[13:37:45.648] Packages needed by the future expression (n = 0): <none>
[13:37:45.648] Packages needed by future strategies (n = 0): <none>
[13:37:45.649] {
[13:37:45.649]     {
[13:37:45.649]         {
[13:37:45.649]             ...future.startTime <- base::Sys.time()
[13:37:45.649]             {
[13:37:45.649]                 {
[13:37:45.649]                   {
[13:37:45.649]                     {
[13:37:45.649]                       base::local({
[13:37:45.649]                         has_future <- base::requireNamespace("future", 
[13:37:45.649]                           quietly = TRUE)
[13:37:45.649]                         if (has_future) {
[13:37:45.649]                           ns <- base::getNamespace("future")
[13:37:45.649]                           version <- ns[[".package"]][["version"]]
[13:37:45.649]                           if (is.null(version)) 
[13:37:45.649]                             version <- utils::packageVersion("future")
[13:37:45.649]                         }
[13:37:45.649]                         else {
[13:37:45.649]                           version <- NULL
[13:37:45.649]                         }
[13:37:45.649]                         if (!has_future || version < "1.8.0") {
[13:37:45.649]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:45.649]                             "", base::R.version$version.string), 
[13:37:45.649]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:45.649]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:45.649]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:45.649]                               "release", "version")], collapse = " "), 
[13:37:45.649]                             hostname = base::Sys.info()[["nodename"]])
[13:37:45.649]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:45.649]                             info)
[13:37:45.649]                           info <- base::paste(info, collapse = "; ")
[13:37:45.649]                           if (!has_future) {
[13:37:45.649]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:45.649]                               info)
[13:37:45.649]                           }
[13:37:45.649]                           else {
[13:37:45.649]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:45.649]                               info, version)
[13:37:45.649]                           }
[13:37:45.649]                           base::stop(msg)
[13:37:45.649]                         }
[13:37:45.649]                       })
[13:37:45.649]                     }
[13:37:45.649]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:45.649]                     base::options(mc.cores = 1L)
[13:37:45.649]                   }
[13:37:45.649]                   ...future.strategy.old <- future::plan("list")
[13:37:45.649]                   options(future.plan = NULL)
[13:37:45.649]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.649]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:45.649]                 }
[13:37:45.649]                 ...future.workdir <- getwd()
[13:37:45.649]             }
[13:37:45.649]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:45.649]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:45.649]         }
[13:37:45.649]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:45.649]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:45.649]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:45.649]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:45.649]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:45.649]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:45.649]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:45.649]             base::names(...future.oldOptions))
[13:37:45.649]     }
[13:37:45.649]     if (FALSE) {
[13:37:45.649]     }
[13:37:45.649]     else {
[13:37:45.649]         if (TRUE) {
[13:37:45.649]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:45.649]                 open = "w")
[13:37:45.649]         }
[13:37:45.649]         else {
[13:37:45.649]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:45.649]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:45.649]         }
[13:37:45.649]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:45.649]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:45.649]             base::sink(type = "output", split = FALSE)
[13:37:45.649]             base::close(...future.stdout)
[13:37:45.649]         }, add = TRUE)
[13:37:45.649]     }
[13:37:45.649]     ...future.frame <- base::sys.nframe()
[13:37:45.649]     ...future.conditions <- base::list()
[13:37:45.649]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:45.649]     if (FALSE) {
[13:37:45.649]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:45.649]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:45.649]     }
[13:37:45.649]     ...future.result <- base::tryCatch({
[13:37:45.649]         base::withCallingHandlers({
[13:37:45.649]             ...future.value <- base::withVisible(base::local({
[13:37:45.649]                 withCallingHandlers({
[13:37:45.649]                   {
[13:37:45.649]                     2
[13:37:45.649]                   }
[13:37:45.649]                 }, immediateCondition = function(cond) {
[13:37:45.649]                   save_rds <- function (object, pathname, ...) 
[13:37:45.649]                   {
[13:37:45.649]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:37:45.649]                     if (file_test("-f", pathname_tmp)) {
[13:37:45.649]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.649]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:37:45.649]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.649]                         fi_tmp[["mtime"]])
[13:37:45.649]                     }
[13:37:45.649]                     tryCatch({
[13:37:45.649]                       saveRDS(object, file = pathname_tmp, ...)
[13:37:45.649]                     }, error = function(ex) {
[13:37:45.649]                       msg <- conditionMessage(ex)
[13:37:45.649]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.649]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:37:45.649]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.649]                         fi_tmp[["mtime"]], msg)
[13:37:45.649]                       ex$message <- msg
[13:37:45.649]                       stop(ex)
[13:37:45.649]                     })
[13:37:45.649]                     stopifnot(file_test("-f", pathname_tmp))
[13:37:45.649]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:37:45.649]                     if (!res || file_test("-f", pathname_tmp)) {
[13:37:45.649]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.649]                       fi <- file.info(pathname)
[13:37:45.649]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:37:45.649]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.649]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:37:45.649]                         fi[["size"]], fi[["mtime"]])
[13:37:45.649]                       stop(msg)
[13:37:45.649]                     }
[13:37:45.649]                     invisible(pathname)
[13:37:45.649]                   }
[13:37:45.649]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:37:45.649]                     rootPath = tempdir()) 
[13:37:45.649]                   {
[13:37:45.649]                     obj <- list(time = Sys.time(), condition = cond)
[13:37:45.649]                     file <- tempfile(pattern = class(cond)[1], 
[13:37:45.649]                       tmpdir = path, fileext = ".rds")
[13:37:45.649]                     save_rds(obj, file)
[13:37:45.649]                   }
[13:37:45.649]                   saveImmediateCondition(cond, path = "/tmp/RtmpLAMaHJ/.future/immediateConditions")
[13:37:45.649]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.649]                   {
[13:37:45.649]                     inherits <- base::inherits
[13:37:45.649]                     invokeRestart <- base::invokeRestart
[13:37:45.649]                     is.null <- base::is.null
[13:37:45.649]                     muffled <- FALSE
[13:37:45.649]                     if (inherits(cond, "message")) {
[13:37:45.649]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:45.649]                       if (muffled) 
[13:37:45.649]                         invokeRestart("muffleMessage")
[13:37:45.649]                     }
[13:37:45.649]                     else if (inherits(cond, "warning")) {
[13:37:45.649]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:45.649]                       if (muffled) 
[13:37:45.649]                         invokeRestart("muffleWarning")
[13:37:45.649]                     }
[13:37:45.649]                     else if (inherits(cond, "condition")) {
[13:37:45.649]                       if (!is.null(pattern)) {
[13:37:45.649]                         computeRestarts <- base::computeRestarts
[13:37:45.649]                         grepl <- base::grepl
[13:37:45.649]                         restarts <- computeRestarts(cond)
[13:37:45.649]                         for (restart in restarts) {
[13:37:45.649]                           name <- restart$name
[13:37:45.649]                           if (is.null(name)) 
[13:37:45.649]                             next
[13:37:45.649]                           if (!grepl(pattern, name)) 
[13:37:45.649]                             next
[13:37:45.649]                           invokeRestart(restart)
[13:37:45.649]                           muffled <- TRUE
[13:37:45.649]                           break
[13:37:45.649]                         }
[13:37:45.649]                       }
[13:37:45.649]                     }
[13:37:45.649]                     invisible(muffled)
[13:37:45.649]                   }
[13:37:45.649]                   muffleCondition(cond)
[13:37:45.649]                 })
[13:37:45.649]             }))
[13:37:45.649]             future::FutureResult(value = ...future.value$value, 
[13:37:45.649]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.649]                   ...future.rng), globalenv = if (FALSE) 
[13:37:45.649]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:45.649]                     ...future.globalenv.names))
[13:37:45.649]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:45.649]         }, condition = base::local({
[13:37:45.649]             c <- base::c
[13:37:45.649]             inherits <- base::inherits
[13:37:45.649]             invokeRestart <- base::invokeRestart
[13:37:45.649]             length <- base::length
[13:37:45.649]             list <- base::list
[13:37:45.649]             seq.int <- base::seq.int
[13:37:45.649]             signalCondition <- base::signalCondition
[13:37:45.649]             sys.calls <- base::sys.calls
[13:37:45.649]             `[[` <- base::`[[`
[13:37:45.649]             `+` <- base::`+`
[13:37:45.649]             `<<-` <- base::`<<-`
[13:37:45.649]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:45.649]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:45.649]                   3L)]
[13:37:45.649]             }
[13:37:45.649]             function(cond) {
[13:37:45.649]                 is_error <- inherits(cond, "error")
[13:37:45.649]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:45.649]                   NULL)
[13:37:45.649]                 if (is_error) {
[13:37:45.649]                   sessionInformation <- function() {
[13:37:45.649]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:45.649]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:45.649]                       search = base::search(), system = base::Sys.info())
[13:37:45.649]                   }
[13:37:45.649]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.649]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:45.649]                     cond$call), session = sessionInformation(), 
[13:37:45.649]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:45.649]                   signalCondition(cond)
[13:37:45.649]                 }
[13:37:45.649]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:45.649]                 "immediateCondition"))) {
[13:37:45.649]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:45.649]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.649]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:45.649]                   if (TRUE && !signal) {
[13:37:45.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.649]                     {
[13:37:45.649]                       inherits <- base::inherits
[13:37:45.649]                       invokeRestart <- base::invokeRestart
[13:37:45.649]                       is.null <- base::is.null
[13:37:45.649]                       muffled <- FALSE
[13:37:45.649]                       if (inherits(cond, "message")) {
[13:37:45.649]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.649]                         if (muffled) 
[13:37:45.649]                           invokeRestart("muffleMessage")
[13:37:45.649]                       }
[13:37:45.649]                       else if (inherits(cond, "warning")) {
[13:37:45.649]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.649]                         if (muffled) 
[13:37:45.649]                           invokeRestart("muffleWarning")
[13:37:45.649]                       }
[13:37:45.649]                       else if (inherits(cond, "condition")) {
[13:37:45.649]                         if (!is.null(pattern)) {
[13:37:45.649]                           computeRestarts <- base::computeRestarts
[13:37:45.649]                           grepl <- base::grepl
[13:37:45.649]                           restarts <- computeRestarts(cond)
[13:37:45.649]                           for (restart in restarts) {
[13:37:45.649]                             name <- restart$name
[13:37:45.649]                             if (is.null(name)) 
[13:37:45.649]                               next
[13:37:45.649]                             if (!grepl(pattern, name)) 
[13:37:45.649]                               next
[13:37:45.649]                             invokeRestart(restart)
[13:37:45.649]                             muffled <- TRUE
[13:37:45.649]                             break
[13:37:45.649]                           }
[13:37:45.649]                         }
[13:37:45.649]                       }
[13:37:45.649]                       invisible(muffled)
[13:37:45.649]                     }
[13:37:45.649]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.649]                   }
[13:37:45.649]                 }
[13:37:45.649]                 else {
[13:37:45.649]                   if (TRUE) {
[13:37:45.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.649]                     {
[13:37:45.649]                       inherits <- base::inherits
[13:37:45.649]                       invokeRestart <- base::invokeRestart
[13:37:45.649]                       is.null <- base::is.null
[13:37:45.649]                       muffled <- FALSE
[13:37:45.649]                       if (inherits(cond, "message")) {
[13:37:45.649]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.649]                         if (muffled) 
[13:37:45.649]                           invokeRestart("muffleMessage")
[13:37:45.649]                       }
[13:37:45.649]                       else if (inherits(cond, "warning")) {
[13:37:45.649]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.649]                         if (muffled) 
[13:37:45.649]                           invokeRestart("muffleWarning")
[13:37:45.649]                       }
[13:37:45.649]                       else if (inherits(cond, "condition")) {
[13:37:45.649]                         if (!is.null(pattern)) {
[13:37:45.649]                           computeRestarts <- base::computeRestarts
[13:37:45.649]                           grepl <- base::grepl
[13:37:45.649]                           restarts <- computeRestarts(cond)
[13:37:45.649]                           for (restart in restarts) {
[13:37:45.649]                             name <- restart$name
[13:37:45.649]                             if (is.null(name)) 
[13:37:45.649]                               next
[13:37:45.649]                             if (!grepl(pattern, name)) 
[13:37:45.649]                               next
[13:37:45.649]                             invokeRestart(restart)
[13:37:45.649]                             muffled <- TRUE
[13:37:45.649]                             break
[13:37:45.649]                           }
[13:37:45.649]                         }
[13:37:45.649]                       }
[13:37:45.649]                       invisible(muffled)
[13:37:45.649]                     }
[13:37:45.649]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.649]                   }
[13:37:45.649]                 }
[13:37:45.649]             }
[13:37:45.649]         }))
[13:37:45.649]     }, error = function(ex) {
[13:37:45.649]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:45.649]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.649]                 ...future.rng), started = ...future.startTime, 
[13:37:45.649]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:45.649]             version = "1.8"), class = "FutureResult")
[13:37:45.649]     }, finally = {
[13:37:45.649]         if (!identical(...future.workdir, getwd())) 
[13:37:45.649]             setwd(...future.workdir)
[13:37:45.649]         {
[13:37:45.649]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:45.649]                 ...future.oldOptions$nwarnings <- NULL
[13:37:45.649]             }
[13:37:45.649]             base::options(...future.oldOptions)
[13:37:45.649]             if (.Platform$OS.type == "windows") {
[13:37:45.649]                 old_names <- names(...future.oldEnvVars)
[13:37:45.649]                 envs <- base::Sys.getenv()
[13:37:45.649]                 names <- names(envs)
[13:37:45.649]                 common <- intersect(names, old_names)
[13:37:45.649]                 added <- setdiff(names, old_names)
[13:37:45.649]                 removed <- setdiff(old_names, names)
[13:37:45.649]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:45.649]                   envs[common]]
[13:37:45.649]                 NAMES <- toupper(changed)
[13:37:45.649]                 args <- list()
[13:37:45.649]                 for (kk in seq_along(NAMES)) {
[13:37:45.649]                   name <- changed[[kk]]
[13:37:45.649]                   NAME <- NAMES[[kk]]
[13:37:45.649]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.649]                     next
[13:37:45.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.649]                 }
[13:37:45.649]                 NAMES <- toupper(added)
[13:37:45.649]                 for (kk in seq_along(NAMES)) {
[13:37:45.649]                   name <- added[[kk]]
[13:37:45.649]                   NAME <- NAMES[[kk]]
[13:37:45.649]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.649]                     next
[13:37:45.649]                   args[[name]] <- ""
[13:37:45.649]                 }
[13:37:45.649]                 NAMES <- toupper(removed)
[13:37:45.649]                 for (kk in seq_along(NAMES)) {
[13:37:45.649]                   name <- removed[[kk]]
[13:37:45.649]                   NAME <- NAMES[[kk]]
[13:37:45.649]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.649]                     next
[13:37:45.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.649]                 }
[13:37:45.649]                 if (length(args) > 0) 
[13:37:45.649]                   base::do.call(base::Sys.setenv, args = args)
[13:37:45.649]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:45.649]             }
[13:37:45.649]             else {
[13:37:45.649]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:45.649]             }
[13:37:45.649]             {
[13:37:45.649]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:45.649]                   0L) {
[13:37:45.649]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:45.649]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:45.649]                   base::options(opts)
[13:37:45.649]                 }
[13:37:45.649]                 {
[13:37:45.649]                   {
[13:37:45.649]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:45.649]                     NULL
[13:37:45.649]                   }
[13:37:45.649]                   options(future.plan = NULL)
[13:37:45.649]                   if (is.na(NA_character_)) 
[13:37:45.649]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.649]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:45.649]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:45.649]                     .init = FALSE)
[13:37:45.649]                 }
[13:37:45.649]             }
[13:37:45.649]         }
[13:37:45.649]     })
[13:37:45.649]     if (TRUE) {
[13:37:45.649]         base::sink(type = "output", split = FALSE)
[13:37:45.649]         if (TRUE) {
[13:37:45.649]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:45.649]         }
[13:37:45.649]         else {
[13:37:45.649]             ...future.result["stdout"] <- base::list(NULL)
[13:37:45.649]         }
[13:37:45.649]         base::close(...future.stdout)
[13:37:45.649]         ...future.stdout <- NULL
[13:37:45.649]     }
[13:37:45.649]     ...future.result$conditions <- ...future.conditions
[13:37:45.649]     ...future.result$finished <- base::Sys.time()
[13:37:45.649]     ...future.result
[13:37:45.649] }
[13:37:45.652] requestCore(): workers = 2
[13:37:45.653] Poll #1 (0): usedCores() = 2, workers = 2
[13:37:45.664] result() for MulticoreFuture ...
[13:37:45.665] result() for MulticoreFuture ...
[13:37:45.665] result() for MulticoreFuture ... done
[13:37:45.665] result() for MulticoreFuture ... done
[13:37:45.665] result() for MulticoreFuture ...
[13:37:45.665] result() for MulticoreFuture ... done
[13:37:45.668] MulticoreFuture started
[13:37:45.668] - Launch lazy future ... done
[13:37:45.669] run() for ‘MulticoreFuture’ ... done
[13:37:45.669] plan(): Setting new future strategy stack:
[13:37:45.671] resolve() on list environment ...
[13:37:45.670] List of future strategies:
[13:37:45.670] 1. sequential:
[13:37:45.670]    - args: function (..., envir = parent.frame())
[13:37:45.670]    - tweaked: FALSE
[13:37:45.670]    - call: NULL
[13:37:45.671]  recursive: 0
[13:37:45.671] plan(): nbrOfWorkers() = 1
[13:37:45.672]  length: 3
[13:37:45.672]  elements: ‘a’, ‘b’, ‘c’
[13:37:45.673] Future #1
[13:37:45.674]  length: 2 (resolved future 1)
[13:37:45.674] plan(): Setting new future strategy stack:
[13:37:45.674] List of future strategies:
[13:37:45.674] 1. multicore:
[13:37:45.674]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:37:45.674]    - tweaked: FALSE
[13:37:45.674]    - call: plan(strategy)
[13:37:45.684]  length: 1 (resolved future 3)
[13:37:45.686] plan(): nbrOfWorkers() = 2
[13:37:45.695] Future #2
[13:37:45.699]  length: 0 (resolved future 2)
[13:37:45.700] resolve() on list environment ... DONE
[13:37:45.702] getGlobalsAndPackages() ...
[13:37:45.702] Searching for globals...
[13:37:45.705] - globals found: [1] ‘{’
[13:37:45.705] Searching for globals ... DONE
[13:37:45.705] Resolving globals: FALSE
[13:37:45.706] 
[13:37:45.706] 
[13:37:45.706] getGlobalsAndPackages() ... DONE
[13:37:45.707] run() for ‘Future’ ...
[13:37:45.707] - state: ‘created’
[13:37:45.707] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:37:45.712] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:45.713] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:37:45.713]   - Field: ‘label’
[13:37:45.713]   - Field: ‘local’
[13:37:45.714]   - Field: ‘owner’
[13:37:45.714]   - Field: ‘envir’
[13:37:45.714]   - Field: ‘workers’
[13:37:45.714]   - Field: ‘packages’
[13:37:45.714]   - Field: ‘gc’
[13:37:45.715]   - Field: ‘job’
[13:37:45.715]   - Field: ‘conditions’
[13:37:45.715]   - Field: ‘expr’
[13:37:45.715]   - Field: ‘uuid’
[13:37:45.715]   - Field: ‘seed’
[13:37:45.715]   - Field: ‘version’
[13:37:45.715]   - Field: ‘result’
[13:37:45.716]   - Field: ‘asynchronous’
[13:37:45.716]   - Field: ‘calls’
[13:37:45.716]   - Field: ‘globals’
[13:37:45.716]   - Field: ‘stdout’
[13:37:45.716]   - Field: ‘earlySignal’
[13:37:45.716]   - Field: ‘lazy’
[13:37:45.716]   - Field: ‘state’
[13:37:45.717] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:37:45.717] - Launch lazy future ...
[13:37:45.717] Packages needed by the future expression (n = 0): <none>
[13:37:45.717] Packages needed by future strategies (n = 0): <none>
[13:37:45.718] {
[13:37:45.718]     {
[13:37:45.718]         {
[13:37:45.718]             ...future.startTime <- base::Sys.time()
[13:37:45.718]             {
[13:37:45.718]                 {
[13:37:45.718]                   {
[13:37:45.718]                     {
[13:37:45.718]                       base::local({
[13:37:45.718]                         has_future <- base::requireNamespace("future", 
[13:37:45.718]                           quietly = TRUE)
[13:37:45.718]                         if (has_future) {
[13:37:45.718]                           ns <- base::getNamespace("future")
[13:37:45.718]                           version <- ns[[".package"]][["version"]]
[13:37:45.718]                           if (is.null(version)) 
[13:37:45.718]                             version <- utils::packageVersion("future")
[13:37:45.718]                         }
[13:37:45.718]                         else {
[13:37:45.718]                           version <- NULL
[13:37:45.718]                         }
[13:37:45.718]                         if (!has_future || version < "1.8.0") {
[13:37:45.718]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:45.718]                             "", base::R.version$version.string), 
[13:37:45.718]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:45.718]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:45.718]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:45.718]                               "release", "version")], collapse = " "), 
[13:37:45.718]                             hostname = base::Sys.info()[["nodename"]])
[13:37:45.718]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:45.718]                             info)
[13:37:45.718]                           info <- base::paste(info, collapse = "; ")
[13:37:45.718]                           if (!has_future) {
[13:37:45.718]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:45.718]                               info)
[13:37:45.718]                           }
[13:37:45.718]                           else {
[13:37:45.718]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:45.718]                               info, version)
[13:37:45.718]                           }
[13:37:45.718]                           base::stop(msg)
[13:37:45.718]                         }
[13:37:45.718]                       })
[13:37:45.718]                     }
[13:37:45.718]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:45.718]                     base::options(mc.cores = 1L)
[13:37:45.718]                   }
[13:37:45.718]                   ...future.strategy.old <- future::plan("list")
[13:37:45.718]                   options(future.plan = NULL)
[13:37:45.718]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.718]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:45.718]                 }
[13:37:45.718]                 ...future.workdir <- getwd()
[13:37:45.718]             }
[13:37:45.718]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:45.718]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:45.718]         }
[13:37:45.718]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:45.718]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:45.718]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:45.718]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:45.718]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:45.718]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:45.718]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:45.718]             base::names(...future.oldOptions))
[13:37:45.718]     }
[13:37:45.718]     if (FALSE) {
[13:37:45.718]     }
[13:37:45.718]     else {
[13:37:45.718]         if (TRUE) {
[13:37:45.718]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:45.718]                 open = "w")
[13:37:45.718]         }
[13:37:45.718]         else {
[13:37:45.718]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:45.718]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:45.718]         }
[13:37:45.718]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:45.718]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:45.718]             base::sink(type = "output", split = FALSE)
[13:37:45.718]             base::close(...future.stdout)
[13:37:45.718]         }, add = TRUE)
[13:37:45.718]     }
[13:37:45.718]     ...future.frame <- base::sys.nframe()
[13:37:45.718]     ...future.conditions <- base::list()
[13:37:45.718]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:45.718]     if (FALSE) {
[13:37:45.718]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:45.718]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:45.718]     }
[13:37:45.718]     ...future.result <- base::tryCatch({
[13:37:45.718]         base::withCallingHandlers({
[13:37:45.718]             ...future.value <- base::withVisible(base::local({
[13:37:45.718]                 withCallingHandlers({
[13:37:45.718]                   {
[13:37:45.718]                     1
[13:37:45.718]                   }
[13:37:45.718]                 }, immediateCondition = function(cond) {
[13:37:45.718]                   save_rds <- function (object, pathname, ...) 
[13:37:45.718]                   {
[13:37:45.718]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:37:45.718]                     if (file_test("-f", pathname_tmp)) {
[13:37:45.718]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.718]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:37:45.718]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.718]                         fi_tmp[["mtime"]])
[13:37:45.718]                     }
[13:37:45.718]                     tryCatch({
[13:37:45.718]                       saveRDS(object, file = pathname_tmp, ...)
[13:37:45.718]                     }, error = function(ex) {
[13:37:45.718]                       msg <- conditionMessage(ex)
[13:37:45.718]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.718]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:37:45.718]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.718]                         fi_tmp[["mtime"]], msg)
[13:37:45.718]                       ex$message <- msg
[13:37:45.718]                       stop(ex)
[13:37:45.718]                     })
[13:37:45.718]                     stopifnot(file_test("-f", pathname_tmp))
[13:37:45.718]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:37:45.718]                     if (!res || file_test("-f", pathname_tmp)) {
[13:37:45.718]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.718]                       fi <- file.info(pathname)
[13:37:45.718]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:37:45.718]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.718]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:37:45.718]                         fi[["size"]], fi[["mtime"]])
[13:37:45.718]                       stop(msg)
[13:37:45.718]                     }
[13:37:45.718]                     invisible(pathname)
[13:37:45.718]                   }
[13:37:45.718]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:37:45.718]                     rootPath = tempdir()) 
[13:37:45.718]                   {
[13:37:45.718]                     obj <- list(time = Sys.time(), condition = cond)
[13:37:45.718]                     file <- tempfile(pattern = class(cond)[1], 
[13:37:45.718]                       tmpdir = path, fileext = ".rds")
[13:37:45.718]                     save_rds(obj, file)
[13:37:45.718]                   }
[13:37:45.718]                   saveImmediateCondition(cond, path = "/tmp/RtmpLAMaHJ/.future/immediateConditions")
[13:37:45.718]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.718]                   {
[13:37:45.718]                     inherits <- base::inherits
[13:37:45.718]                     invokeRestart <- base::invokeRestart
[13:37:45.718]                     is.null <- base::is.null
[13:37:45.718]                     muffled <- FALSE
[13:37:45.718]                     if (inherits(cond, "message")) {
[13:37:45.718]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:45.718]                       if (muffled) 
[13:37:45.718]                         invokeRestart("muffleMessage")
[13:37:45.718]                     }
[13:37:45.718]                     else if (inherits(cond, "warning")) {
[13:37:45.718]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:45.718]                       if (muffled) 
[13:37:45.718]                         invokeRestart("muffleWarning")
[13:37:45.718]                     }
[13:37:45.718]                     else if (inherits(cond, "condition")) {
[13:37:45.718]                       if (!is.null(pattern)) {
[13:37:45.718]                         computeRestarts <- base::computeRestarts
[13:37:45.718]                         grepl <- base::grepl
[13:37:45.718]                         restarts <- computeRestarts(cond)
[13:37:45.718]                         for (restart in restarts) {
[13:37:45.718]                           name <- restart$name
[13:37:45.718]                           if (is.null(name)) 
[13:37:45.718]                             next
[13:37:45.718]                           if (!grepl(pattern, name)) 
[13:37:45.718]                             next
[13:37:45.718]                           invokeRestart(restart)
[13:37:45.718]                           muffled <- TRUE
[13:37:45.718]                           break
[13:37:45.718]                         }
[13:37:45.718]                       }
[13:37:45.718]                     }
[13:37:45.718]                     invisible(muffled)
[13:37:45.718]                   }
[13:37:45.718]                   muffleCondition(cond)
[13:37:45.718]                 })
[13:37:45.718]             }))
[13:37:45.718]             future::FutureResult(value = ...future.value$value, 
[13:37:45.718]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.718]                   ...future.rng), globalenv = if (FALSE) 
[13:37:45.718]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:45.718]                     ...future.globalenv.names))
[13:37:45.718]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:45.718]         }, condition = base::local({
[13:37:45.718]             c <- base::c
[13:37:45.718]             inherits <- base::inherits
[13:37:45.718]             invokeRestart <- base::invokeRestart
[13:37:45.718]             length <- base::length
[13:37:45.718]             list <- base::list
[13:37:45.718]             seq.int <- base::seq.int
[13:37:45.718]             signalCondition <- base::signalCondition
[13:37:45.718]             sys.calls <- base::sys.calls
[13:37:45.718]             `[[` <- base::`[[`
[13:37:45.718]             `+` <- base::`+`
[13:37:45.718]             `<<-` <- base::`<<-`
[13:37:45.718]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:45.718]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:45.718]                   3L)]
[13:37:45.718]             }
[13:37:45.718]             function(cond) {
[13:37:45.718]                 is_error <- inherits(cond, "error")
[13:37:45.718]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:45.718]                   NULL)
[13:37:45.718]                 if (is_error) {
[13:37:45.718]                   sessionInformation <- function() {
[13:37:45.718]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:45.718]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:45.718]                       search = base::search(), system = base::Sys.info())
[13:37:45.718]                   }
[13:37:45.718]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.718]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:45.718]                     cond$call), session = sessionInformation(), 
[13:37:45.718]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:45.718]                   signalCondition(cond)
[13:37:45.718]                 }
[13:37:45.718]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:45.718]                 "immediateCondition"))) {
[13:37:45.718]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:45.718]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.718]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:45.718]                   if (TRUE && !signal) {
[13:37:45.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.718]                     {
[13:37:45.718]                       inherits <- base::inherits
[13:37:45.718]                       invokeRestart <- base::invokeRestart
[13:37:45.718]                       is.null <- base::is.null
[13:37:45.718]                       muffled <- FALSE
[13:37:45.718]                       if (inherits(cond, "message")) {
[13:37:45.718]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.718]                         if (muffled) 
[13:37:45.718]                           invokeRestart("muffleMessage")
[13:37:45.718]                       }
[13:37:45.718]                       else if (inherits(cond, "warning")) {
[13:37:45.718]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.718]                         if (muffled) 
[13:37:45.718]                           invokeRestart("muffleWarning")
[13:37:45.718]                       }
[13:37:45.718]                       else if (inherits(cond, "condition")) {
[13:37:45.718]                         if (!is.null(pattern)) {
[13:37:45.718]                           computeRestarts <- base::computeRestarts
[13:37:45.718]                           grepl <- base::grepl
[13:37:45.718]                           restarts <- computeRestarts(cond)
[13:37:45.718]                           for (restart in restarts) {
[13:37:45.718]                             name <- restart$name
[13:37:45.718]                             if (is.null(name)) 
[13:37:45.718]                               next
[13:37:45.718]                             if (!grepl(pattern, name)) 
[13:37:45.718]                               next
[13:37:45.718]                             invokeRestart(restart)
[13:37:45.718]                             muffled <- TRUE
[13:37:45.718]                             break
[13:37:45.718]                           }
[13:37:45.718]                         }
[13:37:45.718]                       }
[13:37:45.718]                       invisible(muffled)
[13:37:45.718]                     }
[13:37:45.718]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.718]                   }
[13:37:45.718]                 }
[13:37:45.718]                 else {
[13:37:45.718]                   if (TRUE) {
[13:37:45.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.718]                     {
[13:37:45.718]                       inherits <- base::inherits
[13:37:45.718]                       invokeRestart <- base::invokeRestart
[13:37:45.718]                       is.null <- base::is.null
[13:37:45.718]                       muffled <- FALSE
[13:37:45.718]                       if (inherits(cond, "message")) {
[13:37:45.718]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.718]                         if (muffled) 
[13:37:45.718]                           invokeRestart("muffleMessage")
[13:37:45.718]                       }
[13:37:45.718]                       else if (inherits(cond, "warning")) {
[13:37:45.718]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.718]                         if (muffled) 
[13:37:45.718]                           invokeRestart("muffleWarning")
[13:37:45.718]                       }
[13:37:45.718]                       else if (inherits(cond, "condition")) {
[13:37:45.718]                         if (!is.null(pattern)) {
[13:37:45.718]                           computeRestarts <- base::computeRestarts
[13:37:45.718]                           grepl <- base::grepl
[13:37:45.718]                           restarts <- computeRestarts(cond)
[13:37:45.718]                           for (restart in restarts) {
[13:37:45.718]                             name <- restart$name
[13:37:45.718]                             if (is.null(name)) 
[13:37:45.718]                               next
[13:37:45.718]                             if (!grepl(pattern, name)) 
[13:37:45.718]                               next
[13:37:45.718]                             invokeRestart(restart)
[13:37:45.718]                             muffled <- TRUE
[13:37:45.718]                             break
[13:37:45.718]                           }
[13:37:45.718]                         }
[13:37:45.718]                       }
[13:37:45.718]                       invisible(muffled)
[13:37:45.718]                     }
[13:37:45.718]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.718]                   }
[13:37:45.718]                 }
[13:37:45.718]             }
[13:37:45.718]         }))
[13:37:45.718]     }, error = function(ex) {
[13:37:45.718]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:45.718]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.718]                 ...future.rng), started = ...future.startTime, 
[13:37:45.718]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:45.718]             version = "1.8"), class = "FutureResult")
[13:37:45.718]     }, finally = {
[13:37:45.718]         if (!identical(...future.workdir, getwd())) 
[13:37:45.718]             setwd(...future.workdir)
[13:37:45.718]         {
[13:37:45.718]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:45.718]                 ...future.oldOptions$nwarnings <- NULL
[13:37:45.718]             }
[13:37:45.718]             base::options(...future.oldOptions)
[13:37:45.718]             if (.Platform$OS.type == "windows") {
[13:37:45.718]                 old_names <- names(...future.oldEnvVars)
[13:37:45.718]                 envs <- base::Sys.getenv()
[13:37:45.718]                 names <- names(envs)
[13:37:45.718]                 common <- intersect(names, old_names)
[13:37:45.718]                 added <- setdiff(names, old_names)
[13:37:45.718]                 removed <- setdiff(old_names, names)
[13:37:45.718]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:45.718]                   envs[common]]
[13:37:45.718]                 NAMES <- toupper(changed)
[13:37:45.718]                 args <- list()
[13:37:45.718]                 for (kk in seq_along(NAMES)) {
[13:37:45.718]                   name <- changed[[kk]]
[13:37:45.718]                   NAME <- NAMES[[kk]]
[13:37:45.718]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.718]                     next
[13:37:45.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.718]                 }
[13:37:45.718]                 NAMES <- toupper(added)
[13:37:45.718]                 for (kk in seq_along(NAMES)) {
[13:37:45.718]                   name <- added[[kk]]
[13:37:45.718]                   NAME <- NAMES[[kk]]
[13:37:45.718]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.718]                     next
[13:37:45.718]                   args[[name]] <- ""
[13:37:45.718]                 }
[13:37:45.718]                 NAMES <- toupper(removed)
[13:37:45.718]                 for (kk in seq_along(NAMES)) {
[13:37:45.718]                   name <- removed[[kk]]
[13:37:45.718]                   NAME <- NAMES[[kk]]
[13:37:45.718]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.718]                     next
[13:37:45.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.718]                 }
[13:37:45.718]                 if (length(args) > 0) 
[13:37:45.718]                   base::do.call(base::Sys.setenv, args = args)
[13:37:45.718]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:45.718]             }
[13:37:45.718]             else {
[13:37:45.718]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:45.718]             }
[13:37:45.718]             {
[13:37:45.718]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:45.718]                   0L) {
[13:37:45.718]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:45.718]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:45.718]                   base::options(opts)
[13:37:45.718]                 }
[13:37:45.718]                 {
[13:37:45.718]                   {
[13:37:45.718]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:45.718]                     NULL
[13:37:45.718]                   }
[13:37:45.718]                   options(future.plan = NULL)
[13:37:45.718]                   if (is.na(NA_character_)) 
[13:37:45.718]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.718]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:45.718]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:45.718]                     .init = FALSE)
[13:37:45.718]                 }
[13:37:45.718]             }
[13:37:45.718]         }
[13:37:45.718]     })
[13:37:45.718]     if (TRUE) {
[13:37:45.718]         base::sink(type = "output", split = FALSE)
[13:37:45.718]         if (TRUE) {
[13:37:45.718]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:45.718]         }
[13:37:45.718]         else {
[13:37:45.718]             ...future.result["stdout"] <- base::list(NULL)
[13:37:45.718]         }
[13:37:45.718]         base::close(...future.stdout)
[13:37:45.718]         ...future.stdout <- NULL
[13:37:45.718]     }
[13:37:45.718]     ...future.result$conditions <- ...future.conditions
[13:37:45.718]     ...future.result$finished <- base::Sys.time()
[13:37:45.718]     ...future.result
[13:37:45.718] }
[13:37:45.721] requestCore(): workers = 2
[13:37:45.721] Poll #1 (0): usedCores() = 2, workers = 2
[13:37:45.732] result() for MulticoreFuture ...
[13:37:45.733] result() for MulticoreFuture ...
[13:37:45.733] result() for MulticoreFuture ... done
[13:37:45.733] result() for MulticoreFuture ... done
[13:37:45.733] result() for MulticoreFuture ...
[13:37:45.733] result() for MulticoreFuture ... done
[13:37:45.736] MulticoreFuture started
[13:37:45.736] - Launch lazy future ... done
[13:37:45.737] run() for ‘MulticoreFuture’ ... done
[13:37:45.738] plan(): Setting new future strategy stack:
[13:37:45.738] getGlobalsAndPackages() ...
[13:37:45.739] Searching for globals...
[13:37:45.738] List of future strategies:
[13:37:45.738] 1. sequential:
[13:37:45.738]    - args: function (..., envir = parent.frame())
[13:37:45.738]    - tweaked: FALSE
[13:37:45.738]    - call: NULL
[13:37:45.739] plan(): nbrOfWorkers() = 1
[13:37:45.742] - globals found: [2] ‘{’, ‘Sys.sleep’
[13:37:45.742] Searching for globals ... DONE
[13:37:45.742] plan(): Setting new future strategy stack:
[13:37:45.742] Resolving globals: FALSE
[13:37:45.743] List of future strategies:
[13:37:45.743] 1. multicore:
[13:37:45.743]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:37:45.743]    - tweaked: FALSE
[13:37:45.743]    - call: plan(strategy)
[13:37:45.743] 
[13:37:45.744] 
[13:37:45.744] getGlobalsAndPackages() ... DONE
[13:37:45.745] run() for ‘Future’ ...
[13:37:45.745] - state: ‘created’
[13:37:45.745] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:37:45.750] plan(): nbrOfWorkers() = 2
[13:37:45.751] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:45.751] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:37:45.751]   - Field: ‘label’
[13:37:45.751]   - Field: ‘local’
[13:37:45.752]   - Field: ‘owner’
[13:37:45.752]   - Field: ‘envir’
[13:37:45.752]   - Field: ‘workers’
[13:37:45.752]   - Field: ‘packages’
[13:37:45.752]   - Field: ‘gc’
[13:37:45.752]   - Field: ‘job’
[13:37:45.753]   - Field: ‘conditions’
[13:37:45.753]   - Field: ‘expr’
[13:37:45.753]   - Field: ‘uuid’
[13:37:45.753]   - Field: ‘seed’
[13:37:45.753]   - Field: ‘version’
[13:37:45.753]   - Field: ‘result’
[13:37:45.753]   - Field: ‘asynchronous’
[13:37:45.753]   - Field: ‘calls’
[13:37:45.754]   - Field: ‘globals’
[13:37:45.754]   - Field: ‘stdout’
[13:37:45.754]   - Field: ‘earlySignal’
[13:37:45.754]   - Field: ‘lazy’
[13:37:45.754]   - Field: ‘state’
[13:37:45.754] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:37:45.755] - Launch lazy future ...
[13:37:45.755] Packages needed by the future expression (n = 0): <none>
[13:37:45.755] Packages needed by future strategies (n = 0): <none>
[13:37:45.756] {
[13:37:45.756]     {
[13:37:45.756]         {
[13:37:45.756]             ...future.startTime <- base::Sys.time()
[13:37:45.756]             {
[13:37:45.756]                 {
[13:37:45.756]                   {
[13:37:45.756]                     {
[13:37:45.756]                       base::local({
[13:37:45.756]                         has_future <- base::requireNamespace("future", 
[13:37:45.756]                           quietly = TRUE)
[13:37:45.756]                         if (has_future) {
[13:37:45.756]                           ns <- base::getNamespace("future")
[13:37:45.756]                           version <- ns[[".package"]][["version"]]
[13:37:45.756]                           if (is.null(version)) 
[13:37:45.756]                             version <- utils::packageVersion("future")
[13:37:45.756]                         }
[13:37:45.756]                         else {
[13:37:45.756]                           version <- NULL
[13:37:45.756]                         }
[13:37:45.756]                         if (!has_future || version < "1.8.0") {
[13:37:45.756]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:45.756]                             "", base::R.version$version.string), 
[13:37:45.756]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:45.756]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:45.756]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:45.756]                               "release", "version")], collapse = " "), 
[13:37:45.756]                             hostname = base::Sys.info()[["nodename"]])
[13:37:45.756]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:45.756]                             info)
[13:37:45.756]                           info <- base::paste(info, collapse = "; ")
[13:37:45.756]                           if (!has_future) {
[13:37:45.756]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:45.756]                               info)
[13:37:45.756]                           }
[13:37:45.756]                           else {
[13:37:45.756]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:45.756]                               info, version)
[13:37:45.756]                           }
[13:37:45.756]                           base::stop(msg)
[13:37:45.756]                         }
[13:37:45.756]                       })
[13:37:45.756]                     }
[13:37:45.756]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:45.756]                     base::options(mc.cores = 1L)
[13:37:45.756]                   }
[13:37:45.756]                   ...future.strategy.old <- future::plan("list")
[13:37:45.756]                   options(future.plan = NULL)
[13:37:45.756]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.756]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:45.756]                 }
[13:37:45.756]                 ...future.workdir <- getwd()
[13:37:45.756]             }
[13:37:45.756]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:45.756]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:45.756]         }
[13:37:45.756]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:45.756]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:45.756]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:45.756]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:45.756]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:45.756]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:45.756]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:45.756]             base::names(...future.oldOptions))
[13:37:45.756]     }
[13:37:45.756]     if (FALSE) {
[13:37:45.756]     }
[13:37:45.756]     else {
[13:37:45.756]         if (TRUE) {
[13:37:45.756]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:45.756]                 open = "w")
[13:37:45.756]         }
[13:37:45.756]         else {
[13:37:45.756]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:45.756]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:45.756]         }
[13:37:45.756]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:45.756]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:45.756]             base::sink(type = "output", split = FALSE)
[13:37:45.756]             base::close(...future.stdout)
[13:37:45.756]         }, add = TRUE)
[13:37:45.756]     }
[13:37:45.756]     ...future.frame <- base::sys.nframe()
[13:37:45.756]     ...future.conditions <- base::list()
[13:37:45.756]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:45.756]     if (FALSE) {
[13:37:45.756]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:45.756]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:45.756]     }
[13:37:45.756]     ...future.result <- base::tryCatch({
[13:37:45.756]         base::withCallingHandlers({
[13:37:45.756]             ...future.value <- base::withVisible(base::local({
[13:37:45.756]                 withCallingHandlers({
[13:37:45.756]                   {
[13:37:45.756]                     Sys.sleep(0.5)
[13:37:45.756]                     2
[13:37:45.756]                   }
[13:37:45.756]                 }, immediateCondition = function(cond) {
[13:37:45.756]                   save_rds <- function (object, pathname, ...) 
[13:37:45.756]                   {
[13:37:45.756]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:37:45.756]                     if (file_test("-f", pathname_tmp)) {
[13:37:45.756]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.756]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:37:45.756]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.756]                         fi_tmp[["mtime"]])
[13:37:45.756]                     }
[13:37:45.756]                     tryCatch({
[13:37:45.756]                       saveRDS(object, file = pathname_tmp, ...)
[13:37:45.756]                     }, error = function(ex) {
[13:37:45.756]                       msg <- conditionMessage(ex)
[13:37:45.756]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.756]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:37:45.756]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.756]                         fi_tmp[["mtime"]], msg)
[13:37:45.756]                       ex$message <- msg
[13:37:45.756]                       stop(ex)
[13:37:45.756]                     })
[13:37:45.756]                     stopifnot(file_test("-f", pathname_tmp))
[13:37:45.756]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:37:45.756]                     if (!res || file_test("-f", pathname_tmp)) {
[13:37:45.756]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.756]                       fi <- file.info(pathname)
[13:37:45.756]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:37:45.756]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.756]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:37:45.756]                         fi[["size"]], fi[["mtime"]])
[13:37:45.756]                       stop(msg)
[13:37:45.756]                     }
[13:37:45.756]                     invisible(pathname)
[13:37:45.756]                   }
[13:37:45.756]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:37:45.756]                     rootPath = tempdir()) 
[13:37:45.756]                   {
[13:37:45.756]                     obj <- list(time = Sys.time(), condition = cond)
[13:37:45.756]                     file <- tempfile(pattern = class(cond)[1], 
[13:37:45.756]                       tmpdir = path, fileext = ".rds")
[13:37:45.756]                     save_rds(obj, file)
[13:37:45.756]                   }
[13:37:45.756]                   saveImmediateCondition(cond, path = "/tmp/RtmpLAMaHJ/.future/immediateConditions")
[13:37:45.756]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.756]                   {
[13:37:45.756]                     inherits <- base::inherits
[13:37:45.756]                     invokeRestart <- base::invokeRestart
[13:37:45.756]                     is.null <- base::is.null
[13:37:45.756]                     muffled <- FALSE
[13:37:45.756]                     if (inherits(cond, "message")) {
[13:37:45.756]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:45.756]                       if (muffled) 
[13:37:45.756]                         invokeRestart("muffleMessage")
[13:37:45.756]                     }
[13:37:45.756]                     else if (inherits(cond, "warning")) {
[13:37:45.756]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:45.756]                       if (muffled) 
[13:37:45.756]                         invokeRestart("muffleWarning")
[13:37:45.756]                     }
[13:37:45.756]                     else if (inherits(cond, "condition")) {
[13:37:45.756]                       if (!is.null(pattern)) {
[13:37:45.756]                         computeRestarts <- base::computeRestarts
[13:37:45.756]                         grepl <- base::grepl
[13:37:45.756]                         restarts <- computeRestarts(cond)
[13:37:45.756]                         for (restart in restarts) {
[13:37:45.756]                           name <- restart$name
[13:37:45.756]                           if (is.null(name)) 
[13:37:45.756]                             next
[13:37:45.756]                           if (!grepl(pattern, name)) 
[13:37:45.756]                             next
[13:37:45.756]                           invokeRestart(restart)
[13:37:45.756]                           muffled <- TRUE
[13:37:45.756]                           break
[13:37:45.756]                         }
[13:37:45.756]                       }
[13:37:45.756]                     }
[13:37:45.756]                     invisible(muffled)
[13:37:45.756]                   }
[13:37:45.756]                   muffleCondition(cond)
[13:37:45.756]                 })
[13:37:45.756]             }))
[13:37:45.756]             future::FutureResult(value = ...future.value$value, 
[13:37:45.756]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.756]                   ...future.rng), globalenv = if (FALSE) 
[13:37:45.756]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:45.756]                     ...future.globalenv.names))
[13:37:45.756]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:45.756]         }, condition = base::local({
[13:37:45.756]             c <- base::c
[13:37:45.756]             inherits <- base::inherits
[13:37:45.756]             invokeRestart <- base::invokeRestart
[13:37:45.756]             length <- base::length
[13:37:45.756]             list <- base::list
[13:37:45.756]             seq.int <- base::seq.int
[13:37:45.756]             signalCondition <- base::signalCondition
[13:37:45.756]             sys.calls <- base::sys.calls
[13:37:45.756]             `[[` <- base::`[[`
[13:37:45.756]             `+` <- base::`+`
[13:37:45.756]             `<<-` <- base::`<<-`
[13:37:45.756]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:45.756]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:45.756]                   3L)]
[13:37:45.756]             }
[13:37:45.756]             function(cond) {
[13:37:45.756]                 is_error <- inherits(cond, "error")
[13:37:45.756]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:45.756]                   NULL)
[13:37:45.756]                 if (is_error) {
[13:37:45.756]                   sessionInformation <- function() {
[13:37:45.756]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:45.756]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:45.756]                       search = base::search(), system = base::Sys.info())
[13:37:45.756]                   }
[13:37:45.756]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.756]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:45.756]                     cond$call), session = sessionInformation(), 
[13:37:45.756]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:45.756]                   signalCondition(cond)
[13:37:45.756]                 }
[13:37:45.756]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:45.756]                 "immediateCondition"))) {
[13:37:45.756]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:45.756]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.756]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:45.756]                   if (TRUE && !signal) {
[13:37:45.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.756]                     {
[13:37:45.756]                       inherits <- base::inherits
[13:37:45.756]                       invokeRestart <- base::invokeRestart
[13:37:45.756]                       is.null <- base::is.null
[13:37:45.756]                       muffled <- FALSE
[13:37:45.756]                       if (inherits(cond, "message")) {
[13:37:45.756]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.756]                         if (muffled) 
[13:37:45.756]                           invokeRestart("muffleMessage")
[13:37:45.756]                       }
[13:37:45.756]                       else if (inherits(cond, "warning")) {
[13:37:45.756]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.756]                         if (muffled) 
[13:37:45.756]                           invokeRestart("muffleWarning")
[13:37:45.756]                       }
[13:37:45.756]                       else if (inherits(cond, "condition")) {
[13:37:45.756]                         if (!is.null(pattern)) {
[13:37:45.756]                           computeRestarts <- base::computeRestarts
[13:37:45.756]                           grepl <- base::grepl
[13:37:45.756]                           restarts <- computeRestarts(cond)
[13:37:45.756]                           for (restart in restarts) {
[13:37:45.756]                             name <- restart$name
[13:37:45.756]                             if (is.null(name)) 
[13:37:45.756]                               next
[13:37:45.756]                             if (!grepl(pattern, name)) 
[13:37:45.756]                               next
[13:37:45.756]                             invokeRestart(restart)
[13:37:45.756]                             muffled <- TRUE
[13:37:45.756]                             break
[13:37:45.756]                           }
[13:37:45.756]                         }
[13:37:45.756]                       }
[13:37:45.756]                       invisible(muffled)
[13:37:45.756]                     }
[13:37:45.756]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.756]                   }
[13:37:45.756]                 }
[13:37:45.756]                 else {
[13:37:45.756]                   if (TRUE) {
[13:37:45.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.756]                     {
[13:37:45.756]                       inherits <- base::inherits
[13:37:45.756]                       invokeRestart <- base::invokeRestart
[13:37:45.756]                       is.null <- base::is.null
[13:37:45.756]                       muffled <- FALSE
[13:37:45.756]                       if (inherits(cond, "message")) {
[13:37:45.756]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.756]                         if (muffled) 
[13:37:45.756]                           invokeRestart("muffleMessage")
[13:37:45.756]                       }
[13:37:45.756]                       else if (inherits(cond, "warning")) {
[13:37:45.756]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.756]                         if (muffled) 
[13:37:45.756]                           invokeRestart("muffleWarning")
[13:37:45.756]                       }
[13:37:45.756]                       else if (inherits(cond, "condition")) {
[13:37:45.756]                         if (!is.null(pattern)) {
[13:37:45.756]                           computeRestarts <- base::computeRestarts
[13:37:45.756]                           grepl <- base::grepl
[13:37:45.756]                           restarts <- computeRestarts(cond)
[13:37:45.756]                           for (restart in restarts) {
[13:37:45.756]                             name <- restart$name
[13:37:45.756]                             if (is.null(name)) 
[13:37:45.756]                               next
[13:37:45.756]                             if (!grepl(pattern, name)) 
[13:37:45.756]                               next
[13:37:45.756]                             invokeRestart(restart)
[13:37:45.756]                             muffled <- TRUE
[13:37:45.756]                             break
[13:37:45.756]                           }
[13:37:45.756]                         }
[13:37:45.756]                       }
[13:37:45.756]                       invisible(muffled)
[13:37:45.756]                     }
[13:37:45.756]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.756]                   }
[13:37:45.756]                 }
[13:37:45.756]             }
[13:37:45.756]         }))
[13:37:45.756]     }, error = function(ex) {
[13:37:45.756]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:45.756]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.756]                 ...future.rng), started = ...future.startTime, 
[13:37:45.756]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:45.756]             version = "1.8"), class = "FutureResult")
[13:37:45.756]     }, finally = {
[13:37:45.756]         if (!identical(...future.workdir, getwd())) 
[13:37:45.756]             setwd(...future.workdir)
[13:37:45.756]         {
[13:37:45.756]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:45.756]                 ...future.oldOptions$nwarnings <- NULL
[13:37:45.756]             }
[13:37:45.756]             base::options(...future.oldOptions)
[13:37:45.756]             if (.Platform$OS.type == "windows") {
[13:37:45.756]                 old_names <- names(...future.oldEnvVars)
[13:37:45.756]                 envs <- base::Sys.getenv()
[13:37:45.756]                 names <- names(envs)
[13:37:45.756]                 common <- intersect(names, old_names)
[13:37:45.756]                 added <- setdiff(names, old_names)
[13:37:45.756]                 removed <- setdiff(old_names, names)
[13:37:45.756]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:45.756]                   envs[common]]
[13:37:45.756]                 NAMES <- toupper(changed)
[13:37:45.756]                 args <- list()
[13:37:45.756]                 for (kk in seq_along(NAMES)) {
[13:37:45.756]                   name <- changed[[kk]]
[13:37:45.756]                   NAME <- NAMES[[kk]]
[13:37:45.756]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.756]                     next
[13:37:45.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.756]                 }
[13:37:45.756]                 NAMES <- toupper(added)
[13:37:45.756]                 for (kk in seq_along(NAMES)) {
[13:37:45.756]                   name <- added[[kk]]
[13:37:45.756]                   NAME <- NAMES[[kk]]
[13:37:45.756]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.756]                     next
[13:37:45.756]                   args[[name]] <- ""
[13:37:45.756]                 }
[13:37:45.756]                 NAMES <- toupper(removed)
[13:37:45.756]                 for (kk in seq_along(NAMES)) {
[13:37:45.756]                   name <- removed[[kk]]
[13:37:45.756]                   NAME <- NAMES[[kk]]
[13:37:45.756]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.756]                     next
[13:37:45.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.756]                 }
[13:37:45.756]                 if (length(args) > 0) 
[13:37:45.756]                   base::do.call(base::Sys.setenv, args = args)
[13:37:45.756]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:45.756]             }
[13:37:45.756]             else {
[13:37:45.756]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:45.756]             }
[13:37:45.756]             {
[13:37:45.756]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:45.756]                   0L) {
[13:37:45.756]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:45.756]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:45.756]                   base::options(opts)
[13:37:45.756]                 }
[13:37:45.756]                 {
[13:37:45.756]                   {
[13:37:45.756]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:45.756]                     NULL
[13:37:45.756]                   }
[13:37:45.756]                   options(future.plan = NULL)
[13:37:45.756]                   if (is.na(NA_character_)) 
[13:37:45.756]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.756]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:45.756]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:45.756]                     .init = FALSE)
[13:37:45.756]                 }
[13:37:45.756]             }
[13:37:45.756]         }
[13:37:45.756]     })
[13:37:45.756]     if (TRUE) {
[13:37:45.756]         base::sink(type = "output", split = FALSE)
[13:37:45.756]         if (TRUE) {
[13:37:45.756]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:45.756]         }
[13:37:45.756]         else {
[13:37:45.756]             ...future.result["stdout"] <- base::list(NULL)
[13:37:45.756]         }
[13:37:45.756]         base::close(...future.stdout)
[13:37:45.756]         ...future.stdout <- NULL
[13:37:45.756]     }
[13:37:45.756]     ...future.result$conditions <- ...future.conditions
[13:37:45.756]     ...future.result$finished <- base::Sys.time()
[13:37:45.756]     ...future.result
[13:37:45.756] }
[13:37:45.760] requestCore(): workers = 2
[13:37:45.760] Poll #1 (0): usedCores() = 2, workers = 2
[13:37:45.771] result() for MulticoreFuture ...
[13:37:45.772] result() for MulticoreFuture ...
[13:37:45.772] result() for MulticoreFuture ... done
[13:37:45.772] result() for MulticoreFuture ... done
[13:37:45.773] result() for MulticoreFuture ...
[13:37:45.773] result() for MulticoreFuture ... done
[13:37:45.776] MulticoreFuture started
[13:37:45.777] - Launch lazy future ... done
[13:37:45.777] run() for ‘MulticoreFuture’ ... done
[13:37:45.777] plan(): Setting new future strategy stack:
[13:37:45.778] getGlobalsAndPackages() ...
[13:37:45.778] Searching for globals...
[13:37:45.778] List of future strategies:
[13:37:45.778] 1. sequential:
[13:37:45.778]    - args: function (..., envir = parent.frame())
[13:37:45.778]    - tweaked: FALSE
[13:37:45.778]    - call: NULL
[13:37:45.779] plan(): nbrOfWorkers() = 1
[13:37:45.780] - globals found: [1] ‘{’
[13:37:45.780] Searching for globals ... DONE
[13:37:45.780] Resolving globals: FALSE
[13:37:45.781] 
[13:37:45.781] 
[13:37:45.781] getGlobalsAndPackages() ... DONE
[13:37:45.781] run() for ‘Future’ ...
[13:37:45.782] - state: ‘created’
[13:37:45.782] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:37:45.793] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:45.793] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:37:45.794]   - Field: ‘label’
[13:37:45.794]   - Field: ‘local’
[13:37:45.794]   - Field: ‘owner’
[13:37:45.795]   - Field: ‘envir’
[13:37:45.795]   - Field: ‘workers’
[13:37:45.795]   - Field: ‘packages’
[13:37:45.796]   - Field: ‘gc’
[13:37:45.796]   - Field: ‘job’
[13:37:45.796]   - Field: ‘conditions’
[13:37:45.797]   - Field: ‘expr’
[13:37:45.797]   - Field: ‘uuid’
[13:37:45.798]   - Field: ‘seed’
[13:37:45.798]   - Field: ‘version’
[13:37:45.798]   - Field: ‘result’
[13:37:45.798]   - Field: ‘asynchronous’
[13:37:45.799]   - Field: ‘calls’
[13:37:45.799]   - Field: ‘globals’
[13:37:45.799]   - Field: ‘stdout’
[13:37:45.799]   - Field: ‘earlySignal’
[13:37:45.799]   - Field: ‘lazy’
[13:37:45.800]   - Field: ‘state’
[13:37:45.800] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:37:45.800] - Launch lazy future ...
[13:37:45.801] Packages needed by the future expression (n = 0): <none>
[13:37:45.801] Packages needed by future strategies (n = 0): <none>
[13:37:45.802] {
[13:37:45.802]     {
[13:37:45.802]         {
[13:37:45.802]             ...future.startTime <- base::Sys.time()
[13:37:45.802]             {
[13:37:45.802]                 {
[13:37:45.802]                   {
[13:37:45.802]                     {
[13:37:45.802]                       base::local({
[13:37:45.802]                         has_future <- base::requireNamespace("future", 
[13:37:45.802]                           quietly = TRUE)
[13:37:45.802]                         if (has_future) {
[13:37:45.802]                           ns <- base::getNamespace("future")
[13:37:45.802]                           version <- ns[[".package"]][["version"]]
[13:37:45.802]                           if (is.null(version)) 
[13:37:45.802]                             version <- utils::packageVersion("future")
[13:37:45.802]                         }
[13:37:45.802]                         else {
[13:37:45.802]                           version <- NULL
[13:37:45.802]                         }
[13:37:45.802]                         if (!has_future || version < "1.8.0") {
[13:37:45.802]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:45.802]                             "", base::R.version$version.string), 
[13:37:45.802]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:45.802]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:45.802]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:45.802]                               "release", "version")], collapse = " "), 
[13:37:45.802]                             hostname = base::Sys.info()[["nodename"]])
[13:37:45.802]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:45.802]                             info)
[13:37:45.802]                           info <- base::paste(info, collapse = "; ")
[13:37:45.802]                           if (!has_future) {
[13:37:45.802]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:45.802]                               info)
[13:37:45.802]                           }
[13:37:45.802]                           else {
[13:37:45.802]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:45.802]                               info, version)
[13:37:45.802]                           }
[13:37:45.802]                           base::stop(msg)
[13:37:45.802]                         }
[13:37:45.802]                       })
[13:37:45.802]                     }
[13:37:45.802]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:45.802]                     base::options(mc.cores = 1L)
[13:37:45.802]                   }
[13:37:45.802]                   ...future.strategy.old <- future::plan("list")
[13:37:45.802]                   options(future.plan = NULL)
[13:37:45.802]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.802]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:45.802]                 }
[13:37:45.802]                 ...future.workdir <- getwd()
[13:37:45.802]             }
[13:37:45.802]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:45.802]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:45.802]         }
[13:37:45.802]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:45.802]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:45.802]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:45.802]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:45.802]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:45.802]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:45.802]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:45.802]             base::names(...future.oldOptions))
[13:37:45.802]     }
[13:37:45.802]     if (FALSE) {
[13:37:45.802]     }
[13:37:45.802]     else {
[13:37:45.802]         if (TRUE) {
[13:37:45.802]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:45.802]                 open = "w")
[13:37:45.802]         }
[13:37:45.802]         else {
[13:37:45.802]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:45.802]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:45.802]         }
[13:37:45.802]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:45.802]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:45.802]             base::sink(type = "output", split = FALSE)
[13:37:45.802]             base::close(...future.stdout)
[13:37:45.802]         }, add = TRUE)
[13:37:45.802]     }
[13:37:45.802]     ...future.frame <- base::sys.nframe()
[13:37:45.802]     ...future.conditions <- base::list()
[13:37:45.802]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:45.802]     if (FALSE) {
[13:37:45.802]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:45.802]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:45.802]     }
[13:37:45.802]     ...future.result <- base::tryCatch({
[13:37:45.802]         base::withCallingHandlers({
[13:37:45.802]             ...future.value <- base::withVisible(base::local({
[13:37:45.802]                 withCallingHandlers({
[13:37:45.802]                   {
[13:37:45.802]                     3
[13:37:45.802]                   }
[13:37:45.802]                 }, immediateCondition = function(cond) {
[13:37:45.802]                   save_rds <- function (object, pathname, ...) 
[13:37:45.802]                   {
[13:37:45.802]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:37:45.802]                     if (file_test("-f", pathname_tmp)) {
[13:37:45.802]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.802]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:37:45.802]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.802]                         fi_tmp[["mtime"]])
[13:37:45.802]                     }
[13:37:45.802]                     tryCatch({
[13:37:45.802]                       saveRDS(object, file = pathname_tmp, ...)
[13:37:45.802]                     }, error = function(ex) {
[13:37:45.802]                       msg <- conditionMessage(ex)
[13:37:45.802]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.802]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:37:45.802]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.802]                         fi_tmp[["mtime"]], msg)
[13:37:45.802]                       ex$message <- msg
[13:37:45.802]                       stop(ex)
[13:37:45.802]                     })
[13:37:45.802]                     stopifnot(file_test("-f", pathname_tmp))
[13:37:45.802]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:37:45.802]                     if (!res || file_test("-f", pathname_tmp)) {
[13:37:45.802]                       fi_tmp <- file.info(pathname_tmp)
[13:37:45.802]                       fi <- file.info(pathname)
[13:37:45.802]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:37:45.802]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:37:45.802]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:37:45.802]                         fi[["size"]], fi[["mtime"]])
[13:37:45.802]                       stop(msg)
[13:37:45.802]                     }
[13:37:45.802]                     invisible(pathname)
[13:37:45.802]                   }
[13:37:45.802]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:37:45.802]                     rootPath = tempdir()) 
[13:37:45.802]                   {
[13:37:45.802]                     obj <- list(time = Sys.time(), condition = cond)
[13:37:45.802]                     file <- tempfile(pattern = class(cond)[1], 
[13:37:45.802]                       tmpdir = path, fileext = ".rds")
[13:37:45.802]                     save_rds(obj, file)
[13:37:45.802]                   }
[13:37:45.802]                   saveImmediateCondition(cond, path = "/tmp/RtmpLAMaHJ/.future/immediateConditions")
[13:37:45.802]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.802]                   {
[13:37:45.802]                     inherits <- base::inherits
[13:37:45.802]                     invokeRestart <- base::invokeRestart
[13:37:45.802]                     is.null <- base::is.null
[13:37:45.802]                     muffled <- FALSE
[13:37:45.802]                     if (inherits(cond, "message")) {
[13:37:45.802]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:45.802]                       if (muffled) 
[13:37:45.802]                         invokeRestart("muffleMessage")
[13:37:45.802]                     }
[13:37:45.802]                     else if (inherits(cond, "warning")) {
[13:37:45.802]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:45.802]                       if (muffled) 
[13:37:45.802]                         invokeRestart("muffleWarning")
[13:37:45.802]                     }
[13:37:45.802]                     else if (inherits(cond, "condition")) {
[13:37:45.802]                       if (!is.null(pattern)) {
[13:37:45.802]                         computeRestarts <- base::computeRestarts
[13:37:45.802]                         grepl <- base::grepl
[13:37:45.802]                         restarts <- computeRestarts(cond)
[13:37:45.802]                         for (restart in restarts) {
[13:37:45.802]                           name <- restart$name
[13:37:45.802]                           if (is.null(name)) 
[13:37:45.802]                             next
[13:37:45.802]                           if (!grepl(pattern, name)) 
[13:37:45.802]                             next
[13:37:45.802]                           invokeRestart(restart)
[13:37:45.802]                           muffled <- TRUE
[13:37:45.802]                           break
[13:37:45.802]                         }
[13:37:45.802]                       }
[13:37:45.802]                     }
[13:37:45.802]                     invisible(muffled)
[13:37:45.802]                   }
[13:37:45.802]                   muffleCondition(cond)
[13:37:45.802]                 })
[13:37:45.802]             }))
[13:37:45.802]             future::FutureResult(value = ...future.value$value, 
[13:37:45.802]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.802]                   ...future.rng), globalenv = if (FALSE) 
[13:37:45.802]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:45.802]                     ...future.globalenv.names))
[13:37:45.802]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:45.802]         }, condition = base::local({
[13:37:45.802]             c <- base::c
[13:37:45.802]             inherits <- base::inherits
[13:37:45.802]             invokeRestart <- base::invokeRestart
[13:37:45.802]             length <- base::length
[13:37:45.802]             list <- base::list
[13:37:45.802]             seq.int <- base::seq.int
[13:37:45.802]             signalCondition <- base::signalCondition
[13:37:45.802]             sys.calls <- base::sys.calls
[13:37:45.802]             `[[` <- base::`[[`
[13:37:45.802]             `+` <- base::`+`
[13:37:45.802]             `<<-` <- base::`<<-`
[13:37:45.802]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:45.802]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:45.802]                   3L)]
[13:37:45.802]             }
[13:37:45.802]             function(cond) {
[13:37:45.802]                 is_error <- inherits(cond, "error")
[13:37:45.802]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:45.802]                   NULL)
[13:37:45.802]                 if (is_error) {
[13:37:45.802]                   sessionInformation <- function() {
[13:37:45.802]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:45.802]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:45.802]                       search = base::search(), system = base::Sys.info())
[13:37:45.802]                   }
[13:37:45.802]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.802]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:45.802]                     cond$call), session = sessionInformation(), 
[13:37:45.802]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:45.802]                   signalCondition(cond)
[13:37:45.802]                 }
[13:37:45.802]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:45.802]                 "immediateCondition"))) {
[13:37:45.802]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:45.802]                   ...future.conditions[[length(...future.conditions) + 
[13:37:45.802]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:45.802]                   if (TRUE && !signal) {
[13:37:45.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.802]                     {
[13:37:45.802]                       inherits <- base::inherits
[13:37:45.802]                       invokeRestart <- base::invokeRestart
[13:37:45.802]                       is.null <- base::is.null
[13:37:45.802]                       muffled <- FALSE
[13:37:45.802]                       if (inherits(cond, "message")) {
[13:37:45.802]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.802]                         if (muffled) 
[13:37:45.802]                           invokeRestart("muffleMessage")
[13:37:45.802]                       }
[13:37:45.802]                       else if (inherits(cond, "warning")) {
[13:37:45.802]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.802]                         if (muffled) 
[13:37:45.802]                           invokeRestart("muffleWarning")
[13:37:45.802]                       }
[13:37:45.802]                       else if (inherits(cond, "condition")) {
[13:37:45.802]                         if (!is.null(pattern)) {
[13:37:45.802]                           computeRestarts <- base::computeRestarts
[13:37:45.802]                           grepl <- base::grepl
[13:37:45.802]                           restarts <- computeRestarts(cond)
[13:37:45.802]                           for (restart in restarts) {
[13:37:45.802]                             name <- restart$name
[13:37:45.802]                             if (is.null(name)) 
[13:37:45.802]                               next
[13:37:45.802]                             if (!grepl(pattern, name)) 
[13:37:45.802]                               next
[13:37:45.802]                             invokeRestart(restart)
[13:37:45.802]                             muffled <- TRUE
[13:37:45.802]                             break
[13:37:45.802]                           }
[13:37:45.802]                         }
[13:37:45.802]                       }
[13:37:45.802]                       invisible(muffled)
[13:37:45.802]                     }
[13:37:45.802]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.802]                   }
[13:37:45.802]                 }
[13:37:45.802]                 else {
[13:37:45.802]                   if (TRUE) {
[13:37:45.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:45.802]                     {
[13:37:45.802]                       inherits <- base::inherits
[13:37:45.802]                       invokeRestart <- base::invokeRestart
[13:37:45.802]                       is.null <- base::is.null
[13:37:45.802]                       muffled <- FALSE
[13:37:45.802]                       if (inherits(cond, "message")) {
[13:37:45.802]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:45.802]                         if (muffled) 
[13:37:45.802]                           invokeRestart("muffleMessage")
[13:37:45.802]                       }
[13:37:45.802]                       else if (inherits(cond, "warning")) {
[13:37:45.802]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:45.802]                         if (muffled) 
[13:37:45.802]                           invokeRestart("muffleWarning")
[13:37:45.802]                       }
[13:37:45.802]                       else if (inherits(cond, "condition")) {
[13:37:45.802]                         if (!is.null(pattern)) {
[13:37:45.802]                           computeRestarts <- base::computeRestarts
[13:37:45.802]                           grepl <- base::grepl
[13:37:45.802]                           restarts <- computeRestarts(cond)
[13:37:45.802]                           for (restart in restarts) {
[13:37:45.802]                             name <- restart$name
[13:37:45.802]                             if (is.null(name)) 
[13:37:45.802]                               next
[13:37:45.802]                             if (!grepl(pattern, name)) 
[13:37:45.802]                               next
[13:37:45.802]                             invokeRestart(restart)
[13:37:45.802]                             muffled <- TRUE
[13:37:45.802]                             break
[13:37:45.802]                           }
[13:37:45.802]                         }
[13:37:45.802]                       }
[13:37:45.802]                       invisible(muffled)
[13:37:45.802]                     }
[13:37:45.802]                     muffleCondition(cond, pattern = "^muffle")
[13:37:45.802]                   }
[13:37:45.802]                 }
[13:37:45.802]             }
[13:37:45.802]         }))
[13:37:45.802]     }, error = function(ex) {
[13:37:45.802]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:45.802]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:45.802]                 ...future.rng), started = ...future.startTime, 
[13:37:45.802]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:45.802]             version = "1.8"), class = "FutureResult")
[13:37:45.802]     }, finally = {
[13:37:45.802]         if (!identical(...future.workdir, getwd())) 
[13:37:45.802]             setwd(...future.workdir)
[13:37:45.802]         {
[13:37:45.802]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:45.802]                 ...future.oldOptions$nwarnings <- NULL
[13:37:45.802]             }
[13:37:45.802]             base::options(...future.oldOptions)
[13:37:45.802]             if (.Platform$OS.type == "windows") {
[13:37:45.802]                 old_names <- names(...future.oldEnvVars)
[13:37:45.802]                 envs <- base::Sys.getenv()
[13:37:45.802]                 names <- names(envs)
[13:37:45.802]                 common <- intersect(names, old_names)
[13:37:45.802]                 added <- setdiff(names, old_names)
[13:37:45.802]                 removed <- setdiff(old_names, names)
[13:37:45.802]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:45.802]                   envs[common]]
[13:37:45.802]                 NAMES <- toupper(changed)
[13:37:45.802]                 args <- list()
[13:37:45.802]                 for (kk in seq_along(NAMES)) {
[13:37:45.802]                   name <- changed[[kk]]
[13:37:45.802]                   NAME <- NAMES[[kk]]
[13:37:45.802]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.802]                     next
[13:37:45.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.802]                 }
[13:37:45.802]                 NAMES <- toupper(added)
[13:37:45.802]                 for (kk in seq_along(NAMES)) {
[13:37:45.802]                   name <- added[[kk]]
[13:37:45.802]                   NAME <- NAMES[[kk]]
[13:37:45.802]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.802]                     next
[13:37:45.802]                   args[[name]] <- ""
[13:37:45.802]                 }
[13:37:45.802]                 NAMES <- toupper(removed)
[13:37:45.802]                 for (kk in seq_along(NAMES)) {
[13:37:45.802]                   name <- removed[[kk]]
[13:37:45.802]                   NAME <- NAMES[[kk]]
[13:37:45.802]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:45.802]                     next
[13:37:45.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:45.802]                 }
[13:37:45.802]                 if (length(args) > 0) 
[13:37:45.802]                   base::do.call(base::Sys.setenv, args = args)
[13:37:45.802]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:45.802]             }
[13:37:45.802]             else {
[13:37:45.802]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:45.802]             }
[13:37:45.802]             {
[13:37:45.802]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:45.802]                   0L) {
[13:37:45.802]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:45.802]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:45.802]                   base::options(opts)
[13:37:45.802]                 }
[13:37:45.802]                 {
[13:37:45.802]                   {
[13:37:45.802]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:45.802]                     NULL
[13:37:45.802]                   }
[13:37:45.802]                   options(future.plan = NULL)
[13:37:45.802]                   if (is.na(NA_character_)) 
[13:37:45.802]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:45.802]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:45.802]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:45.802]                     .init = FALSE)
[13:37:45.802]                 }
[13:37:45.802]             }
[13:37:45.802]         }
[13:37:45.802]     })
[13:37:45.802]     if (TRUE) {
[13:37:45.802]         base::sink(type = "output", split = FALSE)
[13:37:45.802]         if (TRUE) {
[13:37:45.802]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:45.802]         }
[13:37:45.802]         else {
[13:37:45.802]             ...future.result["stdout"] <- base::list(NULL)
[13:37:45.802]         }
[13:37:45.802]         base::close(...future.stdout)
[13:37:45.802]         ...future.stdout <- NULL
[13:37:45.802]     }
[13:37:45.802]     ...future.result$conditions <- ...future.conditions
[13:37:45.802]     ...future.result$finished <- base::Sys.time()
[13:37:45.802]     ...future.result
[13:37:45.802] }
[13:37:45.805] requestCore(): workers = 2
[13:37:45.805] Poll #1 (0): usedCores() = 2, workers = 2
[13:37:45.816] result() for MulticoreFuture ...
[13:37:45.817] result() for MulticoreFuture ...
[13:37:45.818] result() for MulticoreFuture ... done
[13:37:45.818] result() for MulticoreFuture ... done
[13:37:45.818] result() for MulticoreFuture ...
[13:37:45.818] result() for MulticoreFuture ... done
[13:37:45.821] MulticoreFuture started
[13:37:45.821] - Launch lazy future ... done
[13:37:45.822] run() for ‘MulticoreFuture’ ... done
[13:37:45.822] plan(): Setting new future strategy stack:
[13:37:45.822] List of future strategies:
[13:37:45.822] 1. sequential:
[13:37:45.822]    - args: function (..., envir = parent.frame())
[13:37:45.822]    - tweaked: FALSE
[13:37:45.822]    - call: NULL
[13:37:45.823] plan(): nbrOfWorkers() = 1
[13:37:45.824] resolve() on list environment ...
[13:37:45.824]  recursive: 0
[13:37:45.825]  length: 4
[13:37:45.825]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:37:45.826] Future #1
[13:37:45.826]  length: 3 (resolved future 1)
[13:37:45.826] plan(): Setting new future strategy stack:
[13:37:45.826] List of future strategies:
[13:37:45.826] 1. multicore:
[13:37:45.826]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:37:45.826]    - tweaked: FALSE
[13:37:45.826]    - call: plan(strategy)
[13:37:45.831] plan(): nbrOfWorkers() = 2
[13:37:45.837] Future #3
[13:37:45.837]  length: 2 (resolved future 3)
[13:37:45.837]  length: 1 (resolved future 4)
[13:37:46.282] plan(): Setting new future strategy stack:
[13:37:46.282] List of future strategies:
[13:37:46.282] 1. multicore:
[13:37:46.282]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:37:46.282]    - tweaked: FALSE
[13:37:46.282]    - call: plan(strategy)
[13:37:46.287] plan(): nbrOfWorkers() = 2
[13:37:46.287] Future #2
[13:37:46.287]  length: 0 (resolved future 2)
[13:37:46.288] resolve() on list environment ... DONE
[13:37:46.288] resolve() on list environment ...
[13:37:46.288]  recursive: 0
[13:37:46.290]  length: 4
[13:37:46.290]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:37:46.290] Future #1
[13:37:46.290]  length: 3 (resolved future 1)
[13:37:46.290] Future #2
[13:37:46.291]  length: 2 (resolved future 2)
[13:37:46.291] Future #3
[13:37:46.291]  length: 1 (resolved future 3)
[13:37:46.291]  length: 0 (resolved future 4)
[13:37:46.291] resolve() on list environment ... DONE
[13:37:46.292] resolve() on list environment ...
[13:37:46.293]  recursive: 0
[13:37:46.293]  length: 4
[13:37:46.294]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:37:46.294] Future #1
[13:37:46.294]  length: 3 (resolved future 1)
[13:37:46.294] Future #2
[13:37:46.294]  length: 2 (resolved future 2)
[13:37:46.295] Future #3
[13:37:46.295]  length: 1 (resolved future 3)
[13:37:46.295]  length: 0 (resolved future 4)
[13:37:46.295] resolve() on list environment ... DONE
[13:37:46.296] resolve() on list environment ...
[13:37:46.296]  recursive: 0
[13:37:46.297]  length: 4
[13:37:46.297]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:37:46.297] Future #1
[13:37:46.297]  length: 3 (resolved future 1)
[13:37:46.298] Future #2
[13:37:46.298]  length: 2 (resolved future 2)
[13:37:46.298] Future #3
[13:37:46.298]  length: 1 (resolved future 3)
[13:37:46.299]  length: 0 (resolved future 4)
[13:37:46.299] resolve() on list environment ... DONE
[13:37:46.299] resolve() on list environment ...
[13:37:46.299]  recursive: 0
[13:37:46.300]  length: 4
[13:37:46.301]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:37:46.301] Future #1
[13:37:46.301] result() for MulticoreFuture ...
[13:37:46.301] result() for MulticoreFuture ... done
[13:37:46.301] result() for MulticoreFuture ...
[13:37:46.301] result() for MulticoreFuture ... done
[13:37:46.302]  length: 3 (resolved future 1)
[13:37:46.302] Future #2
[13:37:46.302] result() for MulticoreFuture ...
[13:37:46.303] result() for MulticoreFuture ...
[13:37:46.303] result() for MulticoreFuture ... done
[13:37:46.303] result() for MulticoreFuture ... done
[13:37:46.303] result() for MulticoreFuture ...
[13:37:46.303] result() for MulticoreFuture ... done
[13:37:46.304]  length: 2 (resolved future 2)
[13:37:46.304] Future #3
[13:37:46.304] result() for MulticoreFuture ...
[13:37:46.305] result() for MulticoreFuture ...
[13:37:46.308] result() for MulticoreFuture ... done
[13:37:46.308] result() for MulticoreFuture ... done
[13:37:46.309] result() for MulticoreFuture ...
[13:37:46.309] result() for MulticoreFuture ... done
[13:37:46.309]  length: 1 (resolved future 3)
[13:37:46.309]  length: 0 (resolved future 4)
[13:37:46.309] resolve() on list environment ... DONE
[13:37:46.310] resolve() on list environment ...
[13:37:46.311]  recursive: 99
[13:37:46.311]  length: 4
[13:37:46.312]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:37:46.312] Future #1
[13:37:46.312] result() for MulticoreFuture ...
[13:37:46.312] result() for MulticoreFuture ... done
[13:37:46.312] result() for MulticoreFuture ...
[13:37:46.312] result() for MulticoreFuture ... done
[13:37:46.312] A MulticoreFuture was resolved
[13:37:46.313]  length: 3 (resolved future 1)
[13:37:46.313] Future #2
[13:37:46.313] result() for MulticoreFuture ...
[13:37:46.313] result() for MulticoreFuture ... done
[13:37:46.313] result() for MulticoreFuture ...
[13:37:46.313] result() for MulticoreFuture ... done
[13:37:46.313] A MulticoreFuture was resolved
[13:37:46.313]  length: 2 (resolved future 2)
[13:37:46.314] Future #3
[13:37:46.314] result() for MulticoreFuture ...
[13:37:46.314] result() for MulticoreFuture ... done
[13:37:46.314] result() for MulticoreFuture ...
[13:37:46.314] result() for MulticoreFuture ... done
[13:37:46.314] A MulticoreFuture was resolved
[13:37:46.315]  length: 1 (resolved future 3)
[13:37:46.315]  length: 0 (resolved future 4)
[13:37:46.315] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multicore') ...
- plan('multisession') ...
[13:37:46.316] plan(): Setting new future strategy stack:
[13:37:46.316] List of future strategies:
[13:37:46.316] 1. multisession:
[13:37:46.316]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:37:46.316]    - tweaked: FALSE
[13:37:46.316]    - call: plan(strategy)
[13:37:46.316] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:37:46.316] multisession:
[13:37:46.316] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:37:46.316] - tweaked: FALSE
[13:37:46.316] - call: plan(strategy)
[13:37:46.324] getGlobalsAndPackages() ...
[13:37:46.324] Not searching for globals
[13:37:46.325] - globals: [0] <none>
[13:37:46.325] getGlobalsAndPackages() ... DONE
[13:37:46.325] [local output] makeClusterPSOCK() ...
[13:37:46.375] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:37:46.376] [local output] Base port: 11392
[13:37:46.376] [local output] Getting setup options for 2 cluster nodes ...
[13:37:46.376] [local output]  - Node 1 of 2 ...
[13:37:46.377] [local output] localMachine=TRUE => revtunnel=FALSE

[13:37:46.378] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpLAMaHJ/worker.rank=1.parallelly.parent=89256.15ca84f60a576.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpLAMaHJ/worker.rank=1.parallelly.parent=89256.15ca84f60a576.pid")'’
[13:37:46.570] - Possible to infer worker's PID: TRUE
[13:37:46.570] [local output] Rscript port: 11392

[13:37:46.571] [local output]  - Node 2 of 2 ...
[13:37:46.571] [local output] localMachine=TRUE => revtunnel=FALSE

[13:37:46.572] [local output] Rscript port: 11392

[13:37:46.572] [local output] Getting setup options for 2 cluster nodes ... done
[13:37:46.572] [local output]  - Parallel setup requested for some PSOCK nodes
[13:37:46.573] [local output] Setting up PSOCK nodes in parallel
[13:37:46.573] List of 36
[13:37:46.573]  $ worker          : chr "localhost"
[13:37:46.573]   ..- attr(*, "localhost")= logi TRUE
[13:37:46.573]  $ master          : chr "localhost"
[13:37:46.573]  $ port            : int 11392
[13:37:46.573]  $ connectTimeout  : num 120
[13:37:46.573]  $ timeout         : num 2592000
[13:37:46.573]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:37:46.573]  $ homogeneous     : logi TRUE
[13:37:46.573]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:37:46.573]  $ rscript_envs    : NULL
[13:37:46.573]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:37:46.573]  $ rscript_startup : NULL
[13:37:46.573]  $ rscript_sh      : chr "sh"
[13:37:46.573]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:37:46.573]  $ methods         : logi TRUE
[13:37:46.573]  $ socketOptions   : chr "no-delay"
[13:37:46.573]  $ useXDR          : logi FALSE
[13:37:46.573]  $ outfile         : chr "/dev/null"
[13:37:46.573]  $ renice          : int NA
[13:37:46.573]  $ rshcmd          : NULL
[13:37:46.573]  $ user            : chr(0) 
[13:37:46.573]  $ revtunnel       : logi FALSE
[13:37:46.573]  $ rshlogfile      : NULL
[13:37:46.573]  $ rshopts         : chr(0) 
[13:37:46.573]  $ rank            : int 1
[13:37:46.573]  $ manual          : logi FALSE
[13:37:46.573]  $ dryrun          : logi FALSE
[13:37:46.573]  $ quiet           : logi FALSE
[13:37:46.573]  $ setup_strategy  : chr "parallel"
[13:37:46.573]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:37:46.573]  $ pidfile         : chr "/tmp/RtmpLAMaHJ/worker.rank=1.parallelly.parent=89256.15ca84f60a576.pid"
[13:37:46.573]  $ rshcmd_label    : NULL
[13:37:46.573]  $ rsh_call        : NULL
[13:37:46.573]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:37:46.573]  $ localMachine    : logi TRUE
[13:37:46.573]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:37:46.573]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:37:46.573]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:37:46.573]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:37:46.573]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:37:46.573]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:37:46.573]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:37:46.573]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:37:46.573]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:37:46.573]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:37:46.573]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:37:46.573]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:37:46.573]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:37:46.573]  $ arguments       :List of 28
[13:37:46.573]   ..$ worker          : chr "localhost"
[13:37:46.573]   ..$ master          : NULL
[13:37:46.573]   ..$ port            : int 11392
[13:37:46.573]   ..$ connectTimeout  : num 120
[13:37:46.573]   ..$ timeout         : num 2592000
[13:37:46.573]   ..$ rscript         : NULL
[13:37:46.573]   ..$ homogeneous     : NULL
[13:37:46.573]   ..$ rscript_args    : NULL
[13:37:46.573]   ..$ rscript_envs    : NULL
[13:37:46.573]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:37:46.573]   ..$ rscript_startup : NULL
[13:37:46.573]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:37:46.573]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:37:46.573]   ..$ methods         : logi TRUE
[13:37:46.573]   ..$ socketOptions   : chr "no-delay"
[13:37:46.573]   ..$ useXDR          : logi FALSE
[13:37:46.573]   ..$ outfile         : chr "/dev/null"
[13:37:46.573]   ..$ renice          : int NA
[13:37:46.573]   ..$ rshcmd          : NULL
[13:37:46.573]   ..$ user            : NULL
[13:37:46.573]   ..$ revtunnel       : logi NA
[13:37:46.573]   ..$ rshlogfile      : NULL
[13:37:46.573]   ..$ rshopts         : NULL
[13:37:46.573]   ..$ rank            : int 1
[13:37:46.573]   ..$ manual          : logi FALSE
[13:37:46.573]   ..$ dryrun          : logi FALSE
[13:37:46.573]   ..$ quiet           : logi FALSE
[13:37:46.573]   ..$ setup_strategy  : chr "parallel"
[13:37:46.573]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:37:46.590] [local output] System call to launch all workers:
[13:37:46.590] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpLAMaHJ/worker.rank=1.parallelly.parent=89256.15ca84f60a576.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11392 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:37:46.590] [local output] Starting PSOCK main server
[13:37:46.596] [local output] Workers launched
[13:37:46.596] [local output] Waiting for workers to connect back
[13:37:46.596]  - [local output] 0 workers out of 2 ready
[13:37:46.857]  - [local output] 0 workers out of 2 ready
[13:37:46.858]  - [local output] 1 workers out of 2 ready
[13:37:46.858]  - [local output] 2 workers out of 2 ready
[13:37:46.858] [local output] Launching of workers completed
[13:37:46.858] [local output] Collecting session information from workers
[13:37:46.859] [local output]  - Worker #1 of 2
[13:37:46.860] [local output]  - Worker #2 of 2
[13:37:46.860] [local output] makeClusterPSOCK() ... done
[13:37:46.871] Packages needed by the future expression (n = 0): <none>
[13:37:46.872] Packages needed by future strategies (n = 0): <none>
[13:37:46.872] {
[13:37:46.872]     {
[13:37:46.872]         {
[13:37:46.872]             ...future.startTime <- base::Sys.time()
[13:37:46.872]             {
[13:37:46.872]                 {
[13:37:46.872]                   {
[13:37:46.872]                     {
[13:37:46.872]                       base::local({
[13:37:46.872]                         has_future <- base::requireNamespace("future", 
[13:37:46.872]                           quietly = TRUE)
[13:37:46.872]                         if (has_future) {
[13:37:46.872]                           ns <- base::getNamespace("future")
[13:37:46.872]                           version <- ns[[".package"]][["version"]]
[13:37:46.872]                           if (is.null(version)) 
[13:37:46.872]                             version <- utils::packageVersion("future")
[13:37:46.872]                         }
[13:37:46.872]                         else {
[13:37:46.872]                           version <- NULL
[13:37:46.872]                         }
[13:37:46.872]                         if (!has_future || version < "1.8.0") {
[13:37:46.872]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:46.872]                             "", base::R.version$version.string), 
[13:37:46.872]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:46.872]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:46.872]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:46.872]                               "release", "version")], collapse = " "), 
[13:37:46.872]                             hostname = base::Sys.info()[["nodename"]])
[13:37:46.872]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:46.872]                             info)
[13:37:46.872]                           info <- base::paste(info, collapse = "; ")
[13:37:46.872]                           if (!has_future) {
[13:37:46.872]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:46.872]                               info)
[13:37:46.872]                           }
[13:37:46.872]                           else {
[13:37:46.872]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:46.872]                               info, version)
[13:37:46.872]                           }
[13:37:46.872]                           base::stop(msg)
[13:37:46.872]                         }
[13:37:46.872]                       })
[13:37:46.872]                     }
[13:37:46.872]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:46.872]                     base::options(mc.cores = 1L)
[13:37:46.872]                   }
[13:37:46.872]                   ...future.strategy.old <- future::plan("list")
[13:37:46.872]                   options(future.plan = NULL)
[13:37:46.872]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:46.872]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:46.872]                 }
[13:37:46.872]                 ...future.workdir <- getwd()
[13:37:46.872]             }
[13:37:46.872]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:46.872]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:46.872]         }
[13:37:46.872]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:46.872]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:46.872]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:46.872]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:46.872]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:46.872]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:46.872]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:46.872]             base::names(...future.oldOptions))
[13:37:46.872]     }
[13:37:46.872]     if (FALSE) {
[13:37:46.872]     }
[13:37:46.872]     else {
[13:37:46.872]         if (TRUE) {
[13:37:46.872]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:46.872]                 open = "w")
[13:37:46.872]         }
[13:37:46.872]         else {
[13:37:46.872]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:46.872]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:46.872]         }
[13:37:46.872]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:46.872]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:46.872]             base::sink(type = "output", split = FALSE)
[13:37:46.872]             base::close(...future.stdout)
[13:37:46.872]         }, add = TRUE)
[13:37:46.872]     }
[13:37:46.872]     ...future.frame <- base::sys.nframe()
[13:37:46.872]     ...future.conditions <- base::list()
[13:37:46.872]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:46.872]     if (FALSE) {
[13:37:46.872]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:46.872]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:46.872]     }
[13:37:46.872]     ...future.result <- base::tryCatch({
[13:37:46.872]         base::withCallingHandlers({
[13:37:46.872]             ...future.value <- base::withVisible(base::local({
[13:37:46.872]                 ...future.makeSendCondition <- base::local({
[13:37:46.872]                   sendCondition <- NULL
[13:37:46.872]                   function(frame = 1L) {
[13:37:46.872]                     if (is.function(sendCondition)) 
[13:37:46.872]                       return(sendCondition)
[13:37:46.872]                     ns <- getNamespace("parallel")
[13:37:46.872]                     if (exists("sendData", mode = "function", 
[13:37:46.872]                       envir = ns)) {
[13:37:46.872]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:46.872]                         envir = ns)
[13:37:46.872]                       envir <- sys.frame(frame)
[13:37:46.872]                       master <- NULL
[13:37:46.872]                       while (!identical(envir, .GlobalEnv) && 
[13:37:46.872]                         !identical(envir, emptyenv())) {
[13:37:46.872]                         if (exists("master", mode = "list", envir = envir, 
[13:37:46.872]                           inherits = FALSE)) {
[13:37:46.872]                           master <- get("master", mode = "list", 
[13:37:46.872]                             envir = envir, inherits = FALSE)
[13:37:46.872]                           if (inherits(master, c("SOCKnode", 
[13:37:46.872]                             "SOCK0node"))) {
[13:37:46.872]                             sendCondition <<- function(cond) {
[13:37:46.872]                               data <- list(type = "VALUE", value = cond, 
[13:37:46.872]                                 success = TRUE)
[13:37:46.872]                               parallel_sendData(master, data)
[13:37:46.872]                             }
[13:37:46.872]                             return(sendCondition)
[13:37:46.872]                           }
[13:37:46.872]                         }
[13:37:46.872]                         frame <- frame + 1L
[13:37:46.872]                         envir <- sys.frame(frame)
[13:37:46.872]                       }
[13:37:46.872]                     }
[13:37:46.872]                     sendCondition <<- function(cond) NULL
[13:37:46.872]                   }
[13:37:46.872]                 })
[13:37:46.872]                 withCallingHandlers({
[13:37:46.872]                   NA
[13:37:46.872]                 }, immediateCondition = function(cond) {
[13:37:46.872]                   sendCondition <- ...future.makeSendCondition()
[13:37:46.872]                   sendCondition(cond)
[13:37:46.872]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:46.872]                   {
[13:37:46.872]                     inherits <- base::inherits
[13:37:46.872]                     invokeRestart <- base::invokeRestart
[13:37:46.872]                     is.null <- base::is.null
[13:37:46.872]                     muffled <- FALSE
[13:37:46.872]                     if (inherits(cond, "message")) {
[13:37:46.872]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:46.872]                       if (muffled) 
[13:37:46.872]                         invokeRestart("muffleMessage")
[13:37:46.872]                     }
[13:37:46.872]                     else if (inherits(cond, "warning")) {
[13:37:46.872]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:46.872]                       if (muffled) 
[13:37:46.872]                         invokeRestart("muffleWarning")
[13:37:46.872]                     }
[13:37:46.872]                     else if (inherits(cond, "condition")) {
[13:37:46.872]                       if (!is.null(pattern)) {
[13:37:46.872]                         computeRestarts <- base::computeRestarts
[13:37:46.872]                         grepl <- base::grepl
[13:37:46.872]                         restarts <- computeRestarts(cond)
[13:37:46.872]                         for (restart in restarts) {
[13:37:46.872]                           name <- restart$name
[13:37:46.872]                           if (is.null(name)) 
[13:37:46.872]                             next
[13:37:46.872]                           if (!grepl(pattern, name)) 
[13:37:46.872]                             next
[13:37:46.872]                           invokeRestart(restart)
[13:37:46.872]                           muffled <- TRUE
[13:37:46.872]                           break
[13:37:46.872]                         }
[13:37:46.872]                       }
[13:37:46.872]                     }
[13:37:46.872]                     invisible(muffled)
[13:37:46.872]                   }
[13:37:46.872]                   muffleCondition(cond)
[13:37:46.872]                 })
[13:37:46.872]             }))
[13:37:46.872]             future::FutureResult(value = ...future.value$value, 
[13:37:46.872]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:46.872]                   ...future.rng), globalenv = if (FALSE) 
[13:37:46.872]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:46.872]                     ...future.globalenv.names))
[13:37:46.872]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:46.872]         }, condition = base::local({
[13:37:46.872]             c <- base::c
[13:37:46.872]             inherits <- base::inherits
[13:37:46.872]             invokeRestart <- base::invokeRestart
[13:37:46.872]             length <- base::length
[13:37:46.872]             list <- base::list
[13:37:46.872]             seq.int <- base::seq.int
[13:37:46.872]             signalCondition <- base::signalCondition
[13:37:46.872]             sys.calls <- base::sys.calls
[13:37:46.872]             `[[` <- base::`[[`
[13:37:46.872]             `+` <- base::`+`
[13:37:46.872]             `<<-` <- base::`<<-`
[13:37:46.872]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:46.872]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:46.872]                   3L)]
[13:37:46.872]             }
[13:37:46.872]             function(cond) {
[13:37:46.872]                 is_error <- inherits(cond, "error")
[13:37:46.872]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:46.872]                   NULL)
[13:37:46.872]                 if (is_error) {
[13:37:46.872]                   sessionInformation <- function() {
[13:37:46.872]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:46.872]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:46.872]                       search = base::search(), system = base::Sys.info())
[13:37:46.872]                   }
[13:37:46.872]                   ...future.conditions[[length(...future.conditions) + 
[13:37:46.872]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:46.872]                     cond$call), session = sessionInformation(), 
[13:37:46.872]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:46.872]                   signalCondition(cond)
[13:37:46.872]                 }
[13:37:46.872]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:46.872]                 "immediateCondition"))) {
[13:37:46.872]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:46.872]                   ...future.conditions[[length(...future.conditions) + 
[13:37:46.872]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:46.872]                   if (TRUE && !signal) {
[13:37:46.872]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:46.872]                     {
[13:37:46.872]                       inherits <- base::inherits
[13:37:46.872]                       invokeRestart <- base::invokeRestart
[13:37:46.872]                       is.null <- base::is.null
[13:37:46.872]                       muffled <- FALSE
[13:37:46.872]                       if (inherits(cond, "message")) {
[13:37:46.872]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:46.872]                         if (muffled) 
[13:37:46.872]                           invokeRestart("muffleMessage")
[13:37:46.872]                       }
[13:37:46.872]                       else if (inherits(cond, "warning")) {
[13:37:46.872]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:46.872]                         if (muffled) 
[13:37:46.872]                           invokeRestart("muffleWarning")
[13:37:46.872]                       }
[13:37:46.872]                       else if (inherits(cond, "condition")) {
[13:37:46.872]                         if (!is.null(pattern)) {
[13:37:46.872]                           computeRestarts <- base::computeRestarts
[13:37:46.872]                           grepl <- base::grepl
[13:37:46.872]                           restarts <- computeRestarts(cond)
[13:37:46.872]                           for (restart in restarts) {
[13:37:46.872]                             name <- restart$name
[13:37:46.872]                             if (is.null(name)) 
[13:37:46.872]                               next
[13:37:46.872]                             if (!grepl(pattern, name)) 
[13:37:46.872]                               next
[13:37:46.872]                             invokeRestart(restart)
[13:37:46.872]                             muffled <- TRUE
[13:37:46.872]                             break
[13:37:46.872]                           }
[13:37:46.872]                         }
[13:37:46.872]                       }
[13:37:46.872]                       invisible(muffled)
[13:37:46.872]                     }
[13:37:46.872]                     muffleCondition(cond, pattern = "^muffle")
[13:37:46.872]                   }
[13:37:46.872]                 }
[13:37:46.872]                 else {
[13:37:46.872]                   if (TRUE) {
[13:37:46.872]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:46.872]                     {
[13:37:46.872]                       inherits <- base::inherits
[13:37:46.872]                       invokeRestart <- base::invokeRestart
[13:37:46.872]                       is.null <- base::is.null
[13:37:46.872]                       muffled <- FALSE
[13:37:46.872]                       if (inherits(cond, "message")) {
[13:37:46.872]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:46.872]                         if (muffled) 
[13:37:46.872]                           invokeRestart("muffleMessage")
[13:37:46.872]                       }
[13:37:46.872]                       else if (inherits(cond, "warning")) {
[13:37:46.872]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:46.872]                         if (muffled) 
[13:37:46.872]                           invokeRestart("muffleWarning")
[13:37:46.872]                       }
[13:37:46.872]                       else if (inherits(cond, "condition")) {
[13:37:46.872]                         if (!is.null(pattern)) {
[13:37:46.872]                           computeRestarts <- base::computeRestarts
[13:37:46.872]                           grepl <- base::grepl
[13:37:46.872]                           restarts <- computeRestarts(cond)
[13:37:46.872]                           for (restart in restarts) {
[13:37:46.872]                             name <- restart$name
[13:37:46.872]                             if (is.null(name)) 
[13:37:46.872]                               next
[13:37:46.872]                             if (!grepl(pattern, name)) 
[13:37:46.872]                               next
[13:37:46.872]                             invokeRestart(restart)
[13:37:46.872]                             muffled <- TRUE
[13:37:46.872]                             break
[13:37:46.872]                           }
[13:37:46.872]                         }
[13:37:46.872]                       }
[13:37:46.872]                       invisible(muffled)
[13:37:46.872]                     }
[13:37:46.872]                     muffleCondition(cond, pattern = "^muffle")
[13:37:46.872]                   }
[13:37:46.872]                 }
[13:37:46.872]             }
[13:37:46.872]         }))
[13:37:46.872]     }, error = function(ex) {
[13:37:46.872]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:46.872]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:46.872]                 ...future.rng), started = ...future.startTime, 
[13:37:46.872]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:46.872]             version = "1.8"), class = "FutureResult")
[13:37:46.872]     }, finally = {
[13:37:46.872]         if (!identical(...future.workdir, getwd())) 
[13:37:46.872]             setwd(...future.workdir)
[13:37:46.872]         {
[13:37:46.872]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:46.872]                 ...future.oldOptions$nwarnings <- NULL
[13:37:46.872]             }
[13:37:46.872]             base::options(...future.oldOptions)
[13:37:46.872]             if (.Platform$OS.type == "windows") {
[13:37:46.872]                 old_names <- names(...future.oldEnvVars)
[13:37:46.872]                 envs <- base::Sys.getenv()
[13:37:46.872]                 names <- names(envs)
[13:37:46.872]                 common <- intersect(names, old_names)
[13:37:46.872]                 added <- setdiff(names, old_names)
[13:37:46.872]                 removed <- setdiff(old_names, names)
[13:37:46.872]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:46.872]                   envs[common]]
[13:37:46.872]                 NAMES <- toupper(changed)
[13:37:46.872]                 args <- list()
[13:37:46.872]                 for (kk in seq_along(NAMES)) {
[13:37:46.872]                   name <- changed[[kk]]
[13:37:46.872]                   NAME <- NAMES[[kk]]
[13:37:46.872]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:46.872]                     next
[13:37:46.872]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:46.872]                 }
[13:37:46.872]                 NAMES <- toupper(added)
[13:37:46.872]                 for (kk in seq_along(NAMES)) {
[13:37:46.872]                   name <- added[[kk]]
[13:37:46.872]                   NAME <- NAMES[[kk]]
[13:37:46.872]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:46.872]                     next
[13:37:46.872]                   args[[name]] <- ""
[13:37:46.872]                 }
[13:37:46.872]                 NAMES <- toupper(removed)
[13:37:46.872]                 for (kk in seq_along(NAMES)) {
[13:37:46.872]                   name <- removed[[kk]]
[13:37:46.872]                   NAME <- NAMES[[kk]]
[13:37:46.872]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:46.872]                     next
[13:37:46.872]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:46.872]                 }
[13:37:46.872]                 if (length(args) > 0) 
[13:37:46.872]                   base::do.call(base::Sys.setenv, args = args)
[13:37:46.872]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:46.872]             }
[13:37:46.872]             else {
[13:37:46.872]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:46.872]             }
[13:37:46.872]             {
[13:37:46.872]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:46.872]                   0L) {
[13:37:46.872]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:46.872]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:46.872]                   base::options(opts)
[13:37:46.872]                 }
[13:37:46.872]                 {
[13:37:46.872]                   {
[13:37:46.872]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:46.872]                     NULL
[13:37:46.872]                   }
[13:37:46.872]                   options(future.plan = NULL)
[13:37:46.872]                   if (is.na(NA_character_)) 
[13:37:46.872]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:46.872]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:46.872]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:46.872]                     .init = FALSE)
[13:37:46.872]                 }
[13:37:46.872]             }
[13:37:46.872]         }
[13:37:46.872]     })
[13:37:46.872]     if (TRUE) {
[13:37:46.872]         base::sink(type = "output", split = FALSE)
[13:37:46.872]         if (TRUE) {
[13:37:46.872]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:46.872]         }
[13:37:46.872]         else {
[13:37:46.872]             ...future.result["stdout"] <- base::list(NULL)
[13:37:46.872]         }
[13:37:46.872]         base::close(...future.stdout)
[13:37:46.872]         ...future.stdout <- NULL
[13:37:46.872]     }
[13:37:46.872]     ...future.result$conditions <- ...future.conditions
[13:37:46.872]     ...future.result$finished <- base::Sys.time()
[13:37:46.872]     ...future.result
[13:37:46.872] }
[13:37:46.929] MultisessionFuture started
[13:37:46.929] result() for ClusterFuture ...
[13:37:46.930] receiveMessageFromWorker() for ClusterFuture ...
[13:37:46.931] - Validating connection of MultisessionFuture
[13:37:46.965] - received message: FutureResult
[13:37:46.965] - Received FutureResult
[13:37:46.966] - Erased future from FutureRegistry
[13:37:46.966] result() for ClusterFuture ...
[13:37:46.966] - result already collected: FutureResult
[13:37:46.966] result() for ClusterFuture ... done
[13:37:46.966] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:46.966] result() for ClusterFuture ... done
[13:37:46.966] result() for ClusterFuture ...
[13:37:46.966] - result already collected: FutureResult
[13:37:46.967] result() for ClusterFuture ... done
[13:37:46.967] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:37:46.971] plan(): nbrOfWorkers() = 2
*** resolve() for Future objects ...
- result = FALSE, recursive = FALSE ...
[13:37:46.975] getGlobalsAndPackages() ...
[13:37:46.975] Searching for globals...
[13:37:46.977] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:37:46.977] Searching for globals ... DONE
[13:37:46.977] Resolving globals: FALSE
[13:37:46.977] 
[13:37:46.977] 
[13:37:46.978] getGlobalsAndPackages() ... DONE
[13:37:46.978] run() for ‘Future’ ...
[13:37:46.978] - state: ‘created’
[13:37:46.978] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:46.993] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:46.994] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:46.994]   - Field: ‘node’
[13:37:46.994]   - Field: ‘label’
[13:37:46.994]   - Field: ‘local’
[13:37:46.994]   - Field: ‘owner’
[13:37:46.994]   - Field: ‘envir’
[13:37:46.994]   - Field: ‘workers’
[13:37:46.995]   - Field: ‘packages’
[13:37:46.995]   - Field: ‘gc’
[13:37:46.995]   - Field: ‘conditions’
[13:37:46.995]   - Field: ‘persistent’
[13:37:46.995]   - Field: ‘expr’
[13:37:46.995]   - Field: ‘uuid’
[13:37:46.995]   - Field: ‘seed’
[13:37:46.995]   - Field: ‘version’
[13:37:46.995]   - Field: ‘result’
[13:37:46.996]   - Field: ‘asynchronous’
[13:37:46.996]   - Field: ‘calls’
[13:37:46.996]   - Field: ‘globals’
[13:37:46.996]   - Field: ‘stdout’
[13:37:46.996]   - Field: ‘earlySignal’
[13:37:46.996]   - Field: ‘lazy’
[13:37:46.996]   - Field: ‘state’
[13:37:46.996] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:46.997] - Launch lazy future ...
[13:37:46.997] Packages needed by the future expression (n = 0): <none>
[13:37:46.997] Packages needed by future strategies (n = 0): <none>
[13:37:46.998] {
[13:37:46.998]     {
[13:37:46.998]         {
[13:37:46.998]             ...future.startTime <- base::Sys.time()
[13:37:46.998]             {
[13:37:46.998]                 {
[13:37:46.998]                   {
[13:37:46.998]                     {
[13:37:46.998]                       base::local({
[13:37:46.998]                         has_future <- base::requireNamespace("future", 
[13:37:46.998]                           quietly = TRUE)
[13:37:46.998]                         if (has_future) {
[13:37:46.998]                           ns <- base::getNamespace("future")
[13:37:46.998]                           version <- ns[[".package"]][["version"]]
[13:37:46.998]                           if (is.null(version)) 
[13:37:46.998]                             version <- utils::packageVersion("future")
[13:37:46.998]                         }
[13:37:46.998]                         else {
[13:37:46.998]                           version <- NULL
[13:37:46.998]                         }
[13:37:46.998]                         if (!has_future || version < "1.8.0") {
[13:37:46.998]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:46.998]                             "", base::R.version$version.string), 
[13:37:46.998]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:46.998]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:46.998]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:46.998]                               "release", "version")], collapse = " "), 
[13:37:46.998]                             hostname = base::Sys.info()[["nodename"]])
[13:37:46.998]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:46.998]                             info)
[13:37:46.998]                           info <- base::paste(info, collapse = "; ")
[13:37:46.998]                           if (!has_future) {
[13:37:46.998]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:46.998]                               info)
[13:37:46.998]                           }
[13:37:46.998]                           else {
[13:37:46.998]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:46.998]                               info, version)
[13:37:46.998]                           }
[13:37:46.998]                           base::stop(msg)
[13:37:46.998]                         }
[13:37:46.998]                       })
[13:37:46.998]                     }
[13:37:46.998]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:46.998]                     base::options(mc.cores = 1L)
[13:37:46.998]                   }
[13:37:46.998]                   ...future.strategy.old <- future::plan("list")
[13:37:46.998]                   options(future.plan = NULL)
[13:37:46.998]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:46.998]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:46.998]                 }
[13:37:46.998]                 ...future.workdir <- getwd()
[13:37:46.998]             }
[13:37:46.998]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:46.998]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:46.998]         }
[13:37:46.998]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:46.998]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:46.998]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:46.998]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:46.998]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:46.998]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:46.998]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:46.998]             base::names(...future.oldOptions))
[13:37:46.998]     }
[13:37:46.998]     if (FALSE) {
[13:37:46.998]     }
[13:37:46.998]     else {
[13:37:46.998]         if (TRUE) {
[13:37:46.998]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:46.998]                 open = "w")
[13:37:46.998]         }
[13:37:46.998]         else {
[13:37:46.998]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:46.998]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:46.998]         }
[13:37:46.998]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:46.998]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:46.998]             base::sink(type = "output", split = FALSE)
[13:37:46.998]             base::close(...future.stdout)
[13:37:46.998]         }, add = TRUE)
[13:37:46.998]     }
[13:37:46.998]     ...future.frame <- base::sys.nframe()
[13:37:46.998]     ...future.conditions <- base::list()
[13:37:46.998]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:46.998]     if (FALSE) {
[13:37:46.998]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:46.998]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:46.998]     }
[13:37:46.998]     ...future.result <- base::tryCatch({
[13:37:46.998]         base::withCallingHandlers({
[13:37:46.998]             ...future.value <- base::withVisible(base::local({
[13:37:46.998]                 ...future.makeSendCondition <- base::local({
[13:37:46.998]                   sendCondition <- NULL
[13:37:46.998]                   function(frame = 1L) {
[13:37:46.998]                     if (is.function(sendCondition)) 
[13:37:46.998]                       return(sendCondition)
[13:37:46.998]                     ns <- getNamespace("parallel")
[13:37:46.998]                     if (exists("sendData", mode = "function", 
[13:37:46.998]                       envir = ns)) {
[13:37:46.998]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:46.998]                         envir = ns)
[13:37:46.998]                       envir <- sys.frame(frame)
[13:37:46.998]                       master <- NULL
[13:37:46.998]                       while (!identical(envir, .GlobalEnv) && 
[13:37:46.998]                         !identical(envir, emptyenv())) {
[13:37:46.998]                         if (exists("master", mode = "list", envir = envir, 
[13:37:46.998]                           inherits = FALSE)) {
[13:37:46.998]                           master <- get("master", mode = "list", 
[13:37:46.998]                             envir = envir, inherits = FALSE)
[13:37:46.998]                           if (inherits(master, c("SOCKnode", 
[13:37:46.998]                             "SOCK0node"))) {
[13:37:46.998]                             sendCondition <<- function(cond) {
[13:37:46.998]                               data <- list(type = "VALUE", value = cond, 
[13:37:46.998]                                 success = TRUE)
[13:37:46.998]                               parallel_sendData(master, data)
[13:37:46.998]                             }
[13:37:46.998]                             return(sendCondition)
[13:37:46.998]                           }
[13:37:46.998]                         }
[13:37:46.998]                         frame <- frame + 1L
[13:37:46.998]                         envir <- sys.frame(frame)
[13:37:46.998]                       }
[13:37:46.998]                     }
[13:37:46.998]                     sendCondition <<- function(cond) NULL
[13:37:46.998]                   }
[13:37:46.998]                 })
[13:37:46.998]                 withCallingHandlers({
[13:37:46.998]                   {
[13:37:46.998]                     Sys.sleep(0.5)
[13:37:46.998]                     list(a = 1, b = 42L)
[13:37:46.998]                   }
[13:37:46.998]                 }, immediateCondition = function(cond) {
[13:37:46.998]                   sendCondition <- ...future.makeSendCondition()
[13:37:46.998]                   sendCondition(cond)
[13:37:46.998]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:46.998]                   {
[13:37:46.998]                     inherits <- base::inherits
[13:37:46.998]                     invokeRestart <- base::invokeRestart
[13:37:46.998]                     is.null <- base::is.null
[13:37:46.998]                     muffled <- FALSE
[13:37:46.998]                     if (inherits(cond, "message")) {
[13:37:46.998]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:46.998]                       if (muffled) 
[13:37:46.998]                         invokeRestart("muffleMessage")
[13:37:46.998]                     }
[13:37:46.998]                     else if (inherits(cond, "warning")) {
[13:37:46.998]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:46.998]                       if (muffled) 
[13:37:46.998]                         invokeRestart("muffleWarning")
[13:37:46.998]                     }
[13:37:46.998]                     else if (inherits(cond, "condition")) {
[13:37:46.998]                       if (!is.null(pattern)) {
[13:37:46.998]                         computeRestarts <- base::computeRestarts
[13:37:46.998]                         grepl <- base::grepl
[13:37:46.998]                         restarts <- computeRestarts(cond)
[13:37:46.998]                         for (restart in restarts) {
[13:37:46.998]                           name <- restart$name
[13:37:46.998]                           if (is.null(name)) 
[13:37:46.998]                             next
[13:37:46.998]                           if (!grepl(pattern, name)) 
[13:37:46.998]                             next
[13:37:46.998]                           invokeRestart(restart)
[13:37:46.998]                           muffled <- TRUE
[13:37:46.998]                           break
[13:37:46.998]                         }
[13:37:46.998]                       }
[13:37:46.998]                     }
[13:37:46.998]                     invisible(muffled)
[13:37:46.998]                   }
[13:37:46.998]                   muffleCondition(cond)
[13:37:46.998]                 })
[13:37:46.998]             }))
[13:37:46.998]             future::FutureResult(value = ...future.value$value, 
[13:37:46.998]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:46.998]                   ...future.rng), globalenv = if (FALSE) 
[13:37:46.998]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:46.998]                     ...future.globalenv.names))
[13:37:46.998]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:46.998]         }, condition = base::local({
[13:37:46.998]             c <- base::c
[13:37:46.998]             inherits <- base::inherits
[13:37:46.998]             invokeRestart <- base::invokeRestart
[13:37:46.998]             length <- base::length
[13:37:46.998]             list <- base::list
[13:37:46.998]             seq.int <- base::seq.int
[13:37:46.998]             signalCondition <- base::signalCondition
[13:37:46.998]             sys.calls <- base::sys.calls
[13:37:46.998]             `[[` <- base::`[[`
[13:37:46.998]             `+` <- base::`+`
[13:37:46.998]             `<<-` <- base::`<<-`
[13:37:46.998]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:46.998]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:46.998]                   3L)]
[13:37:46.998]             }
[13:37:46.998]             function(cond) {
[13:37:46.998]                 is_error <- inherits(cond, "error")
[13:37:46.998]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:46.998]                   NULL)
[13:37:46.998]                 if (is_error) {
[13:37:46.998]                   sessionInformation <- function() {
[13:37:46.998]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:46.998]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:46.998]                       search = base::search(), system = base::Sys.info())
[13:37:46.998]                   }
[13:37:46.998]                   ...future.conditions[[length(...future.conditions) + 
[13:37:46.998]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:46.998]                     cond$call), session = sessionInformation(), 
[13:37:46.998]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:46.998]                   signalCondition(cond)
[13:37:46.998]                 }
[13:37:46.998]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:46.998]                 "immediateCondition"))) {
[13:37:46.998]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:46.998]                   ...future.conditions[[length(...future.conditions) + 
[13:37:46.998]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:46.998]                   if (TRUE && !signal) {
[13:37:46.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:46.998]                     {
[13:37:46.998]                       inherits <- base::inherits
[13:37:46.998]                       invokeRestart <- base::invokeRestart
[13:37:46.998]                       is.null <- base::is.null
[13:37:46.998]                       muffled <- FALSE
[13:37:46.998]                       if (inherits(cond, "message")) {
[13:37:46.998]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:46.998]                         if (muffled) 
[13:37:46.998]                           invokeRestart("muffleMessage")
[13:37:46.998]                       }
[13:37:46.998]                       else if (inherits(cond, "warning")) {
[13:37:46.998]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:46.998]                         if (muffled) 
[13:37:46.998]                           invokeRestart("muffleWarning")
[13:37:46.998]                       }
[13:37:46.998]                       else if (inherits(cond, "condition")) {
[13:37:46.998]                         if (!is.null(pattern)) {
[13:37:46.998]                           computeRestarts <- base::computeRestarts
[13:37:46.998]                           grepl <- base::grepl
[13:37:46.998]                           restarts <- computeRestarts(cond)
[13:37:46.998]                           for (restart in restarts) {
[13:37:46.998]                             name <- restart$name
[13:37:46.998]                             if (is.null(name)) 
[13:37:46.998]                               next
[13:37:46.998]                             if (!grepl(pattern, name)) 
[13:37:46.998]                               next
[13:37:46.998]                             invokeRestart(restart)
[13:37:46.998]                             muffled <- TRUE
[13:37:46.998]                             break
[13:37:46.998]                           }
[13:37:46.998]                         }
[13:37:46.998]                       }
[13:37:46.998]                       invisible(muffled)
[13:37:46.998]                     }
[13:37:46.998]                     muffleCondition(cond, pattern = "^muffle")
[13:37:46.998]                   }
[13:37:46.998]                 }
[13:37:46.998]                 else {
[13:37:46.998]                   if (TRUE) {
[13:37:46.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:46.998]                     {
[13:37:46.998]                       inherits <- base::inherits
[13:37:46.998]                       invokeRestart <- base::invokeRestart
[13:37:46.998]                       is.null <- base::is.null
[13:37:46.998]                       muffled <- FALSE
[13:37:46.998]                       if (inherits(cond, "message")) {
[13:37:46.998]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:46.998]                         if (muffled) 
[13:37:46.998]                           invokeRestart("muffleMessage")
[13:37:46.998]                       }
[13:37:46.998]                       else if (inherits(cond, "warning")) {
[13:37:46.998]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:46.998]                         if (muffled) 
[13:37:46.998]                           invokeRestart("muffleWarning")
[13:37:46.998]                       }
[13:37:46.998]                       else if (inherits(cond, "condition")) {
[13:37:46.998]                         if (!is.null(pattern)) {
[13:37:46.998]                           computeRestarts <- base::computeRestarts
[13:37:46.998]                           grepl <- base::grepl
[13:37:46.998]                           restarts <- computeRestarts(cond)
[13:37:46.998]                           for (restart in restarts) {
[13:37:46.998]                             name <- restart$name
[13:37:46.998]                             if (is.null(name)) 
[13:37:46.998]                               next
[13:37:46.998]                             if (!grepl(pattern, name)) 
[13:37:46.998]                               next
[13:37:46.998]                             invokeRestart(restart)
[13:37:46.998]                             muffled <- TRUE
[13:37:46.998]                             break
[13:37:46.998]                           }
[13:37:46.998]                         }
[13:37:46.998]                       }
[13:37:46.998]                       invisible(muffled)
[13:37:46.998]                     }
[13:37:46.998]                     muffleCondition(cond, pattern = "^muffle")
[13:37:46.998]                   }
[13:37:46.998]                 }
[13:37:46.998]             }
[13:37:46.998]         }))
[13:37:46.998]     }, error = function(ex) {
[13:37:46.998]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:46.998]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:46.998]                 ...future.rng), started = ...future.startTime, 
[13:37:46.998]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:46.998]             version = "1.8"), class = "FutureResult")
[13:37:46.998]     }, finally = {
[13:37:46.998]         if (!identical(...future.workdir, getwd())) 
[13:37:46.998]             setwd(...future.workdir)
[13:37:46.998]         {
[13:37:46.998]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:46.998]                 ...future.oldOptions$nwarnings <- NULL
[13:37:46.998]             }
[13:37:46.998]             base::options(...future.oldOptions)
[13:37:46.998]             if (.Platform$OS.type == "windows") {
[13:37:46.998]                 old_names <- names(...future.oldEnvVars)
[13:37:46.998]                 envs <- base::Sys.getenv()
[13:37:46.998]                 names <- names(envs)
[13:37:46.998]                 common <- intersect(names, old_names)
[13:37:46.998]                 added <- setdiff(names, old_names)
[13:37:46.998]                 removed <- setdiff(old_names, names)
[13:37:46.998]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:46.998]                   envs[common]]
[13:37:46.998]                 NAMES <- toupper(changed)
[13:37:46.998]                 args <- list()
[13:37:46.998]                 for (kk in seq_along(NAMES)) {
[13:37:46.998]                   name <- changed[[kk]]
[13:37:46.998]                   NAME <- NAMES[[kk]]
[13:37:46.998]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:46.998]                     next
[13:37:46.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:46.998]                 }
[13:37:46.998]                 NAMES <- toupper(added)
[13:37:46.998]                 for (kk in seq_along(NAMES)) {
[13:37:46.998]                   name <- added[[kk]]
[13:37:46.998]                   NAME <- NAMES[[kk]]
[13:37:46.998]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:46.998]                     next
[13:37:46.998]                   args[[name]] <- ""
[13:37:46.998]                 }
[13:37:46.998]                 NAMES <- toupper(removed)
[13:37:46.998]                 for (kk in seq_along(NAMES)) {
[13:37:46.998]                   name <- removed[[kk]]
[13:37:46.998]                   NAME <- NAMES[[kk]]
[13:37:46.998]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:46.998]                     next
[13:37:46.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:46.998]                 }
[13:37:46.998]                 if (length(args) > 0) 
[13:37:46.998]                   base::do.call(base::Sys.setenv, args = args)
[13:37:46.998]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:46.998]             }
[13:37:46.998]             else {
[13:37:46.998]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:46.998]             }
[13:37:46.998]             {
[13:37:46.998]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:46.998]                   0L) {
[13:37:46.998]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:46.998]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:46.998]                   base::options(opts)
[13:37:46.998]                 }
[13:37:46.998]                 {
[13:37:46.998]                   {
[13:37:46.998]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:46.998]                     NULL
[13:37:46.998]                   }
[13:37:46.998]                   options(future.plan = NULL)
[13:37:46.998]                   if (is.na(NA_character_)) 
[13:37:46.998]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:46.998]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:46.998]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:46.998]                     .init = FALSE)
[13:37:46.998]                 }
[13:37:46.998]             }
[13:37:46.998]         }
[13:37:46.998]     })
[13:37:46.998]     if (TRUE) {
[13:37:46.998]         base::sink(type = "output", split = FALSE)
[13:37:46.998]         if (TRUE) {
[13:37:46.998]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:46.998]         }
[13:37:46.998]         else {
[13:37:46.998]             ...future.result["stdout"] <- base::list(NULL)
[13:37:46.998]         }
[13:37:46.998]         base::close(...future.stdout)
[13:37:46.998]         ...future.stdout <- NULL
[13:37:46.998]     }
[13:37:46.998]     ...future.result$conditions <- ...future.conditions
[13:37:46.998]     ...future.result$finished <- base::Sys.time()
[13:37:46.998]     ...future.result
[13:37:46.998] }
[13:37:47.001] MultisessionFuture started
[13:37:47.002] - Launch lazy future ... done
[13:37:47.002] run() for ‘MultisessionFuture’ ... done
[13:37:47.509] receiveMessageFromWorker() for ClusterFuture ...
[13:37:47.509] - Validating connection of MultisessionFuture
[13:37:47.509] - received message: FutureResult
[13:37:47.510] - Received FutureResult
[13:37:47.510] - Erased future from FutureRegistry
[13:37:47.510] result() for ClusterFuture ...
[13:37:47.510] - result already collected: FutureResult
[13:37:47.510] result() for ClusterFuture ... done
[13:37:47.510] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:47.510] A MultisessionFuture was resolved (result was not collected)
[13:37:47.511] getGlobalsAndPackages() ...
[13:37:47.511] Searching for globals...
[13:37:47.512] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:37:47.512] Searching for globals ... DONE
[13:37:47.512] Resolving globals: FALSE
[13:37:47.513] 
[13:37:47.513] 
[13:37:47.513] getGlobalsAndPackages() ... DONE
[13:37:47.513] run() for ‘Future’ ...
[13:37:47.514] - state: ‘created’
[13:37:47.514] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:47.529] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:47.529] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:47.529]   - Field: ‘node’
[13:37:47.529]   - Field: ‘label’
[13:37:47.529]   - Field: ‘local’
[13:37:47.529]   - Field: ‘owner’
[13:37:47.529]   - Field: ‘envir’
[13:37:47.529]   - Field: ‘workers’
[13:37:47.529]   - Field: ‘packages’
[13:37:47.529]   - Field: ‘gc’
[13:37:47.530]   - Field: ‘conditions’
[13:37:47.530]   - Field: ‘persistent’
[13:37:47.530]   - Field: ‘expr’
[13:37:47.530]   - Field: ‘uuid’
[13:37:47.530]   - Field: ‘seed’
[13:37:47.530]   - Field: ‘version’
[13:37:47.530]   - Field: ‘result’
[13:37:47.530]   - Field: ‘asynchronous’
[13:37:47.531]   - Field: ‘calls’
[13:37:47.531]   - Field: ‘globals’
[13:37:47.531]   - Field: ‘stdout’
[13:37:47.531]   - Field: ‘earlySignal’
[13:37:47.531]   - Field: ‘lazy’
[13:37:47.531]   - Field: ‘state’
[13:37:47.531] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:47.531] - Launch lazy future ...
[13:37:47.532] Packages needed by the future expression (n = 0): <none>
[13:37:47.532] Packages needed by future strategies (n = 0): <none>
[13:37:47.532] {
[13:37:47.532]     {
[13:37:47.532]         {
[13:37:47.532]             ...future.startTime <- base::Sys.time()
[13:37:47.532]             {
[13:37:47.532]                 {
[13:37:47.532]                   {
[13:37:47.532]                     {
[13:37:47.532]                       base::local({
[13:37:47.532]                         has_future <- base::requireNamespace("future", 
[13:37:47.532]                           quietly = TRUE)
[13:37:47.532]                         if (has_future) {
[13:37:47.532]                           ns <- base::getNamespace("future")
[13:37:47.532]                           version <- ns[[".package"]][["version"]]
[13:37:47.532]                           if (is.null(version)) 
[13:37:47.532]                             version <- utils::packageVersion("future")
[13:37:47.532]                         }
[13:37:47.532]                         else {
[13:37:47.532]                           version <- NULL
[13:37:47.532]                         }
[13:37:47.532]                         if (!has_future || version < "1.8.0") {
[13:37:47.532]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:47.532]                             "", base::R.version$version.string), 
[13:37:47.532]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:47.532]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:47.532]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:47.532]                               "release", "version")], collapse = " "), 
[13:37:47.532]                             hostname = base::Sys.info()[["nodename"]])
[13:37:47.532]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:47.532]                             info)
[13:37:47.532]                           info <- base::paste(info, collapse = "; ")
[13:37:47.532]                           if (!has_future) {
[13:37:47.532]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:47.532]                               info)
[13:37:47.532]                           }
[13:37:47.532]                           else {
[13:37:47.532]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:47.532]                               info, version)
[13:37:47.532]                           }
[13:37:47.532]                           base::stop(msg)
[13:37:47.532]                         }
[13:37:47.532]                       })
[13:37:47.532]                     }
[13:37:47.532]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:47.532]                     base::options(mc.cores = 1L)
[13:37:47.532]                   }
[13:37:47.532]                   ...future.strategy.old <- future::plan("list")
[13:37:47.532]                   options(future.plan = NULL)
[13:37:47.532]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:47.532]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:47.532]                 }
[13:37:47.532]                 ...future.workdir <- getwd()
[13:37:47.532]             }
[13:37:47.532]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:47.532]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:47.532]         }
[13:37:47.532]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:47.532]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:47.532]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:47.532]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:47.532]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:47.532]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:47.532]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:47.532]             base::names(...future.oldOptions))
[13:37:47.532]     }
[13:37:47.532]     if (FALSE) {
[13:37:47.532]     }
[13:37:47.532]     else {
[13:37:47.532]         if (TRUE) {
[13:37:47.532]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:47.532]                 open = "w")
[13:37:47.532]         }
[13:37:47.532]         else {
[13:37:47.532]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:47.532]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:47.532]         }
[13:37:47.532]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:47.532]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:47.532]             base::sink(type = "output", split = FALSE)
[13:37:47.532]             base::close(...future.stdout)
[13:37:47.532]         }, add = TRUE)
[13:37:47.532]     }
[13:37:47.532]     ...future.frame <- base::sys.nframe()
[13:37:47.532]     ...future.conditions <- base::list()
[13:37:47.532]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:47.532]     if (FALSE) {
[13:37:47.532]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:47.532]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:47.532]     }
[13:37:47.532]     ...future.result <- base::tryCatch({
[13:37:47.532]         base::withCallingHandlers({
[13:37:47.532]             ...future.value <- base::withVisible(base::local({
[13:37:47.532]                 ...future.makeSendCondition <- base::local({
[13:37:47.532]                   sendCondition <- NULL
[13:37:47.532]                   function(frame = 1L) {
[13:37:47.532]                     if (is.function(sendCondition)) 
[13:37:47.532]                       return(sendCondition)
[13:37:47.532]                     ns <- getNamespace("parallel")
[13:37:47.532]                     if (exists("sendData", mode = "function", 
[13:37:47.532]                       envir = ns)) {
[13:37:47.532]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:47.532]                         envir = ns)
[13:37:47.532]                       envir <- sys.frame(frame)
[13:37:47.532]                       master <- NULL
[13:37:47.532]                       while (!identical(envir, .GlobalEnv) && 
[13:37:47.532]                         !identical(envir, emptyenv())) {
[13:37:47.532]                         if (exists("master", mode = "list", envir = envir, 
[13:37:47.532]                           inherits = FALSE)) {
[13:37:47.532]                           master <- get("master", mode = "list", 
[13:37:47.532]                             envir = envir, inherits = FALSE)
[13:37:47.532]                           if (inherits(master, c("SOCKnode", 
[13:37:47.532]                             "SOCK0node"))) {
[13:37:47.532]                             sendCondition <<- function(cond) {
[13:37:47.532]                               data <- list(type = "VALUE", value = cond, 
[13:37:47.532]                                 success = TRUE)
[13:37:47.532]                               parallel_sendData(master, data)
[13:37:47.532]                             }
[13:37:47.532]                             return(sendCondition)
[13:37:47.532]                           }
[13:37:47.532]                         }
[13:37:47.532]                         frame <- frame + 1L
[13:37:47.532]                         envir <- sys.frame(frame)
[13:37:47.532]                       }
[13:37:47.532]                     }
[13:37:47.532]                     sendCondition <<- function(cond) NULL
[13:37:47.532]                   }
[13:37:47.532]                 })
[13:37:47.532]                 withCallingHandlers({
[13:37:47.532]                   {
[13:37:47.532]                     Sys.sleep(0.5)
[13:37:47.532]                     list(a = 1, b = 42L)
[13:37:47.532]                   }
[13:37:47.532]                 }, immediateCondition = function(cond) {
[13:37:47.532]                   sendCondition <- ...future.makeSendCondition()
[13:37:47.532]                   sendCondition(cond)
[13:37:47.532]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:47.532]                   {
[13:37:47.532]                     inherits <- base::inherits
[13:37:47.532]                     invokeRestart <- base::invokeRestart
[13:37:47.532]                     is.null <- base::is.null
[13:37:47.532]                     muffled <- FALSE
[13:37:47.532]                     if (inherits(cond, "message")) {
[13:37:47.532]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:47.532]                       if (muffled) 
[13:37:47.532]                         invokeRestart("muffleMessage")
[13:37:47.532]                     }
[13:37:47.532]                     else if (inherits(cond, "warning")) {
[13:37:47.532]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:47.532]                       if (muffled) 
[13:37:47.532]                         invokeRestart("muffleWarning")
[13:37:47.532]                     }
[13:37:47.532]                     else if (inherits(cond, "condition")) {
[13:37:47.532]                       if (!is.null(pattern)) {
[13:37:47.532]                         computeRestarts <- base::computeRestarts
[13:37:47.532]                         grepl <- base::grepl
[13:37:47.532]                         restarts <- computeRestarts(cond)
[13:37:47.532]                         for (restart in restarts) {
[13:37:47.532]                           name <- restart$name
[13:37:47.532]                           if (is.null(name)) 
[13:37:47.532]                             next
[13:37:47.532]                           if (!grepl(pattern, name)) 
[13:37:47.532]                             next
[13:37:47.532]                           invokeRestart(restart)
[13:37:47.532]                           muffled <- TRUE
[13:37:47.532]                           break
[13:37:47.532]                         }
[13:37:47.532]                       }
[13:37:47.532]                     }
[13:37:47.532]                     invisible(muffled)
[13:37:47.532]                   }
[13:37:47.532]                   muffleCondition(cond)
[13:37:47.532]                 })
[13:37:47.532]             }))
[13:37:47.532]             future::FutureResult(value = ...future.value$value, 
[13:37:47.532]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:47.532]                   ...future.rng), globalenv = if (FALSE) 
[13:37:47.532]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:47.532]                     ...future.globalenv.names))
[13:37:47.532]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:47.532]         }, condition = base::local({
[13:37:47.532]             c <- base::c
[13:37:47.532]             inherits <- base::inherits
[13:37:47.532]             invokeRestart <- base::invokeRestart
[13:37:47.532]             length <- base::length
[13:37:47.532]             list <- base::list
[13:37:47.532]             seq.int <- base::seq.int
[13:37:47.532]             signalCondition <- base::signalCondition
[13:37:47.532]             sys.calls <- base::sys.calls
[13:37:47.532]             `[[` <- base::`[[`
[13:37:47.532]             `+` <- base::`+`
[13:37:47.532]             `<<-` <- base::`<<-`
[13:37:47.532]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:47.532]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:47.532]                   3L)]
[13:37:47.532]             }
[13:37:47.532]             function(cond) {
[13:37:47.532]                 is_error <- inherits(cond, "error")
[13:37:47.532]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:47.532]                   NULL)
[13:37:47.532]                 if (is_error) {
[13:37:47.532]                   sessionInformation <- function() {
[13:37:47.532]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:47.532]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:47.532]                       search = base::search(), system = base::Sys.info())
[13:37:47.532]                   }
[13:37:47.532]                   ...future.conditions[[length(...future.conditions) + 
[13:37:47.532]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:47.532]                     cond$call), session = sessionInformation(), 
[13:37:47.532]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:47.532]                   signalCondition(cond)
[13:37:47.532]                 }
[13:37:47.532]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:47.532]                 "immediateCondition"))) {
[13:37:47.532]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:47.532]                   ...future.conditions[[length(...future.conditions) + 
[13:37:47.532]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:47.532]                   if (TRUE && !signal) {
[13:37:47.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:47.532]                     {
[13:37:47.532]                       inherits <- base::inherits
[13:37:47.532]                       invokeRestart <- base::invokeRestart
[13:37:47.532]                       is.null <- base::is.null
[13:37:47.532]                       muffled <- FALSE
[13:37:47.532]                       if (inherits(cond, "message")) {
[13:37:47.532]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:47.532]                         if (muffled) 
[13:37:47.532]                           invokeRestart("muffleMessage")
[13:37:47.532]                       }
[13:37:47.532]                       else if (inherits(cond, "warning")) {
[13:37:47.532]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:47.532]                         if (muffled) 
[13:37:47.532]                           invokeRestart("muffleWarning")
[13:37:47.532]                       }
[13:37:47.532]                       else if (inherits(cond, "condition")) {
[13:37:47.532]                         if (!is.null(pattern)) {
[13:37:47.532]                           computeRestarts <- base::computeRestarts
[13:37:47.532]                           grepl <- base::grepl
[13:37:47.532]                           restarts <- computeRestarts(cond)
[13:37:47.532]                           for (restart in restarts) {
[13:37:47.532]                             name <- restart$name
[13:37:47.532]                             if (is.null(name)) 
[13:37:47.532]                               next
[13:37:47.532]                             if (!grepl(pattern, name)) 
[13:37:47.532]                               next
[13:37:47.532]                             invokeRestart(restart)
[13:37:47.532]                             muffled <- TRUE
[13:37:47.532]                             break
[13:37:47.532]                           }
[13:37:47.532]                         }
[13:37:47.532]                       }
[13:37:47.532]                       invisible(muffled)
[13:37:47.532]                     }
[13:37:47.532]                     muffleCondition(cond, pattern = "^muffle")
[13:37:47.532]                   }
[13:37:47.532]                 }
[13:37:47.532]                 else {
[13:37:47.532]                   if (TRUE) {
[13:37:47.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:47.532]                     {
[13:37:47.532]                       inherits <- base::inherits
[13:37:47.532]                       invokeRestart <- base::invokeRestart
[13:37:47.532]                       is.null <- base::is.null
[13:37:47.532]                       muffled <- FALSE
[13:37:47.532]                       if (inherits(cond, "message")) {
[13:37:47.532]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:47.532]                         if (muffled) 
[13:37:47.532]                           invokeRestart("muffleMessage")
[13:37:47.532]                       }
[13:37:47.532]                       else if (inherits(cond, "warning")) {
[13:37:47.532]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:47.532]                         if (muffled) 
[13:37:47.532]                           invokeRestart("muffleWarning")
[13:37:47.532]                       }
[13:37:47.532]                       else if (inherits(cond, "condition")) {
[13:37:47.532]                         if (!is.null(pattern)) {
[13:37:47.532]                           computeRestarts <- base::computeRestarts
[13:37:47.532]                           grepl <- base::grepl
[13:37:47.532]                           restarts <- computeRestarts(cond)
[13:37:47.532]                           for (restart in restarts) {
[13:37:47.532]                             name <- restart$name
[13:37:47.532]                             if (is.null(name)) 
[13:37:47.532]                               next
[13:37:47.532]                             if (!grepl(pattern, name)) 
[13:37:47.532]                               next
[13:37:47.532]                             invokeRestart(restart)
[13:37:47.532]                             muffled <- TRUE
[13:37:47.532]                             break
[13:37:47.532]                           }
[13:37:47.532]                         }
[13:37:47.532]                       }
[13:37:47.532]                       invisible(muffled)
[13:37:47.532]                     }
[13:37:47.532]                     muffleCondition(cond, pattern = "^muffle")
[13:37:47.532]                   }
[13:37:47.532]                 }
[13:37:47.532]             }
[13:37:47.532]         }))
[13:37:47.532]     }, error = function(ex) {
[13:37:47.532]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:47.532]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:47.532]                 ...future.rng), started = ...future.startTime, 
[13:37:47.532]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:47.532]             version = "1.8"), class = "FutureResult")
[13:37:47.532]     }, finally = {
[13:37:47.532]         if (!identical(...future.workdir, getwd())) 
[13:37:47.532]             setwd(...future.workdir)
[13:37:47.532]         {
[13:37:47.532]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:47.532]                 ...future.oldOptions$nwarnings <- NULL
[13:37:47.532]             }
[13:37:47.532]             base::options(...future.oldOptions)
[13:37:47.532]             if (.Platform$OS.type == "windows") {
[13:37:47.532]                 old_names <- names(...future.oldEnvVars)
[13:37:47.532]                 envs <- base::Sys.getenv()
[13:37:47.532]                 names <- names(envs)
[13:37:47.532]                 common <- intersect(names, old_names)
[13:37:47.532]                 added <- setdiff(names, old_names)
[13:37:47.532]                 removed <- setdiff(old_names, names)
[13:37:47.532]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:47.532]                   envs[common]]
[13:37:47.532]                 NAMES <- toupper(changed)
[13:37:47.532]                 args <- list()
[13:37:47.532]                 for (kk in seq_along(NAMES)) {
[13:37:47.532]                   name <- changed[[kk]]
[13:37:47.532]                   NAME <- NAMES[[kk]]
[13:37:47.532]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:47.532]                     next
[13:37:47.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:47.532]                 }
[13:37:47.532]                 NAMES <- toupper(added)
[13:37:47.532]                 for (kk in seq_along(NAMES)) {
[13:37:47.532]                   name <- added[[kk]]
[13:37:47.532]                   NAME <- NAMES[[kk]]
[13:37:47.532]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:47.532]                     next
[13:37:47.532]                   args[[name]] <- ""
[13:37:47.532]                 }
[13:37:47.532]                 NAMES <- toupper(removed)
[13:37:47.532]                 for (kk in seq_along(NAMES)) {
[13:37:47.532]                   name <- removed[[kk]]
[13:37:47.532]                   NAME <- NAMES[[kk]]
[13:37:47.532]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:47.532]                     next
[13:37:47.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:47.532]                 }
[13:37:47.532]                 if (length(args) > 0) 
[13:37:47.532]                   base::do.call(base::Sys.setenv, args = args)
[13:37:47.532]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:47.532]             }
[13:37:47.532]             else {
[13:37:47.532]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:47.532]             }
[13:37:47.532]             {
[13:37:47.532]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:47.532]                   0L) {
[13:37:47.532]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:47.532]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:47.532]                   base::options(opts)
[13:37:47.532]                 }
[13:37:47.532]                 {
[13:37:47.532]                   {
[13:37:47.532]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:47.532]                     NULL
[13:37:47.532]                   }
[13:37:47.532]                   options(future.plan = NULL)
[13:37:47.532]                   if (is.na(NA_character_)) 
[13:37:47.532]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:47.532]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:47.532]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:47.532]                     .init = FALSE)
[13:37:47.532]                 }
[13:37:47.532]             }
[13:37:47.532]         }
[13:37:47.532]     })
[13:37:47.532]     if (TRUE) {
[13:37:47.532]         base::sink(type = "output", split = FALSE)
[13:37:47.532]         if (TRUE) {
[13:37:47.532]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:47.532]         }
[13:37:47.532]         else {
[13:37:47.532]             ...future.result["stdout"] <- base::list(NULL)
[13:37:47.532]         }
[13:37:47.532]         base::close(...future.stdout)
[13:37:47.532]         ...future.stdout <- NULL
[13:37:47.532]     }
[13:37:47.532]     ...future.result$conditions <- ...future.conditions
[13:37:47.532]     ...future.result$finished <- base::Sys.time()
[13:37:47.532]     ...future.result
[13:37:47.532] }
[13:37:47.536] MultisessionFuture started
[13:37:47.536] - Launch lazy future ... done
[13:37:47.536] run() for ‘MultisessionFuture’ ... done
[13:37:48.039] receiveMessageFromWorker() for ClusterFuture ...
[13:37:48.039] - Validating connection of MultisessionFuture
[13:37:48.040] - received message: FutureResult
[13:37:48.040] - Received FutureResult
[13:37:48.040] - Erased future from FutureRegistry
[13:37:48.040] result() for ClusterFuture ...
[13:37:48.040] - result already collected: FutureResult
[13:37:48.040] result() for ClusterFuture ... done
[13:37:48.040] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:48.041] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[13:37:48.041] getGlobalsAndPackages() ...
[13:37:48.041] Searching for globals...
[13:37:48.042] - globals found: [2] ‘list’, ‘stop’
[13:37:48.042] Searching for globals ... DONE
[13:37:48.042] Resolving globals: FALSE
[13:37:48.042] 
[13:37:48.043] 
[13:37:48.043] getGlobalsAndPackages() ... DONE
[13:37:48.043] run() for ‘Future’ ...
[13:37:48.043] - state: ‘created’
[13:37:48.043] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:48.061] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:48.061] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:48.061]   - Field: ‘node’
[13:37:48.061]   - Field: ‘label’
[13:37:48.061]   - Field: ‘local’
[13:37:48.061]   - Field: ‘owner’
[13:37:48.061]   - Field: ‘envir’
[13:37:48.061]   - Field: ‘workers’
[13:37:48.062]   - Field: ‘packages’
[13:37:48.062]   - Field: ‘gc’
[13:37:48.062]   - Field: ‘conditions’
[13:37:48.062]   - Field: ‘persistent’
[13:37:48.062]   - Field: ‘expr’
[13:37:48.062]   - Field: ‘uuid’
[13:37:48.062]   - Field: ‘seed’
[13:37:48.062]   - Field: ‘version’
[13:37:48.062]   - Field: ‘result’
[13:37:48.062]   - Field: ‘asynchronous’
[13:37:48.062]   - Field: ‘calls’
[13:37:48.063]   - Field: ‘globals’
[13:37:48.063]   - Field: ‘stdout’
[13:37:48.063]   - Field: ‘earlySignal’
[13:37:48.063]   - Field: ‘lazy’
[13:37:48.063]   - Field: ‘state’
[13:37:48.063] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:48.063] - Launch lazy future ...
[13:37:48.063] Packages needed by the future expression (n = 0): <none>
[13:37:48.064] Packages needed by future strategies (n = 0): <none>
[13:37:48.064] {
[13:37:48.064]     {
[13:37:48.064]         {
[13:37:48.064]             ...future.startTime <- base::Sys.time()
[13:37:48.064]             {
[13:37:48.064]                 {
[13:37:48.064]                   {
[13:37:48.064]                     {
[13:37:48.064]                       base::local({
[13:37:48.064]                         has_future <- base::requireNamespace("future", 
[13:37:48.064]                           quietly = TRUE)
[13:37:48.064]                         if (has_future) {
[13:37:48.064]                           ns <- base::getNamespace("future")
[13:37:48.064]                           version <- ns[[".package"]][["version"]]
[13:37:48.064]                           if (is.null(version)) 
[13:37:48.064]                             version <- utils::packageVersion("future")
[13:37:48.064]                         }
[13:37:48.064]                         else {
[13:37:48.064]                           version <- NULL
[13:37:48.064]                         }
[13:37:48.064]                         if (!has_future || version < "1.8.0") {
[13:37:48.064]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:48.064]                             "", base::R.version$version.string), 
[13:37:48.064]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:48.064]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:48.064]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:48.064]                               "release", "version")], collapse = " "), 
[13:37:48.064]                             hostname = base::Sys.info()[["nodename"]])
[13:37:48.064]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:48.064]                             info)
[13:37:48.064]                           info <- base::paste(info, collapse = "; ")
[13:37:48.064]                           if (!has_future) {
[13:37:48.064]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:48.064]                               info)
[13:37:48.064]                           }
[13:37:48.064]                           else {
[13:37:48.064]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:48.064]                               info, version)
[13:37:48.064]                           }
[13:37:48.064]                           base::stop(msg)
[13:37:48.064]                         }
[13:37:48.064]                       })
[13:37:48.064]                     }
[13:37:48.064]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:48.064]                     base::options(mc.cores = 1L)
[13:37:48.064]                   }
[13:37:48.064]                   ...future.strategy.old <- future::plan("list")
[13:37:48.064]                   options(future.plan = NULL)
[13:37:48.064]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:48.064]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:48.064]                 }
[13:37:48.064]                 ...future.workdir <- getwd()
[13:37:48.064]             }
[13:37:48.064]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:48.064]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:48.064]         }
[13:37:48.064]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:48.064]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:48.064]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:48.064]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:48.064]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:48.064]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:48.064]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:48.064]             base::names(...future.oldOptions))
[13:37:48.064]     }
[13:37:48.064]     if (FALSE) {
[13:37:48.064]     }
[13:37:48.064]     else {
[13:37:48.064]         if (TRUE) {
[13:37:48.064]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:48.064]                 open = "w")
[13:37:48.064]         }
[13:37:48.064]         else {
[13:37:48.064]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:48.064]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:48.064]         }
[13:37:48.064]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:48.064]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:48.064]             base::sink(type = "output", split = FALSE)
[13:37:48.064]             base::close(...future.stdout)
[13:37:48.064]         }, add = TRUE)
[13:37:48.064]     }
[13:37:48.064]     ...future.frame <- base::sys.nframe()
[13:37:48.064]     ...future.conditions <- base::list()
[13:37:48.064]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:48.064]     if (FALSE) {
[13:37:48.064]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:48.064]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:48.064]     }
[13:37:48.064]     ...future.result <- base::tryCatch({
[13:37:48.064]         base::withCallingHandlers({
[13:37:48.064]             ...future.value <- base::withVisible(base::local({
[13:37:48.064]                 ...future.makeSendCondition <- base::local({
[13:37:48.064]                   sendCondition <- NULL
[13:37:48.064]                   function(frame = 1L) {
[13:37:48.064]                     if (is.function(sendCondition)) 
[13:37:48.064]                       return(sendCondition)
[13:37:48.064]                     ns <- getNamespace("parallel")
[13:37:48.064]                     if (exists("sendData", mode = "function", 
[13:37:48.064]                       envir = ns)) {
[13:37:48.064]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:48.064]                         envir = ns)
[13:37:48.064]                       envir <- sys.frame(frame)
[13:37:48.064]                       master <- NULL
[13:37:48.064]                       while (!identical(envir, .GlobalEnv) && 
[13:37:48.064]                         !identical(envir, emptyenv())) {
[13:37:48.064]                         if (exists("master", mode = "list", envir = envir, 
[13:37:48.064]                           inherits = FALSE)) {
[13:37:48.064]                           master <- get("master", mode = "list", 
[13:37:48.064]                             envir = envir, inherits = FALSE)
[13:37:48.064]                           if (inherits(master, c("SOCKnode", 
[13:37:48.064]                             "SOCK0node"))) {
[13:37:48.064]                             sendCondition <<- function(cond) {
[13:37:48.064]                               data <- list(type = "VALUE", value = cond, 
[13:37:48.064]                                 success = TRUE)
[13:37:48.064]                               parallel_sendData(master, data)
[13:37:48.064]                             }
[13:37:48.064]                             return(sendCondition)
[13:37:48.064]                           }
[13:37:48.064]                         }
[13:37:48.064]                         frame <- frame + 1L
[13:37:48.064]                         envir <- sys.frame(frame)
[13:37:48.064]                       }
[13:37:48.064]                     }
[13:37:48.064]                     sendCondition <<- function(cond) NULL
[13:37:48.064]                   }
[13:37:48.064]                 })
[13:37:48.064]                 withCallingHandlers({
[13:37:48.064]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:37:48.064]                 }, immediateCondition = function(cond) {
[13:37:48.064]                   sendCondition <- ...future.makeSendCondition()
[13:37:48.064]                   sendCondition(cond)
[13:37:48.064]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:48.064]                   {
[13:37:48.064]                     inherits <- base::inherits
[13:37:48.064]                     invokeRestart <- base::invokeRestart
[13:37:48.064]                     is.null <- base::is.null
[13:37:48.064]                     muffled <- FALSE
[13:37:48.064]                     if (inherits(cond, "message")) {
[13:37:48.064]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:48.064]                       if (muffled) 
[13:37:48.064]                         invokeRestart("muffleMessage")
[13:37:48.064]                     }
[13:37:48.064]                     else if (inherits(cond, "warning")) {
[13:37:48.064]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:48.064]                       if (muffled) 
[13:37:48.064]                         invokeRestart("muffleWarning")
[13:37:48.064]                     }
[13:37:48.064]                     else if (inherits(cond, "condition")) {
[13:37:48.064]                       if (!is.null(pattern)) {
[13:37:48.064]                         computeRestarts <- base::computeRestarts
[13:37:48.064]                         grepl <- base::grepl
[13:37:48.064]                         restarts <- computeRestarts(cond)
[13:37:48.064]                         for (restart in restarts) {
[13:37:48.064]                           name <- restart$name
[13:37:48.064]                           if (is.null(name)) 
[13:37:48.064]                             next
[13:37:48.064]                           if (!grepl(pattern, name)) 
[13:37:48.064]                             next
[13:37:48.064]                           invokeRestart(restart)
[13:37:48.064]                           muffled <- TRUE
[13:37:48.064]                           break
[13:37:48.064]                         }
[13:37:48.064]                       }
[13:37:48.064]                     }
[13:37:48.064]                     invisible(muffled)
[13:37:48.064]                   }
[13:37:48.064]                   muffleCondition(cond)
[13:37:48.064]                 })
[13:37:48.064]             }))
[13:37:48.064]             future::FutureResult(value = ...future.value$value, 
[13:37:48.064]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:48.064]                   ...future.rng), globalenv = if (FALSE) 
[13:37:48.064]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:48.064]                     ...future.globalenv.names))
[13:37:48.064]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:48.064]         }, condition = base::local({
[13:37:48.064]             c <- base::c
[13:37:48.064]             inherits <- base::inherits
[13:37:48.064]             invokeRestart <- base::invokeRestart
[13:37:48.064]             length <- base::length
[13:37:48.064]             list <- base::list
[13:37:48.064]             seq.int <- base::seq.int
[13:37:48.064]             signalCondition <- base::signalCondition
[13:37:48.064]             sys.calls <- base::sys.calls
[13:37:48.064]             `[[` <- base::`[[`
[13:37:48.064]             `+` <- base::`+`
[13:37:48.064]             `<<-` <- base::`<<-`
[13:37:48.064]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:48.064]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:48.064]                   3L)]
[13:37:48.064]             }
[13:37:48.064]             function(cond) {
[13:37:48.064]                 is_error <- inherits(cond, "error")
[13:37:48.064]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:48.064]                   NULL)
[13:37:48.064]                 if (is_error) {
[13:37:48.064]                   sessionInformation <- function() {
[13:37:48.064]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:48.064]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:48.064]                       search = base::search(), system = base::Sys.info())
[13:37:48.064]                   }
[13:37:48.064]                   ...future.conditions[[length(...future.conditions) + 
[13:37:48.064]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:48.064]                     cond$call), session = sessionInformation(), 
[13:37:48.064]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:48.064]                   signalCondition(cond)
[13:37:48.064]                 }
[13:37:48.064]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:48.064]                 "immediateCondition"))) {
[13:37:48.064]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:48.064]                   ...future.conditions[[length(...future.conditions) + 
[13:37:48.064]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:48.064]                   if (TRUE && !signal) {
[13:37:48.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:48.064]                     {
[13:37:48.064]                       inherits <- base::inherits
[13:37:48.064]                       invokeRestart <- base::invokeRestart
[13:37:48.064]                       is.null <- base::is.null
[13:37:48.064]                       muffled <- FALSE
[13:37:48.064]                       if (inherits(cond, "message")) {
[13:37:48.064]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:48.064]                         if (muffled) 
[13:37:48.064]                           invokeRestart("muffleMessage")
[13:37:48.064]                       }
[13:37:48.064]                       else if (inherits(cond, "warning")) {
[13:37:48.064]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:48.064]                         if (muffled) 
[13:37:48.064]                           invokeRestart("muffleWarning")
[13:37:48.064]                       }
[13:37:48.064]                       else if (inherits(cond, "condition")) {
[13:37:48.064]                         if (!is.null(pattern)) {
[13:37:48.064]                           computeRestarts <- base::computeRestarts
[13:37:48.064]                           grepl <- base::grepl
[13:37:48.064]                           restarts <- computeRestarts(cond)
[13:37:48.064]                           for (restart in restarts) {
[13:37:48.064]                             name <- restart$name
[13:37:48.064]                             if (is.null(name)) 
[13:37:48.064]                               next
[13:37:48.064]                             if (!grepl(pattern, name)) 
[13:37:48.064]                               next
[13:37:48.064]                             invokeRestart(restart)
[13:37:48.064]                             muffled <- TRUE
[13:37:48.064]                             break
[13:37:48.064]                           }
[13:37:48.064]                         }
[13:37:48.064]                       }
[13:37:48.064]                       invisible(muffled)
[13:37:48.064]                     }
[13:37:48.064]                     muffleCondition(cond, pattern = "^muffle")
[13:37:48.064]                   }
[13:37:48.064]                 }
[13:37:48.064]                 else {
[13:37:48.064]                   if (TRUE) {
[13:37:48.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:48.064]                     {
[13:37:48.064]                       inherits <- base::inherits
[13:37:48.064]                       invokeRestart <- base::invokeRestart
[13:37:48.064]                       is.null <- base::is.null
[13:37:48.064]                       muffled <- FALSE
[13:37:48.064]                       if (inherits(cond, "message")) {
[13:37:48.064]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:48.064]                         if (muffled) 
[13:37:48.064]                           invokeRestart("muffleMessage")
[13:37:48.064]                       }
[13:37:48.064]                       else if (inherits(cond, "warning")) {
[13:37:48.064]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:48.064]                         if (muffled) 
[13:37:48.064]                           invokeRestart("muffleWarning")
[13:37:48.064]                       }
[13:37:48.064]                       else if (inherits(cond, "condition")) {
[13:37:48.064]                         if (!is.null(pattern)) {
[13:37:48.064]                           computeRestarts <- base::computeRestarts
[13:37:48.064]                           grepl <- base::grepl
[13:37:48.064]                           restarts <- computeRestarts(cond)
[13:37:48.064]                           for (restart in restarts) {
[13:37:48.064]                             name <- restart$name
[13:37:48.064]                             if (is.null(name)) 
[13:37:48.064]                               next
[13:37:48.064]                             if (!grepl(pattern, name)) 
[13:37:48.064]                               next
[13:37:48.064]                             invokeRestart(restart)
[13:37:48.064]                             muffled <- TRUE
[13:37:48.064]                             break
[13:37:48.064]                           }
[13:37:48.064]                         }
[13:37:48.064]                       }
[13:37:48.064]                       invisible(muffled)
[13:37:48.064]                     }
[13:37:48.064]                     muffleCondition(cond, pattern = "^muffle")
[13:37:48.064]                   }
[13:37:48.064]                 }
[13:37:48.064]             }
[13:37:48.064]         }))
[13:37:48.064]     }, error = function(ex) {
[13:37:48.064]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:48.064]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:48.064]                 ...future.rng), started = ...future.startTime, 
[13:37:48.064]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:48.064]             version = "1.8"), class = "FutureResult")
[13:37:48.064]     }, finally = {
[13:37:48.064]         if (!identical(...future.workdir, getwd())) 
[13:37:48.064]             setwd(...future.workdir)
[13:37:48.064]         {
[13:37:48.064]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:48.064]                 ...future.oldOptions$nwarnings <- NULL
[13:37:48.064]             }
[13:37:48.064]             base::options(...future.oldOptions)
[13:37:48.064]             if (.Platform$OS.type == "windows") {
[13:37:48.064]                 old_names <- names(...future.oldEnvVars)
[13:37:48.064]                 envs <- base::Sys.getenv()
[13:37:48.064]                 names <- names(envs)
[13:37:48.064]                 common <- intersect(names, old_names)
[13:37:48.064]                 added <- setdiff(names, old_names)
[13:37:48.064]                 removed <- setdiff(old_names, names)
[13:37:48.064]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:48.064]                   envs[common]]
[13:37:48.064]                 NAMES <- toupper(changed)
[13:37:48.064]                 args <- list()
[13:37:48.064]                 for (kk in seq_along(NAMES)) {
[13:37:48.064]                   name <- changed[[kk]]
[13:37:48.064]                   NAME <- NAMES[[kk]]
[13:37:48.064]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:48.064]                     next
[13:37:48.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:48.064]                 }
[13:37:48.064]                 NAMES <- toupper(added)
[13:37:48.064]                 for (kk in seq_along(NAMES)) {
[13:37:48.064]                   name <- added[[kk]]
[13:37:48.064]                   NAME <- NAMES[[kk]]
[13:37:48.064]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:48.064]                     next
[13:37:48.064]                   args[[name]] <- ""
[13:37:48.064]                 }
[13:37:48.064]                 NAMES <- toupper(removed)
[13:37:48.064]                 for (kk in seq_along(NAMES)) {
[13:37:48.064]                   name <- removed[[kk]]
[13:37:48.064]                   NAME <- NAMES[[kk]]
[13:37:48.064]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:48.064]                     next
[13:37:48.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:48.064]                 }
[13:37:48.064]                 if (length(args) > 0) 
[13:37:48.064]                   base::do.call(base::Sys.setenv, args = args)
[13:37:48.064]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:48.064]             }
[13:37:48.064]             else {
[13:37:48.064]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:48.064]             }
[13:37:48.064]             {
[13:37:48.064]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:48.064]                   0L) {
[13:37:48.064]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:48.064]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:48.064]                   base::options(opts)
[13:37:48.064]                 }
[13:37:48.064]                 {
[13:37:48.064]                   {
[13:37:48.064]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:48.064]                     NULL
[13:37:48.064]                   }
[13:37:48.064]                   options(future.plan = NULL)
[13:37:48.064]                   if (is.na(NA_character_)) 
[13:37:48.064]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:48.064]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:48.064]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:48.064]                     .init = FALSE)
[13:37:48.064]                 }
[13:37:48.064]             }
[13:37:48.064]         }
[13:37:48.064]     })
[13:37:48.064]     if (TRUE) {
[13:37:48.064]         base::sink(type = "output", split = FALSE)
[13:37:48.064]         if (TRUE) {
[13:37:48.064]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:48.064]         }
[13:37:48.064]         else {
[13:37:48.064]             ...future.result["stdout"] <- base::list(NULL)
[13:37:48.064]         }
[13:37:48.064]         base::close(...future.stdout)
[13:37:48.064]         ...future.stdout <- NULL
[13:37:48.064]     }
[13:37:48.064]     ...future.result$conditions <- ...future.conditions
[13:37:48.064]     ...future.result$finished <- base::Sys.time()
[13:37:48.064]     ...future.result
[13:37:48.064] }
[13:37:48.067] MultisessionFuture started
[13:37:48.067] - Launch lazy future ... done
[13:37:48.067] run() for ‘MultisessionFuture’ ... done
[13:37:48.069] receiveMessageFromWorker() for ClusterFuture ...
[13:37:48.070] - Validating connection of MultisessionFuture
[13:37:48.070] - received message: FutureResult
[13:37:48.070] - Received FutureResult
[13:37:48.070] - Erased future from FutureRegistry
[13:37:48.070] result() for ClusterFuture ...
[13:37:48.071] - result already collected: FutureResult
[13:37:48.071] result() for ClusterFuture ... done
[13:37:48.071] signalConditions() ...
[13:37:48.071]  - include = ‘immediateCondition’
[13:37:48.071]  - exclude = 
[13:37:48.071]  - resignal = FALSE
[13:37:48.071]  - Number of conditions: 1
[13:37:48.071] signalConditions() ... done
[13:37:48.071] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:48.071] A MultisessionFuture was resolved (result was not collected)
[13:37:48.071] getGlobalsAndPackages() ...
[13:37:48.072] Searching for globals...
[13:37:48.072] - globals found: [2] ‘list’, ‘stop’
[13:37:48.072] Searching for globals ... DONE
[13:37:48.072] Resolving globals: FALSE
[13:37:48.073] 
[13:37:48.073] 
[13:37:48.073] getGlobalsAndPackages() ... DONE
[13:37:48.073] run() for ‘Future’ ...
[13:37:48.073] - state: ‘created’
[13:37:48.073] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:48.087] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:48.088] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:48.088]   - Field: ‘node’
[13:37:48.088]   - Field: ‘label’
[13:37:48.088]   - Field: ‘local’
[13:37:48.088]   - Field: ‘owner’
[13:37:48.088]   - Field: ‘envir’
[13:37:48.088]   - Field: ‘workers’
[13:37:48.088]   - Field: ‘packages’
[13:37:48.088]   - Field: ‘gc’
[13:37:48.088]   - Field: ‘conditions’
[13:37:48.089]   - Field: ‘persistent’
[13:37:48.089]   - Field: ‘expr’
[13:37:48.089]   - Field: ‘uuid’
[13:37:48.089]   - Field: ‘seed’
[13:37:48.089]   - Field: ‘version’
[13:37:48.089]   - Field: ‘result’
[13:37:48.089]   - Field: ‘asynchronous’
[13:37:48.089]   - Field: ‘calls’
[13:37:48.089]   - Field: ‘globals’
[13:37:48.089]   - Field: ‘stdout’
[13:37:48.089]   - Field: ‘earlySignal’
[13:37:48.089]   - Field: ‘lazy’
[13:37:48.090]   - Field: ‘state’
[13:37:48.090] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:48.090] - Launch lazy future ...
[13:37:48.090] Packages needed by the future expression (n = 0): <none>
[13:37:48.090] Packages needed by future strategies (n = 0): <none>
[13:37:48.091] {
[13:37:48.091]     {
[13:37:48.091]         {
[13:37:48.091]             ...future.startTime <- base::Sys.time()
[13:37:48.091]             {
[13:37:48.091]                 {
[13:37:48.091]                   {
[13:37:48.091]                     {
[13:37:48.091]                       base::local({
[13:37:48.091]                         has_future <- base::requireNamespace("future", 
[13:37:48.091]                           quietly = TRUE)
[13:37:48.091]                         if (has_future) {
[13:37:48.091]                           ns <- base::getNamespace("future")
[13:37:48.091]                           version <- ns[[".package"]][["version"]]
[13:37:48.091]                           if (is.null(version)) 
[13:37:48.091]                             version <- utils::packageVersion("future")
[13:37:48.091]                         }
[13:37:48.091]                         else {
[13:37:48.091]                           version <- NULL
[13:37:48.091]                         }
[13:37:48.091]                         if (!has_future || version < "1.8.0") {
[13:37:48.091]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:48.091]                             "", base::R.version$version.string), 
[13:37:48.091]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:48.091]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:48.091]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:48.091]                               "release", "version")], collapse = " "), 
[13:37:48.091]                             hostname = base::Sys.info()[["nodename"]])
[13:37:48.091]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:48.091]                             info)
[13:37:48.091]                           info <- base::paste(info, collapse = "; ")
[13:37:48.091]                           if (!has_future) {
[13:37:48.091]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:48.091]                               info)
[13:37:48.091]                           }
[13:37:48.091]                           else {
[13:37:48.091]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:48.091]                               info, version)
[13:37:48.091]                           }
[13:37:48.091]                           base::stop(msg)
[13:37:48.091]                         }
[13:37:48.091]                       })
[13:37:48.091]                     }
[13:37:48.091]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:48.091]                     base::options(mc.cores = 1L)
[13:37:48.091]                   }
[13:37:48.091]                   ...future.strategy.old <- future::plan("list")
[13:37:48.091]                   options(future.plan = NULL)
[13:37:48.091]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:48.091]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:48.091]                 }
[13:37:48.091]                 ...future.workdir <- getwd()
[13:37:48.091]             }
[13:37:48.091]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:48.091]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:48.091]         }
[13:37:48.091]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:48.091]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:48.091]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:48.091]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:48.091]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:48.091]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:48.091]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:48.091]             base::names(...future.oldOptions))
[13:37:48.091]     }
[13:37:48.091]     if (FALSE) {
[13:37:48.091]     }
[13:37:48.091]     else {
[13:37:48.091]         if (TRUE) {
[13:37:48.091]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:48.091]                 open = "w")
[13:37:48.091]         }
[13:37:48.091]         else {
[13:37:48.091]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:48.091]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:48.091]         }
[13:37:48.091]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:48.091]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:48.091]             base::sink(type = "output", split = FALSE)
[13:37:48.091]             base::close(...future.stdout)
[13:37:48.091]         }, add = TRUE)
[13:37:48.091]     }
[13:37:48.091]     ...future.frame <- base::sys.nframe()
[13:37:48.091]     ...future.conditions <- base::list()
[13:37:48.091]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:48.091]     if (FALSE) {
[13:37:48.091]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:48.091]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:48.091]     }
[13:37:48.091]     ...future.result <- base::tryCatch({
[13:37:48.091]         base::withCallingHandlers({
[13:37:48.091]             ...future.value <- base::withVisible(base::local({
[13:37:48.091]                 ...future.makeSendCondition <- base::local({
[13:37:48.091]                   sendCondition <- NULL
[13:37:48.091]                   function(frame = 1L) {
[13:37:48.091]                     if (is.function(sendCondition)) 
[13:37:48.091]                       return(sendCondition)
[13:37:48.091]                     ns <- getNamespace("parallel")
[13:37:48.091]                     if (exists("sendData", mode = "function", 
[13:37:48.091]                       envir = ns)) {
[13:37:48.091]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:48.091]                         envir = ns)
[13:37:48.091]                       envir <- sys.frame(frame)
[13:37:48.091]                       master <- NULL
[13:37:48.091]                       while (!identical(envir, .GlobalEnv) && 
[13:37:48.091]                         !identical(envir, emptyenv())) {
[13:37:48.091]                         if (exists("master", mode = "list", envir = envir, 
[13:37:48.091]                           inherits = FALSE)) {
[13:37:48.091]                           master <- get("master", mode = "list", 
[13:37:48.091]                             envir = envir, inherits = FALSE)
[13:37:48.091]                           if (inherits(master, c("SOCKnode", 
[13:37:48.091]                             "SOCK0node"))) {
[13:37:48.091]                             sendCondition <<- function(cond) {
[13:37:48.091]                               data <- list(type = "VALUE", value = cond, 
[13:37:48.091]                                 success = TRUE)
[13:37:48.091]                               parallel_sendData(master, data)
[13:37:48.091]                             }
[13:37:48.091]                             return(sendCondition)
[13:37:48.091]                           }
[13:37:48.091]                         }
[13:37:48.091]                         frame <- frame + 1L
[13:37:48.091]                         envir <- sys.frame(frame)
[13:37:48.091]                       }
[13:37:48.091]                     }
[13:37:48.091]                     sendCondition <<- function(cond) NULL
[13:37:48.091]                   }
[13:37:48.091]                 })
[13:37:48.091]                 withCallingHandlers({
[13:37:48.091]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:37:48.091]                 }, immediateCondition = function(cond) {
[13:37:48.091]                   sendCondition <- ...future.makeSendCondition()
[13:37:48.091]                   sendCondition(cond)
[13:37:48.091]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:48.091]                   {
[13:37:48.091]                     inherits <- base::inherits
[13:37:48.091]                     invokeRestart <- base::invokeRestart
[13:37:48.091]                     is.null <- base::is.null
[13:37:48.091]                     muffled <- FALSE
[13:37:48.091]                     if (inherits(cond, "message")) {
[13:37:48.091]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:48.091]                       if (muffled) 
[13:37:48.091]                         invokeRestart("muffleMessage")
[13:37:48.091]                     }
[13:37:48.091]                     else if (inherits(cond, "warning")) {
[13:37:48.091]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:48.091]                       if (muffled) 
[13:37:48.091]                         invokeRestart("muffleWarning")
[13:37:48.091]                     }
[13:37:48.091]                     else if (inherits(cond, "condition")) {
[13:37:48.091]                       if (!is.null(pattern)) {
[13:37:48.091]                         computeRestarts <- base::computeRestarts
[13:37:48.091]                         grepl <- base::grepl
[13:37:48.091]                         restarts <- computeRestarts(cond)
[13:37:48.091]                         for (restart in restarts) {
[13:37:48.091]                           name <- restart$name
[13:37:48.091]                           if (is.null(name)) 
[13:37:48.091]                             next
[13:37:48.091]                           if (!grepl(pattern, name)) 
[13:37:48.091]                             next
[13:37:48.091]                           invokeRestart(restart)
[13:37:48.091]                           muffled <- TRUE
[13:37:48.091]                           break
[13:37:48.091]                         }
[13:37:48.091]                       }
[13:37:48.091]                     }
[13:37:48.091]                     invisible(muffled)
[13:37:48.091]                   }
[13:37:48.091]                   muffleCondition(cond)
[13:37:48.091]                 })
[13:37:48.091]             }))
[13:37:48.091]             future::FutureResult(value = ...future.value$value, 
[13:37:48.091]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:48.091]                   ...future.rng), globalenv = if (FALSE) 
[13:37:48.091]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:48.091]                     ...future.globalenv.names))
[13:37:48.091]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:48.091]         }, condition = base::local({
[13:37:48.091]             c <- base::c
[13:37:48.091]             inherits <- base::inherits
[13:37:48.091]             invokeRestart <- base::invokeRestart
[13:37:48.091]             length <- base::length
[13:37:48.091]             list <- base::list
[13:37:48.091]             seq.int <- base::seq.int
[13:37:48.091]             signalCondition <- base::signalCondition
[13:37:48.091]             sys.calls <- base::sys.calls
[13:37:48.091]             `[[` <- base::`[[`
[13:37:48.091]             `+` <- base::`+`
[13:37:48.091]             `<<-` <- base::`<<-`
[13:37:48.091]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:48.091]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:48.091]                   3L)]
[13:37:48.091]             }
[13:37:48.091]             function(cond) {
[13:37:48.091]                 is_error <- inherits(cond, "error")
[13:37:48.091]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:48.091]                   NULL)
[13:37:48.091]                 if (is_error) {
[13:37:48.091]                   sessionInformation <- function() {
[13:37:48.091]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:48.091]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:48.091]                       search = base::search(), system = base::Sys.info())
[13:37:48.091]                   }
[13:37:48.091]                   ...future.conditions[[length(...future.conditions) + 
[13:37:48.091]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:48.091]                     cond$call), session = sessionInformation(), 
[13:37:48.091]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:48.091]                   signalCondition(cond)
[13:37:48.091]                 }
[13:37:48.091]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:48.091]                 "immediateCondition"))) {
[13:37:48.091]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:48.091]                   ...future.conditions[[length(...future.conditions) + 
[13:37:48.091]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:48.091]                   if (TRUE && !signal) {
[13:37:48.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:48.091]                     {
[13:37:48.091]                       inherits <- base::inherits
[13:37:48.091]                       invokeRestart <- base::invokeRestart
[13:37:48.091]                       is.null <- base::is.null
[13:37:48.091]                       muffled <- FALSE
[13:37:48.091]                       if (inherits(cond, "message")) {
[13:37:48.091]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:48.091]                         if (muffled) 
[13:37:48.091]                           invokeRestart("muffleMessage")
[13:37:48.091]                       }
[13:37:48.091]                       else if (inherits(cond, "warning")) {
[13:37:48.091]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:48.091]                         if (muffled) 
[13:37:48.091]                           invokeRestart("muffleWarning")
[13:37:48.091]                       }
[13:37:48.091]                       else if (inherits(cond, "condition")) {
[13:37:48.091]                         if (!is.null(pattern)) {
[13:37:48.091]                           computeRestarts <- base::computeRestarts
[13:37:48.091]                           grepl <- base::grepl
[13:37:48.091]                           restarts <- computeRestarts(cond)
[13:37:48.091]                           for (restart in restarts) {
[13:37:48.091]                             name <- restart$name
[13:37:48.091]                             if (is.null(name)) 
[13:37:48.091]                               next
[13:37:48.091]                             if (!grepl(pattern, name)) 
[13:37:48.091]                               next
[13:37:48.091]                             invokeRestart(restart)
[13:37:48.091]                             muffled <- TRUE
[13:37:48.091]                             break
[13:37:48.091]                           }
[13:37:48.091]                         }
[13:37:48.091]                       }
[13:37:48.091]                       invisible(muffled)
[13:37:48.091]                     }
[13:37:48.091]                     muffleCondition(cond, pattern = "^muffle")
[13:37:48.091]                   }
[13:37:48.091]                 }
[13:37:48.091]                 else {
[13:37:48.091]                   if (TRUE) {
[13:37:48.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:48.091]                     {
[13:37:48.091]                       inherits <- base::inherits
[13:37:48.091]                       invokeRestart <- base::invokeRestart
[13:37:48.091]                       is.null <- base::is.null
[13:37:48.091]                       muffled <- FALSE
[13:37:48.091]                       if (inherits(cond, "message")) {
[13:37:48.091]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:48.091]                         if (muffled) 
[13:37:48.091]                           invokeRestart("muffleMessage")
[13:37:48.091]                       }
[13:37:48.091]                       else if (inherits(cond, "warning")) {
[13:37:48.091]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:48.091]                         if (muffled) 
[13:37:48.091]                           invokeRestart("muffleWarning")
[13:37:48.091]                       }
[13:37:48.091]                       else if (inherits(cond, "condition")) {
[13:37:48.091]                         if (!is.null(pattern)) {
[13:37:48.091]                           computeRestarts <- base::computeRestarts
[13:37:48.091]                           grepl <- base::grepl
[13:37:48.091]                           restarts <- computeRestarts(cond)
[13:37:48.091]                           for (restart in restarts) {
[13:37:48.091]                             name <- restart$name
[13:37:48.091]                             if (is.null(name)) 
[13:37:48.091]                               next
[13:37:48.091]                             if (!grepl(pattern, name)) 
[13:37:48.091]                               next
[13:37:48.091]                             invokeRestart(restart)
[13:37:48.091]                             muffled <- TRUE
[13:37:48.091]                             break
[13:37:48.091]                           }
[13:37:48.091]                         }
[13:37:48.091]                       }
[13:37:48.091]                       invisible(muffled)
[13:37:48.091]                     }
[13:37:48.091]                     muffleCondition(cond, pattern = "^muffle")
[13:37:48.091]                   }
[13:37:48.091]                 }
[13:37:48.091]             }
[13:37:48.091]         }))
[13:37:48.091]     }, error = function(ex) {
[13:37:48.091]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:48.091]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:48.091]                 ...future.rng), started = ...future.startTime, 
[13:37:48.091]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:48.091]             version = "1.8"), class = "FutureResult")
[13:37:48.091]     }, finally = {
[13:37:48.091]         if (!identical(...future.workdir, getwd())) 
[13:37:48.091]             setwd(...future.workdir)
[13:37:48.091]         {
[13:37:48.091]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:48.091]                 ...future.oldOptions$nwarnings <- NULL
[13:37:48.091]             }
[13:37:48.091]             base::options(...future.oldOptions)
[13:37:48.091]             if (.Platform$OS.type == "windows") {
[13:37:48.091]                 old_names <- names(...future.oldEnvVars)
[13:37:48.091]                 envs <- base::Sys.getenv()
[13:37:48.091]                 names <- names(envs)
[13:37:48.091]                 common <- intersect(names, old_names)
[13:37:48.091]                 added <- setdiff(names, old_names)
[13:37:48.091]                 removed <- setdiff(old_names, names)
[13:37:48.091]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:48.091]                   envs[common]]
[13:37:48.091]                 NAMES <- toupper(changed)
[13:37:48.091]                 args <- list()
[13:37:48.091]                 for (kk in seq_along(NAMES)) {
[13:37:48.091]                   name <- changed[[kk]]
[13:37:48.091]                   NAME <- NAMES[[kk]]
[13:37:48.091]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:48.091]                     next
[13:37:48.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:48.091]                 }
[13:37:48.091]                 NAMES <- toupper(added)
[13:37:48.091]                 for (kk in seq_along(NAMES)) {
[13:37:48.091]                   name <- added[[kk]]
[13:37:48.091]                   NAME <- NAMES[[kk]]
[13:37:48.091]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:48.091]                     next
[13:37:48.091]                   args[[name]] <- ""
[13:37:48.091]                 }
[13:37:48.091]                 NAMES <- toupper(removed)
[13:37:48.091]                 for (kk in seq_along(NAMES)) {
[13:37:48.091]                   name <- removed[[kk]]
[13:37:48.091]                   NAME <- NAMES[[kk]]
[13:37:48.091]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:48.091]                     next
[13:37:48.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:48.091]                 }
[13:37:48.091]                 if (length(args) > 0) 
[13:37:48.091]                   base::do.call(base::Sys.setenv, args = args)
[13:37:48.091]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:48.091]             }
[13:37:48.091]             else {
[13:37:48.091]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:48.091]             }
[13:37:48.091]             {
[13:37:48.091]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:48.091]                   0L) {
[13:37:48.091]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:48.091]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:48.091]                   base::options(opts)
[13:37:48.091]                 }
[13:37:48.091]                 {
[13:37:48.091]                   {
[13:37:48.091]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:48.091]                     NULL
[13:37:48.091]                   }
[13:37:48.091]                   options(future.plan = NULL)
[13:37:48.091]                   if (is.na(NA_character_)) 
[13:37:48.091]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:48.091]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:48.091]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:48.091]                     .init = FALSE)
[13:37:48.091]                 }
[13:37:48.091]             }
[13:37:48.091]         }
[13:37:48.091]     })
[13:37:48.091]     if (TRUE) {
[13:37:48.091]         base::sink(type = "output", split = FALSE)
[13:37:48.091]         if (TRUE) {
[13:37:48.091]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:48.091]         }
[13:37:48.091]         else {
[13:37:48.091]             ...future.result["stdout"] <- base::list(NULL)
[13:37:48.091]         }
[13:37:48.091]         base::close(...future.stdout)
[13:37:48.091]         ...future.stdout <- NULL
[13:37:48.091]     }
[13:37:48.091]     ...future.result$conditions <- ...future.conditions
[13:37:48.091]     ...future.result$finished <- base::Sys.time()
[13:37:48.091]     ...future.result
[13:37:48.091] }
[13:37:48.094] MultisessionFuture started
[13:37:48.094] - Launch lazy future ... done
[13:37:48.094] run() for ‘MultisessionFuture’ ... done
[13:37:48.096] receiveMessageFromWorker() for ClusterFuture ...
[13:37:48.096] - Validating connection of MultisessionFuture
[13:37:48.097] - received message: FutureResult
[13:37:48.097] - Received FutureResult
[13:37:48.097] - Erased future from FutureRegistry
[13:37:48.097] result() for ClusterFuture ...
[13:37:48.097] - result already collected: FutureResult
[13:37:48.097] result() for ClusterFuture ... done
[13:37:48.098] signalConditions() ...
[13:37:48.098]  - include = ‘immediateCondition’
[13:37:48.098]  - exclude = 
[13:37:48.098]  - resignal = FALSE
[13:37:48.098]  - Number of conditions: 1
[13:37:48.098] signalConditions() ... done
[13:37:48.098] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:48.098] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = FALSE ... DONE
- result = FALSE, recursive = TRUE ...
[13:37:48.099] getGlobalsAndPackages() ...
[13:37:48.099] Searching for globals...
[13:37:48.100] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:37:48.100] Searching for globals ... DONE
[13:37:48.100] Resolving globals: FALSE
[13:37:48.100] 
[13:37:48.100] 
[13:37:48.101] getGlobalsAndPackages() ... DONE
[13:37:48.101] run() for ‘Future’ ...
[13:37:48.101] - state: ‘created’
[13:37:48.101] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:48.117] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:48.117] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:48.117]   - Field: ‘node’
[13:37:48.117]   - Field: ‘label’
[13:37:48.118]   - Field: ‘local’
[13:37:48.118]   - Field: ‘owner’
[13:37:48.118]   - Field: ‘envir’
[13:37:48.118]   - Field: ‘workers’
[13:37:48.118]   - Field: ‘packages’
[13:37:48.118]   - Field: ‘gc’
[13:37:48.118]   - Field: ‘conditions’
[13:37:48.118]   - Field: ‘persistent’
[13:37:48.118]   - Field: ‘expr’
[13:37:48.118]   - Field: ‘uuid’
[13:37:48.119]   - Field: ‘seed’
[13:37:48.119]   - Field: ‘version’
[13:37:48.119]   - Field: ‘result’
[13:37:48.119]   - Field: ‘asynchronous’
[13:37:48.119]   - Field: ‘calls’
[13:37:48.119]   - Field: ‘globals’
[13:37:48.119]   - Field: ‘stdout’
[13:37:48.119]   - Field: ‘earlySignal’
[13:37:48.119]   - Field: ‘lazy’
[13:37:48.119]   - Field: ‘state’
[13:37:48.120] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:48.120] - Launch lazy future ...
[13:37:48.120] Packages needed by the future expression (n = 0): <none>
[13:37:48.120] Packages needed by future strategies (n = 0): <none>
[13:37:48.121] {
[13:37:48.121]     {
[13:37:48.121]         {
[13:37:48.121]             ...future.startTime <- base::Sys.time()
[13:37:48.121]             {
[13:37:48.121]                 {
[13:37:48.121]                   {
[13:37:48.121]                     {
[13:37:48.121]                       base::local({
[13:37:48.121]                         has_future <- base::requireNamespace("future", 
[13:37:48.121]                           quietly = TRUE)
[13:37:48.121]                         if (has_future) {
[13:37:48.121]                           ns <- base::getNamespace("future")
[13:37:48.121]                           version <- ns[[".package"]][["version"]]
[13:37:48.121]                           if (is.null(version)) 
[13:37:48.121]                             version <- utils::packageVersion("future")
[13:37:48.121]                         }
[13:37:48.121]                         else {
[13:37:48.121]                           version <- NULL
[13:37:48.121]                         }
[13:37:48.121]                         if (!has_future || version < "1.8.0") {
[13:37:48.121]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:48.121]                             "", base::R.version$version.string), 
[13:37:48.121]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:48.121]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:48.121]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:48.121]                               "release", "version")], collapse = " "), 
[13:37:48.121]                             hostname = base::Sys.info()[["nodename"]])
[13:37:48.121]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:48.121]                             info)
[13:37:48.121]                           info <- base::paste(info, collapse = "; ")
[13:37:48.121]                           if (!has_future) {
[13:37:48.121]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:48.121]                               info)
[13:37:48.121]                           }
[13:37:48.121]                           else {
[13:37:48.121]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:48.121]                               info, version)
[13:37:48.121]                           }
[13:37:48.121]                           base::stop(msg)
[13:37:48.121]                         }
[13:37:48.121]                       })
[13:37:48.121]                     }
[13:37:48.121]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:48.121]                     base::options(mc.cores = 1L)
[13:37:48.121]                   }
[13:37:48.121]                   ...future.strategy.old <- future::plan("list")
[13:37:48.121]                   options(future.plan = NULL)
[13:37:48.121]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:48.121]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:48.121]                 }
[13:37:48.121]                 ...future.workdir <- getwd()
[13:37:48.121]             }
[13:37:48.121]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:48.121]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:48.121]         }
[13:37:48.121]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:48.121]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:48.121]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:48.121]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:48.121]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:48.121]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:48.121]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:48.121]             base::names(...future.oldOptions))
[13:37:48.121]     }
[13:37:48.121]     if (FALSE) {
[13:37:48.121]     }
[13:37:48.121]     else {
[13:37:48.121]         if (TRUE) {
[13:37:48.121]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:48.121]                 open = "w")
[13:37:48.121]         }
[13:37:48.121]         else {
[13:37:48.121]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:48.121]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:48.121]         }
[13:37:48.121]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:48.121]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:48.121]             base::sink(type = "output", split = FALSE)
[13:37:48.121]             base::close(...future.stdout)
[13:37:48.121]         }, add = TRUE)
[13:37:48.121]     }
[13:37:48.121]     ...future.frame <- base::sys.nframe()
[13:37:48.121]     ...future.conditions <- base::list()
[13:37:48.121]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:48.121]     if (FALSE) {
[13:37:48.121]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:48.121]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:48.121]     }
[13:37:48.121]     ...future.result <- base::tryCatch({
[13:37:48.121]         base::withCallingHandlers({
[13:37:48.121]             ...future.value <- base::withVisible(base::local({
[13:37:48.121]                 ...future.makeSendCondition <- base::local({
[13:37:48.121]                   sendCondition <- NULL
[13:37:48.121]                   function(frame = 1L) {
[13:37:48.121]                     if (is.function(sendCondition)) 
[13:37:48.121]                       return(sendCondition)
[13:37:48.121]                     ns <- getNamespace("parallel")
[13:37:48.121]                     if (exists("sendData", mode = "function", 
[13:37:48.121]                       envir = ns)) {
[13:37:48.121]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:48.121]                         envir = ns)
[13:37:48.121]                       envir <- sys.frame(frame)
[13:37:48.121]                       master <- NULL
[13:37:48.121]                       while (!identical(envir, .GlobalEnv) && 
[13:37:48.121]                         !identical(envir, emptyenv())) {
[13:37:48.121]                         if (exists("master", mode = "list", envir = envir, 
[13:37:48.121]                           inherits = FALSE)) {
[13:37:48.121]                           master <- get("master", mode = "list", 
[13:37:48.121]                             envir = envir, inherits = FALSE)
[13:37:48.121]                           if (inherits(master, c("SOCKnode", 
[13:37:48.121]                             "SOCK0node"))) {
[13:37:48.121]                             sendCondition <<- function(cond) {
[13:37:48.121]                               data <- list(type = "VALUE", value = cond, 
[13:37:48.121]                                 success = TRUE)
[13:37:48.121]                               parallel_sendData(master, data)
[13:37:48.121]                             }
[13:37:48.121]                             return(sendCondition)
[13:37:48.121]                           }
[13:37:48.121]                         }
[13:37:48.121]                         frame <- frame + 1L
[13:37:48.121]                         envir <- sys.frame(frame)
[13:37:48.121]                       }
[13:37:48.121]                     }
[13:37:48.121]                     sendCondition <<- function(cond) NULL
[13:37:48.121]                   }
[13:37:48.121]                 })
[13:37:48.121]                 withCallingHandlers({
[13:37:48.121]                   {
[13:37:48.121]                     Sys.sleep(0.5)
[13:37:48.121]                     list(a = 1, b = 42L)
[13:37:48.121]                   }
[13:37:48.121]                 }, immediateCondition = function(cond) {
[13:37:48.121]                   sendCondition <- ...future.makeSendCondition()
[13:37:48.121]                   sendCondition(cond)
[13:37:48.121]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:48.121]                   {
[13:37:48.121]                     inherits <- base::inherits
[13:37:48.121]                     invokeRestart <- base::invokeRestart
[13:37:48.121]                     is.null <- base::is.null
[13:37:48.121]                     muffled <- FALSE
[13:37:48.121]                     if (inherits(cond, "message")) {
[13:37:48.121]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:48.121]                       if (muffled) 
[13:37:48.121]                         invokeRestart("muffleMessage")
[13:37:48.121]                     }
[13:37:48.121]                     else if (inherits(cond, "warning")) {
[13:37:48.121]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:48.121]                       if (muffled) 
[13:37:48.121]                         invokeRestart("muffleWarning")
[13:37:48.121]                     }
[13:37:48.121]                     else if (inherits(cond, "condition")) {
[13:37:48.121]                       if (!is.null(pattern)) {
[13:37:48.121]                         computeRestarts <- base::computeRestarts
[13:37:48.121]                         grepl <- base::grepl
[13:37:48.121]                         restarts <- computeRestarts(cond)
[13:37:48.121]                         for (restart in restarts) {
[13:37:48.121]                           name <- restart$name
[13:37:48.121]                           if (is.null(name)) 
[13:37:48.121]                             next
[13:37:48.121]                           if (!grepl(pattern, name)) 
[13:37:48.121]                             next
[13:37:48.121]                           invokeRestart(restart)
[13:37:48.121]                           muffled <- TRUE
[13:37:48.121]                           break
[13:37:48.121]                         }
[13:37:48.121]                       }
[13:37:48.121]                     }
[13:37:48.121]                     invisible(muffled)
[13:37:48.121]                   }
[13:37:48.121]                   muffleCondition(cond)
[13:37:48.121]                 })
[13:37:48.121]             }))
[13:37:48.121]             future::FutureResult(value = ...future.value$value, 
[13:37:48.121]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:48.121]                   ...future.rng), globalenv = if (FALSE) 
[13:37:48.121]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:48.121]                     ...future.globalenv.names))
[13:37:48.121]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:48.121]         }, condition = base::local({
[13:37:48.121]             c <- base::c
[13:37:48.121]             inherits <- base::inherits
[13:37:48.121]             invokeRestart <- base::invokeRestart
[13:37:48.121]             length <- base::length
[13:37:48.121]             list <- base::list
[13:37:48.121]             seq.int <- base::seq.int
[13:37:48.121]             signalCondition <- base::signalCondition
[13:37:48.121]             sys.calls <- base::sys.calls
[13:37:48.121]             `[[` <- base::`[[`
[13:37:48.121]             `+` <- base::`+`
[13:37:48.121]             `<<-` <- base::`<<-`
[13:37:48.121]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:48.121]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:48.121]                   3L)]
[13:37:48.121]             }
[13:37:48.121]             function(cond) {
[13:37:48.121]                 is_error <- inherits(cond, "error")
[13:37:48.121]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:48.121]                   NULL)
[13:37:48.121]                 if (is_error) {
[13:37:48.121]                   sessionInformation <- function() {
[13:37:48.121]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:48.121]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:48.121]                       search = base::search(), system = base::Sys.info())
[13:37:48.121]                   }
[13:37:48.121]                   ...future.conditions[[length(...future.conditions) + 
[13:37:48.121]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:48.121]                     cond$call), session = sessionInformation(), 
[13:37:48.121]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:48.121]                   signalCondition(cond)
[13:37:48.121]                 }
[13:37:48.121]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:48.121]                 "immediateCondition"))) {
[13:37:48.121]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:48.121]                   ...future.conditions[[length(...future.conditions) + 
[13:37:48.121]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:48.121]                   if (TRUE && !signal) {
[13:37:48.121]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:48.121]                     {
[13:37:48.121]                       inherits <- base::inherits
[13:37:48.121]                       invokeRestart <- base::invokeRestart
[13:37:48.121]                       is.null <- base::is.null
[13:37:48.121]                       muffled <- FALSE
[13:37:48.121]                       if (inherits(cond, "message")) {
[13:37:48.121]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:48.121]                         if (muffled) 
[13:37:48.121]                           invokeRestart("muffleMessage")
[13:37:48.121]                       }
[13:37:48.121]                       else if (inherits(cond, "warning")) {
[13:37:48.121]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:48.121]                         if (muffled) 
[13:37:48.121]                           invokeRestart("muffleWarning")
[13:37:48.121]                       }
[13:37:48.121]                       else if (inherits(cond, "condition")) {
[13:37:48.121]                         if (!is.null(pattern)) {
[13:37:48.121]                           computeRestarts <- base::computeRestarts
[13:37:48.121]                           grepl <- base::grepl
[13:37:48.121]                           restarts <- computeRestarts(cond)
[13:37:48.121]                           for (restart in restarts) {
[13:37:48.121]                             name <- restart$name
[13:37:48.121]                             if (is.null(name)) 
[13:37:48.121]                               next
[13:37:48.121]                             if (!grepl(pattern, name)) 
[13:37:48.121]                               next
[13:37:48.121]                             invokeRestart(restart)
[13:37:48.121]                             muffled <- TRUE
[13:37:48.121]                             break
[13:37:48.121]                           }
[13:37:48.121]                         }
[13:37:48.121]                       }
[13:37:48.121]                       invisible(muffled)
[13:37:48.121]                     }
[13:37:48.121]                     muffleCondition(cond, pattern = "^muffle")
[13:37:48.121]                   }
[13:37:48.121]                 }
[13:37:48.121]                 else {
[13:37:48.121]                   if (TRUE) {
[13:37:48.121]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:48.121]                     {
[13:37:48.121]                       inherits <- base::inherits
[13:37:48.121]                       invokeRestart <- base::invokeRestart
[13:37:48.121]                       is.null <- base::is.null
[13:37:48.121]                       muffled <- FALSE
[13:37:48.121]                       if (inherits(cond, "message")) {
[13:37:48.121]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:48.121]                         if (muffled) 
[13:37:48.121]                           invokeRestart("muffleMessage")
[13:37:48.121]                       }
[13:37:48.121]                       else if (inherits(cond, "warning")) {
[13:37:48.121]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:48.121]                         if (muffled) 
[13:37:48.121]                           invokeRestart("muffleWarning")
[13:37:48.121]                       }
[13:37:48.121]                       else if (inherits(cond, "condition")) {
[13:37:48.121]                         if (!is.null(pattern)) {
[13:37:48.121]                           computeRestarts <- base::computeRestarts
[13:37:48.121]                           grepl <- base::grepl
[13:37:48.121]                           restarts <- computeRestarts(cond)
[13:37:48.121]                           for (restart in restarts) {
[13:37:48.121]                             name <- restart$name
[13:37:48.121]                             if (is.null(name)) 
[13:37:48.121]                               next
[13:37:48.121]                             if (!grepl(pattern, name)) 
[13:37:48.121]                               next
[13:37:48.121]                             invokeRestart(restart)
[13:37:48.121]                             muffled <- TRUE
[13:37:48.121]                             break
[13:37:48.121]                           }
[13:37:48.121]                         }
[13:37:48.121]                       }
[13:37:48.121]                       invisible(muffled)
[13:37:48.121]                     }
[13:37:48.121]                     muffleCondition(cond, pattern = "^muffle")
[13:37:48.121]                   }
[13:37:48.121]                 }
[13:37:48.121]             }
[13:37:48.121]         }))
[13:37:48.121]     }, error = function(ex) {
[13:37:48.121]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:48.121]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:48.121]                 ...future.rng), started = ...future.startTime, 
[13:37:48.121]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:48.121]             version = "1.8"), class = "FutureResult")
[13:37:48.121]     }, finally = {
[13:37:48.121]         if (!identical(...future.workdir, getwd())) 
[13:37:48.121]             setwd(...future.workdir)
[13:37:48.121]         {
[13:37:48.121]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:48.121]                 ...future.oldOptions$nwarnings <- NULL
[13:37:48.121]             }
[13:37:48.121]             base::options(...future.oldOptions)
[13:37:48.121]             if (.Platform$OS.type == "windows") {
[13:37:48.121]                 old_names <- names(...future.oldEnvVars)
[13:37:48.121]                 envs <- base::Sys.getenv()
[13:37:48.121]                 names <- names(envs)
[13:37:48.121]                 common <- intersect(names, old_names)
[13:37:48.121]                 added <- setdiff(names, old_names)
[13:37:48.121]                 removed <- setdiff(old_names, names)
[13:37:48.121]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:48.121]                   envs[common]]
[13:37:48.121]                 NAMES <- toupper(changed)
[13:37:48.121]                 args <- list()
[13:37:48.121]                 for (kk in seq_along(NAMES)) {
[13:37:48.121]                   name <- changed[[kk]]
[13:37:48.121]                   NAME <- NAMES[[kk]]
[13:37:48.121]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:48.121]                     next
[13:37:48.121]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:48.121]                 }
[13:37:48.121]                 NAMES <- toupper(added)
[13:37:48.121]                 for (kk in seq_along(NAMES)) {
[13:37:48.121]                   name <- added[[kk]]
[13:37:48.121]                   NAME <- NAMES[[kk]]
[13:37:48.121]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:48.121]                     next
[13:37:48.121]                   args[[name]] <- ""
[13:37:48.121]                 }
[13:37:48.121]                 NAMES <- toupper(removed)
[13:37:48.121]                 for (kk in seq_along(NAMES)) {
[13:37:48.121]                   name <- removed[[kk]]
[13:37:48.121]                   NAME <- NAMES[[kk]]
[13:37:48.121]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:48.121]                     next
[13:37:48.121]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:48.121]                 }
[13:37:48.121]                 if (length(args) > 0) 
[13:37:48.121]                   base::do.call(base::Sys.setenv, args = args)
[13:37:48.121]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:48.121]             }
[13:37:48.121]             else {
[13:37:48.121]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:48.121]             }
[13:37:48.121]             {
[13:37:48.121]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:48.121]                   0L) {
[13:37:48.121]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:48.121]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:48.121]                   base::options(opts)
[13:37:48.121]                 }
[13:37:48.121]                 {
[13:37:48.121]                   {
[13:37:48.121]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:48.121]                     NULL
[13:37:48.121]                   }
[13:37:48.121]                   options(future.plan = NULL)
[13:37:48.121]                   if (is.na(NA_character_)) 
[13:37:48.121]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:48.121]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:48.121]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:48.121]                     .init = FALSE)
[13:37:48.121]                 }
[13:37:48.121]             }
[13:37:48.121]         }
[13:37:48.121]     })
[13:37:48.121]     if (TRUE) {
[13:37:48.121]         base::sink(type = "output", split = FALSE)
[13:37:48.121]         if (TRUE) {
[13:37:48.121]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:48.121]         }
[13:37:48.121]         else {
[13:37:48.121]             ...future.result["stdout"] <- base::list(NULL)
[13:37:48.121]         }
[13:37:48.121]         base::close(...future.stdout)
[13:37:48.121]         ...future.stdout <- NULL
[13:37:48.121]     }
[13:37:48.121]     ...future.result$conditions <- ...future.conditions
[13:37:48.121]     ...future.result$finished <- base::Sys.time()
[13:37:48.121]     ...future.result
[13:37:48.121] }
[13:37:48.124] MultisessionFuture started
[13:37:48.124] - Launch lazy future ... done
[13:37:48.124] run() for ‘MultisessionFuture’ ... done
[13:37:48.627] receiveMessageFromWorker() for ClusterFuture ...
[13:37:48.627] - Validating connection of MultisessionFuture
[13:37:48.627] - received message: FutureResult
[13:37:48.627] - Received FutureResult
[13:37:48.627] - Erased future from FutureRegistry
[13:37:48.627] result() for ClusterFuture ...
[13:37:48.628] - result already collected: FutureResult
[13:37:48.628] result() for ClusterFuture ... done
[13:37:48.628] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:48.628] A MultisessionFuture was resolved (result was not collected)
[13:37:48.628] getGlobalsAndPackages() ...
[13:37:48.628] Searching for globals...
[13:37:48.629] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:37:48.629] Searching for globals ... DONE
[13:37:48.630] Resolving globals: FALSE
[13:37:48.630] 
[13:37:48.630] 
[13:37:48.630] getGlobalsAndPackages() ... DONE
[13:37:48.630] run() for ‘Future’ ...
[13:37:48.630] - state: ‘created’
[13:37:48.631] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:48.644] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:48.645] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:48.645]   - Field: ‘node’
[13:37:48.645]   - Field: ‘label’
[13:37:48.645]   - Field: ‘local’
[13:37:48.645]   - Field: ‘owner’
[13:37:48.645]   - Field: ‘envir’
[13:37:48.645]   - Field: ‘workers’
[13:37:48.645]   - Field: ‘packages’
[13:37:48.645]   - Field: ‘gc’
[13:37:48.646]   - Field: ‘conditions’
[13:37:48.646]   - Field: ‘persistent’
[13:37:48.646]   - Field: ‘expr’
[13:37:48.646]   - Field: ‘uuid’
[13:37:48.646]   - Field: ‘seed’
[13:37:48.646]   - Field: ‘version’
[13:37:48.646]   - Field: ‘result’
[13:37:48.646]   - Field: ‘asynchronous’
[13:37:48.646]   - Field: ‘calls’
[13:37:48.646]   - Field: ‘globals’
[13:37:48.646]   - Field: ‘stdout’
[13:37:48.647]   - Field: ‘earlySignal’
[13:37:48.647]   - Field: ‘lazy’
[13:37:48.647]   - Field: ‘state’
[13:37:48.647] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:48.647] - Launch lazy future ...
[13:37:48.647] Packages needed by the future expression (n = 0): <none>
[13:37:48.647] Packages needed by future strategies (n = 0): <none>
[13:37:48.648] {
[13:37:48.648]     {
[13:37:48.648]         {
[13:37:48.648]             ...future.startTime <- base::Sys.time()
[13:37:48.648]             {
[13:37:48.648]                 {
[13:37:48.648]                   {
[13:37:48.648]                     {
[13:37:48.648]                       base::local({
[13:37:48.648]                         has_future <- base::requireNamespace("future", 
[13:37:48.648]                           quietly = TRUE)
[13:37:48.648]                         if (has_future) {
[13:37:48.648]                           ns <- base::getNamespace("future")
[13:37:48.648]                           version <- ns[[".package"]][["version"]]
[13:37:48.648]                           if (is.null(version)) 
[13:37:48.648]                             version <- utils::packageVersion("future")
[13:37:48.648]                         }
[13:37:48.648]                         else {
[13:37:48.648]                           version <- NULL
[13:37:48.648]                         }
[13:37:48.648]                         if (!has_future || version < "1.8.0") {
[13:37:48.648]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:48.648]                             "", base::R.version$version.string), 
[13:37:48.648]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:48.648]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:48.648]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:48.648]                               "release", "version")], collapse = " "), 
[13:37:48.648]                             hostname = base::Sys.info()[["nodename"]])
[13:37:48.648]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:48.648]                             info)
[13:37:48.648]                           info <- base::paste(info, collapse = "; ")
[13:37:48.648]                           if (!has_future) {
[13:37:48.648]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:48.648]                               info)
[13:37:48.648]                           }
[13:37:48.648]                           else {
[13:37:48.648]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:48.648]                               info, version)
[13:37:48.648]                           }
[13:37:48.648]                           base::stop(msg)
[13:37:48.648]                         }
[13:37:48.648]                       })
[13:37:48.648]                     }
[13:37:48.648]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:48.648]                     base::options(mc.cores = 1L)
[13:37:48.648]                   }
[13:37:48.648]                   ...future.strategy.old <- future::plan("list")
[13:37:48.648]                   options(future.plan = NULL)
[13:37:48.648]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:48.648]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:48.648]                 }
[13:37:48.648]                 ...future.workdir <- getwd()
[13:37:48.648]             }
[13:37:48.648]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:48.648]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:48.648]         }
[13:37:48.648]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:48.648]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:48.648]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:48.648]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:48.648]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:48.648]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:48.648]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:48.648]             base::names(...future.oldOptions))
[13:37:48.648]     }
[13:37:48.648]     if (FALSE) {
[13:37:48.648]     }
[13:37:48.648]     else {
[13:37:48.648]         if (TRUE) {
[13:37:48.648]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:48.648]                 open = "w")
[13:37:48.648]         }
[13:37:48.648]         else {
[13:37:48.648]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:48.648]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:48.648]         }
[13:37:48.648]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:48.648]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:48.648]             base::sink(type = "output", split = FALSE)
[13:37:48.648]             base::close(...future.stdout)
[13:37:48.648]         }, add = TRUE)
[13:37:48.648]     }
[13:37:48.648]     ...future.frame <- base::sys.nframe()
[13:37:48.648]     ...future.conditions <- base::list()
[13:37:48.648]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:48.648]     if (FALSE) {
[13:37:48.648]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:48.648]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:48.648]     }
[13:37:48.648]     ...future.result <- base::tryCatch({
[13:37:48.648]         base::withCallingHandlers({
[13:37:48.648]             ...future.value <- base::withVisible(base::local({
[13:37:48.648]                 ...future.makeSendCondition <- base::local({
[13:37:48.648]                   sendCondition <- NULL
[13:37:48.648]                   function(frame = 1L) {
[13:37:48.648]                     if (is.function(sendCondition)) 
[13:37:48.648]                       return(sendCondition)
[13:37:48.648]                     ns <- getNamespace("parallel")
[13:37:48.648]                     if (exists("sendData", mode = "function", 
[13:37:48.648]                       envir = ns)) {
[13:37:48.648]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:48.648]                         envir = ns)
[13:37:48.648]                       envir <- sys.frame(frame)
[13:37:48.648]                       master <- NULL
[13:37:48.648]                       while (!identical(envir, .GlobalEnv) && 
[13:37:48.648]                         !identical(envir, emptyenv())) {
[13:37:48.648]                         if (exists("master", mode = "list", envir = envir, 
[13:37:48.648]                           inherits = FALSE)) {
[13:37:48.648]                           master <- get("master", mode = "list", 
[13:37:48.648]                             envir = envir, inherits = FALSE)
[13:37:48.648]                           if (inherits(master, c("SOCKnode", 
[13:37:48.648]                             "SOCK0node"))) {
[13:37:48.648]                             sendCondition <<- function(cond) {
[13:37:48.648]                               data <- list(type = "VALUE", value = cond, 
[13:37:48.648]                                 success = TRUE)
[13:37:48.648]                               parallel_sendData(master, data)
[13:37:48.648]                             }
[13:37:48.648]                             return(sendCondition)
[13:37:48.648]                           }
[13:37:48.648]                         }
[13:37:48.648]                         frame <- frame + 1L
[13:37:48.648]                         envir <- sys.frame(frame)
[13:37:48.648]                       }
[13:37:48.648]                     }
[13:37:48.648]                     sendCondition <<- function(cond) NULL
[13:37:48.648]                   }
[13:37:48.648]                 })
[13:37:48.648]                 withCallingHandlers({
[13:37:48.648]                   {
[13:37:48.648]                     Sys.sleep(0.5)
[13:37:48.648]                     list(a = 1, b = 42L)
[13:37:48.648]                   }
[13:37:48.648]                 }, immediateCondition = function(cond) {
[13:37:48.648]                   sendCondition <- ...future.makeSendCondition()
[13:37:48.648]                   sendCondition(cond)
[13:37:48.648]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:48.648]                   {
[13:37:48.648]                     inherits <- base::inherits
[13:37:48.648]                     invokeRestart <- base::invokeRestart
[13:37:48.648]                     is.null <- base::is.null
[13:37:48.648]                     muffled <- FALSE
[13:37:48.648]                     if (inherits(cond, "message")) {
[13:37:48.648]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:48.648]                       if (muffled) 
[13:37:48.648]                         invokeRestart("muffleMessage")
[13:37:48.648]                     }
[13:37:48.648]                     else if (inherits(cond, "warning")) {
[13:37:48.648]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:48.648]                       if (muffled) 
[13:37:48.648]                         invokeRestart("muffleWarning")
[13:37:48.648]                     }
[13:37:48.648]                     else if (inherits(cond, "condition")) {
[13:37:48.648]                       if (!is.null(pattern)) {
[13:37:48.648]                         computeRestarts <- base::computeRestarts
[13:37:48.648]                         grepl <- base::grepl
[13:37:48.648]                         restarts <- computeRestarts(cond)
[13:37:48.648]                         for (restart in restarts) {
[13:37:48.648]                           name <- restart$name
[13:37:48.648]                           if (is.null(name)) 
[13:37:48.648]                             next
[13:37:48.648]                           if (!grepl(pattern, name)) 
[13:37:48.648]                             next
[13:37:48.648]                           invokeRestart(restart)
[13:37:48.648]                           muffled <- TRUE
[13:37:48.648]                           break
[13:37:48.648]                         }
[13:37:48.648]                       }
[13:37:48.648]                     }
[13:37:48.648]                     invisible(muffled)
[13:37:48.648]                   }
[13:37:48.648]                   muffleCondition(cond)
[13:37:48.648]                 })
[13:37:48.648]             }))
[13:37:48.648]             future::FutureResult(value = ...future.value$value, 
[13:37:48.648]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:48.648]                   ...future.rng), globalenv = if (FALSE) 
[13:37:48.648]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:48.648]                     ...future.globalenv.names))
[13:37:48.648]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:48.648]         }, condition = base::local({
[13:37:48.648]             c <- base::c
[13:37:48.648]             inherits <- base::inherits
[13:37:48.648]             invokeRestart <- base::invokeRestart
[13:37:48.648]             length <- base::length
[13:37:48.648]             list <- base::list
[13:37:48.648]             seq.int <- base::seq.int
[13:37:48.648]             signalCondition <- base::signalCondition
[13:37:48.648]             sys.calls <- base::sys.calls
[13:37:48.648]             `[[` <- base::`[[`
[13:37:48.648]             `+` <- base::`+`
[13:37:48.648]             `<<-` <- base::`<<-`
[13:37:48.648]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:48.648]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:48.648]                   3L)]
[13:37:48.648]             }
[13:37:48.648]             function(cond) {
[13:37:48.648]                 is_error <- inherits(cond, "error")
[13:37:48.648]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:48.648]                   NULL)
[13:37:48.648]                 if (is_error) {
[13:37:48.648]                   sessionInformation <- function() {
[13:37:48.648]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:48.648]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:48.648]                       search = base::search(), system = base::Sys.info())
[13:37:48.648]                   }
[13:37:48.648]                   ...future.conditions[[length(...future.conditions) + 
[13:37:48.648]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:48.648]                     cond$call), session = sessionInformation(), 
[13:37:48.648]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:48.648]                   signalCondition(cond)
[13:37:48.648]                 }
[13:37:48.648]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:48.648]                 "immediateCondition"))) {
[13:37:48.648]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:48.648]                   ...future.conditions[[length(...future.conditions) + 
[13:37:48.648]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:48.648]                   if (TRUE && !signal) {
[13:37:48.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:48.648]                     {
[13:37:48.648]                       inherits <- base::inherits
[13:37:48.648]                       invokeRestart <- base::invokeRestart
[13:37:48.648]                       is.null <- base::is.null
[13:37:48.648]                       muffled <- FALSE
[13:37:48.648]                       if (inherits(cond, "message")) {
[13:37:48.648]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:48.648]                         if (muffled) 
[13:37:48.648]                           invokeRestart("muffleMessage")
[13:37:48.648]                       }
[13:37:48.648]                       else if (inherits(cond, "warning")) {
[13:37:48.648]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:48.648]                         if (muffled) 
[13:37:48.648]                           invokeRestart("muffleWarning")
[13:37:48.648]                       }
[13:37:48.648]                       else if (inherits(cond, "condition")) {
[13:37:48.648]                         if (!is.null(pattern)) {
[13:37:48.648]                           computeRestarts <- base::computeRestarts
[13:37:48.648]                           grepl <- base::grepl
[13:37:48.648]                           restarts <- computeRestarts(cond)
[13:37:48.648]                           for (restart in restarts) {
[13:37:48.648]                             name <- restart$name
[13:37:48.648]                             if (is.null(name)) 
[13:37:48.648]                               next
[13:37:48.648]                             if (!grepl(pattern, name)) 
[13:37:48.648]                               next
[13:37:48.648]                             invokeRestart(restart)
[13:37:48.648]                             muffled <- TRUE
[13:37:48.648]                             break
[13:37:48.648]                           }
[13:37:48.648]                         }
[13:37:48.648]                       }
[13:37:48.648]                       invisible(muffled)
[13:37:48.648]                     }
[13:37:48.648]                     muffleCondition(cond, pattern = "^muffle")
[13:37:48.648]                   }
[13:37:48.648]                 }
[13:37:48.648]                 else {
[13:37:48.648]                   if (TRUE) {
[13:37:48.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:48.648]                     {
[13:37:48.648]                       inherits <- base::inherits
[13:37:48.648]                       invokeRestart <- base::invokeRestart
[13:37:48.648]                       is.null <- base::is.null
[13:37:48.648]                       muffled <- FALSE
[13:37:48.648]                       if (inherits(cond, "message")) {
[13:37:48.648]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:48.648]                         if (muffled) 
[13:37:48.648]                           invokeRestart("muffleMessage")
[13:37:48.648]                       }
[13:37:48.648]                       else if (inherits(cond, "warning")) {
[13:37:48.648]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:48.648]                         if (muffled) 
[13:37:48.648]                           invokeRestart("muffleWarning")
[13:37:48.648]                       }
[13:37:48.648]                       else if (inherits(cond, "condition")) {
[13:37:48.648]                         if (!is.null(pattern)) {
[13:37:48.648]                           computeRestarts <- base::computeRestarts
[13:37:48.648]                           grepl <- base::grepl
[13:37:48.648]                           restarts <- computeRestarts(cond)
[13:37:48.648]                           for (restart in restarts) {
[13:37:48.648]                             name <- restart$name
[13:37:48.648]                             if (is.null(name)) 
[13:37:48.648]                               next
[13:37:48.648]                             if (!grepl(pattern, name)) 
[13:37:48.648]                               next
[13:37:48.648]                             invokeRestart(restart)
[13:37:48.648]                             muffled <- TRUE
[13:37:48.648]                             break
[13:37:48.648]                           }
[13:37:48.648]                         }
[13:37:48.648]                       }
[13:37:48.648]                       invisible(muffled)
[13:37:48.648]                     }
[13:37:48.648]                     muffleCondition(cond, pattern = "^muffle")
[13:37:48.648]                   }
[13:37:48.648]                 }
[13:37:48.648]             }
[13:37:48.648]         }))
[13:37:48.648]     }, error = function(ex) {
[13:37:48.648]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:48.648]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:48.648]                 ...future.rng), started = ...future.startTime, 
[13:37:48.648]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:48.648]             version = "1.8"), class = "FutureResult")
[13:37:48.648]     }, finally = {
[13:37:48.648]         if (!identical(...future.workdir, getwd())) 
[13:37:48.648]             setwd(...future.workdir)
[13:37:48.648]         {
[13:37:48.648]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:48.648]                 ...future.oldOptions$nwarnings <- NULL
[13:37:48.648]             }
[13:37:48.648]             base::options(...future.oldOptions)
[13:37:48.648]             if (.Platform$OS.type == "windows") {
[13:37:48.648]                 old_names <- names(...future.oldEnvVars)
[13:37:48.648]                 envs <- base::Sys.getenv()
[13:37:48.648]                 names <- names(envs)
[13:37:48.648]                 common <- intersect(names, old_names)
[13:37:48.648]                 added <- setdiff(names, old_names)
[13:37:48.648]                 removed <- setdiff(old_names, names)
[13:37:48.648]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:48.648]                   envs[common]]
[13:37:48.648]                 NAMES <- toupper(changed)
[13:37:48.648]                 args <- list()
[13:37:48.648]                 for (kk in seq_along(NAMES)) {
[13:37:48.648]                   name <- changed[[kk]]
[13:37:48.648]                   NAME <- NAMES[[kk]]
[13:37:48.648]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:48.648]                     next
[13:37:48.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:48.648]                 }
[13:37:48.648]                 NAMES <- toupper(added)
[13:37:48.648]                 for (kk in seq_along(NAMES)) {
[13:37:48.648]                   name <- added[[kk]]
[13:37:48.648]                   NAME <- NAMES[[kk]]
[13:37:48.648]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:48.648]                     next
[13:37:48.648]                   args[[name]] <- ""
[13:37:48.648]                 }
[13:37:48.648]                 NAMES <- toupper(removed)
[13:37:48.648]                 for (kk in seq_along(NAMES)) {
[13:37:48.648]                   name <- removed[[kk]]
[13:37:48.648]                   NAME <- NAMES[[kk]]
[13:37:48.648]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:48.648]                     next
[13:37:48.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:48.648]                 }
[13:37:48.648]                 if (length(args) > 0) 
[13:37:48.648]                   base::do.call(base::Sys.setenv, args = args)
[13:37:48.648]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:48.648]             }
[13:37:48.648]             else {
[13:37:48.648]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:48.648]             }
[13:37:48.648]             {
[13:37:48.648]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:48.648]                   0L) {
[13:37:48.648]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:48.648]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:48.648]                   base::options(opts)
[13:37:48.648]                 }
[13:37:48.648]                 {
[13:37:48.648]                   {
[13:37:48.648]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:48.648]                     NULL
[13:37:48.648]                   }
[13:37:48.648]                   options(future.plan = NULL)
[13:37:48.648]                   if (is.na(NA_character_)) 
[13:37:48.648]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:48.648]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:48.648]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:48.648]                     .init = FALSE)
[13:37:48.648]                 }
[13:37:48.648]             }
[13:37:48.648]         }
[13:37:48.648]     })
[13:37:48.648]     if (TRUE) {
[13:37:48.648]         base::sink(type = "output", split = FALSE)
[13:37:48.648]         if (TRUE) {
[13:37:48.648]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:48.648]         }
[13:37:48.648]         else {
[13:37:48.648]             ...future.result["stdout"] <- base::list(NULL)
[13:37:48.648]         }
[13:37:48.648]         base::close(...future.stdout)
[13:37:48.648]         ...future.stdout <- NULL
[13:37:48.648]     }
[13:37:48.648]     ...future.result$conditions <- ...future.conditions
[13:37:48.648]     ...future.result$finished <- base::Sys.time()
[13:37:48.648]     ...future.result
[13:37:48.648] }
[13:37:48.651] MultisessionFuture started
[13:37:48.651] - Launch lazy future ... done
[13:37:48.651] run() for ‘MultisessionFuture’ ... done
[13:37:49.153] receiveMessageFromWorker() for ClusterFuture ...
[13:37:49.154] - Validating connection of MultisessionFuture
[13:37:49.154] - received message: FutureResult
[13:37:49.154] - Received FutureResult
[13:37:49.154] - Erased future from FutureRegistry
[13:37:49.154] result() for ClusterFuture ...
[13:37:49.154] - result already collected: FutureResult
[13:37:49.154] result() for ClusterFuture ... done
[13:37:49.155] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:49.155] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[13:37:49.155] getGlobalsAndPackages() ...
[13:37:49.155] Searching for globals...
[13:37:49.156] - globals found: [2] ‘list’, ‘stop’
[13:37:49.156] Searching for globals ... DONE
[13:37:49.156] Resolving globals: FALSE
[13:37:49.156] 
[13:37:49.156] 
[13:37:49.156] getGlobalsAndPackages() ... DONE
[13:37:49.157] run() for ‘Future’ ...
[13:37:49.157] - state: ‘created’
[13:37:49.157] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:49.171] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:49.171] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:49.171]   - Field: ‘node’
[13:37:49.171]   - Field: ‘label’
[13:37:49.171]   - Field: ‘local’
[13:37:49.172]   - Field: ‘owner’
[13:37:49.172]   - Field: ‘envir’
[13:37:49.172]   - Field: ‘workers’
[13:37:49.172]   - Field: ‘packages’
[13:37:49.172]   - Field: ‘gc’
[13:37:49.172]   - Field: ‘conditions’
[13:37:49.172]   - Field: ‘persistent’
[13:37:49.172]   - Field: ‘expr’
[13:37:49.172]   - Field: ‘uuid’
[13:37:49.172]   - Field: ‘seed’
[13:37:49.172]   - Field: ‘version’
[13:37:49.173]   - Field: ‘result’
[13:37:49.173]   - Field: ‘asynchronous’
[13:37:49.173]   - Field: ‘calls’
[13:37:49.173]   - Field: ‘globals’
[13:37:49.173]   - Field: ‘stdout’
[13:37:49.173]   - Field: ‘earlySignal’
[13:37:49.173]   - Field: ‘lazy’
[13:37:49.173]   - Field: ‘state’
[13:37:49.173] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:49.173] - Launch lazy future ...
[13:37:49.174] Packages needed by the future expression (n = 0): <none>
[13:37:49.174] Packages needed by future strategies (n = 0): <none>
[13:37:49.174] {
[13:37:49.174]     {
[13:37:49.174]         {
[13:37:49.174]             ...future.startTime <- base::Sys.time()
[13:37:49.174]             {
[13:37:49.174]                 {
[13:37:49.174]                   {
[13:37:49.174]                     {
[13:37:49.174]                       base::local({
[13:37:49.174]                         has_future <- base::requireNamespace("future", 
[13:37:49.174]                           quietly = TRUE)
[13:37:49.174]                         if (has_future) {
[13:37:49.174]                           ns <- base::getNamespace("future")
[13:37:49.174]                           version <- ns[[".package"]][["version"]]
[13:37:49.174]                           if (is.null(version)) 
[13:37:49.174]                             version <- utils::packageVersion("future")
[13:37:49.174]                         }
[13:37:49.174]                         else {
[13:37:49.174]                           version <- NULL
[13:37:49.174]                         }
[13:37:49.174]                         if (!has_future || version < "1.8.0") {
[13:37:49.174]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:49.174]                             "", base::R.version$version.string), 
[13:37:49.174]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:49.174]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:49.174]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:49.174]                               "release", "version")], collapse = " "), 
[13:37:49.174]                             hostname = base::Sys.info()[["nodename"]])
[13:37:49.174]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:49.174]                             info)
[13:37:49.174]                           info <- base::paste(info, collapse = "; ")
[13:37:49.174]                           if (!has_future) {
[13:37:49.174]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:49.174]                               info)
[13:37:49.174]                           }
[13:37:49.174]                           else {
[13:37:49.174]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:49.174]                               info, version)
[13:37:49.174]                           }
[13:37:49.174]                           base::stop(msg)
[13:37:49.174]                         }
[13:37:49.174]                       })
[13:37:49.174]                     }
[13:37:49.174]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:49.174]                     base::options(mc.cores = 1L)
[13:37:49.174]                   }
[13:37:49.174]                   ...future.strategy.old <- future::plan("list")
[13:37:49.174]                   options(future.plan = NULL)
[13:37:49.174]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:49.174]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:49.174]                 }
[13:37:49.174]                 ...future.workdir <- getwd()
[13:37:49.174]             }
[13:37:49.174]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:49.174]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:49.174]         }
[13:37:49.174]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:49.174]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:49.174]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:49.174]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:49.174]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:49.174]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:49.174]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:49.174]             base::names(...future.oldOptions))
[13:37:49.174]     }
[13:37:49.174]     if (FALSE) {
[13:37:49.174]     }
[13:37:49.174]     else {
[13:37:49.174]         if (TRUE) {
[13:37:49.174]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:49.174]                 open = "w")
[13:37:49.174]         }
[13:37:49.174]         else {
[13:37:49.174]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:49.174]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:49.174]         }
[13:37:49.174]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:49.174]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:49.174]             base::sink(type = "output", split = FALSE)
[13:37:49.174]             base::close(...future.stdout)
[13:37:49.174]         }, add = TRUE)
[13:37:49.174]     }
[13:37:49.174]     ...future.frame <- base::sys.nframe()
[13:37:49.174]     ...future.conditions <- base::list()
[13:37:49.174]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:49.174]     if (FALSE) {
[13:37:49.174]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:49.174]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:49.174]     }
[13:37:49.174]     ...future.result <- base::tryCatch({
[13:37:49.174]         base::withCallingHandlers({
[13:37:49.174]             ...future.value <- base::withVisible(base::local({
[13:37:49.174]                 ...future.makeSendCondition <- base::local({
[13:37:49.174]                   sendCondition <- NULL
[13:37:49.174]                   function(frame = 1L) {
[13:37:49.174]                     if (is.function(sendCondition)) 
[13:37:49.174]                       return(sendCondition)
[13:37:49.174]                     ns <- getNamespace("parallel")
[13:37:49.174]                     if (exists("sendData", mode = "function", 
[13:37:49.174]                       envir = ns)) {
[13:37:49.174]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:49.174]                         envir = ns)
[13:37:49.174]                       envir <- sys.frame(frame)
[13:37:49.174]                       master <- NULL
[13:37:49.174]                       while (!identical(envir, .GlobalEnv) && 
[13:37:49.174]                         !identical(envir, emptyenv())) {
[13:37:49.174]                         if (exists("master", mode = "list", envir = envir, 
[13:37:49.174]                           inherits = FALSE)) {
[13:37:49.174]                           master <- get("master", mode = "list", 
[13:37:49.174]                             envir = envir, inherits = FALSE)
[13:37:49.174]                           if (inherits(master, c("SOCKnode", 
[13:37:49.174]                             "SOCK0node"))) {
[13:37:49.174]                             sendCondition <<- function(cond) {
[13:37:49.174]                               data <- list(type = "VALUE", value = cond, 
[13:37:49.174]                                 success = TRUE)
[13:37:49.174]                               parallel_sendData(master, data)
[13:37:49.174]                             }
[13:37:49.174]                             return(sendCondition)
[13:37:49.174]                           }
[13:37:49.174]                         }
[13:37:49.174]                         frame <- frame + 1L
[13:37:49.174]                         envir <- sys.frame(frame)
[13:37:49.174]                       }
[13:37:49.174]                     }
[13:37:49.174]                     sendCondition <<- function(cond) NULL
[13:37:49.174]                   }
[13:37:49.174]                 })
[13:37:49.174]                 withCallingHandlers({
[13:37:49.174]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:37:49.174]                 }, immediateCondition = function(cond) {
[13:37:49.174]                   sendCondition <- ...future.makeSendCondition()
[13:37:49.174]                   sendCondition(cond)
[13:37:49.174]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:49.174]                   {
[13:37:49.174]                     inherits <- base::inherits
[13:37:49.174]                     invokeRestart <- base::invokeRestart
[13:37:49.174]                     is.null <- base::is.null
[13:37:49.174]                     muffled <- FALSE
[13:37:49.174]                     if (inherits(cond, "message")) {
[13:37:49.174]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:49.174]                       if (muffled) 
[13:37:49.174]                         invokeRestart("muffleMessage")
[13:37:49.174]                     }
[13:37:49.174]                     else if (inherits(cond, "warning")) {
[13:37:49.174]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:49.174]                       if (muffled) 
[13:37:49.174]                         invokeRestart("muffleWarning")
[13:37:49.174]                     }
[13:37:49.174]                     else if (inherits(cond, "condition")) {
[13:37:49.174]                       if (!is.null(pattern)) {
[13:37:49.174]                         computeRestarts <- base::computeRestarts
[13:37:49.174]                         grepl <- base::grepl
[13:37:49.174]                         restarts <- computeRestarts(cond)
[13:37:49.174]                         for (restart in restarts) {
[13:37:49.174]                           name <- restart$name
[13:37:49.174]                           if (is.null(name)) 
[13:37:49.174]                             next
[13:37:49.174]                           if (!grepl(pattern, name)) 
[13:37:49.174]                             next
[13:37:49.174]                           invokeRestart(restart)
[13:37:49.174]                           muffled <- TRUE
[13:37:49.174]                           break
[13:37:49.174]                         }
[13:37:49.174]                       }
[13:37:49.174]                     }
[13:37:49.174]                     invisible(muffled)
[13:37:49.174]                   }
[13:37:49.174]                   muffleCondition(cond)
[13:37:49.174]                 })
[13:37:49.174]             }))
[13:37:49.174]             future::FutureResult(value = ...future.value$value, 
[13:37:49.174]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:49.174]                   ...future.rng), globalenv = if (FALSE) 
[13:37:49.174]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:49.174]                     ...future.globalenv.names))
[13:37:49.174]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:49.174]         }, condition = base::local({
[13:37:49.174]             c <- base::c
[13:37:49.174]             inherits <- base::inherits
[13:37:49.174]             invokeRestart <- base::invokeRestart
[13:37:49.174]             length <- base::length
[13:37:49.174]             list <- base::list
[13:37:49.174]             seq.int <- base::seq.int
[13:37:49.174]             signalCondition <- base::signalCondition
[13:37:49.174]             sys.calls <- base::sys.calls
[13:37:49.174]             `[[` <- base::`[[`
[13:37:49.174]             `+` <- base::`+`
[13:37:49.174]             `<<-` <- base::`<<-`
[13:37:49.174]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:49.174]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:49.174]                   3L)]
[13:37:49.174]             }
[13:37:49.174]             function(cond) {
[13:37:49.174]                 is_error <- inherits(cond, "error")
[13:37:49.174]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:49.174]                   NULL)
[13:37:49.174]                 if (is_error) {
[13:37:49.174]                   sessionInformation <- function() {
[13:37:49.174]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:49.174]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:49.174]                       search = base::search(), system = base::Sys.info())
[13:37:49.174]                   }
[13:37:49.174]                   ...future.conditions[[length(...future.conditions) + 
[13:37:49.174]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:49.174]                     cond$call), session = sessionInformation(), 
[13:37:49.174]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:49.174]                   signalCondition(cond)
[13:37:49.174]                 }
[13:37:49.174]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:49.174]                 "immediateCondition"))) {
[13:37:49.174]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:49.174]                   ...future.conditions[[length(...future.conditions) + 
[13:37:49.174]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:49.174]                   if (TRUE && !signal) {
[13:37:49.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:49.174]                     {
[13:37:49.174]                       inherits <- base::inherits
[13:37:49.174]                       invokeRestart <- base::invokeRestart
[13:37:49.174]                       is.null <- base::is.null
[13:37:49.174]                       muffled <- FALSE
[13:37:49.174]                       if (inherits(cond, "message")) {
[13:37:49.174]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:49.174]                         if (muffled) 
[13:37:49.174]                           invokeRestart("muffleMessage")
[13:37:49.174]                       }
[13:37:49.174]                       else if (inherits(cond, "warning")) {
[13:37:49.174]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:49.174]                         if (muffled) 
[13:37:49.174]                           invokeRestart("muffleWarning")
[13:37:49.174]                       }
[13:37:49.174]                       else if (inherits(cond, "condition")) {
[13:37:49.174]                         if (!is.null(pattern)) {
[13:37:49.174]                           computeRestarts <- base::computeRestarts
[13:37:49.174]                           grepl <- base::grepl
[13:37:49.174]                           restarts <- computeRestarts(cond)
[13:37:49.174]                           for (restart in restarts) {
[13:37:49.174]                             name <- restart$name
[13:37:49.174]                             if (is.null(name)) 
[13:37:49.174]                               next
[13:37:49.174]                             if (!grepl(pattern, name)) 
[13:37:49.174]                               next
[13:37:49.174]                             invokeRestart(restart)
[13:37:49.174]                             muffled <- TRUE
[13:37:49.174]                             break
[13:37:49.174]                           }
[13:37:49.174]                         }
[13:37:49.174]                       }
[13:37:49.174]                       invisible(muffled)
[13:37:49.174]                     }
[13:37:49.174]                     muffleCondition(cond, pattern = "^muffle")
[13:37:49.174]                   }
[13:37:49.174]                 }
[13:37:49.174]                 else {
[13:37:49.174]                   if (TRUE) {
[13:37:49.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:49.174]                     {
[13:37:49.174]                       inherits <- base::inherits
[13:37:49.174]                       invokeRestart <- base::invokeRestart
[13:37:49.174]                       is.null <- base::is.null
[13:37:49.174]                       muffled <- FALSE
[13:37:49.174]                       if (inherits(cond, "message")) {
[13:37:49.174]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:49.174]                         if (muffled) 
[13:37:49.174]                           invokeRestart("muffleMessage")
[13:37:49.174]                       }
[13:37:49.174]                       else if (inherits(cond, "warning")) {
[13:37:49.174]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:49.174]                         if (muffled) 
[13:37:49.174]                           invokeRestart("muffleWarning")
[13:37:49.174]                       }
[13:37:49.174]                       else if (inherits(cond, "condition")) {
[13:37:49.174]                         if (!is.null(pattern)) {
[13:37:49.174]                           computeRestarts <- base::computeRestarts
[13:37:49.174]                           grepl <- base::grepl
[13:37:49.174]                           restarts <- computeRestarts(cond)
[13:37:49.174]                           for (restart in restarts) {
[13:37:49.174]                             name <- restart$name
[13:37:49.174]                             if (is.null(name)) 
[13:37:49.174]                               next
[13:37:49.174]                             if (!grepl(pattern, name)) 
[13:37:49.174]                               next
[13:37:49.174]                             invokeRestart(restart)
[13:37:49.174]                             muffled <- TRUE
[13:37:49.174]                             break
[13:37:49.174]                           }
[13:37:49.174]                         }
[13:37:49.174]                       }
[13:37:49.174]                       invisible(muffled)
[13:37:49.174]                     }
[13:37:49.174]                     muffleCondition(cond, pattern = "^muffle")
[13:37:49.174]                   }
[13:37:49.174]                 }
[13:37:49.174]             }
[13:37:49.174]         }))
[13:37:49.174]     }, error = function(ex) {
[13:37:49.174]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:49.174]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:49.174]                 ...future.rng), started = ...future.startTime, 
[13:37:49.174]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:49.174]             version = "1.8"), class = "FutureResult")
[13:37:49.174]     }, finally = {
[13:37:49.174]         if (!identical(...future.workdir, getwd())) 
[13:37:49.174]             setwd(...future.workdir)
[13:37:49.174]         {
[13:37:49.174]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:49.174]                 ...future.oldOptions$nwarnings <- NULL
[13:37:49.174]             }
[13:37:49.174]             base::options(...future.oldOptions)
[13:37:49.174]             if (.Platform$OS.type == "windows") {
[13:37:49.174]                 old_names <- names(...future.oldEnvVars)
[13:37:49.174]                 envs <- base::Sys.getenv()
[13:37:49.174]                 names <- names(envs)
[13:37:49.174]                 common <- intersect(names, old_names)
[13:37:49.174]                 added <- setdiff(names, old_names)
[13:37:49.174]                 removed <- setdiff(old_names, names)
[13:37:49.174]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:49.174]                   envs[common]]
[13:37:49.174]                 NAMES <- toupper(changed)
[13:37:49.174]                 args <- list()
[13:37:49.174]                 for (kk in seq_along(NAMES)) {
[13:37:49.174]                   name <- changed[[kk]]
[13:37:49.174]                   NAME <- NAMES[[kk]]
[13:37:49.174]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:49.174]                     next
[13:37:49.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:49.174]                 }
[13:37:49.174]                 NAMES <- toupper(added)
[13:37:49.174]                 for (kk in seq_along(NAMES)) {
[13:37:49.174]                   name <- added[[kk]]
[13:37:49.174]                   NAME <- NAMES[[kk]]
[13:37:49.174]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:49.174]                     next
[13:37:49.174]                   args[[name]] <- ""
[13:37:49.174]                 }
[13:37:49.174]                 NAMES <- toupper(removed)
[13:37:49.174]                 for (kk in seq_along(NAMES)) {
[13:37:49.174]                   name <- removed[[kk]]
[13:37:49.174]                   NAME <- NAMES[[kk]]
[13:37:49.174]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:49.174]                     next
[13:37:49.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:49.174]                 }
[13:37:49.174]                 if (length(args) > 0) 
[13:37:49.174]                   base::do.call(base::Sys.setenv, args = args)
[13:37:49.174]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:49.174]             }
[13:37:49.174]             else {
[13:37:49.174]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:49.174]             }
[13:37:49.174]             {
[13:37:49.174]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:49.174]                   0L) {
[13:37:49.174]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:49.174]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:49.174]                   base::options(opts)
[13:37:49.174]                 }
[13:37:49.174]                 {
[13:37:49.174]                   {
[13:37:49.174]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:49.174]                     NULL
[13:37:49.174]                   }
[13:37:49.174]                   options(future.plan = NULL)
[13:37:49.174]                   if (is.na(NA_character_)) 
[13:37:49.174]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:49.174]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:49.174]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:49.174]                     .init = FALSE)
[13:37:49.174]                 }
[13:37:49.174]             }
[13:37:49.174]         }
[13:37:49.174]     })
[13:37:49.174]     if (TRUE) {
[13:37:49.174]         base::sink(type = "output", split = FALSE)
[13:37:49.174]         if (TRUE) {
[13:37:49.174]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:49.174]         }
[13:37:49.174]         else {
[13:37:49.174]             ...future.result["stdout"] <- base::list(NULL)
[13:37:49.174]         }
[13:37:49.174]         base::close(...future.stdout)
[13:37:49.174]         ...future.stdout <- NULL
[13:37:49.174]     }
[13:37:49.174]     ...future.result$conditions <- ...future.conditions
[13:37:49.174]     ...future.result$finished <- base::Sys.time()
[13:37:49.174]     ...future.result
[13:37:49.174] }
[13:37:49.177] MultisessionFuture started
[13:37:49.177] - Launch lazy future ... done
[13:37:49.177] run() for ‘MultisessionFuture’ ... done
[13:37:49.179] receiveMessageFromWorker() for ClusterFuture ...
[13:37:49.179] - Validating connection of MultisessionFuture
[13:37:49.180] - received message: FutureResult
[13:37:49.180] - Received FutureResult
[13:37:49.180] - Erased future from FutureRegistry
[13:37:49.180] result() for ClusterFuture ...
[13:37:49.180] - result already collected: FutureResult
[13:37:49.180] result() for ClusterFuture ... done
[13:37:49.180] signalConditions() ...
[13:37:49.180]  - include = ‘immediateCondition’
[13:37:49.180]  - exclude = 
[13:37:49.180]  - resignal = FALSE
[13:37:49.181]  - Number of conditions: 1
[13:37:49.181] signalConditions() ... done
[13:37:49.181] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:49.181] A MultisessionFuture was resolved (result was not collected)
[13:37:49.181] getGlobalsAndPackages() ...
[13:37:49.181] Searching for globals...
[13:37:49.182] - globals found: [2] ‘list’, ‘stop’
[13:37:49.182] Searching for globals ... DONE
[13:37:49.182] Resolving globals: FALSE
[13:37:49.182] 
[13:37:49.182] 
[13:37:49.182] getGlobalsAndPackages() ... DONE
[13:37:49.183] run() for ‘Future’ ...
[13:37:49.183] - state: ‘created’
[13:37:49.183] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:49.197] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:49.197] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:49.197]   - Field: ‘node’
[13:37:49.197]   - Field: ‘label’
[13:37:49.197]   - Field: ‘local’
[13:37:49.197]   - Field: ‘owner’
[13:37:49.197]   - Field: ‘envir’
[13:37:49.197]   - Field: ‘workers’
[13:37:49.198]   - Field: ‘packages’
[13:37:49.198]   - Field: ‘gc’
[13:37:49.198]   - Field: ‘conditions’
[13:37:49.198]   - Field: ‘persistent’
[13:37:49.198]   - Field: ‘expr’
[13:37:49.198]   - Field: ‘uuid’
[13:37:49.198]   - Field: ‘seed’
[13:37:49.198]   - Field: ‘version’
[13:37:49.198]   - Field: ‘result’
[13:37:49.198]   - Field: ‘asynchronous’
[13:37:49.198]   - Field: ‘calls’
[13:37:49.199]   - Field: ‘globals’
[13:37:49.199]   - Field: ‘stdout’
[13:37:49.199]   - Field: ‘earlySignal’
[13:37:49.199]   - Field: ‘lazy’
[13:37:49.199]   - Field: ‘state’
[13:37:49.199] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:49.199] - Launch lazy future ...
[13:37:49.199] Packages needed by the future expression (n = 0): <none>
[13:37:49.199] Packages needed by future strategies (n = 0): <none>
[13:37:49.200] {
[13:37:49.200]     {
[13:37:49.200]         {
[13:37:49.200]             ...future.startTime <- base::Sys.time()
[13:37:49.200]             {
[13:37:49.200]                 {
[13:37:49.200]                   {
[13:37:49.200]                     {
[13:37:49.200]                       base::local({
[13:37:49.200]                         has_future <- base::requireNamespace("future", 
[13:37:49.200]                           quietly = TRUE)
[13:37:49.200]                         if (has_future) {
[13:37:49.200]                           ns <- base::getNamespace("future")
[13:37:49.200]                           version <- ns[[".package"]][["version"]]
[13:37:49.200]                           if (is.null(version)) 
[13:37:49.200]                             version <- utils::packageVersion("future")
[13:37:49.200]                         }
[13:37:49.200]                         else {
[13:37:49.200]                           version <- NULL
[13:37:49.200]                         }
[13:37:49.200]                         if (!has_future || version < "1.8.0") {
[13:37:49.200]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:49.200]                             "", base::R.version$version.string), 
[13:37:49.200]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:49.200]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:49.200]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:49.200]                               "release", "version")], collapse = " "), 
[13:37:49.200]                             hostname = base::Sys.info()[["nodename"]])
[13:37:49.200]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:49.200]                             info)
[13:37:49.200]                           info <- base::paste(info, collapse = "; ")
[13:37:49.200]                           if (!has_future) {
[13:37:49.200]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:49.200]                               info)
[13:37:49.200]                           }
[13:37:49.200]                           else {
[13:37:49.200]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:49.200]                               info, version)
[13:37:49.200]                           }
[13:37:49.200]                           base::stop(msg)
[13:37:49.200]                         }
[13:37:49.200]                       })
[13:37:49.200]                     }
[13:37:49.200]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:49.200]                     base::options(mc.cores = 1L)
[13:37:49.200]                   }
[13:37:49.200]                   ...future.strategy.old <- future::plan("list")
[13:37:49.200]                   options(future.plan = NULL)
[13:37:49.200]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:49.200]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:49.200]                 }
[13:37:49.200]                 ...future.workdir <- getwd()
[13:37:49.200]             }
[13:37:49.200]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:49.200]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:49.200]         }
[13:37:49.200]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:49.200]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:49.200]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:49.200]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:49.200]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:49.200]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:49.200]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:49.200]             base::names(...future.oldOptions))
[13:37:49.200]     }
[13:37:49.200]     if (FALSE) {
[13:37:49.200]     }
[13:37:49.200]     else {
[13:37:49.200]         if (TRUE) {
[13:37:49.200]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:49.200]                 open = "w")
[13:37:49.200]         }
[13:37:49.200]         else {
[13:37:49.200]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:49.200]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:49.200]         }
[13:37:49.200]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:49.200]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:49.200]             base::sink(type = "output", split = FALSE)
[13:37:49.200]             base::close(...future.stdout)
[13:37:49.200]         }, add = TRUE)
[13:37:49.200]     }
[13:37:49.200]     ...future.frame <- base::sys.nframe()
[13:37:49.200]     ...future.conditions <- base::list()
[13:37:49.200]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:49.200]     if (FALSE) {
[13:37:49.200]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:49.200]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:49.200]     }
[13:37:49.200]     ...future.result <- base::tryCatch({
[13:37:49.200]         base::withCallingHandlers({
[13:37:49.200]             ...future.value <- base::withVisible(base::local({
[13:37:49.200]                 ...future.makeSendCondition <- base::local({
[13:37:49.200]                   sendCondition <- NULL
[13:37:49.200]                   function(frame = 1L) {
[13:37:49.200]                     if (is.function(sendCondition)) 
[13:37:49.200]                       return(sendCondition)
[13:37:49.200]                     ns <- getNamespace("parallel")
[13:37:49.200]                     if (exists("sendData", mode = "function", 
[13:37:49.200]                       envir = ns)) {
[13:37:49.200]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:49.200]                         envir = ns)
[13:37:49.200]                       envir <- sys.frame(frame)
[13:37:49.200]                       master <- NULL
[13:37:49.200]                       while (!identical(envir, .GlobalEnv) && 
[13:37:49.200]                         !identical(envir, emptyenv())) {
[13:37:49.200]                         if (exists("master", mode = "list", envir = envir, 
[13:37:49.200]                           inherits = FALSE)) {
[13:37:49.200]                           master <- get("master", mode = "list", 
[13:37:49.200]                             envir = envir, inherits = FALSE)
[13:37:49.200]                           if (inherits(master, c("SOCKnode", 
[13:37:49.200]                             "SOCK0node"))) {
[13:37:49.200]                             sendCondition <<- function(cond) {
[13:37:49.200]                               data <- list(type = "VALUE", value = cond, 
[13:37:49.200]                                 success = TRUE)
[13:37:49.200]                               parallel_sendData(master, data)
[13:37:49.200]                             }
[13:37:49.200]                             return(sendCondition)
[13:37:49.200]                           }
[13:37:49.200]                         }
[13:37:49.200]                         frame <- frame + 1L
[13:37:49.200]                         envir <- sys.frame(frame)
[13:37:49.200]                       }
[13:37:49.200]                     }
[13:37:49.200]                     sendCondition <<- function(cond) NULL
[13:37:49.200]                   }
[13:37:49.200]                 })
[13:37:49.200]                 withCallingHandlers({
[13:37:49.200]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:37:49.200]                 }, immediateCondition = function(cond) {
[13:37:49.200]                   sendCondition <- ...future.makeSendCondition()
[13:37:49.200]                   sendCondition(cond)
[13:37:49.200]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:49.200]                   {
[13:37:49.200]                     inherits <- base::inherits
[13:37:49.200]                     invokeRestart <- base::invokeRestart
[13:37:49.200]                     is.null <- base::is.null
[13:37:49.200]                     muffled <- FALSE
[13:37:49.200]                     if (inherits(cond, "message")) {
[13:37:49.200]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:49.200]                       if (muffled) 
[13:37:49.200]                         invokeRestart("muffleMessage")
[13:37:49.200]                     }
[13:37:49.200]                     else if (inherits(cond, "warning")) {
[13:37:49.200]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:49.200]                       if (muffled) 
[13:37:49.200]                         invokeRestart("muffleWarning")
[13:37:49.200]                     }
[13:37:49.200]                     else if (inherits(cond, "condition")) {
[13:37:49.200]                       if (!is.null(pattern)) {
[13:37:49.200]                         computeRestarts <- base::computeRestarts
[13:37:49.200]                         grepl <- base::grepl
[13:37:49.200]                         restarts <- computeRestarts(cond)
[13:37:49.200]                         for (restart in restarts) {
[13:37:49.200]                           name <- restart$name
[13:37:49.200]                           if (is.null(name)) 
[13:37:49.200]                             next
[13:37:49.200]                           if (!grepl(pattern, name)) 
[13:37:49.200]                             next
[13:37:49.200]                           invokeRestart(restart)
[13:37:49.200]                           muffled <- TRUE
[13:37:49.200]                           break
[13:37:49.200]                         }
[13:37:49.200]                       }
[13:37:49.200]                     }
[13:37:49.200]                     invisible(muffled)
[13:37:49.200]                   }
[13:37:49.200]                   muffleCondition(cond)
[13:37:49.200]                 })
[13:37:49.200]             }))
[13:37:49.200]             future::FutureResult(value = ...future.value$value, 
[13:37:49.200]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:49.200]                   ...future.rng), globalenv = if (FALSE) 
[13:37:49.200]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:49.200]                     ...future.globalenv.names))
[13:37:49.200]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:49.200]         }, condition = base::local({
[13:37:49.200]             c <- base::c
[13:37:49.200]             inherits <- base::inherits
[13:37:49.200]             invokeRestart <- base::invokeRestart
[13:37:49.200]             length <- base::length
[13:37:49.200]             list <- base::list
[13:37:49.200]             seq.int <- base::seq.int
[13:37:49.200]             signalCondition <- base::signalCondition
[13:37:49.200]             sys.calls <- base::sys.calls
[13:37:49.200]             `[[` <- base::`[[`
[13:37:49.200]             `+` <- base::`+`
[13:37:49.200]             `<<-` <- base::`<<-`
[13:37:49.200]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:49.200]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:49.200]                   3L)]
[13:37:49.200]             }
[13:37:49.200]             function(cond) {
[13:37:49.200]                 is_error <- inherits(cond, "error")
[13:37:49.200]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:49.200]                   NULL)
[13:37:49.200]                 if (is_error) {
[13:37:49.200]                   sessionInformation <- function() {
[13:37:49.200]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:49.200]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:49.200]                       search = base::search(), system = base::Sys.info())
[13:37:49.200]                   }
[13:37:49.200]                   ...future.conditions[[length(...future.conditions) + 
[13:37:49.200]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:49.200]                     cond$call), session = sessionInformation(), 
[13:37:49.200]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:49.200]                   signalCondition(cond)
[13:37:49.200]                 }
[13:37:49.200]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:49.200]                 "immediateCondition"))) {
[13:37:49.200]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:49.200]                   ...future.conditions[[length(...future.conditions) + 
[13:37:49.200]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:49.200]                   if (TRUE && !signal) {
[13:37:49.200]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:49.200]                     {
[13:37:49.200]                       inherits <- base::inherits
[13:37:49.200]                       invokeRestart <- base::invokeRestart
[13:37:49.200]                       is.null <- base::is.null
[13:37:49.200]                       muffled <- FALSE
[13:37:49.200]                       if (inherits(cond, "message")) {
[13:37:49.200]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:49.200]                         if (muffled) 
[13:37:49.200]                           invokeRestart("muffleMessage")
[13:37:49.200]                       }
[13:37:49.200]                       else if (inherits(cond, "warning")) {
[13:37:49.200]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:49.200]                         if (muffled) 
[13:37:49.200]                           invokeRestart("muffleWarning")
[13:37:49.200]                       }
[13:37:49.200]                       else if (inherits(cond, "condition")) {
[13:37:49.200]                         if (!is.null(pattern)) {
[13:37:49.200]                           computeRestarts <- base::computeRestarts
[13:37:49.200]                           grepl <- base::grepl
[13:37:49.200]                           restarts <- computeRestarts(cond)
[13:37:49.200]                           for (restart in restarts) {
[13:37:49.200]                             name <- restart$name
[13:37:49.200]                             if (is.null(name)) 
[13:37:49.200]                               next
[13:37:49.200]                             if (!grepl(pattern, name)) 
[13:37:49.200]                               next
[13:37:49.200]                             invokeRestart(restart)
[13:37:49.200]                             muffled <- TRUE
[13:37:49.200]                             break
[13:37:49.200]                           }
[13:37:49.200]                         }
[13:37:49.200]                       }
[13:37:49.200]                       invisible(muffled)
[13:37:49.200]                     }
[13:37:49.200]                     muffleCondition(cond, pattern = "^muffle")
[13:37:49.200]                   }
[13:37:49.200]                 }
[13:37:49.200]                 else {
[13:37:49.200]                   if (TRUE) {
[13:37:49.200]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:49.200]                     {
[13:37:49.200]                       inherits <- base::inherits
[13:37:49.200]                       invokeRestart <- base::invokeRestart
[13:37:49.200]                       is.null <- base::is.null
[13:37:49.200]                       muffled <- FALSE
[13:37:49.200]                       if (inherits(cond, "message")) {
[13:37:49.200]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:49.200]                         if (muffled) 
[13:37:49.200]                           invokeRestart("muffleMessage")
[13:37:49.200]                       }
[13:37:49.200]                       else if (inherits(cond, "warning")) {
[13:37:49.200]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:49.200]                         if (muffled) 
[13:37:49.200]                           invokeRestart("muffleWarning")
[13:37:49.200]                       }
[13:37:49.200]                       else if (inherits(cond, "condition")) {
[13:37:49.200]                         if (!is.null(pattern)) {
[13:37:49.200]                           computeRestarts <- base::computeRestarts
[13:37:49.200]                           grepl <- base::grepl
[13:37:49.200]                           restarts <- computeRestarts(cond)
[13:37:49.200]                           for (restart in restarts) {
[13:37:49.200]                             name <- restart$name
[13:37:49.200]                             if (is.null(name)) 
[13:37:49.200]                               next
[13:37:49.200]                             if (!grepl(pattern, name)) 
[13:37:49.200]                               next
[13:37:49.200]                             invokeRestart(restart)
[13:37:49.200]                             muffled <- TRUE
[13:37:49.200]                             break
[13:37:49.200]                           }
[13:37:49.200]                         }
[13:37:49.200]                       }
[13:37:49.200]                       invisible(muffled)
[13:37:49.200]                     }
[13:37:49.200]                     muffleCondition(cond, pattern = "^muffle")
[13:37:49.200]                   }
[13:37:49.200]                 }
[13:37:49.200]             }
[13:37:49.200]         }))
[13:37:49.200]     }, error = function(ex) {
[13:37:49.200]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:49.200]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:49.200]                 ...future.rng), started = ...future.startTime, 
[13:37:49.200]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:49.200]             version = "1.8"), class = "FutureResult")
[13:37:49.200]     }, finally = {
[13:37:49.200]         if (!identical(...future.workdir, getwd())) 
[13:37:49.200]             setwd(...future.workdir)
[13:37:49.200]         {
[13:37:49.200]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:49.200]                 ...future.oldOptions$nwarnings <- NULL
[13:37:49.200]             }
[13:37:49.200]             base::options(...future.oldOptions)
[13:37:49.200]             if (.Platform$OS.type == "windows") {
[13:37:49.200]                 old_names <- names(...future.oldEnvVars)
[13:37:49.200]                 envs <- base::Sys.getenv()
[13:37:49.200]                 names <- names(envs)
[13:37:49.200]                 common <- intersect(names, old_names)
[13:37:49.200]                 added <- setdiff(names, old_names)
[13:37:49.200]                 removed <- setdiff(old_names, names)
[13:37:49.200]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:49.200]                   envs[common]]
[13:37:49.200]                 NAMES <- toupper(changed)
[13:37:49.200]                 args <- list()
[13:37:49.200]                 for (kk in seq_along(NAMES)) {
[13:37:49.200]                   name <- changed[[kk]]
[13:37:49.200]                   NAME <- NAMES[[kk]]
[13:37:49.200]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:49.200]                     next
[13:37:49.200]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:49.200]                 }
[13:37:49.200]                 NAMES <- toupper(added)
[13:37:49.200]                 for (kk in seq_along(NAMES)) {
[13:37:49.200]                   name <- added[[kk]]
[13:37:49.200]                   NAME <- NAMES[[kk]]
[13:37:49.200]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:49.200]                     next
[13:37:49.200]                   args[[name]] <- ""
[13:37:49.200]                 }
[13:37:49.200]                 NAMES <- toupper(removed)
[13:37:49.200]                 for (kk in seq_along(NAMES)) {
[13:37:49.200]                   name <- removed[[kk]]
[13:37:49.200]                   NAME <- NAMES[[kk]]
[13:37:49.200]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:49.200]                     next
[13:37:49.200]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:49.200]                 }
[13:37:49.200]                 if (length(args) > 0) 
[13:37:49.200]                   base::do.call(base::Sys.setenv, args = args)
[13:37:49.200]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:49.200]             }
[13:37:49.200]             else {
[13:37:49.200]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:49.200]             }
[13:37:49.200]             {
[13:37:49.200]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:49.200]                   0L) {
[13:37:49.200]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:49.200]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:49.200]                   base::options(opts)
[13:37:49.200]                 }
[13:37:49.200]                 {
[13:37:49.200]                   {
[13:37:49.200]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:49.200]                     NULL
[13:37:49.200]                   }
[13:37:49.200]                   options(future.plan = NULL)
[13:37:49.200]                   if (is.na(NA_character_)) 
[13:37:49.200]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:49.200]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:49.200]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:49.200]                     .init = FALSE)
[13:37:49.200]                 }
[13:37:49.200]             }
[13:37:49.200]         }
[13:37:49.200]     })
[13:37:49.200]     if (TRUE) {
[13:37:49.200]         base::sink(type = "output", split = FALSE)
[13:37:49.200]         if (TRUE) {
[13:37:49.200]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:49.200]         }
[13:37:49.200]         else {
[13:37:49.200]             ...future.result["stdout"] <- base::list(NULL)
[13:37:49.200]         }
[13:37:49.200]         base::close(...future.stdout)
[13:37:49.200]         ...future.stdout <- NULL
[13:37:49.200]     }
[13:37:49.200]     ...future.result$conditions <- ...future.conditions
[13:37:49.200]     ...future.result$finished <- base::Sys.time()
[13:37:49.200]     ...future.result
[13:37:49.200] }
[13:37:49.203] MultisessionFuture started
[13:37:49.206] - Launch lazy future ... done
[13:37:49.206] run() for ‘MultisessionFuture’ ... done
[13:37:49.207] receiveMessageFromWorker() for ClusterFuture ...
[13:37:49.207] - Validating connection of MultisessionFuture
[13:37:49.207] - received message: FutureResult
[13:37:49.207] - Received FutureResult
[13:37:49.207] - Erased future from FutureRegistry
[13:37:49.207] result() for ClusterFuture ...
[13:37:49.207] - result already collected: FutureResult
[13:37:49.208] result() for ClusterFuture ... done
[13:37:49.208] signalConditions() ...
[13:37:49.208]  - include = ‘immediateCondition’
[13:37:49.208]  - exclude = 
[13:37:49.208]  - resignal = FALSE
[13:37:49.208]  - Number of conditions: 1
[13:37:49.208] signalConditions() ... done
[13:37:49.208] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:49.208] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = TRUE ... DONE
- result = FALSE, recursive = -1 ...
[13:37:49.208] getGlobalsAndPackages() ...
[13:37:49.209] Searching for globals...
[13:37:49.210] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:37:49.210] Searching for globals ... DONE
[13:37:49.210] Resolving globals: FALSE
[13:37:49.210] 
[13:37:49.210] 
[13:37:49.210] getGlobalsAndPackages() ... DONE
[13:37:49.211] run() for ‘Future’ ...
[13:37:49.211] - state: ‘created’
[13:37:49.211] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:49.224] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:49.224] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:49.224]   - Field: ‘node’
[13:37:49.224]   - Field: ‘label’
[13:37:49.224]   - Field: ‘local’
[13:37:49.225]   - Field: ‘owner’
[13:37:49.225]   - Field: ‘envir’
[13:37:49.225]   - Field: ‘workers’
[13:37:49.225]   - Field: ‘packages’
[13:37:49.225]   - Field: ‘gc’
[13:37:49.225]   - Field: ‘conditions’
[13:37:49.225]   - Field: ‘persistent’
[13:37:49.225]   - Field: ‘expr’
[13:37:49.225]   - Field: ‘uuid’
[13:37:49.225]   - Field: ‘seed’
[13:37:49.225]   - Field: ‘version’
[13:37:49.226]   - Field: ‘result’
[13:37:49.226]   - Field: ‘asynchronous’
[13:37:49.226]   - Field: ‘calls’
[13:37:49.226]   - Field: ‘globals’
[13:37:49.226]   - Field: ‘stdout’
[13:37:49.226]   - Field: ‘earlySignal’
[13:37:49.226]   - Field: ‘lazy’
[13:37:49.226]   - Field: ‘state’
[13:37:49.226] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:49.226] - Launch lazy future ...
[13:37:49.227] Packages needed by the future expression (n = 0): <none>
[13:37:49.227] Packages needed by future strategies (n = 0): <none>
[13:37:49.227] {
[13:37:49.227]     {
[13:37:49.227]         {
[13:37:49.227]             ...future.startTime <- base::Sys.time()
[13:37:49.227]             {
[13:37:49.227]                 {
[13:37:49.227]                   {
[13:37:49.227]                     {
[13:37:49.227]                       base::local({
[13:37:49.227]                         has_future <- base::requireNamespace("future", 
[13:37:49.227]                           quietly = TRUE)
[13:37:49.227]                         if (has_future) {
[13:37:49.227]                           ns <- base::getNamespace("future")
[13:37:49.227]                           version <- ns[[".package"]][["version"]]
[13:37:49.227]                           if (is.null(version)) 
[13:37:49.227]                             version <- utils::packageVersion("future")
[13:37:49.227]                         }
[13:37:49.227]                         else {
[13:37:49.227]                           version <- NULL
[13:37:49.227]                         }
[13:37:49.227]                         if (!has_future || version < "1.8.0") {
[13:37:49.227]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:49.227]                             "", base::R.version$version.string), 
[13:37:49.227]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:49.227]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:49.227]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:49.227]                               "release", "version")], collapse = " "), 
[13:37:49.227]                             hostname = base::Sys.info()[["nodename"]])
[13:37:49.227]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:49.227]                             info)
[13:37:49.227]                           info <- base::paste(info, collapse = "; ")
[13:37:49.227]                           if (!has_future) {
[13:37:49.227]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:49.227]                               info)
[13:37:49.227]                           }
[13:37:49.227]                           else {
[13:37:49.227]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:49.227]                               info, version)
[13:37:49.227]                           }
[13:37:49.227]                           base::stop(msg)
[13:37:49.227]                         }
[13:37:49.227]                       })
[13:37:49.227]                     }
[13:37:49.227]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:49.227]                     base::options(mc.cores = 1L)
[13:37:49.227]                   }
[13:37:49.227]                   ...future.strategy.old <- future::plan("list")
[13:37:49.227]                   options(future.plan = NULL)
[13:37:49.227]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:49.227]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:49.227]                 }
[13:37:49.227]                 ...future.workdir <- getwd()
[13:37:49.227]             }
[13:37:49.227]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:49.227]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:49.227]         }
[13:37:49.227]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:49.227]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:49.227]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:49.227]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:49.227]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:49.227]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:49.227]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:49.227]             base::names(...future.oldOptions))
[13:37:49.227]     }
[13:37:49.227]     if (FALSE) {
[13:37:49.227]     }
[13:37:49.227]     else {
[13:37:49.227]         if (TRUE) {
[13:37:49.227]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:49.227]                 open = "w")
[13:37:49.227]         }
[13:37:49.227]         else {
[13:37:49.227]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:49.227]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:49.227]         }
[13:37:49.227]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:49.227]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:49.227]             base::sink(type = "output", split = FALSE)
[13:37:49.227]             base::close(...future.stdout)
[13:37:49.227]         }, add = TRUE)
[13:37:49.227]     }
[13:37:49.227]     ...future.frame <- base::sys.nframe()
[13:37:49.227]     ...future.conditions <- base::list()
[13:37:49.227]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:49.227]     if (FALSE) {
[13:37:49.227]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:49.227]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:49.227]     }
[13:37:49.227]     ...future.result <- base::tryCatch({
[13:37:49.227]         base::withCallingHandlers({
[13:37:49.227]             ...future.value <- base::withVisible(base::local({
[13:37:49.227]                 ...future.makeSendCondition <- base::local({
[13:37:49.227]                   sendCondition <- NULL
[13:37:49.227]                   function(frame = 1L) {
[13:37:49.227]                     if (is.function(sendCondition)) 
[13:37:49.227]                       return(sendCondition)
[13:37:49.227]                     ns <- getNamespace("parallel")
[13:37:49.227]                     if (exists("sendData", mode = "function", 
[13:37:49.227]                       envir = ns)) {
[13:37:49.227]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:49.227]                         envir = ns)
[13:37:49.227]                       envir <- sys.frame(frame)
[13:37:49.227]                       master <- NULL
[13:37:49.227]                       while (!identical(envir, .GlobalEnv) && 
[13:37:49.227]                         !identical(envir, emptyenv())) {
[13:37:49.227]                         if (exists("master", mode = "list", envir = envir, 
[13:37:49.227]                           inherits = FALSE)) {
[13:37:49.227]                           master <- get("master", mode = "list", 
[13:37:49.227]                             envir = envir, inherits = FALSE)
[13:37:49.227]                           if (inherits(master, c("SOCKnode", 
[13:37:49.227]                             "SOCK0node"))) {
[13:37:49.227]                             sendCondition <<- function(cond) {
[13:37:49.227]                               data <- list(type = "VALUE", value = cond, 
[13:37:49.227]                                 success = TRUE)
[13:37:49.227]                               parallel_sendData(master, data)
[13:37:49.227]                             }
[13:37:49.227]                             return(sendCondition)
[13:37:49.227]                           }
[13:37:49.227]                         }
[13:37:49.227]                         frame <- frame + 1L
[13:37:49.227]                         envir <- sys.frame(frame)
[13:37:49.227]                       }
[13:37:49.227]                     }
[13:37:49.227]                     sendCondition <<- function(cond) NULL
[13:37:49.227]                   }
[13:37:49.227]                 })
[13:37:49.227]                 withCallingHandlers({
[13:37:49.227]                   {
[13:37:49.227]                     Sys.sleep(0.5)
[13:37:49.227]                     list(a = 1, b = 42L)
[13:37:49.227]                   }
[13:37:49.227]                 }, immediateCondition = function(cond) {
[13:37:49.227]                   sendCondition <- ...future.makeSendCondition()
[13:37:49.227]                   sendCondition(cond)
[13:37:49.227]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:49.227]                   {
[13:37:49.227]                     inherits <- base::inherits
[13:37:49.227]                     invokeRestart <- base::invokeRestart
[13:37:49.227]                     is.null <- base::is.null
[13:37:49.227]                     muffled <- FALSE
[13:37:49.227]                     if (inherits(cond, "message")) {
[13:37:49.227]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:49.227]                       if (muffled) 
[13:37:49.227]                         invokeRestart("muffleMessage")
[13:37:49.227]                     }
[13:37:49.227]                     else if (inherits(cond, "warning")) {
[13:37:49.227]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:49.227]                       if (muffled) 
[13:37:49.227]                         invokeRestart("muffleWarning")
[13:37:49.227]                     }
[13:37:49.227]                     else if (inherits(cond, "condition")) {
[13:37:49.227]                       if (!is.null(pattern)) {
[13:37:49.227]                         computeRestarts <- base::computeRestarts
[13:37:49.227]                         grepl <- base::grepl
[13:37:49.227]                         restarts <- computeRestarts(cond)
[13:37:49.227]                         for (restart in restarts) {
[13:37:49.227]                           name <- restart$name
[13:37:49.227]                           if (is.null(name)) 
[13:37:49.227]                             next
[13:37:49.227]                           if (!grepl(pattern, name)) 
[13:37:49.227]                             next
[13:37:49.227]                           invokeRestart(restart)
[13:37:49.227]                           muffled <- TRUE
[13:37:49.227]                           break
[13:37:49.227]                         }
[13:37:49.227]                       }
[13:37:49.227]                     }
[13:37:49.227]                     invisible(muffled)
[13:37:49.227]                   }
[13:37:49.227]                   muffleCondition(cond)
[13:37:49.227]                 })
[13:37:49.227]             }))
[13:37:49.227]             future::FutureResult(value = ...future.value$value, 
[13:37:49.227]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:49.227]                   ...future.rng), globalenv = if (FALSE) 
[13:37:49.227]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:49.227]                     ...future.globalenv.names))
[13:37:49.227]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:49.227]         }, condition = base::local({
[13:37:49.227]             c <- base::c
[13:37:49.227]             inherits <- base::inherits
[13:37:49.227]             invokeRestart <- base::invokeRestart
[13:37:49.227]             length <- base::length
[13:37:49.227]             list <- base::list
[13:37:49.227]             seq.int <- base::seq.int
[13:37:49.227]             signalCondition <- base::signalCondition
[13:37:49.227]             sys.calls <- base::sys.calls
[13:37:49.227]             `[[` <- base::`[[`
[13:37:49.227]             `+` <- base::`+`
[13:37:49.227]             `<<-` <- base::`<<-`
[13:37:49.227]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:49.227]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:49.227]                   3L)]
[13:37:49.227]             }
[13:37:49.227]             function(cond) {
[13:37:49.227]                 is_error <- inherits(cond, "error")
[13:37:49.227]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:49.227]                   NULL)
[13:37:49.227]                 if (is_error) {
[13:37:49.227]                   sessionInformation <- function() {
[13:37:49.227]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:49.227]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:49.227]                       search = base::search(), system = base::Sys.info())
[13:37:49.227]                   }
[13:37:49.227]                   ...future.conditions[[length(...future.conditions) + 
[13:37:49.227]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:49.227]                     cond$call), session = sessionInformation(), 
[13:37:49.227]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:49.227]                   signalCondition(cond)
[13:37:49.227]                 }
[13:37:49.227]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:49.227]                 "immediateCondition"))) {
[13:37:49.227]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:49.227]                   ...future.conditions[[length(...future.conditions) + 
[13:37:49.227]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:49.227]                   if (TRUE && !signal) {
[13:37:49.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:49.227]                     {
[13:37:49.227]                       inherits <- base::inherits
[13:37:49.227]                       invokeRestart <- base::invokeRestart
[13:37:49.227]                       is.null <- base::is.null
[13:37:49.227]                       muffled <- FALSE
[13:37:49.227]                       if (inherits(cond, "message")) {
[13:37:49.227]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:49.227]                         if (muffled) 
[13:37:49.227]                           invokeRestart("muffleMessage")
[13:37:49.227]                       }
[13:37:49.227]                       else if (inherits(cond, "warning")) {
[13:37:49.227]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:49.227]                         if (muffled) 
[13:37:49.227]                           invokeRestart("muffleWarning")
[13:37:49.227]                       }
[13:37:49.227]                       else if (inherits(cond, "condition")) {
[13:37:49.227]                         if (!is.null(pattern)) {
[13:37:49.227]                           computeRestarts <- base::computeRestarts
[13:37:49.227]                           grepl <- base::grepl
[13:37:49.227]                           restarts <- computeRestarts(cond)
[13:37:49.227]                           for (restart in restarts) {
[13:37:49.227]                             name <- restart$name
[13:37:49.227]                             if (is.null(name)) 
[13:37:49.227]                               next
[13:37:49.227]                             if (!grepl(pattern, name)) 
[13:37:49.227]                               next
[13:37:49.227]                             invokeRestart(restart)
[13:37:49.227]                             muffled <- TRUE
[13:37:49.227]                             break
[13:37:49.227]                           }
[13:37:49.227]                         }
[13:37:49.227]                       }
[13:37:49.227]                       invisible(muffled)
[13:37:49.227]                     }
[13:37:49.227]                     muffleCondition(cond, pattern = "^muffle")
[13:37:49.227]                   }
[13:37:49.227]                 }
[13:37:49.227]                 else {
[13:37:49.227]                   if (TRUE) {
[13:37:49.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:49.227]                     {
[13:37:49.227]                       inherits <- base::inherits
[13:37:49.227]                       invokeRestart <- base::invokeRestart
[13:37:49.227]                       is.null <- base::is.null
[13:37:49.227]                       muffled <- FALSE
[13:37:49.227]                       if (inherits(cond, "message")) {
[13:37:49.227]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:49.227]                         if (muffled) 
[13:37:49.227]                           invokeRestart("muffleMessage")
[13:37:49.227]                       }
[13:37:49.227]                       else if (inherits(cond, "warning")) {
[13:37:49.227]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:49.227]                         if (muffled) 
[13:37:49.227]                           invokeRestart("muffleWarning")
[13:37:49.227]                       }
[13:37:49.227]                       else if (inherits(cond, "condition")) {
[13:37:49.227]                         if (!is.null(pattern)) {
[13:37:49.227]                           computeRestarts <- base::computeRestarts
[13:37:49.227]                           grepl <- base::grepl
[13:37:49.227]                           restarts <- computeRestarts(cond)
[13:37:49.227]                           for (restart in restarts) {
[13:37:49.227]                             name <- restart$name
[13:37:49.227]                             if (is.null(name)) 
[13:37:49.227]                               next
[13:37:49.227]                             if (!grepl(pattern, name)) 
[13:37:49.227]                               next
[13:37:49.227]                             invokeRestart(restart)
[13:37:49.227]                             muffled <- TRUE
[13:37:49.227]                             break
[13:37:49.227]                           }
[13:37:49.227]                         }
[13:37:49.227]                       }
[13:37:49.227]                       invisible(muffled)
[13:37:49.227]                     }
[13:37:49.227]                     muffleCondition(cond, pattern = "^muffle")
[13:37:49.227]                   }
[13:37:49.227]                 }
[13:37:49.227]             }
[13:37:49.227]         }))
[13:37:49.227]     }, error = function(ex) {
[13:37:49.227]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:49.227]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:49.227]                 ...future.rng), started = ...future.startTime, 
[13:37:49.227]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:49.227]             version = "1.8"), class = "FutureResult")
[13:37:49.227]     }, finally = {
[13:37:49.227]         if (!identical(...future.workdir, getwd())) 
[13:37:49.227]             setwd(...future.workdir)
[13:37:49.227]         {
[13:37:49.227]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:49.227]                 ...future.oldOptions$nwarnings <- NULL
[13:37:49.227]             }
[13:37:49.227]             base::options(...future.oldOptions)
[13:37:49.227]             if (.Platform$OS.type == "windows") {
[13:37:49.227]                 old_names <- names(...future.oldEnvVars)
[13:37:49.227]                 envs <- base::Sys.getenv()
[13:37:49.227]                 names <- names(envs)
[13:37:49.227]                 common <- intersect(names, old_names)
[13:37:49.227]                 added <- setdiff(names, old_names)
[13:37:49.227]                 removed <- setdiff(old_names, names)
[13:37:49.227]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:49.227]                   envs[common]]
[13:37:49.227]                 NAMES <- toupper(changed)
[13:37:49.227]                 args <- list()
[13:37:49.227]                 for (kk in seq_along(NAMES)) {
[13:37:49.227]                   name <- changed[[kk]]
[13:37:49.227]                   NAME <- NAMES[[kk]]
[13:37:49.227]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:49.227]                     next
[13:37:49.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:49.227]                 }
[13:37:49.227]                 NAMES <- toupper(added)
[13:37:49.227]                 for (kk in seq_along(NAMES)) {
[13:37:49.227]                   name <- added[[kk]]
[13:37:49.227]                   NAME <- NAMES[[kk]]
[13:37:49.227]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:49.227]                     next
[13:37:49.227]                   args[[name]] <- ""
[13:37:49.227]                 }
[13:37:49.227]                 NAMES <- toupper(removed)
[13:37:49.227]                 for (kk in seq_along(NAMES)) {
[13:37:49.227]                   name <- removed[[kk]]
[13:37:49.227]                   NAME <- NAMES[[kk]]
[13:37:49.227]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:49.227]                     next
[13:37:49.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:49.227]                 }
[13:37:49.227]                 if (length(args) > 0) 
[13:37:49.227]                   base::do.call(base::Sys.setenv, args = args)
[13:37:49.227]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:49.227]             }
[13:37:49.227]             else {
[13:37:49.227]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:49.227]             }
[13:37:49.227]             {
[13:37:49.227]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:49.227]                   0L) {
[13:37:49.227]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:49.227]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:49.227]                   base::options(opts)
[13:37:49.227]                 }
[13:37:49.227]                 {
[13:37:49.227]                   {
[13:37:49.227]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:49.227]                     NULL
[13:37:49.227]                   }
[13:37:49.227]                   options(future.plan = NULL)
[13:37:49.227]                   if (is.na(NA_character_)) 
[13:37:49.227]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:49.227]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:49.227]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:49.227]                     .init = FALSE)
[13:37:49.227]                 }
[13:37:49.227]             }
[13:37:49.227]         }
[13:37:49.227]     })
[13:37:49.227]     if (TRUE) {
[13:37:49.227]         base::sink(type = "output", split = FALSE)
[13:37:49.227]         if (TRUE) {
[13:37:49.227]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:49.227]         }
[13:37:49.227]         else {
[13:37:49.227]             ...future.result["stdout"] <- base::list(NULL)
[13:37:49.227]         }
[13:37:49.227]         base::close(...future.stdout)
[13:37:49.227]         ...future.stdout <- NULL
[13:37:49.227]     }
[13:37:49.227]     ...future.result$conditions <- ...future.conditions
[13:37:49.227]     ...future.result$finished <- base::Sys.time()
[13:37:49.227]     ...future.result
[13:37:49.227] }
[13:37:49.230] MultisessionFuture started
[13:37:49.230] - Launch lazy future ... done
[13:37:49.230] run() for ‘MultisessionFuture’ ... done
[13:37:49.230] getGlobalsAndPackages() ...
[13:37:49.230] Searching for globals...
[13:37:49.231] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:37:49.231] Searching for globals ... DONE
[13:37:49.232] Resolving globals: FALSE
[13:37:49.232] 
[13:37:49.232] 
[13:37:49.232] getGlobalsAndPackages() ... DONE
- w/ exception ...
[13:37:49.232] getGlobalsAndPackages() ...
[13:37:49.232] Searching for globals...
[13:37:49.233] - globals found: [2] ‘list’, ‘stop’
[13:37:49.233] Searching for globals ... DONE
[13:37:49.233] Resolving globals: FALSE
[13:37:49.233] 
[13:37:49.233] 
[13:37:49.234] getGlobalsAndPackages() ... DONE
[13:37:49.234] run() for ‘Future’ ...
[13:37:49.234] - state: ‘created’
[13:37:49.234] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:49.247] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:49.248] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:49.248]   - Field: ‘node’
[13:37:49.248]   - Field: ‘label’
[13:37:49.248]   - Field: ‘local’
[13:37:49.248]   - Field: ‘owner’
[13:37:49.248]   - Field: ‘envir’
[13:37:49.248]   - Field: ‘workers’
[13:37:49.248]   - Field: ‘packages’
[13:37:49.248]   - Field: ‘gc’
[13:37:49.248]   - Field: ‘conditions’
[13:37:49.249]   - Field: ‘persistent’
[13:37:49.249]   - Field: ‘expr’
[13:37:49.249]   - Field: ‘uuid’
[13:37:49.249]   - Field: ‘seed’
[13:37:49.249]   - Field: ‘version’
[13:37:49.249]   - Field: ‘result’
[13:37:49.249]   - Field: ‘asynchronous’
[13:37:49.249]   - Field: ‘calls’
[13:37:49.249]   - Field: ‘globals’
[13:37:49.249]   - Field: ‘stdout’
[13:37:49.249]   - Field: ‘earlySignal’
[13:37:49.250]   - Field: ‘lazy’
[13:37:49.250]   - Field: ‘state’
[13:37:49.250] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:49.250] - Launch lazy future ...
[13:37:49.250] Packages needed by the future expression (n = 0): <none>
[13:37:49.250] Packages needed by future strategies (n = 0): <none>
[13:37:49.251] {
[13:37:49.251]     {
[13:37:49.251]         {
[13:37:49.251]             ...future.startTime <- base::Sys.time()
[13:37:49.251]             {
[13:37:49.251]                 {
[13:37:49.251]                   {
[13:37:49.251]                     {
[13:37:49.251]                       base::local({
[13:37:49.251]                         has_future <- base::requireNamespace("future", 
[13:37:49.251]                           quietly = TRUE)
[13:37:49.251]                         if (has_future) {
[13:37:49.251]                           ns <- base::getNamespace("future")
[13:37:49.251]                           version <- ns[[".package"]][["version"]]
[13:37:49.251]                           if (is.null(version)) 
[13:37:49.251]                             version <- utils::packageVersion("future")
[13:37:49.251]                         }
[13:37:49.251]                         else {
[13:37:49.251]                           version <- NULL
[13:37:49.251]                         }
[13:37:49.251]                         if (!has_future || version < "1.8.0") {
[13:37:49.251]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:49.251]                             "", base::R.version$version.string), 
[13:37:49.251]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:49.251]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:49.251]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:49.251]                               "release", "version")], collapse = " "), 
[13:37:49.251]                             hostname = base::Sys.info()[["nodename"]])
[13:37:49.251]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:49.251]                             info)
[13:37:49.251]                           info <- base::paste(info, collapse = "; ")
[13:37:49.251]                           if (!has_future) {
[13:37:49.251]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:49.251]                               info)
[13:37:49.251]                           }
[13:37:49.251]                           else {
[13:37:49.251]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:49.251]                               info, version)
[13:37:49.251]                           }
[13:37:49.251]                           base::stop(msg)
[13:37:49.251]                         }
[13:37:49.251]                       })
[13:37:49.251]                     }
[13:37:49.251]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:49.251]                     base::options(mc.cores = 1L)
[13:37:49.251]                   }
[13:37:49.251]                   ...future.strategy.old <- future::plan("list")
[13:37:49.251]                   options(future.plan = NULL)
[13:37:49.251]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:49.251]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:49.251]                 }
[13:37:49.251]                 ...future.workdir <- getwd()
[13:37:49.251]             }
[13:37:49.251]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:49.251]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:49.251]         }
[13:37:49.251]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:49.251]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:49.251]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:49.251]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:49.251]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:49.251]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:49.251]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:49.251]             base::names(...future.oldOptions))
[13:37:49.251]     }
[13:37:49.251]     if (FALSE) {
[13:37:49.251]     }
[13:37:49.251]     else {
[13:37:49.251]         if (TRUE) {
[13:37:49.251]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:49.251]                 open = "w")
[13:37:49.251]         }
[13:37:49.251]         else {
[13:37:49.251]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:49.251]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:49.251]         }
[13:37:49.251]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:49.251]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:49.251]             base::sink(type = "output", split = FALSE)
[13:37:49.251]             base::close(...future.stdout)
[13:37:49.251]         }, add = TRUE)
[13:37:49.251]     }
[13:37:49.251]     ...future.frame <- base::sys.nframe()
[13:37:49.251]     ...future.conditions <- base::list()
[13:37:49.251]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:49.251]     if (FALSE) {
[13:37:49.251]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:49.251]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:49.251]     }
[13:37:49.251]     ...future.result <- base::tryCatch({
[13:37:49.251]         base::withCallingHandlers({
[13:37:49.251]             ...future.value <- base::withVisible(base::local({
[13:37:49.251]                 ...future.makeSendCondition <- base::local({
[13:37:49.251]                   sendCondition <- NULL
[13:37:49.251]                   function(frame = 1L) {
[13:37:49.251]                     if (is.function(sendCondition)) 
[13:37:49.251]                       return(sendCondition)
[13:37:49.251]                     ns <- getNamespace("parallel")
[13:37:49.251]                     if (exists("sendData", mode = "function", 
[13:37:49.251]                       envir = ns)) {
[13:37:49.251]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:49.251]                         envir = ns)
[13:37:49.251]                       envir <- sys.frame(frame)
[13:37:49.251]                       master <- NULL
[13:37:49.251]                       while (!identical(envir, .GlobalEnv) && 
[13:37:49.251]                         !identical(envir, emptyenv())) {
[13:37:49.251]                         if (exists("master", mode = "list", envir = envir, 
[13:37:49.251]                           inherits = FALSE)) {
[13:37:49.251]                           master <- get("master", mode = "list", 
[13:37:49.251]                             envir = envir, inherits = FALSE)
[13:37:49.251]                           if (inherits(master, c("SOCKnode", 
[13:37:49.251]                             "SOCK0node"))) {
[13:37:49.251]                             sendCondition <<- function(cond) {
[13:37:49.251]                               data <- list(type = "VALUE", value = cond, 
[13:37:49.251]                                 success = TRUE)
[13:37:49.251]                               parallel_sendData(master, data)
[13:37:49.251]                             }
[13:37:49.251]                             return(sendCondition)
[13:37:49.251]                           }
[13:37:49.251]                         }
[13:37:49.251]                         frame <- frame + 1L
[13:37:49.251]                         envir <- sys.frame(frame)
[13:37:49.251]                       }
[13:37:49.251]                     }
[13:37:49.251]                     sendCondition <<- function(cond) NULL
[13:37:49.251]                   }
[13:37:49.251]                 })
[13:37:49.251]                 withCallingHandlers({
[13:37:49.251]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:37:49.251]                 }, immediateCondition = function(cond) {
[13:37:49.251]                   sendCondition <- ...future.makeSendCondition()
[13:37:49.251]                   sendCondition(cond)
[13:37:49.251]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:49.251]                   {
[13:37:49.251]                     inherits <- base::inherits
[13:37:49.251]                     invokeRestart <- base::invokeRestart
[13:37:49.251]                     is.null <- base::is.null
[13:37:49.251]                     muffled <- FALSE
[13:37:49.251]                     if (inherits(cond, "message")) {
[13:37:49.251]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:49.251]                       if (muffled) 
[13:37:49.251]                         invokeRestart("muffleMessage")
[13:37:49.251]                     }
[13:37:49.251]                     else if (inherits(cond, "warning")) {
[13:37:49.251]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:49.251]                       if (muffled) 
[13:37:49.251]                         invokeRestart("muffleWarning")
[13:37:49.251]                     }
[13:37:49.251]                     else if (inherits(cond, "condition")) {
[13:37:49.251]                       if (!is.null(pattern)) {
[13:37:49.251]                         computeRestarts <- base::computeRestarts
[13:37:49.251]                         grepl <- base::grepl
[13:37:49.251]                         restarts <- computeRestarts(cond)
[13:37:49.251]                         for (restart in restarts) {
[13:37:49.251]                           name <- restart$name
[13:37:49.251]                           if (is.null(name)) 
[13:37:49.251]                             next
[13:37:49.251]                           if (!grepl(pattern, name)) 
[13:37:49.251]                             next
[13:37:49.251]                           invokeRestart(restart)
[13:37:49.251]                           muffled <- TRUE
[13:37:49.251]                           break
[13:37:49.251]                         }
[13:37:49.251]                       }
[13:37:49.251]                     }
[13:37:49.251]                     invisible(muffled)
[13:37:49.251]                   }
[13:37:49.251]                   muffleCondition(cond)
[13:37:49.251]                 })
[13:37:49.251]             }))
[13:37:49.251]             future::FutureResult(value = ...future.value$value, 
[13:37:49.251]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:49.251]                   ...future.rng), globalenv = if (FALSE) 
[13:37:49.251]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:49.251]                     ...future.globalenv.names))
[13:37:49.251]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:49.251]         }, condition = base::local({
[13:37:49.251]             c <- base::c
[13:37:49.251]             inherits <- base::inherits
[13:37:49.251]             invokeRestart <- base::invokeRestart
[13:37:49.251]             length <- base::length
[13:37:49.251]             list <- base::list
[13:37:49.251]             seq.int <- base::seq.int
[13:37:49.251]             signalCondition <- base::signalCondition
[13:37:49.251]             sys.calls <- base::sys.calls
[13:37:49.251]             `[[` <- base::`[[`
[13:37:49.251]             `+` <- base::`+`
[13:37:49.251]             `<<-` <- base::`<<-`
[13:37:49.251]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:49.251]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:49.251]                   3L)]
[13:37:49.251]             }
[13:37:49.251]             function(cond) {
[13:37:49.251]                 is_error <- inherits(cond, "error")
[13:37:49.251]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:49.251]                   NULL)
[13:37:49.251]                 if (is_error) {
[13:37:49.251]                   sessionInformation <- function() {
[13:37:49.251]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:49.251]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:49.251]                       search = base::search(), system = base::Sys.info())
[13:37:49.251]                   }
[13:37:49.251]                   ...future.conditions[[length(...future.conditions) + 
[13:37:49.251]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:49.251]                     cond$call), session = sessionInformation(), 
[13:37:49.251]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:49.251]                   signalCondition(cond)
[13:37:49.251]                 }
[13:37:49.251]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:49.251]                 "immediateCondition"))) {
[13:37:49.251]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:49.251]                   ...future.conditions[[length(...future.conditions) + 
[13:37:49.251]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:49.251]                   if (TRUE && !signal) {
[13:37:49.251]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:49.251]                     {
[13:37:49.251]                       inherits <- base::inherits
[13:37:49.251]                       invokeRestart <- base::invokeRestart
[13:37:49.251]                       is.null <- base::is.null
[13:37:49.251]                       muffled <- FALSE
[13:37:49.251]                       if (inherits(cond, "message")) {
[13:37:49.251]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:49.251]                         if (muffled) 
[13:37:49.251]                           invokeRestart("muffleMessage")
[13:37:49.251]                       }
[13:37:49.251]                       else if (inherits(cond, "warning")) {
[13:37:49.251]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:49.251]                         if (muffled) 
[13:37:49.251]                           invokeRestart("muffleWarning")
[13:37:49.251]                       }
[13:37:49.251]                       else if (inherits(cond, "condition")) {
[13:37:49.251]                         if (!is.null(pattern)) {
[13:37:49.251]                           computeRestarts <- base::computeRestarts
[13:37:49.251]                           grepl <- base::grepl
[13:37:49.251]                           restarts <- computeRestarts(cond)
[13:37:49.251]                           for (restart in restarts) {
[13:37:49.251]                             name <- restart$name
[13:37:49.251]                             if (is.null(name)) 
[13:37:49.251]                               next
[13:37:49.251]                             if (!grepl(pattern, name)) 
[13:37:49.251]                               next
[13:37:49.251]                             invokeRestart(restart)
[13:37:49.251]                             muffled <- TRUE
[13:37:49.251]                             break
[13:37:49.251]                           }
[13:37:49.251]                         }
[13:37:49.251]                       }
[13:37:49.251]                       invisible(muffled)
[13:37:49.251]                     }
[13:37:49.251]                     muffleCondition(cond, pattern = "^muffle")
[13:37:49.251]                   }
[13:37:49.251]                 }
[13:37:49.251]                 else {
[13:37:49.251]                   if (TRUE) {
[13:37:49.251]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:49.251]                     {
[13:37:49.251]                       inherits <- base::inherits
[13:37:49.251]                       invokeRestart <- base::invokeRestart
[13:37:49.251]                       is.null <- base::is.null
[13:37:49.251]                       muffled <- FALSE
[13:37:49.251]                       if (inherits(cond, "message")) {
[13:37:49.251]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:49.251]                         if (muffled) 
[13:37:49.251]                           invokeRestart("muffleMessage")
[13:37:49.251]                       }
[13:37:49.251]                       else if (inherits(cond, "warning")) {
[13:37:49.251]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:49.251]                         if (muffled) 
[13:37:49.251]                           invokeRestart("muffleWarning")
[13:37:49.251]                       }
[13:37:49.251]                       else if (inherits(cond, "condition")) {
[13:37:49.251]                         if (!is.null(pattern)) {
[13:37:49.251]                           computeRestarts <- base::computeRestarts
[13:37:49.251]                           grepl <- base::grepl
[13:37:49.251]                           restarts <- computeRestarts(cond)
[13:37:49.251]                           for (restart in restarts) {
[13:37:49.251]                             name <- restart$name
[13:37:49.251]                             if (is.null(name)) 
[13:37:49.251]                               next
[13:37:49.251]                             if (!grepl(pattern, name)) 
[13:37:49.251]                               next
[13:37:49.251]                             invokeRestart(restart)
[13:37:49.251]                             muffled <- TRUE
[13:37:49.251]                             break
[13:37:49.251]                           }
[13:37:49.251]                         }
[13:37:49.251]                       }
[13:37:49.251]                       invisible(muffled)
[13:37:49.251]                     }
[13:37:49.251]                     muffleCondition(cond, pattern = "^muffle")
[13:37:49.251]                   }
[13:37:49.251]                 }
[13:37:49.251]             }
[13:37:49.251]         }))
[13:37:49.251]     }, error = function(ex) {
[13:37:49.251]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:49.251]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:49.251]                 ...future.rng), started = ...future.startTime, 
[13:37:49.251]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:49.251]             version = "1.8"), class = "FutureResult")
[13:37:49.251]     }, finally = {
[13:37:49.251]         if (!identical(...future.workdir, getwd())) 
[13:37:49.251]             setwd(...future.workdir)
[13:37:49.251]         {
[13:37:49.251]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:49.251]                 ...future.oldOptions$nwarnings <- NULL
[13:37:49.251]             }
[13:37:49.251]             base::options(...future.oldOptions)
[13:37:49.251]             if (.Platform$OS.type == "windows") {
[13:37:49.251]                 old_names <- names(...future.oldEnvVars)
[13:37:49.251]                 envs <- base::Sys.getenv()
[13:37:49.251]                 names <- names(envs)
[13:37:49.251]                 common <- intersect(names, old_names)
[13:37:49.251]                 added <- setdiff(names, old_names)
[13:37:49.251]                 removed <- setdiff(old_names, names)
[13:37:49.251]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:49.251]                   envs[common]]
[13:37:49.251]                 NAMES <- toupper(changed)
[13:37:49.251]                 args <- list()
[13:37:49.251]                 for (kk in seq_along(NAMES)) {
[13:37:49.251]                   name <- changed[[kk]]
[13:37:49.251]                   NAME <- NAMES[[kk]]
[13:37:49.251]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:49.251]                     next
[13:37:49.251]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:49.251]                 }
[13:37:49.251]                 NAMES <- toupper(added)
[13:37:49.251]                 for (kk in seq_along(NAMES)) {
[13:37:49.251]                   name <- added[[kk]]
[13:37:49.251]                   NAME <- NAMES[[kk]]
[13:37:49.251]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:49.251]                     next
[13:37:49.251]                   args[[name]] <- ""
[13:37:49.251]                 }
[13:37:49.251]                 NAMES <- toupper(removed)
[13:37:49.251]                 for (kk in seq_along(NAMES)) {
[13:37:49.251]                   name <- removed[[kk]]
[13:37:49.251]                   NAME <- NAMES[[kk]]
[13:37:49.251]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:49.251]                     next
[13:37:49.251]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:49.251]                 }
[13:37:49.251]                 if (length(args) > 0) 
[13:37:49.251]                   base::do.call(base::Sys.setenv, args = args)
[13:37:49.251]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:49.251]             }
[13:37:49.251]             else {
[13:37:49.251]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:49.251]             }
[13:37:49.251]             {
[13:37:49.251]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:49.251]                   0L) {
[13:37:49.251]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:49.251]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:49.251]                   base::options(opts)
[13:37:49.251]                 }
[13:37:49.251]                 {
[13:37:49.251]                   {
[13:37:49.251]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:49.251]                     NULL
[13:37:49.251]                   }
[13:37:49.251]                   options(future.plan = NULL)
[13:37:49.251]                   if (is.na(NA_character_)) 
[13:37:49.251]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:49.251]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:49.251]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:49.251]                     .init = FALSE)
[13:37:49.251]                 }
[13:37:49.251]             }
[13:37:49.251]         }
[13:37:49.251]     })
[13:37:49.251]     if (TRUE) {
[13:37:49.251]         base::sink(type = "output", split = FALSE)
[13:37:49.251]         if (TRUE) {
[13:37:49.251]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:49.251]         }
[13:37:49.251]         else {
[13:37:49.251]             ...future.result["stdout"] <- base::list(NULL)
[13:37:49.251]         }
[13:37:49.251]         base::close(...future.stdout)
[13:37:49.251]         ...future.stdout <- NULL
[13:37:49.251]     }
[13:37:49.251]     ...future.result$conditions <- ...future.conditions
[13:37:49.251]     ...future.result$finished <- base::Sys.time()
[13:37:49.251]     ...future.result
[13:37:49.251] }
[13:37:49.304] MultisessionFuture started
[13:37:49.304] - Launch lazy future ... done
[13:37:49.304] run() for ‘MultisessionFuture’ ... done
[13:37:49.305] getGlobalsAndPackages() ...
[13:37:49.305] Searching for globals...
[13:37:49.305] - globals found: [2] ‘list’, ‘stop’
[13:37:49.306] Searching for globals ... DONE
[13:37:49.306] Resolving globals: FALSE
[13:37:49.306] 
[13:37:49.306] 
[13:37:49.306] getGlobalsAndPackages() ... DONE
- result = FALSE, recursive = -1 ... DONE
- result = FALSE, recursive = 0 ...
[13:37:49.307] getGlobalsAndPackages() ...
[13:37:49.307] Searching for globals...
[13:37:49.308] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:37:49.308] Searching for globals ... DONE
[13:37:49.308] Resolving globals: FALSE
[13:37:49.309] 
[13:37:49.309] 
[13:37:49.309] getGlobalsAndPackages() ... DONE
[13:37:49.309] run() for ‘Future’ ...
[13:37:49.309] - state: ‘created’
[13:37:49.309] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:49.326] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:49.326] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:49.326]   - Field: ‘node’
[13:37:49.326]   - Field: ‘label’
[13:37:49.326]   - Field: ‘local’
[13:37:49.327]   - Field: ‘owner’
[13:37:49.327]   - Field: ‘envir’
[13:37:49.327]   - Field: ‘workers’
[13:37:49.327]   - Field: ‘packages’
[13:37:49.327]   - Field: ‘gc’
[13:37:49.327]   - Field: ‘conditions’
[13:37:49.328]   - Field: ‘persistent’
[13:37:49.328]   - Field: ‘expr’
[13:37:49.328]   - Field: ‘uuid’
[13:37:49.328]   - Field: ‘seed’
[13:37:49.328]   - Field: ‘version’
[13:37:49.328]   - Field: ‘result’
[13:37:49.329]   - Field: ‘asynchronous’
[13:37:49.329]   - Field: ‘calls’
[13:37:49.329]   - Field: ‘globals’
[13:37:49.329]   - Field: ‘stdout’
[13:37:49.329]   - Field: ‘earlySignal’
[13:37:49.329]   - Field: ‘lazy’
[13:37:49.330]   - Field: ‘state’
[13:37:49.330] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:49.330] - Launch lazy future ...
[13:37:49.330] Packages needed by the future expression (n = 0): <none>
[13:37:49.331] Packages needed by future strategies (n = 0): <none>
[13:37:49.331] {
[13:37:49.331]     {
[13:37:49.331]         {
[13:37:49.331]             ...future.startTime <- base::Sys.time()
[13:37:49.331]             {
[13:37:49.331]                 {
[13:37:49.331]                   {
[13:37:49.331]                     {
[13:37:49.331]                       base::local({
[13:37:49.331]                         has_future <- base::requireNamespace("future", 
[13:37:49.331]                           quietly = TRUE)
[13:37:49.331]                         if (has_future) {
[13:37:49.331]                           ns <- base::getNamespace("future")
[13:37:49.331]                           version <- ns[[".package"]][["version"]]
[13:37:49.331]                           if (is.null(version)) 
[13:37:49.331]                             version <- utils::packageVersion("future")
[13:37:49.331]                         }
[13:37:49.331]                         else {
[13:37:49.331]                           version <- NULL
[13:37:49.331]                         }
[13:37:49.331]                         if (!has_future || version < "1.8.0") {
[13:37:49.331]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:49.331]                             "", base::R.version$version.string), 
[13:37:49.331]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:49.331]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:49.331]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:49.331]                               "release", "version")], collapse = " "), 
[13:37:49.331]                             hostname = base::Sys.info()[["nodename"]])
[13:37:49.331]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:49.331]                             info)
[13:37:49.331]                           info <- base::paste(info, collapse = "; ")
[13:37:49.331]                           if (!has_future) {
[13:37:49.331]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:49.331]                               info)
[13:37:49.331]                           }
[13:37:49.331]                           else {
[13:37:49.331]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:49.331]                               info, version)
[13:37:49.331]                           }
[13:37:49.331]                           base::stop(msg)
[13:37:49.331]                         }
[13:37:49.331]                       })
[13:37:49.331]                     }
[13:37:49.331]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:49.331]                     base::options(mc.cores = 1L)
[13:37:49.331]                   }
[13:37:49.331]                   ...future.strategy.old <- future::plan("list")
[13:37:49.331]                   options(future.plan = NULL)
[13:37:49.331]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:49.331]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:49.331]                 }
[13:37:49.331]                 ...future.workdir <- getwd()
[13:37:49.331]             }
[13:37:49.331]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:49.331]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:49.331]         }
[13:37:49.331]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:49.331]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:49.331]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:49.331]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:49.331]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:49.331]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:49.331]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:49.331]             base::names(...future.oldOptions))
[13:37:49.331]     }
[13:37:49.331]     if (FALSE) {
[13:37:49.331]     }
[13:37:49.331]     else {
[13:37:49.331]         if (TRUE) {
[13:37:49.331]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:49.331]                 open = "w")
[13:37:49.331]         }
[13:37:49.331]         else {
[13:37:49.331]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:49.331]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:49.331]         }
[13:37:49.331]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:49.331]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:49.331]             base::sink(type = "output", split = FALSE)
[13:37:49.331]             base::close(...future.stdout)
[13:37:49.331]         }, add = TRUE)
[13:37:49.331]     }
[13:37:49.331]     ...future.frame <- base::sys.nframe()
[13:37:49.331]     ...future.conditions <- base::list()
[13:37:49.331]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:49.331]     if (FALSE) {
[13:37:49.331]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:49.331]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:49.331]     }
[13:37:49.331]     ...future.result <- base::tryCatch({
[13:37:49.331]         base::withCallingHandlers({
[13:37:49.331]             ...future.value <- base::withVisible(base::local({
[13:37:49.331]                 ...future.makeSendCondition <- base::local({
[13:37:49.331]                   sendCondition <- NULL
[13:37:49.331]                   function(frame = 1L) {
[13:37:49.331]                     if (is.function(sendCondition)) 
[13:37:49.331]                       return(sendCondition)
[13:37:49.331]                     ns <- getNamespace("parallel")
[13:37:49.331]                     if (exists("sendData", mode = "function", 
[13:37:49.331]                       envir = ns)) {
[13:37:49.331]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:49.331]                         envir = ns)
[13:37:49.331]                       envir <- sys.frame(frame)
[13:37:49.331]                       master <- NULL
[13:37:49.331]                       while (!identical(envir, .GlobalEnv) && 
[13:37:49.331]                         !identical(envir, emptyenv())) {
[13:37:49.331]                         if (exists("master", mode = "list", envir = envir, 
[13:37:49.331]                           inherits = FALSE)) {
[13:37:49.331]                           master <- get("master", mode = "list", 
[13:37:49.331]                             envir = envir, inherits = FALSE)
[13:37:49.331]                           if (inherits(master, c("SOCKnode", 
[13:37:49.331]                             "SOCK0node"))) {
[13:37:49.331]                             sendCondition <<- function(cond) {
[13:37:49.331]                               data <- list(type = "VALUE", value = cond, 
[13:37:49.331]                                 success = TRUE)
[13:37:49.331]                               parallel_sendData(master, data)
[13:37:49.331]                             }
[13:37:49.331]                             return(sendCondition)
[13:37:49.331]                           }
[13:37:49.331]                         }
[13:37:49.331]                         frame <- frame + 1L
[13:37:49.331]                         envir <- sys.frame(frame)
[13:37:49.331]                       }
[13:37:49.331]                     }
[13:37:49.331]                     sendCondition <<- function(cond) NULL
[13:37:49.331]                   }
[13:37:49.331]                 })
[13:37:49.331]                 withCallingHandlers({
[13:37:49.331]                   {
[13:37:49.331]                     Sys.sleep(0.5)
[13:37:49.331]                     list(a = 1, b = 42L)
[13:37:49.331]                   }
[13:37:49.331]                 }, immediateCondition = function(cond) {
[13:37:49.331]                   sendCondition <- ...future.makeSendCondition()
[13:37:49.331]                   sendCondition(cond)
[13:37:49.331]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:49.331]                   {
[13:37:49.331]                     inherits <- base::inherits
[13:37:49.331]                     invokeRestart <- base::invokeRestart
[13:37:49.331]                     is.null <- base::is.null
[13:37:49.331]                     muffled <- FALSE
[13:37:49.331]                     if (inherits(cond, "message")) {
[13:37:49.331]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:49.331]                       if (muffled) 
[13:37:49.331]                         invokeRestart("muffleMessage")
[13:37:49.331]                     }
[13:37:49.331]                     else if (inherits(cond, "warning")) {
[13:37:49.331]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:49.331]                       if (muffled) 
[13:37:49.331]                         invokeRestart("muffleWarning")
[13:37:49.331]                     }
[13:37:49.331]                     else if (inherits(cond, "condition")) {
[13:37:49.331]                       if (!is.null(pattern)) {
[13:37:49.331]                         computeRestarts <- base::computeRestarts
[13:37:49.331]                         grepl <- base::grepl
[13:37:49.331]                         restarts <- computeRestarts(cond)
[13:37:49.331]                         for (restart in restarts) {
[13:37:49.331]                           name <- restart$name
[13:37:49.331]                           if (is.null(name)) 
[13:37:49.331]                             next
[13:37:49.331]                           if (!grepl(pattern, name)) 
[13:37:49.331]                             next
[13:37:49.331]                           invokeRestart(restart)
[13:37:49.331]                           muffled <- TRUE
[13:37:49.331]                           break
[13:37:49.331]                         }
[13:37:49.331]                       }
[13:37:49.331]                     }
[13:37:49.331]                     invisible(muffled)
[13:37:49.331]                   }
[13:37:49.331]                   muffleCondition(cond)
[13:37:49.331]                 })
[13:37:49.331]             }))
[13:37:49.331]             future::FutureResult(value = ...future.value$value, 
[13:37:49.331]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:49.331]                   ...future.rng), globalenv = if (FALSE) 
[13:37:49.331]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:49.331]                     ...future.globalenv.names))
[13:37:49.331]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:49.331]         }, condition = base::local({
[13:37:49.331]             c <- base::c
[13:37:49.331]             inherits <- base::inherits
[13:37:49.331]             invokeRestart <- base::invokeRestart
[13:37:49.331]             length <- base::length
[13:37:49.331]             list <- base::list
[13:37:49.331]             seq.int <- base::seq.int
[13:37:49.331]             signalCondition <- base::signalCondition
[13:37:49.331]             sys.calls <- base::sys.calls
[13:37:49.331]             `[[` <- base::`[[`
[13:37:49.331]             `+` <- base::`+`
[13:37:49.331]             `<<-` <- base::`<<-`
[13:37:49.331]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:49.331]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:49.331]                   3L)]
[13:37:49.331]             }
[13:37:49.331]             function(cond) {
[13:37:49.331]                 is_error <- inherits(cond, "error")
[13:37:49.331]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:49.331]                   NULL)
[13:37:49.331]                 if (is_error) {
[13:37:49.331]                   sessionInformation <- function() {
[13:37:49.331]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:49.331]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:49.331]                       search = base::search(), system = base::Sys.info())
[13:37:49.331]                   }
[13:37:49.331]                   ...future.conditions[[length(...future.conditions) + 
[13:37:49.331]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:49.331]                     cond$call), session = sessionInformation(), 
[13:37:49.331]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:49.331]                   signalCondition(cond)
[13:37:49.331]                 }
[13:37:49.331]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:49.331]                 "immediateCondition"))) {
[13:37:49.331]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:49.331]                   ...future.conditions[[length(...future.conditions) + 
[13:37:49.331]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:49.331]                   if (TRUE && !signal) {
[13:37:49.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:49.331]                     {
[13:37:49.331]                       inherits <- base::inherits
[13:37:49.331]                       invokeRestart <- base::invokeRestart
[13:37:49.331]                       is.null <- base::is.null
[13:37:49.331]                       muffled <- FALSE
[13:37:49.331]                       if (inherits(cond, "message")) {
[13:37:49.331]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:49.331]                         if (muffled) 
[13:37:49.331]                           invokeRestart("muffleMessage")
[13:37:49.331]                       }
[13:37:49.331]                       else if (inherits(cond, "warning")) {
[13:37:49.331]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:49.331]                         if (muffled) 
[13:37:49.331]                           invokeRestart("muffleWarning")
[13:37:49.331]                       }
[13:37:49.331]                       else if (inherits(cond, "condition")) {
[13:37:49.331]                         if (!is.null(pattern)) {
[13:37:49.331]                           computeRestarts <- base::computeRestarts
[13:37:49.331]                           grepl <- base::grepl
[13:37:49.331]                           restarts <- computeRestarts(cond)
[13:37:49.331]                           for (restart in restarts) {
[13:37:49.331]                             name <- restart$name
[13:37:49.331]                             if (is.null(name)) 
[13:37:49.331]                               next
[13:37:49.331]                             if (!grepl(pattern, name)) 
[13:37:49.331]                               next
[13:37:49.331]                             invokeRestart(restart)
[13:37:49.331]                             muffled <- TRUE
[13:37:49.331]                             break
[13:37:49.331]                           }
[13:37:49.331]                         }
[13:37:49.331]                       }
[13:37:49.331]                       invisible(muffled)
[13:37:49.331]                     }
[13:37:49.331]                     muffleCondition(cond, pattern = "^muffle")
[13:37:49.331]                   }
[13:37:49.331]                 }
[13:37:49.331]                 else {
[13:37:49.331]                   if (TRUE) {
[13:37:49.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:49.331]                     {
[13:37:49.331]                       inherits <- base::inherits
[13:37:49.331]                       invokeRestart <- base::invokeRestart
[13:37:49.331]                       is.null <- base::is.null
[13:37:49.331]                       muffled <- FALSE
[13:37:49.331]                       if (inherits(cond, "message")) {
[13:37:49.331]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:49.331]                         if (muffled) 
[13:37:49.331]                           invokeRestart("muffleMessage")
[13:37:49.331]                       }
[13:37:49.331]                       else if (inherits(cond, "warning")) {
[13:37:49.331]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:49.331]                         if (muffled) 
[13:37:49.331]                           invokeRestart("muffleWarning")
[13:37:49.331]                       }
[13:37:49.331]                       else if (inherits(cond, "condition")) {
[13:37:49.331]                         if (!is.null(pattern)) {
[13:37:49.331]                           computeRestarts <- base::computeRestarts
[13:37:49.331]                           grepl <- base::grepl
[13:37:49.331]                           restarts <- computeRestarts(cond)
[13:37:49.331]                           for (restart in restarts) {
[13:37:49.331]                             name <- restart$name
[13:37:49.331]                             if (is.null(name)) 
[13:37:49.331]                               next
[13:37:49.331]                             if (!grepl(pattern, name)) 
[13:37:49.331]                               next
[13:37:49.331]                             invokeRestart(restart)
[13:37:49.331]                             muffled <- TRUE
[13:37:49.331]                             break
[13:37:49.331]                           }
[13:37:49.331]                         }
[13:37:49.331]                       }
[13:37:49.331]                       invisible(muffled)
[13:37:49.331]                     }
[13:37:49.331]                     muffleCondition(cond, pattern = "^muffle")
[13:37:49.331]                   }
[13:37:49.331]                 }
[13:37:49.331]             }
[13:37:49.331]         }))
[13:37:49.331]     }, error = function(ex) {
[13:37:49.331]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:49.331]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:49.331]                 ...future.rng), started = ...future.startTime, 
[13:37:49.331]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:49.331]             version = "1.8"), class = "FutureResult")
[13:37:49.331]     }, finally = {
[13:37:49.331]         if (!identical(...future.workdir, getwd())) 
[13:37:49.331]             setwd(...future.workdir)
[13:37:49.331]         {
[13:37:49.331]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:49.331]                 ...future.oldOptions$nwarnings <- NULL
[13:37:49.331]             }
[13:37:49.331]             base::options(...future.oldOptions)
[13:37:49.331]             if (.Platform$OS.type == "windows") {
[13:37:49.331]                 old_names <- names(...future.oldEnvVars)
[13:37:49.331]                 envs <- base::Sys.getenv()
[13:37:49.331]                 names <- names(envs)
[13:37:49.331]                 common <- intersect(names, old_names)
[13:37:49.331]                 added <- setdiff(names, old_names)
[13:37:49.331]                 removed <- setdiff(old_names, names)
[13:37:49.331]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:49.331]                   envs[common]]
[13:37:49.331]                 NAMES <- toupper(changed)
[13:37:49.331]                 args <- list()
[13:37:49.331]                 for (kk in seq_along(NAMES)) {
[13:37:49.331]                   name <- changed[[kk]]
[13:37:49.331]                   NAME <- NAMES[[kk]]
[13:37:49.331]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:49.331]                     next
[13:37:49.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:49.331]                 }
[13:37:49.331]                 NAMES <- toupper(added)
[13:37:49.331]                 for (kk in seq_along(NAMES)) {
[13:37:49.331]                   name <- added[[kk]]
[13:37:49.331]                   NAME <- NAMES[[kk]]
[13:37:49.331]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:49.331]                     next
[13:37:49.331]                   args[[name]] <- ""
[13:37:49.331]                 }
[13:37:49.331]                 NAMES <- toupper(removed)
[13:37:49.331]                 for (kk in seq_along(NAMES)) {
[13:37:49.331]                   name <- removed[[kk]]
[13:37:49.331]                   NAME <- NAMES[[kk]]
[13:37:49.331]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:49.331]                     next
[13:37:49.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:49.331]                 }
[13:37:49.331]                 if (length(args) > 0) 
[13:37:49.331]                   base::do.call(base::Sys.setenv, args = args)
[13:37:49.331]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:49.331]             }
[13:37:49.331]             else {
[13:37:49.331]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:49.331]             }
[13:37:49.331]             {
[13:37:49.331]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:49.331]                   0L) {
[13:37:49.331]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:49.331]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:49.331]                   base::options(opts)
[13:37:49.331]                 }
[13:37:49.331]                 {
[13:37:49.331]                   {
[13:37:49.331]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:49.331]                     NULL
[13:37:49.331]                   }
[13:37:49.331]                   options(future.plan = NULL)
[13:37:49.331]                   if (is.na(NA_character_)) 
[13:37:49.331]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:49.331]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:49.331]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:49.331]                     .init = FALSE)
[13:37:49.331]                 }
[13:37:49.331]             }
[13:37:49.331]         }
[13:37:49.331]     })
[13:37:49.331]     if (TRUE) {
[13:37:49.331]         base::sink(type = "output", split = FALSE)
[13:37:49.331]         if (TRUE) {
[13:37:49.331]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:49.331]         }
[13:37:49.331]         else {
[13:37:49.331]             ...future.result["stdout"] <- base::list(NULL)
[13:37:49.331]         }
[13:37:49.331]         base::close(...future.stdout)
[13:37:49.331]         ...future.stdout <- NULL
[13:37:49.331]     }
[13:37:49.331]     ...future.result$conditions <- ...future.conditions
[13:37:49.331]     ...future.result$finished <- base::Sys.time()
[13:37:49.331]     ...future.result
[13:37:49.331] }
[13:37:49.335] Poll #1 (0): usedNodes() = 2, workers = 2
[13:37:49.356] receiveMessageFromWorker() for ClusterFuture ...
[13:37:49.357] - Validating connection of MultisessionFuture
[13:37:49.357] - received message: FutureResult
[13:37:49.357] - Received FutureResult
[13:37:49.357] - Erased future from FutureRegistry
[13:37:49.357] result() for ClusterFuture ...
[13:37:49.358] - result already collected: FutureResult
[13:37:49.358] result() for ClusterFuture ... done
[13:37:49.358] signalConditions() ...
[13:37:49.358]  - include = ‘immediateCondition’
[13:37:49.358]  - exclude = 
[13:37:49.358]  - resignal = FALSE
[13:37:49.358]  - Number of conditions: 1
[13:37:49.358] signalConditions() ... done
[13:37:49.358] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:49.358] result() for ClusterFuture ...
[13:37:49.359] - result already collected: FutureResult
[13:37:49.359] result() for ClusterFuture ... done
[13:37:49.359] result() for ClusterFuture ...
[13:37:49.359] - result already collected: FutureResult
[13:37:49.359] result() for ClusterFuture ... done
[13:37:49.359] signalConditions() ...
[13:37:49.359]  - include = ‘immediateCondition’
[13:37:49.359]  - exclude = 
[13:37:49.359]  - resignal = FALSE
[13:37:49.359]  - Number of conditions: 1
[13:37:49.359] signalConditions() ... done
[13:37:49.360] MultisessionFuture started
[13:37:49.361] - Launch lazy future ... done
[13:37:49.361] run() for ‘MultisessionFuture’ ... done
[13:37:49.876] receiveMessageFromWorker() for ClusterFuture ...
[13:37:49.876] - Validating connection of MultisessionFuture
[13:37:49.877] - received message: FutureResult
[13:37:49.877] - Received FutureResult
[13:37:49.877] - Erased future from FutureRegistry
[13:37:49.877] result() for ClusterFuture ...
[13:37:49.877] - result already collected: FutureResult
[13:37:49.877] result() for ClusterFuture ... done
[13:37:49.877] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:49.877] A MultisessionFuture was resolved (result was not collected)
[13:37:49.878] getGlobalsAndPackages() ...
[13:37:49.878] Searching for globals...
[13:37:49.879] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:37:49.879] Searching for globals ... DONE
[13:37:49.879] Resolving globals: FALSE
[13:37:49.879] 
[13:37:49.879] 
[13:37:49.880] getGlobalsAndPackages() ... DONE
[13:37:49.880] run() for ‘Future’ ...
[13:37:49.880] - state: ‘created’
[13:37:49.880] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:49.894] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:49.894] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:49.894]   - Field: ‘node’
[13:37:49.894]   - Field: ‘label’
[13:37:49.894]   - Field: ‘local’
[13:37:49.895]   - Field: ‘owner’
[13:37:49.895]   - Field: ‘envir’
[13:37:49.895]   - Field: ‘workers’
[13:37:49.895]   - Field: ‘packages’
[13:37:49.895]   - Field: ‘gc’
[13:37:49.895]   - Field: ‘conditions’
[13:37:49.895]   - Field: ‘persistent’
[13:37:49.895]   - Field: ‘expr’
[13:37:49.895]   - Field: ‘uuid’
[13:37:49.895]   - Field: ‘seed’
[13:37:49.895]   - Field: ‘version’
[13:37:49.896]   - Field: ‘result’
[13:37:49.896]   - Field: ‘asynchronous’
[13:37:49.896]   - Field: ‘calls’
[13:37:49.896]   - Field: ‘globals’
[13:37:49.896]   - Field: ‘stdout’
[13:37:49.896]   - Field: ‘earlySignal’
[13:37:49.896]   - Field: ‘lazy’
[13:37:49.896]   - Field: ‘state’
[13:37:49.896] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:49.896] - Launch lazy future ...
[13:37:49.897] Packages needed by the future expression (n = 0): <none>
[13:37:49.897] Packages needed by future strategies (n = 0): <none>
[13:37:49.897] {
[13:37:49.897]     {
[13:37:49.897]         {
[13:37:49.897]             ...future.startTime <- base::Sys.time()
[13:37:49.897]             {
[13:37:49.897]                 {
[13:37:49.897]                   {
[13:37:49.897]                     {
[13:37:49.897]                       base::local({
[13:37:49.897]                         has_future <- base::requireNamespace("future", 
[13:37:49.897]                           quietly = TRUE)
[13:37:49.897]                         if (has_future) {
[13:37:49.897]                           ns <- base::getNamespace("future")
[13:37:49.897]                           version <- ns[[".package"]][["version"]]
[13:37:49.897]                           if (is.null(version)) 
[13:37:49.897]                             version <- utils::packageVersion("future")
[13:37:49.897]                         }
[13:37:49.897]                         else {
[13:37:49.897]                           version <- NULL
[13:37:49.897]                         }
[13:37:49.897]                         if (!has_future || version < "1.8.0") {
[13:37:49.897]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:49.897]                             "", base::R.version$version.string), 
[13:37:49.897]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:49.897]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:49.897]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:49.897]                               "release", "version")], collapse = " "), 
[13:37:49.897]                             hostname = base::Sys.info()[["nodename"]])
[13:37:49.897]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:49.897]                             info)
[13:37:49.897]                           info <- base::paste(info, collapse = "; ")
[13:37:49.897]                           if (!has_future) {
[13:37:49.897]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:49.897]                               info)
[13:37:49.897]                           }
[13:37:49.897]                           else {
[13:37:49.897]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:49.897]                               info, version)
[13:37:49.897]                           }
[13:37:49.897]                           base::stop(msg)
[13:37:49.897]                         }
[13:37:49.897]                       })
[13:37:49.897]                     }
[13:37:49.897]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:49.897]                     base::options(mc.cores = 1L)
[13:37:49.897]                   }
[13:37:49.897]                   ...future.strategy.old <- future::plan("list")
[13:37:49.897]                   options(future.plan = NULL)
[13:37:49.897]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:49.897]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:49.897]                 }
[13:37:49.897]                 ...future.workdir <- getwd()
[13:37:49.897]             }
[13:37:49.897]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:49.897]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:49.897]         }
[13:37:49.897]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:49.897]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:49.897]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:49.897]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:49.897]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:49.897]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:49.897]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:49.897]             base::names(...future.oldOptions))
[13:37:49.897]     }
[13:37:49.897]     if (FALSE) {
[13:37:49.897]     }
[13:37:49.897]     else {
[13:37:49.897]         if (TRUE) {
[13:37:49.897]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:49.897]                 open = "w")
[13:37:49.897]         }
[13:37:49.897]         else {
[13:37:49.897]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:49.897]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:49.897]         }
[13:37:49.897]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:49.897]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:49.897]             base::sink(type = "output", split = FALSE)
[13:37:49.897]             base::close(...future.stdout)
[13:37:49.897]         }, add = TRUE)
[13:37:49.897]     }
[13:37:49.897]     ...future.frame <- base::sys.nframe()
[13:37:49.897]     ...future.conditions <- base::list()
[13:37:49.897]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:49.897]     if (FALSE) {
[13:37:49.897]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:49.897]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:49.897]     }
[13:37:49.897]     ...future.result <- base::tryCatch({
[13:37:49.897]         base::withCallingHandlers({
[13:37:49.897]             ...future.value <- base::withVisible(base::local({
[13:37:49.897]                 ...future.makeSendCondition <- base::local({
[13:37:49.897]                   sendCondition <- NULL
[13:37:49.897]                   function(frame = 1L) {
[13:37:49.897]                     if (is.function(sendCondition)) 
[13:37:49.897]                       return(sendCondition)
[13:37:49.897]                     ns <- getNamespace("parallel")
[13:37:49.897]                     if (exists("sendData", mode = "function", 
[13:37:49.897]                       envir = ns)) {
[13:37:49.897]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:49.897]                         envir = ns)
[13:37:49.897]                       envir <- sys.frame(frame)
[13:37:49.897]                       master <- NULL
[13:37:49.897]                       while (!identical(envir, .GlobalEnv) && 
[13:37:49.897]                         !identical(envir, emptyenv())) {
[13:37:49.897]                         if (exists("master", mode = "list", envir = envir, 
[13:37:49.897]                           inherits = FALSE)) {
[13:37:49.897]                           master <- get("master", mode = "list", 
[13:37:49.897]                             envir = envir, inherits = FALSE)
[13:37:49.897]                           if (inherits(master, c("SOCKnode", 
[13:37:49.897]                             "SOCK0node"))) {
[13:37:49.897]                             sendCondition <<- function(cond) {
[13:37:49.897]                               data <- list(type = "VALUE", value = cond, 
[13:37:49.897]                                 success = TRUE)
[13:37:49.897]                               parallel_sendData(master, data)
[13:37:49.897]                             }
[13:37:49.897]                             return(sendCondition)
[13:37:49.897]                           }
[13:37:49.897]                         }
[13:37:49.897]                         frame <- frame + 1L
[13:37:49.897]                         envir <- sys.frame(frame)
[13:37:49.897]                       }
[13:37:49.897]                     }
[13:37:49.897]                     sendCondition <<- function(cond) NULL
[13:37:49.897]                   }
[13:37:49.897]                 })
[13:37:49.897]                 withCallingHandlers({
[13:37:49.897]                   {
[13:37:49.897]                     Sys.sleep(0.5)
[13:37:49.897]                     list(a = 1, b = 42L)
[13:37:49.897]                   }
[13:37:49.897]                 }, immediateCondition = function(cond) {
[13:37:49.897]                   sendCondition <- ...future.makeSendCondition()
[13:37:49.897]                   sendCondition(cond)
[13:37:49.897]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:49.897]                   {
[13:37:49.897]                     inherits <- base::inherits
[13:37:49.897]                     invokeRestart <- base::invokeRestart
[13:37:49.897]                     is.null <- base::is.null
[13:37:49.897]                     muffled <- FALSE
[13:37:49.897]                     if (inherits(cond, "message")) {
[13:37:49.897]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:49.897]                       if (muffled) 
[13:37:49.897]                         invokeRestart("muffleMessage")
[13:37:49.897]                     }
[13:37:49.897]                     else if (inherits(cond, "warning")) {
[13:37:49.897]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:49.897]                       if (muffled) 
[13:37:49.897]                         invokeRestart("muffleWarning")
[13:37:49.897]                     }
[13:37:49.897]                     else if (inherits(cond, "condition")) {
[13:37:49.897]                       if (!is.null(pattern)) {
[13:37:49.897]                         computeRestarts <- base::computeRestarts
[13:37:49.897]                         grepl <- base::grepl
[13:37:49.897]                         restarts <- computeRestarts(cond)
[13:37:49.897]                         for (restart in restarts) {
[13:37:49.897]                           name <- restart$name
[13:37:49.897]                           if (is.null(name)) 
[13:37:49.897]                             next
[13:37:49.897]                           if (!grepl(pattern, name)) 
[13:37:49.897]                             next
[13:37:49.897]                           invokeRestart(restart)
[13:37:49.897]                           muffled <- TRUE
[13:37:49.897]                           break
[13:37:49.897]                         }
[13:37:49.897]                       }
[13:37:49.897]                     }
[13:37:49.897]                     invisible(muffled)
[13:37:49.897]                   }
[13:37:49.897]                   muffleCondition(cond)
[13:37:49.897]                 })
[13:37:49.897]             }))
[13:37:49.897]             future::FutureResult(value = ...future.value$value, 
[13:37:49.897]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:49.897]                   ...future.rng), globalenv = if (FALSE) 
[13:37:49.897]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:49.897]                     ...future.globalenv.names))
[13:37:49.897]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:49.897]         }, condition = base::local({
[13:37:49.897]             c <- base::c
[13:37:49.897]             inherits <- base::inherits
[13:37:49.897]             invokeRestart <- base::invokeRestart
[13:37:49.897]             length <- base::length
[13:37:49.897]             list <- base::list
[13:37:49.897]             seq.int <- base::seq.int
[13:37:49.897]             signalCondition <- base::signalCondition
[13:37:49.897]             sys.calls <- base::sys.calls
[13:37:49.897]             `[[` <- base::`[[`
[13:37:49.897]             `+` <- base::`+`
[13:37:49.897]             `<<-` <- base::`<<-`
[13:37:49.897]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:49.897]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:49.897]                   3L)]
[13:37:49.897]             }
[13:37:49.897]             function(cond) {
[13:37:49.897]                 is_error <- inherits(cond, "error")
[13:37:49.897]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:49.897]                   NULL)
[13:37:49.897]                 if (is_error) {
[13:37:49.897]                   sessionInformation <- function() {
[13:37:49.897]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:49.897]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:49.897]                       search = base::search(), system = base::Sys.info())
[13:37:49.897]                   }
[13:37:49.897]                   ...future.conditions[[length(...future.conditions) + 
[13:37:49.897]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:49.897]                     cond$call), session = sessionInformation(), 
[13:37:49.897]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:49.897]                   signalCondition(cond)
[13:37:49.897]                 }
[13:37:49.897]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:49.897]                 "immediateCondition"))) {
[13:37:49.897]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:49.897]                   ...future.conditions[[length(...future.conditions) + 
[13:37:49.897]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:49.897]                   if (TRUE && !signal) {
[13:37:49.897]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:49.897]                     {
[13:37:49.897]                       inherits <- base::inherits
[13:37:49.897]                       invokeRestart <- base::invokeRestart
[13:37:49.897]                       is.null <- base::is.null
[13:37:49.897]                       muffled <- FALSE
[13:37:49.897]                       if (inherits(cond, "message")) {
[13:37:49.897]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:49.897]                         if (muffled) 
[13:37:49.897]                           invokeRestart("muffleMessage")
[13:37:49.897]                       }
[13:37:49.897]                       else if (inherits(cond, "warning")) {
[13:37:49.897]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:49.897]                         if (muffled) 
[13:37:49.897]                           invokeRestart("muffleWarning")
[13:37:49.897]                       }
[13:37:49.897]                       else if (inherits(cond, "condition")) {
[13:37:49.897]                         if (!is.null(pattern)) {
[13:37:49.897]                           computeRestarts <- base::computeRestarts
[13:37:49.897]                           grepl <- base::grepl
[13:37:49.897]                           restarts <- computeRestarts(cond)
[13:37:49.897]                           for (restart in restarts) {
[13:37:49.897]                             name <- restart$name
[13:37:49.897]                             if (is.null(name)) 
[13:37:49.897]                               next
[13:37:49.897]                             if (!grepl(pattern, name)) 
[13:37:49.897]                               next
[13:37:49.897]                             invokeRestart(restart)
[13:37:49.897]                             muffled <- TRUE
[13:37:49.897]                             break
[13:37:49.897]                           }
[13:37:49.897]                         }
[13:37:49.897]                       }
[13:37:49.897]                       invisible(muffled)
[13:37:49.897]                     }
[13:37:49.897]                     muffleCondition(cond, pattern = "^muffle")
[13:37:49.897]                   }
[13:37:49.897]                 }
[13:37:49.897]                 else {
[13:37:49.897]                   if (TRUE) {
[13:37:49.897]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:49.897]                     {
[13:37:49.897]                       inherits <- base::inherits
[13:37:49.897]                       invokeRestart <- base::invokeRestart
[13:37:49.897]                       is.null <- base::is.null
[13:37:49.897]                       muffled <- FALSE
[13:37:49.897]                       if (inherits(cond, "message")) {
[13:37:49.897]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:49.897]                         if (muffled) 
[13:37:49.897]                           invokeRestart("muffleMessage")
[13:37:49.897]                       }
[13:37:49.897]                       else if (inherits(cond, "warning")) {
[13:37:49.897]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:49.897]                         if (muffled) 
[13:37:49.897]                           invokeRestart("muffleWarning")
[13:37:49.897]                       }
[13:37:49.897]                       else if (inherits(cond, "condition")) {
[13:37:49.897]                         if (!is.null(pattern)) {
[13:37:49.897]                           computeRestarts <- base::computeRestarts
[13:37:49.897]                           grepl <- base::grepl
[13:37:49.897]                           restarts <- computeRestarts(cond)
[13:37:49.897]                           for (restart in restarts) {
[13:37:49.897]                             name <- restart$name
[13:37:49.897]                             if (is.null(name)) 
[13:37:49.897]                               next
[13:37:49.897]                             if (!grepl(pattern, name)) 
[13:37:49.897]                               next
[13:37:49.897]                             invokeRestart(restart)
[13:37:49.897]                             muffled <- TRUE
[13:37:49.897]                             break
[13:37:49.897]                           }
[13:37:49.897]                         }
[13:37:49.897]                       }
[13:37:49.897]                       invisible(muffled)
[13:37:49.897]                     }
[13:37:49.897]                     muffleCondition(cond, pattern = "^muffle")
[13:37:49.897]                   }
[13:37:49.897]                 }
[13:37:49.897]             }
[13:37:49.897]         }))
[13:37:49.897]     }, error = function(ex) {
[13:37:49.897]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:49.897]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:49.897]                 ...future.rng), started = ...future.startTime, 
[13:37:49.897]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:49.897]             version = "1.8"), class = "FutureResult")
[13:37:49.897]     }, finally = {
[13:37:49.897]         if (!identical(...future.workdir, getwd())) 
[13:37:49.897]             setwd(...future.workdir)
[13:37:49.897]         {
[13:37:49.897]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:49.897]                 ...future.oldOptions$nwarnings <- NULL
[13:37:49.897]             }
[13:37:49.897]             base::options(...future.oldOptions)
[13:37:49.897]             if (.Platform$OS.type == "windows") {
[13:37:49.897]                 old_names <- names(...future.oldEnvVars)
[13:37:49.897]                 envs <- base::Sys.getenv()
[13:37:49.897]                 names <- names(envs)
[13:37:49.897]                 common <- intersect(names, old_names)
[13:37:49.897]                 added <- setdiff(names, old_names)
[13:37:49.897]                 removed <- setdiff(old_names, names)
[13:37:49.897]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:49.897]                   envs[common]]
[13:37:49.897]                 NAMES <- toupper(changed)
[13:37:49.897]                 args <- list()
[13:37:49.897]                 for (kk in seq_along(NAMES)) {
[13:37:49.897]                   name <- changed[[kk]]
[13:37:49.897]                   NAME <- NAMES[[kk]]
[13:37:49.897]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:49.897]                     next
[13:37:49.897]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:49.897]                 }
[13:37:49.897]                 NAMES <- toupper(added)
[13:37:49.897]                 for (kk in seq_along(NAMES)) {
[13:37:49.897]                   name <- added[[kk]]
[13:37:49.897]                   NAME <- NAMES[[kk]]
[13:37:49.897]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:49.897]                     next
[13:37:49.897]                   args[[name]] <- ""
[13:37:49.897]                 }
[13:37:49.897]                 NAMES <- toupper(removed)
[13:37:49.897]                 for (kk in seq_along(NAMES)) {
[13:37:49.897]                   name <- removed[[kk]]
[13:37:49.897]                   NAME <- NAMES[[kk]]
[13:37:49.897]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:49.897]                     next
[13:37:49.897]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:49.897]                 }
[13:37:49.897]                 if (length(args) > 0) 
[13:37:49.897]                   base::do.call(base::Sys.setenv, args = args)
[13:37:49.897]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:49.897]             }
[13:37:49.897]             else {
[13:37:49.897]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:49.897]             }
[13:37:49.897]             {
[13:37:49.897]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:49.897]                   0L) {
[13:37:49.897]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:49.897]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:49.897]                   base::options(opts)
[13:37:49.897]                 }
[13:37:49.897]                 {
[13:37:49.897]                   {
[13:37:49.897]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:49.897]                     NULL
[13:37:49.897]                   }
[13:37:49.897]                   options(future.plan = NULL)
[13:37:49.897]                   if (is.na(NA_character_)) 
[13:37:49.897]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:49.897]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:49.897]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:49.897]                     .init = FALSE)
[13:37:49.897]                 }
[13:37:49.897]             }
[13:37:49.897]         }
[13:37:49.897]     })
[13:37:49.897]     if (TRUE) {
[13:37:49.897]         base::sink(type = "output", split = FALSE)
[13:37:49.897]         if (TRUE) {
[13:37:49.897]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:49.897]         }
[13:37:49.897]         else {
[13:37:49.897]             ...future.result["stdout"] <- base::list(NULL)
[13:37:49.897]         }
[13:37:49.897]         base::close(...future.stdout)
[13:37:49.897]         ...future.stdout <- NULL
[13:37:49.897]     }
[13:37:49.897]     ...future.result$conditions <- ...future.conditions
[13:37:49.897]     ...future.result$finished <- base::Sys.time()
[13:37:49.897]     ...future.result
[13:37:49.897] }
[13:37:49.900] MultisessionFuture started
[13:37:49.900] - Launch lazy future ... done
[13:37:49.900] run() for ‘MultisessionFuture’ ... done
[13:37:50.403] receiveMessageFromWorker() for ClusterFuture ...
[13:37:50.403] - Validating connection of MultisessionFuture
[13:37:50.404] - received message: FutureResult
[13:37:50.404] - Received FutureResult
[13:37:50.404] - Erased future from FutureRegistry
[13:37:50.404] result() for ClusterFuture ...
[13:37:50.404] - result already collected: FutureResult
[13:37:50.404] result() for ClusterFuture ... done
[13:37:50.404] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:50.404] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[13:37:50.405] getGlobalsAndPackages() ...
[13:37:50.405] Searching for globals...
[13:37:50.405] - globals found: [2] ‘list’, ‘stop’
[13:37:50.405] Searching for globals ... DONE
[13:37:50.406] Resolving globals: FALSE
[13:37:50.406] 
[13:37:50.406] 
[13:37:50.406] getGlobalsAndPackages() ... DONE
[13:37:50.406] run() for ‘Future’ ...
[13:37:50.406] - state: ‘created’
[13:37:50.407] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:50.421] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:50.421] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:50.421]   - Field: ‘node’
[13:37:50.421]   - Field: ‘label’
[13:37:50.421]   - Field: ‘local’
[13:37:50.421]   - Field: ‘owner’
[13:37:50.421]   - Field: ‘envir’
[13:37:50.421]   - Field: ‘workers’
[13:37:50.421]   - Field: ‘packages’
[13:37:50.421]   - Field: ‘gc’
[13:37:50.422]   - Field: ‘conditions’
[13:37:50.422]   - Field: ‘persistent’
[13:37:50.422]   - Field: ‘expr’
[13:37:50.422]   - Field: ‘uuid’
[13:37:50.422]   - Field: ‘seed’
[13:37:50.422]   - Field: ‘version’
[13:37:50.422]   - Field: ‘result’
[13:37:50.422]   - Field: ‘asynchronous’
[13:37:50.422]   - Field: ‘calls’
[13:37:50.422]   - Field: ‘globals’
[13:37:50.423]   - Field: ‘stdout’
[13:37:50.423]   - Field: ‘earlySignal’
[13:37:50.423]   - Field: ‘lazy’
[13:37:50.423]   - Field: ‘state’
[13:37:50.423] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:50.423] - Launch lazy future ...
[13:37:50.423] Packages needed by the future expression (n = 0): <none>
[13:37:50.425] Packages needed by future strategies (n = 0): <none>
[13:37:50.426] {
[13:37:50.426]     {
[13:37:50.426]         {
[13:37:50.426]             ...future.startTime <- base::Sys.time()
[13:37:50.426]             {
[13:37:50.426]                 {
[13:37:50.426]                   {
[13:37:50.426]                     {
[13:37:50.426]                       base::local({
[13:37:50.426]                         has_future <- base::requireNamespace("future", 
[13:37:50.426]                           quietly = TRUE)
[13:37:50.426]                         if (has_future) {
[13:37:50.426]                           ns <- base::getNamespace("future")
[13:37:50.426]                           version <- ns[[".package"]][["version"]]
[13:37:50.426]                           if (is.null(version)) 
[13:37:50.426]                             version <- utils::packageVersion("future")
[13:37:50.426]                         }
[13:37:50.426]                         else {
[13:37:50.426]                           version <- NULL
[13:37:50.426]                         }
[13:37:50.426]                         if (!has_future || version < "1.8.0") {
[13:37:50.426]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:50.426]                             "", base::R.version$version.string), 
[13:37:50.426]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:50.426]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:50.426]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:50.426]                               "release", "version")], collapse = " "), 
[13:37:50.426]                             hostname = base::Sys.info()[["nodename"]])
[13:37:50.426]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:50.426]                             info)
[13:37:50.426]                           info <- base::paste(info, collapse = "; ")
[13:37:50.426]                           if (!has_future) {
[13:37:50.426]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:50.426]                               info)
[13:37:50.426]                           }
[13:37:50.426]                           else {
[13:37:50.426]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:50.426]                               info, version)
[13:37:50.426]                           }
[13:37:50.426]                           base::stop(msg)
[13:37:50.426]                         }
[13:37:50.426]                       })
[13:37:50.426]                     }
[13:37:50.426]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:50.426]                     base::options(mc.cores = 1L)
[13:37:50.426]                   }
[13:37:50.426]                   ...future.strategy.old <- future::plan("list")
[13:37:50.426]                   options(future.plan = NULL)
[13:37:50.426]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:50.426]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:50.426]                 }
[13:37:50.426]                 ...future.workdir <- getwd()
[13:37:50.426]             }
[13:37:50.426]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:50.426]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:50.426]         }
[13:37:50.426]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:50.426]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:50.426]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:50.426]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:50.426]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:50.426]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:50.426]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:50.426]             base::names(...future.oldOptions))
[13:37:50.426]     }
[13:37:50.426]     if (FALSE) {
[13:37:50.426]     }
[13:37:50.426]     else {
[13:37:50.426]         if (TRUE) {
[13:37:50.426]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:50.426]                 open = "w")
[13:37:50.426]         }
[13:37:50.426]         else {
[13:37:50.426]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:50.426]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:50.426]         }
[13:37:50.426]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:50.426]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:50.426]             base::sink(type = "output", split = FALSE)
[13:37:50.426]             base::close(...future.stdout)
[13:37:50.426]         }, add = TRUE)
[13:37:50.426]     }
[13:37:50.426]     ...future.frame <- base::sys.nframe()
[13:37:50.426]     ...future.conditions <- base::list()
[13:37:50.426]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:50.426]     if (FALSE) {
[13:37:50.426]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:50.426]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:50.426]     }
[13:37:50.426]     ...future.result <- base::tryCatch({
[13:37:50.426]         base::withCallingHandlers({
[13:37:50.426]             ...future.value <- base::withVisible(base::local({
[13:37:50.426]                 ...future.makeSendCondition <- base::local({
[13:37:50.426]                   sendCondition <- NULL
[13:37:50.426]                   function(frame = 1L) {
[13:37:50.426]                     if (is.function(sendCondition)) 
[13:37:50.426]                       return(sendCondition)
[13:37:50.426]                     ns <- getNamespace("parallel")
[13:37:50.426]                     if (exists("sendData", mode = "function", 
[13:37:50.426]                       envir = ns)) {
[13:37:50.426]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:50.426]                         envir = ns)
[13:37:50.426]                       envir <- sys.frame(frame)
[13:37:50.426]                       master <- NULL
[13:37:50.426]                       while (!identical(envir, .GlobalEnv) && 
[13:37:50.426]                         !identical(envir, emptyenv())) {
[13:37:50.426]                         if (exists("master", mode = "list", envir = envir, 
[13:37:50.426]                           inherits = FALSE)) {
[13:37:50.426]                           master <- get("master", mode = "list", 
[13:37:50.426]                             envir = envir, inherits = FALSE)
[13:37:50.426]                           if (inherits(master, c("SOCKnode", 
[13:37:50.426]                             "SOCK0node"))) {
[13:37:50.426]                             sendCondition <<- function(cond) {
[13:37:50.426]                               data <- list(type = "VALUE", value = cond, 
[13:37:50.426]                                 success = TRUE)
[13:37:50.426]                               parallel_sendData(master, data)
[13:37:50.426]                             }
[13:37:50.426]                             return(sendCondition)
[13:37:50.426]                           }
[13:37:50.426]                         }
[13:37:50.426]                         frame <- frame + 1L
[13:37:50.426]                         envir <- sys.frame(frame)
[13:37:50.426]                       }
[13:37:50.426]                     }
[13:37:50.426]                     sendCondition <<- function(cond) NULL
[13:37:50.426]                   }
[13:37:50.426]                 })
[13:37:50.426]                 withCallingHandlers({
[13:37:50.426]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:37:50.426]                 }, immediateCondition = function(cond) {
[13:37:50.426]                   sendCondition <- ...future.makeSendCondition()
[13:37:50.426]                   sendCondition(cond)
[13:37:50.426]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:50.426]                   {
[13:37:50.426]                     inherits <- base::inherits
[13:37:50.426]                     invokeRestart <- base::invokeRestart
[13:37:50.426]                     is.null <- base::is.null
[13:37:50.426]                     muffled <- FALSE
[13:37:50.426]                     if (inherits(cond, "message")) {
[13:37:50.426]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:50.426]                       if (muffled) 
[13:37:50.426]                         invokeRestart("muffleMessage")
[13:37:50.426]                     }
[13:37:50.426]                     else if (inherits(cond, "warning")) {
[13:37:50.426]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:50.426]                       if (muffled) 
[13:37:50.426]                         invokeRestart("muffleWarning")
[13:37:50.426]                     }
[13:37:50.426]                     else if (inherits(cond, "condition")) {
[13:37:50.426]                       if (!is.null(pattern)) {
[13:37:50.426]                         computeRestarts <- base::computeRestarts
[13:37:50.426]                         grepl <- base::grepl
[13:37:50.426]                         restarts <- computeRestarts(cond)
[13:37:50.426]                         for (restart in restarts) {
[13:37:50.426]                           name <- restart$name
[13:37:50.426]                           if (is.null(name)) 
[13:37:50.426]                             next
[13:37:50.426]                           if (!grepl(pattern, name)) 
[13:37:50.426]                             next
[13:37:50.426]                           invokeRestart(restart)
[13:37:50.426]                           muffled <- TRUE
[13:37:50.426]                           break
[13:37:50.426]                         }
[13:37:50.426]                       }
[13:37:50.426]                     }
[13:37:50.426]                     invisible(muffled)
[13:37:50.426]                   }
[13:37:50.426]                   muffleCondition(cond)
[13:37:50.426]                 })
[13:37:50.426]             }))
[13:37:50.426]             future::FutureResult(value = ...future.value$value, 
[13:37:50.426]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:50.426]                   ...future.rng), globalenv = if (FALSE) 
[13:37:50.426]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:50.426]                     ...future.globalenv.names))
[13:37:50.426]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:50.426]         }, condition = base::local({
[13:37:50.426]             c <- base::c
[13:37:50.426]             inherits <- base::inherits
[13:37:50.426]             invokeRestart <- base::invokeRestart
[13:37:50.426]             length <- base::length
[13:37:50.426]             list <- base::list
[13:37:50.426]             seq.int <- base::seq.int
[13:37:50.426]             signalCondition <- base::signalCondition
[13:37:50.426]             sys.calls <- base::sys.calls
[13:37:50.426]             `[[` <- base::`[[`
[13:37:50.426]             `+` <- base::`+`
[13:37:50.426]             `<<-` <- base::`<<-`
[13:37:50.426]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:50.426]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:50.426]                   3L)]
[13:37:50.426]             }
[13:37:50.426]             function(cond) {
[13:37:50.426]                 is_error <- inherits(cond, "error")
[13:37:50.426]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:50.426]                   NULL)
[13:37:50.426]                 if (is_error) {
[13:37:50.426]                   sessionInformation <- function() {
[13:37:50.426]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:50.426]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:50.426]                       search = base::search(), system = base::Sys.info())
[13:37:50.426]                   }
[13:37:50.426]                   ...future.conditions[[length(...future.conditions) + 
[13:37:50.426]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:50.426]                     cond$call), session = sessionInformation(), 
[13:37:50.426]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:50.426]                   signalCondition(cond)
[13:37:50.426]                 }
[13:37:50.426]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:50.426]                 "immediateCondition"))) {
[13:37:50.426]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:50.426]                   ...future.conditions[[length(...future.conditions) + 
[13:37:50.426]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:50.426]                   if (TRUE && !signal) {
[13:37:50.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:50.426]                     {
[13:37:50.426]                       inherits <- base::inherits
[13:37:50.426]                       invokeRestart <- base::invokeRestart
[13:37:50.426]                       is.null <- base::is.null
[13:37:50.426]                       muffled <- FALSE
[13:37:50.426]                       if (inherits(cond, "message")) {
[13:37:50.426]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:50.426]                         if (muffled) 
[13:37:50.426]                           invokeRestart("muffleMessage")
[13:37:50.426]                       }
[13:37:50.426]                       else if (inherits(cond, "warning")) {
[13:37:50.426]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:50.426]                         if (muffled) 
[13:37:50.426]                           invokeRestart("muffleWarning")
[13:37:50.426]                       }
[13:37:50.426]                       else if (inherits(cond, "condition")) {
[13:37:50.426]                         if (!is.null(pattern)) {
[13:37:50.426]                           computeRestarts <- base::computeRestarts
[13:37:50.426]                           grepl <- base::grepl
[13:37:50.426]                           restarts <- computeRestarts(cond)
[13:37:50.426]                           for (restart in restarts) {
[13:37:50.426]                             name <- restart$name
[13:37:50.426]                             if (is.null(name)) 
[13:37:50.426]                               next
[13:37:50.426]                             if (!grepl(pattern, name)) 
[13:37:50.426]                               next
[13:37:50.426]                             invokeRestart(restart)
[13:37:50.426]                             muffled <- TRUE
[13:37:50.426]                             break
[13:37:50.426]                           }
[13:37:50.426]                         }
[13:37:50.426]                       }
[13:37:50.426]                       invisible(muffled)
[13:37:50.426]                     }
[13:37:50.426]                     muffleCondition(cond, pattern = "^muffle")
[13:37:50.426]                   }
[13:37:50.426]                 }
[13:37:50.426]                 else {
[13:37:50.426]                   if (TRUE) {
[13:37:50.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:50.426]                     {
[13:37:50.426]                       inherits <- base::inherits
[13:37:50.426]                       invokeRestart <- base::invokeRestart
[13:37:50.426]                       is.null <- base::is.null
[13:37:50.426]                       muffled <- FALSE
[13:37:50.426]                       if (inherits(cond, "message")) {
[13:37:50.426]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:50.426]                         if (muffled) 
[13:37:50.426]                           invokeRestart("muffleMessage")
[13:37:50.426]                       }
[13:37:50.426]                       else if (inherits(cond, "warning")) {
[13:37:50.426]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:50.426]                         if (muffled) 
[13:37:50.426]                           invokeRestart("muffleWarning")
[13:37:50.426]                       }
[13:37:50.426]                       else if (inherits(cond, "condition")) {
[13:37:50.426]                         if (!is.null(pattern)) {
[13:37:50.426]                           computeRestarts <- base::computeRestarts
[13:37:50.426]                           grepl <- base::grepl
[13:37:50.426]                           restarts <- computeRestarts(cond)
[13:37:50.426]                           for (restart in restarts) {
[13:37:50.426]                             name <- restart$name
[13:37:50.426]                             if (is.null(name)) 
[13:37:50.426]                               next
[13:37:50.426]                             if (!grepl(pattern, name)) 
[13:37:50.426]                               next
[13:37:50.426]                             invokeRestart(restart)
[13:37:50.426]                             muffled <- TRUE
[13:37:50.426]                             break
[13:37:50.426]                           }
[13:37:50.426]                         }
[13:37:50.426]                       }
[13:37:50.426]                       invisible(muffled)
[13:37:50.426]                     }
[13:37:50.426]                     muffleCondition(cond, pattern = "^muffle")
[13:37:50.426]                   }
[13:37:50.426]                 }
[13:37:50.426]             }
[13:37:50.426]         }))
[13:37:50.426]     }, error = function(ex) {
[13:37:50.426]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:50.426]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:50.426]                 ...future.rng), started = ...future.startTime, 
[13:37:50.426]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:50.426]             version = "1.8"), class = "FutureResult")
[13:37:50.426]     }, finally = {
[13:37:50.426]         if (!identical(...future.workdir, getwd())) 
[13:37:50.426]             setwd(...future.workdir)
[13:37:50.426]         {
[13:37:50.426]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:50.426]                 ...future.oldOptions$nwarnings <- NULL
[13:37:50.426]             }
[13:37:50.426]             base::options(...future.oldOptions)
[13:37:50.426]             if (.Platform$OS.type == "windows") {
[13:37:50.426]                 old_names <- names(...future.oldEnvVars)
[13:37:50.426]                 envs <- base::Sys.getenv()
[13:37:50.426]                 names <- names(envs)
[13:37:50.426]                 common <- intersect(names, old_names)
[13:37:50.426]                 added <- setdiff(names, old_names)
[13:37:50.426]                 removed <- setdiff(old_names, names)
[13:37:50.426]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:50.426]                   envs[common]]
[13:37:50.426]                 NAMES <- toupper(changed)
[13:37:50.426]                 args <- list()
[13:37:50.426]                 for (kk in seq_along(NAMES)) {
[13:37:50.426]                   name <- changed[[kk]]
[13:37:50.426]                   NAME <- NAMES[[kk]]
[13:37:50.426]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:50.426]                     next
[13:37:50.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:50.426]                 }
[13:37:50.426]                 NAMES <- toupper(added)
[13:37:50.426]                 for (kk in seq_along(NAMES)) {
[13:37:50.426]                   name <- added[[kk]]
[13:37:50.426]                   NAME <- NAMES[[kk]]
[13:37:50.426]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:50.426]                     next
[13:37:50.426]                   args[[name]] <- ""
[13:37:50.426]                 }
[13:37:50.426]                 NAMES <- toupper(removed)
[13:37:50.426]                 for (kk in seq_along(NAMES)) {
[13:37:50.426]                   name <- removed[[kk]]
[13:37:50.426]                   NAME <- NAMES[[kk]]
[13:37:50.426]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:50.426]                     next
[13:37:50.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:50.426]                 }
[13:37:50.426]                 if (length(args) > 0) 
[13:37:50.426]                   base::do.call(base::Sys.setenv, args = args)
[13:37:50.426]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:50.426]             }
[13:37:50.426]             else {
[13:37:50.426]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:50.426]             }
[13:37:50.426]             {
[13:37:50.426]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:50.426]                   0L) {
[13:37:50.426]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:50.426]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:50.426]                   base::options(opts)
[13:37:50.426]                 }
[13:37:50.426]                 {
[13:37:50.426]                   {
[13:37:50.426]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:50.426]                     NULL
[13:37:50.426]                   }
[13:37:50.426]                   options(future.plan = NULL)
[13:37:50.426]                   if (is.na(NA_character_)) 
[13:37:50.426]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:50.426]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:50.426]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:50.426]                     .init = FALSE)
[13:37:50.426]                 }
[13:37:50.426]             }
[13:37:50.426]         }
[13:37:50.426]     })
[13:37:50.426]     if (TRUE) {
[13:37:50.426]         base::sink(type = "output", split = FALSE)
[13:37:50.426]         if (TRUE) {
[13:37:50.426]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:50.426]         }
[13:37:50.426]         else {
[13:37:50.426]             ...future.result["stdout"] <- base::list(NULL)
[13:37:50.426]         }
[13:37:50.426]         base::close(...future.stdout)
[13:37:50.426]         ...future.stdout <- NULL
[13:37:50.426]     }
[13:37:50.426]     ...future.result$conditions <- ...future.conditions
[13:37:50.426]     ...future.result$finished <- base::Sys.time()
[13:37:50.426]     ...future.result
[13:37:50.426] }
[13:37:50.429] MultisessionFuture started
[13:37:50.429] - Launch lazy future ... done
[13:37:50.429] run() for ‘MultisessionFuture’ ... done
[13:37:50.431] receiveMessageFromWorker() for ClusterFuture ...
[13:37:50.431] - Validating connection of MultisessionFuture
[13:37:50.432] - received message: FutureResult
[13:37:50.432] - Received FutureResult
[13:37:50.432] - Erased future from FutureRegistry
[13:37:50.432] result() for ClusterFuture ...
[13:37:50.432] - result already collected: FutureResult
[13:37:50.432] result() for ClusterFuture ... done
[13:37:50.432] signalConditions() ...
[13:37:50.432]  - include = ‘immediateCondition’
[13:37:50.432]  - exclude = 
[13:37:50.432]  - resignal = FALSE
[13:37:50.432]  - Number of conditions: 1
[13:37:50.433] signalConditions() ... done
[13:37:50.433] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:50.433] A MultisessionFuture was resolved (result was not collected)
[13:37:50.433] getGlobalsAndPackages() ...
[13:37:50.433] Searching for globals...
[13:37:50.434] - globals found: [2] ‘list’, ‘stop’
[13:37:50.434] Searching for globals ... DONE
[13:37:50.434] Resolving globals: FALSE
[13:37:50.434] 
[13:37:50.434] 
[13:37:50.434] getGlobalsAndPackages() ... DONE
[13:37:50.435] run() for ‘Future’ ...
[13:37:50.435] - state: ‘created’
[13:37:50.435] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:50.448] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:50.448] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:50.448]   - Field: ‘node’
[13:37:50.448]   - Field: ‘label’
[13:37:50.449]   - Field: ‘local’
[13:37:50.449]   - Field: ‘owner’
[13:37:50.449]   - Field: ‘envir’
[13:37:50.449]   - Field: ‘workers’
[13:37:50.449]   - Field: ‘packages’
[13:37:50.449]   - Field: ‘gc’
[13:37:50.449]   - Field: ‘conditions’
[13:37:50.449]   - Field: ‘persistent’
[13:37:50.449]   - Field: ‘expr’
[13:37:50.449]   - Field: ‘uuid’
[13:37:50.449]   - Field: ‘seed’
[13:37:50.450]   - Field: ‘version’
[13:37:50.450]   - Field: ‘result’
[13:37:50.450]   - Field: ‘asynchronous’
[13:37:50.450]   - Field: ‘calls’
[13:37:50.450]   - Field: ‘globals’
[13:37:50.450]   - Field: ‘stdout’
[13:37:50.450]   - Field: ‘earlySignal’
[13:37:50.450]   - Field: ‘lazy’
[13:37:50.450]   - Field: ‘state’
[13:37:50.450] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:50.450] - Launch lazy future ...
[13:37:50.451] Packages needed by the future expression (n = 0): <none>
[13:37:50.451] Packages needed by future strategies (n = 0): <none>
[13:37:50.451] {
[13:37:50.451]     {
[13:37:50.451]         {
[13:37:50.451]             ...future.startTime <- base::Sys.time()
[13:37:50.451]             {
[13:37:50.451]                 {
[13:37:50.451]                   {
[13:37:50.451]                     {
[13:37:50.451]                       base::local({
[13:37:50.451]                         has_future <- base::requireNamespace("future", 
[13:37:50.451]                           quietly = TRUE)
[13:37:50.451]                         if (has_future) {
[13:37:50.451]                           ns <- base::getNamespace("future")
[13:37:50.451]                           version <- ns[[".package"]][["version"]]
[13:37:50.451]                           if (is.null(version)) 
[13:37:50.451]                             version <- utils::packageVersion("future")
[13:37:50.451]                         }
[13:37:50.451]                         else {
[13:37:50.451]                           version <- NULL
[13:37:50.451]                         }
[13:37:50.451]                         if (!has_future || version < "1.8.0") {
[13:37:50.451]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:50.451]                             "", base::R.version$version.string), 
[13:37:50.451]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:50.451]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:50.451]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:50.451]                               "release", "version")], collapse = " "), 
[13:37:50.451]                             hostname = base::Sys.info()[["nodename"]])
[13:37:50.451]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:50.451]                             info)
[13:37:50.451]                           info <- base::paste(info, collapse = "; ")
[13:37:50.451]                           if (!has_future) {
[13:37:50.451]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:50.451]                               info)
[13:37:50.451]                           }
[13:37:50.451]                           else {
[13:37:50.451]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:50.451]                               info, version)
[13:37:50.451]                           }
[13:37:50.451]                           base::stop(msg)
[13:37:50.451]                         }
[13:37:50.451]                       })
[13:37:50.451]                     }
[13:37:50.451]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:50.451]                     base::options(mc.cores = 1L)
[13:37:50.451]                   }
[13:37:50.451]                   ...future.strategy.old <- future::plan("list")
[13:37:50.451]                   options(future.plan = NULL)
[13:37:50.451]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:50.451]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:50.451]                 }
[13:37:50.451]                 ...future.workdir <- getwd()
[13:37:50.451]             }
[13:37:50.451]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:50.451]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:50.451]         }
[13:37:50.451]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:50.451]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:50.451]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:50.451]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:50.451]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:50.451]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:50.451]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:50.451]             base::names(...future.oldOptions))
[13:37:50.451]     }
[13:37:50.451]     if (FALSE) {
[13:37:50.451]     }
[13:37:50.451]     else {
[13:37:50.451]         if (TRUE) {
[13:37:50.451]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:50.451]                 open = "w")
[13:37:50.451]         }
[13:37:50.451]         else {
[13:37:50.451]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:50.451]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:50.451]         }
[13:37:50.451]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:50.451]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:50.451]             base::sink(type = "output", split = FALSE)
[13:37:50.451]             base::close(...future.stdout)
[13:37:50.451]         }, add = TRUE)
[13:37:50.451]     }
[13:37:50.451]     ...future.frame <- base::sys.nframe()
[13:37:50.451]     ...future.conditions <- base::list()
[13:37:50.451]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:50.451]     if (FALSE) {
[13:37:50.451]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:50.451]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:50.451]     }
[13:37:50.451]     ...future.result <- base::tryCatch({
[13:37:50.451]         base::withCallingHandlers({
[13:37:50.451]             ...future.value <- base::withVisible(base::local({
[13:37:50.451]                 ...future.makeSendCondition <- base::local({
[13:37:50.451]                   sendCondition <- NULL
[13:37:50.451]                   function(frame = 1L) {
[13:37:50.451]                     if (is.function(sendCondition)) 
[13:37:50.451]                       return(sendCondition)
[13:37:50.451]                     ns <- getNamespace("parallel")
[13:37:50.451]                     if (exists("sendData", mode = "function", 
[13:37:50.451]                       envir = ns)) {
[13:37:50.451]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:50.451]                         envir = ns)
[13:37:50.451]                       envir <- sys.frame(frame)
[13:37:50.451]                       master <- NULL
[13:37:50.451]                       while (!identical(envir, .GlobalEnv) && 
[13:37:50.451]                         !identical(envir, emptyenv())) {
[13:37:50.451]                         if (exists("master", mode = "list", envir = envir, 
[13:37:50.451]                           inherits = FALSE)) {
[13:37:50.451]                           master <- get("master", mode = "list", 
[13:37:50.451]                             envir = envir, inherits = FALSE)
[13:37:50.451]                           if (inherits(master, c("SOCKnode", 
[13:37:50.451]                             "SOCK0node"))) {
[13:37:50.451]                             sendCondition <<- function(cond) {
[13:37:50.451]                               data <- list(type = "VALUE", value = cond, 
[13:37:50.451]                                 success = TRUE)
[13:37:50.451]                               parallel_sendData(master, data)
[13:37:50.451]                             }
[13:37:50.451]                             return(sendCondition)
[13:37:50.451]                           }
[13:37:50.451]                         }
[13:37:50.451]                         frame <- frame + 1L
[13:37:50.451]                         envir <- sys.frame(frame)
[13:37:50.451]                       }
[13:37:50.451]                     }
[13:37:50.451]                     sendCondition <<- function(cond) NULL
[13:37:50.451]                   }
[13:37:50.451]                 })
[13:37:50.451]                 withCallingHandlers({
[13:37:50.451]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:37:50.451]                 }, immediateCondition = function(cond) {
[13:37:50.451]                   sendCondition <- ...future.makeSendCondition()
[13:37:50.451]                   sendCondition(cond)
[13:37:50.451]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:50.451]                   {
[13:37:50.451]                     inherits <- base::inherits
[13:37:50.451]                     invokeRestart <- base::invokeRestart
[13:37:50.451]                     is.null <- base::is.null
[13:37:50.451]                     muffled <- FALSE
[13:37:50.451]                     if (inherits(cond, "message")) {
[13:37:50.451]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:50.451]                       if (muffled) 
[13:37:50.451]                         invokeRestart("muffleMessage")
[13:37:50.451]                     }
[13:37:50.451]                     else if (inherits(cond, "warning")) {
[13:37:50.451]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:50.451]                       if (muffled) 
[13:37:50.451]                         invokeRestart("muffleWarning")
[13:37:50.451]                     }
[13:37:50.451]                     else if (inherits(cond, "condition")) {
[13:37:50.451]                       if (!is.null(pattern)) {
[13:37:50.451]                         computeRestarts <- base::computeRestarts
[13:37:50.451]                         grepl <- base::grepl
[13:37:50.451]                         restarts <- computeRestarts(cond)
[13:37:50.451]                         for (restart in restarts) {
[13:37:50.451]                           name <- restart$name
[13:37:50.451]                           if (is.null(name)) 
[13:37:50.451]                             next
[13:37:50.451]                           if (!grepl(pattern, name)) 
[13:37:50.451]                             next
[13:37:50.451]                           invokeRestart(restart)
[13:37:50.451]                           muffled <- TRUE
[13:37:50.451]                           break
[13:37:50.451]                         }
[13:37:50.451]                       }
[13:37:50.451]                     }
[13:37:50.451]                     invisible(muffled)
[13:37:50.451]                   }
[13:37:50.451]                   muffleCondition(cond)
[13:37:50.451]                 })
[13:37:50.451]             }))
[13:37:50.451]             future::FutureResult(value = ...future.value$value, 
[13:37:50.451]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:50.451]                   ...future.rng), globalenv = if (FALSE) 
[13:37:50.451]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:50.451]                     ...future.globalenv.names))
[13:37:50.451]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:50.451]         }, condition = base::local({
[13:37:50.451]             c <- base::c
[13:37:50.451]             inherits <- base::inherits
[13:37:50.451]             invokeRestart <- base::invokeRestart
[13:37:50.451]             length <- base::length
[13:37:50.451]             list <- base::list
[13:37:50.451]             seq.int <- base::seq.int
[13:37:50.451]             signalCondition <- base::signalCondition
[13:37:50.451]             sys.calls <- base::sys.calls
[13:37:50.451]             `[[` <- base::`[[`
[13:37:50.451]             `+` <- base::`+`
[13:37:50.451]             `<<-` <- base::`<<-`
[13:37:50.451]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:50.451]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:50.451]                   3L)]
[13:37:50.451]             }
[13:37:50.451]             function(cond) {
[13:37:50.451]                 is_error <- inherits(cond, "error")
[13:37:50.451]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:50.451]                   NULL)
[13:37:50.451]                 if (is_error) {
[13:37:50.451]                   sessionInformation <- function() {
[13:37:50.451]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:50.451]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:50.451]                       search = base::search(), system = base::Sys.info())
[13:37:50.451]                   }
[13:37:50.451]                   ...future.conditions[[length(...future.conditions) + 
[13:37:50.451]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:50.451]                     cond$call), session = sessionInformation(), 
[13:37:50.451]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:50.451]                   signalCondition(cond)
[13:37:50.451]                 }
[13:37:50.451]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:50.451]                 "immediateCondition"))) {
[13:37:50.451]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:50.451]                   ...future.conditions[[length(...future.conditions) + 
[13:37:50.451]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:50.451]                   if (TRUE && !signal) {
[13:37:50.451]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:50.451]                     {
[13:37:50.451]                       inherits <- base::inherits
[13:37:50.451]                       invokeRestart <- base::invokeRestart
[13:37:50.451]                       is.null <- base::is.null
[13:37:50.451]                       muffled <- FALSE
[13:37:50.451]                       if (inherits(cond, "message")) {
[13:37:50.451]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:50.451]                         if (muffled) 
[13:37:50.451]                           invokeRestart("muffleMessage")
[13:37:50.451]                       }
[13:37:50.451]                       else if (inherits(cond, "warning")) {
[13:37:50.451]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:50.451]                         if (muffled) 
[13:37:50.451]                           invokeRestart("muffleWarning")
[13:37:50.451]                       }
[13:37:50.451]                       else if (inherits(cond, "condition")) {
[13:37:50.451]                         if (!is.null(pattern)) {
[13:37:50.451]                           computeRestarts <- base::computeRestarts
[13:37:50.451]                           grepl <- base::grepl
[13:37:50.451]                           restarts <- computeRestarts(cond)
[13:37:50.451]                           for (restart in restarts) {
[13:37:50.451]                             name <- restart$name
[13:37:50.451]                             if (is.null(name)) 
[13:37:50.451]                               next
[13:37:50.451]                             if (!grepl(pattern, name)) 
[13:37:50.451]                               next
[13:37:50.451]                             invokeRestart(restart)
[13:37:50.451]                             muffled <- TRUE
[13:37:50.451]                             break
[13:37:50.451]                           }
[13:37:50.451]                         }
[13:37:50.451]                       }
[13:37:50.451]                       invisible(muffled)
[13:37:50.451]                     }
[13:37:50.451]                     muffleCondition(cond, pattern = "^muffle")
[13:37:50.451]                   }
[13:37:50.451]                 }
[13:37:50.451]                 else {
[13:37:50.451]                   if (TRUE) {
[13:37:50.451]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:50.451]                     {
[13:37:50.451]                       inherits <- base::inherits
[13:37:50.451]                       invokeRestart <- base::invokeRestart
[13:37:50.451]                       is.null <- base::is.null
[13:37:50.451]                       muffled <- FALSE
[13:37:50.451]                       if (inherits(cond, "message")) {
[13:37:50.451]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:50.451]                         if (muffled) 
[13:37:50.451]                           invokeRestart("muffleMessage")
[13:37:50.451]                       }
[13:37:50.451]                       else if (inherits(cond, "warning")) {
[13:37:50.451]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:50.451]                         if (muffled) 
[13:37:50.451]                           invokeRestart("muffleWarning")
[13:37:50.451]                       }
[13:37:50.451]                       else if (inherits(cond, "condition")) {
[13:37:50.451]                         if (!is.null(pattern)) {
[13:37:50.451]                           computeRestarts <- base::computeRestarts
[13:37:50.451]                           grepl <- base::grepl
[13:37:50.451]                           restarts <- computeRestarts(cond)
[13:37:50.451]                           for (restart in restarts) {
[13:37:50.451]                             name <- restart$name
[13:37:50.451]                             if (is.null(name)) 
[13:37:50.451]                               next
[13:37:50.451]                             if (!grepl(pattern, name)) 
[13:37:50.451]                               next
[13:37:50.451]                             invokeRestart(restart)
[13:37:50.451]                             muffled <- TRUE
[13:37:50.451]                             break
[13:37:50.451]                           }
[13:37:50.451]                         }
[13:37:50.451]                       }
[13:37:50.451]                       invisible(muffled)
[13:37:50.451]                     }
[13:37:50.451]                     muffleCondition(cond, pattern = "^muffle")
[13:37:50.451]                   }
[13:37:50.451]                 }
[13:37:50.451]             }
[13:37:50.451]         }))
[13:37:50.451]     }, error = function(ex) {
[13:37:50.451]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:50.451]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:50.451]                 ...future.rng), started = ...future.startTime, 
[13:37:50.451]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:50.451]             version = "1.8"), class = "FutureResult")
[13:37:50.451]     }, finally = {
[13:37:50.451]         if (!identical(...future.workdir, getwd())) 
[13:37:50.451]             setwd(...future.workdir)
[13:37:50.451]         {
[13:37:50.451]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:50.451]                 ...future.oldOptions$nwarnings <- NULL
[13:37:50.451]             }
[13:37:50.451]             base::options(...future.oldOptions)
[13:37:50.451]             if (.Platform$OS.type == "windows") {
[13:37:50.451]                 old_names <- names(...future.oldEnvVars)
[13:37:50.451]                 envs <- base::Sys.getenv()
[13:37:50.451]                 names <- names(envs)
[13:37:50.451]                 common <- intersect(names, old_names)
[13:37:50.451]                 added <- setdiff(names, old_names)
[13:37:50.451]                 removed <- setdiff(old_names, names)
[13:37:50.451]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:50.451]                   envs[common]]
[13:37:50.451]                 NAMES <- toupper(changed)
[13:37:50.451]                 args <- list()
[13:37:50.451]                 for (kk in seq_along(NAMES)) {
[13:37:50.451]                   name <- changed[[kk]]
[13:37:50.451]                   NAME <- NAMES[[kk]]
[13:37:50.451]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:50.451]                     next
[13:37:50.451]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:50.451]                 }
[13:37:50.451]                 NAMES <- toupper(added)
[13:37:50.451]                 for (kk in seq_along(NAMES)) {
[13:37:50.451]                   name <- added[[kk]]
[13:37:50.451]                   NAME <- NAMES[[kk]]
[13:37:50.451]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:50.451]                     next
[13:37:50.451]                   args[[name]] <- ""
[13:37:50.451]                 }
[13:37:50.451]                 NAMES <- toupper(removed)
[13:37:50.451]                 for (kk in seq_along(NAMES)) {
[13:37:50.451]                   name <- removed[[kk]]
[13:37:50.451]                   NAME <- NAMES[[kk]]
[13:37:50.451]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:50.451]                     next
[13:37:50.451]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:50.451]                 }
[13:37:50.451]                 if (length(args) > 0) 
[13:37:50.451]                   base::do.call(base::Sys.setenv, args = args)
[13:37:50.451]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:50.451]             }
[13:37:50.451]             else {
[13:37:50.451]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:50.451]             }
[13:37:50.451]             {
[13:37:50.451]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:50.451]                   0L) {
[13:37:50.451]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:50.451]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:50.451]                   base::options(opts)
[13:37:50.451]                 }
[13:37:50.451]                 {
[13:37:50.451]                   {
[13:37:50.451]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:50.451]                     NULL
[13:37:50.451]                   }
[13:37:50.451]                   options(future.plan = NULL)
[13:37:50.451]                   if (is.na(NA_character_)) 
[13:37:50.451]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:50.451]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:50.451]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:50.451]                     .init = FALSE)
[13:37:50.451]                 }
[13:37:50.451]             }
[13:37:50.451]         }
[13:37:50.451]     })
[13:37:50.451]     if (TRUE) {
[13:37:50.451]         base::sink(type = "output", split = FALSE)
[13:37:50.451]         if (TRUE) {
[13:37:50.451]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:50.451]         }
[13:37:50.451]         else {
[13:37:50.451]             ...future.result["stdout"] <- base::list(NULL)
[13:37:50.451]         }
[13:37:50.451]         base::close(...future.stdout)
[13:37:50.451]         ...future.stdout <- NULL
[13:37:50.451]     }
[13:37:50.451]     ...future.result$conditions <- ...future.conditions
[13:37:50.451]     ...future.result$finished <- base::Sys.time()
[13:37:50.451]     ...future.result
[13:37:50.451] }
[13:37:50.454] MultisessionFuture started
[13:37:50.454] - Launch lazy future ... done
[13:37:50.454] run() for ‘MultisessionFuture’ ... done
[13:37:50.456] receiveMessageFromWorker() for ClusterFuture ...
[13:37:50.456] - Validating connection of MultisessionFuture
[13:37:50.456] - received message: FutureResult
[13:37:50.456] - Received FutureResult
[13:37:50.457] - Erased future from FutureRegistry
[13:37:50.457] result() for ClusterFuture ...
[13:37:50.457] - result already collected: FutureResult
[13:37:50.457] result() for ClusterFuture ... done
[13:37:50.457] signalConditions() ...
[13:37:50.457]  - include = ‘immediateCondition’
[13:37:50.457]  - exclude = 
[13:37:50.457]  - resignal = FALSE
[13:37:50.457]  - Number of conditions: 1
[13:37:50.458] signalConditions() ... done
[13:37:50.458] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:50.458] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 0 ... DONE
- result = FALSE, recursive = 1 ...
[13:37:50.458] getGlobalsAndPackages() ...
[13:37:50.458] Searching for globals...
[13:37:50.460] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:37:50.460] Searching for globals ... DONE
[13:37:50.460] Resolving globals: FALSE
[13:37:50.460] 
[13:37:50.460] 
[13:37:50.460] getGlobalsAndPackages() ... DONE
[13:37:50.461] run() for ‘Future’ ...
[13:37:50.461] - state: ‘created’
[13:37:50.461] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:50.475] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:50.475] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:50.475]   - Field: ‘node’
[13:37:50.475]   - Field: ‘label’
[13:37:50.475]   - Field: ‘local’
[13:37:50.476]   - Field: ‘owner’
[13:37:50.476]   - Field: ‘envir’
[13:37:50.476]   - Field: ‘workers’
[13:37:50.476]   - Field: ‘packages’
[13:37:50.476]   - Field: ‘gc’
[13:37:50.476]   - Field: ‘conditions’
[13:37:50.476]   - Field: ‘persistent’
[13:37:50.476]   - Field: ‘expr’
[13:37:50.476]   - Field: ‘uuid’
[13:37:50.476]   - Field: ‘seed’
[13:37:50.476]   - Field: ‘version’
[13:37:50.477]   - Field: ‘result’
[13:37:50.477]   - Field: ‘asynchronous’
[13:37:50.477]   - Field: ‘calls’
[13:37:50.477]   - Field: ‘globals’
[13:37:50.477]   - Field: ‘stdout’
[13:37:50.477]   - Field: ‘earlySignal’
[13:37:50.477]   - Field: ‘lazy’
[13:37:50.477]   - Field: ‘state’
[13:37:50.477] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:50.477] - Launch lazy future ...
[13:37:50.478] Packages needed by the future expression (n = 0): <none>
[13:37:50.478] Packages needed by future strategies (n = 0): <none>
[13:37:50.478] {
[13:37:50.478]     {
[13:37:50.478]         {
[13:37:50.478]             ...future.startTime <- base::Sys.time()
[13:37:50.478]             {
[13:37:50.478]                 {
[13:37:50.478]                   {
[13:37:50.478]                     {
[13:37:50.478]                       base::local({
[13:37:50.478]                         has_future <- base::requireNamespace("future", 
[13:37:50.478]                           quietly = TRUE)
[13:37:50.478]                         if (has_future) {
[13:37:50.478]                           ns <- base::getNamespace("future")
[13:37:50.478]                           version <- ns[[".package"]][["version"]]
[13:37:50.478]                           if (is.null(version)) 
[13:37:50.478]                             version <- utils::packageVersion("future")
[13:37:50.478]                         }
[13:37:50.478]                         else {
[13:37:50.478]                           version <- NULL
[13:37:50.478]                         }
[13:37:50.478]                         if (!has_future || version < "1.8.0") {
[13:37:50.478]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:50.478]                             "", base::R.version$version.string), 
[13:37:50.478]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:50.478]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:50.478]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:50.478]                               "release", "version")], collapse = " "), 
[13:37:50.478]                             hostname = base::Sys.info()[["nodename"]])
[13:37:50.478]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:50.478]                             info)
[13:37:50.478]                           info <- base::paste(info, collapse = "; ")
[13:37:50.478]                           if (!has_future) {
[13:37:50.478]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:50.478]                               info)
[13:37:50.478]                           }
[13:37:50.478]                           else {
[13:37:50.478]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:50.478]                               info, version)
[13:37:50.478]                           }
[13:37:50.478]                           base::stop(msg)
[13:37:50.478]                         }
[13:37:50.478]                       })
[13:37:50.478]                     }
[13:37:50.478]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:50.478]                     base::options(mc.cores = 1L)
[13:37:50.478]                   }
[13:37:50.478]                   ...future.strategy.old <- future::plan("list")
[13:37:50.478]                   options(future.plan = NULL)
[13:37:50.478]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:50.478]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:50.478]                 }
[13:37:50.478]                 ...future.workdir <- getwd()
[13:37:50.478]             }
[13:37:50.478]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:50.478]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:50.478]         }
[13:37:50.478]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:50.478]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:50.478]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:50.478]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:50.478]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:50.478]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:50.478]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:50.478]             base::names(...future.oldOptions))
[13:37:50.478]     }
[13:37:50.478]     if (FALSE) {
[13:37:50.478]     }
[13:37:50.478]     else {
[13:37:50.478]         if (TRUE) {
[13:37:50.478]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:50.478]                 open = "w")
[13:37:50.478]         }
[13:37:50.478]         else {
[13:37:50.478]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:50.478]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:50.478]         }
[13:37:50.478]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:50.478]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:50.478]             base::sink(type = "output", split = FALSE)
[13:37:50.478]             base::close(...future.stdout)
[13:37:50.478]         }, add = TRUE)
[13:37:50.478]     }
[13:37:50.478]     ...future.frame <- base::sys.nframe()
[13:37:50.478]     ...future.conditions <- base::list()
[13:37:50.478]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:50.478]     if (FALSE) {
[13:37:50.478]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:50.478]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:50.478]     }
[13:37:50.478]     ...future.result <- base::tryCatch({
[13:37:50.478]         base::withCallingHandlers({
[13:37:50.478]             ...future.value <- base::withVisible(base::local({
[13:37:50.478]                 ...future.makeSendCondition <- base::local({
[13:37:50.478]                   sendCondition <- NULL
[13:37:50.478]                   function(frame = 1L) {
[13:37:50.478]                     if (is.function(sendCondition)) 
[13:37:50.478]                       return(sendCondition)
[13:37:50.478]                     ns <- getNamespace("parallel")
[13:37:50.478]                     if (exists("sendData", mode = "function", 
[13:37:50.478]                       envir = ns)) {
[13:37:50.478]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:50.478]                         envir = ns)
[13:37:50.478]                       envir <- sys.frame(frame)
[13:37:50.478]                       master <- NULL
[13:37:50.478]                       while (!identical(envir, .GlobalEnv) && 
[13:37:50.478]                         !identical(envir, emptyenv())) {
[13:37:50.478]                         if (exists("master", mode = "list", envir = envir, 
[13:37:50.478]                           inherits = FALSE)) {
[13:37:50.478]                           master <- get("master", mode = "list", 
[13:37:50.478]                             envir = envir, inherits = FALSE)
[13:37:50.478]                           if (inherits(master, c("SOCKnode", 
[13:37:50.478]                             "SOCK0node"))) {
[13:37:50.478]                             sendCondition <<- function(cond) {
[13:37:50.478]                               data <- list(type = "VALUE", value = cond, 
[13:37:50.478]                                 success = TRUE)
[13:37:50.478]                               parallel_sendData(master, data)
[13:37:50.478]                             }
[13:37:50.478]                             return(sendCondition)
[13:37:50.478]                           }
[13:37:50.478]                         }
[13:37:50.478]                         frame <- frame + 1L
[13:37:50.478]                         envir <- sys.frame(frame)
[13:37:50.478]                       }
[13:37:50.478]                     }
[13:37:50.478]                     sendCondition <<- function(cond) NULL
[13:37:50.478]                   }
[13:37:50.478]                 })
[13:37:50.478]                 withCallingHandlers({
[13:37:50.478]                   {
[13:37:50.478]                     Sys.sleep(0.5)
[13:37:50.478]                     list(a = 1, b = 42L)
[13:37:50.478]                   }
[13:37:50.478]                 }, immediateCondition = function(cond) {
[13:37:50.478]                   sendCondition <- ...future.makeSendCondition()
[13:37:50.478]                   sendCondition(cond)
[13:37:50.478]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:50.478]                   {
[13:37:50.478]                     inherits <- base::inherits
[13:37:50.478]                     invokeRestart <- base::invokeRestart
[13:37:50.478]                     is.null <- base::is.null
[13:37:50.478]                     muffled <- FALSE
[13:37:50.478]                     if (inherits(cond, "message")) {
[13:37:50.478]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:50.478]                       if (muffled) 
[13:37:50.478]                         invokeRestart("muffleMessage")
[13:37:50.478]                     }
[13:37:50.478]                     else if (inherits(cond, "warning")) {
[13:37:50.478]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:50.478]                       if (muffled) 
[13:37:50.478]                         invokeRestart("muffleWarning")
[13:37:50.478]                     }
[13:37:50.478]                     else if (inherits(cond, "condition")) {
[13:37:50.478]                       if (!is.null(pattern)) {
[13:37:50.478]                         computeRestarts <- base::computeRestarts
[13:37:50.478]                         grepl <- base::grepl
[13:37:50.478]                         restarts <- computeRestarts(cond)
[13:37:50.478]                         for (restart in restarts) {
[13:37:50.478]                           name <- restart$name
[13:37:50.478]                           if (is.null(name)) 
[13:37:50.478]                             next
[13:37:50.478]                           if (!grepl(pattern, name)) 
[13:37:50.478]                             next
[13:37:50.478]                           invokeRestart(restart)
[13:37:50.478]                           muffled <- TRUE
[13:37:50.478]                           break
[13:37:50.478]                         }
[13:37:50.478]                       }
[13:37:50.478]                     }
[13:37:50.478]                     invisible(muffled)
[13:37:50.478]                   }
[13:37:50.478]                   muffleCondition(cond)
[13:37:50.478]                 })
[13:37:50.478]             }))
[13:37:50.478]             future::FutureResult(value = ...future.value$value, 
[13:37:50.478]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:50.478]                   ...future.rng), globalenv = if (FALSE) 
[13:37:50.478]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:50.478]                     ...future.globalenv.names))
[13:37:50.478]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:50.478]         }, condition = base::local({
[13:37:50.478]             c <- base::c
[13:37:50.478]             inherits <- base::inherits
[13:37:50.478]             invokeRestart <- base::invokeRestart
[13:37:50.478]             length <- base::length
[13:37:50.478]             list <- base::list
[13:37:50.478]             seq.int <- base::seq.int
[13:37:50.478]             signalCondition <- base::signalCondition
[13:37:50.478]             sys.calls <- base::sys.calls
[13:37:50.478]             `[[` <- base::`[[`
[13:37:50.478]             `+` <- base::`+`
[13:37:50.478]             `<<-` <- base::`<<-`
[13:37:50.478]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:50.478]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:50.478]                   3L)]
[13:37:50.478]             }
[13:37:50.478]             function(cond) {
[13:37:50.478]                 is_error <- inherits(cond, "error")
[13:37:50.478]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:50.478]                   NULL)
[13:37:50.478]                 if (is_error) {
[13:37:50.478]                   sessionInformation <- function() {
[13:37:50.478]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:50.478]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:50.478]                       search = base::search(), system = base::Sys.info())
[13:37:50.478]                   }
[13:37:50.478]                   ...future.conditions[[length(...future.conditions) + 
[13:37:50.478]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:50.478]                     cond$call), session = sessionInformation(), 
[13:37:50.478]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:50.478]                   signalCondition(cond)
[13:37:50.478]                 }
[13:37:50.478]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:50.478]                 "immediateCondition"))) {
[13:37:50.478]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:50.478]                   ...future.conditions[[length(...future.conditions) + 
[13:37:50.478]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:50.478]                   if (TRUE && !signal) {
[13:37:50.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:50.478]                     {
[13:37:50.478]                       inherits <- base::inherits
[13:37:50.478]                       invokeRestart <- base::invokeRestart
[13:37:50.478]                       is.null <- base::is.null
[13:37:50.478]                       muffled <- FALSE
[13:37:50.478]                       if (inherits(cond, "message")) {
[13:37:50.478]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:50.478]                         if (muffled) 
[13:37:50.478]                           invokeRestart("muffleMessage")
[13:37:50.478]                       }
[13:37:50.478]                       else if (inherits(cond, "warning")) {
[13:37:50.478]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:50.478]                         if (muffled) 
[13:37:50.478]                           invokeRestart("muffleWarning")
[13:37:50.478]                       }
[13:37:50.478]                       else if (inherits(cond, "condition")) {
[13:37:50.478]                         if (!is.null(pattern)) {
[13:37:50.478]                           computeRestarts <- base::computeRestarts
[13:37:50.478]                           grepl <- base::grepl
[13:37:50.478]                           restarts <- computeRestarts(cond)
[13:37:50.478]                           for (restart in restarts) {
[13:37:50.478]                             name <- restart$name
[13:37:50.478]                             if (is.null(name)) 
[13:37:50.478]                               next
[13:37:50.478]                             if (!grepl(pattern, name)) 
[13:37:50.478]                               next
[13:37:50.478]                             invokeRestart(restart)
[13:37:50.478]                             muffled <- TRUE
[13:37:50.478]                             break
[13:37:50.478]                           }
[13:37:50.478]                         }
[13:37:50.478]                       }
[13:37:50.478]                       invisible(muffled)
[13:37:50.478]                     }
[13:37:50.478]                     muffleCondition(cond, pattern = "^muffle")
[13:37:50.478]                   }
[13:37:50.478]                 }
[13:37:50.478]                 else {
[13:37:50.478]                   if (TRUE) {
[13:37:50.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:50.478]                     {
[13:37:50.478]                       inherits <- base::inherits
[13:37:50.478]                       invokeRestart <- base::invokeRestart
[13:37:50.478]                       is.null <- base::is.null
[13:37:50.478]                       muffled <- FALSE
[13:37:50.478]                       if (inherits(cond, "message")) {
[13:37:50.478]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:50.478]                         if (muffled) 
[13:37:50.478]                           invokeRestart("muffleMessage")
[13:37:50.478]                       }
[13:37:50.478]                       else if (inherits(cond, "warning")) {
[13:37:50.478]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:50.478]                         if (muffled) 
[13:37:50.478]                           invokeRestart("muffleWarning")
[13:37:50.478]                       }
[13:37:50.478]                       else if (inherits(cond, "condition")) {
[13:37:50.478]                         if (!is.null(pattern)) {
[13:37:50.478]                           computeRestarts <- base::computeRestarts
[13:37:50.478]                           grepl <- base::grepl
[13:37:50.478]                           restarts <- computeRestarts(cond)
[13:37:50.478]                           for (restart in restarts) {
[13:37:50.478]                             name <- restart$name
[13:37:50.478]                             if (is.null(name)) 
[13:37:50.478]                               next
[13:37:50.478]                             if (!grepl(pattern, name)) 
[13:37:50.478]                               next
[13:37:50.478]                             invokeRestart(restart)
[13:37:50.478]                             muffled <- TRUE
[13:37:50.478]                             break
[13:37:50.478]                           }
[13:37:50.478]                         }
[13:37:50.478]                       }
[13:37:50.478]                       invisible(muffled)
[13:37:50.478]                     }
[13:37:50.478]                     muffleCondition(cond, pattern = "^muffle")
[13:37:50.478]                   }
[13:37:50.478]                 }
[13:37:50.478]             }
[13:37:50.478]         }))
[13:37:50.478]     }, error = function(ex) {
[13:37:50.478]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:50.478]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:50.478]                 ...future.rng), started = ...future.startTime, 
[13:37:50.478]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:50.478]             version = "1.8"), class = "FutureResult")
[13:37:50.478]     }, finally = {
[13:37:50.478]         if (!identical(...future.workdir, getwd())) 
[13:37:50.478]             setwd(...future.workdir)
[13:37:50.478]         {
[13:37:50.478]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:50.478]                 ...future.oldOptions$nwarnings <- NULL
[13:37:50.478]             }
[13:37:50.478]             base::options(...future.oldOptions)
[13:37:50.478]             if (.Platform$OS.type == "windows") {
[13:37:50.478]                 old_names <- names(...future.oldEnvVars)
[13:37:50.478]                 envs <- base::Sys.getenv()
[13:37:50.478]                 names <- names(envs)
[13:37:50.478]                 common <- intersect(names, old_names)
[13:37:50.478]                 added <- setdiff(names, old_names)
[13:37:50.478]                 removed <- setdiff(old_names, names)
[13:37:50.478]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:50.478]                   envs[common]]
[13:37:50.478]                 NAMES <- toupper(changed)
[13:37:50.478]                 args <- list()
[13:37:50.478]                 for (kk in seq_along(NAMES)) {
[13:37:50.478]                   name <- changed[[kk]]
[13:37:50.478]                   NAME <- NAMES[[kk]]
[13:37:50.478]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:50.478]                     next
[13:37:50.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:50.478]                 }
[13:37:50.478]                 NAMES <- toupper(added)
[13:37:50.478]                 for (kk in seq_along(NAMES)) {
[13:37:50.478]                   name <- added[[kk]]
[13:37:50.478]                   NAME <- NAMES[[kk]]
[13:37:50.478]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:50.478]                     next
[13:37:50.478]                   args[[name]] <- ""
[13:37:50.478]                 }
[13:37:50.478]                 NAMES <- toupper(removed)
[13:37:50.478]                 for (kk in seq_along(NAMES)) {
[13:37:50.478]                   name <- removed[[kk]]
[13:37:50.478]                   NAME <- NAMES[[kk]]
[13:37:50.478]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:50.478]                     next
[13:37:50.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:50.478]                 }
[13:37:50.478]                 if (length(args) > 0) 
[13:37:50.478]                   base::do.call(base::Sys.setenv, args = args)
[13:37:50.478]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:50.478]             }
[13:37:50.478]             else {
[13:37:50.478]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:50.478]             }
[13:37:50.478]             {
[13:37:50.478]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:50.478]                   0L) {
[13:37:50.478]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:50.478]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:50.478]                   base::options(opts)
[13:37:50.478]                 }
[13:37:50.478]                 {
[13:37:50.478]                   {
[13:37:50.478]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:50.478]                     NULL
[13:37:50.478]                   }
[13:37:50.478]                   options(future.plan = NULL)
[13:37:50.478]                   if (is.na(NA_character_)) 
[13:37:50.478]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:50.478]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:50.478]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:50.478]                     .init = FALSE)
[13:37:50.478]                 }
[13:37:50.478]             }
[13:37:50.478]         }
[13:37:50.478]     })
[13:37:50.478]     if (TRUE) {
[13:37:50.478]         base::sink(type = "output", split = FALSE)
[13:37:50.478]         if (TRUE) {
[13:37:50.478]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:50.478]         }
[13:37:50.478]         else {
[13:37:50.478]             ...future.result["stdout"] <- base::list(NULL)
[13:37:50.478]         }
[13:37:50.478]         base::close(...future.stdout)
[13:37:50.478]         ...future.stdout <- NULL
[13:37:50.478]     }
[13:37:50.478]     ...future.result$conditions <- ...future.conditions
[13:37:50.478]     ...future.result$finished <- base::Sys.time()
[13:37:50.478]     ...future.result
[13:37:50.478] }
[13:37:50.481] MultisessionFuture started
[13:37:50.481] - Launch lazy future ... done
[13:37:50.481] run() for ‘MultisessionFuture’ ... done
[13:37:50.983] receiveMessageFromWorker() for ClusterFuture ...
[13:37:50.984] - Validating connection of MultisessionFuture
[13:37:50.984] - received message: FutureResult
[13:37:50.984] - Received FutureResult
[13:37:50.984] - Erased future from FutureRegistry
[13:37:50.984] result() for ClusterFuture ...
[13:37:50.984] - result already collected: FutureResult
[13:37:50.985] result() for ClusterFuture ... done
[13:37:50.985] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:50.985] A MultisessionFuture was resolved (result was not collected)
[13:37:50.985] getGlobalsAndPackages() ...
[13:37:50.985] Searching for globals...
[13:37:50.986] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:37:50.986] Searching for globals ... DONE
[13:37:50.986] Resolving globals: FALSE
[13:37:50.987] 
[13:37:50.987] 
[13:37:50.987] getGlobalsAndPackages() ... DONE
[13:37:50.987] run() for ‘Future’ ...
[13:37:50.987] - state: ‘created’
[13:37:50.987] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:51.001] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:51.001] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:51.001]   - Field: ‘node’
[13:37:51.002]   - Field: ‘label’
[13:37:51.002]   - Field: ‘local’
[13:37:51.002]   - Field: ‘owner’
[13:37:51.002]   - Field: ‘envir’
[13:37:51.002]   - Field: ‘workers’
[13:37:51.002]   - Field: ‘packages’
[13:37:51.002]   - Field: ‘gc’
[13:37:51.002]   - Field: ‘conditions’
[13:37:51.002]   - Field: ‘persistent’
[13:37:51.002]   - Field: ‘expr’
[13:37:51.003]   - Field: ‘uuid’
[13:37:51.003]   - Field: ‘seed’
[13:37:51.003]   - Field: ‘version’
[13:37:51.003]   - Field: ‘result’
[13:37:51.003]   - Field: ‘asynchronous’
[13:37:51.003]   - Field: ‘calls’
[13:37:51.003]   - Field: ‘globals’
[13:37:51.003]   - Field: ‘stdout’
[13:37:51.003]   - Field: ‘earlySignal’
[13:37:51.003]   - Field: ‘lazy’
[13:37:51.003]   - Field: ‘state’
[13:37:51.004] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:51.004] - Launch lazy future ...
[13:37:51.004] Packages needed by the future expression (n = 0): <none>
[13:37:51.004] Packages needed by future strategies (n = 0): <none>
[13:37:51.004] {
[13:37:51.004]     {
[13:37:51.004]         {
[13:37:51.004]             ...future.startTime <- base::Sys.time()
[13:37:51.004]             {
[13:37:51.004]                 {
[13:37:51.004]                   {
[13:37:51.004]                     {
[13:37:51.004]                       base::local({
[13:37:51.004]                         has_future <- base::requireNamespace("future", 
[13:37:51.004]                           quietly = TRUE)
[13:37:51.004]                         if (has_future) {
[13:37:51.004]                           ns <- base::getNamespace("future")
[13:37:51.004]                           version <- ns[[".package"]][["version"]]
[13:37:51.004]                           if (is.null(version)) 
[13:37:51.004]                             version <- utils::packageVersion("future")
[13:37:51.004]                         }
[13:37:51.004]                         else {
[13:37:51.004]                           version <- NULL
[13:37:51.004]                         }
[13:37:51.004]                         if (!has_future || version < "1.8.0") {
[13:37:51.004]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:51.004]                             "", base::R.version$version.string), 
[13:37:51.004]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:51.004]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:51.004]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:51.004]                               "release", "version")], collapse = " "), 
[13:37:51.004]                             hostname = base::Sys.info()[["nodename"]])
[13:37:51.004]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:51.004]                             info)
[13:37:51.004]                           info <- base::paste(info, collapse = "; ")
[13:37:51.004]                           if (!has_future) {
[13:37:51.004]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:51.004]                               info)
[13:37:51.004]                           }
[13:37:51.004]                           else {
[13:37:51.004]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:51.004]                               info, version)
[13:37:51.004]                           }
[13:37:51.004]                           base::stop(msg)
[13:37:51.004]                         }
[13:37:51.004]                       })
[13:37:51.004]                     }
[13:37:51.004]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:51.004]                     base::options(mc.cores = 1L)
[13:37:51.004]                   }
[13:37:51.004]                   ...future.strategy.old <- future::plan("list")
[13:37:51.004]                   options(future.plan = NULL)
[13:37:51.004]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:51.004]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:51.004]                 }
[13:37:51.004]                 ...future.workdir <- getwd()
[13:37:51.004]             }
[13:37:51.004]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:51.004]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:51.004]         }
[13:37:51.004]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:51.004]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:51.004]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:51.004]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:51.004]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:51.004]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:51.004]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:51.004]             base::names(...future.oldOptions))
[13:37:51.004]     }
[13:37:51.004]     if (FALSE) {
[13:37:51.004]     }
[13:37:51.004]     else {
[13:37:51.004]         if (TRUE) {
[13:37:51.004]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:51.004]                 open = "w")
[13:37:51.004]         }
[13:37:51.004]         else {
[13:37:51.004]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:51.004]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:51.004]         }
[13:37:51.004]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:51.004]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:51.004]             base::sink(type = "output", split = FALSE)
[13:37:51.004]             base::close(...future.stdout)
[13:37:51.004]         }, add = TRUE)
[13:37:51.004]     }
[13:37:51.004]     ...future.frame <- base::sys.nframe()
[13:37:51.004]     ...future.conditions <- base::list()
[13:37:51.004]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:51.004]     if (FALSE) {
[13:37:51.004]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:51.004]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:51.004]     }
[13:37:51.004]     ...future.result <- base::tryCatch({
[13:37:51.004]         base::withCallingHandlers({
[13:37:51.004]             ...future.value <- base::withVisible(base::local({
[13:37:51.004]                 ...future.makeSendCondition <- base::local({
[13:37:51.004]                   sendCondition <- NULL
[13:37:51.004]                   function(frame = 1L) {
[13:37:51.004]                     if (is.function(sendCondition)) 
[13:37:51.004]                       return(sendCondition)
[13:37:51.004]                     ns <- getNamespace("parallel")
[13:37:51.004]                     if (exists("sendData", mode = "function", 
[13:37:51.004]                       envir = ns)) {
[13:37:51.004]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:51.004]                         envir = ns)
[13:37:51.004]                       envir <- sys.frame(frame)
[13:37:51.004]                       master <- NULL
[13:37:51.004]                       while (!identical(envir, .GlobalEnv) && 
[13:37:51.004]                         !identical(envir, emptyenv())) {
[13:37:51.004]                         if (exists("master", mode = "list", envir = envir, 
[13:37:51.004]                           inherits = FALSE)) {
[13:37:51.004]                           master <- get("master", mode = "list", 
[13:37:51.004]                             envir = envir, inherits = FALSE)
[13:37:51.004]                           if (inherits(master, c("SOCKnode", 
[13:37:51.004]                             "SOCK0node"))) {
[13:37:51.004]                             sendCondition <<- function(cond) {
[13:37:51.004]                               data <- list(type = "VALUE", value = cond, 
[13:37:51.004]                                 success = TRUE)
[13:37:51.004]                               parallel_sendData(master, data)
[13:37:51.004]                             }
[13:37:51.004]                             return(sendCondition)
[13:37:51.004]                           }
[13:37:51.004]                         }
[13:37:51.004]                         frame <- frame + 1L
[13:37:51.004]                         envir <- sys.frame(frame)
[13:37:51.004]                       }
[13:37:51.004]                     }
[13:37:51.004]                     sendCondition <<- function(cond) NULL
[13:37:51.004]                   }
[13:37:51.004]                 })
[13:37:51.004]                 withCallingHandlers({
[13:37:51.004]                   {
[13:37:51.004]                     Sys.sleep(0.5)
[13:37:51.004]                     list(a = 1, b = 42L)
[13:37:51.004]                   }
[13:37:51.004]                 }, immediateCondition = function(cond) {
[13:37:51.004]                   sendCondition <- ...future.makeSendCondition()
[13:37:51.004]                   sendCondition(cond)
[13:37:51.004]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:51.004]                   {
[13:37:51.004]                     inherits <- base::inherits
[13:37:51.004]                     invokeRestart <- base::invokeRestart
[13:37:51.004]                     is.null <- base::is.null
[13:37:51.004]                     muffled <- FALSE
[13:37:51.004]                     if (inherits(cond, "message")) {
[13:37:51.004]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:51.004]                       if (muffled) 
[13:37:51.004]                         invokeRestart("muffleMessage")
[13:37:51.004]                     }
[13:37:51.004]                     else if (inherits(cond, "warning")) {
[13:37:51.004]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:51.004]                       if (muffled) 
[13:37:51.004]                         invokeRestart("muffleWarning")
[13:37:51.004]                     }
[13:37:51.004]                     else if (inherits(cond, "condition")) {
[13:37:51.004]                       if (!is.null(pattern)) {
[13:37:51.004]                         computeRestarts <- base::computeRestarts
[13:37:51.004]                         grepl <- base::grepl
[13:37:51.004]                         restarts <- computeRestarts(cond)
[13:37:51.004]                         for (restart in restarts) {
[13:37:51.004]                           name <- restart$name
[13:37:51.004]                           if (is.null(name)) 
[13:37:51.004]                             next
[13:37:51.004]                           if (!grepl(pattern, name)) 
[13:37:51.004]                             next
[13:37:51.004]                           invokeRestart(restart)
[13:37:51.004]                           muffled <- TRUE
[13:37:51.004]                           break
[13:37:51.004]                         }
[13:37:51.004]                       }
[13:37:51.004]                     }
[13:37:51.004]                     invisible(muffled)
[13:37:51.004]                   }
[13:37:51.004]                   muffleCondition(cond)
[13:37:51.004]                 })
[13:37:51.004]             }))
[13:37:51.004]             future::FutureResult(value = ...future.value$value, 
[13:37:51.004]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:51.004]                   ...future.rng), globalenv = if (FALSE) 
[13:37:51.004]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:51.004]                     ...future.globalenv.names))
[13:37:51.004]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:51.004]         }, condition = base::local({
[13:37:51.004]             c <- base::c
[13:37:51.004]             inherits <- base::inherits
[13:37:51.004]             invokeRestart <- base::invokeRestart
[13:37:51.004]             length <- base::length
[13:37:51.004]             list <- base::list
[13:37:51.004]             seq.int <- base::seq.int
[13:37:51.004]             signalCondition <- base::signalCondition
[13:37:51.004]             sys.calls <- base::sys.calls
[13:37:51.004]             `[[` <- base::`[[`
[13:37:51.004]             `+` <- base::`+`
[13:37:51.004]             `<<-` <- base::`<<-`
[13:37:51.004]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:51.004]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:51.004]                   3L)]
[13:37:51.004]             }
[13:37:51.004]             function(cond) {
[13:37:51.004]                 is_error <- inherits(cond, "error")
[13:37:51.004]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:51.004]                   NULL)
[13:37:51.004]                 if (is_error) {
[13:37:51.004]                   sessionInformation <- function() {
[13:37:51.004]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:51.004]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:51.004]                       search = base::search(), system = base::Sys.info())
[13:37:51.004]                   }
[13:37:51.004]                   ...future.conditions[[length(...future.conditions) + 
[13:37:51.004]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:51.004]                     cond$call), session = sessionInformation(), 
[13:37:51.004]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:51.004]                   signalCondition(cond)
[13:37:51.004]                 }
[13:37:51.004]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:51.004]                 "immediateCondition"))) {
[13:37:51.004]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:51.004]                   ...future.conditions[[length(...future.conditions) + 
[13:37:51.004]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:51.004]                   if (TRUE && !signal) {
[13:37:51.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:51.004]                     {
[13:37:51.004]                       inherits <- base::inherits
[13:37:51.004]                       invokeRestart <- base::invokeRestart
[13:37:51.004]                       is.null <- base::is.null
[13:37:51.004]                       muffled <- FALSE
[13:37:51.004]                       if (inherits(cond, "message")) {
[13:37:51.004]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:51.004]                         if (muffled) 
[13:37:51.004]                           invokeRestart("muffleMessage")
[13:37:51.004]                       }
[13:37:51.004]                       else if (inherits(cond, "warning")) {
[13:37:51.004]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:51.004]                         if (muffled) 
[13:37:51.004]                           invokeRestart("muffleWarning")
[13:37:51.004]                       }
[13:37:51.004]                       else if (inherits(cond, "condition")) {
[13:37:51.004]                         if (!is.null(pattern)) {
[13:37:51.004]                           computeRestarts <- base::computeRestarts
[13:37:51.004]                           grepl <- base::grepl
[13:37:51.004]                           restarts <- computeRestarts(cond)
[13:37:51.004]                           for (restart in restarts) {
[13:37:51.004]                             name <- restart$name
[13:37:51.004]                             if (is.null(name)) 
[13:37:51.004]                               next
[13:37:51.004]                             if (!grepl(pattern, name)) 
[13:37:51.004]                               next
[13:37:51.004]                             invokeRestart(restart)
[13:37:51.004]                             muffled <- TRUE
[13:37:51.004]                             break
[13:37:51.004]                           }
[13:37:51.004]                         }
[13:37:51.004]                       }
[13:37:51.004]                       invisible(muffled)
[13:37:51.004]                     }
[13:37:51.004]                     muffleCondition(cond, pattern = "^muffle")
[13:37:51.004]                   }
[13:37:51.004]                 }
[13:37:51.004]                 else {
[13:37:51.004]                   if (TRUE) {
[13:37:51.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:51.004]                     {
[13:37:51.004]                       inherits <- base::inherits
[13:37:51.004]                       invokeRestart <- base::invokeRestart
[13:37:51.004]                       is.null <- base::is.null
[13:37:51.004]                       muffled <- FALSE
[13:37:51.004]                       if (inherits(cond, "message")) {
[13:37:51.004]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:51.004]                         if (muffled) 
[13:37:51.004]                           invokeRestart("muffleMessage")
[13:37:51.004]                       }
[13:37:51.004]                       else if (inherits(cond, "warning")) {
[13:37:51.004]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:51.004]                         if (muffled) 
[13:37:51.004]                           invokeRestart("muffleWarning")
[13:37:51.004]                       }
[13:37:51.004]                       else if (inherits(cond, "condition")) {
[13:37:51.004]                         if (!is.null(pattern)) {
[13:37:51.004]                           computeRestarts <- base::computeRestarts
[13:37:51.004]                           grepl <- base::grepl
[13:37:51.004]                           restarts <- computeRestarts(cond)
[13:37:51.004]                           for (restart in restarts) {
[13:37:51.004]                             name <- restart$name
[13:37:51.004]                             if (is.null(name)) 
[13:37:51.004]                               next
[13:37:51.004]                             if (!grepl(pattern, name)) 
[13:37:51.004]                               next
[13:37:51.004]                             invokeRestart(restart)
[13:37:51.004]                             muffled <- TRUE
[13:37:51.004]                             break
[13:37:51.004]                           }
[13:37:51.004]                         }
[13:37:51.004]                       }
[13:37:51.004]                       invisible(muffled)
[13:37:51.004]                     }
[13:37:51.004]                     muffleCondition(cond, pattern = "^muffle")
[13:37:51.004]                   }
[13:37:51.004]                 }
[13:37:51.004]             }
[13:37:51.004]         }))
[13:37:51.004]     }, error = function(ex) {
[13:37:51.004]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:51.004]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:51.004]                 ...future.rng), started = ...future.startTime, 
[13:37:51.004]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:51.004]             version = "1.8"), class = "FutureResult")
[13:37:51.004]     }, finally = {
[13:37:51.004]         if (!identical(...future.workdir, getwd())) 
[13:37:51.004]             setwd(...future.workdir)
[13:37:51.004]         {
[13:37:51.004]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:51.004]                 ...future.oldOptions$nwarnings <- NULL
[13:37:51.004]             }
[13:37:51.004]             base::options(...future.oldOptions)
[13:37:51.004]             if (.Platform$OS.type == "windows") {
[13:37:51.004]                 old_names <- names(...future.oldEnvVars)
[13:37:51.004]                 envs <- base::Sys.getenv()
[13:37:51.004]                 names <- names(envs)
[13:37:51.004]                 common <- intersect(names, old_names)
[13:37:51.004]                 added <- setdiff(names, old_names)
[13:37:51.004]                 removed <- setdiff(old_names, names)
[13:37:51.004]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:51.004]                   envs[common]]
[13:37:51.004]                 NAMES <- toupper(changed)
[13:37:51.004]                 args <- list()
[13:37:51.004]                 for (kk in seq_along(NAMES)) {
[13:37:51.004]                   name <- changed[[kk]]
[13:37:51.004]                   NAME <- NAMES[[kk]]
[13:37:51.004]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:51.004]                     next
[13:37:51.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:51.004]                 }
[13:37:51.004]                 NAMES <- toupper(added)
[13:37:51.004]                 for (kk in seq_along(NAMES)) {
[13:37:51.004]                   name <- added[[kk]]
[13:37:51.004]                   NAME <- NAMES[[kk]]
[13:37:51.004]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:51.004]                     next
[13:37:51.004]                   args[[name]] <- ""
[13:37:51.004]                 }
[13:37:51.004]                 NAMES <- toupper(removed)
[13:37:51.004]                 for (kk in seq_along(NAMES)) {
[13:37:51.004]                   name <- removed[[kk]]
[13:37:51.004]                   NAME <- NAMES[[kk]]
[13:37:51.004]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:51.004]                     next
[13:37:51.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:51.004]                 }
[13:37:51.004]                 if (length(args) > 0) 
[13:37:51.004]                   base::do.call(base::Sys.setenv, args = args)
[13:37:51.004]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:51.004]             }
[13:37:51.004]             else {
[13:37:51.004]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:51.004]             }
[13:37:51.004]             {
[13:37:51.004]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:51.004]                   0L) {
[13:37:51.004]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:51.004]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:51.004]                   base::options(opts)
[13:37:51.004]                 }
[13:37:51.004]                 {
[13:37:51.004]                   {
[13:37:51.004]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:51.004]                     NULL
[13:37:51.004]                   }
[13:37:51.004]                   options(future.plan = NULL)
[13:37:51.004]                   if (is.na(NA_character_)) 
[13:37:51.004]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:51.004]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:51.004]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:51.004]                     .init = FALSE)
[13:37:51.004]                 }
[13:37:51.004]             }
[13:37:51.004]         }
[13:37:51.004]     })
[13:37:51.004]     if (TRUE) {
[13:37:51.004]         base::sink(type = "output", split = FALSE)
[13:37:51.004]         if (TRUE) {
[13:37:51.004]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:51.004]         }
[13:37:51.004]         else {
[13:37:51.004]             ...future.result["stdout"] <- base::list(NULL)
[13:37:51.004]         }
[13:37:51.004]         base::close(...future.stdout)
[13:37:51.004]         ...future.stdout <- NULL
[13:37:51.004]     }
[13:37:51.004]     ...future.result$conditions <- ...future.conditions
[13:37:51.004]     ...future.result$finished <- base::Sys.time()
[13:37:51.004]     ...future.result
[13:37:51.004] }
[13:37:51.007] MultisessionFuture started
[13:37:51.008] - Launch lazy future ... done
[13:37:51.008] run() for ‘MultisessionFuture’ ... done
[13:37:51.510] receiveMessageFromWorker() for ClusterFuture ...
[13:37:51.511] - Validating connection of MultisessionFuture
[13:37:51.511] - received message: FutureResult
[13:37:51.511] - Received FutureResult
[13:37:51.511] - Erased future from FutureRegistry
[13:37:51.511] result() for ClusterFuture ...
[13:37:51.512] - result already collected: FutureResult
[13:37:51.512] result() for ClusterFuture ... done
[13:37:51.512] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:51.512] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[13:37:51.512] getGlobalsAndPackages() ...
[13:37:51.512] Searching for globals...
[13:37:51.513] - globals found: [2] ‘list’, ‘stop’
[13:37:51.513] Searching for globals ... DONE
[13:37:51.513] Resolving globals: FALSE
[13:37:51.513] 
[13:37:51.513] 
[13:37:51.514] getGlobalsAndPackages() ... DONE
[13:37:51.514] run() for ‘Future’ ...
[13:37:51.514] - state: ‘created’
[13:37:51.514] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:51.528] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:51.528] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:51.528]   - Field: ‘node’
[13:37:51.529]   - Field: ‘label’
[13:37:51.529]   - Field: ‘local’
[13:37:51.529]   - Field: ‘owner’
[13:37:51.529]   - Field: ‘envir’
[13:37:51.529]   - Field: ‘workers’
[13:37:51.529]   - Field: ‘packages’
[13:37:51.529]   - Field: ‘gc’
[13:37:51.529]   - Field: ‘conditions’
[13:37:51.529]   - Field: ‘persistent’
[13:37:51.529]   - Field: ‘expr’
[13:37:51.529]   - Field: ‘uuid’
[13:37:51.530]   - Field: ‘seed’
[13:37:51.530]   - Field: ‘version’
[13:37:51.530]   - Field: ‘result’
[13:37:51.530]   - Field: ‘asynchronous’
[13:37:51.530]   - Field: ‘calls’
[13:37:51.530]   - Field: ‘globals’
[13:37:51.530]   - Field: ‘stdout’
[13:37:51.530]   - Field: ‘earlySignal’
[13:37:51.530]   - Field: ‘lazy’
[13:37:51.530]   - Field: ‘state’
[13:37:51.531] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:51.531] - Launch lazy future ...
[13:37:51.531] Packages needed by the future expression (n = 0): <none>
[13:37:51.531] Packages needed by future strategies (n = 0): <none>
[13:37:51.531] {
[13:37:51.531]     {
[13:37:51.531]         {
[13:37:51.531]             ...future.startTime <- base::Sys.time()
[13:37:51.531]             {
[13:37:51.531]                 {
[13:37:51.531]                   {
[13:37:51.531]                     {
[13:37:51.531]                       base::local({
[13:37:51.531]                         has_future <- base::requireNamespace("future", 
[13:37:51.531]                           quietly = TRUE)
[13:37:51.531]                         if (has_future) {
[13:37:51.531]                           ns <- base::getNamespace("future")
[13:37:51.531]                           version <- ns[[".package"]][["version"]]
[13:37:51.531]                           if (is.null(version)) 
[13:37:51.531]                             version <- utils::packageVersion("future")
[13:37:51.531]                         }
[13:37:51.531]                         else {
[13:37:51.531]                           version <- NULL
[13:37:51.531]                         }
[13:37:51.531]                         if (!has_future || version < "1.8.0") {
[13:37:51.531]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:51.531]                             "", base::R.version$version.string), 
[13:37:51.531]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:51.531]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:51.531]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:51.531]                               "release", "version")], collapse = " "), 
[13:37:51.531]                             hostname = base::Sys.info()[["nodename"]])
[13:37:51.531]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:51.531]                             info)
[13:37:51.531]                           info <- base::paste(info, collapse = "; ")
[13:37:51.531]                           if (!has_future) {
[13:37:51.531]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:51.531]                               info)
[13:37:51.531]                           }
[13:37:51.531]                           else {
[13:37:51.531]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:51.531]                               info, version)
[13:37:51.531]                           }
[13:37:51.531]                           base::stop(msg)
[13:37:51.531]                         }
[13:37:51.531]                       })
[13:37:51.531]                     }
[13:37:51.531]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:51.531]                     base::options(mc.cores = 1L)
[13:37:51.531]                   }
[13:37:51.531]                   ...future.strategy.old <- future::plan("list")
[13:37:51.531]                   options(future.plan = NULL)
[13:37:51.531]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:51.531]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:51.531]                 }
[13:37:51.531]                 ...future.workdir <- getwd()
[13:37:51.531]             }
[13:37:51.531]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:51.531]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:51.531]         }
[13:37:51.531]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:51.531]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:51.531]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:51.531]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:51.531]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:51.531]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:51.531]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:51.531]             base::names(...future.oldOptions))
[13:37:51.531]     }
[13:37:51.531]     if (FALSE) {
[13:37:51.531]     }
[13:37:51.531]     else {
[13:37:51.531]         if (TRUE) {
[13:37:51.531]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:51.531]                 open = "w")
[13:37:51.531]         }
[13:37:51.531]         else {
[13:37:51.531]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:51.531]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:51.531]         }
[13:37:51.531]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:51.531]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:51.531]             base::sink(type = "output", split = FALSE)
[13:37:51.531]             base::close(...future.stdout)
[13:37:51.531]         }, add = TRUE)
[13:37:51.531]     }
[13:37:51.531]     ...future.frame <- base::sys.nframe()
[13:37:51.531]     ...future.conditions <- base::list()
[13:37:51.531]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:51.531]     if (FALSE) {
[13:37:51.531]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:51.531]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:51.531]     }
[13:37:51.531]     ...future.result <- base::tryCatch({
[13:37:51.531]         base::withCallingHandlers({
[13:37:51.531]             ...future.value <- base::withVisible(base::local({
[13:37:51.531]                 ...future.makeSendCondition <- base::local({
[13:37:51.531]                   sendCondition <- NULL
[13:37:51.531]                   function(frame = 1L) {
[13:37:51.531]                     if (is.function(sendCondition)) 
[13:37:51.531]                       return(sendCondition)
[13:37:51.531]                     ns <- getNamespace("parallel")
[13:37:51.531]                     if (exists("sendData", mode = "function", 
[13:37:51.531]                       envir = ns)) {
[13:37:51.531]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:51.531]                         envir = ns)
[13:37:51.531]                       envir <- sys.frame(frame)
[13:37:51.531]                       master <- NULL
[13:37:51.531]                       while (!identical(envir, .GlobalEnv) && 
[13:37:51.531]                         !identical(envir, emptyenv())) {
[13:37:51.531]                         if (exists("master", mode = "list", envir = envir, 
[13:37:51.531]                           inherits = FALSE)) {
[13:37:51.531]                           master <- get("master", mode = "list", 
[13:37:51.531]                             envir = envir, inherits = FALSE)
[13:37:51.531]                           if (inherits(master, c("SOCKnode", 
[13:37:51.531]                             "SOCK0node"))) {
[13:37:51.531]                             sendCondition <<- function(cond) {
[13:37:51.531]                               data <- list(type = "VALUE", value = cond, 
[13:37:51.531]                                 success = TRUE)
[13:37:51.531]                               parallel_sendData(master, data)
[13:37:51.531]                             }
[13:37:51.531]                             return(sendCondition)
[13:37:51.531]                           }
[13:37:51.531]                         }
[13:37:51.531]                         frame <- frame + 1L
[13:37:51.531]                         envir <- sys.frame(frame)
[13:37:51.531]                       }
[13:37:51.531]                     }
[13:37:51.531]                     sendCondition <<- function(cond) NULL
[13:37:51.531]                   }
[13:37:51.531]                 })
[13:37:51.531]                 withCallingHandlers({
[13:37:51.531]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:37:51.531]                 }, immediateCondition = function(cond) {
[13:37:51.531]                   sendCondition <- ...future.makeSendCondition()
[13:37:51.531]                   sendCondition(cond)
[13:37:51.531]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:51.531]                   {
[13:37:51.531]                     inherits <- base::inherits
[13:37:51.531]                     invokeRestart <- base::invokeRestart
[13:37:51.531]                     is.null <- base::is.null
[13:37:51.531]                     muffled <- FALSE
[13:37:51.531]                     if (inherits(cond, "message")) {
[13:37:51.531]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:51.531]                       if (muffled) 
[13:37:51.531]                         invokeRestart("muffleMessage")
[13:37:51.531]                     }
[13:37:51.531]                     else if (inherits(cond, "warning")) {
[13:37:51.531]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:51.531]                       if (muffled) 
[13:37:51.531]                         invokeRestart("muffleWarning")
[13:37:51.531]                     }
[13:37:51.531]                     else if (inherits(cond, "condition")) {
[13:37:51.531]                       if (!is.null(pattern)) {
[13:37:51.531]                         computeRestarts <- base::computeRestarts
[13:37:51.531]                         grepl <- base::grepl
[13:37:51.531]                         restarts <- computeRestarts(cond)
[13:37:51.531]                         for (restart in restarts) {
[13:37:51.531]                           name <- restart$name
[13:37:51.531]                           if (is.null(name)) 
[13:37:51.531]                             next
[13:37:51.531]                           if (!grepl(pattern, name)) 
[13:37:51.531]                             next
[13:37:51.531]                           invokeRestart(restart)
[13:37:51.531]                           muffled <- TRUE
[13:37:51.531]                           break
[13:37:51.531]                         }
[13:37:51.531]                       }
[13:37:51.531]                     }
[13:37:51.531]                     invisible(muffled)
[13:37:51.531]                   }
[13:37:51.531]                   muffleCondition(cond)
[13:37:51.531]                 })
[13:37:51.531]             }))
[13:37:51.531]             future::FutureResult(value = ...future.value$value, 
[13:37:51.531]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:51.531]                   ...future.rng), globalenv = if (FALSE) 
[13:37:51.531]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:51.531]                     ...future.globalenv.names))
[13:37:51.531]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:51.531]         }, condition = base::local({
[13:37:51.531]             c <- base::c
[13:37:51.531]             inherits <- base::inherits
[13:37:51.531]             invokeRestart <- base::invokeRestart
[13:37:51.531]             length <- base::length
[13:37:51.531]             list <- base::list
[13:37:51.531]             seq.int <- base::seq.int
[13:37:51.531]             signalCondition <- base::signalCondition
[13:37:51.531]             sys.calls <- base::sys.calls
[13:37:51.531]             `[[` <- base::`[[`
[13:37:51.531]             `+` <- base::`+`
[13:37:51.531]             `<<-` <- base::`<<-`
[13:37:51.531]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:51.531]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:51.531]                   3L)]
[13:37:51.531]             }
[13:37:51.531]             function(cond) {
[13:37:51.531]                 is_error <- inherits(cond, "error")
[13:37:51.531]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:51.531]                   NULL)
[13:37:51.531]                 if (is_error) {
[13:37:51.531]                   sessionInformation <- function() {
[13:37:51.531]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:51.531]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:51.531]                       search = base::search(), system = base::Sys.info())
[13:37:51.531]                   }
[13:37:51.531]                   ...future.conditions[[length(...future.conditions) + 
[13:37:51.531]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:51.531]                     cond$call), session = sessionInformation(), 
[13:37:51.531]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:51.531]                   signalCondition(cond)
[13:37:51.531]                 }
[13:37:51.531]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:51.531]                 "immediateCondition"))) {
[13:37:51.531]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:51.531]                   ...future.conditions[[length(...future.conditions) + 
[13:37:51.531]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:51.531]                   if (TRUE && !signal) {
[13:37:51.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:51.531]                     {
[13:37:51.531]                       inherits <- base::inherits
[13:37:51.531]                       invokeRestart <- base::invokeRestart
[13:37:51.531]                       is.null <- base::is.null
[13:37:51.531]                       muffled <- FALSE
[13:37:51.531]                       if (inherits(cond, "message")) {
[13:37:51.531]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:51.531]                         if (muffled) 
[13:37:51.531]                           invokeRestart("muffleMessage")
[13:37:51.531]                       }
[13:37:51.531]                       else if (inherits(cond, "warning")) {
[13:37:51.531]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:51.531]                         if (muffled) 
[13:37:51.531]                           invokeRestart("muffleWarning")
[13:37:51.531]                       }
[13:37:51.531]                       else if (inherits(cond, "condition")) {
[13:37:51.531]                         if (!is.null(pattern)) {
[13:37:51.531]                           computeRestarts <- base::computeRestarts
[13:37:51.531]                           grepl <- base::grepl
[13:37:51.531]                           restarts <- computeRestarts(cond)
[13:37:51.531]                           for (restart in restarts) {
[13:37:51.531]                             name <- restart$name
[13:37:51.531]                             if (is.null(name)) 
[13:37:51.531]                               next
[13:37:51.531]                             if (!grepl(pattern, name)) 
[13:37:51.531]                               next
[13:37:51.531]                             invokeRestart(restart)
[13:37:51.531]                             muffled <- TRUE
[13:37:51.531]                             break
[13:37:51.531]                           }
[13:37:51.531]                         }
[13:37:51.531]                       }
[13:37:51.531]                       invisible(muffled)
[13:37:51.531]                     }
[13:37:51.531]                     muffleCondition(cond, pattern = "^muffle")
[13:37:51.531]                   }
[13:37:51.531]                 }
[13:37:51.531]                 else {
[13:37:51.531]                   if (TRUE) {
[13:37:51.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:51.531]                     {
[13:37:51.531]                       inherits <- base::inherits
[13:37:51.531]                       invokeRestart <- base::invokeRestart
[13:37:51.531]                       is.null <- base::is.null
[13:37:51.531]                       muffled <- FALSE
[13:37:51.531]                       if (inherits(cond, "message")) {
[13:37:51.531]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:51.531]                         if (muffled) 
[13:37:51.531]                           invokeRestart("muffleMessage")
[13:37:51.531]                       }
[13:37:51.531]                       else if (inherits(cond, "warning")) {
[13:37:51.531]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:51.531]                         if (muffled) 
[13:37:51.531]                           invokeRestart("muffleWarning")
[13:37:51.531]                       }
[13:37:51.531]                       else if (inherits(cond, "condition")) {
[13:37:51.531]                         if (!is.null(pattern)) {
[13:37:51.531]                           computeRestarts <- base::computeRestarts
[13:37:51.531]                           grepl <- base::grepl
[13:37:51.531]                           restarts <- computeRestarts(cond)
[13:37:51.531]                           for (restart in restarts) {
[13:37:51.531]                             name <- restart$name
[13:37:51.531]                             if (is.null(name)) 
[13:37:51.531]                               next
[13:37:51.531]                             if (!grepl(pattern, name)) 
[13:37:51.531]                               next
[13:37:51.531]                             invokeRestart(restart)
[13:37:51.531]                             muffled <- TRUE
[13:37:51.531]                             break
[13:37:51.531]                           }
[13:37:51.531]                         }
[13:37:51.531]                       }
[13:37:51.531]                       invisible(muffled)
[13:37:51.531]                     }
[13:37:51.531]                     muffleCondition(cond, pattern = "^muffle")
[13:37:51.531]                   }
[13:37:51.531]                 }
[13:37:51.531]             }
[13:37:51.531]         }))
[13:37:51.531]     }, error = function(ex) {
[13:37:51.531]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:51.531]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:51.531]                 ...future.rng), started = ...future.startTime, 
[13:37:51.531]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:51.531]             version = "1.8"), class = "FutureResult")
[13:37:51.531]     }, finally = {
[13:37:51.531]         if (!identical(...future.workdir, getwd())) 
[13:37:51.531]             setwd(...future.workdir)
[13:37:51.531]         {
[13:37:51.531]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:51.531]                 ...future.oldOptions$nwarnings <- NULL
[13:37:51.531]             }
[13:37:51.531]             base::options(...future.oldOptions)
[13:37:51.531]             if (.Platform$OS.type == "windows") {
[13:37:51.531]                 old_names <- names(...future.oldEnvVars)
[13:37:51.531]                 envs <- base::Sys.getenv()
[13:37:51.531]                 names <- names(envs)
[13:37:51.531]                 common <- intersect(names, old_names)
[13:37:51.531]                 added <- setdiff(names, old_names)
[13:37:51.531]                 removed <- setdiff(old_names, names)
[13:37:51.531]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:51.531]                   envs[common]]
[13:37:51.531]                 NAMES <- toupper(changed)
[13:37:51.531]                 args <- list()
[13:37:51.531]                 for (kk in seq_along(NAMES)) {
[13:37:51.531]                   name <- changed[[kk]]
[13:37:51.531]                   NAME <- NAMES[[kk]]
[13:37:51.531]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:51.531]                     next
[13:37:51.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:51.531]                 }
[13:37:51.531]                 NAMES <- toupper(added)
[13:37:51.531]                 for (kk in seq_along(NAMES)) {
[13:37:51.531]                   name <- added[[kk]]
[13:37:51.531]                   NAME <- NAMES[[kk]]
[13:37:51.531]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:51.531]                     next
[13:37:51.531]                   args[[name]] <- ""
[13:37:51.531]                 }
[13:37:51.531]                 NAMES <- toupper(removed)
[13:37:51.531]                 for (kk in seq_along(NAMES)) {
[13:37:51.531]                   name <- removed[[kk]]
[13:37:51.531]                   NAME <- NAMES[[kk]]
[13:37:51.531]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:51.531]                     next
[13:37:51.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:51.531]                 }
[13:37:51.531]                 if (length(args) > 0) 
[13:37:51.531]                   base::do.call(base::Sys.setenv, args = args)
[13:37:51.531]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:51.531]             }
[13:37:51.531]             else {
[13:37:51.531]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:51.531]             }
[13:37:51.531]             {
[13:37:51.531]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:51.531]                   0L) {
[13:37:51.531]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:51.531]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:51.531]                   base::options(opts)
[13:37:51.531]                 }
[13:37:51.531]                 {
[13:37:51.531]                   {
[13:37:51.531]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:51.531]                     NULL
[13:37:51.531]                   }
[13:37:51.531]                   options(future.plan = NULL)
[13:37:51.531]                   if (is.na(NA_character_)) 
[13:37:51.531]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:51.531]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:51.531]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:51.531]                     .init = FALSE)
[13:37:51.531]                 }
[13:37:51.531]             }
[13:37:51.531]         }
[13:37:51.531]     })
[13:37:51.531]     if (TRUE) {
[13:37:51.531]         base::sink(type = "output", split = FALSE)
[13:37:51.531]         if (TRUE) {
[13:37:51.531]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:51.531]         }
[13:37:51.531]         else {
[13:37:51.531]             ...future.result["stdout"] <- base::list(NULL)
[13:37:51.531]         }
[13:37:51.531]         base::close(...future.stdout)
[13:37:51.531]         ...future.stdout <- NULL
[13:37:51.531]     }
[13:37:51.531]     ...future.result$conditions <- ...future.conditions
[13:37:51.531]     ...future.result$finished <- base::Sys.time()
[13:37:51.531]     ...future.result
[13:37:51.531] }
[13:37:51.534] MultisessionFuture started
[13:37:51.534] - Launch lazy future ... done
[13:37:51.535] run() for ‘MultisessionFuture’ ... done
[13:37:51.536] receiveMessageFromWorker() for ClusterFuture ...
[13:37:51.536] - Validating connection of MultisessionFuture
[13:37:51.537] - received message: FutureResult
[13:37:51.537] - Received FutureResult
[13:37:51.537] - Erased future from FutureRegistry
[13:37:51.537] result() for ClusterFuture ...
[13:37:51.537] - result already collected: FutureResult
[13:37:51.537] result() for ClusterFuture ... done
[13:37:51.537] signalConditions() ...
[13:37:51.537]  - include = ‘immediateCondition’
[13:37:51.537]  - exclude = 
[13:37:51.537]  - resignal = FALSE
[13:37:51.537]  - Number of conditions: 1
[13:37:51.538] signalConditions() ... done
[13:37:51.538] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:51.538] A MultisessionFuture was resolved (result was not collected)
[13:37:51.538] getGlobalsAndPackages() ...
[13:37:51.538] Searching for globals...
[13:37:51.539] - globals found: [2] ‘list’, ‘stop’
[13:37:51.539] Searching for globals ... DONE
[13:37:51.539] Resolving globals: FALSE
[13:37:51.539] 
[13:37:51.539] 
[13:37:51.539] getGlobalsAndPackages() ... DONE
[13:37:51.539] run() for ‘Future’ ...
[13:37:51.540] - state: ‘created’
[13:37:51.540] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:51.553] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:51.553] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:51.553]   - Field: ‘node’
[13:37:51.553]   - Field: ‘label’
[13:37:51.554]   - Field: ‘local’
[13:37:51.554]   - Field: ‘owner’
[13:37:51.554]   - Field: ‘envir’
[13:37:51.554]   - Field: ‘workers’
[13:37:51.554]   - Field: ‘packages’
[13:37:51.554]   - Field: ‘gc’
[13:37:51.554]   - Field: ‘conditions’
[13:37:51.554]   - Field: ‘persistent’
[13:37:51.554]   - Field: ‘expr’
[13:37:51.554]   - Field: ‘uuid’
[13:37:51.555]   - Field: ‘seed’
[13:37:51.555]   - Field: ‘version’
[13:37:51.555]   - Field: ‘result’
[13:37:51.555]   - Field: ‘asynchronous’
[13:37:51.555]   - Field: ‘calls’
[13:37:51.555]   - Field: ‘globals’
[13:37:51.555]   - Field: ‘stdout’
[13:37:51.555]   - Field: ‘earlySignal’
[13:37:51.555]   - Field: ‘lazy’
[13:37:51.555]   - Field: ‘state’
[13:37:51.555] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:51.556] - Launch lazy future ...
[13:37:51.556] Packages needed by the future expression (n = 0): <none>
[13:37:51.556] Packages needed by future strategies (n = 0): <none>
[13:37:51.556] {
[13:37:51.556]     {
[13:37:51.556]         {
[13:37:51.556]             ...future.startTime <- base::Sys.time()
[13:37:51.556]             {
[13:37:51.556]                 {
[13:37:51.556]                   {
[13:37:51.556]                     {
[13:37:51.556]                       base::local({
[13:37:51.556]                         has_future <- base::requireNamespace("future", 
[13:37:51.556]                           quietly = TRUE)
[13:37:51.556]                         if (has_future) {
[13:37:51.556]                           ns <- base::getNamespace("future")
[13:37:51.556]                           version <- ns[[".package"]][["version"]]
[13:37:51.556]                           if (is.null(version)) 
[13:37:51.556]                             version <- utils::packageVersion("future")
[13:37:51.556]                         }
[13:37:51.556]                         else {
[13:37:51.556]                           version <- NULL
[13:37:51.556]                         }
[13:37:51.556]                         if (!has_future || version < "1.8.0") {
[13:37:51.556]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:51.556]                             "", base::R.version$version.string), 
[13:37:51.556]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:51.556]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:51.556]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:51.556]                               "release", "version")], collapse = " "), 
[13:37:51.556]                             hostname = base::Sys.info()[["nodename"]])
[13:37:51.556]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:51.556]                             info)
[13:37:51.556]                           info <- base::paste(info, collapse = "; ")
[13:37:51.556]                           if (!has_future) {
[13:37:51.556]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:51.556]                               info)
[13:37:51.556]                           }
[13:37:51.556]                           else {
[13:37:51.556]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:51.556]                               info, version)
[13:37:51.556]                           }
[13:37:51.556]                           base::stop(msg)
[13:37:51.556]                         }
[13:37:51.556]                       })
[13:37:51.556]                     }
[13:37:51.556]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:51.556]                     base::options(mc.cores = 1L)
[13:37:51.556]                   }
[13:37:51.556]                   ...future.strategy.old <- future::plan("list")
[13:37:51.556]                   options(future.plan = NULL)
[13:37:51.556]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:51.556]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:51.556]                 }
[13:37:51.556]                 ...future.workdir <- getwd()
[13:37:51.556]             }
[13:37:51.556]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:51.556]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:51.556]         }
[13:37:51.556]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:51.556]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:51.556]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:51.556]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:51.556]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:51.556]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:51.556]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:51.556]             base::names(...future.oldOptions))
[13:37:51.556]     }
[13:37:51.556]     if (FALSE) {
[13:37:51.556]     }
[13:37:51.556]     else {
[13:37:51.556]         if (TRUE) {
[13:37:51.556]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:51.556]                 open = "w")
[13:37:51.556]         }
[13:37:51.556]         else {
[13:37:51.556]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:51.556]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:51.556]         }
[13:37:51.556]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:51.556]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:51.556]             base::sink(type = "output", split = FALSE)
[13:37:51.556]             base::close(...future.stdout)
[13:37:51.556]         }, add = TRUE)
[13:37:51.556]     }
[13:37:51.556]     ...future.frame <- base::sys.nframe()
[13:37:51.556]     ...future.conditions <- base::list()
[13:37:51.556]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:51.556]     if (FALSE) {
[13:37:51.556]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:51.556]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:51.556]     }
[13:37:51.556]     ...future.result <- base::tryCatch({
[13:37:51.556]         base::withCallingHandlers({
[13:37:51.556]             ...future.value <- base::withVisible(base::local({
[13:37:51.556]                 ...future.makeSendCondition <- base::local({
[13:37:51.556]                   sendCondition <- NULL
[13:37:51.556]                   function(frame = 1L) {
[13:37:51.556]                     if (is.function(sendCondition)) 
[13:37:51.556]                       return(sendCondition)
[13:37:51.556]                     ns <- getNamespace("parallel")
[13:37:51.556]                     if (exists("sendData", mode = "function", 
[13:37:51.556]                       envir = ns)) {
[13:37:51.556]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:51.556]                         envir = ns)
[13:37:51.556]                       envir <- sys.frame(frame)
[13:37:51.556]                       master <- NULL
[13:37:51.556]                       while (!identical(envir, .GlobalEnv) && 
[13:37:51.556]                         !identical(envir, emptyenv())) {
[13:37:51.556]                         if (exists("master", mode = "list", envir = envir, 
[13:37:51.556]                           inherits = FALSE)) {
[13:37:51.556]                           master <- get("master", mode = "list", 
[13:37:51.556]                             envir = envir, inherits = FALSE)
[13:37:51.556]                           if (inherits(master, c("SOCKnode", 
[13:37:51.556]                             "SOCK0node"))) {
[13:37:51.556]                             sendCondition <<- function(cond) {
[13:37:51.556]                               data <- list(type = "VALUE", value = cond, 
[13:37:51.556]                                 success = TRUE)
[13:37:51.556]                               parallel_sendData(master, data)
[13:37:51.556]                             }
[13:37:51.556]                             return(sendCondition)
[13:37:51.556]                           }
[13:37:51.556]                         }
[13:37:51.556]                         frame <- frame + 1L
[13:37:51.556]                         envir <- sys.frame(frame)
[13:37:51.556]                       }
[13:37:51.556]                     }
[13:37:51.556]                     sendCondition <<- function(cond) NULL
[13:37:51.556]                   }
[13:37:51.556]                 })
[13:37:51.556]                 withCallingHandlers({
[13:37:51.556]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:37:51.556]                 }, immediateCondition = function(cond) {
[13:37:51.556]                   sendCondition <- ...future.makeSendCondition()
[13:37:51.556]                   sendCondition(cond)
[13:37:51.556]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:51.556]                   {
[13:37:51.556]                     inherits <- base::inherits
[13:37:51.556]                     invokeRestart <- base::invokeRestart
[13:37:51.556]                     is.null <- base::is.null
[13:37:51.556]                     muffled <- FALSE
[13:37:51.556]                     if (inherits(cond, "message")) {
[13:37:51.556]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:51.556]                       if (muffled) 
[13:37:51.556]                         invokeRestart("muffleMessage")
[13:37:51.556]                     }
[13:37:51.556]                     else if (inherits(cond, "warning")) {
[13:37:51.556]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:51.556]                       if (muffled) 
[13:37:51.556]                         invokeRestart("muffleWarning")
[13:37:51.556]                     }
[13:37:51.556]                     else if (inherits(cond, "condition")) {
[13:37:51.556]                       if (!is.null(pattern)) {
[13:37:51.556]                         computeRestarts <- base::computeRestarts
[13:37:51.556]                         grepl <- base::grepl
[13:37:51.556]                         restarts <- computeRestarts(cond)
[13:37:51.556]                         for (restart in restarts) {
[13:37:51.556]                           name <- restart$name
[13:37:51.556]                           if (is.null(name)) 
[13:37:51.556]                             next
[13:37:51.556]                           if (!grepl(pattern, name)) 
[13:37:51.556]                             next
[13:37:51.556]                           invokeRestart(restart)
[13:37:51.556]                           muffled <- TRUE
[13:37:51.556]                           break
[13:37:51.556]                         }
[13:37:51.556]                       }
[13:37:51.556]                     }
[13:37:51.556]                     invisible(muffled)
[13:37:51.556]                   }
[13:37:51.556]                   muffleCondition(cond)
[13:37:51.556]                 })
[13:37:51.556]             }))
[13:37:51.556]             future::FutureResult(value = ...future.value$value, 
[13:37:51.556]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:51.556]                   ...future.rng), globalenv = if (FALSE) 
[13:37:51.556]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:51.556]                     ...future.globalenv.names))
[13:37:51.556]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:51.556]         }, condition = base::local({
[13:37:51.556]             c <- base::c
[13:37:51.556]             inherits <- base::inherits
[13:37:51.556]             invokeRestart <- base::invokeRestart
[13:37:51.556]             length <- base::length
[13:37:51.556]             list <- base::list
[13:37:51.556]             seq.int <- base::seq.int
[13:37:51.556]             signalCondition <- base::signalCondition
[13:37:51.556]             sys.calls <- base::sys.calls
[13:37:51.556]             `[[` <- base::`[[`
[13:37:51.556]             `+` <- base::`+`
[13:37:51.556]             `<<-` <- base::`<<-`
[13:37:51.556]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:51.556]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:51.556]                   3L)]
[13:37:51.556]             }
[13:37:51.556]             function(cond) {
[13:37:51.556]                 is_error <- inherits(cond, "error")
[13:37:51.556]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:51.556]                   NULL)
[13:37:51.556]                 if (is_error) {
[13:37:51.556]                   sessionInformation <- function() {
[13:37:51.556]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:51.556]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:51.556]                       search = base::search(), system = base::Sys.info())
[13:37:51.556]                   }
[13:37:51.556]                   ...future.conditions[[length(...future.conditions) + 
[13:37:51.556]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:51.556]                     cond$call), session = sessionInformation(), 
[13:37:51.556]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:51.556]                   signalCondition(cond)
[13:37:51.556]                 }
[13:37:51.556]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:51.556]                 "immediateCondition"))) {
[13:37:51.556]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:51.556]                   ...future.conditions[[length(...future.conditions) + 
[13:37:51.556]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:51.556]                   if (TRUE && !signal) {
[13:37:51.556]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:51.556]                     {
[13:37:51.556]                       inherits <- base::inherits
[13:37:51.556]                       invokeRestart <- base::invokeRestart
[13:37:51.556]                       is.null <- base::is.null
[13:37:51.556]                       muffled <- FALSE
[13:37:51.556]                       if (inherits(cond, "message")) {
[13:37:51.556]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:51.556]                         if (muffled) 
[13:37:51.556]                           invokeRestart("muffleMessage")
[13:37:51.556]                       }
[13:37:51.556]                       else if (inherits(cond, "warning")) {
[13:37:51.556]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:51.556]                         if (muffled) 
[13:37:51.556]                           invokeRestart("muffleWarning")
[13:37:51.556]                       }
[13:37:51.556]                       else if (inherits(cond, "condition")) {
[13:37:51.556]                         if (!is.null(pattern)) {
[13:37:51.556]                           computeRestarts <- base::computeRestarts
[13:37:51.556]                           grepl <- base::grepl
[13:37:51.556]                           restarts <- computeRestarts(cond)
[13:37:51.556]                           for (restart in restarts) {
[13:37:51.556]                             name <- restart$name
[13:37:51.556]                             if (is.null(name)) 
[13:37:51.556]                               next
[13:37:51.556]                             if (!grepl(pattern, name)) 
[13:37:51.556]                               next
[13:37:51.556]                             invokeRestart(restart)
[13:37:51.556]                             muffled <- TRUE
[13:37:51.556]                             break
[13:37:51.556]                           }
[13:37:51.556]                         }
[13:37:51.556]                       }
[13:37:51.556]                       invisible(muffled)
[13:37:51.556]                     }
[13:37:51.556]                     muffleCondition(cond, pattern = "^muffle")
[13:37:51.556]                   }
[13:37:51.556]                 }
[13:37:51.556]                 else {
[13:37:51.556]                   if (TRUE) {
[13:37:51.556]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:51.556]                     {
[13:37:51.556]                       inherits <- base::inherits
[13:37:51.556]                       invokeRestart <- base::invokeRestart
[13:37:51.556]                       is.null <- base::is.null
[13:37:51.556]                       muffled <- FALSE
[13:37:51.556]                       if (inherits(cond, "message")) {
[13:37:51.556]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:51.556]                         if (muffled) 
[13:37:51.556]                           invokeRestart("muffleMessage")
[13:37:51.556]                       }
[13:37:51.556]                       else if (inherits(cond, "warning")) {
[13:37:51.556]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:51.556]                         if (muffled) 
[13:37:51.556]                           invokeRestart("muffleWarning")
[13:37:51.556]                       }
[13:37:51.556]                       else if (inherits(cond, "condition")) {
[13:37:51.556]                         if (!is.null(pattern)) {
[13:37:51.556]                           computeRestarts <- base::computeRestarts
[13:37:51.556]                           grepl <- base::grepl
[13:37:51.556]                           restarts <- computeRestarts(cond)
[13:37:51.556]                           for (restart in restarts) {
[13:37:51.556]                             name <- restart$name
[13:37:51.556]                             if (is.null(name)) 
[13:37:51.556]                               next
[13:37:51.556]                             if (!grepl(pattern, name)) 
[13:37:51.556]                               next
[13:37:51.556]                             invokeRestart(restart)
[13:37:51.556]                             muffled <- TRUE
[13:37:51.556]                             break
[13:37:51.556]                           }
[13:37:51.556]                         }
[13:37:51.556]                       }
[13:37:51.556]                       invisible(muffled)
[13:37:51.556]                     }
[13:37:51.556]                     muffleCondition(cond, pattern = "^muffle")
[13:37:51.556]                   }
[13:37:51.556]                 }
[13:37:51.556]             }
[13:37:51.556]         }))
[13:37:51.556]     }, error = function(ex) {
[13:37:51.556]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:51.556]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:51.556]                 ...future.rng), started = ...future.startTime, 
[13:37:51.556]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:51.556]             version = "1.8"), class = "FutureResult")
[13:37:51.556]     }, finally = {
[13:37:51.556]         if (!identical(...future.workdir, getwd())) 
[13:37:51.556]             setwd(...future.workdir)
[13:37:51.556]         {
[13:37:51.556]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:51.556]                 ...future.oldOptions$nwarnings <- NULL
[13:37:51.556]             }
[13:37:51.556]             base::options(...future.oldOptions)
[13:37:51.556]             if (.Platform$OS.type == "windows") {
[13:37:51.556]                 old_names <- names(...future.oldEnvVars)
[13:37:51.556]                 envs <- base::Sys.getenv()
[13:37:51.556]                 names <- names(envs)
[13:37:51.556]                 common <- intersect(names, old_names)
[13:37:51.556]                 added <- setdiff(names, old_names)
[13:37:51.556]                 removed <- setdiff(old_names, names)
[13:37:51.556]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:51.556]                   envs[common]]
[13:37:51.556]                 NAMES <- toupper(changed)
[13:37:51.556]                 args <- list()
[13:37:51.556]                 for (kk in seq_along(NAMES)) {
[13:37:51.556]                   name <- changed[[kk]]
[13:37:51.556]                   NAME <- NAMES[[kk]]
[13:37:51.556]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:51.556]                     next
[13:37:51.556]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:51.556]                 }
[13:37:51.556]                 NAMES <- toupper(added)
[13:37:51.556]                 for (kk in seq_along(NAMES)) {
[13:37:51.556]                   name <- added[[kk]]
[13:37:51.556]                   NAME <- NAMES[[kk]]
[13:37:51.556]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:51.556]                     next
[13:37:51.556]                   args[[name]] <- ""
[13:37:51.556]                 }
[13:37:51.556]                 NAMES <- toupper(removed)
[13:37:51.556]                 for (kk in seq_along(NAMES)) {
[13:37:51.556]                   name <- removed[[kk]]
[13:37:51.556]                   NAME <- NAMES[[kk]]
[13:37:51.556]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:51.556]                     next
[13:37:51.556]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:51.556]                 }
[13:37:51.556]                 if (length(args) > 0) 
[13:37:51.556]                   base::do.call(base::Sys.setenv, args = args)
[13:37:51.556]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:51.556]             }
[13:37:51.556]             else {
[13:37:51.556]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:51.556]             }
[13:37:51.556]             {
[13:37:51.556]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:51.556]                   0L) {
[13:37:51.556]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:51.556]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:51.556]                   base::options(opts)
[13:37:51.556]                 }
[13:37:51.556]                 {
[13:37:51.556]                   {
[13:37:51.556]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:51.556]                     NULL
[13:37:51.556]                   }
[13:37:51.556]                   options(future.plan = NULL)
[13:37:51.556]                   if (is.na(NA_character_)) 
[13:37:51.556]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:51.556]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:51.556]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:51.556]                     .init = FALSE)
[13:37:51.556]                 }
[13:37:51.556]             }
[13:37:51.556]         }
[13:37:51.556]     })
[13:37:51.556]     if (TRUE) {
[13:37:51.556]         base::sink(type = "output", split = FALSE)
[13:37:51.556]         if (TRUE) {
[13:37:51.556]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:51.556]         }
[13:37:51.556]         else {
[13:37:51.556]             ...future.result["stdout"] <- base::list(NULL)
[13:37:51.556]         }
[13:37:51.556]         base::close(...future.stdout)
[13:37:51.556]         ...future.stdout <- NULL
[13:37:51.556]     }
[13:37:51.556]     ...future.result$conditions <- ...future.conditions
[13:37:51.556]     ...future.result$finished <- base::Sys.time()
[13:37:51.556]     ...future.result
[13:37:51.556] }
[13:37:51.559] MultisessionFuture started
[13:37:51.559] - Launch lazy future ... done
[13:37:51.559] run() for ‘MultisessionFuture’ ... done
[13:37:51.561] receiveMessageFromWorker() for ClusterFuture ...
[13:37:51.561] - Validating connection of MultisessionFuture
[13:37:51.561] - received message: FutureResult
[13:37:51.561] - Received FutureResult
[13:37:51.561] - Erased future from FutureRegistry
[13:37:51.562] result() for ClusterFuture ...
[13:37:51.562] - result already collected: FutureResult
[13:37:51.562] result() for ClusterFuture ... done
[13:37:51.562] signalConditions() ...
[13:37:51.562]  - include = ‘immediateCondition’
[13:37:51.562]  - exclude = 
[13:37:51.565]  - resignal = FALSE
[13:37:51.565]  - Number of conditions: 1
[13:37:51.565] signalConditions() ... done
[13:37:51.565] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:51.565] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 1 ... DONE
- result = FALSE, recursive = 2 ...
[13:37:51.565] getGlobalsAndPackages() ...
[13:37:51.565] Searching for globals...
[13:37:51.566] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:37:51.567] Searching for globals ... DONE
[13:37:51.567] Resolving globals: FALSE
[13:37:51.567] 
[13:37:51.567] 
[13:37:51.567] getGlobalsAndPackages() ... DONE
[13:37:51.567] run() for ‘Future’ ...
[13:37:51.567] - state: ‘created’
[13:37:51.568] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:51.581] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:51.581] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:51.581]   - Field: ‘node’
[13:37:51.581]   - Field: ‘label’
[13:37:51.581]   - Field: ‘local’
[13:37:51.582]   - Field: ‘owner’
[13:37:51.582]   - Field: ‘envir’
[13:37:51.582]   - Field: ‘workers’
[13:37:51.582]   - Field: ‘packages’
[13:37:51.582]   - Field: ‘gc’
[13:37:51.582]   - Field: ‘conditions’
[13:37:51.582]   - Field: ‘persistent’
[13:37:51.582]   - Field: ‘expr’
[13:37:51.582]   - Field: ‘uuid’
[13:37:51.582]   - Field: ‘seed’
[13:37:51.582]   - Field: ‘version’
[13:37:51.583]   - Field: ‘result’
[13:37:51.583]   - Field: ‘asynchronous’
[13:37:51.583]   - Field: ‘calls’
[13:37:51.583]   - Field: ‘globals’
[13:37:51.583]   - Field: ‘stdout’
[13:37:51.583]   - Field: ‘earlySignal’
[13:37:51.583]   - Field: ‘lazy’
[13:37:51.583]   - Field: ‘state’
[13:37:51.583] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:51.583] - Launch lazy future ...
[13:37:51.584] Packages needed by the future expression (n = 0): <none>
[13:37:51.584] Packages needed by future strategies (n = 0): <none>
[13:37:51.584] {
[13:37:51.584]     {
[13:37:51.584]         {
[13:37:51.584]             ...future.startTime <- base::Sys.time()
[13:37:51.584]             {
[13:37:51.584]                 {
[13:37:51.584]                   {
[13:37:51.584]                     {
[13:37:51.584]                       base::local({
[13:37:51.584]                         has_future <- base::requireNamespace("future", 
[13:37:51.584]                           quietly = TRUE)
[13:37:51.584]                         if (has_future) {
[13:37:51.584]                           ns <- base::getNamespace("future")
[13:37:51.584]                           version <- ns[[".package"]][["version"]]
[13:37:51.584]                           if (is.null(version)) 
[13:37:51.584]                             version <- utils::packageVersion("future")
[13:37:51.584]                         }
[13:37:51.584]                         else {
[13:37:51.584]                           version <- NULL
[13:37:51.584]                         }
[13:37:51.584]                         if (!has_future || version < "1.8.0") {
[13:37:51.584]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:51.584]                             "", base::R.version$version.string), 
[13:37:51.584]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:51.584]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:51.584]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:51.584]                               "release", "version")], collapse = " "), 
[13:37:51.584]                             hostname = base::Sys.info()[["nodename"]])
[13:37:51.584]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:51.584]                             info)
[13:37:51.584]                           info <- base::paste(info, collapse = "; ")
[13:37:51.584]                           if (!has_future) {
[13:37:51.584]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:51.584]                               info)
[13:37:51.584]                           }
[13:37:51.584]                           else {
[13:37:51.584]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:51.584]                               info, version)
[13:37:51.584]                           }
[13:37:51.584]                           base::stop(msg)
[13:37:51.584]                         }
[13:37:51.584]                       })
[13:37:51.584]                     }
[13:37:51.584]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:51.584]                     base::options(mc.cores = 1L)
[13:37:51.584]                   }
[13:37:51.584]                   ...future.strategy.old <- future::plan("list")
[13:37:51.584]                   options(future.plan = NULL)
[13:37:51.584]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:51.584]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:51.584]                 }
[13:37:51.584]                 ...future.workdir <- getwd()
[13:37:51.584]             }
[13:37:51.584]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:51.584]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:51.584]         }
[13:37:51.584]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:51.584]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:51.584]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:51.584]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:51.584]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:51.584]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:51.584]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:51.584]             base::names(...future.oldOptions))
[13:37:51.584]     }
[13:37:51.584]     if (FALSE) {
[13:37:51.584]     }
[13:37:51.584]     else {
[13:37:51.584]         if (TRUE) {
[13:37:51.584]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:51.584]                 open = "w")
[13:37:51.584]         }
[13:37:51.584]         else {
[13:37:51.584]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:51.584]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:51.584]         }
[13:37:51.584]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:51.584]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:51.584]             base::sink(type = "output", split = FALSE)
[13:37:51.584]             base::close(...future.stdout)
[13:37:51.584]         }, add = TRUE)
[13:37:51.584]     }
[13:37:51.584]     ...future.frame <- base::sys.nframe()
[13:37:51.584]     ...future.conditions <- base::list()
[13:37:51.584]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:51.584]     if (FALSE) {
[13:37:51.584]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:51.584]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:51.584]     }
[13:37:51.584]     ...future.result <- base::tryCatch({
[13:37:51.584]         base::withCallingHandlers({
[13:37:51.584]             ...future.value <- base::withVisible(base::local({
[13:37:51.584]                 ...future.makeSendCondition <- base::local({
[13:37:51.584]                   sendCondition <- NULL
[13:37:51.584]                   function(frame = 1L) {
[13:37:51.584]                     if (is.function(sendCondition)) 
[13:37:51.584]                       return(sendCondition)
[13:37:51.584]                     ns <- getNamespace("parallel")
[13:37:51.584]                     if (exists("sendData", mode = "function", 
[13:37:51.584]                       envir = ns)) {
[13:37:51.584]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:51.584]                         envir = ns)
[13:37:51.584]                       envir <- sys.frame(frame)
[13:37:51.584]                       master <- NULL
[13:37:51.584]                       while (!identical(envir, .GlobalEnv) && 
[13:37:51.584]                         !identical(envir, emptyenv())) {
[13:37:51.584]                         if (exists("master", mode = "list", envir = envir, 
[13:37:51.584]                           inherits = FALSE)) {
[13:37:51.584]                           master <- get("master", mode = "list", 
[13:37:51.584]                             envir = envir, inherits = FALSE)
[13:37:51.584]                           if (inherits(master, c("SOCKnode", 
[13:37:51.584]                             "SOCK0node"))) {
[13:37:51.584]                             sendCondition <<- function(cond) {
[13:37:51.584]                               data <- list(type = "VALUE", value = cond, 
[13:37:51.584]                                 success = TRUE)
[13:37:51.584]                               parallel_sendData(master, data)
[13:37:51.584]                             }
[13:37:51.584]                             return(sendCondition)
[13:37:51.584]                           }
[13:37:51.584]                         }
[13:37:51.584]                         frame <- frame + 1L
[13:37:51.584]                         envir <- sys.frame(frame)
[13:37:51.584]                       }
[13:37:51.584]                     }
[13:37:51.584]                     sendCondition <<- function(cond) NULL
[13:37:51.584]                   }
[13:37:51.584]                 })
[13:37:51.584]                 withCallingHandlers({
[13:37:51.584]                   {
[13:37:51.584]                     Sys.sleep(0.5)
[13:37:51.584]                     list(a = 1, b = 42L)
[13:37:51.584]                   }
[13:37:51.584]                 }, immediateCondition = function(cond) {
[13:37:51.584]                   sendCondition <- ...future.makeSendCondition()
[13:37:51.584]                   sendCondition(cond)
[13:37:51.584]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:51.584]                   {
[13:37:51.584]                     inherits <- base::inherits
[13:37:51.584]                     invokeRestart <- base::invokeRestart
[13:37:51.584]                     is.null <- base::is.null
[13:37:51.584]                     muffled <- FALSE
[13:37:51.584]                     if (inherits(cond, "message")) {
[13:37:51.584]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:51.584]                       if (muffled) 
[13:37:51.584]                         invokeRestart("muffleMessage")
[13:37:51.584]                     }
[13:37:51.584]                     else if (inherits(cond, "warning")) {
[13:37:51.584]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:51.584]                       if (muffled) 
[13:37:51.584]                         invokeRestart("muffleWarning")
[13:37:51.584]                     }
[13:37:51.584]                     else if (inherits(cond, "condition")) {
[13:37:51.584]                       if (!is.null(pattern)) {
[13:37:51.584]                         computeRestarts <- base::computeRestarts
[13:37:51.584]                         grepl <- base::grepl
[13:37:51.584]                         restarts <- computeRestarts(cond)
[13:37:51.584]                         for (restart in restarts) {
[13:37:51.584]                           name <- restart$name
[13:37:51.584]                           if (is.null(name)) 
[13:37:51.584]                             next
[13:37:51.584]                           if (!grepl(pattern, name)) 
[13:37:51.584]                             next
[13:37:51.584]                           invokeRestart(restart)
[13:37:51.584]                           muffled <- TRUE
[13:37:51.584]                           break
[13:37:51.584]                         }
[13:37:51.584]                       }
[13:37:51.584]                     }
[13:37:51.584]                     invisible(muffled)
[13:37:51.584]                   }
[13:37:51.584]                   muffleCondition(cond)
[13:37:51.584]                 })
[13:37:51.584]             }))
[13:37:51.584]             future::FutureResult(value = ...future.value$value, 
[13:37:51.584]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:51.584]                   ...future.rng), globalenv = if (FALSE) 
[13:37:51.584]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:51.584]                     ...future.globalenv.names))
[13:37:51.584]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:51.584]         }, condition = base::local({
[13:37:51.584]             c <- base::c
[13:37:51.584]             inherits <- base::inherits
[13:37:51.584]             invokeRestart <- base::invokeRestart
[13:37:51.584]             length <- base::length
[13:37:51.584]             list <- base::list
[13:37:51.584]             seq.int <- base::seq.int
[13:37:51.584]             signalCondition <- base::signalCondition
[13:37:51.584]             sys.calls <- base::sys.calls
[13:37:51.584]             `[[` <- base::`[[`
[13:37:51.584]             `+` <- base::`+`
[13:37:51.584]             `<<-` <- base::`<<-`
[13:37:51.584]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:51.584]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:51.584]                   3L)]
[13:37:51.584]             }
[13:37:51.584]             function(cond) {
[13:37:51.584]                 is_error <- inherits(cond, "error")
[13:37:51.584]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:51.584]                   NULL)
[13:37:51.584]                 if (is_error) {
[13:37:51.584]                   sessionInformation <- function() {
[13:37:51.584]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:51.584]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:51.584]                       search = base::search(), system = base::Sys.info())
[13:37:51.584]                   }
[13:37:51.584]                   ...future.conditions[[length(...future.conditions) + 
[13:37:51.584]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:51.584]                     cond$call), session = sessionInformation(), 
[13:37:51.584]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:51.584]                   signalCondition(cond)
[13:37:51.584]                 }
[13:37:51.584]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:51.584]                 "immediateCondition"))) {
[13:37:51.584]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:51.584]                   ...future.conditions[[length(...future.conditions) + 
[13:37:51.584]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:51.584]                   if (TRUE && !signal) {
[13:37:51.584]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:51.584]                     {
[13:37:51.584]                       inherits <- base::inherits
[13:37:51.584]                       invokeRestart <- base::invokeRestart
[13:37:51.584]                       is.null <- base::is.null
[13:37:51.584]                       muffled <- FALSE
[13:37:51.584]                       if (inherits(cond, "message")) {
[13:37:51.584]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:51.584]                         if (muffled) 
[13:37:51.584]                           invokeRestart("muffleMessage")
[13:37:51.584]                       }
[13:37:51.584]                       else if (inherits(cond, "warning")) {
[13:37:51.584]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:51.584]                         if (muffled) 
[13:37:51.584]                           invokeRestart("muffleWarning")
[13:37:51.584]                       }
[13:37:51.584]                       else if (inherits(cond, "condition")) {
[13:37:51.584]                         if (!is.null(pattern)) {
[13:37:51.584]                           computeRestarts <- base::computeRestarts
[13:37:51.584]                           grepl <- base::grepl
[13:37:51.584]                           restarts <- computeRestarts(cond)
[13:37:51.584]                           for (restart in restarts) {
[13:37:51.584]                             name <- restart$name
[13:37:51.584]                             if (is.null(name)) 
[13:37:51.584]                               next
[13:37:51.584]                             if (!grepl(pattern, name)) 
[13:37:51.584]                               next
[13:37:51.584]                             invokeRestart(restart)
[13:37:51.584]                             muffled <- TRUE
[13:37:51.584]                             break
[13:37:51.584]                           }
[13:37:51.584]                         }
[13:37:51.584]                       }
[13:37:51.584]                       invisible(muffled)
[13:37:51.584]                     }
[13:37:51.584]                     muffleCondition(cond, pattern = "^muffle")
[13:37:51.584]                   }
[13:37:51.584]                 }
[13:37:51.584]                 else {
[13:37:51.584]                   if (TRUE) {
[13:37:51.584]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:51.584]                     {
[13:37:51.584]                       inherits <- base::inherits
[13:37:51.584]                       invokeRestart <- base::invokeRestart
[13:37:51.584]                       is.null <- base::is.null
[13:37:51.584]                       muffled <- FALSE
[13:37:51.584]                       if (inherits(cond, "message")) {
[13:37:51.584]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:51.584]                         if (muffled) 
[13:37:51.584]                           invokeRestart("muffleMessage")
[13:37:51.584]                       }
[13:37:51.584]                       else if (inherits(cond, "warning")) {
[13:37:51.584]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:51.584]                         if (muffled) 
[13:37:51.584]                           invokeRestart("muffleWarning")
[13:37:51.584]                       }
[13:37:51.584]                       else if (inherits(cond, "condition")) {
[13:37:51.584]                         if (!is.null(pattern)) {
[13:37:51.584]                           computeRestarts <- base::computeRestarts
[13:37:51.584]                           grepl <- base::grepl
[13:37:51.584]                           restarts <- computeRestarts(cond)
[13:37:51.584]                           for (restart in restarts) {
[13:37:51.584]                             name <- restart$name
[13:37:51.584]                             if (is.null(name)) 
[13:37:51.584]                               next
[13:37:51.584]                             if (!grepl(pattern, name)) 
[13:37:51.584]                               next
[13:37:51.584]                             invokeRestart(restart)
[13:37:51.584]                             muffled <- TRUE
[13:37:51.584]                             break
[13:37:51.584]                           }
[13:37:51.584]                         }
[13:37:51.584]                       }
[13:37:51.584]                       invisible(muffled)
[13:37:51.584]                     }
[13:37:51.584]                     muffleCondition(cond, pattern = "^muffle")
[13:37:51.584]                   }
[13:37:51.584]                 }
[13:37:51.584]             }
[13:37:51.584]         }))
[13:37:51.584]     }, error = function(ex) {
[13:37:51.584]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:51.584]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:51.584]                 ...future.rng), started = ...future.startTime, 
[13:37:51.584]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:51.584]             version = "1.8"), class = "FutureResult")
[13:37:51.584]     }, finally = {
[13:37:51.584]         if (!identical(...future.workdir, getwd())) 
[13:37:51.584]             setwd(...future.workdir)
[13:37:51.584]         {
[13:37:51.584]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:51.584]                 ...future.oldOptions$nwarnings <- NULL
[13:37:51.584]             }
[13:37:51.584]             base::options(...future.oldOptions)
[13:37:51.584]             if (.Platform$OS.type == "windows") {
[13:37:51.584]                 old_names <- names(...future.oldEnvVars)
[13:37:51.584]                 envs <- base::Sys.getenv()
[13:37:51.584]                 names <- names(envs)
[13:37:51.584]                 common <- intersect(names, old_names)
[13:37:51.584]                 added <- setdiff(names, old_names)
[13:37:51.584]                 removed <- setdiff(old_names, names)
[13:37:51.584]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:51.584]                   envs[common]]
[13:37:51.584]                 NAMES <- toupper(changed)
[13:37:51.584]                 args <- list()
[13:37:51.584]                 for (kk in seq_along(NAMES)) {
[13:37:51.584]                   name <- changed[[kk]]
[13:37:51.584]                   NAME <- NAMES[[kk]]
[13:37:51.584]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:51.584]                     next
[13:37:51.584]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:51.584]                 }
[13:37:51.584]                 NAMES <- toupper(added)
[13:37:51.584]                 for (kk in seq_along(NAMES)) {
[13:37:51.584]                   name <- added[[kk]]
[13:37:51.584]                   NAME <- NAMES[[kk]]
[13:37:51.584]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:51.584]                     next
[13:37:51.584]                   args[[name]] <- ""
[13:37:51.584]                 }
[13:37:51.584]                 NAMES <- toupper(removed)
[13:37:51.584]                 for (kk in seq_along(NAMES)) {
[13:37:51.584]                   name <- removed[[kk]]
[13:37:51.584]                   NAME <- NAMES[[kk]]
[13:37:51.584]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:51.584]                     next
[13:37:51.584]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:51.584]                 }
[13:37:51.584]                 if (length(args) > 0) 
[13:37:51.584]                   base::do.call(base::Sys.setenv, args = args)
[13:37:51.584]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:51.584]             }
[13:37:51.584]             else {
[13:37:51.584]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:51.584]             }
[13:37:51.584]             {
[13:37:51.584]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:51.584]                   0L) {
[13:37:51.584]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:51.584]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:51.584]                   base::options(opts)
[13:37:51.584]                 }
[13:37:51.584]                 {
[13:37:51.584]                   {
[13:37:51.584]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:51.584]                     NULL
[13:37:51.584]                   }
[13:37:51.584]                   options(future.plan = NULL)
[13:37:51.584]                   if (is.na(NA_character_)) 
[13:37:51.584]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:51.584]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:51.584]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:51.584]                     .init = FALSE)
[13:37:51.584]                 }
[13:37:51.584]             }
[13:37:51.584]         }
[13:37:51.584]     })
[13:37:51.584]     if (TRUE) {
[13:37:51.584]         base::sink(type = "output", split = FALSE)
[13:37:51.584]         if (TRUE) {
[13:37:51.584]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:51.584]         }
[13:37:51.584]         else {
[13:37:51.584]             ...future.result["stdout"] <- base::list(NULL)
[13:37:51.584]         }
[13:37:51.584]         base::close(...future.stdout)
[13:37:51.584]         ...future.stdout <- NULL
[13:37:51.584]     }
[13:37:51.584]     ...future.result$conditions <- ...future.conditions
[13:37:51.584]     ...future.result$finished <- base::Sys.time()
[13:37:51.584]     ...future.result
[13:37:51.584] }
[13:37:51.587] MultisessionFuture started
[13:37:51.587] - Launch lazy future ... done
[13:37:51.587] run() for ‘MultisessionFuture’ ... done
[13:37:52.090] receiveMessageFromWorker() for ClusterFuture ...
[13:37:52.090] - Validating connection of MultisessionFuture
[13:37:52.090] - received message: FutureResult
[13:37:52.090] - Received FutureResult
[13:37:52.090] - Erased future from FutureRegistry
[13:37:52.090] result() for ClusterFuture ...
[13:37:52.090] - result already collected: FutureResult
[13:37:52.091] result() for ClusterFuture ... done
[13:37:52.091] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:52.091] A MultisessionFuture was resolved (result was not collected)
[13:37:52.091] getGlobalsAndPackages() ...
[13:37:52.091] Searching for globals...
[13:37:52.092] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:37:52.092] Searching for globals ... DONE
[13:37:52.092] Resolving globals: FALSE
[13:37:52.093] 
[13:37:52.093] 
[13:37:52.093] getGlobalsAndPackages() ... DONE
[13:37:52.093] run() for ‘Future’ ...
[13:37:52.093] - state: ‘created’
[13:37:52.093] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:52.109] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:52.109] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:52.109]   - Field: ‘node’
[13:37:52.109]   - Field: ‘label’
[13:37:52.109]   - Field: ‘local’
[13:37:52.109]   - Field: ‘owner’
[13:37:52.109]   - Field: ‘envir’
[13:37:52.109]   - Field: ‘workers’
[13:37:52.109]   - Field: ‘packages’
[13:37:52.110]   - Field: ‘gc’
[13:37:52.110]   - Field: ‘conditions’
[13:37:52.110]   - Field: ‘persistent’
[13:37:52.110]   - Field: ‘expr’
[13:37:52.110]   - Field: ‘uuid’
[13:37:52.110]   - Field: ‘seed’
[13:37:52.110]   - Field: ‘version’
[13:37:52.110]   - Field: ‘result’
[13:37:52.110]   - Field: ‘asynchronous’
[13:37:52.110]   - Field: ‘calls’
[13:37:52.111]   - Field: ‘globals’
[13:37:52.111]   - Field: ‘stdout’
[13:37:52.111]   - Field: ‘earlySignal’
[13:37:52.111]   - Field: ‘lazy’
[13:37:52.111]   - Field: ‘state’
[13:37:52.111] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:52.111] - Launch lazy future ...
[13:37:52.111] Packages needed by the future expression (n = 0): <none>
[13:37:52.112] Packages needed by future strategies (n = 0): <none>
[13:37:52.112] {
[13:37:52.112]     {
[13:37:52.112]         {
[13:37:52.112]             ...future.startTime <- base::Sys.time()
[13:37:52.112]             {
[13:37:52.112]                 {
[13:37:52.112]                   {
[13:37:52.112]                     {
[13:37:52.112]                       base::local({
[13:37:52.112]                         has_future <- base::requireNamespace("future", 
[13:37:52.112]                           quietly = TRUE)
[13:37:52.112]                         if (has_future) {
[13:37:52.112]                           ns <- base::getNamespace("future")
[13:37:52.112]                           version <- ns[[".package"]][["version"]]
[13:37:52.112]                           if (is.null(version)) 
[13:37:52.112]                             version <- utils::packageVersion("future")
[13:37:52.112]                         }
[13:37:52.112]                         else {
[13:37:52.112]                           version <- NULL
[13:37:52.112]                         }
[13:37:52.112]                         if (!has_future || version < "1.8.0") {
[13:37:52.112]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:52.112]                             "", base::R.version$version.string), 
[13:37:52.112]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:52.112]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:52.112]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:52.112]                               "release", "version")], collapse = " "), 
[13:37:52.112]                             hostname = base::Sys.info()[["nodename"]])
[13:37:52.112]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:52.112]                             info)
[13:37:52.112]                           info <- base::paste(info, collapse = "; ")
[13:37:52.112]                           if (!has_future) {
[13:37:52.112]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:52.112]                               info)
[13:37:52.112]                           }
[13:37:52.112]                           else {
[13:37:52.112]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:52.112]                               info, version)
[13:37:52.112]                           }
[13:37:52.112]                           base::stop(msg)
[13:37:52.112]                         }
[13:37:52.112]                       })
[13:37:52.112]                     }
[13:37:52.112]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:52.112]                     base::options(mc.cores = 1L)
[13:37:52.112]                   }
[13:37:52.112]                   ...future.strategy.old <- future::plan("list")
[13:37:52.112]                   options(future.plan = NULL)
[13:37:52.112]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:52.112]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:52.112]                 }
[13:37:52.112]                 ...future.workdir <- getwd()
[13:37:52.112]             }
[13:37:52.112]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:52.112]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:52.112]         }
[13:37:52.112]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:52.112]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:52.112]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:52.112]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:52.112]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:52.112]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:52.112]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:52.112]             base::names(...future.oldOptions))
[13:37:52.112]     }
[13:37:52.112]     if (FALSE) {
[13:37:52.112]     }
[13:37:52.112]     else {
[13:37:52.112]         if (TRUE) {
[13:37:52.112]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:52.112]                 open = "w")
[13:37:52.112]         }
[13:37:52.112]         else {
[13:37:52.112]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:52.112]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:52.112]         }
[13:37:52.112]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:52.112]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:52.112]             base::sink(type = "output", split = FALSE)
[13:37:52.112]             base::close(...future.stdout)
[13:37:52.112]         }, add = TRUE)
[13:37:52.112]     }
[13:37:52.112]     ...future.frame <- base::sys.nframe()
[13:37:52.112]     ...future.conditions <- base::list()
[13:37:52.112]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:52.112]     if (FALSE) {
[13:37:52.112]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:52.112]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:52.112]     }
[13:37:52.112]     ...future.result <- base::tryCatch({
[13:37:52.112]         base::withCallingHandlers({
[13:37:52.112]             ...future.value <- base::withVisible(base::local({
[13:37:52.112]                 ...future.makeSendCondition <- base::local({
[13:37:52.112]                   sendCondition <- NULL
[13:37:52.112]                   function(frame = 1L) {
[13:37:52.112]                     if (is.function(sendCondition)) 
[13:37:52.112]                       return(sendCondition)
[13:37:52.112]                     ns <- getNamespace("parallel")
[13:37:52.112]                     if (exists("sendData", mode = "function", 
[13:37:52.112]                       envir = ns)) {
[13:37:52.112]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:52.112]                         envir = ns)
[13:37:52.112]                       envir <- sys.frame(frame)
[13:37:52.112]                       master <- NULL
[13:37:52.112]                       while (!identical(envir, .GlobalEnv) && 
[13:37:52.112]                         !identical(envir, emptyenv())) {
[13:37:52.112]                         if (exists("master", mode = "list", envir = envir, 
[13:37:52.112]                           inherits = FALSE)) {
[13:37:52.112]                           master <- get("master", mode = "list", 
[13:37:52.112]                             envir = envir, inherits = FALSE)
[13:37:52.112]                           if (inherits(master, c("SOCKnode", 
[13:37:52.112]                             "SOCK0node"))) {
[13:37:52.112]                             sendCondition <<- function(cond) {
[13:37:52.112]                               data <- list(type = "VALUE", value = cond, 
[13:37:52.112]                                 success = TRUE)
[13:37:52.112]                               parallel_sendData(master, data)
[13:37:52.112]                             }
[13:37:52.112]                             return(sendCondition)
[13:37:52.112]                           }
[13:37:52.112]                         }
[13:37:52.112]                         frame <- frame + 1L
[13:37:52.112]                         envir <- sys.frame(frame)
[13:37:52.112]                       }
[13:37:52.112]                     }
[13:37:52.112]                     sendCondition <<- function(cond) NULL
[13:37:52.112]                   }
[13:37:52.112]                 })
[13:37:52.112]                 withCallingHandlers({
[13:37:52.112]                   {
[13:37:52.112]                     Sys.sleep(0.5)
[13:37:52.112]                     list(a = 1, b = 42L)
[13:37:52.112]                   }
[13:37:52.112]                 }, immediateCondition = function(cond) {
[13:37:52.112]                   sendCondition <- ...future.makeSendCondition()
[13:37:52.112]                   sendCondition(cond)
[13:37:52.112]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:52.112]                   {
[13:37:52.112]                     inherits <- base::inherits
[13:37:52.112]                     invokeRestart <- base::invokeRestart
[13:37:52.112]                     is.null <- base::is.null
[13:37:52.112]                     muffled <- FALSE
[13:37:52.112]                     if (inherits(cond, "message")) {
[13:37:52.112]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:52.112]                       if (muffled) 
[13:37:52.112]                         invokeRestart("muffleMessage")
[13:37:52.112]                     }
[13:37:52.112]                     else if (inherits(cond, "warning")) {
[13:37:52.112]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:52.112]                       if (muffled) 
[13:37:52.112]                         invokeRestart("muffleWarning")
[13:37:52.112]                     }
[13:37:52.112]                     else if (inherits(cond, "condition")) {
[13:37:52.112]                       if (!is.null(pattern)) {
[13:37:52.112]                         computeRestarts <- base::computeRestarts
[13:37:52.112]                         grepl <- base::grepl
[13:37:52.112]                         restarts <- computeRestarts(cond)
[13:37:52.112]                         for (restart in restarts) {
[13:37:52.112]                           name <- restart$name
[13:37:52.112]                           if (is.null(name)) 
[13:37:52.112]                             next
[13:37:52.112]                           if (!grepl(pattern, name)) 
[13:37:52.112]                             next
[13:37:52.112]                           invokeRestart(restart)
[13:37:52.112]                           muffled <- TRUE
[13:37:52.112]                           break
[13:37:52.112]                         }
[13:37:52.112]                       }
[13:37:52.112]                     }
[13:37:52.112]                     invisible(muffled)
[13:37:52.112]                   }
[13:37:52.112]                   muffleCondition(cond)
[13:37:52.112]                 })
[13:37:52.112]             }))
[13:37:52.112]             future::FutureResult(value = ...future.value$value, 
[13:37:52.112]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:52.112]                   ...future.rng), globalenv = if (FALSE) 
[13:37:52.112]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:52.112]                     ...future.globalenv.names))
[13:37:52.112]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:52.112]         }, condition = base::local({
[13:37:52.112]             c <- base::c
[13:37:52.112]             inherits <- base::inherits
[13:37:52.112]             invokeRestart <- base::invokeRestart
[13:37:52.112]             length <- base::length
[13:37:52.112]             list <- base::list
[13:37:52.112]             seq.int <- base::seq.int
[13:37:52.112]             signalCondition <- base::signalCondition
[13:37:52.112]             sys.calls <- base::sys.calls
[13:37:52.112]             `[[` <- base::`[[`
[13:37:52.112]             `+` <- base::`+`
[13:37:52.112]             `<<-` <- base::`<<-`
[13:37:52.112]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:52.112]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:52.112]                   3L)]
[13:37:52.112]             }
[13:37:52.112]             function(cond) {
[13:37:52.112]                 is_error <- inherits(cond, "error")
[13:37:52.112]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:52.112]                   NULL)
[13:37:52.112]                 if (is_error) {
[13:37:52.112]                   sessionInformation <- function() {
[13:37:52.112]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:52.112]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:52.112]                       search = base::search(), system = base::Sys.info())
[13:37:52.112]                   }
[13:37:52.112]                   ...future.conditions[[length(...future.conditions) + 
[13:37:52.112]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:52.112]                     cond$call), session = sessionInformation(), 
[13:37:52.112]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:52.112]                   signalCondition(cond)
[13:37:52.112]                 }
[13:37:52.112]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:52.112]                 "immediateCondition"))) {
[13:37:52.112]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:52.112]                   ...future.conditions[[length(...future.conditions) + 
[13:37:52.112]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:52.112]                   if (TRUE && !signal) {
[13:37:52.112]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:52.112]                     {
[13:37:52.112]                       inherits <- base::inherits
[13:37:52.112]                       invokeRestart <- base::invokeRestart
[13:37:52.112]                       is.null <- base::is.null
[13:37:52.112]                       muffled <- FALSE
[13:37:52.112]                       if (inherits(cond, "message")) {
[13:37:52.112]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:52.112]                         if (muffled) 
[13:37:52.112]                           invokeRestart("muffleMessage")
[13:37:52.112]                       }
[13:37:52.112]                       else if (inherits(cond, "warning")) {
[13:37:52.112]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:52.112]                         if (muffled) 
[13:37:52.112]                           invokeRestart("muffleWarning")
[13:37:52.112]                       }
[13:37:52.112]                       else if (inherits(cond, "condition")) {
[13:37:52.112]                         if (!is.null(pattern)) {
[13:37:52.112]                           computeRestarts <- base::computeRestarts
[13:37:52.112]                           grepl <- base::grepl
[13:37:52.112]                           restarts <- computeRestarts(cond)
[13:37:52.112]                           for (restart in restarts) {
[13:37:52.112]                             name <- restart$name
[13:37:52.112]                             if (is.null(name)) 
[13:37:52.112]                               next
[13:37:52.112]                             if (!grepl(pattern, name)) 
[13:37:52.112]                               next
[13:37:52.112]                             invokeRestart(restart)
[13:37:52.112]                             muffled <- TRUE
[13:37:52.112]                             break
[13:37:52.112]                           }
[13:37:52.112]                         }
[13:37:52.112]                       }
[13:37:52.112]                       invisible(muffled)
[13:37:52.112]                     }
[13:37:52.112]                     muffleCondition(cond, pattern = "^muffle")
[13:37:52.112]                   }
[13:37:52.112]                 }
[13:37:52.112]                 else {
[13:37:52.112]                   if (TRUE) {
[13:37:52.112]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:52.112]                     {
[13:37:52.112]                       inherits <- base::inherits
[13:37:52.112]                       invokeRestart <- base::invokeRestart
[13:37:52.112]                       is.null <- base::is.null
[13:37:52.112]                       muffled <- FALSE
[13:37:52.112]                       if (inherits(cond, "message")) {
[13:37:52.112]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:52.112]                         if (muffled) 
[13:37:52.112]                           invokeRestart("muffleMessage")
[13:37:52.112]                       }
[13:37:52.112]                       else if (inherits(cond, "warning")) {
[13:37:52.112]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:52.112]                         if (muffled) 
[13:37:52.112]                           invokeRestart("muffleWarning")
[13:37:52.112]                       }
[13:37:52.112]                       else if (inherits(cond, "condition")) {
[13:37:52.112]                         if (!is.null(pattern)) {
[13:37:52.112]                           computeRestarts <- base::computeRestarts
[13:37:52.112]                           grepl <- base::grepl
[13:37:52.112]                           restarts <- computeRestarts(cond)
[13:37:52.112]                           for (restart in restarts) {
[13:37:52.112]                             name <- restart$name
[13:37:52.112]                             if (is.null(name)) 
[13:37:52.112]                               next
[13:37:52.112]                             if (!grepl(pattern, name)) 
[13:37:52.112]                               next
[13:37:52.112]                             invokeRestart(restart)
[13:37:52.112]                             muffled <- TRUE
[13:37:52.112]                             break
[13:37:52.112]                           }
[13:37:52.112]                         }
[13:37:52.112]                       }
[13:37:52.112]                       invisible(muffled)
[13:37:52.112]                     }
[13:37:52.112]                     muffleCondition(cond, pattern = "^muffle")
[13:37:52.112]                   }
[13:37:52.112]                 }
[13:37:52.112]             }
[13:37:52.112]         }))
[13:37:52.112]     }, error = function(ex) {
[13:37:52.112]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:52.112]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:52.112]                 ...future.rng), started = ...future.startTime, 
[13:37:52.112]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:52.112]             version = "1.8"), class = "FutureResult")
[13:37:52.112]     }, finally = {
[13:37:52.112]         if (!identical(...future.workdir, getwd())) 
[13:37:52.112]             setwd(...future.workdir)
[13:37:52.112]         {
[13:37:52.112]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:52.112]                 ...future.oldOptions$nwarnings <- NULL
[13:37:52.112]             }
[13:37:52.112]             base::options(...future.oldOptions)
[13:37:52.112]             if (.Platform$OS.type == "windows") {
[13:37:52.112]                 old_names <- names(...future.oldEnvVars)
[13:37:52.112]                 envs <- base::Sys.getenv()
[13:37:52.112]                 names <- names(envs)
[13:37:52.112]                 common <- intersect(names, old_names)
[13:37:52.112]                 added <- setdiff(names, old_names)
[13:37:52.112]                 removed <- setdiff(old_names, names)
[13:37:52.112]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:52.112]                   envs[common]]
[13:37:52.112]                 NAMES <- toupper(changed)
[13:37:52.112]                 args <- list()
[13:37:52.112]                 for (kk in seq_along(NAMES)) {
[13:37:52.112]                   name <- changed[[kk]]
[13:37:52.112]                   NAME <- NAMES[[kk]]
[13:37:52.112]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:52.112]                     next
[13:37:52.112]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:52.112]                 }
[13:37:52.112]                 NAMES <- toupper(added)
[13:37:52.112]                 for (kk in seq_along(NAMES)) {
[13:37:52.112]                   name <- added[[kk]]
[13:37:52.112]                   NAME <- NAMES[[kk]]
[13:37:52.112]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:52.112]                     next
[13:37:52.112]                   args[[name]] <- ""
[13:37:52.112]                 }
[13:37:52.112]                 NAMES <- toupper(removed)
[13:37:52.112]                 for (kk in seq_along(NAMES)) {
[13:37:52.112]                   name <- removed[[kk]]
[13:37:52.112]                   NAME <- NAMES[[kk]]
[13:37:52.112]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:52.112]                     next
[13:37:52.112]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:52.112]                 }
[13:37:52.112]                 if (length(args) > 0) 
[13:37:52.112]                   base::do.call(base::Sys.setenv, args = args)
[13:37:52.112]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:52.112]             }
[13:37:52.112]             else {
[13:37:52.112]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:52.112]             }
[13:37:52.112]             {
[13:37:52.112]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:52.112]                   0L) {
[13:37:52.112]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:52.112]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:52.112]                   base::options(opts)
[13:37:52.112]                 }
[13:37:52.112]                 {
[13:37:52.112]                   {
[13:37:52.112]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:52.112]                     NULL
[13:37:52.112]                   }
[13:37:52.112]                   options(future.plan = NULL)
[13:37:52.112]                   if (is.na(NA_character_)) 
[13:37:52.112]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:52.112]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:52.112]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:52.112]                     .init = FALSE)
[13:37:52.112]                 }
[13:37:52.112]             }
[13:37:52.112]         }
[13:37:52.112]     })
[13:37:52.112]     if (TRUE) {
[13:37:52.112]         base::sink(type = "output", split = FALSE)
[13:37:52.112]         if (TRUE) {
[13:37:52.112]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:52.112]         }
[13:37:52.112]         else {
[13:37:52.112]             ...future.result["stdout"] <- base::list(NULL)
[13:37:52.112]         }
[13:37:52.112]         base::close(...future.stdout)
[13:37:52.112]         ...future.stdout <- NULL
[13:37:52.112]     }
[13:37:52.112]     ...future.result$conditions <- ...future.conditions
[13:37:52.112]     ...future.result$finished <- base::Sys.time()
[13:37:52.112]     ...future.result
[13:37:52.112] }
[13:37:52.115] MultisessionFuture started
[13:37:52.115] - Launch lazy future ... done
[13:37:52.115] run() for ‘MultisessionFuture’ ... done
[13:37:52.618] receiveMessageFromWorker() for ClusterFuture ...
[13:37:52.618] - Validating connection of MultisessionFuture
[13:37:52.618] - received message: FutureResult
[13:37:52.618] - Received FutureResult
[13:37:52.618] - Erased future from FutureRegistry
[13:37:52.618] result() for ClusterFuture ...
[13:37:52.619] - result already collected: FutureResult
[13:37:52.619] result() for ClusterFuture ... done
[13:37:52.619] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:52.619] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[13:37:52.619] getGlobalsAndPackages() ...
[13:37:52.619] Searching for globals...
[13:37:52.620] - globals found: [2] ‘list’, ‘stop’
[13:37:52.620] Searching for globals ... DONE
[13:37:52.620] Resolving globals: FALSE
[13:37:52.620] 
[13:37:52.620] 
[13:37:52.621] getGlobalsAndPackages() ... DONE
[13:37:52.621] run() for ‘Future’ ...
[13:37:52.621] - state: ‘created’
[13:37:52.621] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:52.635] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:52.635] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:52.635]   - Field: ‘node’
[13:37:52.635]   - Field: ‘label’
[13:37:52.635]   - Field: ‘local’
[13:37:52.635]   - Field: ‘owner’
[13:37:52.635]   - Field: ‘envir’
[13:37:52.636]   - Field: ‘workers’
[13:37:52.636]   - Field: ‘packages’
[13:37:52.636]   - Field: ‘gc’
[13:37:52.636]   - Field: ‘conditions’
[13:37:52.636]   - Field: ‘persistent’
[13:37:52.636]   - Field: ‘expr’
[13:37:52.636]   - Field: ‘uuid’
[13:37:52.636]   - Field: ‘seed’
[13:37:52.636]   - Field: ‘version’
[13:37:52.636]   - Field: ‘result’
[13:37:52.636]   - Field: ‘asynchronous’
[13:37:52.637]   - Field: ‘calls’
[13:37:52.637]   - Field: ‘globals’
[13:37:52.637]   - Field: ‘stdout’
[13:37:52.637]   - Field: ‘earlySignal’
[13:37:52.637]   - Field: ‘lazy’
[13:37:52.637]   - Field: ‘state’
[13:37:52.637] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:52.637] - Launch lazy future ...
[13:37:52.637] Packages needed by the future expression (n = 0): <none>
[13:37:52.638] Packages needed by future strategies (n = 0): <none>
[13:37:52.638] {
[13:37:52.638]     {
[13:37:52.638]         {
[13:37:52.638]             ...future.startTime <- base::Sys.time()
[13:37:52.638]             {
[13:37:52.638]                 {
[13:37:52.638]                   {
[13:37:52.638]                     {
[13:37:52.638]                       base::local({
[13:37:52.638]                         has_future <- base::requireNamespace("future", 
[13:37:52.638]                           quietly = TRUE)
[13:37:52.638]                         if (has_future) {
[13:37:52.638]                           ns <- base::getNamespace("future")
[13:37:52.638]                           version <- ns[[".package"]][["version"]]
[13:37:52.638]                           if (is.null(version)) 
[13:37:52.638]                             version <- utils::packageVersion("future")
[13:37:52.638]                         }
[13:37:52.638]                         else {
[13:37:52.638]                           version <- NULL
[13:37:52.638]                         }
[13:37:52.638]                         if (!has_future || version < "1.8.0") {
[13:37:52.638]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:52.638]                             "", base::R.version$version.string), 
[13:37:52.638]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:52.638]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:52.638]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:52.638]                               "release", "version")], collapse = " "), 
[13:37:52.638]                             hostname = base::Sys.info()[["nodename"]])
[13:37:52.638]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:52.638]                             info)
[13:37:52.638]                           info <- base::paste(info, collapse = "; ")
[13:37:52.638]                           if (!has_future) {
[13:37:52.638]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:52.638]                               info)
[13:37:52.638]                           }
[13:37:52.638]                           else {
[13:37:52.638]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:52.638]                               info, version)
[13:37:52.638]                           }
[13:37:52.638]                           base::stop(msg)
[13:37:52.638]                         }
[13:37:52.638]                       })
[13:37:52.638]                     }
[13:37:52.638]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:52.638]                     base::options(mc.cores = 1L)
[13:37:52.638]                   }
[13:37:52.638]                   ...future.strategy.old <- future::plan("list")
[13:37:52.638]                   options(future.plan = NULL)
[13:37:52.638]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:52.638]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:52.638]                 }
[13:37:52.638]                 ...future.workdir <- getwd()
[13:37:52.638]             }
[13:37:52.638]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:52.638]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:52.638]         }
[13:37:52.638]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:52.638]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:52.638]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:52.638]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:52.638]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:52.638]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:52.638]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:52.638]             base::names(...future.oldOptions))
[13:37:52.638]     }
[13:37:52.638]     if (FALSE) {
[13:37:52.638]     }
[13:37:52.638]     else {
[13:37:52.638]         if (TRUE) {
[13:37:52.638]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:52.638]                 open = "w")
[13:37:52.638]         }
[13:37:52.638]         else {
[13:37:52.638]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:52.638]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:52.638]         }
[13:37:52.638]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:52.638]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:52.638]             base::sink(type = "output", split = FALSE)
[13:37:52.638]             base::close(...future.stdout)
[13:37:52.638]         }, add = TRUE)
[13:37:52.638]     }
[13:37:52.638]     ...future.frame <- base::sys.nframe()
[13:37:52.638]     ...future.conditions <- base::list()
[13:37:52.638]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:52.638]     if (FALSE) {
[13:37:52.638]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:52.638]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:52.638]     }
[13:37:52.638]     ...future.result <- base::tryCatch({
[13:37:52.638]         base::withCallingHandlers({
[13:37:52.638]             ...future.value <- base::withVisible(base::local({
[13:37:52.638]                 ...future.makeSendCondition <- base::local({
[13:37:52.638]                   sendCondition <- NULL
[13:37:52.638]                   function(frame = 1L) {
[13:37:52.638]                     if (is.function(sendCondition)) 
[13:37:52.638]                       return(sendCondition)
[13:37:52.638]                     ns <- getNamespace("parallel")
[13:37:52.638]                     if (exists("sendData", mode = "function", 
[13:37:52.638]                       envir = ns)) {
[13:37:52.638]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:52.638]                         envir = ns)
[13:37:52.638]                       envir <- sys.frame(frame)
[13:37:52.638]                       master <- NULL
[13:37:52.638]                       while (!identical(envir, .GlobalEnv) && 
[13:37:52.638]                         !identical(envir, emptyenv())) {
[13:37:52.638]                         if (exists("master", mode = "list", envir = envir, 
[13:37:52.638]                           inherits = FALSE)) {
[13:37:52.638]                           master <- get("master", mode = "list", 
[13:37:52.638]                             envir = envir, inherits = FALSE)
[13:37:52.638]                           if (inherits(master, c("SOCKnode", 
[13:37:52.638]                             "SOCK0node"))) {
[13:37:52.638]                             sendCondition <<- function(cond) {
[13:37:52.638]                               data <- list(type = "VALUE", value = cond, 
[13:37:52.638]                                 success = TRUE)
[13:37:52.638]                               parallel_sendData(master, data)
[13:37:52.638]                             }
[13:37:52.638]                             return(sendCondition)
[13:37:52.638]                           }
[13:37:52.638]                         }
[13:37:52.638]                         frame <- frame + 1L
[13:37:52.638]                         envir <- sys.frame(frame)
[13:37:52.638]                       }
[13:37:52.638]                     }
[13:37:52.638]                     sendCondition <<- function(cond) NULL
[13:37:52.638]                   }
[13:37:52.638]                 })
[13:37:52.638]                 withCallingHandlers({
[13:37:52.638]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:37:52.638]                 }, immediateCondition = function(cond) {
[13:37:52.638]                   sendCondition <- ...future.makeSendCondition()
[13:37:52.638]                   sendCondition(cond)
[13:37:52.638]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:52.638]                   {
[13:37:52.638]                     inherits <- base::inherits
[13:37:52.638]                     invokeRestart <- base::invokeRestart
[13:37:52.638]                     is.null <- base::is.null
[13:37:52.638]                     muffled <- FALSE
[13:37:52.638]                     if (inherits(cond, "message")) {
[13:37:52.638]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:52.638]                       if (muffled) 
[13:37:52.638]                         invokeRestart("muffleMessage")
[13:37:52.638]                     }
[13:37:52.638]                     else if (inherits(cond, "warning")) {
[13:37:52.638]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:52.638]                       if (muffled) 
[13:37:52.638]                         invokeRestart("muffleWarning")
[13:37:52.638]                     }
[13:37:52.638]                     else if (inherits(cond, "condition")) {
[13:37:52.638]                       if (!is.null(pattern)) {
[13:37:52.638]                         computeRestarts <- base::computeRestarts
[13:37:52.638]                         grepl <- base::grepl
[13:37:52.638]                         restarts <- computeRestarts(cond)
[13:37:52.638]                         for (restart in restarts) {
[13:37:52.638]                           name <- restart$name
[13:37:52.638]                           if (is.null(name)) 
[13:37:52.638]                             next
[13:37:52.638]                           if (!grepl(pattern, name)) 
[13:37:52.638]                             next
[13:37:52.638]                           invokeRestart(restart)
[13:37:52.638]                           muffled <- TRUE
[13:37:52.638]                           break
[13:37:52.638]                         }
[13:37:52.638]                       }
[13:37:52.638]                     }
[13:37:52.638]                     invisible(muffled)
[13:37:52.638]                   }
[13:37:52.638]                   muffleCondition(cond)
[13:37:52.638]                 })
[13:37:52.638]             }))
[13:37:52.638]             future::FutureResult(value = ...future.value$value, 
[13:37:52.638]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:52.638]                   ...future.rng), globalenv = if (FALSE) 
[13:37:52.638]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:52.638]                     ...future.globalenv.names))
[13:37:52.638]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:52.638]         }, condition = base::local({
[13:37:52.638]             c <- base::c
[13:37:52.638]             inherits <- base::inherits
[13:37:52.638]             invokeRestart <- base::invokeRestart
[13:37:52.638]             length <- base::length
[13:37:52.638]             list <- base::list
[13:37:52.638]             seq.int <- base::seq.int
[13:37:52.638]             signalCondition <- base::signalCondition
[13:37:52.638]             sys.calls <- base::sys.calls
[13:37:52.638]             `[[` <- base::`[[`
[13:37:52.638]             `+` <- base::`+`
[13:37:52.638]             `<<-` <- base::`<<-`
[13:37:52.638]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:52.638]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:52.638]                   3L)]
[13:37:52.638]             }
[13:37:52.638]             function(cond) {
[13:37:52.638]                 is_error <- inherits(cond, "error")
[13:37:52.638]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:52.638]                   NULL)
[13:37:52.638]                 if (is_error) {
[13:37:52.638]                   sessionInformation <- function() {
[13:37:52.638]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:52.638]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:52.638]                       search = base::search(), system = base::Sys.info())
[13:37:52.638]                   }
[13:37:52.638]                   ...future.conditions[[length(...future.conditions) + 
[13:37:52.638]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:52.638]                     cond$call), session = sessionInformation(), 
[13:37:52.638]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:52.638]                   signalCondition(cond)
[13:37:52.638]                 }
[13:37:52.638]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:52.638]                 "immediateCondition"))) {
[13:37:52.638]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:52.638]                   ...future.conditions[[length(...future.conditions) + 
[13:37:52.638]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:52.638]                   if (TRUE && !signal) {
[13:37:52.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:52.638]                     {
[13:37:52.638]                       inherits <- base::inherits
[13:37:52.638]                       invokeRestart <- base::invokeRestart
[13:37:52.638]                       is.null <- base::is.null
[13:37:52.638]                       muffled <- FALSE
[13:37:52.638]                       if (inherits(cond, "message")) {
[13:37:52.638]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:52.638]                         if (muffled) 
[13:37:52.638]                           invokeRestart("muffleMessage")
[13:37:52.638]                       }
[13:37:52.638]                       else if (inherits(cond, "warning")) {
[13:37:52.638]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:52.638]                         if (muffled) 
[13:37:52.638]                           invokeRestart("muffleWarning")
[13:37:52.638]                       }
[13:37:52.638]                       else if (inherits(cond, "condition")) {
[13:37:52.638]                         if (!is.null(pattern)) {
[13:37:52.638]                           computeRestarts <- base::computeRestarts
[13:37:52.638]                           grepl <- base::grepl
[13:37:52.638]                           restarts <- computeRestarts(cond)
[13:37:52.638]                           for (restart in restarts) {
[13:37:52.638]                             name <- restart$name
[13:37:52.638]                             if (is.null(name)) 
[13:37:52.638]                               next
[13:37:52.638]                             if (!grepl(pattern, name)) 
[13:37:52.638]                               next
[13:37:52.638]                             invokeRestart(restart)
[13:37:52.638]                             muffled <- TRUE
[13:37:52.638]                             break
[13:37:52.638]                           }
[13:37:52.638]                         }
[13:37:52.638]                       }
[13:37:52.638]                       invisible(muffled)
[13:37:52.638]                     }
[13:37:52.638]                     muffleCondition(cond, pattern = "^muffle")
[13:37:52.638]                   }
[13:37:52.638]                 }
[13:37:52.638]                 else {
[13:37:52.638]                   if (TRUE) {
[13:37:52.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:52.638]                     {
[13:37:52.638]                       inherits <- base::inherits
[13:37:52.638]                       invokeRestart <- base::invokeRestart
[13:37:52.638]                       is.null <- base::is.null
[13:37:52.638]                       muffled <- FALSE
[13:37:52.638]                       if (inherits(cond, "message")) {
[13:37:52.638]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:52.638]                         if (muffled) 
[13:37:52.638]                           invokeRestart("muffleMessage")
[13:37:52.638]                       }
[13:37:52.638]                       else if (inherits(cond, "warning")) {
[13:37:52.638]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:52.638]                         if (muffled) 
[13:37:52.638]                           invokeRestart("muffleWarning")
[13:37:52.638]                       }
[13:37:52.638]                       else if (inherits(cond, "condition")) {
[13:37:52.638]                         if (!is.null(pattern)) {
[13:37:52.638]                           computeRestarts <- base::computeRestarts
[13:37:52.638]                           grepl <- base::grepl
[13:37:52.638]                           restarts <- computeRestarts(cond)
[13:37:52.638]                           for (restart in restarts) {
[13:37:52.638]                             name <- restart$name
[13:37:52.638]                             if (is.null(name)) 
[13:37:52.638]                               next
[13:37:52.638]                             if (!grepl(pattern, name)) 
[13:37:52.638]                               next
[13:37:52.638]                             invokeRestart(restart)
[13:37:52.638]                             muffled <- TRUE
[13:37:52.638]                             break
[13:37:52.638]                           }
[13:37:52.638]                         }
[13:37:52.638]                       }
[13:37:52.638]                       invisible(muffled)
[13:37:52.638]                     }
[13:37:52.638]                     muffleCondition(cond, pattern = "^muffle")
[13:37:52.638]                   }
[13:37:52.638]                 }
[13:37:52.638]             }
[13:37:52.638]         }))
[13:37:52.638]     }, error = function(ex) {
[13:37:52.638]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:52.638]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:52.638]                 ...future.rng), started = ...future.startTime, 
[13:37:52.638]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:52.638]             version = "1.8"), class = "FutureResult")
[13:37:52.638]     }, finally = {
[13:37:52.638]         if (!identical(...future.workdir, getwd())) 
[13:37:52.638]             setwd(...future.workdir)
[13:37:52.638]         {
[13:37:52.638]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:52.638]                 ...future.oldOptions$nwarnings <- NULL
[13:37:52.638]             }
[13:37:52.638]             base::options(...future.oldOptions)
[13:37:52.638]             if (.Platform$OS.type == "windows") {
[13:37:52.638]                 old_names <- names(...future.oldEnvVars)
[13:37:52.638]                 envs <- base::Sys.getenv()
[13:37:52.638]                 names <- names(envs)
[13:37:52.638]                 common <- intersect(names, old_names)
[13:37:52.638]                 added <- setdiff(names, old_names)
[13:37:52.638]                 removed <- setdiff(old_names, names)
[13:37:52.638]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:52.638]                   envs[common]]
[13:37:52.638]                 NAMES <- toupper(changed)
[13:37:52.638]                 args <- list()
[13:37:52.638]                 for (kk in seq_along(NAMES)) {
[13:37:52.638]                   name <- changed[[kk]]
[13:37:52.638]                   NAME <- NAMES[[kk]]
[13:37:52.638]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:52.638]                     next
[13:37:52.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:52.638]                 }
[13:37:52.638]                 NAMES <- toupper(added)
[13:37:52.638]                 for (kk in seq_along(NAMES)) {
[13:37:52.638]                   name <- added[[kk]]
[13:37:52.638]                   NAME <- NAMES[[kk]]
[13:37:52.638]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:52.638]                     next
[13:37:52.638]                   args[[name]] <- ""
[13:37:52.638]                 }
[13:37:52.638]                 NAMES <- toupper(removed)
[13:37:52.638]                 for (kk in seq_along(NAMES)) {
[13:37:52.638]                   name <- removed[[kk]]
[13:37:52.638]                   NAME <- NAMES[[kk]]
[13:37:52.638]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:52.638]                     next
[13:37:52.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:52.638]                 }
[13:37:52.638]                 if (length(args) > 0) 
[13:37:52.638]                   base::do.call(base::Sys.setenv, args = args)
[13:37:52.638]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:52.638]             }
[13:37:52.638]             else {
[13:37:52.638]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:52.638]             }
[13:37:52.638]             {
[13:37:52.638]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:52.638]                   0L) {
[13:37:52.638]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:52.638]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:52.638]                   base::options(opts)
[13:37:52.638]                 }
[13:37:52.638]                 {
[13:37:52.638]                   {
[13:37:52.638]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:52.638]                     NULL
[13:37:52.638]                   }
[13:37:52.638]                   options(future.plan = NULL)
[13:37:52.638]                   if (is.na(NA_character_)) 
[13:37:52.638]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:52.638]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:52.638]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:52.638]                     .init = FALSE)
[13:37:52.638]                 }
[13:37:52.638]             }
[13:37:52.638]         }
[13:37:52.638]     })
[13:37:52.638]     if (TRUE) {
[13:37:52.638]         base::sink(type = "output", split = FALSE)
[13:37:52.638]         if (TRUE) {
[13:37:52.638]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:52.638]         }
[13:37:52.638]         else {
[13:37:52.638]             ...future.result["stdout"] <- base::list(NULL)
[13:37:52.638]         }
[13:37:52.638]         base::close(...future.stdout)
[13:37:52.638]         ...future.stdout <- NULL
[13:37:52.638]     }
[13:37:52.638]     ...future.result$conditions <- ...future.conditions
[13:37:52.638]     ...future.result$finished <- base::Sys.time()
[13:37:52.638]     ...future.result
[13:37:52.638] }
[13:37:52.641] MultisessionFuture started
[13:37:52.641] - Launch lazy future ... done
[13:37:52.641] run() for ‘MultisessionFuture’ ... done
[13:37:52.643] receiveMessageFromWorker() for ClusterFuture ...
[13:37:52.643] - Validating connection of MultisessionFuture
[13:37:52.643] - received message: FutureResult
[13:37:52.643] - Received FutureResult
[13:37:52.644] - Erased future from FutureRegistry
[13:37:52.644] result() for ClusterFuture ...
[13:37:52.644] - result already collected: FutureResult
[13:37:52.644] result() for ClusterFuture ... done
[13:37:52.644] signalConditions() ...
[13:37:52.644]  - include = ‘immediateCondition’
[13:37:52.644]  - exclude = 
[13:37:52.644]  - resignal = FALSE
[13:37:52.644]  - Number of conditions: 1
[13:37:52.644] signalConditions() ... done
[13:37:52.644] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:52.645] A MultisessionFuture was resolved (result was not collected)
[13:37:52.645] getGlobalsAndPackages() ...
[13:37:52.645] Searching for globals...
[13:37:52.645] - globals found: [2] ‘list’, ‘stop’
[13:37:52.645] Searching for globals ... DONE
[13:37:52.646] Resolving globals: FALSE
[13:37:52.646] 
[13:37:52.646] 
[13:37:52.646] getGlobalsAndPackages() ... DONE
[13:37:52.646] run() for ‘Future’ ...
[13:37:52.646] - state: ‘created’
[13:37:52.647] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:52.660] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:52.660] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:52.660]   - Field: ‘node’
[13:37:52.660]   - Field: ‘label’
[13:37:52.660]   - Field: ‘local’
[13:37:52.660]   - Field: ‘owner’
[13:37:52.660]   - Field: ‘envir’
[13:37:52.661]   - Field: ‘workers’
[13:37:52.661]   - Field: ‘packages’
[13:37:52.661]   - Field: ‘gc’
[13:37:52.661]   - Field: ‘conditions’
[13:37:52.661]   - Field: ‘persistent’
[13:37:52.661]   - Field: ‘expr’
[13:37:52.661]   - Field: ‘uuid’
[13:37:52.661]   - Field: ‘seed’
[13:37:52.661]   - Field: ‘version’
[13:37:52.661]   - Field: ‘result’
[13:37:52.661]   - Field: ‘asynchronous’
[13:37:52.662]   - Field: ‘calls’
[13:37:52.662]   - Field: ‘globals’
[13:37:52.662]   - Field: ‘stdout’
[13:37:52.662]   - Field: ‘earlySignal’
[13:37:52.662]   - Field: ‘lazy’
[13:37:52.662]   - Field: ‘state’
[13:37:52.662] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:52.662] - Launch lazy future ...
[13:37:52.663] Packages needed by the future expression (n = 0): <none>
[13:37:52.663] Packages needed by future strategies (n = 0): <none>
[13:37:52.663] {
[13:37:52.663]     {
[13:37:52.663]         {
[13:37:52.663]             ...future.startTime <- base::Sys.time()
[13:37:52.663]             {
[13:37:52.663]                 {
[13:37:52.663]                   {
[13:37:52.663]                     {
[13:37:52.663]                       base::local({
[13:37:52.663]                         has_future <- base::requireNamespace("future", 
[13:37:52.663]                           quietly = TRUE)
[13:37:52.663]                         if (has_future) {
[13:37:52.663]                           ns <- base::getNamespace("future")
[13:37:52.663]                           version <- ns[[".package"]][["version"]]
[13:37:52.663]                           if (is.null(version)) 
[13:37:52.663]                             version <- utils::packageVersion("future")
[13:37:52.663]                         }
[13:37:52.663]                         else {
[13:37:52.663]                           version <- NULL
[13:37:52.663]                         }
[13:37:52.663]                         if (!has_future || version < "1.8.0") {
[13:37:52.663]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:52.663]                             "", base::R.version$version.string), 
[13:37:52.663]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:52.663]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:52.663]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:52.663]                               "release", "version")], collapse = " "), 
[13:37:52.663]                             hostname = base::Sys.info()[["nodename"]])
[13:37:52.663]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:52.663]                             info)
[13:37:52.663]                           info <- base::paste(info, collapse = "; ")
[13:37:52.663]                           if (!has_future) {
[13:37:52.663]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:52.663]                               info)
[13:37:52.663]                           }
[13:37:52.663]                           else {
[13:37:52.663]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:52.663]                               info, version)
[13:37:52.663]                           }
[13:37:52.663]                           base::stop(msg)
[13:37:52.663]                         }
[13:37:52.663]                       })
[13:37:52.663]                     }
[13:37:52.663]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:52.663]                     base::options(mc.cores = 1L)
[13:37:52.663]                   }
[13:37:52.663]                   ...future.strategy.old <- future::plan("list")
[13:37:52.663]                   options(future.plan = NULL)
[13:37:52.663]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:52.663]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:52.663]                 }
[13:37:52.663]                 ...future.workdir <- getwd()
[13:37:52.663]             }
[13:37:52.663]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:52.663]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:52.663]         }
[13:37:52.663]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:52.663]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:52.663]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:52.663]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:52.663]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:52.663]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:52.663]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:52.663]             base::names(...future.oldOptions))
[13:37:52.663]     }
[13:37:52.663]     if (FALSE) {
[13:37:52.663]     }
[13:37:52.663]     else {
[13:37:52.663]         if (TRUE) {
[13:37:52.663]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:52.663]                 open = "w")
[13:37:52.663]         }
[13:37:52.663]         else {
[13:37:52.663]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:52.663]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:52.663]         }
[13:37:52.663]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:52.663]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:52.663]             base::sink(type = "output", split = FALSE)
[13:37:52.663]             base::close(...future.stdout)
[13:37:52.663]         }, add = TRUE)
[13:37:52.663]     }
[13:37:52.663]     ...future.frame <- base::sys.nframe()
[13:37:52.663]     ...future.conditions <- base::list()
[13:37:52.663]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:52.663]     if (FALSE) {
[13:37:52.663]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:52.663]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:52.663]     }
[13:37:52.663]     ...future.result <- base::tryCatch({
[13:37:52.663]         base::withCallingHandlers({
[13:37:52.663]             ...future.value <- base::withVisible(base::local({
[13:37:52.663]                 ...future.makeSendCondition <- base::local({
[13:37:52.663]                   sendCondition <- NULL
[13:37:52.663]                   function(frame = 1L) {
[13:37:52.663]                     if (is.function(sendCondition)) 
[13:37:52.663]                       return(sendCondition)
[13:37:52.663]                     ns <- getNamespace("parallel")
[13:37:52.663]                     if (exists("sendData", mode = "function", 
[13:37:52.663]                       envir = ns)) {
[13:37:52.663]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:52.663]                         envir = ns)
[13:37:52.663]                       envir <- sys.frame(frame)
[13:37:52.663]                       master <- NULL
[13:37:52.663]                       while (!identical(envir, .GlobalEnv) && 
[13:37:52.663]                         !identical(envir, emptyenv())) {
[13:37:52.663]                         if (exists("master", mode = "list", envir = envir, 
[13:37:52.663]                           inherits = FALSE)) {
[13:37:52.663]                           master <- get("master", mode = "list", 
[13:37:52.663]                             envir = envir, inherits = FALSE)
[13:37:52.663]                           if (inherits(master, c("SOCKnode", 
[13:37:52.663]                             "SOCK0node"))) {
[13:37:52.663]                             sendCondition <<- function(cond) {
[13:37:52.663]                               data <- list(type = "VALUE", value = cond, 
[13:37:52.663]                                 success = TRUE)
[13:37:52.663]                               parallel_sendData(master, data)
[13:37:52.663]                             }
[13:37:52.663]                             return(sendCondition)
[13:37:52.663]                           }
[13:37:52.663]                         }
[13:37:52.663]                         frame <- frame + 1L
[13:37:52.663]                         envir <- sys.frame(frame)
[13:37:52.663]                       }
[13:37:52.663]                     }
[13:37:52.663]                     sendCondition <<- function(cond) NULL
[13:37:52.663]                   }
[13:37:52.663]                 })
[13:37:52.663]                 withCallingHandlers({
[13:37:52.663]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:37:52.663]                 }, immediateCondition = function(cond) {
[13:37:52.663]                   sendCondition <- ...future.makeSendCondition()
[13:37:52.663]                   sendCondition(cond)
[13:37:52.663]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:52.663]                   {
[13:37:52.663]                     inherits <- base::inherits
[13:37:52.663]                     invokeRestart <- base::invokeRestart
[13:37:52.663]                     is.null <- base::is.null
[13:37:52.663]                     muffled <- FALSE
[13:37:52.663]                     if (inherits(cond, "message")) {
[13:37:52.663]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:52.663]                       if (muffled) 
[13:37:52.663]                         invokeRestart("muffleMessage")
[13:37:52.663]                     }
[13:37:52.663]                     else if (inherits(cond, "warning")) {
[13:37:52.663]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:52.663]                       if (muffled) 
[13:37:52.663]                         invokeRestart("muffleWarning")
[13:37:52.663]                     }
[13:37:52.663]                     else if (inherits(cond, "condition")) {
[13:37:52.663]                       if (!is.null(pattern)) {
[13:37:52.663]                         computeRestarts <- base::computeRestarts
[13:37:52.663]                         grepl <- base::grepl
[13:37:52.663]                         restarts <- computeRestarts(cond)
[13:37:52.663]                         for (restart in restarts) {
[13:37:52.663]                           name <- restart$name
[13:37:52.663]                           if (is.null(name)) 
[13:37:52.663]                             next
[13:37:52.663]                           if (!grepl(pattern, name)) 
[13:37:52.663]                             next
[13:37:52.663]                           invokeRestart(restart)
[13:37:52.663]                           muffled <- TRUE
[13:37:52.663]                           break
[13:37:52.663]                         }
[13:37:52.663]                       }
[13:37:52.663]                     }
[13:37:52.663]                     invisible(muffled)
[13:37:52.663]                   }
[13:37:52.663]                   muffleCondition(cond)
[13:37:52.663]                 })
[13:37:52.663]             }))
[13:37:52.663]             future::FutureResult(value = ...future.value$value, 
[13:37:52.663]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:52.663]                   ...future.rng), globalenv = if (FALSE) 
[13:37:52.663]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:52.663]                     ...future.globalenv.names))
[13:37:52.663]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:52.663]         }, condition = base::local({
[13:37:52.663]             c <- base::c
[13:37:52.663]             inherits <- base::inherits
[13:37:52.663]             invokeRestart <- base::invokeRestart
[13:37:52.663]             length <- base::length
[13:37:52.663]             list <- base::list
[13:37:52.663]             seq.int <- base::seq.int
[13:37:52.663]             signalCondition <- base::signalCondition
[13:37:52.663]             sys.calls <- base::sys.calls
[13:37:52.663]             `[[` <- base::`[[`
[13:37:52.663]             `+` <- base::`+`
[13:37:52.663]             `<<-` <- base::`<<-`
[13:37:52.663]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:52.663]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:52.663]                   3L)]
[13:37:52.663]             }
[13:37:52.663]             function(cond) {
[13:37:52.663]                 is_error <- inherits(cond, "error")
[13:37:52.663]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:52.663]                   NULL)
[13:37:52.663]                 if (is_error) {
[13:37:52.663]                   sessionInformation <- function() {
[13:37:52.663]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:52.663]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:52.663]                       search = base::search(), system = base::Sys.info())
[13:37:52.663]                   }
[13:37:52.663]                   ...future.conditions[[length(...future.conditions) + 
[13:37:52.663]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:52.663]                     cond$call), session = sessionInformation(), 
[13:37:52.663]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:52.663]                   signalCondition(cond)
[13:37:52.663]                 }
[13:37:52.663]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:52.663]                 "immediateCondition"))) {
[13:37:52.663]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:52.663]                   ...future.conditions[[length(...future.conditions) + 
[13:37:52.663]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:52.663]                   if (TRUE && !signal) {
[13:37:52.663]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:52.663]                     {
[13:37:52.663]                       inherits <- base::inherits
[13:37:52.663]                       invokeRestart <- base::invokeRestart
[13:37:52.663]                       is.null <- base::is.null
[13:37:52.663]                       muffled <- FALSE
[13:37:52.663]                       if (inherits(cond, "message")) {
[13:37:52.663]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:52.663]                         if (muffled) 
[13:37:52.663]                           invokeRestart("muffleMessage")
[13:37:52.663]                       }
[13:37:52.663]                       else if (inherits(cond, "warning")) {
[13:37:52.663]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:52.663]                         if (muffled) 
[13:37:52.663]                           invokeRestart("muffleWarning")
[13:37:52.663]                       }
[13:37:52.663]                       else if (inherits(cond, "condition")) {
[13:37:52.663]                         if (!is.null(pattern)) {
[13:37:52.663]                           computeRestarts <- base::computeRestarts
[13:37:52.663]                           grepl <- base::grepl
[13:37:52.663]                           restarts <- computeRestarts(cond)
[13:37:52.663]                           for (restart in restarts) {
[13:37:52.663]                             name <- restart$name
[13:37:52.663]                             if (is.null(name)) 
[13:37:52.663]                               next
[13:37:52.663]                             if (!grepl(pattern, name)) 
[13:37:52.663]                               next
[13:37:52.663]                             invokeRestart(restart)
[13:37:52.663]                             muffled <- TRUE
[13:37:52.663]                             break
[13:37:52.663]                           }
[13:37:52.663]                         }
[13:37:52.663]                       }
[13:37:52.663]                       invisible(muffled)
[13:37:52.663]                     }
[13:37:52.663]                     muffleCondition(cond, pattern = "^muffle")
[13:37:52.663]                   }
[13:37:52.663]                 }
[13:37:52.663]                 else {
[13:37:52.663]                   if (TRUE) {
[13:37:52.663]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:52.663]                     {
[13:37:52.663]                       inherits <- base::inherits
[13:37:52.663]                       invokeRestart <- base::invokeRestart
[13:37:52.663]                       is.null <- base::is.null
[13:37:52.663]                       muffled <- FALSE
[13:37:52.663]                       if (inherits(cond, "message")) {
[13:37:52.663]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:52.663]                         if (muffled) 
[13:37:52.663]                           invokeRestart("muffleMessage")
[13:37:52.663]                       }
[13:37:52.663]                       else if (inherits(cond, "warning")) {
[13:37:52.663]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:52.663]                         if (muffled) 
[13:37:52.663]                           invokeRestart("muffleWarning")
[13:37:52.663]                       }
[13:37:52.663]                       else if (inherits(cond, "condition")) {
[13:37:52.663]                         if (!is.null(pattern)) {
[13:37:52.663]                           computeRestarts <- base::computeRestarts
[13:37:52.663]                           grepl <- base::grepl
[13:37:52.663]                           restarts <- computeRestarts(cond)
[13:37:52.663]                           for (restart in restarts) {
[13:37:52.663]                             name <- restart$name
[13:37:52.663]                             if (is.null(name)) 
[13:37:52.663]                               next
[13:37:52.663]                             if (!grepl(pattern, name)) 
[13:37:52.663]                               next
[13:37:52.663]                             invokeRestart(restart)
[13:37:52.663]                             muffled <- TRUE
[13:37:52.663]                             break
[13:37:52.663]                           }
[13:37:52.663]                         }
[13:37:52.663]                       }
[13:37:52.663]                       invisible(muffled)
[13:37:52.663]                     }
[13:37:52.663]                     muffleCondition(cond, pattern = "^muffle")
[13:37:52.663]                   }
[13:37:52.663]                 }
[13:37:52.663]             }
[13:37:52.663]         }))
[13:37:52.663]     }, error = function(ex) {
[13:37:52.663]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:52.663]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:52.663]                 ...future.rng), started = ...future.startTime, 
[13:37:52.663]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:52.663]             version = "1.8"), class = "FutureResult")
[13:37:52.663]     }, finally = {
[13:37:52.663]         if (!identical(...future.workdir, getwd())) 
[13:37:52.663]             setwd(...future.workdir)
[13:37:52.663]         {
[13:37:52.663]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:52.663]                 ...future.oldOptions$nwarnings <- NULL
[13:37:52.663]             }
[13:37:52.663]             base::options(...future.oldOptions)
[13:37:52.663]             if (.Platform$OS.type == "windows") {
[13:37:52.663]                 old_names <- names(...future.oldEnvVars)
[13:37:52.663]                 envs <- base::Sys.getenv()
[13:37:52.663]                 names <- names(envs)
[13:37:52.663]                 common <- intersect(names, old_names)
[13:37:52.663]                 added <- setdiff(names, old_names)
[13:37:52.663]                 removed <- setdiff(old_names, names)
[13:37:52.663]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:52.663]                   envs[common]]
[13:37:52.663]                 NAMES <- toupper(changed)
[13:37:52.663]                 args <- list()
[13:37:52.663]                 for (kk in seq_along(NAMES)) {
[13:37:52.663]                   name <- changed[[kk]]
[13:37:52.663]                   NAME <- NAMES[[kk]]
[13:37:52.663]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:52.663]                     next
[13:37:52.663]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:52.663]                 }
[13:37:52.663]                 NAMES <- toupper(added)
[13:37:52.663]                 for (kk in seq_along(NAMES)) {
[13:37:52.663]                   name <- added[[kk]]
[13:37:52.663]                   NAME <- NAMES[[kk]]
[13:37:52.663]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:52.663]                     next
[13:37:52.663]                   args[[name]] <- ""
[13:37:52.663]                 }
[13:37:52.663]                 NAMES <- toupper(removed)
[13:37:52.663]                 for (kk in seq_along(NAMES)) {
[13:37:52.663]                   name <- removed[[kk]]
[13:37:52.663]                   NAME <- NAMES[[kk]]
[13:37:52.663]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:52.663]                     next
[13:37:52.663]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:52.663]                 }
[13:37:52.663]                 if (length(args) > 0) 
[13:37:52.663]                   base::do.call(base::Sys.setenv, args = args)
[13:37:52.663]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:52.663]             }
[13:37:52.663]             else {
[13:37:52.663]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:52.663]             }
[13:37:52.663]             {
[13:37:52.663]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:52.663]                   0L) {
[13:37:52.663]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:52.663]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:52.663]                   base::options(opts)
[13:37:52.663]                 }
[13:37:52.663]                 {
[13:37:52.663]                   {
[13:37:52.663]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:52.663]                     NULL
[13:37:52.663]                   }
[13:37:52.663]                   options(future.plan = NULL)
[13:37:52.663]                   if (is.na(NA_character_)) 
[13:37:52.663]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:52.663]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:52.663]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:52.663]                     .init = FALSE)
[13:37:52.663]                 }
[13:37:52.663]             }
[13:37:52.663]         }
[13:37:52.663]     })
[13:37:52.663]     if (TRUE) {
[13:37:52.663]         base::sink(type = "output", split = FALSE)
[13:37:52.663]         if (TRUE) {
[13:37:52.663]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:52.663]         }
[13:37:52.663]         else {
[13:37:52.663]             ...future.result["stdout"] <- base::list(NULL)
[13:37:52.663]         }
[13:37:52.663]         base::close(...future.stdout)
[13:37:52.663]         ...future.stdout <- NULL
[13:37:52.663]     }
[13:37:52.663]     ...future.result$conditions <- ...future.conditions
[13:37:52.663]     ...future.result$finished <- base::Sys.time()
[13:37:52.663]     ...future.result
[13:37:52.663] }
[13:37:52.666] MultisessionFuture started
[13:37:52.666] - Launch lazy future ... done
[13:37:52.666] run() for ‘MultisessionFuture’ ... done
[13:37:52.667] receiveMessageFromWorker() for ClusterFuture ...
[13:37:52.668] - Validating connection of MultisessionFuture
[13:37:52.668] - received message: FutureResult
[13:37:52.668] - Received FutureResult
[13:37:52.668] - Erased future from FutureRegistry
[13:37:52.668] result() for ClusterFuture ...
[13:37:52.668] - result already collected: FutureResult
[13:37:52.668] result() for ClusterFuture ... done
[13:37:52.669] signalConditions() ...
[13:37:52.669]  - include = ‘immediateCondition’
[13:37:52.669]  - exclude = 
[13:37:52.669]  - resignal = FALSE
[13:37:52.669]  - Number of conditions: 1
[13:37:52.669] signalConditions() ... done
[13:37:52.669] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:52.669] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 2 ... DONE
- result = FALSE, recursive = Inf ...
[13:37:52.669] getGlobalsAndPackages() ...
[13:37:52.670] Searching for globals...
[13:37:52.671] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:37:52.671] Searching for globals ... DONE
[13:37:52.671] Resolving globals: FALSE
[13:37:52.671] 
[13:37:52.671] 
[13:37:52.671] getGlobalsAndPackages() ... DONE
[13:37:52.672] run() for ‘Future’ ...
[13:37:52.672] - state: ‘created’
[13:37:52.672] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:52.685] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:52.685] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:52.686]   - Field: ‘node’
[13:37:52.686]   - Field: ‘label’
[13:37:52.686]   - Field: ‘local’
[13:37:52.686]   - Field: ‘owner’
[13:37:52.686]   - Field: ‘envir’
[13:37:52.686]   - Field: ‘workers’
[13:37:52.686]   - Field: ‘packages’
[13:37:52.686]   - Field: ‘gc’
[13:37:52.686]   - Field: ‘conditions’
[13:37:52.686]   - Field: ‘persistent’
[13:37:52.687]   - Field: ‘expr’
[13:37:52.687]   - Field: ‘uuid’
[13:37:52.687]   - Field: ‘seed’
[13:37:52.687]   - Field: ‘version’
[13:37:52.687]   - Field: ‘result’
[13:37:52.687]   - Field: ‘asynchronous’
[13:37:52.687]   - Field: ‘calls’
[13:37:52.687]   - Field: ‘globals’
[13:37:52.687]   - Field: ‘stdout’
[13:37:52.687]   - Field: ‘earlySignal’
[13:37:52.687]   - Field: ‘lazy’
[13:37:52.687]   - Field: ‘state’
[13:37:52.688] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:52.688] - Launch lazy future ...
[13:37:52.688] Packages needed by the future expression (n = 0): <none>
[13:37:52.688] Packages needed by future strategies (n = 0): <none>
[13:37:52.688] {
[13:37:52.688]     {
[13:37:52.688]         {
[13:37:52.688]             ...future.startTime <- base::Sys.time()
[13:37:52.688]             {
[13:37:52.688]                 {
[13:37:52.688]                   {
[13:37:52.688]                     {
[13:37:52.688]                       base::local({
[13:37:52.688]                         has_future <- base::requireNamespace("future", 
[13:37:52.688]                           quietly = TRUE)
[13:37:52.688]                         if (has_future) {
[13:37:52.688]                           ns <- base::getNamespace("future")
[13:37:52.688]                           version <- ns[[".package"]][["version"]]
[13:37:52.688]                           if (is.null(version)) 
[13:37:52.688]                             version <- utils::packageVersion("future")
[13:37:52.688]                         }
[13:37:52.688]                         else {
[13:37:52.688]                           version <- NULL
[13:37:52.688]                         }
[13:37:52.688]                         if (!has_future || version < "1.8.0") {
[13:37:52.688]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:52.688]                             "", base::R.version$version.string), 
[13:37:52.688]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:52.688]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:52.688]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:52.688]                               "release", "version")], collapse = " "), 
[13:37:52.688]                             hostname = base::Sys.info()[["nodename"]])
[13:37:52.688]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:52.688]                             info)
[13:37:52.688]                           info <- base::paste(info, collapse = "; ")
[13:37:52.688]                           if (!has_future) {
[13:37:52.688]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:52.688]                               info)
[13:37:52.688]                           }
[13:37:52.688]                           else {
[13:37:52.688]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:52.688]                               info, version)
[13:37:52.688]                           }
[13:37:52.688]                           base::stop(msg)
[13:37:52.688]                         }
[13:37:52.688]                       })
[13:37:52.688]                     }
[13:37:52.688]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:52.688]                     base::options(mc.cores = 1L)
[13:37:52.688]                   }
[13:37:52.688]                   ...future.strategy.old <- future::plan("list")
[13:37:52.688]                   options(future.plan = NULL)
[13:37:52.688]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:52.688]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:52.688]                 }
[13:37:52.688]                 ...future.workdir <- getwd()
[13:37:52.688]             }
[13:37:52.688]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:52.688]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:52.688]         }
[13:37:52.688]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:52.688]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:52.688]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:52.688]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:52.688]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:52.688]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:52.688]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:52.688]             base::names(...future.oldOptions))
[13:37:52.688]     }
[13:37:52.688]     if (FALSE) {
[13:37:52.688]     }
[13:37:52.688]     else {
[13:37:52.688]         if (TRUE) {
[13:37:52.688]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:52.688]                 open = "w")
[13:37:52.688]         }
[13:37:52.688]         else {
[13:37:52.688]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:52.688]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:52.688]         }
[13:37:52.688]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:52.688]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:52.688]             base::sink(type = "output", split = FALSE)
[13:37:52.688]             base::close(...future.stdout)
[13:37:52.688]         }, add = TRUE)
[13:37:52.688]     }
[13:37:52.688]     ...future.frame <- base::sys.nframe()
[13:37:52.688]     ...future.conditions <- base::list()
[13:37:52.688]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:52.688]     if (FALSE) {
[13:37:52.688]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:52.688]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:52.688]     }
[13:37:52.688]     ...future.result <- base::tryCatch({
[13:37:52.688]         base::withCallingHandlers({
[13:37:52.688]             ...future.value <- base::withVisible(base::local({
[13:37:52.688]                 ...future.makeSendCondition <- base::local({
[13:37:52.688]                   sendCondition <- NULL
[13:37:52.688]                   function(frame = 1L) {
[13:37:52.688]                     if (is.function(sendCondition)) 
[13:37:52.688]                       return(sendCondition)
[13:37:52.688]                     ns <- getNamespace("parallel")
[13:37:52.688]                     if (exists("sendData", mode = "function", 
[13:37:52.688]                       envir = ns)) {
[13:37:52.688]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:52.688]                         envir = ns)
[13:37:52.688]                       envir <- sys.frame(frame)
[13:37:52.688]                       master <- NULL
[13:37:52.688]                       while (!identical(envir, .GlobalEnv) && 
[13:37:52.688]                         !identical(envir, emptyenv())) {
[13:37:52.688]                         if (exists("master", mode = "list", envir = envir, 
[13:37:52.688]                           inherits = FALSE)) {
[13:37:52.688]                           master <- get("master", mode = "list", 
[13:37:52.688]                             envir = envir, inherits = FALSE)
[13:37:52.688]                           if (inherits(master, c("SOCKnode", 
[13:37:52.688]                             "SOCK0node"))) {
[13:37:52.688]                             sendCondition <<- function(cond) {
[13:37:52.688]                               data <- list(type = "VALUE", value = cond, 
[13:37:52.688]                                 success = TRUE)
[13:37:52.688]                               parallel_sendData(master, data)
[13:37:52.688]                             }
[13:37:52.688]                             return(sendCondition)
[13:37:52.688]                           }
[13:37:52.688]                         }
[13:37:52.688]                         frame <- frame + 1L
[13:37:52.688]                         envir <- sys.frame(frame)
[13:37:52.688]                       }
[13:37:52.688]                     }
[13:37:52.688]                     sendCondition <<- function(cond) NULL
[13:37:52.688]                   }
[13:37:52.688]                 })
[13:37:52.688]                 withCallingHandlers({
[13:37:52.688]                   {
[13:37:52.688]                     Sys.sleep(0.5)
[13:37:52.688]                     list(a = 1, b = 42L)
[13:37:52.688]                   }
[13:37:52.688]                 }, immediateCondition = function(cond) {
[13:37:52.688]                   sendCondition <- ...future.makeSendCondition()
[13:37:52.688]                   sendCondition(cond)
[13:37:52.688]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:52.688]                   {
[13:37:52.688]                     inherits <- base::inherits
[13:37:52.688]                     invokeRestart <- base::invokeRestart
[13:37:52.688]                     is.null <- base::is.null
[13:37:52.688]                     muffled <- FALSE
[13:37:52.688]                     if (inherits(cond, "message")) {
[13:37:52.688]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:52.688]                       if (muffled) 
[13:37:52.688]                         invokeRestart("muffleMessage")
[13:37:52.688]                     }
[13:37:52.688]                     else if (inherits(cond, "warning")) {
[13:37:52.688]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:52.688]                       if (muffled) 
[13:37:52.688]                         invokeRestart("muffleWarning")
[13:37:52.688]                     }
[13:37:52.688]                     else if (inherits(cond, "condition")) {
[13:37:52.688]                       if (!is.null(pattern)) {
[13:37:52.688]                         computeRestarts <- base::computeRestarts
[13:37:52.688]                         grepl <- base::grepl
[13:37:52.688]                         restarts <- computeRestarts(cond)
[13:37:52.688]                         for (restart in restarts) {
[13:37:52.688]                           name <- restart$name
[13:37:52.688]                           if (is.null(name)) 
[13:37:52.688]                             next
[13:37:52.688]                           if (!grepl(pattern, name)) 
[13:37:52.688]                             next
[13:37:52.688]                           invokeRestart(restart)
[13:37:52.688]                           muffled <- TRUE
[13:37:52.688]                           break
[13:37:52.688]                         }
[13:37:52.688]                       }
[13:37:52.688]                     }
[13:37:52.688]                     invisible(muffled)
[13:37:52.688]                   }
[13:37:52.688]                   muffleCondition(cond)
[13:37:52.688]                 })
[13:37:52.688]             }))
[13:37:52.688]             future::FutureResult(value = ...future.value$value, 
[13:37:52.688]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:52.688]                   ...future.rng), globalenv = if (FALSE) 
[13:37:52.688]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:52.688]                     ...future.globalenv.names))
[13:37:52.688]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:52.688]         }, condition = base::local({
[13:37:52.688]             c <- base::c
[13:37:52.688]             inherits <- base::inherits
[13:37:52.688]             invokeRestart <- base::invokeRestart
[13:37:52.688]             length <- base::length
[13:37:52.688]             list <- base::list
[13:37:52.688]             seq.int <- base::seq.int
[13:37:52.688]             signalCondition <- base::signalCondition
[13:37:52.688]             sys.calls <- base::sys.calls
[13:37:52.688]             `[[` <- base::`[[`
[13:37:52.688]             `+` <- base::`+`
[13:37:52.688]             `<<-` <- base::`<<-`
[13:37:52.688]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:52.688]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:52.688]                   3L)]
[13:37:52.688]             }
[13:37:52.688]             function(cond) {
[13:37:52.688]                 is_error <- inherits(cond, "error")
[13:37:52.688]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:52.688]                   NULL)
[13:37:52.688]                 if (is_error) {
[13:37:52.688]                   sessionInformation <- function() {
[13:37:52.688]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:52.688]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:52.688]                       search = base::search(), system = base::Sys.info())
[13:37:52.688]                   }
[13:37:52.688]                   ...future.conditions[[length(...future.conditions) + 
[13:37:52.688]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:52.688]                     cond$call), session = sessionInformation(), 
[13:37:52.688]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:52.688]                   signalCondition(cond)
[13:37:52.688]                 }
[13:37:52.688]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:52.688]                 "immediateCondition"))) {
[13:37:52.688]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:52.688]                   ...future.conditions[[length(...future.conditions) + 
[13:37:52.688]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:52.688]                   if (TRUE && !signal) {
[13:37:52.688]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:52.688]                     {
[13:37:52.688]                       inherits <- base::inherits
[13:37:52.688]                       invokeRestart <- base::invokeRestart
[13:37:52.688]                       is.null <- base::is.null
[13:37:52.688]                       muffled <- FALSE
[13:37:52.688]                       if (inherits(cond, "message")) {
[13:37:52.688]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:52.688]                         if (muffled) 
[13:37:52.688]                           invokeRestart("muffleMessage")
[13:37:52.688]                       }
[13:37:52.688]                       else if (inherits(cond, "warning")) {
[13:37:52.688]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:52.688]                         if (muffled) 
[13:37:52.688]                           invokeRestart("muffleWarning")
[13:37:52.688]                       }
[13:37:52.688]                       else if (inherits(cond, "condition")) {
[13:37:52.688]                         if (!is.null(pattern)) {
[13:37:52.688]                           computeRestarts <- base::computeRestarts
[13:37:52.688]                           grepl <- base::grepl
[13:37:52.688]                           restarts <- computeRestarts(cond)
[13:37:52.688]                           for (restart in restarts) {
[13:37:52.688]                             name <- restart$name
[13:37:52.688]                             if (is.null(name)) 
[13:37:52.688]                               next
[13:37:52.688]                             if (!grepl(pattern, name)) 
[13:37:52.688]                               next
[13:37:52.688]                             invokeRestart(restart)
[13:37:52.688]                             muffled <- TRUE
[13:37:52.688]                             break
[13:37:52.688]                           }
[13:37:52.688]                         }
[13:37:52.688]                       }
[13:37:52.688]                       invisible(muffled)
[13:37:52.688]                     }
[13:37:52.688]                     muffleCondition(cond, pattern = "^muffle")
[13:37:52.688]                   }
[13:37:52.688]                 }
[13:37:52.688]                 else {
[13:37:52.688]                   if (TRUE) {
[13:37:52.688]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:52.688]                     {
[13:37:52.688]                       inherits <- base::inherits
[13:37:52.688]                       invokeRestart <- base::invokeRestart
[13:37:52.688]                       is.null <- base::is.null
[13:37:52.688]                       muffled <- FALSE
[13:37:52.688]                       if (inherits(cond, "message")) {
[13:37:52.688]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:52.688]                         if (muffled) 
[13:37:52.688]                           invokeRestart("muffleMessage")
[13:37:52.688]                       }
[13:37:52.688]                       else if (inherits(cond, "warning")) {
[13:37:52.688]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:52.688]                         if (muffled) 
[13:37:52.688]                           invokeRestart("muffleWarning")
[13:37:52.688]                       }
[13:37:52.688]                       else if (inherits(cond, "condition")) {
[13:37:52.688]                         if (!is.null(pattern)) {
[13:37:52.688]                           computeRestarts <- base::computeRestarts
[13:37:52.688]                           grepl <- base::grepl
[13:37:52.688]                           restarts <- computeRestarts(cond)
[13:37:52.688]                           for (restart in restarts) {
[13:37:52.688]                             name <- restart$name
[13:37:52.688]                             if (is.null(name)) 
[13:37:52.688]                               next
[13:37:52.688]                             if (!grepl(pattern, name)) 
[13:37:52.688]                               next
[13:37:52.688]                             invokeRestart(restart)
[13:37:52.688]                             muffled <- TRUE
[13:37:52.688]                             break
[13:37:52.688]                           }
[13:37:52.688]                         }
[13:37:52.688]                       }
[13:37:52.688]                       invisible(muffled)
[13:37:52.688]                     }
[13:37:52.688]                     muffleCondition(cond, pattern = "^muffle")
[13:37:52.688]                   }
[13:37:52.688]                 }
[13:37:52.688]             }
[13:37:52.688]         }))
[13:37:52.688]     }, error = function(ex) {
[13:37:52.688]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:52.688]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:52.688]                 ...future.rng), started = ...future.startTime, 
[13:37:52.688]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:52.688]             version = "1.8"), class = "FutureResult")
[13:37:52.688]     }, finally = {
[13:37:52.688]         if (!identical(...future.workdir, getwd())) 
[13:37:52.688]             setwd(...future.workdir)
[13:37:52.688]         {
[13:37:52.688]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:52.688]                 ...future.oldOptions$nwarnings <- NULL
[13:37:52.688]             }
[13:37:52.688]             base::options(...future.oldOptions)
[13:37:52.688]             if (.Platform$OS.type == "windows") {
[13:37:52.688]                 old_names <- names(...future.oldEnvVars)
[13:37:52.688]                 envs <- base::Sys.getenv()
[13:37:52.688]                 names <- names(envs)
[13:37:52.688]                 common <- intersect(names, old_names)
[13:37:52.688]                 added <- setdiff(names, old_names)
[13:37:52.688]                 removed <- setdiff(old_names, names)
[13:37:52.688]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:52.688]                   envs[common]]
[13:37:52.688]                 NAMES <- toupper(changed)
[13:37:52.688]                 args <- list()
[13:37:52.688]                 for (kk in seq_along(NAMES)) {
[13:37:52.688]                   name <- changed[[kk]]
[13:37:52.688]                   NAME <- NAMES[[kk]]
[13:37:52.688]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:52.688]                     next
[13:37:52.688]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:52.688]                 }
[13:37:52.688]                 NAMES <- toupper(added)
[13:37:52.688]                 for (kk in seq_along(NAMES)) {
[13:37:52.688]                   name <- added[[kk]]
[13:37:52.688]                   NAME <- NAMES[[kk]]
[13:37:52.688]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:52.688]                     next
[13:37:52.688]                   args[[name]] <- ""
[13:37:52.688]                 }
[13:37:52.688]                 NAMES <- toupper(removed)
[13:37:52.688]                 for (kk in seq_along(NAMES)) {
[13:37:52.688]                   name <- removed[[kk]]
[13:37:52.688]                   NAME <- NAMES[[kk]]
[13:37:52.688]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:52.688]                     next
[13:37:52.688]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:52.688]                 }
[13:37:52.688]                 if (length(args) > 0) 
[13:37:52.688]                   base::do.call(base::Sys.setenv, args = args)
[13:37:52.688]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:52.688]             }
[13:37:52.688]             else {
[13:37:52.688]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:52.688]             }
[13:37:52.688]             {
[13:37:52.688]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:52.688]                   0L) {
[13:37:52.688]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:52.688]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:52.688]                   base::options(opts)
[13:37:52.688]                 }
[13:37:52.688]                 {
[13:37:52.688]                   {
[13:37:52.688]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:52.688]                     NULL
[13:37:52.688]                   }
[13:37:52.688]                   options(future.plan = NULL)
[13:37:52.688]                   if (is.na(NA_character_)) 
[13:37:52.688]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:52.688]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:52.688]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:52.688]                     .init = FALSE)
[13:37:52.688]                 }
[13:37:52.688]             }
[13:37:52.688]         }
[13:37:52.688]     })
[13:37:52.688]     if (TRUE) {
[13:37:52.688]         base::sink(type = "output", split = FALSE)
[13:37:52.688]         if (TRUE) {
[13:37:52.688]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:52.688]         }
[13:37:52.688]         else {
[13:37:52.688]             ...future.result["stdout"] <- base::list(NULL)
[13:37:52.688]         }
[13:37:52.688]         base::close(...future.stdout)
[13:37:52.688]         ...future.stdout <- NULL
[13:37:52.688]     }
[13:37:52.688]     ...future.result$conditions <- ...future.conditions
[13:37:52.688]     ...future.result$finished <- base::Sys.time()
[13:37:52.688]     ...future.result
[13:37:52.688] }
[13:37:52.691] MultisessionFuture started
[13:37:52.691] - Launch lazy future ... done
[13:37:52.691] run() for ‘MultisessionFuture’ ... done
[13:37:53.194] receiveMessageFromWorker() for ClusterFuture ...
[13:37:53.194] - Validating connection of MultisessionFuture
[13:37:53.194] - received message: FutureResult
[13:37:53.194] - Received FutureResult
[13:37:53.194] - Erased future from FutureRegistry
[13:37:53.195] result() for ClusterFuture ...
[13:37:53.195] - result already collected: FutureResult
[13:37:53.195] result() for ClusterFuture ... done
[13:37:53.195] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:53.195] A MultisessionFuture was resolved (result was not collected)
[13:37:53.195] getGlobalsAndPackages() ...
[13:37:53.195] Searching for globals...
[13:37:53.196] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:37:53.196] Searching for globals ... DONE
[13:37:53.197] Resolving globals: FALSE
[13:37:53.197] 
[13:37:53.197] 
[13:37:53.197] getGlobalsAndPackages() ... DONE
[13:37:53.197] run() for ‘Future’ ...
[13:37:53.197] - state: ‘created’
[13:37:53.198] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:53.211] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:53.212] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:53.212]   - Field: ‘node’
[13:37:53.212]   - Field: ‘label’
[13:37:53.212]   - Field: ‘local’
[13:37:53.212]   - Field: ‘owner’
[13:37:53.212]   - Field: ‘envir’
[13:37:53.212]   - Field: ‘workers’
[13:37:53.212]   - Field: ‘packages’
[13:37:53.212]   - Field: ‘gc’
[13:37:53.212]   - Field: ‘conditions’
[13:37:53.213]   - Field: ‘persistent’
[13:37:53.213]   - Field: ‘expr’
[13:37:53.213]   - Field: ‘uuid’
[13:37:53.213]   - Field: ‘seed’
[13:37:53.213]   - Field: ‘version’
[13:37:53.213]   - Field: ‘result’
[13:37:53.213]   - Field: ‘asynchronous’
[13:37:53.213]   - Field: ‘calls’
[13:37:53.213]   - Field: ‘globals’
[13:37:53.213]   - Field: ‘stdout’
[13:37:53.213]   - Field: ‘earlySignal’
[13:37:53.214]   - Field: ‘lazy’
[13:37:53.214]   - Field: ‘state’
[13:37:53.214] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:53.214] - Launch lazy future ...
[13:37:53.214] Packages needed by the future expression (n = 0): <none>
[13:37:53.214] Packages needed by future strategies (n = 0): <none>
[13:37:53.215] {
[13:37:53.215]     {
[13:37:53.215]         {
[13:37:53.215]             ...future.startTime <- base::Sys.time()
[13:37:53.215]             {
[13:37:53.215]                 {
[13:37:53.215]                   {
[13:37:53.215]                     {
[13:37:53.215]                       base::local({
[13:37:53.215]                         has_future <- base::requireNamespace("future", 
[13:37:53.215]                           quietly = TRUE)
[13:37:53.215]                         if (has_future) {
[13:37:53.215]                           ns <- base::getNamespace("future")
[13:37:53.215]                           version <- ns[[".package"]][["version"]]
[13:37:53.215]                           if (is.null(version)) 
[13:37:53.215]                             version <- utils::packageVersion("future")
[13:37:53.215]                         }
[13:37:53.215]                         else {
[13:37:53.215]                           version <- NULL
[13:37:53.215]                         }
[13:37:53.215]                         if (!has_future || version < "1.8.0") {
[13:37:53.215]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:53.215]                             "", base::R.version$version.string), 
[13:37:53.215]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:53.215]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:53.215]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:53.215]                               "release", "version")], collapse = " "), 
[13:37:53.215]                             hostname = base::Sys.info()[["nodename"]])
[13:37:53.215]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:53.215]                             info)
[13:37:53.215]                           info <- base::paste(info, collapse = "; ")
[13:37:53.215]                           if (!has_future) {
[13:37:53.215]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:53.215]                               info)
[13:37:53.215]                           }
[13:37:53.215]                           else {
[13:37:53.215]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:53.215]                               info, version)
[13:37:53.215]                           }
[13:37:53.215]                           base::stop(msg)
[13:37:53.215]                         }
[13:37:53.215]                       })
[13:37:53.215]                     }
[13:37:53.215]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:53.215]                     base::options(mc.cores = 1L)
[13:37:53.215]                   }
[13:37:53.215]                   ...future.strategy.old <- future::plan("list")
[13:37:53.215]                   options(future.plan = NULL)
[13:37:53.215]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:53.215]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:53.215]                 }
[13:37:53.215]                 ...future.workdir <- getwd()
[13:37:53.215]             }
[13:37:53.215]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:53.215]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:53.215]         }
[13:37:53.215]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:53.215]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:53.215]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:53.215]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:53.215]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:53.215]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:53.215]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:53.215]             base::names(...future.oldOptions))
[13:37:53.215]     }
[13:37:53.215]     if (FALSE) {
[13:37:53.215]     }
[13:37:53.215]     else {
[13:37:53.215]         if (TRUE) {
[13:37:53.215]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:53.215]                 open = "w")
[13:37:53.215]         }
[13:37:53.215]         else {
[13:37:53.215]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:53.215]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:53.215]         }
[13:37:53.215]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:53.215]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:53.215]             base::sink(type = "output", split = FALSE)
[13:37:53.215]             base::close(...future.stdout)
[13:37:53.215]         }, add = TRUE)
[13:37:53.215]     }
[13:37:53.215]     ...future.frame <- base::sys.nframe()
[13:37:53.215]     ...future.conditions <- base::list()
[13:37:53.215]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:53.215]     if (FALSE) {
[13:37:53.215]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:53.215]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:53.215]     }
[13:37:53.215]     ...future.result <- base::tryCatch({
[13:37:53.215]         base::withCallingHandlers({
[13:37:53.215]             ...future.value <- base::withVisible(base::local({
[13:37:53.215]                 ...future.makeSendCondition <- base::local({
[13:37:53.215]                   sendCondition <- NULL
[13:37:53.215]                   function(frame = 1L) {
[13:37:53.215]                     if (is.function(sendCondition)) 
[13:37:53.215]                       return(sendCondition)
[13:37:53.215]                     ns <- getNamespace("parallel")
[13:37:53.215]                     if (exists("sendData", mode = "function", 
[13:37:53.215]                       envir = ns)) {
[13:37:53.215]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:53.215]                         envir = ns)
[13:37:53.215]                       envir <- sys.frame(frame)
[13:37:53.215]                       master <- NULL
[13:37:53.215]                       while (!identical(envir, .GlobalEnv) && 
[13:37:53.215]                         !identical(envir, emptyenv())) {
[13:37:53.215]                         if (exists("master", mode = "list", envir = envir, 
[13:37:53.215]                           inherits = FALSE)) {
[13:37:53.215]                           master <- get("master", mode = "list", 
[13:37:53.215]                             envir = envir, inherits = FALSE)
[13:37:53.215]                           if (inherits(master, c("SOCKnode", 
[13:37:53.215]                             "SOCK0node"))) {
[13:37:53.215]                             sendCondition <<- function(cond) {
[13:37:53.215]                               data <- list(type = "VALUE", value = cond, 
[13:37:53.215]                                 success = TRUE)
[13:37:53.215]                               parallel_sendData(master, data)
[13:37:53.215]                             }
[13:37:53.215]                             return(sendCondition)
[13:37:53.215]                           }
[13:37:53.215]                         }
[13:37:53.215]                         frame <- frame + 1L
[13:37:53.215]                         envir <- sys.frame(frame)
[13:37:53.215]                       }
[13:37:53.215]                     }
[13:37:53.215]                     sendCondition <<- function(cond) NULL
[13:37:53.215]                   }
[13:37:53.215]                 })
[13:37:53.215]                 withCallingHandlers({
[13:37:53.215]                   {
[13:37:53.215]                     Sys.sleep(0.5)
[13:37:53.215]                     list(a = 1, b = 42L)
[13:37:53.215]                   }
[13:37:53.215]                 }, immediateCondition = function(cond) {
[13:37:53.215]                   sendCondition <- ...future.makeSendCondition()
[13:37:53.215]                   sendCondition(cond)
[13:37:53.215]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:53.215]                   {
[13:37:53.215]                     inherits <- base::inherits
[13:37:53.215]                     invokeRestart <- base::invokeRestart
[13:37:53.215]                     is.null <- base::is.null
[13:37:53.215]                     muffled <- FALSE
[13:37:53.215]                     if (inherits(cond, "message")) {
[13:37:53.215]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:53.215]                       if (muffled) 
[13:37:53.215]                         invokeRestart("muffleMessage")
[13:37:53.215]                     }
[13:37:53.215]                     else if (inherits(cond, "warning")) {
[13:37:53.215]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:53.215]                       if (muffled) 
[13:37:53.215]                         invokeRestart("muffleWarning")
[13:37:53.215]                     }
[13:37:53.215]                     else if (inherits(cond, "condition")) {
[13:37:53.215]                       if (!is.null(pattern)) {
[13:37:53.215]                         computeRestarts <- base::computeRestarts
[13:37:53.215]                         grepl <- base::grepl
[13:37:53.215]                         restarts <- computeRestarts(cond)
[13:37:53.215]                         for (restart in restarts) {
[13:37:53.215]                           name <- restart$name
[13:37:53.215]                           if (is.null(name)) 
[13:37:53.215]                             next
[13:37:53.215]                           if (!grepl(pattern, name)) 
[13:37:53.215]                             next
[13:37:53.215]                           invokeRestart(restart)
[13:37:53.215]                           muffled <- TRUE
[13:37:53.215]                           break
[13:37:53.215]                         }
[13:37:53.215]                       }
[13:37:53.215]                     }
[13:37:53.215]                     invisible(muffled)
[13:37:53.215]                   }
[13:37:53.215]                   muffleCondition(cond)
[13:37:53.215]                 })
[13:37:53.215]             }))
[13:37:53.215]             future::FutureResult(value = ...future.value$value, 
[13:37:53.215]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:53.215]                   ...future.rng), globalenv = if (FALSE) 
[13:37:53.215]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:53.215]                     ...future.globalenv.names))
[13:37:53.215]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:53.215]         }, condition = base::local({
[13:37:53.215]             c <- base::c
[13:37:53.215]             inherits <- base::inherits
[13:37:53.215]             invokeRestart <- base::invokeRestart
[13:37:53.215]             length <- base::length
[13:37:53.215]             list <- base::list
[13:37:53.215]             seq.int <- base::seq.int
[13:37:53.215]             signalCondition <- base::signalCondition
[13:37:53.215]             sys.calls <- base::sys.calls
[13:37:53.215]             `[[` <- base::`[[`
[13:37:53.215]             `+` <- base::`+`
[13:37:53.215]             `<<-` <- base::`<<-`
[13:37:53.215]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:53.215]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:53.215]                   3L)]
[13:37:53.215]             }
[13:37:53.215]             function(cond) {
[13:37:53.215]                 is_error <- inherits(cond, "error")
[13:37:53.215]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:53.215]                   NULL)
[13:37:53.215]                 if (is_error) {
[13:37:53.215]                   sessionInformation <- function() {
[13:37:53.215]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:53.215]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:53.215]                       search = base::search(), system = base::Sys.info())
[13:37:53.215]                   }
[13:37:53.215]                   ...future.conditions[[length(...future.conditions) + 
[13:37:53.215]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:53.215]                     cond$call), session = sessionInformation(), 
[13:37:53.215]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:53.215]                   signalCondition(cond)
[13:37:53.215]                 }
[13:37:53.215]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:53.215]                 "immediateCondition"))) {
[13:37:53.215]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:53.215]                   ...future.conditions[[length(...future.conditions) + 
[13:37:53.215]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:53.215]                   if (TRUE && !signal) {
[13:37:53.215]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:53.215]                     {
[13:37:53.215]                       inherits <- base::inherits
[13:37:53.215]                       invokeRestart <- base::invokeRestart
[13:37:53.215]                       is.null <- base::is.null
[13:37:53.215]                       muffled <- FALSE
[13:37:53.215]                       if (inherits(cond, "message")) {
[13:37:53.215]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:53.215]                         if (muffled) 
[13:37:53.215]                           invokeRestart("muffleMessage")
[13:37:53.215]                       }
[13:37:53.215]                       else if (inherits(cond, "warning")) {
[13:37:53.215]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:53.215]                         if (muffled) 
[13:37:53.215]                           invokeRestart("muffleWarning")
[13:37:53.215]                       }
[13:37:53.215]                       else if (inherits(cond, "condition")) {
[13:37:53.215]                         if (!is.null(pattern)) {
[13:37:53.215]                           computeRestarts <- base::computeRestarts
[13:37:53.215]                           grepl <- base::grepl
[13:37:53.215]                           restarts <- computeRestarts(cond)
[13:37:53.215]                           for (restart in restarts) {
[13:37:53.215]                             name <- restart$name
[13:37:53.215]                             if (is.null(name)) 
[13:37:53.215]                               next
[13:37:53.215]                             if (!grepl(pattern, name)) 
[13:37:53.215]                               next
[13:37:53.215]                             invokeRestart(restart)
[13:37:53.215]                             muffled <- TRUE
[13:37:53.215]                             break
[13:37:53.215]                           }
[13:37:53.215]                         }
[13:37:53.215]                       }
[13:37:53.215]                       invisible(muffled)
[13:37:53.215]                     }
[13:37:53.215]                     muffleCondition(cond, pattern = "^muffle")
[13:37:53.215]                   }
[13:37:53.215]                 }
[13:37:53.215]                 else {
[13:37:53.215]                   if (TRUE) {
[13:37:53.215]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:53.215]                     {
[13:37:53.215]                       inherits <- base::inherits
[13:37:53.215]                       invokeRestart <- base::invokeRestart
[13:37:53.215]                       is.null <- base::is.null
[13:37:53.215]                       muffled <- FALSE
[13:37:53.215]                       if (inherits(cond, "message")) {
[13:37:53.215]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:53.215]                         if (muffled) 
[13:37:53.215]                           invokeRestart("muffleMessage")
[13:37:53.215]                       }
[13:37:53.215]                       else if (inherits(cond, "warning")) {
[13:37:53.215]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:53.215]                         if (muffled) 
[13:37:53.215]                           invokeRestart("muffleWarning")
[13:37:53.215]                       }
[13:37:53.215]                       else if (inherits(cond, "condition")) {
[13:37:53.215]                         if (!is.null(pattern)) {
[13:37:53.215]                           computeRestarts <- base::computeRestarts
[13:37:53.215]                           grepl <- base::grepl
[13:37:53.215]                           restarts <- computeRestarts(cond)
[13:37:53.215]                           for (restart in restarts) {
[13:37:53.215]                             name <- restart$name
[13:37:53.215]                             if (is.null(name)) 
[13:37:53.215]                               next
[13:37:53.215]                             if (!grepl(pattern, name)) 
[13:37:53.215]                               next
[13:37:53.215]                             invokeRestart(restart)
[13:37:53.215]                             muffled <- TRUE
[13:37:53.215]                             break
[13:37:53.215]                           }
[13:37:53.215]                         }
[13:37:53.215]                       }
[13:37:53.215]                       invisible(muffled)
[13:37:53.215]                     }
[13:37:53.215]                     muffleCondition(cond, pattern = "^muffle")
[13:37:53.215]                   }
[13:37:53.215]                 }
[13:37:53.215]             }
[13:37:53.215]         }))
[13:37:53.215]     }, error = function(ex) {
[13:37:53.215]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:53.215]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:53.215]                 ...future.rng), started = ...future.startTime, 
[13:37:53.215]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:53.215]             version = "1.8"), class = "FutureResult")
[13:37:53.215]     }, finally = {
[13:37:53.215]         if (!identical(...future.workdir, getwd())) 
[13:37:53.215]             setwd(...future.workdir)
[13:37:53.215]         {
[13:37:53.215]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:53.215]                 ...future.oldOptions$nwarnings <- NULL
[13:37:53.215]             }
[13:37:53.215]             base::options(...future.oldOptions)
[13:37:53.215]             if (.Platform$OS.type == "windows") {
[13:37:53.215]                 old_names <- names(...future.oldEnvVars)
[13:37:53.215]                 envs <- base::Sys.getenv()
[13:37:53.215]                 names <- names(envs)
[13:37:53.215]                 common <- intersect(names, old_names)
[13:37:53.215]                 added <- setdiff(names, old_names)
[13:37:53.215]                 removed <- setdiff(old_names, names)
[13:37:53.215]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:53.215]                   envs[common]]
[13:37:53.215]                 NAMES <- toupper(changed)
[13:37:53.215]                 args <- list()
[13:37:53.215]                 for (kk in seq_along(NAMES)) {
[13:37:53.215]                   name <- changed[[kk]]
[13:37:53.215]                   NAME <- NAMES[[kk]]
[13:37:53.215]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:53.215]                     next
[13:37:53.215]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:53.215]                 }
[13:37:53.215]                 NAMES <- toupper(added)
[13:37:53.215]                 for (kk in seq_along(NAMES)) {
[13:37:53.215]                   name <- added[[kk]]
[13:37:53.215]                   NAME <- NAMES[[kk]]
[13:37:53.215]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:53.215]                     next
[13:37:53.215]                   args[[name]] <- ""
[13:37:53.215]                 }
[13:37:53.215]                 NAMES <- toupper(removed)
[13:37:53.215]                 for (kk in seq_along(NAMES)) {
[13:37:53.215]                   name <- removed[[kk]]
[13:37:53.215]                   NAME <- NAMES[[kk]]
[13:37:53.215]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:53.215]                     next
[13:37:53.215]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:53.215]                 }
[13:37:53.215]                 if (length(args) > 0) 
[13:37:53.215]                   base::do.call(base::Sys.setenv, args = args)
[13:37:53.215]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:53.215]             }
[13:37:53.215]             else {
[13:37:53.215]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:53.215]             }
[13:37:53.215]             {
[13:37:53.215]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:53.215]                   0L) {
[13:37:53.215]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:53.215]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:53.215]                   base::options(opts)
[13:37:53.215]                 }
[13:37:53.215]                 {
[13:37:53.215]                   {
[13:37:53.215]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:53.215]                     NULL
[13:37:53.215]                   }
[13:37:53.215]                   options(future.plan = NULL)
[13:37:53.215]                   if (is.na(NA_character_)) 
[13:37:53.215]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:53.215]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:53.215]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:53.215]                     .init = FALSE)
[13:37:53.215]                 }
[13:37:53.215]             }
[13:37:53.215]         }
[13:37:53.215]     })
[13:37:53.215]     if (TRUE) {
[13:37:53.215]         base::sink(type = "output", split = FALSE)
[13:37:53.215]         if (TRUE) {
[13:37:53.215]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:53.215]         }
[13:37:53.215]         else {
[13:37:53.215]             ...future.result["stdout"] <- base::list(NULL)
[13:37:53.215]         }
[13:37:53.215]         base::close(...future.stdout)
[13:37:53.215]         ...future.stdout <- NULL
[13:37:53.215]     }
[13:37:53.215]     ...future.result$conditions <- ...future.conditions
[13:37:53.215]     ...future.result$finished <- base::Sys.time()
[13:37:53.215]     ...future.result
[13:37:53.215] }
[13:37:53.218] MultisessionFuture started
[13:37:53.218] - Launch lazy future ... done
[13:37:53.218] run() for ‘MultisessionFuture’ ... done
[13:37:53.721] receiveMessageFromWorker() for ClusterFuture ...
[13:37:53.721] - Validating connection of MultisessionFuture
[13:37:53.721] - received message: FutureResult
[13:37:53.721] - Received FutureResult
[13:37:53.721] - Erased future from FutureRegistry
[13:37:53.721] result() for ClusterFuture ...
[13:37:53.722] - result already collected: FutureResult
[13:37:53.722] result() for ClusterFuture ... done
[13:37:53.722] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:53.722] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[13:37:53.722] getGlobalsAndPackages() ...
[13:37:53.722] Searching for globals...
[13:37:53.723] - globals found: [2] ‘list’, ‘stop’
[13:37:53.723] Searching for globals ... DONE
[13:37:53.723] Resolving globals: FALSE
[13:37:53.723] 
[13:37:53.724] 
[13:37:53.724] getGlobalsAndPackages() ... DONE
[13:37:53.724] run() for ‘Future’ ...
[13:37:53.724] - state: ‘created’
[13:37:53.724] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:53.738] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:53.738] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:53.739]   - Field: ‘node’
[13:37:53.739]   - Field: ‘label’
[13:37:53.739]   - Field: ‘local’
[13:37:53.739]   - Field: ‘owner’
[13:37:53.739]   - Field: ‘envir’
[13:37:53.739]   - Field: ‘workers’
[13:37:53.739]   - Field: ‘packages’
[13:37:53.739]   - Field: ‘gc’
[13:37:53.739]   - Field: ‘conditions’
[13:37:53.739]   - Field: ‘persistent’
[13:37:53.739]   - Field: ‘expr’
[13:37:53.740]   - Field: ‘uuid’
[13:37:53.740]   - Field: ‘seed’
[13:37:53.740]   - Field: ‘version’
[13:37:53.740]   - Field: ‘result’
[13:37:53.740]   - Field: ‘asynchronous’
[13:37:53.740]   - Field: ‘calls’
[13:37:53.740]   - Field: ‘globals’
[13:37:53.740]   - Field: ‘stdout’
[13:37:53.740]   - Field: ‘earlySignal’
[13:37:53.740]   - Field: ‘lazy’
[13:37:53.740]   - Field: ‘state’
[13:37:53.741] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:53.741] - Launch lazy future ...
[13:37:53.741] Packages needed by the future expression (n = 0): <none>
[13:37:53.741] Packages needed by future strategies (n = 0): <none>
[13:37:53.741] {
[13:37:53.741]     {
[13:37:53.741]         {
[13:37:53.741]             ...future.startTime <- base::Sys.time()
[13:37:53.741]             {
[13:37:53.741]                 {
[13:37:53.741]                   {
[13:37:53.741]                     {
[13:37:53.741]                       base::local({
[13:37:53.741]                         has_future <- base::requireNamespace("future", 
[13:37:53.741]                           quietly = TRUE)
[13:37:53.741]                         if (has_future) {
[13:37:53.741]                           ns <- base::getNamespace("future")
[13:37:53.741]                           version <- ns[[".package"]][["version"]]
[13:37:53.741]                           if (is.null(version)) 
[13:37:53.741]                             version <- utils::packageVersion("future")
[13:37:53.741]                         }
[13:37:53.741]                         else {
[13:37:53.741]                           version <- NULL
[13:37:53.741]                         }
[13:37:53.741]                         if (!has_future || version < "1.8.0") {
[13:37:53.741]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:53.741]                             "", base::R.version$version.string), 
[13:37:53.741]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:53.741]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:53.741]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:53.741]                               "release", "version")], collapse = " "), 
[13:37:53.741]                             hostname = base::Sys.info()[["nodename"]])
[13:37:53.741]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:53.741]                             info)
[13:37:53.741]                           info <- base::paste(info, collapse = "; ")
[13:37:53.741]                           if (!has_future) {
[13:37:53.741]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:53.741]                               info)
[13:37:53.741]                           }
[13:37:53.741]                           else {
[13:37:53.741]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:53.741]                               info, version)
[13:37:53.741]                           }
[13:37:53.741]                           base::stop(msg)
[13:37:53.741]                         }
[13:37:53.741]                       })
[13:37:53.741]                     }
[13:37:53.741]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:53.741]                     base::options(mc.cores = 1L)
[13:37:53.741]                   }
[13:37:53.741]                   ...future.strategy.old <- future::plan("list")
[13:37:53.741]                   options(future.plan = NULL)
[13:37:53.741]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:53.741]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:53.741]                 }
[13:37:53.741]                 ...future.workdir <- getwd()
[13:37:53.741]             }
[13:37:53.741]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:53.741]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:53.741]         }
[13:37:53.741]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:53.741]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:53.741]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:53.741]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:53.741]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:53.741]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:53.741]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:53.741]             base::names(...future.oldOptions))
[13:37:53.741]     }
[13:37:53.741]     if (FALSE) {
[13:37:53.741]     }
[13:37:53.741]     else {
[13:37:53.741]         if (TRUE) {
[13:37:53.741]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:53.741]                 open = "w")
[13:37:53.741]         }
[13:37:53.741]         else {
[13:37:53.741]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:53.741]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:53.741]         }
[13:37:53.741]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:53.741]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:53.741]             base::sink(type = "output", split = FALSE)
[13:37:53.741]             base::close(...future.stdout)
[13:37:53.741]         }, add = TRUE)
[13:37:53.741]     }
[13:37:53.741]     ...future.frame <- base::sys.nframe()
[13:37:53.741]     ...future.conditions <- base::list()
[13:37:53.741]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:53.741]     if (FALSE) {
[13:37:53.741]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:53.741]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:53.741]     }
[13:37:53.741]     ...future.result <- base::tryCatch({
[13:37:53.741]         base::withCallingHandlers({
[13:37:53.741]             ...future.value <- base::withVisible(base::local({
[13:37:53.741]                 ...future.makeSendCondition <- base::local({
[13:37:53.741]                   sendCondition <- NULL
[13:37:53.741]                   function(frame = 1L) {
[13:37:53.741]                     if (is.function(sendCondition)) 
[13:37:53.741]                       return(sendCondition)
[13:37:53.741]                     ns <- getNamespace("parallel")
[13:37:53.741]                     if (exists("sendData", mode = "function", 
[13:37:53.741]                       envir = ns)) {
[13:37:53.741]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:53.741]                         envir = ns)
[13:37:53.741]                       envir <- sys.frame(frame)
[13:37:53.741]                       master <- NULL
[13:37:53.741]                       while (!identical(envir, .GlobalEnv) && 
[13:37:53.741]                         !identical(envir, emptyenv())) {
[13:37:53.741]                         if (exists("master", mode = "list", envir = envir, 
[13:37:53.741]                           inherits = FALSE)) {
[13:37:53.741]                           master <- get("master", mode = "list", 
[13:37:53.741]                             envir = envir, inherits = FALSE)
[13:37:53.741]                           if (inherits(master, c("SOCKnode", 
[13:37:53.741]                             "SOCK0node"))) {
[13:37:53.741]                             sendCondition <<- function(cond) {
[13:37:53.741]                               data <- list(type = "VALUE", value = cond, 
[13:37:53.741]                                 success = TRUE)
[13:37:53.741]                               parallel_sendData(master, data)
[13:37:53.741]                             }
[13:37:53.741]                             return(sendCondition)
[13:37:53.741]                           }
[13:37:53.741]                         }
[13:37:53.741]                         frame <- frame + 1L
[13:37:53.741]                         envir <- sys.frame(frame)
[13:37:53.741]                       }
[13:37:53.741]                     }
[13:37:53.741]                     sendCondition <<- function(cond) NULL
[13:37:53.741]                   }
[13:37:53.741]                 })
[13:37:53.741]                 withCallingHandlers({
[13:37:53.741]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:37:53.741]                 }, immediateCondition = function(cond) {
[13:37:53.741]                   sendCondition <- ...future.makeSendCondition()
[13:37:53.741]                   sendCondition(cond)
[13:37:53.741]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:53.741]                   {
[13:37:53.741]                     inherits <- base::inherits
[13:37:53.741]                     invokeRestart <- base::invokeRestart
[13:37:53.741]                     is.null <- base::is.null
[13:37:53.741]                     muffled <- FALSE
[13:37:53.741]                     if (inherits(cond, "message")) {
[13:37:53.741]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:53.741]                       if (muffled) 
[13:37:53.741]                         invokeRestart("muffleMessage")
[13:37:53.741]                     }
[13:37:53.741]                     else if (inherits(cond, "warning")) {
[13:37:53.741]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:53.741]                       if (muffled) 
[13:37:53.741]                         invokeRestart("muffleWarning")
[13:37:53.741]                     }
[13:37:53.741]                     else if (inherits(cond, "condition")) {
[13:37:53.741]                       if (!is.null(pattern)) {
[13:37:53.741]                         computeRestarts <- base::computeRestarts
[13:37:53.741]                         grepl <- base::grepl
[13:37:53.741]                         restarts <- computeRestarts(cond)
[13:37:53.741]                         for (restart in restarts) {
[13:37:53.741]                           name <- restart$name
[13:37:53.741]                           if (is.null(name)) 
[13:37:53.741]                             next
[13:37:53.741]                           if (!grepl(pattern, name)) 
[13:37:53.741]                             next
[13:37:53.741]                           invokeRestart(restart)
[13:37:53.741]                           muffled <- TRUE
[13:37:53.741]                           break
[13:37:53.741]                         }
[13:37:53.741]                       }
[13:37:53.741]                     }
[13:37:53.741]                     invisible(muffled)
[13:37:53.741]                   }
[13:37:53.741]                   muffleCondition(cond)
[13:37:53.741]                 })
[13:37:53.741]             }))
[13:37:53.741]             future::FutureResult(value = ...future.value$value, 
[13:37:53.741]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:53.741]                   ...future.rng), globalenv = if (FALSE) 
[13:37:53.741]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:53.741]                     ...future.globalenv.names))
[13:37:53.741]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:53.741]         }, condition = base::local({
[13:37:53.741]             c <- base::c
[13:37:53.741]             inherits <- base::inherits
[13:37:53.741]             invokeRestart <- base::invokeRestart
[13:37:53.741]             length <- base::length
[13:37:53.741]             list <- base::list
[13:37:53.741]             seq.int <- base::seq.int
[13:37:53.741]             signalCondition <- base::signalCondition
[13:37:53.741]             sys.calls <- base::sys.calls
[13:37:53.741]             `[[` <- base::`[[`
[13:37:53.741]             `+` <- base::`+`
[13:37:53.741]             `<<-` <- base::`<<-`
[13:37:53.741]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:53.741]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:53.741]                   3L)]
[13:37:53.741]             }
[13:37:53.741]             function(cond) {
[13:37:53.741]                 is_error <- inherits(cond, "error")
[13:37:53.741]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:53.741]                   NULL)
[13:37:53.741]                 if (is_error) {
[13:37:53.741]                   sessionInformation <- function() {
[13:37:53.741]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:53.741]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:53.741]                       search = base::search(), system = base::Sys.info())
[13:37:53.741]                   }
[13:37:53.741]                   ...future.conditions[[length(...future.conditions) + 
[13:37:53.741]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:53.741]                     cond$call), session = sessionInformation(), 
[13:37:53.741]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:53.741]                   signalCondition(cond)
[13:37:53.741]                 }
[13:37:53.741]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:53.741]                 "immediateCondition"))) {
[13:37:53.741]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:53.741]                   ...future.conditions[[length(...future.conditions) + 
[13:37:53.741]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:53.741]                   if (TRUE && !signal) {
[13:37:53.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:53.741]                     {
[13:37:53.741]                       inherits <- base::inherits
[13:37:53.741]                       invokeRestart <- base::invokeRestart
[13:37:53.741]                       is.null <- base::is.null
[13:37:53.741]                       muffled <- FALSE
[13:37:53.741]                       if (inherits(cond, "message")) {
[13:37:53.741]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:53.741]                         if (muffled) 
[13:37:53.741]                           invokeRestart("muffleMessage")
[13:37:53.741]                       }
[13:37:53.741]                       else if (inherits(cond, "warning")) {
[13:37:53.741]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:53.741]                         if (muffled) 
[13:37:53.741]                           invokeRestart("muffleWarning")
[13:37:53.741]                       }
[13:37:53.741]                       else if (inherits(cond, "condition")) {
[13:37:53.741]                         if (!is.null(pattern)) {
[13:37:53.741]                           computeRestarts <- base::computeRestarts
[13:37:53.741]                           grepl <- base::grepl
[13:37:53.741]                           restarts <- computeRestarts(cond)
[13:37:53.741]                           for (restart in restarts) {
[13:37:53.741]                             name <- restart$name
[13:37:53.741]                             if (is.null(name)) 
[13:37:53.741]                               next
[13:37:53.741]                             if (!grepl(pattern, name)) 
[13:37:53.741]                               next
[13:37:53.741]                             invokeRestart(restart)
[13:37:53.741]                             muffled <- TRUE
[13:37:53.741]                             break
[13:37:53.741]                           }
[13:37:53.741]                         }
[13:37:53.741]                       }
[13:37:53.741]                       invisible(muffled)
[13:37:53.741]                     }
[13:37:53.741]                     muffleCondition(cond, pattern = "^muffle")
[13:37:53.741]                   }
[13:37:53.741]                 }
[13:37:53.741]                 else {
[13:37:53.741]                   if (TRUE) {
[13:37:53.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:53.741]                     {
[13:37:53.741]                       inherits <- base::inherits
[13:37:53.741]                       invokeRestart <- base::invokeRestart
[13:37:53.741]                       is.null <- base::is.null
[13:37:53.741]                       muffled <- FALSE
[13:37:53.741]                       if (inherits(cond, "message")) {
[13:37:53.741]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:53.741]                         if (muffled) 
[13:37:53.741]                           invokeRestart("muffleMessage")
[13:37:53.741]                       }
[13:37:53.741]                       else if (inherits(cond, "warning")) {
[13:37:53.741]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:53.741]                         if (muffled) 
[13:37:53.741]                           invokeRestart("muffleWarning")
[13:37:53.741]                       }
[13:37:53.741]                       else if (inherits(cond, "condition")) {
[13:37:53.741]                         if (!is.null(pattern)) {
[13:37:53.741]                           computeRestarts <- base::computeRestarts
[13:37:53.741]                           grepl <- base::grepl
[13:37:53.741]                           restarts <- computeRestarts(cond)
[13:37:53.741]                           for (restart in restarts) {
[13:37:53.741]                             name <- restart$name
[13:37:53.741]                             if (is.null(name)) 
[13:37:53.741]                               next
[13:37:53.741]                             if (!grepl(pattern, name)) 
[13:37:53.741]                               next
[13:37:53.741]                             invokeRestart(restart)
[13:37:53.741]                             muffled <- TRUE
[13:37:53.741]                             break
[13:37:53.741]                           }
[13:37:53.741]                         }
[13:37:53.741]                       }
[13:37:53.741]                       invisible(muffled)
[13:37:53.741]                     }
[13:37:53.741]                     muffleCondition(cond, pattern = "^muffle")
[13:37:53.741]                   }
[13:37:53.741]                 }
[13:37:53.741]             }
[13:37:53.741]         }))
[13:37:53.741]     }, error = function(ex) {
[13:37:53.741]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:53.741]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:53.741]                 ...future.rng), started = ...future.startTime, 
[13:37:53.741]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:53.741]             version = "1.8"), class = "FutureResult")
[13:37:53.741]     }, finally = {
[13:37:53.741]         if (!identical(...future.workdir, getwd())) 
[13:37:53.741]             setwd(...future.workdir)
[13:37:53.741]         {
[13:37:53.741]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:53.741]                 ...future.oldOptions$nwarnings <- NULL
[13:37:53.741]             }
[13:37:53.741]             base::options(...future.oldOptions)
[13:37:53.741]             if (.Platform$OS.type == "windows") {
[13:37:53.741]                 old_names <- names(...future.oldEnvVars)
[13:37:53.741]                 envs <- base::Sys.getenv()
[13:37:53.741]                 names <- names(envs)
[13:37:53.741]                 common <- intersect(names, old_names)
[13:37:53.741]                 added <- setdiff(names, old_names)
[13:37:53.741]                 removed <- setdiff(old_names, names)
[13:37:53.741]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:53.741]                   envs[common]]
[13:37:53.741]                 NAMES <- toupper(changed)
[13:37:53.741]                 args <- list()
[13:37:53.741]                 for (kk in seq_along(NAMES)) {
[13:37:53.741]                   name <- changed[[kk]]
[13:37:53.741]                   NAME <- NAMES[[kk]]
[13:37:53.741]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:53.741]                     next
[13:37:53.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:53.741]                 }
[13:37:53.741]                 NAMES <- toupper(added)
[13:37:53.741]                 for (kk in seq_along(NAMES)) {
[13:37:53.741]                   name <- added[[kk]]
[13:37:53.741]                   NAME <- NAMES[[kk]]
[13:37:53.741]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:53.741]                     next
[13:37:53.741]                   args[[name]] <- ""
[13:37:53.741]                 }
[13:37:53.741]                 NAMES <- toupper(removed)
[13:37:53.741]                 for (kk in seq_along(NAMES)) {
[13:37:53.741]                   name <- removed[[kk]]
[13:37:53.741]                   NAME <- NAMES[[kk]]
[13:37:53.741]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:53.741]                     next
[13:37:53.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:53.741]                 }
[13:37:53.741]                 if (length(args) > 0) 
[13:37:53.741]                   base::do.call(base::Sys.setenv, args = args)
[13:37:53.741]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:53.741]             }
[13:37:53.741]             else {
[13:37:53.741]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:53.741]             }
[13:37:53.741]             {
[13:37:53.741]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:53.741]                   0L) {
[13:37:53.741]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:53.741]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:53.741]                   base::options(opts)
[13:37:53.741]                 }
[13:37:53.741]                 {
[13:37:53.741]                   {
[13:37:53.741]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:53.741]                     NULL
[13:37:53.741]                   }
[13:37:53.741]                   options(future.plan = NULL)
[13:37:53.741]                   if (is.na(NA_character_)) 
[13:37:53.741]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:53.741]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:53.741]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:53.741]                     .init = FALSE)
[13:37:53.741]                 }
[13:37:53.741]             }
[13:37:53.741]         }
[13:37:53.741]     })
[13:37:53.741]     if (TRUE) {
[13:37:53.741]         base::sink(type = "output", split = FALSE)
[13:37:53.741]         if (TRUE) {
[13:37:53.741]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:53.741]         }
[13:37:53.741]         else {
[13:37:53.741]             ...future.result["stdout"] <- base::list(NULL)
[13:37:53.741]         }
[13:37:53.741]         base::close(...future.stdout)
[13:37:53.741]         ...future.stdout <- NULL
[13:37:53.741]     }
[13:37:53.741]     ...future.result$conditions <- ...future.conditions
[13:37:53.741]     ...future.result$finished <- base::Sys.time()
[13:37:53.741]     ...future.result
[13:37:53.741] }
[13:37:53.744] MultisessionFuture started
[13:37:53.744] - Launch lazy future ... done
[13:37:53.745] run() for ‘MultisessionFuture’ ... done
[13:37:53.746] receiveMessageFromWorker() for ClusterFuture ...
[13:37:53.746] - Validating connection of MultisessionFuture
[13:37:53.747] - received message: FutureResult
[13:37:53.747] - Received FutureResult
[13:37:53.747] - Erased future from FutureRegistry
[13:37:53.747] result() for ClusterFuture ...
[13:37:53.747] - result already collected: FutureResult
[13:37:53.747] result() for ClusterFuture ... done
[13:37:53.747] signalConditions() ...
[13:37:53.747]  - include = ‘immediateCondition’
[13:37:53.748]  - exclude = 
[13:37:53.748]  - resignal = FALSE
[13:37:53.748]  - Number of conditions: 1
[13:37:53.748] signalConditions() ... done
[13:37:53.748] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:53.748] A MultisessionFuture was resolved (result was not collected)
[13:37:53.748] getGlobalsAndPackages() ...
[13:37:53.748] Searching for globals...
[13:37:53.749] - globals found: [2] ‘list’, ‘stop’
[13:37:53.749] Searching for globals ... DONE
[13:37:53.749] Resolving globals: FALSE
[13:37:53.749] 
[13:37:53.749] 
[13:37:53.750] getGlobalsAndPackages() ... DONE
[13:37:53.750] run() for ‘Future’ ...
[13:37:53.750] - state: ‘created’
[13:37:53.750] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:53.763] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:53.764] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:53.764]   - Field: ‘node’
[13:37:53.764]   - Field: ‘label’
[13:37:53.764]   - Field: ‘local’
[13:37:53.764]   - Field: ‘owner’
[13:37:53.764]   - Field: ‘envir’
[13:37:53.764]   - Field: ‘workers’
[13:37:53.764]   - Field: ‘packages’
[13:37:53.764]   - Field: ‘gc’
[13:37:53.764]   - Field: ‘conditions’
[13:37:53.765]   - Field: ‘persistent’
[13:37:53.765]   - Field: ‘expr’
[13:37:53.765]   - Field: ‘uuid’
[13:37:53.765]   - Field: ‘seed’
[13:37:53.765]   - Field: ‘version’
[13:37:53.765]   - Field: ‘result’
[13:37:53.765]   - Field: ‘asynchronous’
[13:37:53.765]   - Field: ‘calls’
[13:37:53.765]   - Field: ‘globals’
[13:37:53.765]   - Field: ‘stdout’
[13:37:53.765]   - Field: ‘earlySignal’
[13:37:53.766]   - Field: ‘lazy’
[13:37:53.766]   - Field: ‘state’
[13:37:53.766] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:53.766] - Launch lazy future ...
[13:37:53.766] Packages needed by the future expression (n = 0): <none>
[13:37:53.766] Packages needed by future strategies (n = 0): <none>
[13:37:53.767] {
[13:37:53.767]     {
[13:37:53.767]         {
[13:37:53.767]             ...future.startTime <- base::Sys.time()
[13:37:53.767]             {
[13:37:53.767]                 {
[13:37:53.767]                   {
[13:37:53.767]                     {
[13:37:53.767]                       base::local({
[13:37:53.767]                         has_future <- base::requireNamespace("future", 
[13:37:53.767]                           quietly = TRUE)
[13:37:53.767]                         if (has_future) {
[13:37:53.767]                           ns <- base::getNamespace("future")
[13:37:53.767]                           version <- ns[[".package"]][["version"]]
[13:37:53.767]                           if (is.null(version)) 
[13:37:53.767]                             version <- utils::packageVersion("future")
[13:37:53.767]                         }
[13:37:53.767]                         else {
[13:37:53.767]                           version <- NULL
[13:37:53.767]                         }
[13:37:53.767]                         if (!has_future || version < "1.8.0") {
[13:37:53.767]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:53.767]                             "", base::R.version$version.string), 
[13:37:53.767]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:53.767]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:53.767]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:53.767]                               "release", "version")], collapse = " "), 
[13:37:53.767]                             hostname = base::Sys.info()[["nodename"]])
[13:37:53.767]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:53.767]                             info)
[13:37:53.767]                           info <- base::paste(info, collapse = "; ")
[13:37:53.767]                           if (!has_future) {
[13:37:53.767]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:53.767]                               info)
[13:37:53.767]                           }
[13:37:53.767]                           else {
[13:37:53.767]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:53.767]                               info, version)
[13:37:53.767]                           }
[13:37:53.767]                           base::stop(msg)
[13:37:53.767]                         }
[13:37:53.767]                       })
[13:37:53.767]                     }
[13:37:53.767]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:53.767]                     base::options(mc.cores = 1L)
[13:37:53.767]                   }
[13:37:53.767]                   ...future.strategy.old <- future::plan("list")
[13:37:53.767]                   options(future.plan = NULL)
[13:37:53.767]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:53.767]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:53.767]                 }
[13:37:53.767]                 ...future.workdir <- getwd()
[13:37:53.767]             }
[13:37:53.767]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:53.767]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:53.767]         }
[13:37:53.767]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:53.767]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:53.767]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:53.767]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:53.767]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:53.767]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:53.767]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:53.767]             base::names(...future.oldOptions))
[13:37:53.767]     }
[13:37:53.767]     if (FALSE) {
[13:37:53.767]     }
[13:37:53.767]     else {
[13:37:53.767]         if (TRUE) {
[13:37:53.767]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:53.767]                 open = "w")
[13:37:53.767]         }
[13:37:53.767]         else {
[13:37:53.767]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:53.767]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:53.767]         }
[13:37:53.767]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:53.767]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:53.767]             base::sink(type = "output", split = FALSE)
[13:37:53.767]             base::close(...future.stdout)
[13:37:53.767]         }, add = TRUE)
[13:37:53.767]     }
[13:37:53.767]     ...future.frame <- base::sys.nframe()
[13:37:53.767]     ...future.conditions <- base::list()
[13:37:53.767]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:53.767]     if (FALSE) {
[13:37:53.767]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:53.767]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:53.767]     }
[13:37:53.767]     ...future.result <- base::tryCatch({
[13:37:53.767]         base::withCallingHandlers({
[13:37:53.767]             ...future.value <- base::withVisible(base::local({
[13:37:53.767]                 ...future.makeSendCondition <- base::local({
[13:37:53.767]                   sendCondition <- NULL
[13:37:53.767]                   function(frame = 1L) {
[13:37:53.767]                     if (is.function(sendCondition)) 
[13:37:53.767]                       return(sendCondition)
[13:37:53.767]                     ns <- getNamespace("parallel")
[13:37:53.767]                     if (exists("sendData", mode = "function", 
[13:37:53.767]                       envir = ns)) {
[13:37:53.767]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:53.767]                         envir = ns)
[13:37:53.767]                       envir <- sys.frame(frame)
[13:37:53.767]                       master <- NULL
[13:37:53.767]                       while (!identical(envir, .GlobalEnv) && 
[13:37:53.767]                         !identical(envir, emptyenv())) {
[13:37:53.767]                         if (exists("master", mode = "list", envir = envir, 
[13:37:53.767]                           inherits = FALSE)) {
[13:37:53.767]                           master <- get("master", mode = "list", 
[13:37:53.767]                             envir = envir, inherits = FALSE)
[13:37:53.767]                           if (inherits(master, c("SOCKnode", 
[13:37:53.767]                             "SOCK0node"))) {
[13:37:53.767]                             sendCondition <<- function(cond) {
[13:37:53.767]                               data <- list(type = "VALUE", value = cond, 
[13:37:53.767]                                 success = TRUE)
[13:37:53.767]                               parallel_sendData(master, data)
[13:37:53.767]                             }
[13:37:53.767]                             return(sendCondition)
[13:37:53.767]                           }
[13:37:53.767]                         }
[13:37:53.767]                         frame <- frame + 1L
[13:37:53.767]                         envir <- sys.frame(frame)
[13:37:53.767]                       }
[13:37:53.767]                     }
[13:37:53.767]                     sendCondition <<- function(cond) NULL
[13:37:53.767]                   }
[13:37:53.767]                 })
[13:37:53.767]                 withCallingHandlers({
[13:37:53.767]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:37:53.767]                 }, immediateCondition = function(cond) {
[13:37:53.767]                   sendCondition <- ...future.makeSendCondition()
[13:37:53.767]                   sendCondition(cond)
[13:37:53.767]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:53.767]                   {
[13:37:53.767]                     inherits <- base::inherits
[13:37:53.767]                     invokeRestart <- base::invokeRestart
[13:37:53.767]                     is.null <- base::is.null
[13:37:53.767]                     muffled <- FALSE
[13:37:53.767]                     if (inherits(cond, "message")) {
[13:37:53.767]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:53.767]                       if (muffled) 
[13:37:53.767]                         invokeRestart("muffleMessage")
[13:37:53.767]                     }
[13:37:53.767]                     else if (inherits(cond, "warning")) {
[13:37:53.767]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:53.767]                       if (muffled) 
[13:37:53.767]                         invokeRestart("muffleWarning")
[13:37:53.767]                     }
[13:37:53.767]                     else if (inherits(cond, "condition")) {
[13:37:53.767]                       if (!is.null(pattern)) {
[13:37:53.767]                         computeRestarts <- base::computeRestarts
[13:37:53.767]                         grepl <- base::grepl
[13:37:53.767]                         restarts <- computeRestarts(cond)
[13:37:53.767]                         for (restart in restarts) {
[13:37:53.767]                           name <- restart$name
[13:37:53.767]                           if (is.null(name)) 
[13:37:53.767]                             next
[13:37:53.767]                           if (!grepl(pattern, name)) 
[13:37:53.767]                             next
[13:37:53.767]                           invokeRestart(restart)
[13:37:53.767]                           muffled <- TRUE
[13:37:53.767]                           break
[13:37:53.767]                         }
[13:37:53.767]                       }
[13:37:53.767]                     }
[13:37:53.767]                     invisible(muffled)
[13:37:53.767]                   }
[13:37:53.767]                   muffleCondition(cond)
[13:37:53.767]                 })
[13:37:53.767]             }))
[13:37:53.767]             future::FutureResult(value = ...future.value$value, 
[13:37:53.767]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:53.767]                   ...future.rng), globalenv = if (FALSE) 
[13:37:53.767]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:53.767]                     ...future.globalenv.names))
[13:37:53.767]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:53.767]         }, condition = base::local({
[13:37:53.767]             c <- base::c
[13:37:53.767]             inherits <- base::inherits
[13:37:53.767]             invokeRestart <- base::invokeRestart
[13:37:53.767]             length <- base::length
[13:37:53.767]             list <- base::list
[13:37:53.767]             seq.int <- base::seq.int
[13:37:53.767]             signalCondition <- base::signalCondition
[13:37:53.767]             sys.calls <- base::sys.calls
[13:37:53.767]             `[[` <- base::`[[`
[13:37:53.767]             `+` <- base::`+`
[13:37:53.767]             `<<-` <- base::`<<-`
[13:37:53.767]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:53.767]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:53.767]                   3L)]
[13:37:53.767]             }
[13:37:53.767]             function(cond) {
[13:37:53.767]                 is_error <- inherits(cond, "error")
[13:37:53.767]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:53.767]                   NULL)
[13:37:53.767]                 if (is_error) {
[13:37:53.767]                   sessionInformation <- function() {
[13:37:53.767]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:53.767]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:53.767]                       search = base::search(), system = base::Sys.info())
[13:37:53.767]                   }
[13:37:53.767]                   ...future.conditions[[length(...future.conditions) + 
[13:37:53.767]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:53.767]                     cond$call), session = sessionInformation(), 
[13:37:53.767]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:53.767]                   signalCondition(cond)
[13:37:53.767]                 }
[13:37:53.767]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:53.767]                 "immediateCondition"))) {
[13:37:53.767]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:53.767]                   ...future.conditions[[length(...future.conditions) + 
[13:37:53.767]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:53.767]                   if (TRUE && !signal) {
[13:37:53.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:53.767]                     {
[13:37:53.767]                       inherits <- base::inherits
[13:37:53.767]                       invokeRestart <- base::invokeRestart
[13:37:53.767]                       is.null <- base::is.null
[13:37:53.767]                       muffled <- FALSE
[13:37:53.767]                       if (inherits(cond, "message")) {
[13:37:53.767]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:53.767]                         if (muffled) 
[13:37:53.767]                           invokeRestart("muffleMessage")
[13:37:53.767]                       }
[13:37:53.767]                       else if (inherits(cond, "warning")) {
[13:37:53.767]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:53.767]                         if (muffled) 
[13:37:53.767]                           invokeRestart("muffleWarning")
[13:37:53.767]                       }
[13:37:53.767]                       else if (inherits(cond, "condition")) {
[13:37:53.767]                         if (!is.null(pattern)) {
[13:37:53.767]                           computeRestarts <- base::computeRestarts
[13:37:53.767]                           grepl <- base::grepl
[13:37:53.767]                           restarts <- computeRestarts(cond)
[13:37:53.767]                           for (restart in restarts) {
[13:37:53.767]                             name <- restart$name
[13:37:53.767]                             if (is.null(name)) 
[13:37:53.767]                               next
[13:37:53.767]                             if (!grepl(pattern, name)) 
[13:37:53.767]                               next
[13:37:53.767]                             invokeRestart(restart)
[13:37:53.767]                             muffled <- TRUE
[13:37:53.767]                             break
[13:37:53.767]                           }
[13:37:53.767]                         }
[13:37:53.767]                       }
[13:37:53.767]                       invisible(muffled)
[13:37:53.767]                     }
[13:37:53.767]                     muffleCondition(cond, pattern = "^muffle")
[13:37:53.767]                   }
[13:37:53.767]                 }
[13:37:53.767]                 else {
[13:37:53.767]                   if (TRUE) {
[13:37:53.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:53.767]                     {
[13:37:53.767]                       inherits <- base::inherits
[13:37:53.767]                       invokeRestart <- base::invokeRestart
[13:37:53.767]                       is.null <- base::is.null
[13:37:53.767]                       muffled <- FALSE
[13:37:53.767]                       if (inherits(cond, "message")) {
[13:37:53.767]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:53.767]                         if (muffled) 
[13:37:53.767]                           invokeRestart("muffleMessage")
[13:37:53.767]                       }
[13:37:53.767]                       else if (inherits(cond, "warning")) {
[13:37:53.767]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:53.767]                         if (muffled) 
[13:37:53.767]                           invokeRestart("muffleWarning")
[13:37:53.767]                       }
[13:37:53.767]                       else if (inherits(cond, "condition")) {
[13:37:53.767]                         if (!is.null(pattern)) {
[13:37:53.767]                           computeRestarts <- base::computeRestarts
[13:37:53.767]                           grepl <- base::grepl
[13:37:53.767]                           restarts <- computeRestarts(cond)
[13:37:53.767]                           for (restart in restarts) {
[13:37:53.767]                             name <- restart$name
[13:37:53.767]                             if (is.null(name)) 
[13:37:53.767]                               next
[13:37:53.767]                             if (!grepl(pattern, name)) 
[13:37:53.767]                               next
[13:37:53.767]                             invokeRestart(restart)
[13:37:53.767]                             muffled <- TRUE
[13:37:53.767]                             break
[13:37:53.767]                           }
[13:37:53.767]                         }
[13:37:53.767]                       }
[13:37:53.767]                       invisible(muffled)
[13:37:53.767]                     }
[13:37:53.767]                     muffleCondition(cond, pattern = "^muffle")
[13:37:53.767]                   }
[13:37:53.767]                 }
[13:37:53.767]             }
[13:37:53.767]         }))
[13:37:53.767]     }, error = function(ex) {
[13:37:53.767]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:53.767]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:53.767]                 ...future.rng), started = ...future.startTime, 
[13:37:53.767]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:53.767]             version = "1.8"), class = "FutureResult")
[13:37:53.767]     }, finally = {
[13:37:53.767]         if (!identical(...future.workdir, getwd())) 
[13:37:53.767]             setwd(...future.workdir)
[13:37:53.767]         {
[13:37:53.767]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:53.767]                 ...future.oldOptions$nwarnings <- NULL
[13:37:53.767]             }
[13:37:53.767]             base::options(...future.oldOptions)
[13:37:53.767]             if (.Platform$OS.type == "windows") {
[13:37:53.767]                 old_names <- names(...future.oldEnvVars)
[13:37:53.767]                 envs <- base::Sys.getenv()
[13:37:53.767]                 names <- names(envs)
[13:37:53.767]                 common <- intersect(names, old_names)
[13:37:53.767]                 added <- setdiff(names, old_names)
[13:37:53.767]                 removed <- setdiff(old_names, names)
[13:37:53.767]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:53.767]                   envs[common]]
[13:37:53.767]                 NAMES <- toupper(changed)
[13:37:53.767]                 args <- list()
[13:37:53.767]                 for (kk in seq_along(NAMES)) {
[13:37:53.767]                   name <- changed[[kk]]
[13:37:53.767]                   NAME <- NAMES[[kk]]
[13:37:53.767]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:53.767]                     next
[13:37:53.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:53.767]                 }
[13:37:53.767]                 NAMES <- toupper(added)
[13:37:53.767]                 for (kk in seq_along(NAMES)) {
[13:37:53.767]                   name <- added[[kk]]
[13:37:53.767]                   NAME <- NAMES[[kk]]
[13:37:53.767]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:53.767]                     next
[13:37:53.767]                   args[[name]] <- ""
[13:37:53.767]                 }
[13:37:53.767]                 NAMES <- toupper(removed)
[13:37:53.767]                 for (kk in seq_along(NAMES)) {
[13:37:53.767]                   name <- removed[[kk]]
[13:37:53.767]                   NAME <- NAMES[[kk]]
[13:37:53.767]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:53.767]                     next
[13:37:53.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:53.767]                 }
[13:37:53.767]                 if (length(args) > 0) 
[13:37:53.767]                   base::do.call(base::Sys.setenv, args = args)
[13:37:53.767]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:53.767]             }
[13:37:53.767]             else {
[13:37:53.767]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:53.767]             }
[13:37:53.767]             {
[13:37:53.767]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:53.767]                   0L) {
[13:37:53.767]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:53.767]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:53.767]                   base::options(opts)
[13:37:53.767]                 }
[13:37:53.767]                 {
[13:37:53.767]                   {
[13:37:53.767]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:53.767]                     NULL
[13:37:53.767]                   }
[13:37:53.767]                   options(future.plan = NULL)
[13:37:53.767]                   if (is.na(NA_character_)) 
[13:37:53.767]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:53.767]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:53.767]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:53.767]                     .init = FALSE)
[13:37:53.767]                 }
[13:37:53.767]             }
[13:37:53.767]         }
[13:37:53.767]     })
[13:37:53.767]     if (TRUE) {
[13:37:53.767]         base::sink(type = "output", split = FALSE)
[13:37:53.767]         if (TRUE) {
[13:37:53.767]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:53.767]         }
[13:37:53.767]         else {
[13:37:53.767]             ...future.result["stdout"] <- base::list(NULL)
[13:37:53.767]         }
[13:37:53.767]         base::close(...future.stdout)
[13:37:53.767]         ...future.stdout <- NULL
[13:37:53.767]     }
[13:37:53.767]     ...future.result$conditions <- ...future.conditions
[13:37:53.767]     ...future.result$finished <- base::Sys.time()
[13:37:53.767]     ...future.result
[13:37:53.767] }
[13:37:53.769] MultisessionFuture started
[13:37:53.770] - Launch lazy future ... done
[13:37:53.770] run() for ‘MultisessionFuture’ ... done
[13:37:53.771] receiveMessageFromWorker() for ClusterFuture ...
[13:37:53.771] - Validating connection of MultisessionFuture
[13:37:53.772] - received message: FutureResult
[13:37:53.772] - Received FutureResult
[13:37:53.772] - Erased future from FutureRegistry
[13:37:53.772] result() for ClusterFuture ...
[13:37:53.772] - result already collected: FutureResult
[13:37:53.772] result() for ClusterFuture ... done
[13:37:53.773] signalConditions() ...
[13:37:53.773]  - include = ‘immediateCondition’
[13:37:53.773]  - exclude = 
[13:37:53.773]  - resignal = FALSE
[13:37:53.773]  - Number of conditions: 1
[13:37:53.773] signalConditions() ... done
[13:37:53.773] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:53.773] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = Inf ... DONE
- result = TRUE, recursive = FALSE ...
[13:37:53.773] getGlobalsAndPackages() ...
[13:37:53.774] Searching for globals...
[13:37:53.775] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:37:53.775] Searching for globals ... DONE
[13:37:53.775] Resolving globals: FALSE
[13:37:53.775] 
[13:37:53.775] 
[13:37:53.775] getGlobalsAndPackages() ... DONE
[13:37:53.776] run() for ‘Future’ ...
[13:37:53.776] - state: ‘created’
[13:37:53.776] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:53.789] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:53.789] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:53.790]   - Field: ‘node’
[13:37:53.790]   - Field: ‘label’
[13:37:53.790]   - Field: ‘local’
[13:37:53.790]   - Field: ‘owner’
[13:37:53.790]   - Field: ‘envir’
[13:37:53.790]   - Field: ‘workers’
[13:37:53.790]   - Field: ‘packages’
[13:37:53.790]   - Field: ‘gc’
[13:37:53.790]   - Field: ‘conditions’
[13:37:53.790]   - Field: ‘persistent’
[13:37:53.791]   - Field: ‘expr’
[13:37:53.791]   - Field: ‘uuid’
[13:37:53.791]   - Field: ‘seed’
[13:37:53.791]   - Field: ‘version’
[13:37:53.791]   - Field: ‘result’
[13:37:53.791]   - Field: ‘asynchronous’
[13:37:53.791]   - Field: ‘calls’
[13:37:53.791]   - Field: ‘globals’
[13:37:53.791]   - Field: ‘stdout’
[13:37:53.791]   - Field: ‘earlySignal’
[13:37:53.791]   - Field: ‘lazy’
[13:37:53.792]   - Field: ‘state’
[13:37:53.792] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:53.792] - Launch lazy future ...
[13:37:53.792] Packages needed by the future expression (n = 0): <none>
[13:37:53.792] Packages needed by future strategies (n = 0): <none>
[13:37:53.792] {
[13:37:53.792]     {
[13:37:53.792]         {
[13:37:53.792]             ...future.startTime <- base::Sys.time()
[13:37:53.792]             {
[13:37:53.792]                 {
[13:37:53.792]                   {
[13:37:53.792]                     {
[13:37:53.792]                       base::local({
[13:37:53.792]                         has_future <- base::requireNamespace("future", 
[13:37:53.792]                           quietly = TRUE)
[13:37:53.792]                         if (has_future) {
[13:37:53.792]                           ns <- base::getNamespace("future")
[13:37:53.792]                           version <- ns[[".package"]][["version"]]
[13:37:53.792]                           if (is.null(version)) 
[13:37:53.792]                             version <- utils::packageVersion("future")
[13:37:53.792]                         }
[13:37:53.792]                         else {
[13:37:53.792]                           version <- NULL
[13:37:53.792]                         }
[13:37:53.792]                         if (!has_future || version < "1.8.0") {
[13:37:53.792]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:53.792]                             "", base::R.version$version.string), 
[13:37:53.792]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:53.792]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:53.792]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:53.792]                               "release", "version")], collapse = " "), 
[13:37:53.792]                             hostname = base::Sys.info()[["nodename"]])
[13:37:53.792]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:53.792]                             info)
[13:37:53.792]                           info <- base::paste(info, collapse = "; ")
[13:37:53.792]                           if (!has_future) {
[13:37:53.792]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:53.792]                               info)
[13:37:53.792]                           }
[13:37:53.792]                           else {
[13:37:53.792]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:53.792]                               info, version)
[13:37:53.792]                           }
[13:37:53.792]                           base::stop(msg)
[13:37:53.792]                         }
[13:37:53.792]                       })
[13:37:53.792]                     }
[13:37:53.792]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:53.792]                     base::options(mc.cores = 1L)
[13:37:53.792]                   }
[13:37:53.792]                   ...future.strategy.old <- future::plan("list")
[13:37:53.792]                   options(future.plan = NULL)
[13:37:53.792]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:53.792]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:53.792]                 }
[13:37:53.792]                 ...future.workdir <- getwd()
[13:37:53.792]             }
[13:37:53.792]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:53.792]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:53.792]         }
[13:37:53.792]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:53.792]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:53.792]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:53.792]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:53.792]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:53.792]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:53.792]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:53.792]             base::names(...future.oldOptions))
[13:37:53.792]     }
[13:37:53.792]     if (FALSE) {
[13:37:53.792]     }
[13:37:53.792]     else {
[13:37:53.792]         if (TRUE) {
[13:37:53.792]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:53.792]                 open = "w")
[13:37:53.792]         }
[13:37:53.792]         else {
[13:37:53.792]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:53.792]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:53.792]         }
[13:37:53.792]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:53.792]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:53.792]             base::sink(type = "output", split = FALSE)
[13:37:53.792]             base::close(...future.stdout)
[13:37:53.792]         }, add = TRUE)
[13:37:53.792]     }
[13:37:53.792]     ...future.frame <- base::sys.nframe()
[13:37:53.792]     ...future.conditions <- base::list()
[13:37:53.792]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:53.792]     if (FALSE) {
[13:37:53.792]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:53.792]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:53.792]     }
[13:37:53.792]     ...future.result <- base::tryCatch({
[13:37:53.792]         base::withCallingHandlers({
[13:37:53.792]             ...future.value <- base::withVisible(base::local({
[13:37:53.792]                 ...future.makeSendCondition <- base::local({
[13:37:53.792]                   sendCondition <- NULL
[13:37:53.792]                   function(frame = 1L) {
[13:37:53.792]                     if (is.function(sendCondition)) 
[13:37:53.792]                       return(sendCondition)
[13:37:53.792]                     ns <- getNamespace("parallel")
[13:37:53.792]                     if (exists("sendData", mode = "function", 
[13:37:53.792]                       envir = ns)) {
[13:37:53.792]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:53.792]                         envir = ns)
[13:37:53.792]                       envir <- sys.frame(frame)
[13:37:53.792]                       master <- NULL
[13:37:53.792]                       while (!identical(envir, .GlobalEnv) && 
[13:37:53.792]                         !identical(envir, emptyenv())) {
[13:37:53.792]                         if (exists("master", mode = "list", envir = envir, 
[13:37:53.792]                           inherits = FALSE)) {
[13:37:53.792]                           master <- get("master", mode = "list", 
[13:37:53.792]                             envir = envir, inherits = FALSE)
[13:37:53.792]                           if (inherits(master, c("SOCKnode", 
[13:37:53.792]                             "SOCK0node"))) {
[13:37:53.792]                             sendCondition <<- function(cond) {
[13:37:53.792]                               data <- list(type = "VALUE", value = cond, 
[13:37:53.792]                                 success = TRUE)
[13:37:53.792]                               parallel_sendData(master, data)
[13:37:53.792]                             }
[13:37:53.792]                             return(sendCondition)
[13:37:53.792]                           }
[13:37:53.792]                         }
[13:37:53.792]                         frame <- frame + 1L
[13:37:53.792]                         envir <- sys.frame(frame)
[13:37:53.792]                       }
[13:37:53.792]                     }
[13:37:53.792]                     sendCondition <<- function(cond) NULL
[13:37:53.792]                   }
[13:37:53.792]                 })
[13:37:53.792]                 withCallingHandlers({
[13:37:53.792]                   {
[13:37:53.792]                     Sys.sleep(0.5)
[13:37:53.792]                     list(a = 1, b = 42L)
[13:37:53.792]                   }
[13:37:53.792]                 }, immediateCondition = function(cond) {
[13:37:53.792]                   sendCondition <- ...future.makeSendCondition()
[13:37:53.792]                   sendCondition(cond)
[13:37:53.792]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:53.792]                   {
[13:37:53.792]                     inherits <- base::inherits
[13:37:53.792]                     invokeRestart <- base::invokeRestart
[13:37:53.792]                     is.null <- base::is.null
[13:37:53.792]                     muffled <- FALSE
[13:37:53.792]                     if (inherits(cond, "message")) {
[13:37:53.792]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:53.792]                       if (muffled) 
[13:37:53.792]                         invokeRestart("muffleMessage")
[13:37:53.792]                     }
[13:37:53.792]                     else if (inherits(cond, "warning")) {
[13:37:53.792]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:53.792]                       if (muffled) 
[13:37:53.792]                         invokeRestart("muffleWarning")
[13:37:53.792]                     }
[13:37:53.792]                     else if (inherits(cond, "condition")) {
[13:37:53.792]                       if (!is.null(pattern)) {
[13:37:53.792]                         computeRestarts <- base::computeRestarts
[13:37:53.792]                         grepl <- base::grepl
[13:37:53.792]                         restarts <- computeRestarts(cond)
[13:37:53.792]                         for (restart in restarts) {
[13:37:53.792]                           name <- restart$name
[13:37:53.792]                           if (is.null(name)) 
[13:37:53.792]                             next
[13:37:53.792]                           if (!grepl(pattern, name)) 
[13:37:53.792]                             next
[13:37:53.792]                           invokeRestart(restart)
[13:37:53.792]                           muffled <- TRUE
[13:37:53.792]                           break
[13:37:53.792]                         }
[13:37:53.792]                       }
[13:37:53.792]                     }
[13:37:53.792]                     invisible(muffled)
[13:37:53.792]                   }
[13:37:53.792]                   muffleCondition(cond)
[13:37:53.792]                 })
[13:37:53.792]             }))
[13:37:53.792]             future::FutureResult(value = ...future.value$value, 
[13:37:53.792]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:53.792]                   ...future.rng), globalenv = if (FALSE) 
[13:37:53.792]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:53.792]                     ...future.globalenv.names))
[13:37:53.792]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:53.792]         }, condition = base::local({
[13:37:53.792]             c <- base::c
[13:37:53.792]             inherits <- base::inherits
[13:37:53.792]             invokeRestart <- base::invokeRestart
[13:37:53.792]             length <- base::length
[13:37:53.792]             list <- base::list
[13:37:53.792]             seq.int <- base::seq.int
[13:37:53.792]             signalCondition <- base::signalCondition
[13:37:53.792]             sys.calls <- base::sys.calls
[13:37:53.792]             `[[` <- base::`[[`
[13:37:53.792]             `+` <- base::`+`
[13:37:53.792]             `<<-` <- base::`<<-`
[13:37:53.792]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:53.792]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:53.792]                   3L)]
[13:37:53.792]             }
[13:37:53.792]             function(cond) {
[13:37:53.792]                 is_error <- inherits(cond, "error")
[13:37:53.792]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:53.792]                   NULL)
[13:37:53.792]                 if (is_error) {
[13:37:53.792]                   sessionInformation <- function() {
[13:37:53.792]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:53.792]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:53.792]                       search = base::search(), system = base::Sys.info())
[13:37:53.792]                   }
[13:37:53.792]                   ...future.conditions[[length(...future.conditions) + 
[13:37:53.792]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:53.792]                     cond$call), session = sessionInformation(), 
[13:37:53.792]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:53.792]                   signalCondition(cond)
[13:37:53.792]                 }
[13:37:53.792]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:53.792]                 "immediateCondition"))) {
[13:37:53.792]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:53.792]                   ...future.conditions[[length(...future.conditions) + 
[13:37:53.792]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:53.792]                   if (TRUE && !signal) {
[13:37:53.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:53.792]                     {
[13:37:53.792]                       inherits <- base::inherits
[13:37:53.792]                       invokeRestart <- base::invokeRestart
[13:37:53.792]                       is.null <- base::is.null
[13:37:53.792]                       muffled <- FALSE
[13:37:53.792]                       if (inherits(cond, "message")) {
[13:37:53.792]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:53.792]                         if (muffled) 
[13:37:53.792]                           invokeRestart("muffleMessage")
[13:37:53.792]                       }
[13:37:53.792]                       else if (inherits(cond, "warning")) {
[13:37:53.792]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:53.792]                         if (muffled) 
[13:37:53.792]                           invokeRestart("muffleWarning")
[13:37:53.792]                       }
[13:37:53.792]                       else if (inherits(cond, "condition")) {
[13:37:53.792]                         if (!is.null(pattern)) {
[13:37:53.792]                           computeRestarts <- base::computeRestarts
[13:37:53.792]                           grepl <- base::grepl
[13:37:53.792]                           restarts <- computeRestarts(cond)
[13:37:53.792]                           for (restart in restarts) {
[13:37:53.792]                             name <- restart$name
[13:37:53.792]                             if (is.null(name)) 
[13:37:53.792]                               next
[13:37:53.792]                             if (!grepl(pattern, name)) 
[13:37:53.792]                               next
[13:37:53.792]                             invokeRestart(restart)
[13:37:53.792]                             muffled <- TRUE
[13:37:53.792]                             break
[13:37:53.792]                           }
[13:37:53.792]                         }
[13:37:53.792]                       }
[13:37:53.792]                       invisible(muffled)
[13:37:53.792]                     }
[13:37:53.792]                     muffleCondition(cond, pattern = "^muffle")
[13:37:53.792]                   }
[13:37:53.792]                 }
[13:37:53.792]                 else {
[13:37:53.792]                   if (TRUE) {
[13:37:53.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:53.792]                     {
[13:37:53.792]                       inherits <- base::inherits
[13:37:53.792]                       invokeRestart <- base::invokeRestart
[13:37:53.792]                       is.null <- base::is.null
[13:37:53.792]                       muffled <- FALSE
[13:37:53.792]                       if (inherits(cond, "message")) {
[13:37:53.792]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:53.792]                         if (muffled) 
[13:37:53.792]                           invokeRestart("muffleMessage")
[13:37:53.792]                       }
[13:37:53.792]                       else if (inherits(cond, "warning")) {
[13:37:53.792]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:53.792]                         if (muffled) 
[13:37:53.792]                           invokeRestart("muffleWarning")
[13:37:53.792]                       }
[13:37:53.792]                       else if (inherits(cond, "condition")) {
[13:37:53.792]                         if (!is.null(pattern)) {
[13:37:53.792]                           computeRestarts <- base::computeRestarts
[13:37:53.792]                           grepl <- base::grepl
[13:37:53.792]                           restarts <- computeRestarts(cond)
[13:37:53.792]                           for (restart in restarts) {
[13:37:53.792]                             name <- restart$name
[13:37:53.792]                             if (is.null(name)) 
[13:37:53.792]                               next
[13:37:53.792]                             if (!grepl(pattern, name)) 
[13:37:53.792]                               next
[13:37:53.792]                             invokeRestart(restart)
[13:37:53.792]                             muffled <- TRUE
[13:37:53.792]                             break
[13:37:53.792]                           }
[13:37:53.792]                         }
[13:37:53.792]                       }
[13:37:53.792]                       invisible(muffled)
[13:37:53.792]                     }
[13:37:53.792]                     muffleCondition(cond, pattern = "^muffle")
[13:37:53.792]                   }
[13:37:53.792]                 }
[13:37:53.792]             }
[13:37:53.792]         }))
[13:37:53.792]     }, error = function(ex) {
[13:37:53.792]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:53.792]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:53.792]                 ...future.rng), started = ...future.startTime, 
[13:37:53.792]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:53.792]             version = "1.8"), class = "FutureResult")
[13:37:53.792]     }, finally = {
[13:37:53.792]         if (!identical(...future.workdir, getwd())) 
[13:37:53.792]             setwd(...future.workdir)
[13:37:53.792]         {
[13:37:53.792]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:53.792]                 ...future.oldOptions$nwarnings <- NULL
[13:37:53.792]             }
[13:37:53.792]             base::options(...future.oldOptions)
[13:37:53.792]             if (.Platform$OS.type == "windows") {
[13:37:53.792]                 old_names <- names(...future.oldEnvVars)
[13:37:53.792]                 envs <- base::Sys.getenv()
[13:37:53.792]                 names <- names(envs)
[13:37:53.792]                 common <- intersect(names, old_names)
[13:37:53.792]                 added <- setdiff(names, old_names)
[13:37:53.792]                 removed <- setdiff(old_names, names)
[13:37:53.792]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:53.792]                   envs[common]]
[13:37:53.792]                 NAMES <- toupper(changed)
[13:37:53.792]                 args <- list()
[13:37:53.792]                 for (kk in seq_along(NAMES)) {
[13:37:53.792]                   name <- changed[[kk]]
[13:37:53.792]                   NAME <- NAMES[[kk]]
[13:37:53.792]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:53.792]                     next
[13:37:53.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:53.792]                 }
[13:37:53.792]                 NAMES <- toupper(added)
[13:37:53.792]                 for (kk in seq_along(NAMES)) {
[13:37:53.792]                   name <- added[[kk]]
[13:37:53.792]                   NAME <- NAMES[[kk]]
[13:37:53.792]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:53.792]                     next
[13:37:53.792]                   args[[name]] <- ""
[13:37:53.792]                 }
[13:37:53.792]                 NAMES <- toupper(removed)
[13:37:53.792]                 for (kk in seq_along(NAMES)) {
[13:37:53.792]                   name <- removed[[kk]]
[13:37:53.792]                   NAME <- NAMES[[kk]]
[13:37:53.792]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:53.792]                     next
[13:37:53.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:53.792]                 }
[13:37:53.792]                 if (length(args) > 0) 
[13:37:53.792]                   base::do.call(base::Sys.setenv, args = args)
[13:37:53.792]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:53.792]             }
[13:37:53.792]             else {
[13:37:53.792]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:53.792]             }
[13:37:53.792]             {
[13:37:53.792]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:53.792]                   0L) {
[13:37:53.792]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:53.792]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:53.792]                   base::options(opts)
[13:37:53.792]                 }
[13:37:53.792]                 {
[13:37:53.792]                   {
[13:37:53.792]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:53.792]                     NULL
[13:37:53.792]                   }
[13:37:53.792]                   options(future.plan = NULL)
[13:37:53.792]                   if (is.na(NA_character_)) 
[13:37:53.792]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:53.792]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:53.792]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:53.792]                     .init = FALSE)
[13:37:53.792]                 }
[13:37:53.792]             }
[13:37:53.792]         }
[13:37:53.792]     })
[13:37:53.792]     if (TRUE) {
[13:37:53.792]         base::sink(type = "output", split = FALSE)
[13:37:53.792]         if (TRUE) {
[13:37:53.792]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:53.792]         }
[13:37:53.792]         else {
[13:37:53.792]             ...future.result["stdout"] <- base::list(NULL)
[13:37:53.792]         }
[13:37:53.792]         base::close(...future.stdout)
[13:37:53.792]         ...future.stdout <- NULL
[13:37:53.792]     }
[13:37:53.792]     ...future.result$conditions <- ...future.conditions
[13:37:53.792]     ...future.result$finished <- base::Sys.time()
[13:37:53.792]     ...future.result
[13:37:53.792] }
[13:37:53.795] MultisessionFuture started
[13:37:53.795] - Launch lazy future ... done
[13:37:53.795] run() for ‘MultisessionFuture’ ... done
[13:37:54.297] receiveMessageFromWorker() for ClusterFuture ...
[13:37:54.298] - Validating connection of MultisessionFuture
[13:37:54.298] - received message: FutureResult
[13:37:54.298] - Received FutureResult
[13:37:54.298] - Erased future from FutureRegistry
[13:37:54.298] result() for ClusterFuture ...
[13:37:54.299] - result already collected: FutureResult
[13:37:54.299] result() for ClusterFuture ... done
[13:37:54.299] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:54.299] A MultisessionFuture was resolved
[13:37:54.299] getGlobalsAndPackages() ...
[13:37:54.299] Searching for globals...
[13:37:54.300] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:37:54.300] Searching for globals ... DONE
[13:37:54.300] Resolving globals: FALSE
[13:37:54.301] 
[13:37:54.301] 
[13:37:54.301] getGlobalsAndPackages() ... DONE
[13:37:54.301] run() for ‘Future’ ...
[13:37:54.301] - state: ‘created’
[13:37:54.301] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:54.315] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:54.315] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:54.316]   - Field: ‘node’
[13:37:54.316]   - Field: ‘label’
[13:37:54.316]   - Field: ‘local’
[13:37:54.316]   - Field: ‘owner’
[13:37:54.316]   - Field: ‘envir’
[13:37:54.316]   - Field: ‘workers’
[13:37:54.316]   - Field: ‘packages’
[13:37:54.316]   - Field: ‘gc’
[13:37:54.316]   - Field: ‘conditions’
[13:37:54.316]   - Field: ‘persistent’
[13:37:54.316]   - Field: ‘expr’
[13:37:54.317]   - Field: ‘uuid’
[13:37:54.317]   - Field: ‘seed’
[13:37:54.317]   - Field: ‘version’
[13:37:54.317]   - Field: ‘result’
[13:37:54.317]   - Field: ‘asynchronous’
[13:37:54.317]   - Field: ‘calls’
[13:37:54.317]   - Field: ‘globals’
[13:37:54.317]   - Field: ‘stdout’
[13:37:54.317]   - Field: ‘earlySignal’
[13:37:54.317]   - Field: ‘lazy’
[13:37:54.317]   - Field: ‘state’
[13:37:54.318] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:54.318] - Launch lazy future ...
[13:37:54.320] Packages needed by the future expression (n = 0): <none>
[13:37:54.321] Packages needed by future strategies (n = 0): <none>
[13:37:54.321] {
[13:37:54.321]     {
[13:37:54.321]         {
[13:37:54.321]             ...future.startTime <- base::Sys.time()
[13:37:54.321]             {
[13:37:54.321]                 {
[13:37:54.321]                   {
[13:37:54.321]                     {
[13:37:54.321]                       base::local({
[13:37:54.321]                         has_future <- base::requireNamespace("future", 
[13:37:54.321]                           quietly = TRUE)
[13:37:54.321]                         if (has_future) {
[13:37:54.321]                           ns <- base::getNamespace("future")
[13:37:54.321]                           version <- ns[[".package"]][["version"]]
[13:37:54.321]                           if (is.null(version)) 
[13:37:54.321]                             version <- utils::packageVersion("future")
[13:37:54.321]                         }
[13:37:54.321]                         else {
[13:37:54.321]                           version <- NULL
[13:37:54.321]                         }
[13:37:54.321]                         if (!has_future || version < "1.8.0") {
[13:37:54.321]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:54.321]                             "", base::R.version$version.string), 
[13:37:54.321]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:54.321]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:54.321]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:54.321]                               "release", "version")], collapse = " "), 
[13:37:54.321]                             hostname = base::Sys.info()[["nodename"]])
[13:37:54.321]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:54.321]                             info)
[13:37:54.321]                           info <- base::paste(info, collapse = "; ")
[13:37:54.321]                           if (!has_future) {
[13:37:54.321]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:54.321]                               info)
[13:37:54.321]                           }
[13:37:54.321]                           else {
[13:37:54.321]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:54.321]                               info, version)
[13:37:54.321]                           }
[13:37:54.321]                           base::stop(msg)
[13:37:54.321]                         }
[13:37:54.321]                       })
[13:37:54.321]                     }
[13:37:54.321]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:54.321]                     base::options(mc.cores = 1L)
[13:37:54.321]                   }
[13:37:54.321]                   ...future.strategy.old <- future::plan("list")
[13:37:54.321]                   options(future.plan = NULL)
[13:37:54.321]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:54.321]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:54.321]                 }
[13:37:54.321]                 ...future.workdir <- getwd()
[13:37:54.321]             }
[13:37:54.321]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:54.321]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:54.321]         }
[13:37:54.321]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:54.321]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:54.321]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:54.321]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:54.321]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:54.321]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:54.321]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:54.321]             base::names(...future.oldOptions))
[13:37:54.321]     }
[13:37:54.321]     if (FALSE) {
[13:37:54.321]     }
[13:37:54.321]     else {
[13:37:54.321]         if (TRUE) {
[13:37:54.321]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:54.321]                 open = "w")
[13:37:54.321]         }
[13:37:54.321]         else {
[13:37:54.321]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:54.321]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:54.321]         }
[13:37:54.321]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:54.321]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:54.321]             base::sink(type = "output", split = FALSE)
[13:37:54.321]             base::close(...future.stdout)
[13:37:54.321]         }, add = TRUE)
[13:37:54.321]     }
[13:37:54.321]     ...future.frame <- base::sys.nframe()
[13:37:54.321]     ...future.conditions <- base::list()
[13:37:54.321]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:54.321]     if (FALSE) {
[13:37:54.321]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:54.321]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:54.321]     }
[13:37:54.321]     ...future.result <- base::tryCatch({
[13:37:54.321]         base::withCallingHandlers({
[13:37:54.321]             ...future.value <- base::withVisible(base::local({
[13:37:54.321]                 ...future.makeSendCondition <- base::local({
[13:37:54.321]                   sendCondition <- NULL
[13:37:54.321]                   function(frame = 1L) {
[13:37:54.321]                     if (is.function(sendCondition)) 
[13:37:54.321]                       return(sendCondition)
[13:37:54.321]                     ns <- getNamespace("parallel")
[13:37:54.321]                     if (exists("sendData", mode = "function", 
[13:37:54.321]                       envir = ns)) {
[13:37:54.321]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:54.321]                         envir = ns)
[13:37:54.321]                       envir <- sys.frame(frame)
[13:37:54.321]                       master <- NULL
[13:37:54.321]                       while (!identical(envir, .GlobalEnv) && 
[13:37:54.321]                         !identical(envir, emptyenv())) {
[13:37:54.321]                         if (exists("master", mode = "list", envir = envir, 
[13:37:54.321]                           inherits = FALSE)) {
[13:37:54.321]                           master <- get("master", mode = "list", 
[13:37:54.321]                             envir = envir, inherits = FALSE)
[13:37:54.321]                           if (inherits(master, c("SOCKnode", 
[13:37:54.321]                             "SOCK0node"))) {
[13:37:54.321]                             sendCondition <<- function(cond) {
[13:37:54.321]                               data <- list(type = "VALUE", value = cond, 
[13:37:54.321]                                 success = TRUE)
[13:37:54.321]                               parallel_sendData(master, data)
[13:37:54.321]                             }
[13:37:54.321]                             return(sendCondition)
[13:37:54.321]                           }
[13:37:54.321]                         }
[13:37:54.321]                         frame <- frame + 1L
[13:37:54.321]                         envir <- sys.frame(frame)
[13:37:54.321]                       }
[13:37:54.321]                     }
[13:37:54.321]                     sendCondition <<- function(cond) NULL
[13:37:54.321]                   }
[13:37:54.321]                 })
[13:37:54.321]                 withCallingHandlers({
[13:37:54.321]                   {
[13:37:54.321]                     Sys.sleep(0.5)
[13:37:54.321]                     list(a = 1, b = 42L)
[13:37:54.321]                   }
[13:37:54.321]                 }, immediateCondition = function(cond) {
[13:37:54.321]                   sendCondition <- ...future.makeSendCondition()
[13:37:54.321]                   sendCondition(cond)
[13:37:54.321]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:54.321]                   {
[13:37:54.321]                     inherits <- base::inherits
[13:37:54.321]                     invokeRestart <- base::invokeRestart
[13:37:54.321]                     is.null <- base::is.null
[13:37:54.321]                     muffled <- FALSE
[13:37:54.321]                     if (inherits(cond, "message")) {
[13:37:54.321]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:54.321]                       if (muffled) 
[13:37:54.321]                         invokeRestart("muffleMessage")
[13:37:54.321]                     }
[13:37:54.321]                     else if (inherits(cond, "warning")) {
[13:37:54.321]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:54.321]                       if (muffled) 
[13:37:54.321]                         invokeRestart("muffleWarning")
[13:37:54.321]                     }
[13:37:54.321]                     else if (inherits(cond, "condition")) {
[13:37:54.321]                       if (!is.null(pattern)) {
[13:37:54.321]                         computeRestarts <- base::computeRestarts
[13:37:54.321]                         grepl <- base::grepl
[13:37:54.321]                         restarts <- computeRestarts(cond)
[13:37:54.321]                         for (restart in restarts) {
[13:37:54.321]                           name <- restart$name
[13:37:54.321]                           if (is.null(name)) 
[13:37:54.321]                             next
[13:37:54.321]                           if (!grepl(pattern, name)) 
[13:37:54.321]                             next
[13:37:54.321]                           invokeRestart(restart)
[13:37:54.321]                           muffled <- TRUE
[13:37:54.321]                           break
[13:37:54.321]                         }
[13:37:54.321]                       }
[13:37:54.321]                     }
[13:37:54.321]                     invisible(muffled)
[13:37:54.321]                   }
[13:37:54.321]                   muffleCondition(cond)
[13:37:54.321]                 })
[13:37:54.321]             }))
[13:37:54.321]             future::FutureResult(value = ...future.value$value, 
[13:37:54.321]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:54.321]                   ...future.rng), globalenv = if (FALSE) 
[13:37:54.321]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:54.321]                     ...future.globalenv.names))
[13:37:54.321]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:54.321]         }, condition = base::local({
[13:37:54.321]             c <- base::c
[13:37:54.321]             inherits <- base::inherits
[13:37:54.321]             invokeRestart <- base::invokeRestart
[13:37:54.321]             length <- base::length
[13:37:54.321]             list <- base::list
[13:37:54.321]             seq.int <- base::seq.int
[13:37:54.321]             signalCondition <- base::signalCondition
[13:37:54.321]             sys.calls <- base::sys.calls
[13:37:54.321]             `[[` <- base::`[[`
[13:37:54.321]             `+` <- base::`+`
[13:37:54.321]             `<<-` <- base::`<<-`
[13:37:54.321]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:54.321]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:54.321]                   3L)]
[13:37:54.321]             }
[13:37:54.321]             function(cond) {
[13:37:54.321]                 is_error <- inherits(cond, "error")
[13:37:54.321]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:54.321]                   NULL)
[13:37:54.321]                 if (is_error) {
[13:37:54.321]                   sessionInformation <- function() {
[13:37:54.321]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:54.321]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:54.321]                       search = base::search(), system = base::Sys.info())
[13:37:54.321]                   }
[13:37:54.321]                   ...future.conditions[[length(...future.conditions) + 
[13:37:54.321]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:54.321]                     cond$call), session = sessionInformation(), 
[13:37:54.321]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:54.321]                   signalCondition(cond)
[13:37:54.321]                 }
[13:37:54.321]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:54.321]                 "immediateCondition"))) {
[13:37:54.321]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:54.321]                   ...future.conditions[[length(...future.conditions) + 
[13:37:54.321]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:54.321]                   if (TRUE && !signal) {
[13:37:54.321]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:54.321]                     {
[13:37:54.321]                       inherits <- base::inherits
[13:37:54.321]                       invokeRestart <- base::invokeRestart
[13:37:54.321]                       is.null <- base::is.null
[13:37:54.321]                       muffled <- FALSE
[13:37:54.321]                       if (inherits(cond, "message")) {
[13:37:54.321]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:54.321]                         if (muffled) 
[13:37:54.321]                           invokeRestart("muffleMessage")
[13:37:54.321]                       }
[13:37:54.321]                       else if (inherits(cond, "warning")) {
[13:37:54.321]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:54.321]                         if (muffled) 
[13:37:54.321]                           invokeRestart("muffleWarning")
[13:37:54.321]                       }
[13:37:54.321]                       else if (inherits(cond, "condition")) {
[13:37:54.321]                         if (!is.null(pattern)) {
[13:37:54.321]                           computeRestarts <- base::computeRestarts
[13:37:54.321]                           grepl <- base::grepl
[13:37:54.321]                           restarts <- computeRestarts(cond)
[13:37:54.321]                           for (restart in restarts) {
[13:37:54.321]                             name <- restart$name
[13:37:54.321]                             if (is.null(name)) 
[13:37:54.321]                               next
[13:37:54.321]                             if (!grepl(pattern, name)) 
[13:37:54.321]                               next
[13:37:54.321]                             invokeRestart(restart)
[13:37:54.321]                             muffled <- TRUE
[13:37:54.321]                             break
[13:37:54.321]                           }
[13:37:54.321]                         }
[13:37:54.321]                       }
[13:37:54.321]                       invisible(muffled)
[13:37:54.321]                     }
[13:37:54.321]                     muffleCondition(cond, pattern = "^muffle")
[13:37:54.321]                   }
[13:37:54.321]                 }
[13:37:54.321]                 else {
[13:37:54.321]                   if (TRUE) {
[13:37:54.321]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:54.321]                     {
[13:37:54.321]                       inherits <- base::inherits
[13:37:54.321]                       invokeRestart <- base::invokeRestart
[13:37:54.321]                       is.null <- base::is.null
[13:37:54.321]                       muffled <- FALSE
[13:37:54.321]                       if (inherits(cond, "message")) {
[13:37:54.321]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:54.321]                         if (muffled) 
[13:37:54.321]                           invokeRestart("muffleMessage")
[13:37:54.321]                       }
[13:37:54.321]                       else if (inherits(cond, "warning")) {
[13:37:54.321]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:54.321]                         if (muffled) 
[13:37:54.321]                           invokeRestart("muffleWarning")
[13:37:54.321]                       }
[13:37:54.321]                       else if (inherits(cond, "condition")) {
[13:37:54.321]                         if (!is.null(pattern)) {
[13:37:54.321]                           computeRestarts <- base::computeRestarts
[13:37:54.321]                           grepl <- base::grepl
[13:37:54.321]                           restarts <- computeRestarts(cond)
[13:37:54.321]                           for (restart in restarts) {
[13:37:54.321]                             name <- restart$name
[13:37:54.321]                             if (is.null(name)) 
[13:37:54.321]                               next
[13:37:54.321]                             if (!grepl(pattern, name)) 
[13:37:54.321]                               next
[13:37:54.321]                             invokeRestart(restart)
[13:37:54.321]                             muffled <- TRUE
[13:37:54.321]                             break
[13:37:54.321]                           }
[13:37:54.321]                         }
[13:37:54.321]                       }
[13:37:54.321]                       invisible(muffled)
[13:37:54.321]                     }
[13:37:54.321]                     muffleCondition(cond, pattern = "^muffle")
[13:37:54.321]                   }
[13:37:54.321]                 }
[13:37:54.321]             }
[13:37:54.321]         }))
[13:37:54.321]     }, error = function(ex) {
[13:37:54.321]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:54.321]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:54.321]                 ...future.rng), started = ...future.startTime, 
[13:37:54.321]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:54.321]             version = "1.8"), class = "FutureResult")
[13:37:54.321]     }, finally = {
[13:37:54.321]         if (!identical(...future.workdir, getwd())) 
[13:37:54.321]             setwd(...future.workdir)
[13:37:54.321]         {
[13:37:54.321]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:54.321]                 ...future.oldOptions$nwarnings <- NULL
[13:37:54.321]             }
[13:37:54.321]             base::options(...future.oldOptions)
[13:37:54.321]             if (.Platform$OS.type == "windows") {
[13:37:54.321]                 old_names <- names(...future.oldEnvVars)
[13:37:54.321]                 envs <- base::Sys.getenv()
[13:37:54.321]                 names <- names(envs)
[13:37:54.321]                 common <- intersect(names, old_names)
[13:37:54.321]                 added <- setdiff(names, old_names)
[13:37:54.321]                 removed <- setdiff(old_names, names)
[13:37:54.321]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:54.321]                   envs[common]]
[13:37:54.321]                 NAMES <- toupper(changed)
[13:37:54.321]                 args <- list()
[13:37:54.321]                 for (kk in seq_along(NAMES)) {
[13:37:54.321]                   name <- changed[[kk]]
[13:37:54.321]                   NAME <- NAMES[[kk]]
[13:37:54.321]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:54.321]                     next
[13:37:54.321]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:54.321]                 }
[13:37:54.321]                 NAMES <- toupper(added)
[13:37:54.321]                 for (kk in seq_along(NAMES)) {
[13:37:54.321]                   name <- added[[kk]]
[13:37:54.321]                   NAME <- NAMES[[kk]]
[13:37:54.321]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:54.321]                     next
[13:37:54.321]                   args[[name]] <- ""
[13:37:54.321]                 }
[13:37:54.321]                 NAMES <- toupper(removed)
[13:37:54.321]                 for (kk in seq_along(NAMES)) {
[13:37:54.321]                   name <- removed[[kk]]
[13:37:54.321]                   NAME <- NAMES[[kk]]
[13:37:54.321]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:54.321]                     next
[13:37:54.321]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:54.321]                 }
[13:37:54.321]                 if (length(args) > 0) 
[13:37:54.321]                   base::do.call(base::Sys.setenv, args = args)
[13:37:54.321]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:54.321]             }
[13:37:54.321]             else {
[13:37:54.321]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:54.321]             }
[13:37:54.321]             {
[13:37:54.321]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:54.321]                   0L) {
[13:37:54.321]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:54.321]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:54.321]                   base::options(opts)
[13:37:54.321]                 }
[13:37:54.321]                 {
[13:37:54.321]                   {
[13:37:54.321]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:54.321]                     NULL
[13:37:54.321]                   }
[13:37:54.321]                   options(future.plan = NULL)
[13:37:54.321]                   if (is.na(NA_character_)) 
[13:37:54.321]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:54.321]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:54.321]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:54.321]                     .init = FALSE)
[13:37:54.321]                 }
[13:37:54.321]             }
[13:37:54.321]         }
[13:37:54.321]     })
[13:37:54.321]     if (TRUE) {
[13:37:54.321]         base::sink(type = "output", split = FALSE)
[13:37:54.321]         if (TRUE) {
[13:37:54.321]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:54.321]         }
[13:37:54.321]         else {
[13:37:54.321]             ...future.result["stdout"] <- base::list(NULL)
[13:37:54.321]         }
[13:37:54.321]         base::close(...future.stdout)
[13:37:54.321]         ...future.stdout <- NULL
[13:37:54.321]     }
[13:37:54.321]     ...future.result$conditions <- ...future.conditions
[13:37:54.321]     ...future.result$finished <- base::Sys.time()
[13:37:54.321]     ...future.result
[13:37:54.321] }
[13:37:54.324] MultisessionFuture started
[13:37:54.324] - Launch lazy future ... done
[13:37:54.324] run() for ‘MultisessionFuture’ ... done
[13:37:54.826] receiveMessageFromWorker() for ClusterFuture ...
[13:37:54.827] - Validating connection of MultisessionFuture
[13:37:54.827] - received message: FutureResult
[13:37:54.827] - Received FutureResult
[13:37:54.827] - Erased future from FutureRegistry
[13:37:54.827] result() for ClusterFuture ...
[13:37:54.827] - result already collected: FutureResult
[13:37:54.827] result() for ClusterFuture ... done
[13:37:54.828] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:54.828] A MultisessionFuture was resolved
- w/ exception ...
[13:37:54.828] getGlobalsAndPackages() ...
[13:37:54.828] Searching for globals...
[13:37:54.829] - globals found: [2] ‘list’, ‘stop’
[13:37:54.829] Searching for globals ... DONE
[13:37:54.829] Resolving globals: FALSE
[13:37:54.829] 
[13:37:54.829] 
[13:37:54.829] getGlobalsAndPackages() ... DONE
[13:37:54.830] run() for ‘Future’ ...
[13:37:54.830] - state: ‘created’
[13:37:54.830] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:54.844] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:54.844] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:54.844]   - Field: ‘node’
[13:37:54.844]   - Field: ‘label’
[13:37:54.844]   - Field: ‘local’
[13:37:54.844]   - Field: ‘owner’
[13:37:54.844]   - Field: ‘envir’
[13:37:54.844]   - Field: ‘workers’
[13:37:54.844]   - Field: ‘packages’
[13:37:54.845]   - Field: ‘gc’
[13:37:54.845]   - Field: ‘conditions’
[13:37:54.845]   - Field: ‘persistent’
[13:37:54.845]   - Field: ‘expr’
[13:37:54.845]   - Field: ‘uuid’
[13:37:54.845]   - Field: ‘seed’
[13:37:54.845]   - Field: ‘version’
[13:37:54.845]   - Field: ‘result’
[13:37:54.845]   - Field: ‘asynchronous’
[13:37:54.845]   - Field: ‘calls’
[13:37:54.845]   - Field: ‘globals’
[13:37:54.846]   - Field: ‘stdout’
[13:37:54.846]   - Field: ‘earlySignal’
[13:37:54.846]   - Field: ‘lazy’
[13:37:54.846]   - Field: ‘state’
[13:37:54.846] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:54.846] - Launch lazy future ...
[13:37:54.846] Packages needed by the future expression (n = 0): <none>
[13:37:54.846] Packages needed by future strategies (n = 0): <none>
[13:37:54.847] {
[13:37:54.847]     {
[13:37:54.847]         {
[13:37:54.847]             ...future.startTime <- base::Sys.time()
[13:37:54.847]             {
[13:37:54.847]                 {
[13:37:54.847]                   {
[13:37:54.847]                     {
[13:37:54.847]                       base::local({
[13:37:54.847]                         has_future <- base::requireNamespace("future", 
[13:37:54.847]                           quietly = TRUE)
[13:37:54.847]                         if (has_future) {
[13:37:54.847]                           ns <- base::getNamespace("future")
[13:37:54.847]                           version <- ns[[".package"]][["version"]]
[13:37:54.847]                           if (is.null(version)) 
[13:37:54.847]                             version <- utils::packageVersion("future")
[13:37:54.847]                         }
[13:37:54.847]                         else {
[13:37:54.847]                           version <- NULL
[13:37:54.847]                         }
[13:37:54.847]                         if (!has_future || version < "1.8.0") {
[13:37:54.847]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:54.847]                             "", base::R.version$version.string), 
[13:37:54.847]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:54.847]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:54.847]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:54.847]                               "release", "version")], collapse = " "), 
[13:37:54.847]                             hostname = base::Sys.info()[["nodename"]])
[13:37:54.847]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:54.847]                             info)
[13:37:54.847]                           info <- base::paste(info, collapse = "; ")
[13:37:54.847]                           if (!has_future) {
[13:37:54.847]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:54.847]                               info)
[13:37:54.847]                           }
[13:37:54.847]                           else {
[13:37:54.847]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:54.847]                               info, version)
[13:37:54.847]                           }
[13:37:54.847]                           base::stop(msg)
[13:37:54.847]                         }
[13:37:54.847]                       })
[13:37:54.847]                     }
[13:37:54.847]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:54.847]                     base::options(mc.cores = 1L)
[13:37:54.847]                   }
[13:37:54.847]                   ...future.strategy.old <- future::plan("list")
[13:37:54.847]                   options(future.plan = NULL)
[13:37:54.847]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:54.847]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:54.847]                 }
[13:37:54.847]                 ...future.workdir <- getwd()
[13:37:54.847]             }
[13:37:54.847]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:54.847]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:54.847]         }
[13:37:54.847]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:54.847]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:54.847]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:54.847]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:54.847]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:54.847]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:54.847]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:54.847]             base::names(...future.oldOptions))
[13:37:54.847]     }
[13:37:54.847]     if (FALSE) {
[13:37:54.847]     }
[13:37:54.847]     else {
[13:37:54.847]         if (TRUE) {
[13:37:54.847]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:54.847]                 open = "w")
[13:37:54.847]         }
[13:37:54.847]         else {
[13:37:54.847]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:54.847]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:54.847]         }
[13:37:54.847]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:54.847]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:54.847]             base::sink(type = "output", split = FALSE)
[13:37:54.847]             base::close(...future.stdout)
[13:37:54.847]         }, add = TRUE)
[13:37:54.847]     }
[13:37:54.847]     ...future.frame <- base::sys.nframe()
[13:37:54.847]     ...future.conditions <- base::list()
[13:37:54.847]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:54.847]     if (FALSE) {
[13:37:54.847]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:54.847]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:54.847]     }
[13:37:54.847]     ...future.result <- base::tryCatch({
[13:37:54.847]         base::withCallingHandlers({
[13:37:54.847]             ...future.value <- base::withVisible(base::local({
[13:37:54.847]                 ...future.makeSendCondition <- base::local({
[13:37:54.847]                   sendCondition <- NULL
[13:37:54.847]                   function(frame = 1L) {
[13:37:54.847]                     if (is.function(sendCondition)) 
[13:37:54.847]                       return(sendCondition)
[13:37:54.847]                     ns <- getNamespace("parallel")
[13:37:54.847]                     if (exists("sendData", mode = "function", 
[13:37:54.847]                       envir = ns)) {
[13:37:54.847]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:54.847]                         envir = ns)
[13:37:54.847]                       envir <- sys.frame(frame)
[13:37:54.847]                       master <- NULL
[13:37:54.847]                       while (!identical(envir, .GlobalEnv) && 
[13:37:54.847]                         !identical(envir, emptyenv())) {
[13:37:54.847]                         if (exists("master", mode = "list", envir = envir, 
[13:37:54.847]                           inherits = FALSE)) {
[13:37:54.847]                           master <- get("master", mode = "list", 
[13:37:54.847]                             envir = envir, inherits = FALSE)
[13:37:54.847]                           if (inherits(master, c("SOCKnode", 
[13:37:54.847]                             "SOCK0node"))) {
[13:37:54.847]                             sendCondition <<- function(cond) {
[13:37:54.847]                               data <- list(type = "VALUE", value = cond, 
[13:37:54.847]                                 success = TRUE)
[13:37:54.847]                               parallel_sendData(master, data)
[13:37:54.847]                             }
[13:37:54.847]                             return(sendCondition)
[13:37:54.847]                           }
[13:37:54.847]                         }
[13:37:54.847]                         frame <- frame + 1L
[13:37:54.847]                         envir <- sys.frame(frame)
[13:37:54.847]                       }
[13:37:54.847]                     }
[13:37:54.847]                     sendCondition <<- function(cond) NULL
[13:37:54.847]                   }
[13:37:54.847]                 })
[13:37:54.847]                 withCallingHandlers({
[13:37:54.847]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:37:54.847]                 }, immediateCondition = function(cond) {
[13:37:54.847]                   sendCondition <- ...future.makeSendCondition()
[13:37:54.847]                   sendCondition(cond)
[13:37:54.847]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:54.847]                   {
[13:37:54.847]                     inherits <- base::inherits
[13:37:54.847]                     invokeRestart <- base::invokeRestart
[13:37:54.847]                     is.null <- base::is.null
[13:37:54.847]                     muffled <- FALSE
[13:37:54.847]                     if (inherits(cond, "message")) {
[13:37:54.847]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:54.847]                       if (muffled) 
[13:37:54.847]                         invokeRestart("muffleMessage")
[13:37:54.847]                     }
[13:37:54.847]                     else if (inherits(cond, "warning")) {
[13:37:54.847]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:54.847]                       if (muffled) 
[13:37:54.847]                         invokeRestart("muffleWarning")
[13:37:54.847]                     }
[13:37:54.847]                     else if (inherits(cond, "condition")) {
[13:37:54.847]                       if (!is.null(pattern)) {
[13:37:54.847]                         computeRestarts <- base::computeRestarts
[13:37:54.847]                         grepl <- base::grepl
[13:37:54.847]                         restarts <- computeRestarts(cond)
[13:37:54.847]                         for (restart in restarts) {
[13:37:54.847]                           name <- restart$name
[13:37:54.847]                           if (is.null(name)) 
[13:37:54.847]                             next
[13:37:54.847]                           if (!grepl(pattern, name)) 
[13:37:54.847]                             next
[13:37:54.847]                           invokeRestart(restart)
[13:37:54.847]                           muffled <- TRUE
[13:37:54.847]                           break
[13:37:54.847]                         }
[13:37:54.847]                       }
[13:37:54.847]                     }
[13:37:54.847]                     invisible(muffled)
[13:37:54.847]                   }
[13:37:54.847]                   muffleCondition(cond)
[13:37:54.847]                 })
[13:37:54.847]             }))
[13:37:54.847]             future::FutureResult(value = ...future.value$value, 
[13:37:54.847]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:54.847]                   ...future.rng), globalenv = if (FALSE) 
[13:37:54.847]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:54.847]                     ...future.globalenv.names))
[13:37:54.847]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:54.847]         }, condition = base::local({
[13:37:54.847]             c <- base::c
[13:37:54.847]             inherits <- base::inherits
[13:37:54.847]             invokeRestart <- base::invokeRestart
[13:37:54.847]             length <- base::length
[13:37:54.847]             list <- base::list
[13:37:54.847]             seq.int <- base::seq.int
[13:37:54.847]             signalCondition <- base::signalCondition
[13:37:54.847]             sys.calls <- base::sys.calls
[13:37:54.847]             `[[` <- base::`[[`
[13:37:54.847]             `+` <- base::`+`
[13:37:54.847]             `<<-` <- base::`<<-`
[13:37:54.847]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:54.847]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:54.847]                   3L)]
[13:37:54.847]             }
[13:37:54.847]             function(cond) {
[13:37:54.847]                 is_error <- inherits(cond, "error")
[13:37:54.847]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:54.847]                   NULL)
[13:37:54.847]                 if (is_error) {
[13:37:54.847]                   sessionInformation <- function() {
[13:37:54.847]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:54.847]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:54.847]                       search = base::search(), system = base::Sys.info())
[13:37:54.847]                   }
[13:37:54.847]                   ...future.conditions[[length(...future.conditions) + 
[13:37:54.847]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:54.847]                     cond$call), session = sessionInformation(), 
[13:37:54.847]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:54.847]                   signalCondition(cond)
[13:37:54.847]                 }
[13:37:54.847]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:54.847]                 "immediateCondition"))) {
[13:37:54.847]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:54.847]                   ...future.conditions[[length(...future.conditions) + 
[13:37:54.847]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:54.847]                   if (TRUE && !signal) {
[13:37:54.847]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:54.847]                     {
[13:37:54.847]                       inherits <- base::inherits
[13:37:54.847]                       invokeRestart <- base::invokeRestart
[13:37:54.847]                       is.null <- base::is.null
[13:37:54.847]                       muffled <- FALSE
[13:37:54.847]                       if (inherits(cond, "message")) {
[13:37:54.847]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:54.847]                         if (muffled) 
[13:37:54.847]                           invokeRestart("muffleMessage")
[13:37:54.847]                       }
[13:37:54.847]                       else if (inherits(cond, "warning")) {
[13:37:54.847]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:54.847]                         if (muffled) 
[13:37:54.847]                           invokeRestart("muffleWarning")
[13:37:54.847]                       }
[13:37:54.847]                       else if (inherits(cond, "condition")) {
[13:37:54.847]                         if (!is.null(pattern)) {
[13:37:54.847]                           computeRestarts <- base::computeRestarts
[13:37:54.847]                           grepl <- base::grepl
[13:37:54.847]                           restarts <- computeRestarts(cond)
[13:37:54.847]                           for (restart in restarts) {
[13:37:54.847]                             name <- restart$name
[13:37:54.847]                             if (is.null(name)) 
[13:37:54.847]                               next
[13:37:54.847]                             if (!grepl(pattern, name)) 
[13:37:54.847]                               next
[13:37:54.847]                             invokeRestart(restart)
[13:37:54.847]                             muffled <- TRUE
[13:37:54.847]                             break
[13:37:54.847]                           }
[13:37:54.847]                         }
[13:37:54.847]                       }
[13:37:54.847]                       invisible(muffled)
[13:37:54.847]                     }
[13:37:54.847]                     muffleCondition(cond, pattern = "^muffle")
[13:37:54.847]                   }
[13:37:54.847]                 }
[13:37:54.847]                 else {
[13:37:54.847]                   if (TRUE) {
[13:37:54.847]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:54.847]                     {
[13:37:54.847]                       inherits <- base::inherits
[13:37:54.847]                       invokeRestart <- base::invokeRestart
[13:37:54.847]                       is.null <- base::is.null
[13:37:54.847]                       muffled <- FALSE
[13:37:54.847]                       if (inherits(cond, "message")) {
[13:37:54.847]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:54.847]                         if (muffled) 
[13:37:54.847]                           invokeRestart("muffleMessage")
[13:37:54.847]                       }
[13:37:54.847]                       else if (inherits(cond, "warning")) {
[13:37:54.847]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:54.847]                         if (muffled) 
[13:37:54.847]                           invokeRestart("muffleWarning")
[13:37:54.847]                       }
[13:37:54.847]                       else if (inherits(cond, "condition")) {
[13:37:54.847]                         if (!is.null(pattern)) {
[13:37:54.847]                           computeRestarts <- base::computeRestarts
[13:37:54.847]                           grepl <- base::grepl
[13:37:54.847]                           restarts <- computeRestarts(cond)
[13:37:54.847]                           for (restart in restarts) {
[13:37:54.847]                             name <- restart$name
[13:37:54.847]                             if (is.null(name)) 
[13:37:54.847]                               next
[13:37:54.847]                             if (!grepl(pattern, name)) 
[13:37:54.847]                               next
[13:37:54.847]                             invokeRestart(restart)
[13:37:54.847]                             muffled <- TRUE
[13:37:54.847]                             break
[13:37:54.847]                           }
[13:37:54.847]                         }
[13:37:54.847]                       }
[13:37:54.847]                       invisible(muffled)
[13:37:54.847]                     }
[13:37:54.847]                     muffleCondition(cond, pattern = "^muffle")
[13:37:54.847]                   }
[13:37:54.847]                 }
[13:37:54.847]             }
[13:37:54.847]         }))
[13:37:54.847]     }, error = function(ex) {
[13:37:54.847]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:54.847]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:54.847]                 ...future.rng), started = ...future.startTime, 
[13:37:54.847]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:54.847]             version = "1.8"), class = "FutureResult")
[13:37:54.847]     }, finally = {
[13:37:54.847]         if (!identical(...future.workdir, getwd())) 
[13:37:54.847]             setwd(...future.workdir)
[13:37:54.847]         {
[13:37:54.847]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:54.847]                 ...future.oldOptions$nwarnings <- NULL
[13:37:54.847]             }
[13:37:54.847]             base::options(...future.oldOptions)
[13:37:54.847]             if (.Platform$OS.type == "windows") {
[13:37:54.847]                 old_names <- names(...future.oldEnvVars)
[13:37:54.847]                 envs <- base::Sys.getenv()
[13:37:54.847]                 names <- names(envs)
[13:37:54.847]                 common <- intersect(names, old_names)
[13:37:54.847]                 added <- setdiff(names, old_names)
[13:37:54.847]                 removed <- setdiff(old_names, names)
[13:37:54.847]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:54.847]                   envs[common]]
[13:37:54.847]                 NAMES <- toupper(changed)
[13:37:54.847]                 args <- list()
[13:37:54.847]                 for (kk in seq_along(NAMES)) {
[13:37:54.847]                   name <- changed[[kk]]
[13:37:54.847]                   NAME <- NAMES[[kk]]
[13:37:54.847]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:54.847]                     next
[13:37:54.847]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:54.847]                 }
[13:37:54.847]                 NAMES <- toupper(added)
[13:37:54.847]                 for (kk in seq_along(NAMES)) {
[13:37:54.847]                   name <- added[[kk]]
[13:37:54.847]                   NAME <- NAMES[[kk]]
[13:37:54.847]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:54.847]                     next
[13:37:54.847]                   args[[name]] <- ""
[13:37:54.847]                 }
[13:37:54.847]                 NAMES <- toupper(removed)
[13:37:54.847]                 for (kk in seq_along(NAMES)) {
[13:37:54.847]                   name <- removed[[kk]]
[13:37:54.847]                   NAME <- NAMES[[kk]]
[13:37:54.847]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:54.847]                     next
[13:37:54.847]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:54.847]                 }
[13:37:54.847]                 if (length(args) > 0) 
[13:37:54.847]                   base::do.call(base::Sys.setenv, args = args)
[13:37:54.847]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:54.847]             }
[13:37:54.847]             else {
[13:37:54.847]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:54.847]             }
[13:37:54.847]             {
[13:37:54.847]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:54.847]                   0L) {
[13:37:54.847]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:54.847]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:54.847]                   base::options(opts)
[13:37:54.847]                 }
[13:37:54.847]                 {
[13:37:54.847]                   {
[13:37:54.847]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:54.847]                     NULL
[13:37:54.847]                   }
[13:37:54.847]                   options(future.plan = NULL)
[13:37:54.847]                   if (is.na(NA_character_)) 
[13:37:54.847]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:54.847]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:54.847]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:54.847]                     .init = FALSE)
[13:37:54.847]                 }
[13:37:54.847]             }
[13:37:54.847]         }
[13:37:54.847]     })
[13:37:54.847]     if (TRUE) {
[13:37:54.847]         base::sink(type = "output", split = FALSE)
[13:37:54.847]         if (TRUE) {
[13:37:54.847]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:54.847]         }
[13:37:54.847]         else {
[13:37:54.847]             ...future.result["stdout"] <- base::list(NULL)
[13:37:54.847]         }
[13:37:54.847]         base::close(...future.stdout)
[13:37:54.847]         ...future.stdout <- NULL
[13:37:54.847]     }
[13:37:54.847]     ...future.result$conditions <- ...future.conditions
[13:37:54.847]     ...future.result$finished <- base::Sys.time()
[13:37:54.847]     ...future.result
[13:37:54.847] }
[13:37:54.850] MultisessionFuture started
[13:37:54.850] - Launch lazy future ... done
[13:37:54.850] run() for ‘MultisessionFuture’ ... done
[13:37:54.852] receiveMessageFromWorker() for ClusterFuture ...
[13:37:54.852] - Validating connection of MultisessionFuture
[13:37:54.852] - received message: FutureResult
[13:37:54.852] - Received FutureResult
[13:37:54.852] - Erased future from FutureRegistry
[13:37:54.852] result() for ClusterFuture ...
[13:37:54.853] - result already collected: FutureResult
[13:37:54.853] result() for ClusterFuture ... done
[13:37:54.853] signalConditions() ...
[13:37:54.853]  - include = ‘immediateCondition’
[13:37:54.853]  - exclude = 
[13:37:54.853]  - resignal = FALSE
[13:37:54.853]  - Number of conditions: 1
[13:37:54.853] signalConditions() ... done
[13:37:54.853] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:54.853] A MultisessionFuture was resolved
[13:37:54.853] getGlobalsAndPackages() ...
[13:37:54.854] Searching for globals...
[13:37:54.854] - globals found: [2] ‘list’, ‘stop’
[13:37:54.854] Searching for globals ... DONE
[13:37:54.854] Resolving globals: FALSE
[13:37:54.855] 
[13:37:54.855] 
[13:37:54.855] getGlobalsAndPackages() ... DONE
[13:37:54.855] run() for ‘Future’ ...
[13:37:54.855] - state: ‘created’
[13:37:54.855] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:54.871] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:54.871] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:54.872]   - Field: ‘node’
[13:37:54.872]   - Field: ‘label’
[13:37:54.872]   - Field: ‘local’
[13:37:54.872]   - Field: ‘owner’
[13:37:54.872]   - Field: ‘envir’
[13:37:54.872]   - Field: ‘workers’
[13:37:54.872]   - Field: ‘packages’
[13:37:54.872]   - Field: ‘gc’
[13:37:54.872]   - Field: ‘conditions’
[13:37:54.872]   - Field: ‘persistent’
[13:37:54.873]   - Field: ‘expr’
[13:37:54.873]   - Field: ‘uuid’
[13:37:54.873]   - Field: ‘seed’
[13:37:54.873]   - Field: ‘version’
[13:37:54.873]   - Field: ‘result’
[13:37:54.873]   - Field: ‘asynchronous’
[13:37:54.873]   - Field: ‘calls’
[13:37:54.873]   - Field: ‘globals’
[13:37:54.873]   - Field: ‘stdout’
[13:37:54.873]   - Field: ‘earlySignal’
[13:37:54.874]   - Field: ‘lazy’
[13:37:54.874]   - Field: ‘state’
[13:37:54.874] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:54.874] - Launch lazy future ...
[13:37:54.874] Packages needed by the future expression (n = 0): <none>
[13:37:54.874] Packages needed by future strategies (n = 0): <none>
[13:37:54.875] {
[13:37:54.875]     {
[13:37:54.875]         {
[13:37:54.875]             ...future.startTime <- base::Sys.time()
[13:37:54.875]             {
[13:37:54.875]                 {
[13:37:54.875]                   {
[13:37:54.875]                     {
[13:37:54.875]                       base::local({
[13:37:54.875]                         has_future <- base::requireNamespace("future", 
[13:37:54.875]                           quietly = TRUE)
[13:37:54.875]                         if (has_future) {
[13:37:54.875]                           ns <- base::getNamespace("future")
[13:37:54.875]                           version <- ns[[".package"]][["version"]]
[13:37:54.875]                           if (is.null(version)) 
[13:37:54.875]                             version <- utils::packageVersion("future")
[13:37:54.875]                         }
[13:37:54.875]                         else {
[13:37:54.875]                           version <- NULL
[13:37:54.875]                         }
[13:37:54.875]                         if (!has_future || version < "1.8.0") {
[13:37:54.875]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:54.875]                             "", base::R.version$version.string), 
[13:37:54.875]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:54.875]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:54.875]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:54.875]                               "release", "version")], collapse = " "), 
[13:37:54.875]                             hostname = base::Sys.info()[["nodename"]])
[13:37:54.875]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:54.875]                             info)
[13:37:54.875]                           info <- base::paste(info, collapse = "; ")
[13:37:54.875]                           if (!has_future) {
[13:37:54.875]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:54.875]                               info)
[13:37:54.875]                           }
[13:37:54.875]                           else {
[13:37:54.875]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:54.875]                               info, version)
[13:37:54.875]                           }
[13:37:54.875]                           base::stop(msg)
[13:37:54.875]                         }
[13:37:54.875]                       })
[13:37:54.875]                     }
[13:37:54.875]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:54.875]                     base::options(mc.cores = 1L)
[13:37:54.875]                   }
[13:37:54.875]                   ...future.strategy.old <- future::plan("list")
[13:37:54.875]                   options(future.plan = NULL)
[13:37:54.875]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:54.875]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:54.875]                 }
[13:37:54.875]                 ...future.workdir <- getwd()
[13:37:54.875]             }
[13:37:54.875]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:54.875]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:54.875]         }
[13:37:54.875]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:54.875]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:54.875]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:54.875]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:54.875]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:54.875]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:54.875]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:54.875]             base::names(...future.oldOptions))
[13:37:54.875]     }
[13:37:54.875]     if (FALSE) {
[13:37:54.875]     }
[13:37:54.875]     else {
[13:37:54.875]         if (TRUE) {
[13:37:54.875]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:54.875]                 open = "w")
[13:37:54.875]         }
[13:37:54.875]         else {
[13:37:54.875]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:54.875]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:54.875]         }
[13:37:54.875]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:54.875]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:54.875]             base::sink(type = "output", split = FALSE)
[13:37:54.875]             base::close(...future.stdout)
[13:37:54.875]         }, add = TRUE)
[13:37:54.875]     }
[13:37:54.875]     ...future.frame <- base::sys.nframe()
[13:37:54.875]     ...future.conditions <- base::list()
[13:37:54.875]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:54.875]     if (FALSE) {
[13:37:54.875]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:54.875]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:54.875]     }
[13:37:54.875]     ...future.result <- base::tryCatch({
[13:37:54.875]         base::withCallingHandlers({
[13:37:54.875]             ...future.value <- base::withVisible(base::local({
[13:37:54.875]                 ...future.makeSendCondition <- base::local({
[13:37:54.875]                   sendCondition <- NULL
[13:37:54.875]                   function(frame = 1L) {
[13:37:54.875]                     if (is.function(sendCondition)) 
[13:37:54.875]                       return(sendCondition)
[13:37:54.875]                     ns <- getNamespace("parallel")
[13:37:54.875]                     if (exists("sendData", mode = "function", 
[13:37:54.875]                       envir = ns)) {
[13:37:54.875]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:54.875]                         envir = ns)
[13:37:54.875]                       envir <- sys.frame(frame)
[13:37:54.875]                       master <- NULL
[13:37:54.875]                       while (!identical(envir, .GlobalEnv) && 
[13:37:54.875]                         !identical(envir, emptyenv())) {
[13:37:54.875]                         if (exists("master", mode = "list", envir = envir, 
[13:37:54.875]                           inherits = FALSE)) {
[13:37:54.875]                           master <- get("master", mode = "list", 
[13:37:54.875]                             envir = envir, inherits = FALSE)
[13:37:54.875]                           if (inherits(master, c("SOCKnode", 
[13:37:54.875]                             "SOCK0node"))) {
[13:37:54.875]                             sendCondition <<- function(cond) {
[13:37:54.875]                               data <- list(type = "VALUE", value = cond, 
[13:37:54.875]                                 success = TRUE)
[13:37:54.875]                               parallel_sendData(master, data)
[13:37:54.875]                             }
[13:37:54.875]                             return(sendCondition)
[13:37:54.875]                           }
[13:37:54.875]                         }
[13:37:54.875]                         frame <- frame + 1L
[13:37:54.875]                         envir <- sys.frame(frame)
[13:37:54.875]                       }
[13:37:54.875]                     }
[13:37:54.875]                     sendCondition <<- function(cond) NULL
[13:37:54.875]                   }
[13:37:54.875]                 })
[13:37:54.875]                 withCallingHandlers({
[13:37:54.875]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:37:54.875]                 }, immediateCondition = function(cond) {
[13:37:54.875]                   sendCondition <- ...future.makeSendCondition()
[13:37:54.875]                   sendCondition(cond)
[13:37:54.875]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:54.875]                   {
[13:37:54.875]                     inherits <- base::inherits
[13:37:54.875]                     invokeRestart <- base::invokeRestart
[13:37:54.875]                     is.null <- base::is.null
[13:37:54.875]                     muffled <- FALSE
[13:37:54.875]                     if (inherits(cond, "message")) {
[13:37:54.875]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:54.875]                       if (muffled) 
[13:37:54.875]                         invokeRestart("muffleMessage")
[13:37:54.875]                     }
[13:37:54.875]                     else if (inherits(cond, "warning")) {
[13:37:54.875]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:54.875]                       if (muffled) 
[13:37:54.875]                         invokeRestart("muffleWarning")
[13:37:54.875]                     }
[13:37:54.875]                     else if (inherits(cond, "condition")) {
[13:37:54.875]                       if (!is.null(pattern)) {
[13:37:54.875]                         computeRestarts <- base::computeRestarts
[13:37:54.875]                         grepl <- base::grepl
[13:37:54.875]                         restarts <- computeRestarts(cond)
[13:37:54.875]                         for (restart in restarts) {
[13:37:54.875]                           name <- restart$name
[13:37:54.875]                           if (is.null(name)) 
[13:37:54.875]                             next
[13:37:54.875]                           if (!grepl(pattern, name)) 
[13:37:54.875]                             next
[13:37:54.875]                           invokeRestart(restart)
[13:37:54.875]                           muffled <- TRUE
[13:37:54.875]                           break
[13:37:54.875]                         }
[13:37:54.875]                       }
[13:37:54.875]                     }
[13:37:54.875]                     invisible(muffled)
[13:37:54.875]                   }
[13:37:54.875]                   muffleCondition(cond)
[13:37:54.875]                 })
[13:37:54.875]             }))
[13:37:54.875]             future::FutureResult(value = ...future.value$value, 
[13:37:54.875]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:54.875]                   ...future.rng), globalenv = if (FALSE) 
[13:37:54.875]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:54.875]                     ...future.globalenv.names))
[13:37:54.875]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:54.875]         }, condition = base::local({
[13:37:54.875]             c <- base::c
[13:37:54.875]             inherits <- base::inherits
[13:37:54.875]             invokeRestart <- base::invokeRestart
[13:37:54.875]             length <- base::length
[13:37:54.875]             list <- base::list
[13:37:54.875]             seq.int <- base::seq.int
[13:37:54.875]             signalCondition <- base::signalCondition
[13:37:54.875]             sys.calls <- base::sys.calls
[13:37:54.875]             `[[` <- base::`[[`
[13:37:54.875]             `+` <- base::`+`
[13:37:54.875]             `<<-` <- base::`<<-`
[13:37:54.875]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:54.875]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:54.875]                   3L)]
[13:37:54.875]             }
[13:37:54.875]             function(cond) {
[13:37:54.875]                 is_error <- inherits(cond, "error")
[13:37:54.875]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:54.875]                   NULL)
[13:37:54.875]                 if (is_error) {
[13:37:54.875]                   sessionInformation <- function() {
[13:37:54.875]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:54.875]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:54.875]                       search = base::search(), system = base::Sys.info())
[13:37:54.875]                   }
[13:37:54.875]                   ...future.conditions[[length(...future.conditions) + 
[13:37:54.875]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:54.875]                     cond$call), session = sessionInformation(), 
[13:37:54.875]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:54.875]                   signalCondition(cond)
[13:37:54.875]                 }
[13:37:54.875]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:54.875]                 "immediateCondition"))) {
[13:37:54.875]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:54.875]                   ...future.conditions[[length(...future.conditions) + 
[13:37:54.875]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:54.875]                   if (TRUE && !signal) {
[13:37:54.875]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:54.875]                     {
[13:37:54.875]                       inherits <- base::inherits
[13:37:54.875]                       invokeRestart <- base::invokeRestart
[13:37:54.875]                       is.null <- base::is.null
[13:37:54.875]                       muffled <- FALSE
[13:37:54.875]                       if (inherits(cond, "message")) {
[13:37:54.875]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:54.875]                         if (muffled) 
[13:37:54.875]                           invokeRestart("muffleMessage")
[13:37:54.875]                       }
[13:37:54.875]                       else if (inherits(cond, "warning")) {
[13:37:54.875]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:54.875]                         if (muffled) 
[13:37:54.875]                           invokeRestart("muffleWarning")
[13:37:54.875]                       }
[13:37:54.875]                       else if (inherits(cond, "condition")) {
[13:37:54.875]                         if (!is.null(pattern)) {
[13:37:54.875]                           computeRestarts <- base::computeRestarts
[13:37:54.875]                           grepl <- base::grepl
[13:37:54.875]                           restarts <- computeRestarts(cond)
[13:37:54.875]                           for (restart in restarts) {
[13:37:54.875]                             name <- restart$name
[13:37:54.875]                             if (is.null(name)) 
[13:37:54.875]                               next
[13:37:54.875]                             if (!grepl(pattern, name)) 
[13:37:54.875]                               next
[13:37:54.875]                             invokeRestart(restart)
[13:37:54.875]                             muffled <- TRUE
[13:37:54.875]                             break
[13:37:54.875]                           }
[13:37:54.875]                         }
[13:37:54.875]                       }
[13:37:54.875]                       invisible(muffled)
[13:37:54.875]                     }
[13:37:54.875]                     muffleCondition(cond, pattern = "^muffle")
[13:37:54.875]                   }
[13:37:54.875]                 }
[13:37:54.875]                 else {
[13:37:54.875]                   if (TRUE) {
[13:37:54.875]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:54.875]                     {
[13:37:54.875]                       inherits <- base::inherits
[13:37:54.875]                       invokeRestart <- base::invokeRestart
[13:37:54.875]                       is.null <- base::is.null
[13:37:54.875]                       muffled <- FALSE
[13:37:54.875]                       if (inherits(cond, "message")) {
[13:37:54.875]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:54.875]                         if (muffled) 
[13:37:54.875]                           invokeRestart("muffleMessage")
[13:37:54.875]                       }
[13:37:54.875]                       else if (inherits(cond, "warning")) {
[13:37:54.875]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:54.875]                         if (muffled) 
[13:37:54.875]                           invokeRestart("muffleWarning")
[13:37:54.875]                       }
[13:37:54.875]                       else if (inherits(cond, "condition")) {
[13:37:54.875]                         if (!is.null(pattern)) {
[13:37:54.875]                           computeRestarts <- base::computeRestarts
[13:37:54.875]                           grepl <- base::grepl
[13:37:54.875]                           restarts <- computeRestarts(cond)
[13:37:54.875]                           for (restart in restarts) {
[13:37:54.875]                             name <- restart$name
[13:37:54.875]                             if (is.null(name)) 
[13:37:54.875]                               next
[13:37:54.875]                             if (!grepl(pattern, name)) 
[13:37:54.875]                               next
[13:37:54.875]                             invokeRestart(restart)
[13:37:54.875]                             muffled <- TRUE
[13:37:54.875]                             break
[13:37:54.875]                           }
[13:37:54.875]                         }
[13:37:54.875]                       }
[13:37:54.875]                       invisible(muffled)
[13:37:54.875]                     }
[13:37:54.875]                     muffleCondition(cond, pattern = "^muffle")
[13:37:54.875]                   }
[13:37:54.875]                 }
[13:37:54.875]             }
[13:37:54.875]         }))
[13:37:54.875]     }, error = function(ex) {
[13:37:54.875]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:54.875]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:54.875]                 ...future.rng), started = ...future.startTime, 
[13:37:54.875]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:54.875]             version = "1.8"), class = "FutureResult")
[13:37:54.875]     }, finally = {
[13:37:54.875]         if (!identical(...future.workdir, getwd())) 
[13:37:54.875]             setwd(...future.workdir)
[13:37:54.875]         {
[13:37:54.875]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:54.875]                 ...future.oldOptions$nwarnings <- NULL
[13:37:54.875]             }
[13:37:54.875]             base::options(...future.oldOptions)
[13:37:54.875]             if (.Platform$OS.type == "windows") {
[13:37:54.875]                 old_names <- names(...future.oldEnvVars)
[13:37:54.875]                 envs <- base::Sys.getenv()
[13:37:54.875]                 names <- names(envs)
[13:37:54.875]                 common <- intersect(names, old_names)
[13:37:54.875]                 added <- setdiff(names, old_names)
[13:37:54.875]                 removed <- setdiff(old_names, names)
[13:37:54.875]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:54.875]                   envs[common]]
[13:37:54.875]                 NAMES <- toupper(changed)
[13:37:54.875]                 args <- list()
[13:37:54.875]                 for (kk in seq_along(NAMES)) {
[13:37:54.875]                   name <- changed[[kk]]
[13:37:54.875]                   NAME <- NAMES[[kk]]
[13:37:54.875]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:54.875]                     next
[13:37:54.875]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:54.875]                 }
[13:37:54.875]                 NAMES <- toupper(added)
[13:37:54.875]                 for (kk in seq_along(NAMES)) {
[13:37:54.875]                   name <- added[[kk]]
[13:37:54.875]                   NAME <- NAMES[[kk]]
[13:37:54.875]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:54.875]                     next
[13:37:54.875]                   args[[name]] <- ""
[13:37:54.875]                 }
[13:37:54.875]                 NAMES <- toupper(removed)
[13:37:54.875]                 for (kk in seq_along(NAMES)) {
[13:37:54.875]                   name <- removed[[kk]]
[13:37:54.875]                   NAME <- NAMES[[kk]]
[13:37:54.875]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:54.875]                     next
[13:37:54.875]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:54.875]                 }
[13:37:54.875]                 if (length(args) > 0) 
[13:37:54.875]                   base::do.call(base::Sys.setenv, args = args)
[13:37:54.875]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:54.875]             }
[13:37:54.875]             else {
[13:37:54.875]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:54.875]             }
[13:37:54.875]             {
[13:37:54.875]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:54.875]                   0L) {
[13:37:54.875]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:54.875]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:54.875]                   base::options(opts)
[13:37:54.875]                 }
[13:37:54.875]                 {
[13:37:54.875]                   {
[13:37:54.875]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:54.875]                     NULL
[13:37:54.875]                   }
[13:37:54.875]                   options(future.plan = NULL)
[13:37:54.875]                   if (is.na(NA_character_)) 
[13:37:54.875]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:54.875]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:54.875]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:54.875]                     .init = FALSE)
[13:37:54.875]                 }
[13:37:54.875]             }
[13:37:54.875]         }
[13:37:54.875]     })
[13:37:54.875]     if (TRUE) {
[13:37:54.875]         base::sink(type = "output", split = FALSE)
[13:37:54.875]         if (TRUE) {
[13:37:54.875]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:54.875]         }
[13:37:54.875]         else {
[13:37:54.875]             ...future.result["stdout"] <- base::list(NULL)
[13:37:54.875]         }
[13:37:54.875]         base::close(...future.stdout)
[13:37:54.875]         ...future.stdout <- NULL
[13:37:54.875]     }
[13:37:54.875]     ...future.result$conditions <- ...future.conditions
[13:37:54.875]     ...future.result$finished <- base::Sys.time()
[13:37:54.875]     ...future.result
[13:37:54.875] }
[13:37:54.877] MultisessionFuture started
[13:37:54.877] - Launch lazy future ... done
[13:37:54.878] run() for ‘MultisessionFuture’ ... done
[13:37:54.879] receiveMessageFromWorker() for ClusterFuture ...
[13:37:54.879] - Validating connection of MultisessionFuture
[13:37:54.879] - received message: FutureResult
[13:37:54.880] - Received FutureResult
[13:37:54.880] - Erased future from FutureRegistry
[13:37:54.880] result() for ClusterFuture ...
[13:37:54.880] - result already collected: FutureResult
[13:37:54.880] result() for ClusterFuture ... done
[13:37:54.880] signalConditions() ...
[13:37:54.880]  - include = ‘immediateCondition’
[13:37:54.880]  - exclude = 
[13:37:54.880]  - resignal = FALSE
[13:37:54.880]  - Number of conditions: 1
[13:37:54.880] signalConditions() ... done
[13:37:54.881] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:54.881] A MultisessionFuture was resolved
- result = TRUE, recursive = FALSE ... DONE
- result = TRUE, recursive = TRUE ...
[13:37:54.881] getGlobalsAndPackages() ...
[13:37:54.881] Searching for globals...
[13:37:54.882] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:37:54.882] Searching for globals ... DONE
[13:37:54.882] Resolving globals: FALSE
[13:37:54.883] 
[13:37:54.883] 
[13:37:54.883] getGlobalsAndPackages() ... DONE
[13:37:54.883] run() for ‘Future’ ...
[13:37:54.883] - state: ‘created’
[13:37:54.883] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:54.896] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:54.897] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:54.897]   - Field: ‘node’
[13:37:54.897]   - Field: ‘label’
[13:37:54.897]   - Field: ‘local’
[13:37:54.897]   - Field: ‘owner’
[13:37:54.897]   - Field: ‘envir’
[13:37:54.897]   - Field: ‘workers’
[13:37:54.897]   - Field: ‘packages’
[13:37:54.897]   - Field: ‘gc’
[13:37:54.897]   - Field: ‘conditions’
[13:37:54.898]   - Field: ‘persistent’
[13:37:54.898]   - Field: ‘expr’
[13:37:54.898]   - Field: ‘uuid’
[13:37:54.898]   - Field: ‘seed’
[13:37:54.898]   - Field: ‘version’
[13:37:54.898]   - Field: ‘result’
[13:37:54.898]   - Field: ‘asynchronous’
[13:37:54.898]   - Field: ‘calls’
[13:37:54.898]   - Field: ‘globals’
[13:37:54.898]   - Field: ‘stdout’
[13:37:54.899]   - Field: ‘earlySignal’
[13:37:54.899]   - Field: ‘lazy’
[13:37:54.899]   - Field: ‘state’
[13:37:54.899] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:54.899] - Launch lazy future ...
[13:37:54.899] Packages needed by the future expression (n = 0): <none>
[13:37:54.899] Packages needed by future strategies (n = 0): <none>
[13:37:54.900] {
[13:37:54.900]     {
[13:37:54.900]         {
[13:37:54.900]             ...future.startTime <- base::Sys.time()
[13:37:54.900]             {
[13:37:54.900]                 {
[13:37:54.900]                   {
[13:37:54.900]                     {
[13:37:54.900]                       base::local({
[13:37:54.900]                         has_future <- base::requireNamespace("future", 
[13:37:54.900]                           quietly = TRUE)
[13:37:54.900]                         if (has_future) {
[13:37:54.900]                           ns <- base::getNamespace("future")
[13:37:54.900]                           version <- ns[[".package"]][["version"]]
[13:37:54.900]                           if (is.null(version)) 
[13:37:54.900]                             version <- utils::packageVersion("future")
[13:37:54.900]                         }
[13:37:54.900]                         else {
[13:37:54.900]                           version <- NULL
[13:37:54.900]                         }
[13:37:54.900]                         if (!has_future || version < "1.8.0") {
[13:37:54.900]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:54.900]                             "", base::R.version$version.string), 
[13:37:54.900]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:54.900]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:54.900]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:54.900]                               "release", "version")], collapse = " "), 
[13:37:54.900]                             hostname = base::Sys.info()[["nodename"]])
[13:37:54.900]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:54.900]                             info)
[13:37:54.900]                           info <- base::paste(info, collapse = "; ")
[13:37:54.900]                           if (!has_future) {
[13:37:54.900]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:54.900]                               info)
[13:37:54.900]                           }
[13:37:54.900]                           else {
[13:37:54.900]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:54.900]                               info, version)
[13:37:54.900]                           }
[13:37:54.900]                           base::stop(msg)
[13:37:54.900]                         }
[13:37:54.900]                       })
[13:37:54.900]                     }
[13:37:54.900]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:54.900]                     base::options(mc.cores = 1L)
[13:37:54.900]                   }
[13:37:54.900]                   ...future.strategy.old <- future::plan("list")
[13:37:54.900]                   options(future.plan = NULL)
[13:37:54.900]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:54.900]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:54.900]                 }
[13:37:54.900]                 ...future.workdir <- getwd()
[13:37:54.900]             }
[13:37:54.900]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:54.900]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:54.900]         }
[13:37:54.900]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:54.900]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:54.900]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:54.900]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:54.900]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:54.900]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:54.900]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:54.900]             base::names(...future.oldOptions))
[13:37:54.900]     }
[13:37:54.900]     if (FALSE) {
[13:37:54.900]     }
[13:37:54.900]     else {
[13:37:54.900]         if (TRUE) {
[13:37:54.900]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:54.900]                 open = "w")
[13:37:54.900]         }
[13:37:54.900]         else {
[13:37:54.900]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:54.900]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:54.900]         }
[13:37:54.900]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:54.900]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:54.900]             base::sink(type = "output", split = FALSE)
[13:37:54.900]             base::close(...future.stdout)
[13:37:54.900]         }, add = TRUE)
[13:37:54.900]     }
[13:37:54.900]     ...future.frame <- base::sys.nframe()
[13:37:54.900]     ...future.conditions <- base::list()
[13:37:54.900]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:54.900]     if (FALSE) {
[13:37:54.900]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:54.900]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:54.900]     }
[13:37:54.900]     ...future.result <- base::tryCatch({
[13:37:54.900]         base::withCallingHandlers({
[13:37:54.900]             ...future.value <- base::withVisible(base::local({
[13:37:54.900]                 ...future.makeSendCondition <- base::local({
[13:37:54.900]                   sendCondition <- NULL
[13:37:54.900]                   function(frame = 1L) {
[13:37:54.900]                     if (is.function(sendCondition)) 
[13:37:54.900]                       return(sendCondition)
[13:37:54.900]                     ns <- getNamespace("parallel")
[13:37:54.900]                     if (exists("sendData", mode = "function", 
[13:37:54.900]                       envir = ns)) {
[13:37:54.900]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:54.900]                         envir = ns)
[13:37:54.900]                       envir <- sys.frame(frame)
[13:37:54.900]                       master <- NULL
[13:37:54.900]                       while (!identical(envir, .GlobalEnv) && 
[13:37:54.900]                         !identical(envir, emptyenv())) {
[13:37:54.900]                         if (exists("master", mode = "list", envir = envir, 
[13:37:54.900]                           inherits = FALSE)) {
[13:37:54.900]                           master <- get("master", mode = "list", 
[13:37:54.900]                             envir = envir, inherits = FALSE)
[13:37:54.900]                           if (inherits(master, c("SOCKnode", 
[13:37:54.900]                             "SOCK0node"))) {
[13:37:54.900]                             sendCondition <<- function(cond) {
[13:37:54.900]                               data <- list(type = "VALUE", value = cond, 
[13:37:54.900]                                 success = TRUE)
[13:37:54.900]                               parallel_sendData(master, data)
[13:37:54.900]                             }
[13:37:54.900]                             return(sendCondition)
[13:37:54.900]                           }
[13:37:54.900]                         }
[13:37:54.900]                         frame <- frame + 1L
[13:37:54.900]                         envir <- sys.frame(frame)
[13:37:54.900]                       }
[13:37:54.900]                     }
[13:37:54.900]                     sendCondition <<- function(cond) NULL
[13:37:54.900]                   }
[13:37:54.900]                 })
[13:37:54.900]                 withCallingHandlers({
[13:37:54.900]                   {
[13:37:54.900]                     Sys.sleep(0.5)
[13:37:54.900]                     list(a = 1, b = 42L)
[13:37:54.900]                   }
[13:37:54.900]                 }, immediateCondition = function(cond) {
[13:37:54.900]                   sendCondition <- ...future.makeSendCondition()
[13:37:54.900]                   sendCondition(cond)
[13:37:54.900]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:54.900]                   {
[13:37:54.900]                     inherits <- base::inherits
[13:37:54.900]                     invokeRestart <- base::invokeRestart
[13:37:54.900]                     is.null <- base::is.null
[13:37:54.900]                     muffled <- FALSE
[13:37:54.900]                     if (inherits(cond, "message")) {
[13:37:54.900]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:54.900]                       if (muffled) 
[13:37:54.900]                         invokeRestart("muffleMessage")
[13:37:54.900]                     }
[13:37:54.900]                     else if (inherits(cond, "warning")) {
[13:37:54.900]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:54.900]                       if (muffled) 
[13:37:54.900]                         invokeRestart("muffleWarning")
[13:37:54.900]                     }
[13:37:54.900]                     else if (inherits(cond, "condition")) {
[13:37:54.900]                       if (!is.null(pattern)) {
[13:37:54.900]                         computeRestarts <- base::computeRestarts
[13:37:54.900]                         grepl <- base::grepl
[13:37:54.900]                         restarts <- computeRestarts(cond)
[13:37:54.900]                         for (restart in restarts) {
[13:37:54.900]                           name <- restart$name
[13:37:54.900]                           if (is.null(name)) 
[13:37:54.900]                             next
[13:37:54.900]                           if (!grepl(pattern, name)) 
[13:37:54.900]                             next
[13:37:54.900]                           invokeRestart(restart)
[13:37:54.900]                           muffled <- TRUE
[13:37:54.900]                           break
[13:37:54.900]                         }
[13:37:54.900]                       }
[13:37:54.900]                     }
[13:37:54.900]                     invisible(muffled)
[13:37:54.900]                   }
[13:37:54.900]                   muffleCondition(cond)
[13:37:54.900]                 })
[13:37:54.900]             }))
[13:37:54.900]             future::FutureResult(value = ...future.value$value, 
[13:37:54.900]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:54.900]                   ...future.rng), globalenv = if (FALSE) 
[13:37:54.900]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:54.900]                     ...future.globalenv.names))
[13:37:54.900]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:54.900]         }, condition = base::local({
[13:37:54.900]             c <- base::c
[13:37:54.900]             inherits <- base::inherits
[13:37:54.900]             invokeRestart <- base::invokeRestart
[13:37:54.900]             length <- base::length
[13:37:54.900]             list <- base::list
[13:37:54.900]             seq.int <- base::seq.int
[13:37:54.900]             signalCondition <- base::signalCondition
[13:37:54.900]             sys.calls <- base::sys.calls
[13:37:54.900]             `[[` <- base::`[[`
[13:37:54.900]             `+` <- base::`+`
[13:37:54.900]             `<<-` <- base::`<<-`
[13:37:54.900]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:54.900]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:54.900]                   3L)]
[13:37:54.900]             }
[13:37:54.900]             function(cond) {
[13:37:54.900]                 is_error <- inherits(cond, "error")
[13:37:54.900]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:54.900]                   NULL)
[13:37:54.900]                 if (is_error) {
[13:37:54.900]                   sessionInformation <- function() {
[13:37:54.900]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:54.900]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:54.900]                       search = base::search(), system = base::Sys.info())
[13:37:54.900]                   }
[13:37:54.900]                   ...future.conditions[[length(...future.conditions) + 
[13:37:54.900]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:54.900]                     cond$call), session = sessionInformation(), 
[13:37:54.900]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:54.900]                   signalCondition(cond)
[13:37:54.900]                 }
[13:37:54.900]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:54.900]                 "immediateCondition"))) {
[13:37:54.900]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:54.900]                   ...future.conditions[[length(...future.conditions) + 
[13:37:54.900]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:54.900]                   if (TRUE && !signal) {
[13:37:54.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:54.900]                     {
[13:37:54.900]                       inherits <- base::inherits
[13:37:54.900]                       invokeRestart <- base::invokeRestart
[13:37:54.900]                       is.null <- base::is.null
[13:37:54.900]                       muffled <- FALSE
[13:37:54.900]                       if (inherits(cond, "message")) {
[13:37:54.900]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:54.900]                         if (muffled) 
[13:37:54.900]                           invokeRestart("muffleMessage")
[13:37:54.900]                       }
[13:37:54.900]                       else if (inherits(cond, "warning")) {
[13:37:54.900]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:54.900]                         if (muffled) 
[13:37:54.900]                           invokeRestart("muffleWarning")
[13:37:54.900]                       }
[13:37:54.900]                       else if (inherits(cond, "condition")) {
[13:37:54.900]                         if (!is.null(pattern)) {
[13:37:54.900]                           computeRestarts <- base::computeRestarts
[13:37:54.900]                           grepl <- base::grepl
[13:37:54.900]                           restarts <- computeRestarts(cond)
[13:37:54.900]                           for (restart in restarts) {
[13:37:54.900]                             name <- restart$name
[13:37:54.900]                             if (is.null(name)) 
[13:37:54.900]                               next
[13:37:54.900]                             if (!grepl(pattern, name)) 
[13:37:54.900]                               next
[13:37:54.900]                             invokeRestart(restart)
[13:37:54.900]                             muffled <- TRUE
[13:37:54.900]                             break
[13:37:54.900]                           }
[13:37:54.900]                         }
[13:37:54.900]                       }
[13:37:54.900]                       invisible(muffled)
[13:37:54.900]                     }
[13:37:54.900]                     muffleCondition(cond, pattern = "^muffle")
[13:37:54.900]                   }
[13:37:54.900]                 }
[13:37:54.900]                 else {
[13:37:54.900]                   if (TRUE) {
[13:37:54.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:54.900]                     {
[13:37:54.900]                       inherits <- base::inherits
[13:37:54.900]                       invokeRestart <- base::invokeRestart
[13:37:54.900]                       is.null <- base::is.null
[13:37:54.900]                       muffled <- FALSE
[13:37:54.900]                       if (inherits(cond, "message")) {
[13:37:54.900]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:54.900]                         if (muffled) 
[13:37:54.900]                           invokeRestart("muffleMessage")
[13:37:54.900]                       }
[13:37:54.900]                       else if (inherits(cond, "warning")) {
[13:37:54.900]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:54.900]                         if (muffled) 
[13:37:54.900]                           invokeRestart("muffleWarning")
[13:37:54.900]                       }
[13:37:54.900]                       else if (inherits(cond, "condition")) {
[13:37:54.900]                         if (!is.null(pattern)) {
[13:37:54.900]                           computeRestarts <- base::computeRestarts
[13:37:54.900]                           grepl <- base::grepl
[13:37:54.900]                           restarts <- computeRestarts(cond)
[13:37:54.900]                           for (restart in restarts) {
[13:37:54.900]                             name <- restart$name
[13:37:54.900]                             if (is.null(name)) 
[13:37:54.900]                               next
[13:37:54.900]                             if (!grepl(pattern, name)) 
[13:37:54.900]                               next
[13:37:54.900]                             invokeRestart(restart)
[13:37:54.900]                             muffled <- TRUE
[13:37:54.900]                             break
[13:37:54.900]                           }
[13:37:54.900]                         }
[13:37:54.900]                       }
[13:37:54.900]                       invisible(muffled)
[13:37:54.900]                     }
[13:37:54.900]                     muffleCondition(cond, pattern = "^muffle")
[13:37:54.900]                   }
[13:37:54.900]                 }
[13:37:54.900]             }
[13:37:54.900]         }))
[13:37:54.900]     }, error = function(ex) {
[13:37:54.900]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:54.900]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:54.900]                 ...future.rng), started = ...future.startTime, 
[13:37:54.900]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:54.900]             version = "1.8"), class = "FutureResult")
[13:37:54.900]     }, finally = {
[13:37:54.900]         if (!identical(...future.workdir, getwd())) 
[13:37:54.900]             setwd(...future.workdir)
[13:37:54.900]         {
[13:37:54.900]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:54.900]                 ...future.oldOptions$nwarnings <- NULL
[13:37:54.900]             }
[13:37:54.900]             base::options(...future.oldOptions)
[13:37:54.900]             if (.Platform$OS.type == "windows") {
[13:37:54.900]                 old_names <- names(...future.oldEnvVars)
[13:37:54.900]                 envs <- base::Sys.getenv()
[13:37:54.900]                 names <- names(envs)
[13:37:54.900]                 common <- intersect(names, old_names)
[13:37:54.900]                 added <- setdiff(names, old_names)
[13:37:54.900]                 removed <- setdiff(old_names, names)
[13:37:54.900]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:54.900]                   envs[common]]
[13:37:54.900]                 NAMES <- toupper(changed)
[13:37:54.900]                 args <- list()
[13:37:54.900]                 for (kk in seq_along(NAMES)) {
[13:37:54.900]                   name <- changed[[kk]]
[13:37:54.900]                   NAME <- NAMES[[kk]]
[13:37:54.900]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:54.900]                     next
[13:37:54.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:54.900]                 }
[13:37:54.900]                 NAMES <- toupper(added)
[13:37:54.900]                 for (kk in seq_along(NAMES)) {
[13:37:54.900]                   name <- added[[kk]]
[13:37:54.900]                   NAME <- NAMES[[kk]]
[13:37:54.900]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:54.900]                     next
[13:37:54.900]                   args[[name]] <- ""
[13:37:54.900]                 }
[13:37:54.900]                 NAMES <- toupper(removed)
[13:37:54.900]                 for (kk in seq_along(NAMES)) {
[13:37:54.900]                   name <- removed[[kk]]
[13:37:54.900]                   NAME <- NAMES[[kk]]
[13:37:54.900]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:54.900]                     next
[13:37:54.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:54.900]                 }
[13:37:54.900]                 if (length(args) > 0) 
[13:37:54.900]                   base::do.call(base::Sys.setenv, args = args)
[13:37:54.900]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:54.900]             }
[13:37:54.900]             else {
[13:37:54.900]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:54.900]             }
[13:37:54.900]             {
[13:37:54.900]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:54.900]                   0L) {
[13:37:54.900]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:54.900]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:54.900]                   base::options(opts)
[13:37:54.900]                 }
[13:37:54.900]                 {
[13:37:54.900]                   {
[13:37:54.900]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:54.900]                     NULL
[13:37:54.900]                   }
[13:37:54.900]                   options(future.plan = NULL)
[13:37:54.900]                   if (is.na(NA_character_)) 
[13:37:54.900]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:54.900]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:54.900]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:54.900]                     .init = FALSE)
[13:37:54.900]                 }
[13:37:54.900]             }
[13:37:54.900]         }
[13:37:54.900]     })
[13:37:54.900]     if (TRUE) {
[13:37:54.900]         base::sink(type = "output", split = FALSE)
[13:37:54.900]         if (TRUE) {
[13:37:54.900]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:54.900]         }
[13:37:54.900]         else {
[13:37:54.900]             ...future.result["stdout"] <- base::list(NULL)
[13:37:54.900]         }
[13:37:54.900]         base::close(...future.stdout)
[13:37:54.900]         ...future.stdout <- NULL
[13:37:54.900]     }
[13:37:54.900]     ...future.result$conditions <- ...future.conditions
[13:37:54.900]     ...future.result$finished <- base::Sys.time()
[13:37:54.900]     ...future.result
[13:37:54.900] }
[13:37:54.902] MultisessionFuture started
[13:37:54.903] - Launch lazy future ... done
[13:37:54.903] run() for ‘MultisessionFuture’ ... done
[13:37:55.405] receiveMessageFromWorker() for ClusterFuture ...
[13:37:55.405] - Validating connection of MultisessionFuture
[13:37:55.405] - received message: FutureResult
[13:37:55.405] - Received FutureResult
[13:37:55.406] - Erased future from FutureRegistry
[13:37:55.406] result() for ClusterFuture ...
[13:37:55.406] - result already collected: FutureResult
[13:37:55.406] result() for ClusterFuture ... done
[13:37:55.406] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:55.406] resolve() on list ...
[13:37:55.406]  recursive: 98
[13:37:55.406]  length: 2
[13:37:55.406]  elements: ‘a’, ‘b’
[13:37:55.406]  length: 1 (resolved future 1)
[13:37:55.407]  length: 0 (resolved future 2)
[13:37:55.407] resolve() on list ... DONE
[13:37:55.407] A MultisessionFuture was resolved (and resolved itself)
[13:37:55.407] getGlobalsAndPackages() ...
[13:37:55.407] Searching for globals...
[13:37:55.408] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:37:55.408] Searching for globals ... DONE
[13:37:55.408] Resolving globals: FALSE
[13:37:55.409] 
[13:37:55.409] 
[13:37:55.409] getGlobalsAndPackages() ... DONE
[13:37:55.409] run() for ‘Future’ ...
[13:37:55.409] - state: ‘created’
[13:37:55.409] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:55.423] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:55.423] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:55.424]   - Field: ‘node’
[13:37:55.424]   - Field: ‘label’
[13:37:55.424]   - Field: ‘local’
[13:37:55.424]   - Field: ‘owner’
[13:37:55.424]   - Field: ‘envir’
[13:37:55.424]   - Field: ‘workers’
[13:37:55.424]   - Field: ‘packages’
[13:37:55.424]   - Field: ‘gc’
[13:37:55.424]   - Field: ‘conditions’
[13:37:55.424]   - Field: ‘persistent’
[13:37:55.424]   - Field: ‘expr’
[13:37:55.425]   - Field: ‘uuid’
[13:37:55.425]   - Field: ‘seed’
[13:37:55.425]   - Field: ‘version’
[13:37:55.425]   - Field: ‘result’
[13:37:55.425]   - Field: ‘asynchronous’
[13:37:55.425]   - Field: ‘calls’
[13:37:55.425]   - Field: ‘globals’
[13:37:55.425]   - Field: ‘stdout’
[13:37:55.425]   - Field: ‘earlySignal’
[13:37:55.425]   - Field: ‘lazy’
[13:37:55.425]   - Field: ‘state’
[13:37:55.426] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:55.426] - Launch lazy future ...
[13:37:55.426] Packages needed by the future expression (n = 0): <none>
[13:37:55.426] Packages needed by future strategies (n = 0): <none>
[13:37:55.426] {
[13:37:55.426]     {
[13:37:55.426]         {
[13:37:55.426]             ...future.startTime <- base::Sys.time()
[13:37:55.426]             {
[13:37:55.426]                 {
[13:37:55.426]                   {
[13:37:55.426]                     {
[13:37:55.426]                       base::local({
[13:37:55.426]                         has_future <- base::requireNamespace("future", 
[13:37:55.426]                           quietly = TRUE)
[13:37:55.426]                         if (has_future) {
[13:37:55.426]                           ns <- base::getNamespace("future")
[13:37:55.426]                           version <- ns[[".package"]][["version"]]
[13:37:55.426]                           if (is.null(version)) 
[13:37:55.426]                             version <- utils::packageVersion("future")
[13:37:55.426]                         }
[13:37:55.426]                         else {
[13:37:55.426]                           version <- NULL
[13:37:55.426]                         }
[13:37:55.426]                         if (!has_future || version < "1.8.0") {
[13:37:55.426]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:55.426]                             "", base::R.version$version.string), 
[13:37:55.426]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:55.426]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:55.426]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:55.426]                               "release", "version")], collapse = " "), 
[13:37:55.426]                             hostname = base::Sys.info()[["nodename"]])
[13:37:55.426]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:55.426]                             info)
[13:37:55.426]                           info <- base::paste(info, collapse = "; ")
[13:37:55.426]                           if (!has_future) {
[13:37:55.426]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:55.426]                               info)
[13:37:55.426]                           }
[13:37:55.426]                           else {
[13:37:55.426]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:55.426]                               info, version)
[13:37:55.426]                           }
[13:37:55.426]                           base::stop(msg)
[13:37:55.426]                         }
[13:37:55.426]                       })
[13:37:55.426]                     }
[13:37:55.426]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:55.426]                     base::options(mc.cores = 1L)
[13:37:55.426]                   }
[13:37:55.426]                   ...future.strategy.old <- future::plan("list")
[13:37:55.426]                   options(future.plan = NULL)
[13:37:55.426]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:55.426]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:55.426]                 }
[13:37:55.426]                 ...future.workdir <- getwd()
[13:37:55.426]             }
[13:37:55.426]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:55.426]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:55.426]         }
[13:37:55.426]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:55.426]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:55.426]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:55.426]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:55.426]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:55.426]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:55.426]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:55.426]             base::names(...future.oldOptions))
[13:37:55.426]     }
[13:37:55.426]     if (FALSE) {
[13:37:55.426]     }
[13:37:55.426]     else {
[13:37:55.426]         if (TRUE) {
[13:37:55.426]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:55.426]                 open = "w")
[13:37:55.426]         }
[13:37:55.426]         else {
[13:37:55.426]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:55.426]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:55.426]         }
[13:37:55.426]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:55.426]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:55.426]             base::sink(type = "output", split = FALSE)
[13:37:55.426]             base::close(...future.stdout)
[13:37:55.426]         }, add = TRUE)
[13:37:55.426]     }
[13:37:55.426]     ...future.frame <- base::sys.nframe()
[13:37:55.426]     ...future.conditions <- base::list()
[13:37:55.426]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:55.426]     if (FALSE) {
[13:37:55.426]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:55.426]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:55.426]     }
[13:37:55.426]     ...future.result <- base::tryCatch({
[13:37:55.426]         base::withCallingHandlers({
[13:37:55.426]             ...future.value <- base::withVisible(base::local({
[13:37:55.426]                 ...future.makeSendCondition <- base::local({
[13:37:55.426]                   sendCondition <- NULL
[13:37:55.426]                   function(frame = 1L) {
[13:37:55.426]                     if (is.function(sendCondition)) 
[13:37:55.426]                       return(sendCondition)
[13:37:55.426]                     ns <- getNamespace("parallel")
[13:37:55.426]                     if (exists("sendData", mode = "function", 
[13:37:55.426]                       envir = ns)) {
[13:37:55.426]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:55.426]                         envir = ns)
[13:37:55.426]                       envir <- sys.frame(frame)
[13:37:55.426]                       master <- NULL
[13:37:55.426]                       while (!identical(envir, .GlobalEnv) && 
[13:37:55.426]                         !identical(envir, emptyenv())) {
[13:37:55.426]                         if (exists("master", mode = "list", envir = envir, 
[13:37:55.426]                           inherits = FALSE)) {
[13:37:55.426]                           master <- get("master", mode = "list", 
[13:37:55.426]                             envir = envir, inherits = FALSE)
[13:37:55.426]                           if (inherits(master, c("SOCKnode", 
[13:37:55.426]                             "SOCK0node"))) {
[13:37:55.426]                             sendCondition <<- function(cond) {
[13:37:55.426]                               data <- list(type = "VALUE", value = cond, 
[13:37:55.426]                                 success = TRUE)
[13:37:55.426]                               parallel_sendData(master, data)
[13:37:55.426]                             }
[13:37:55.426]                             return(sendCondition)
[13:37:55.426]                           }
[13:37:55.426]                         }
[13:37:55.426]                         frame <- frame + 1L
[13:37:55.426]                         envir <- sys.frame(frame)
[13:37:55.426]                       }
[13:37:55.426]                     }
[13:37:55.426]                     sendCondition <<- function(cond) NULL
[13:37:55.426]                   }
[13:37:55.426]                 })
[13:37:55.426]                 withCallingHandlers({
[13:37:55.426]                   {
[13:37:55.426]                     Sys.sleep(0.5)
[13:37:55.426]                     list(a = 1, b = 42L)
[13:37:55.426]                   }
[13:37:55.426]                 }, immediateCondition = function(cond) {
[13:37:55.426]                   sendCondition <- ...future.makeSendCondition()
[13:37:55.426]                   sendCondition(cond)
[13:37:55.426]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:55.426]                   {
[13:37:55.426]                     inherits <- base::inherits
[13:37:55.426]                     invokeRestart <- base::invokeRestart
[13:37:55.426]                     is.null <- base::is.null
[13:37:55.426]                     muffled <- FALSE
[13:37:55.426]                     if (inherits(cond, "message")) {
[13:37:55.426]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:55.426]                       if (muffled) 
[13:37:55.426]                         invokeRestart("muffleMessage")
[13:37:55.426]                     }
[13:37:55.426]                     else if (inherits(cond, "warning")) {
[13:37:55.426]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:55.426]                       if (muffled) 
[13:37:55.426]                         invokeRestart("muffleWarning")
[13:37:55.426]                     }
[13:37:55.426]                     else if (inherits(cond, "condition")) {
[13:37:55.426]                       if (!is.null(pattern)) {
[13:37:55.426]                         computeRestarts <- base::computeRestarts
[13:37:55.426]                         grepl <- base::grepl
[13:37:55.426]                         restarts <- computeRestarts(cond)
[13:37:55.426]                         for (restart in restarts) {
[13:37:55.426]                           name <- restart$name
[13:37:55.426]                           if (is.null(name)) 
[13:37:55.426]                             next
[13:37:55.426]                           if (!grepl(pattern, name)) 
[13:37:55.426]                             next
[13:37:55.426]                           invokeRestart(restart)
[13:37:55.426]                           muffled <- TRUE
[13:37:55.426]                           break
[13:37:55.426]                         }
[13:37:55.426]                       }
[13:37:55.426]                     }
[13:37:55.426]                     invisible(muffled)
[13:37:55.426]                   }
[13:37:55.426]                   muffleCondition(cond)
[13:37:55.426]                 })
[13:37:55.426]             }))
[13:37:55.426]             future::FutureResult(value = ...future.value$value, 
[13:37:55.426]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:55.426]                   ...future.rng), globalenv = if (FALSE) 
[13:37:55.426]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:55.426]                     ...future.globalenv.names))
[13:37:55.426]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:55.426]         }, condition = base::local({
[13:37:55.426]             c <- base::c
[13:37:55.426]             inherits <- base::inherits
[13:37:55.426]             invokeRestart <- base::invokeRestart
[13:37:55.426]             length <- base::length
[13:37:55.426]             list <- base::list
[13:37:55.426]             seq.int <- base::seq.int
[13:37:55.426]             signalCondition <- base::signalCondition
[13:37:55.426]             sys.calls <- base::sys.calls
[13:37:55.426]             `[[` <- base::`[[`
[13:37:55.426]             `+` <- base::`+`
[13:37:55.426]             `<<-` <- base::`<<-`
[13:37:55.426]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:55.426]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:55.426]                   3L)]
[13:37:55.426]             }
[13:37:55.426]             function(cond) {
[13:37:55.426]                 is_error <- inherits(cond, "error")
[13:37:55.426]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:55.426]                   NULL)
[13:37:55.426]                 if (is_error) {
[13:37:55.426]                   sessionInformation <- function() {
[13:37:55.426]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:55.426]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:55.426]                       search = base::search(), system = base::Sys.info())
[13:37:55.426]                   }
[13:37:55.426]                   ...future.conditions[[length(...future.conditions) + 
[13:37:55.426]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:55.426]                     cond$call), session = sessionInformation(), 
[13:37:55.426]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:55.426]                   signalCondition(cond)
[13:37:55.426]                 }
[13:37:55.426]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:55.426]                 "immediateCondition"))) {
[13:37:55.426]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:55.426]                   ...future.conditions[[length(...future.conditions) + 
[13:37:55.426]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:55.426]                   if (TRUE && !signal) {
[13:37:55.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:55.426]                     {
[13:37:55.426]                       inherits <- base::inherits
[13:37:55.426]                       invokeRestart <- base::invokeRestart
[13:37:55.426]                       is.null <- base::is.null
[13:37:55.426]                       muffled <- FALSE
[13:37:55.426]                       if (inherits(cond, "message")) {
[13:37:55.426]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:55.426]                         if (muffled) 
[13:37:55.426]                           invokeRestart("muffleMessage")
[13:37:55.426]                       }
[13:37:55.426]                       else if (inherits(cond, "warning")) {
[13:37:55.426]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:55.426]                         if (muffled) 
[13:37:55.426]                           invokeRestart("muffleWarning")
[13:37:55.426]                       }
[13:37:55.426]                       else if (inherits(cond, "condition")) {
[13:37:55.426]                         if (!is.null(pattern)) {
[13:37:55.426]                           computeRestarts <- base::computeRestarts
[13:37:55.426]                           grepl <- base::grepl
[13:37:55.426]                           restarts <- computeRestarts(cond)
[13:37:55.426]                           for (restart in restarts) {
[13:37:55.426]                             name <- restart$name
[13:37:55.426]                             if (is.null(name)) 
[13:37:55.426]                               next
[13:37:55.426]                             if (!grepl(pattern, name)) 
[13:37:55.426]                               next
[13:37:55.426]                             invokeRestart(restart)
[13:37:55.426]                             muffled <- TRUE
[13:37:55.426]                             break
[13:37:55.426]                           }
[13:37:55.426]                         }
[13:37:55.426]                       }
[13:37:55.426]                       invisible(muffled)
[13:37:55.426]                     }
[13:37:55.426]                     muffleCondition(cond, pattern = "^muffle")
[13:37:55.426]                   }
[13:37:55.426]                 }
[13:37:55.426]                 else {
[13:37:55.426]                   if (TRUE) {
[13:37:55.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:55.426]                     {
[13:37:55.426]                       inherits <- base::inherits
[13:37:55.426]                       invokeRestart <- base::invokeRestart
[13:37:55.426]                       is.null <- base::is.null
[13:37:55.426]                       muffled <- FALSE
[13:37:55.426]                       if (inherits(cond, "message")) {
[13:37:55.426]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:55.426]                         if (muffled) 
[13:37:55.426]                           invokeRestart("muffleMessage")
[13:37:55.426]                       }
[13:37:55.426]                       else if (inherits(cond, "warning")) {
[13:37:55.426]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:55.426]                         if (muffled) 
[13:37:55.426]                           invokeRestart("muffleWarning")
[13:37:55.426]                       }
[13:37:55.426]                       else if (inherits(cond, "condition")) {
[13:37:55.426]                         if (!is.null(pattern)) {
[13:37:55.426]                           computeRestarts <- base::computeRestarts
[13:37:55.426]                           grepl <- base::grepl
[13:37:55.426]                           restarts <- computeRestarts(cond)
[13:37:55.426]                           for (restart in restarts) {
[13:37:55.426]                             name <- restart$name
[13:37:55.426]                             if (is.null(name)) 
[13:37:55.426]                               next
[13:37:55.426]                             if (!grepl(pattern, name)) 
[13:37:55.426]                               next
[13:37:55.426]                             invokeRestart(restart)
[13:37:55.426]                             muffled <- TRUE
[13:37:55.426]                             break
[13:37:55.426]                           }
[13:37:55.426]                         }
[13:37:55.426]                       }
[13:37:55.426]                       invisible(muffled)
[13:37:55.426]                     }
[13:37:55.426]                     muffleCondition(cond, pattern = "^muffle")
[13:37:55.426]                   }
[13:37:55.426]                 }
[13:37:55.426]             }
[13:37:55.426]         }))
[13:37:55.426]     }, error = function(ex) {
[13:37:55.426]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:55.426]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:55.426]                 ...future.rng), started = ...future.startTime, 
[13:37:55.426]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:55.426]             version = "1.8"), class = "FutureResult")
[13:37:55.426]     }, finally = {
[13:37:55.426]         if (!identical(...future.workdir, getwd())) 
[13:37:55.426]             setwd(...future.workdir)
[13:37:55.426]         {
[13:37:55.426]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:55.426]                 ...future.oldOptions$nwarnings <- NULL
[13:37:55.426]             }
[13:37:55.426]             base::options(...future.oldOptions)
[13:37:55.426]             if (.Platform$OS.type == "windows") {
[13:37:55.426]                 old_names <- names(...future.oldEnvVars)
[13:37:55.426]                 envs <- base::Sys.getenv()
[13:37:55.426]                 names <- names(envs)
[13:37:55.426]                 common <- intersect(names, old_names)
[13:37:55.426]                 added <- setdiff(names, old_names)
[13:37:55.426]                 removed <- setdiff(old_names, names)
[13:37:55.426]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:55.426]                   envs[common]]
[13:37:55.426]                 NAMES <- toupper(changed)
[13:37:55.426]                 args <- list()
[13:37:55.426]                 for (kk in seq_along(NAMES)) {
[13:37:55.426]                   name <- changed[[kk]]
[13:37:55.426]                   NAME <- NAMES[[kk]]
[13:37:55.426]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:55.426]                     next
[13:37:55.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:55.426]                 }
[13:37:55.426]                 NAMES <- toupper(added)
[13:37:55.426]                 for (kk in seq_along(NAMES)) {
[13:37:55.426]                   name <- added[[kk]]
[13:37:55.426]                   NAME <- NAMES[[kk]]
[13:37:55.426]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:55.426]                     next
[13:37:55.426]                   args[[name]] <- ""
[13:37:55.426]                 }
[13:37:55.426]                 NAMES <- toupper(removed)
[13:37:55.426]                 for (kk in seq_along(NAMES)) {
[13:37:55.426]                   name <- removed[[kk]]
[13:37:55.426]                   NAME <- NAMES[[kk]]
[13:37:55.426]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:55.426]                     next
[13:37:55.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:55.426]                 }
[13:37:55.426]                 if (length(args) > 0) 
[13:37:55.426]                   base::do.call(base::Sys.setenv, args = args)
[13:37:55.426]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:55.426]             }
[13:37:55.426]             else {
[13:37:55.426]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:55.426]             }
[13:37:55.426]             {
[13:37:55.426]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:55.426]                   0L) {
[13:37:55.426]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:55.426]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:55.426]                   base::options(opts)
[13:37:55.426]                 }
[13:37:55.426]                 {
[13:37:55.426]                   {
[13:37:55.426]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:55.426]                     NULL
[13:37:55.426]                   }
[13:37:55.426]                   options(future.plan = NULL)
[13:37:55.426]                   if (is.na(NA_character_)) 
[13:37:55.426]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:55.426]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:55.426]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:55.426]                     .init = FALSE)
[13:37:55.426]                 }
[13:37:55.426]             }
[13:37:55.426]         }
[13:37:55.426]     })
[13:37:55.426]     if (TRUE) {
[13:37:55.426]         base::sink(type = "output", split = FALSE)
[13:37:55.426]         if (TRUE) {
[13:37:55.426]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:55.426]         }
[13:37:55.426]         else {
[13:37:55.426]             ...future.result["stdout"] <- base::list(NULL)
[13:37:55.426]         }
[13:37:55.426]         base::close(...future.stdout)
[13:37:55.426]         ...future.stdout <- NULL
[13:37:55.426]     }
[13:37:55.426]     ...future.result$conditions <- ...future.conditions
[13:37:55.426]     ...future.result$finished <- base::Sys.time()
[13:37:55.426]     ...future.result
[13:37:55.426] }
[13:37:55.429] MultisessionFuture started
[13:37:55.430] - Launch lazy future ... done
[13:37:55.430] run() for ‘MultisessionFuture’ ... done
[13:37:55.932] receiveMessageFromWorker() for ClusterFuture ...
[13:37:55.932] - Validating connection of MultisessionFuture
[13:37:55.932] - received message: FutureResult
[13:37:55.933] - Received FutureResult
[13:37:55.933] - Erased future from FutureRegistry
[13:37:55.933] result() for ClusterFuture ...
[13:37:55.933] - result already collected: FutureResult
[13:37:55.933] result() for ClusterFuture ... done
[13:37:55.933] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:55.933] resolve() on list ...
[13:37:55.933]  recursive: 98
[13:37:55.933]  length: 2
[13:37:55.933]  elements: ‘a’, ‘b’
[13:37:55.934]  length: 1 (resolved future 1)
[13:37:55.934]  length: 0 (resolved future 2)
[13:37:55.934] resolve() on list ... DONE
[13:37:55.934] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[13:37:55.934] getGlobalsAndPackages() ...
[13:37:55.934] Searching for globals...
[13:37:55.935] - globals found: [2] ‘list’, ‘stop’
[13:37:55.935] Searching for globals ... DONE
[13:37:55.935] Resolving globals: FALSE
[13:37:55.935] 
[13:37:55.935] 
[13:37:55.936] getGlobalsAndPackages() ... DONE
[13:37:55.936] run() for ‘Future’ ...
[13:37:55.941] - state: ‘created’
[13:37:55.941] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:55.958] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:55.958] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:55.958]   - Field: ‘node’
[13:37:55.958]   - Field: ‘label’
[13:37:55.958]   - Field: ‘local’
[13:37:55.959]   - Field: ‘owner’
[13:37:55.959]   - Field: ‘envir’
[13:37:55.959]   - Field: ‘workers’
[13:37:55.959]   - Field: ‘packages’
[13:37:55.959]   - Field: ‘gc’
[13:37:55.959]   - Field: ‘conditions’
[13:37:55.959]   - Field: ‘persistent’
[13:37:55.959]   - Field: ‘expr’
[13:37:55.959]   - Field: ‘uuid’
[13:37:55.959]   - Field: ‘seed’
[13:37:55.959]   - Field: ‘version’
[13:37:55.960]   - Field: ‘result’
[13:37:55.960]   - Field: ‘asynchronous’
[13:37:55.960]   - Field: ‘calls’
[13:37:55.960]   - Field: ‘globals’
[13:37:55.960]   - Field: ‘stdout’
[13:37:55.960]   - Field: ‘earlySignal’
[13:37:55.960]   - Field: ‘lazy’
[13:37:55.960]   - Field: ‘state’
[13:37:55.960] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:55.960] - Launch lazy future ...
[13:37:55.961] Packages needed by the future expression (n = 0): <none>
[13:37:55.961] Packages needed by future strategies (n = 0): <none>
[13:37:55.961] {
[13:37:55.961]     {
[13:37:55.961]         {
[13:37:55.961]             ...future.startTime <- base::Sys.time()
[13:37:55.961]             {
[13:37:55.961]                 {
[13:37:55.961]                   {
[13:37:55.961]                     {
[13:37:55.961]                       base::local({
[13:37:55.961]                         has_future <- base::requireNamespace("future", 
[13:37:55.961]                           quietly = TRUE)
[13:37:55.961]                         if (has_future) {
[13:37:55.961]                           ns <- base::getNamespace("future")
[13:37:55.961]                           version <- ns[[".package"]][["version"]]
[13:37:55.961]                           if (is.null(version)) 
[13:37:55.961]                             version <- utils::packageVersion("future")
[13:37:55.961]                         }
[13:37:55.961]                         else {
[13:37:55.961]                           version <- NULL
[13:37:55.961]                         }
[13:37:55.961]                         if (!has_future || version < "1.8.0") {
[13:37:55.961]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:55.961]                             "", base::R.version$version.string), 
[13:37:55.961]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:55.961]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:55.961]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:55.961]                               "release", "version")], collapse = " "), 
[13:37:55.961]                             hostname = base::Sys.info()[["nodename"]])
[13:37:55.961]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:55.961]                             info)
[13:37:55.961]                           info <- base::paste(info, collapse = "; ")
[13:37:55.961]                           if (!has_future) {
[13:37:55.961]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:55.961]                               info)
[13:37:55.961]                           }
[13:37:55.961]                           else {
[13:37:55.961]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:55.961]                               info, version)
[13:37:55.961]                           }
[13:37:55.961]                           base::stop(msg)
[13:37:55.961]                         }
[13:37:55.961]                       })
[13:37:55.961]                     }
[13:37:55.961]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:55.961]                     base::options(mc.cores = 1L)
[13:37:55.961]                   }
[13:37:55.961]                   ...future.strategy.old <- future::plan("list")
[13:37:55.961]                   options(future.plan = NULL)
[13:37:55.961]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:55.961]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:55.961]                 }
[13:37:55.961]                 ...future.workdir <- getwd()
[13:37:55.961]             }
[13:37:55.961]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:55.961]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:55.961]         }
[13:37:55.961]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:55.961]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:55.961]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:55.961]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:55.961]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:55.961]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:55.961]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:55.961]             base::names(...future.oldOptions))
[13:37:55.961]     }
[13:37:55.961]     if (FALSE) {
[13:37:55.961]     }
[13:37:55.961]     else {
[13:37:55.961]         if (TRUE) {
[13:37:55.961]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:55.961]                 open = "w")
[13:37:55.961]         }
[13:37:55.961]         else {
[13:37:55.961]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:55.961]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:55.961]         }
[13:37:55.961]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:55.961]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:55.961]             base::sink(type = "output", split = FALSE)
[13:37:55.961]             base::close(...future.stdout)
[13:37:55.961]         }, add = TRUE)
[13:37:55.961]     }
[13:37:55.961]     ...future.frame <- base::sys.nframe()
[13:37:55.961]     ...future.conditions <- base::list()
[13:37:55.961]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:55.961]     if (FALSE) {
[13:37:55.961]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:55.961]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:55.961]     }
[13:37:55.961]     ...future.result <- base::tryCatch({
[13:37:55.961]         base::withCallingHandlers({
[13:37:55.961]             ...future.value <- base::withVisible(base::local({
[13:37:55.961]                 ...future.makeSendCondition <- base::local({
[13:37:55.961]                   sendCondition <- NULL
[13:37:55.961]                   function(frame = 1L) {
[13:37:55.961]                     if (is.function(sendCondition)) 
[13:37:55.961]                       return(sendCondition)
[13:37:55.961]                     ns <- getNamespace("parallel")
[13:37:55.961]                     if (exists("sendData", mode = "function", 
[13:37:55.961]                       envir = ns)) {
[13:37:55.961]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:55.961]                         envir = ns)
[13:37:55.961]                       envir <- sys.frame(frame)
[13:37:55.961]                       master <- NULL
[13:37:55.961]                       while (!identical(envir, .GlobalEnv) && 
[13:37:55.961]                         !identical(envir, emptyenv())) {
[13:37:55.961]                         if (exists("master", mode = "list", envir = envir, 
[13:37:55.961]                           inherits = FALSE)) {
[13:37:55.961]                           master <- get("master", mode = "list", 
[13:37:55.961]                             envir = envir, inherits = FALSE)
[13:37:55.961]                           if (inherits(master, c("SOCKnode", 
[13:37:55.961]                             "SOCK0node"))) {
[13:37:55.961]                             sendCondition <<- function(cond) {
[13:37:55.961]                               data <- list(type = "VALUE", value = cond, 
[13:37:55.961]                                 success = TRUE)
[13:37:55.961]                               parallel_sendData(master, data)
[13:37:55.961]                             }
[13:37:55.961]                             return(sendCondition)
[13:37:55.961]                           }
[13:37:55.961]                         }
[13:37:55.961]                         frame <- frame + 1L
[13:37:55.961]                         envir <- sys.frame(frame)
[13:37:55.961]                       }
[13:37:55.961]                     }
[13:37:55.961]                     sendCondition <<- function(cond) NULL
[13:37:55.961]                   }
[13:37:55.961]                 })
[13:37:55.961]                 withCallingHandlers({
[13:37:55.961]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:37:55.961]                 }, immediateCondition = function(cond) {
[13:37:55.961]                   sendCondition <- ...future.makeSendCondition()
[13:37:55.961]                   sendCondition(cond)
[13:37:55.961]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:55.961]                   {
[13:37:55.961]                     inherits <- base::inherits
[13:37:55.961]                     invokeRestart <- base::invokeRestart
[13:37:55.961]                     is.null <- base::is.null
[13:37:55.961]                     muffled <- FALSE
[13:37:55.961]                     if (inherits(cond, "message")) {
[13:37:55.961]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:55.961]                       if (muffled) 
[13:37:55.961]                         invokeRestart("muffleMessage")
[13:37:55.961]                     }
[13:37:55.961]                     else if (inherits(cond, "warning")) {
[13:37:55.961]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:55.961]                       if (muffled) 
[13:37:55.961]                         invokeRestart("muffleWarning")
[13:37:55.961]                     }
[13:37:55.961]                     else if (inherits(cond, "condition")) {
[13:37:55.961]                       if (!is.null(pattern)) {
[13:37:55.961]                         computeRestarts <- base::computeRestarts
[13:37:55.961]                         grepl <- base::grepl
[13:37:55.961]                         restarts <- computeRestarts(cond)
[13:37:55.961]                         for (restart in restarts) {
[13:37:55.961]                           name <- restart$name
[13:37:55.961]                           if (is.null(name)) 
[13:37:55.961]                             next
[13:37:55.961]                           if (!grepl(pattern, name)) 
[13:37:55.961]                             next
[13:37:55.961]                           invokeRestart(restart)
[13:37:55.961]                           muffled <- TRUE
[13:37:55.961]                           break
[13:37:55.961]                         }
[13:37:55.961]                       }
[13:37:55.961]                     }
[13:37:55.961]                     invisible(muffled)
[13:37:55.961]                   }
[13:37:55.961]                   muffleCondition(cond)
[13:37:55.961]                 })
[13:37:55.961]             }))
[13:37:55.961]             future::FutureResult(value = ...future.value$value, 
[13:37:55.961]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:55.961]                   ...future.rng), globalenv = if (FALSE) 
[13:37:55.961]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:55.961]                     ...future.globalenv.names))
[13:37:55.961]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:55.961]         }, condition = base::local({
[13:37:55.961]             c <- base::c
[13:37:55.961]             inherits <- base::inherits
[13:37:55.961]             invokeRestart <- base::invokeRestart
[13:37:55.961]             length <- base::length
[13:37:55.961]             list <- base::list
[13:37:55.961]             seq.int <- base::seq.int
[13:37:55.961]             signalCondition <- base::signalCondition
[13:37:55.961]             sys.calls <- base::sys.calls
[13:37:55.961]             `[[` <- base::`[[`
[13:37:55.961]             `+` <- base::`+`
[13:37:55.961]             `<<-` <- base::`<<-`
[13:37:55.961]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:55.961]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:55.961]                   3L)]
[13:37:55.961]             }
[13:37:55.961]             function(cond) {
[13:37:55.961]                 is_error <- inherits(cond, "error")
[13:37:55.961]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:55.961]                   NULL)
[13:37:55.961]                 if (is_error) {
[13:37:55.961]                   sessionInformation <- function() {
[13:37:55.961]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:55.961]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:55.961]                       search = base::search(), system = base::Sys.info())
[13:37:55.961]                   }
[13:37:55.961]                   ...future.conditions[[length(...future.conditions) + 
[13:37:55.961]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:55.961]                     cond$call), session = sessionInformation(), 
[13:37:55.961]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:55.961]                   signalCondition(cond)
[13:37:55.961]                 }
[13:37:55.961]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:55.961]                 "immediateCondition"))) {
[13:37:55.961]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:55.961]                   ...future.conditions[[length(...future.conditions) + 
[13:37:55.961]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:55.961]                   if (TRUE && !signal) {
[13:37:55.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:55.961]                     {
[13:37:55.961]                       inherits <- base::inherits
[13:37:55.961]                       invokeRestart <- base::invokeRestart
[13:37:55.961]                       is.null <- base::is.null
[13:37:55.961]                       muffled <- FALSE
[13:37:55.961]                       if (inherits(cond, "message")) {
[13:37:55.961]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:55.961]                         if (muffled) 
[13:37:55.961]                           invokeRestart("muffleMessage")
[13:37:55.961]                       }
[13:37:55.961]                       else if (inherits(cond, "warning")) {
[13:37:55.961]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:55.961]                         if (muffled) 
[13:37:55.961]                           invokeRestart("muffleWarning")
[13:37:55.961]                       }
[13:37:55.961]                       else if (inherits(cond, "condition")) {
[13:37:55.961]                         if (!is.null(pattern)) {
[13:37:55.961]                           computeRestarts <- base::computeRestarts
[13:37:55.961]                           grepl <- base::grepl
[13:37:55.961]                           restarts <- computeRestarts(cond)
[13:37:55.961]                           for (restart in restarts) {
[13:37:55.961]                             name <- restart$name
[13:37:55.961]                             if (is.null(name)) 
[13:37:55.961]                               next
[13:37:55.961]                             if (!grepl(pattern, name)) 
[13:37:55.961]                               next
[13:37:55.961]                             invokeRestart(restart)
[13:37:55.961]                             muffled <- TRUE
[13:37:55.961]                             break
[13:37:55.961]                           }
[13:37:55.961]                         }
[13:37:55.961]                       }
[13:37:55.961]                       invisible(muffled)
[13:37:55.961]                     }
[13:37:55.961]                     muffleCondition(cond, pattern = "^muffle")
[13:37:55.961]                   }
[13:37:55.961]                 }
[13:37:55.961]                 else {
[13:37:55.961]                   if (TRUE) {
[13:37:55.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:55.961]                     {
[13:37:55.961]                       inherits <- base::inherits
[13:37:55.961]                       invokeRestart <- base::invokeRestart
[13:37:55.961]                       is.null <- base::is.null
[13:37:55.961]                       muffled <- FALSE
[13:37:55.961]                       if (inherits(cond, "message")) {
[13:37:55.961]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:55.961]                         if (muffled) 
[13:37:55.961]                           invokeRestart("muffleMessage")
[13:37:55.961]                       }
[13:37:55.961]                       else if (inherits(cond, "warning")) {
[13:37:55.961]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:55.961]                         if (muffled) 
[13:37:55.961]                           invokeRestart("muffleWarning")
[13:37:55.961]                       }
[13:37:55.961]                       else if (inherits(cond, "condition")) {
[13:37:55.961]                         if (!is.null(pattern)) {
[13:37:55.961]                           computeRestarts <- base::computeRestarts
[13:37:55.961]                           grepl <- base::grepl
[13:37:55.961]                           restarts <- computeRestarts(cond)
[13:37:55.961]                           for (restart in restarts) {
[13:37:55.961]                             name <- restart$name
[13:37:55.961]                             if (is.null(name)) 
[13:37:55.961]                               next
[13:37:55.961]                             if (!grepl(pattern, name)) 
[13:37:55.961]                               next
[13:37:55.961]                             invokeRestart(restart)
[13:37:55.961]                             muffled <- TRUE
[13:37:55.961]                             break
[13:37:55.961]                           }
[13:37:55.961]                         }
[13:37:55.961]                       }
[13:37:55.961]                       invisible(muffled)
[13:37:55.961]                     }
[13:37:55.961]                     muffleCondition(cond, pattern = "^muffle")
[13:37:55.961]                   }
[13:37:55.961]                 }
[13:37:55.961]             }
[13:37:55.961]         }))
[13:37:55.961]     }, error = function(ex) {
[13:37:55.961]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:55.961]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:55.961]                 ...future.rng), started = ...future.startTime, 
[13:37:55.961]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:55.961]             version = "1.8"), class = "FutureResult")
[13:37:55.961]     }, finally = {
[13:37:55.961]         if (!identical(...future.workdir, getwd())) 
[13:37:55.961]             setwd(...future.workdir)
[13:37:55.961]         {
[13:37:55.961]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:55.961]                 ...future.oldOptions$nwarnings <- NULL
[13:37:55.961]             }
[13:37:55.961]             base::options(...future.oldOptions)
[13:37:55.961]             if (.Platform$OS.type == "windows") {
[13:37:55.961]                 old_names <- names(...future.oldEnvVars)
[13:37:55.961]                 envs <- base::Sys.getenv()
[13:37:55.961]                 names <- names(envs)
[13:37:55.961]                 common <- intersect(names, old_names)
[13:37:55.961]                 added <- setdiff(names, old_names)
[13:37:55.961]                 removed <- setdiff(old_names, names)
[13:37:55.961]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:55.961]                   envs[common]]
[13:37:55.961]                 NAMES <- toupper(changed)
[13:37:55.961]                 args <- list()
[13:37:55.961]                 for (kk in seq_along(NAMES)) {
[13:37:55.961]                   name <- changed[[kk]]
[13:37:55.961]                   NAME <- NAMES[[kk]]
[13:37:55.961]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:55.961]                     next
[13:37:55.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:55.961]                 }
[13:37:55.961]                 NAMES <- toupper(added)
[13:37:55.961]                 for (kk in seq_along(NAMES)) {
[13:37:55.961]                   name <- added[[kk]]
[13:37:55.961]                   NAME <- NAMES[[kk]]
[13:37:55.961]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:55.961]                     next
[13:37:55.961]                   args[[name]] <- ""
[13:37:55.961]                 }
[13:37:55.961]                 NAMES <- toupper(removed)
[13:37:55.961]                 for (kk in seq_along(NAMES)) {
[13:37:55.961]                   name <- removed[[kk]]
[13:37:55.961]                   NAME <- NAMES[[kk]]
[13:37:55.961]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:55.961]                     next
[13:37:55.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:55.961]                 }
[13:37:55.961]                 if (length(args) > 0) 
[13:37:55.961]                   base::do.call(base::Sys.setenv, args = args)
[13:37:55.961]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:55.961]             }
[13:37:55.961]             else {
[13:37:55.961]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:55.961]             }
[13:37:55.961]             {
[13:37:55.961]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:55.961]                   0L) {
[13:37:55.961]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:55.961]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:55.961]                   base::options(opts)
[13:37:55.961]                 }
[13:37:55.961]                 {
[13:37:55.961]                   {
[13:37:55.961]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:55.961]                     NULL
[13:37:55.961]                   }
[13:37:55.961]                   options(future.plan = NULL)
[13:37:55.961]                   if (is.na(NA_character_)) 
[13:37:55.961]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:55.961]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:55.961]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:55.961]                     .init = FALSE)
[13:37:55.961]                 }
[13:37:55.961]             }
[13:37:55.961]         }
[13:37:55.961]     })
[13:37:55.961]     if (TRUE) {
[13:37:55.961]         base::sink(type = "output", split = FALSE)
[13:37:55.961]         if (TRUE) {
[13:37:55.961]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:55.961]         }
[13:37:55.961]         else {
[13:37:55.961]             ...future.result["stdout"] <- base::list(NULL)
[13:37:55.961]         }
[13:37:55.961]         base::close(...future.stdout)
[13:37:55.961]         ...future.stdout <- NULL
[13:37:55.961]     }
[13:37:55.961]     ...future.result$conditions <- ...future.conditions
[13:37:55.961]     ...future.result$finished <- base::Sys.time()
[13:37:55.961]     ...future.result
[13:37:55.961] }
[13:37:55.964] MultisessionFuture started
[13:37:55.964] - Launch lazy future ... done
[13:37:55.964] run() for ‘MultisessionFuture’ ... done
[13:37:55.966] receiveMessageFromWorker() for ClusterFuture ...
[13:37:55.966] - Validating connection of MultisessionFuture
[13:37:55.966] - received message: FutureResult
[13:37:55.966] - Received FutureResult
[13:37:55.966] - Erased future from FutureRegistry
[13:37:55.966] result() for ClusterFuture ...
[13:37:55.967] - result already collected: FutureResult
[13:37:55.967] result() for ClusterFuture ... done
[13:37:55.967] signalConditions() ...
[13:37:55.967]  - include = ‘immediateCondition’
[13:37:55.967]  - exclude = 
[13:37:55.967]  - resignal = FALSE
[13:37:55.967]  - Number of conditions: 1
[13:37:55.967] signalConditions() ... done
[13:37:55.967] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:55.967] A MultisessionFuture was resolved
[13:37:55.967] getGlobalsAndPackages() ...
[13:37:55.968] Searching for globals...
[13:37:55.968] - globals found: [2] ‘list’, ‘stop’
[13:37:55.968] Searching for globals ... DONE
[13:37:55.968] Resolving globals: FALSE
[13:37:55.969] 
[13:37:55.969] 
[13:37:55.969] getGlobalsAndPackages() ... DONE
[13:37:55.969] run() for ‘Future’ ...
[13:37:55.969] - state: ‘created’
[13:37:55.969] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:55.983] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:55.983] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:55.983]   - Field: ‘node’
[13:37:55.983]   - Field: ‘label’
[13:37:55.983]   - Field: ‘local’
[13:37:55.983]   - Field: ‘owner’
[13:37:55.983]   - Field: ‘envir’
[13:37:55.983]   - Field: ‘workers’
[13:37:55.983]   - Field: ‘packages’
[13:37:55.983]   - Field: ‘gc’
[13:37:55.984]   - Field: ‘conditions’
[13:37:55.984]   - Field: ‘persistent’
[13:37:55.984]   - Field: ‘expr’
[13:37:55.984]   - Field: ‘uuid’
[13:37:55.984]   - Field: ‘seed’
[13:37:55.984]   - Field: ‘version’
[13:37:55.984]   - Field: ‘result’
[13:37:55.984]   - Field: ‘asynchronous’
[13:37:55.984]   - Field: ‘calls’
[13:37:55.984]   - Field: ‘globals’
[13:37:55.984]   - Field: ‘stdout’
[13:37:55.985]   - Field: ‘earlySignal’
[13:37:55.985]   - Field: ‘lazy’
[13:37:55.985]   - Field: ‘state’
[13:37:55.985] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:55.985] - Launch lazy future ...
[13:37:55.985] Packages needed by the future expression (n = 0): <none>
[13:37:55.985] Packages needed by future strategies (n = 0): <none>
[13:37:55.986] {
[13:37:55.986]     {
[13:37:55.986]         {
[13:37:55.986]             ...future.startTime <- base::Sys.time()
[13:37:55.986]             {
[13:37:55.986]                 {
[13:37:55.986]                   {
[13:37:55.986]                     {
[13:37:55.986]                       base::local({
[13:37:55.986]                         has_future <- base::requireNamespace("future", 
[13:37:55.986]                           quietly = TRUE)
[13:37:55.986]                         if (has_future) {
[13:37:55.986]                           ns <- base::getNamespace("future")
[13:37:55.986]                           version <- ns[[".package"]][["version"]]
[13:37:55.986]                           if (is.null(version)) 
[13:37:55.986]                             version <- utils::packageVersion("future")
[13:37:55.986]                         }
[13:37:55.986]                         else {
[13:37:55.986]                           version <- NULL
[13:37:55.986]                         }
[13:37:55.986]                         if (!has_future || version < "1.8.0") {
[13:37:55.986]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:55.986]                             "", base::R.version$version.string), 
[13:37:55.986]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:55.986]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:55.986]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:55.986]                               "release", "version")], collapse = " "), 
[13:37:55.986]                             hostname = base::Sys.info()[["nodename"]])
[13:37:55.986]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:55.986]                             info)
[13:37:55.986]                           info <- base::paste(info, collapse = "; ")
[13:37:55.986]                           if (!has_future) {
[13:37:55.986]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:55.986]                               info)
[13:37:55.986]                           }
[13:37:55.986]                           else {
[13:37:55.986]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:55.986]                               info, version)
[13:37:55.986]                           }
[13:37:55.986]                           base::stop(msg)
[13:37:55.986]                         }
[13:37:55.986]                       })
[13:37:55.986]                     }
[13:37:55.986]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:55.986]                     base::options(mc.cores = 1L)
[13:37:55.986]                   }
[13:37:55.986]                   ...future.strategy.old <- future::plan("list")
[13:37:55.986]                   options(future.plan = NULL)
[13:37:55.986]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:55.986]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:55.986]                 }
[13:37:55.986]                 ...future.workdir <- getwd()
[13:37:55.986]             }
[13:37:55.986]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:55.986]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:55.986]         }
[13:37:55.986]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:55.986]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:55.986]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:55.986]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:55.986]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:55.986]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:55.986]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:55.986]             base::names(...future.oldOptions))
[13:37:55.986]     }
[13:37:55.986]     if (FALSE) {
[13:37:55.986]     }
[13:37:55.986]     else {
[13:37:55.986]         if (TRUE) {
[13:37:55.986]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:55.986]                 open = "w")
[13:37:55.986]         }
[13:37:55.986]         else {
[13:37:55.986]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:55.986]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:55.986]         }
[13:37:55.986]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:55.986]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:55.986]             base::sink(type = "output", split = FALSE)
[13:37:55.986]             base::close(...future.stdout)
[13:37:55.986]         }, add = TRUE)
[13:37:55.986]     }
[13:37:55.986]     ...future.frame <- base::sys.nframe()
[13:37:55.986]     ...future.conditions <- base::list()
[13:37:55.986]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:55.986]     if (FALSE) {
[13:37:55.986]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:55.986]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:55.986]     }
[13:37:55.986]     ...future.result <- base::tryCatch({
[13:37:55.986]         base::withCallingHandlers({
[13:37:55.986]             ...future.value <- base::withVisible(base::local({
[13:37:55.986]                 ...future.makeSendCondition <- base::local({
[13:37:55.986]                   sendCondition <- NULL
[13:37:55.986]                   function(frame = 1L) {
[13:37:55.986]                     if (is.function(sendCondition)) 
[13:37:55.986]                       return(sendCondition)
[13:37:55.986]                     ns <- getNamespace("parallel")
[13:37:55.986]                     if (exists("sendData", mode = "function", 
[13:37:55.986]                       envir = ns)) {
[13:37:55.986]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:55.986]                         envir = ns)
[13:37:55.986]                       envir <- sys.frame(frame)
[13:37:55.986]                       master <- NULL
[13:37:55.986]                       while (!identical(envir, .GlobalEnv) && 
[13:37:55.986]                         !identical(envir, emptyenv())) {
[13:37:55.986]                         if (exists("master", mode = "list", envir = envir, 
[13:37:55.986]                           inherits = FALSE)) {
[13:37:55.986]                           master <- get("master", mode = "list", 
[13:37:55.986]                             envir = envir, inherits = FALSE)
[13:37:55.986]                           if (inherits(master, c("SOCKnode", 
[13:37:55.986]                             "SOCK0node"))) {
[13:37:55.986]                             sendCondition <<- function(cond) {
[13:37:55.986]                               data <- list(type = "VALUE", value = cond, 
[13:37:55.986]                                 success = TRUE)
[13:37:55.986]                               parallel_sendData(master, data)
[13:37:55.986]                             }
[13:37:55.986]                             return(sendCondition)
[13:37:55.986]                           }
[13:37:55.986]                         }
[13:37:55.986]                         frame <- frame + 1L
[13:37:55.986]                         envir <- sys.frame(frame)
[13:37:55.986]                       }
[13:37:55.986]                     }
[13:37:55.986]                     sendCondition <<- function(cond) NULL
[13:37:55.986]                   }
[13:37:55.986]                 })
[13:37:55.986]                 withCallingHandlers({
[13:37:55.986]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:37:55.986]                 }, immediateCondition = function(cond) {
[13:37:55.986]                   sendCondition <- ...future.makeSendCondition()
[13:37:55.986]                   sendCondition(cond)
[13:37:55.986]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:55.986]                   {
[13:37:55.986]                     inherits <- base::inherits
[13:37:55.986]                     invokeRestart <- base::invokeRestart
[13:37:55.986]                     is.null <- base::is.null
[13:37:55.986]                     muffled <- FALSE
[13:37:55.986]                     if (inherits(cond, "message")) {
[13:37:55.986]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:55.986]                       if (muffled) 
[13:37:55.986]                         invokeRestart("muffleMessage")
[13:37:55.986]                     }
[13:37:55.986]                     else if (inherits(cond, "warning")) {
[13:37:55.986]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:55.986]                       if (muffled) 
[13:37:55.986]                         invokeRestart("muffleWarning")
[13:37:55.986]                     }
[13:37:55.986]                     else if (inherits(cond, "condition")) {
[13:37:55.986]                       if (!is.null(pattern)) {
[13:37:55.986]                         computeRestarts <- base::computeRestarts
[13:37:55.986]                         grepl <- base::grepl
[13:37:55.986]                         restarts <- computeRestarts(cond)
[13:37:55.986]                         for (restart in restarts) {
[13:37:55.986]                           name <- restart$name
[13:37:55.986]                           if (is.null(name)) 
[13:37:55.986]                             next
[13:37:55.986]                           if (!grepl(pattern, name)) 
[13:37:55.986]                             next
[13:37:55.986]                           invokeRestart(restart)
[13:37:55.986]                           muffled <- TRUE
[13:37:55.986]                           break
[13:37:55.986]                         }
[13:37:55.986]                       }
[13:37:55.986]                     }
[13:37:55.986]                     invisible(muffled)
[13:37:55.986]                   }
[13:37:55.986]                   muffleCondition(cond)
[13:37:55.986]                 })
[13:37:55.986]             }))
[13:37:55.986]             future::FutureResult(value = ...future.value$value, 
[13:37:55.986]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:55.986]                   ...future.rng), globalenv = if (FALSE) 
[13:37:55.986]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:55.986]                     ...future.globalenv.names))
[13:37:55.986]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:55.986]         }, condition = base::local({
[13:37:55.986]             c <- base::c
[13:37:55.986]             inherits <- base::inherits
[13:37:55.986]             invokeRestart <- base::invokeRestart
[13:37:55.986]             length <- base::length
[13:37:55.986]             list <- base::list
[13:37:55.986]             seq.int <- base::seq.int
[13:37:55.986]             signalCondition <- base::signalCondition
[13:37:55.986]             sys.calls <- base::sys.calls
[13:37:55.986]             `[[` <- base::`[[`
[13:37:55.986]             `+` <- base::`+`
[13:37:55.986]             `<<-` <- base::`<<-`
[13:37:55.986]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:55.986]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:55.986]                   3L)]
[13:37:55.986]             }
[13:37:55.986]             function(cond) {
[13:37:55.986]                 is_error <- inherits(cond, "error")
[13:37:55.986]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:55.986]                   NULL)
[13:37:55.986]                 if (is_error) {
[13:37:55.986]                   sessionInformation <- function() {
[13:37:55.986]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:55.986]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:55.986]                       search = base::search(), system = base::Sys.info())
[13:37:55.986]                   }
[13:37:55.986]                   ...future.conditions[[length(...future.conditions) + 
[13:37:55.986]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:55.986]                     cond$call), session = sessionInformation(), 
[13:37:55.986]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:55.986]                   signalCondition(cond)
[13:37:55.986]                 }
[13:37:55.986]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:55.986]                 "immediateCondition"))) {
[13:37:55.986]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:55.986]                   ...future.conditions[[length(...future.conditions) + 
[13:37:55.986]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:55.986]                   if (TRUE && !signal) {
[13:37:55.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:55.986]                     {
[13:37:55.986]                       inherits <- base::inherits
[13:37:55.986]                       invokeRestart <- base::invokeRestart
[13:37:55.986]                       is.null <- base::is.null
[13:37:55.986]                       muffled <- FALSE
[13:37:55.986]                       if (inherits(cond, "message")) {
[13:37:55.986]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:55.986]                         if (muffled) 
[13:37:55.986]                           invokeRestart("muffleMessage")
[13:37:55.986]                       }
[13:37:55.986]                       else if (inherits(cond, "warning")) {
[13:37:55.986]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:55.986]                         if (muffled) 
[13:37:55.986]                           invokeRestart("muffleWarning")
[13:37:55.986]                       }
[13:37:55.986]                       else if (inherits(cond, "condition")) {
[13:37:55.986]                         if (!is.null(pattern)) {
[13:37:55.986]                           computeRestarts <- base::computeRestarts
[13:37:55.986]                           grepl <- base::grepl
[13:37:55.986]                           restarts <- computeRestarts(cond)
[13:37:55.986]                           for (restart in restarts) {
[13:37:55.986]                             name <- restart$name
[13:37:55.986]                             if (is.null(name)) 
[13:37:55.986]                               next
[13:37:55.986]                             if (!grepl(pattern, name)) 
[13:37:55.986]                               next
[13:37:55.986]                             invokeRestart(restart)
[13:37:55.986]                             muffled <- TRUE
[13:37:55.986]                             break
[13:37:55.986]                           }
[13:37:55.986]                         }
[13:37:55.986]                       }
[13:37:55.986]                       invisible(muffled)
[13:37:55.986]                     }
[13:37:55.986]                     muffleCondition(cond, pattern = "^muffle")
[13:37:55.986]                   }
[13:37:55.986]                 }
[13:37:55.986]                 else {
[13:37:55.986]                   if (TRUE) {
[13:37:55.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:55.986]                     {
[13:37:55.986]                       inherits <- base::inherits
[13:37:55.986]                       invokeRestart <- base::invokeRestart
[13:37:55.986]                       is.null <- base::is.null
[13:37:55.986]                       muffled <- FALSE
[13:37:55.986]                       if (inherits(cond, "message")) {
[13:37:55.986]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:55.986]                         if (muffled) 
[13:37:55.986]                           invokeRestart("muffleMessage")
[13:37:55.986]                       }
[13:37:55.986]                       else if (inherits(cond, "warning")) {
[13:37:55.986]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:55.986]                         if (muffled) 
[13:37:55.986]                           invokeRestart("muffleWarning")
[13:37:55.986]                       }
[13:37:55.986]                       else if (inherits(cond, "condition")) {
[13:37:55.986]                         if (!is.null(pattern)) {
[13:37:55.986]                           computeRestarts <- base::computeRestarts
[13:37:55.986]                           grepl <- base::grepl
[13:37:55.986]                           restarts <- computeRestarts(cond)
[13:37:55.986]                           for (restart in restarts) {
[13:37:55.986]                             name <- restart$name
[13:37:55.986]                             if (is.null(name)) 
[13:37:55.986]                               next
[13:37:55.986]                             if (!grepl(pattern, name)) 
[13:37:55.986]                               next
[13:37:55.986]                             invokeRestart(restart)
[13:37:55.986]                             muffled <- TRUE
[13:37:55.986]                             break
[13:37:55.986]                           }
[13:37:55.986]                         }
[13:37:55.986]                       }
[13:37:55.986]                       invisible(muffled)
[13:37:55.986]                     }
[13:37:55.986]                     muffleCondition(cond, pattern = "^muffle")
[13:37:55.986]                   }
[13:37:55.986]                 }
[13:37:55.986]             }
[13:37:55.986]         }))
[13:37:55.986]     }, error = function(ex) {
[13:37:55.986]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:55.986]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:55.986]                 ...future.rng), started = ...future.startTime, 
[13:37:55.986]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:55.986]             version = "1.8"), class = "FutureResult")
[13:37:55.986]     }, finally = {
[13:37:55.986]         if (!identical(...future.workdir, getwd())) 
[13:37:55.986]             setwd(...future.workdir)
[13:37:55.986]         {
[13:37:55.986]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:55.986]                 ...future.oldOptions$nwarnings <- NULL
[13:37:55.986]             }
[13:37:55.986]             base::options(...future.oldOptions)
[13:37:55.986]             if (.Platform$OS.type == "windows") {
[13:37:55.986]                 old_names <- names(...future.oldEnvVars)
[13:37:55.986]                 envs <- base::Sys.getenv()
[13:37:55.986]                 names <- names(envs)
[13:37:55.986]                 common <- intersect(names, old_names)
[13:37:55.986]                 added <- setdiff(names, old_names)
[13:37:55.986]                 removed <- setdiff(old_names, names)
[13:37:55.986]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:55.986]                   envs[common]]
[13:37:55.986]                 NAMES <- toupper(changed)
[13:37:55.986]                 args <- list()
[13:37:55.986]                 for (kk in seq_along(NAMES)) {
[13:37:55.986]                   name <- changed[[kk]]
[13:37:55.986]                   NAME <- NAMES[[kk]]
[13:37:55.986]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:55.986]                     next
[13:37:55.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:55.986]                 }
[13:37:55.986]                 NAMES <- toupper(added)
[13:37:55.986]                 for (kk in seq_along(NAMES)) {
[13:37:55.986]                   name <- added[[kk]]
[13:37:55.986]                   NAME <- NAMES[[kk]]
[13:37:55.986]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:55.986]                     next
[13:37:55.986]                   args[[name]] <- ""
[13:37:55.986]                 }
[13:37:55.986]                 NAMES <- toupper(removed)
[13:37:55.986]                 for (kk in seq_along(NAMES)) {
[13:37:55.986]                   name <- removed[[kk]]
[13:37:55.986]                   NAME <- NAMES[[kk]]
[13:37:55.986]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:55.986]                     next
[13:37:55.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:55.986]                 }
[13:37:55.986]                 if (length(args) > 0) 
[13:37:55.986]                   base::do.call(base::Sys.setenv, args = args)
[13:37:55.986]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:55.986]             }
[13:37:55.986]             else {
[13:37:55.986]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:55.986]             }
[13:37:55.986]             {
[13:37:55.986]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:55.986]                   0L) {
[13:37:55.986]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:55.986]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:55.986]                   base::options(opts)
[13:37:55.986]                 }
[13:37:55.986]                 {
[13:37:55.986]                   {
[13:37:55.986]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:55.986]                     NULL
[13:37:55.986]                   }
[13:37:55.986]                   options(future.plan = NULL)
[13:37:55.986]                   if (is.na(NA_character_)) 
[13:37:55.986]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:55.986]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:55.986]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:55.986]                     .init = FALSE)
[13:37:55.986]                 }
[13:37:55.986]             }
[13:37:55.986]         }
[13:37:55.986]     })
[13:37:55.986]     if (TRUE) {
[13:37:55.986]         base::sink(type = "output", split = FALSE)
[13:37:55.986]         if (TRUE) {
[13:37:55.986]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:55.986]         }
[13:37:55.986]         else {
[13:37:55.986]             ...future.result["stdout"] <- base::list(NULL)
[13:37:55.986]         }
[13:37:55.986]         base::close(...future.stdout)
[13:37:55.986]         ...future.stdout <- NULL
[13:37:55.986]     }
[13:37:55.986]     ...future.result$conditions <- ...future.conditions
[13:37:55.986]     ...future.result$finished <- base::Sys.time()
[13:37:55.986]     ...future.result
[13:37:55.986] }
[13:37:55.988] MultisessionFuture started
[13:37:55.989] - Launch lazy future ... done
[13:37:55.989] run() for ‘MultisessionFuture’ ... done
[13:37:55.990] receiveMessageFromWorker() for ClusterFuture ...
[13:37:55.990] - Validating connection of MultisessionFuture
[13:37:55.990] - received message: FutureResult
[13:37:55.991] - Received FutureResult
[13:37:55.991] - Erased future from FutureRegistry
[13:37:55.991] result() for ClusterFuture ...
[13:37:55.991] - result already collected: FutureResult
[13:37:55.991] result() for ClusterFuture ... done
[13:37:55.991] signalConditions() ...
[13:37:55.991]  - include = ‘immediateCondition’
[13:37:55.991]  - exclude = 
[13:37:55.991]  - resignal = FALSE
[13:37:55.991]  - Number of conditions: 1
[13:37:55.991] signalConditions() ... done
[13:37:55.992] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:55.992] A MultisessionFuture was resolved
- result = TRUE, recursive = TRUE ... DONE
- result = TRUE, recursive = -1 ...
[13:37:55.992] getGlobalsAndPackages() ...
[13:37:55.992] Searching for globals...
[13:37:55.993] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:37:55.993] Searching for globals ... DONE
[13:37:55.993] Resolving globals: FALSE
[13:37:55.994] 
[13:37:55.994] 
[13:37:55.994] getGlobalsAndPackages() ... DONE
[13:37:55.994] run() for ‘Future’ ...
[13:37:55.994] - state: ‘created’
[13:37:55.994] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:56.009] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:56.009] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:56.009]   - Field: ‘node’
[13:37:56.009]   - Field: ‘label’
[13:37:56.009]   - Field: ‘local’
[13:37:56.009]   - Field: ‘owner’
[13:37:56.009]   - Field: ‘envir’
[13:37:56.009]   - Field: ‘workers’
[13:37:56.010]   - Field: ‘packages’
[13:37:56.010]   - Field: ‘gc’
[13:37:56.010]   - Field: ‘conditions’
[13:37:56.010]   - Field: ‘persistent’
[13:37:56.010]   - Field: ‘expr’
[13:37:56.010]   - Field: ‘uuid’
[13:37:56.010]   - Field: ‘seed’
[13:37:56.010]   - Field: ‘version’
[13:37:56.010]   - Field: ‘result’
[13:37:56.010]   - Field: ‘asynchronous’
[13:37:56.011]   - Field: ‘calls’
[13:37:56.011]   - Field: ‘globals’
[13:37:56.011]   - Field: ‘stdout’
[13:37:56.011]   - Field: ‘earlySignal’
[13:37:56.011]   - Field: ‘lazy’
[13:37:56.011]   - Field: ‘state’
[13:37:56.011] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:56.011] - Launch lazy future ...
[13:37:56.011] Packages needed by the future expression (n = 0): <none>
[13:37:56.012] Packages needed by future strategies (n = 0): <none>
[13:37:56.012] {
[13:37:56.012]     {
[13:37:56.012]         {
[13:37:56.012]             ...future.startTime <- base::Sys.time()
[13:37:56.012]             {
[13:37:56.012]                 {
[13:37:56.012]                   {
[13:37:56.012]                     {
[13:37:56.012]                       base::local({
[13:37:56.012]                         has_future <- base::requireNamespace("future", 
[13:37:56.012]                           quietly = TRUE)
[13:37:56.012]                         if (has_future) {
[13:37:56.012]                           ns <- base::getNamespace("future")
[13:37:56.012]                           version <- ns[[".package"]][["version"]]
[13:37:56.012]                           if (is.null(version)) 
[13:37:56.012]                             version <- utils::packageVersion("future")
[13:37:56.012]                         }
[13:37:56.012]                         else {
[13:37:56.012]                           version <- NULL
[13:37:56.012]                         }
[13:37:56.012]                         if (!has_future || version < "1.8.0") {
[13:37:56.012]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:56.012]                             "", base::R.version$version.string), 
[13:37:56.012]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:56.012]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:56.012]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:56.012]                               "release", "version")], collapse = " "), 
[13:37:56.012]                             hostname = base::Sys.info()[["nodename"]])
[13:37:56.012]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:56.012]                             info)
[13:37:56.012]                           info <- base::paste(info, collapse = "; ")
[13:37:56.012]                           if (!has_future) {
[13:37:56.012]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:56.012]                               info)
[13:37:56.012]                           }
[13:37:56.012]                           else {
[13:37:56.012]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:56.012]                               info, version)
[13:37:56.012]                           }
[13:37:56.012]                           base::stop(msg)
[13:37:56.012]                         }
[13:37:56.012]                       })
[13:37:56.012]                     }
[13:37:56.012]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:56.012]                     base::options(mc.cores = 1L)
[13:37:56.012]                   }
[13:37:56.012]                   ...future.strategy.old <- future::plan("list")
[13:37:56.012]                   options(future.plan = NULL)
[13:37:56.012]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:56.012]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:56.012]                 }
[13:37:56.012]                 ...future.workdir <- getwd()
[13:37:56.012]             }
[13:37:56.012]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:56.012]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:56.012]         }
[13:37:56.012]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:56.012]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:56.012]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:56.012]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:56.012]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:56.012]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:56.012]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:56.012]             base::names(...future.oldOptions))
[13:37:56.012]     }
[13:37:56.012]     if (FALSE) {
[13:37:56.012]     }
[13:37:56.012]     else {
[13:37:56.012]         if (TRUE) {
[13:37:56.012]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:56.012]                 open = "w")
[13:37:56.012]         }
[13:37:56.012]         else {
[13:37:56.012]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:56.012]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:56.012]         }
[13:37:56.012]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:56.012]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:56.012]             base::sink(type = "output", split = FALSE)
[13:37:56.012]             base::close(...future.stdout)
[13:37:56.012]         }, add = TRUE)
[13:37:56.012]     }
[13:37:56.012]     ...future.frame <- base::sys.nframe()
[13:37:56.012]     ...future.conditions <- base::list()
[13:37:56.012]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:56.012]     if (FALSE) {
[13:37:56.012]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:56.012]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:56.012]     }
[13:37:56.012]     ...future.result <- base::tryCatch({
[13:37:56.012]         base::withCallingHandlers({
[13:37:56.012]             ...future.value <- base::withVisible(base::local({
[13:37:56.012]                 ...future.makeSendCondition <- base::local({
[13:37:56.012]                   sendCondition <- NULL
[13:37:56.012]                   function(frame = 1L) {
[13:37:56.012]                     if (is.function(sendCondition)) 
[13:37:56.012]                       return(sendCondition)
[13:37:56.012]                     ns <- getNamespace("parallel")
[13:37:56.012]                     if (exists("sendData", mode = "function", 
[13:37:56.012]                       envir = ns)) {
[13:37:56.012]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:56.012]                         envir = ns)
[13:37:56.012]                       envir <- sys.frame(frame)
[13:37:56.012]                       master <- NULL
[13:37:56.012]                       while (!identical(envir, .GlobalEnv) && 
[13:37:56.012]                         !identical(envir, emptyenv())) {
[13:37:56.012]                         if (exists("master", mode = "list", envir = envir, 
[13:37:56.012]                           inherits = FALSE)) {
[13:37:56.012]                           master <- get("master", mode = "list", 
[13:37:56.012]                             envir = envir, inherits = FALSE)
[13:37:56.012]                           if (inherits(master, c("SOCKnode", 
[13:37:56.012]                             "SOCK0node"))) {
[13:37:56.012]                             sendCondition <<- function(cond) {
[13:37:56.012]                               data <- list(type = "VALUE", value = cond, 
[13:37:56.012]                                 success = TRUE)
[13:37:56.012]                               parallel_sendData(master, data)
[13:37:56.012]                             }
[13:37:56.012]                             return(sendCondition)
[13:37:56.012]                           }
[13:37:56.012]                         }
[13:37:56.012]                         frame <- frame + 1L
[13:37:56.012]                         envir <- sys.frame(frame)
[13:37:56.012]                       }
[13:37:56.012]                     }
[13:37:56.012]                     sendCondition <<- function(cond) NULL
[13:37:56.012]                   }
[13:37:56.012]                 })
[13:37:56.012]                 withCallingHandlers({
[13:37:56.012]                   {
[13:37:56.012]                     Sys.sleep(0.5)
[13:37:56.012]                     list(a = 1, b = 42L)
[13:37:56.012]                   }
[13:37:56.012]                 }, immediateCondition = function(cond) {
[13:37:56.012]                   sendCondition <- ...future.makeSendCondition()
[13:37:56.012]                   sendCondition(cond)
[13:37:56.012]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:56.012]                   {
[13:37:56.012]                     inherits <- base::inherits
[13:37:56.012]                     invokeRestart <- base::invokeRestart
[13:37:56.012]                     is.null <- base::is.null
[13:37:56.012]                     muffled <- FALSE
[13:37:56.012]                     if (inherits(cond, "message")) {
[13:37:56.012]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:56.012]                       if (muffled) 
[13:37:56.012]                         invokeRestart("muffleMessage")
[13:37:56.012]                     }
[13:37:56.012]                     else if (inherits(cond, "warning")) {
[13:37:56.012]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:56.012]                       if (muffled) 
[13:37:56.012]                         invokeRestart("muffleWarning")
[13:37:56.012]                     }
[13:37:56.012]                     else if (inherits(cond, "condition")) {
[13:37:56.012]                       if (!is.null(pattern)) {
[13:37:56.012]                         computeRestarts <- base::computeRestarts
[13:37:56.012]                         grepl <- base::grepl
[13:37:56.012]                         restarts <- computeRestarts(cond)
[13:37:56.012]                         for (restart in restarts) {
[13:37:56.012]                           name <- restart$name
[13:37:56.012]                           if (is.null(name)) 
[13:37:56.012]                             next
[13:37:56.012]                           if (!grepl(pattern, name)) 
[13:37:56.012]                             next
[13:37:56.012]                           invokeRestart(restart)
[13:37:56.012]                           muffled <- TRUE
[13:37:56.012]                           break
[13:37:56.012]                         }
[13:37:56.012]                       }
[13:37:56.012]                     }
[13:37:56.012]                     invisible(muffled)
[13:37:56.012]                   }
[13:37:56.012]                   muffleCondition(cond)
[13:37:56.012]                 })
[13:37:56.012]             }))
[13:37:56.012]             future::FutureResult(value = ...future.value$value, 
[13:37:56.012]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:56.012]                   ...future.rng), globalenv = if (FALSE) 
[13:37:56.012]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:56.012]                     ...future.globalenv.names))
[13:37:56.012]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:56.012]         }, condition = base::local({
[13:37:56.012]             c <- base::c
[13:37:56.012]             inherits <- base::inherits
[13:37:56.012]             invokeRestart <- base::invokeRestart
[13:37:56.012]             length <- base::length
[13:37:56.012]             list <- base::list
[13:37:56.012]             seq.int <- base::seq.int
[13:37:56.012]             signalCondition <- base::signalCondition
[13:37:56.012]             sys.calls <- base::sys.calls
[13:37:56.012]             `[[` <- base::`[[`
[13:37:56.012]             `+` <- base::`+`
[13:37:56.012]             `<<-` <- base::`<<-`
[13:37:56.012]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:56.012]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:56.012]                   3L)]
[13:37:56.012]             }
[13:37:56.012]             function(cond) {
[13:37:56.012]                 is_error <- inherits(cond, "error")
[13:37:56.012]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:56.012]                   NULL)
[13:37:56.012]                 if (is_error) {
[13:37:56.012]                   sessionInformation <- function() {
[13:37:56.012]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:56.012]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:56.012]                       search = base::search(), system = base::Sys.info())
[13:37:56.012]                   }
[13:37:56.012]                   ...future.conditions[[length(...future.conditions) + 
[13:37:56.012]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:56.012]                     cond$call), session = sessionInformation(), 
[13:37:56.012]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:56.012]                   signalCondition(cond)
[13:37:56.012]                 }
[13:37:56.012]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:56.012]                 "immediateCondition"))) {
[13:37:56.012]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:56.012]                   ...future.conditions[[length(...future.conditions) + 
[13:37:56.012]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:56.012]                   if (TRUE && !signal) {
[13:37:56.012]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:56.012]                     {
[13:37:56.012]                       inherits <- base::inherits
[13:37:56.012]                       invokeRestart <- base::invokeRestart
[13:37:56.012]                       is.null <- base::is.null
[13:37:56.012]                       muffled <- FALSE
[13:37:56.012]                       if (inherits(cond, "message")) {
[13:37:56.012]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:56.012]                         if (muffled) 
[13:37:56.012]                           invokeRestart("muffleMessage")
[13:37:56.012]                       }
[13:37:56.012]                       else if (inherits(cond, "warning")) {
[13:37:56.012]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:56.012]                         if (muffled) 
[13:37:56.012]                           invokeRestart("muffleWarning")
[13:37:56.012]                       }
[13:37:56.012]                       else if (inherits(cond, "condition")) {
[13:37:56.012]                         if (!is.null(pattern)) {
[13:37:56.012]                           computeRestarts <- base::computeRestarts
[13:37:56.012]                           grepl <- base::grepl
[13:37:56.012]                           restarts <- computeRestarts(cond)
[13:37:56.012]                           for (restart in restarts) {
[13:37:56.012]                             name <- restart$name
[13:37:56.012]                             if (is.null(name)) 
[13:37:56.012]                               next
[13:37:56.012]                             if (!grepl(pattern, name)) 
[13:37:56.012]                               next
[13:37:56.012]                             invokeRestart(restart)
[13:37:56.012]                             muffled <- TRUE
[13:37:56.012]                             break
[13:37:56.012]                           }
[13:37:56.012]                         }
[13:37:56.012]                       }
[13:37:56.012]                       invisible(muffled)
[13:37:56.012]                     }
[13:37:56.012]                     muffleCondition(cond, pattern = "^muffle")
[13:37:56.012]                   }
[13:37:56.012]                 }
[13:37:56.012]                 else {
[13:37:56.012]                   if (TRUE) {
[13:37:56.012]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:56.012]                     {
[13:37:56.012]                       inherits <- base::inherits
[13:37:56.012]                       invokeRestart <- base::invokeRestart
[13:37:56.012]                       is.null <- base::is.null
[13:37:56.012]                       muffled <- FALSE
[13:37:56.012]                       if (inherits(cond, "message")) {
[13:37:56.012]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:56.012]                         if (muffled) 
[13:37:56.012]                           invokeRestart("muffleMessage")
[13:37:56.012]                       }
[13:37:56.012]                       else if (inherits(cond, "warning")) {
[13:37:56.012]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:56.012]                         if (muffled) 
[13:37:56.012]                           invokeRestart("muffleWarning")
[13:37:56.012]                       }
[13:37:56.012]                       else if (inherits(cond, "condition")) {
[13:37:56.012]                         if (!is.null(pattern)) {
[13:37:56.012]                           computeRestarts <- base::computeRestarts
[13:37:56.012]                           grepl <- base::grepl
[13:37:56.012]                           restarts <- computeRestarts(cond)
[13:37:56.012]                           for (restart in restarts) {
[13:37:56.012]                             name <- restart$name
[13:37:56.012]                             if (is.null(name)) 
[13:37:56.012]                               next
[13:37:56.012]                             if (!grepl(pattern, name)) 
[13:37:56.012]                               next
[13:37:56.012]                             invokeRestart(restart)
[13:37:56.012]                             muffled <- TRUE
[13:37:56.012]                             break
[13:37:56.012]                           }
[13:37:56.012]                         }
[13:37:56.012]                       }
[13:37:56.012]                       invisible(muffled)
[13:37:56.012]                     }
[13:37:56.012]                     muffleCondition(cond, pattern = "^muffle")
[13:37:56.012]                   }
[13:37:56.012]                 }
[13:37:56.012]             }
[13:37:56.012]         }))
[13:37:56.012]     }, error = function(ex) {
[13:37:56.012]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:56.012]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:56.012]                 ...future.rng), started = ...future.startTime, 
[13:37:56.012]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:56.012]             version = "1.8"), class = "FutureResult")
[13:37:56.012]     }, finally = {
[13:37:56.012]         if (!identical(...future.workdir, getwd())) 
[13:37:56.012]             setwd(...future.workdir)
[13:37:56.012]         {
[13:37:56.012]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:56.012]                 ...future.oldOptions$nwarnings <- NULL
[13:37:56.012]             }
[13:37:56.012]             base::options(...future.oldOptions)
[13:37:56.012]             if (.Platform$OS.type == "windows") {
[13:37:56.012]                 old_names <- names(...future.oldEnvVars)
[13:37:56.012]                 envs <- base::Sys.getenv()
[13:37:56.012]                 names <- names(envs)
[13:37:56.012]                 common <- intersect(names, old_names)
[13:37:56.012]                 added <- setdiff(names, old_names)
[13:37:56.012]                 removed <- setdiff(old_names, names)
[13:37:56.012]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:56.012]                   envs[common]]
[13:37:56.012]                 NAMES <- toupper(changed)
[13:37:56.012]                 args <- list()
[13:37:56.012]                 for (kk in seq_along(NAMES)) {
[13:37:56.012]                   name <- changed[[kk]]
[13:37:56.012]                   NAME <- NAMES[[kk]]
[13:37:56.012]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:56.012]                     next
[13:37:56.012]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:56.012]                 }
[13:37:56.012]                 NAMES <- toupper(added)
[13:37:56.012]                 for (kk in seq_along(NAMES)) {
[13:37:56.012]                   name <- added[[kk]]
[13:37:56.012]                   NAME <- NAMES[[kk]]
[13:37:56.012]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:56.012]                     next
[13:37:56.012]                   args[[name]] <- ""
[13:37:56.012]                 }
[13:37:56.012]                 NAMES <- toupper(removed)
[13:37:56.012]                 for (kk in seq_along(NAMES)) {
[13:37:56.012]                   name <- removed[[kk]]
[13:37:56.012]                   NAME <- NAMES[[kk]]
[13:37:56.012]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:56.012]                     next
[13:37:56.012]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:56.012]                 }
[13:37:56.012]                 if (length(args) > 0) 
[13:37:56.012]                   base::do.call(base::Sys.setenv, args = args)
[13:37:56.012]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:56.012]             }
[13:37:56.012]             else {
[13:37:56.012]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:56.012]             }
[13:37:56.012]             {
[13:37:56.012]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:56.012]                   0L) {
[13:37:56.012]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:56.012]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:56.012]                   base::options(opts)
[13:37:56.012]                 }
[13:37:56.012]                 {
[13:37:56.012]                   {
[13:37:56.012]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:56.012]                     NULL
[13:37:56.012]                   }
[13:37:56.012]                   options(future.plan = NULL)
[13:37:56.012]                   if (is.na(NA_character_)) 
[13:37:56.012]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:56.012]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:56.012]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:56.012]                     .init = FALSE)
[13:37:56.012]                 }
[13:37:56.012]             }
[13:37:56.012]         }
[13:37:56.012]     })
[13:37:56.012]     if (TRUE) {
[13:37:56.012]         base::sink(type = "output", split = FALSE)
[13:37:56.012]         if (TRUE) {
[13:37:56.012]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:56.012]         }
[13:37:56.012]         else {
[13:37:56.012]             ...future.result["stdout"] <- base::list(NULL)
[13:37:56.012]         }
[13:37:56.012]         base::close(...future.stdout)
[13:37:56.012]         ...future.stdout <- NULL
[13:37:56.012]     }
[13:37:56.012]     ...future.result$conditions <- ...future.conditions
[13:37:56.012]     ...future.result$finished <- base::Sys.time()
[13:37:56.012]     ...future.result
[13:37:56.012] }
[13:37:56.015] MultisessionFuture started
[13:37:56.015] - Launch lazy future ... done
[13:37:56.015] run() for ‘MultisessionFuture’ ... done
[13:37:56.015] getGlobalsAndPackages() ...
[13:37:56.015] Searching for globals...
[13:37:56.016] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:37:56.016] Searching for globals ... DONE
[13:37:56.016] Resolving globals: FALSE
[13:37:56.017] 
[13:37:56.017] 
[13:37:56.017] getGlobalsAndPackages() ... DONE
- w/ exception ...
[13:37:56.017] getGlobalsAndPackages() ...
[13:37:56.017] Searching for globals...
[13:37:56.018] - globals found: [2] ‘list’, ‘stop’
[13:37:56.018] Searching for globals ... DONE
[13:37:56.018] Resolving globals: FALSE
[13:37:56.018] 
[13:37:56.019] 
[13:37:56.019] getGlobalsAndPackages() ... DONE
[13:37:56.019] run() for ‘Future’ ...
[13:37:56.019] - state: ‘created’
[13:37:56.019] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:56.032] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:56.032] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:56.033]   - Field: ‘node’
[13:37:56.033]   - Field: ‘label’
[13:37:56.033]   - Field: ‘local’
[13:37:56.033]   - Field: ‘owner’
[13:37:56.033]   - Field: ‘envir’
[13:37:56.033]   - Field: ‘workers’
[13:37:56.033]   - Field: ‘packages’
[13:37:56.033]   - Field: ‘gc’
[13:37:56.033]   - Field: ‘conditions’
[13:37:56.033]   - Field: ‘persistent’
[13:37:56.034]   - Field: ‘expr’
[13:37:56.034]   - Field: ‘uuid’
[13:37:56.034]   - Field: ‘seed’
[13:37:56.034]   - Field: ‘version’
[13:37:56.034]   - Field: ‘result’
[13:37:56.034]   - Field: ‘asynchronous’
[13:37:56.034]   - Field: ‘calls’
[13:37:56.034]   - Field: ‘globals’
[13:37:56.034]   - Field: ‘stdout’
[13:37:56.034]   - Field: ‘earlySignal’
[13:37:56.035]   - Field: ‘lazy’
[13:37:56.035]   - Field: ‘state’
[13:37:56.035] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:56.035] - Launch lazy future ...
[13:37:56.035] Packages needed by the future expression (n = 0): <none>
[13:37:56.035] Packages needed by future strategies (n = 0): <none>
[13:37:56.036] {
[13:37:56.036]     {
[13:37:56.036]         {
[13:37:56.036]             ...future.startTime <- base::Sys.time()
[13:37:56.036]             {
[13:37:56.036]                 {
[13:37:56.036]                   {
[13:37:56.036]                     {
[13:37:56.036]                       base::local({
[13:37:56.036]                         has_future <- base::requireNamespace("future", 
[13:37:56.036]                           quietly = TRUE)
[13:37:56.036]                         if (has_future) {
[13:37:56.036]                           ns <- base::getNamespace("future")
[13:37:56.036]                           version <- ns[[".package"]][["version"]]
[13:37:56.036]                           if (is.null(version)) 
[13:37:56.036]                             version <- utils::packageVersion("future")
[13:37:56.036]                         }
[13:37:56.036]                         else {
[13:37:56.036]                           version <- NULL
[13:37:56.036]                         }
[13:37:56.036]                         if (!has_future || version < "1.8.0") {
[13:37:56.036]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:56.036]                             "", base::R.version$version.string), 
[13:37:56.036]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:56.036]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:56.036]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:56.036]                               "release", "version")], collapse = " "), 
[13:37:56.036]                             hostname = base::Sys.info()[["nodename"]])
[13:37:56.036]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:56.036]                             info)
[13:37:56.036]                           info <- base::paste(info, collapse = "; ")
[13:37:56.036]                           if (!has_future) {
[13:37:56.036]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:56.036]                               info)
[13:37:56.036]                           }
[13:37:56.036]                           else {
[13:37:56.036]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:56.036]                               info, version)
[13:37:56.036]                           }
[13:37:56.036]                           base::stop(msg)
[13:37:56.036]                         }
[13:37:56.036]                       })
[13:37:56.036]                     }
[13:37:56.036]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:56.036]                     base::options(mc.cores = 1L)
[13:37:56.036]                   }
[13:37:56.036]                   ...future.strategy.old <- future::plan("list")
[13:37:56.036]                   options(future.plan = NULL)
[13:37:56.036]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:56.036]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:56.036]                 }
[13:37:56.036]                 ...future.workdir <- getwd()
[13:37:56.036]             }
[13:37:56.036]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:56.036]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:56.036]         }
[13:37:56.036]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:56.036]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:56.036]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:56.036]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:56.036]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:56.036]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:56.036]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:56.036]             base::names(...future.oldOptions))
[13:37:56.036]     }
[13:37:56.036]     if (FALSE) {
[13:37:56.036]     }
[13:37:56.036]     else {
[13:37:56.036]         if (TRUE) {
[13:37:56.036]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:56.036]                 open = "w")
[13:37:56.036]         }
[13:37:56.036]         else {
[13:37:56.036]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:56.036]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:56.036]         }
[13:37:56.036]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:56.036]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:56.036]             base::sink(type = "output", split = FALSE)
[13:37:56.036]             base::close(...future.stdout)
[13:37:56.036]         }, add = TRUE)
[13:37:56.036]     }
[13:37:56.036]     ...future.frame <- base::sys.nframe()
[13:37:56.036]     ...future.conditions <- base::list()
[13:37:56.036]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:56.036]     if (FALSE) {
[13:37:56.036]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:56.036]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:56.036]     }
[13:37:56.036]     ...future.result <- base::tryCatch({
[13:37:56.036]         base::withCallingHandlers({
[13:37:56.036]             ...future.value <- base::withVisible(base::local({
[13:37:56.036]                 ...future.makeSendCondition <- base::local({
[13:37:56.036]                   sendCondition <- NULL
[13:37:56.036]                   function(frame = 1L) {
[13:37:56.036]                     if (is.function(sendCondition)) 
[13:37:56.036]                       return(sendCondition)
[13:37:56.036]                     ns <- getNamespace("parallel")
[13:37:56.036]                     if (exists("sendData", mode = "function", 
[13:37:56.036]                       envir = ns)) {
[13:37:56.036]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:56.036]                         envir = ns)
[13:37:56.036]                       envir <- sys.frame(frame)
[13:37:56.036]                       master <- NULL
[13:37:56.036]                       while (!identical(envir, .GlobalEnv) && 
[13:37:56.036]                         !identical(envir, emptyenv())) {
[13:37:56.036]                         if (exists("master", mode = "list", envir = envir, 
[13:37:56.036]                           inherits = FALSE)) {
[13:37:56.036]                           master <- get("master", mode = "list", 
[13:37:56.036]                             envir = envir, inherits = FALSE)
[13:37:56.036]                           if (inherits(master, c("SOCKnode", 
[13:37:56.036]                             "SOCK0node"))) {
[13:37:56.036]                             sendCondition <<- function(cond) {
[13:37:56.036]                               data <- list(type = "VALUE", value = cond, 
[13:37:56.036]                                 success = TRUE)
[13:37:56.036]                               parallel_sendData(master, data)
[13:37:56.036]                             }
[13:37:56.036]                             return(sendCondition)
[13:37:56.036]                           }
[13:37:56.036]                         }
[13:37:56.036]                         frame <- frame + 1L
[13:37:56.036]                         envir <- sys.frame(frame)
[13:37:56.036]                       }
[13:37:56.036]                     }
[13:37:56.036]                     sendCondition <<- function(cond) NULL
[13:37:56.036]                   }
[13:37:56.036]                 })
[13:37:56.036]                 withCallingHandlers({
[13:37:56.036]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:37:56.036]                 }, immediateCondition = function(cond) {
[13:37:56.036]                   sendCondition <- ...future.makeSendCondition()
[13:37:56.036]                   sendCondition(cond)
[13:37:56.036]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:56.036]                   {
[13:37:56.036]                     inherits <- base::inherits
[13:37:56.036]                     invokeRestart <- base::invokeRestart
[13:37:56.036]                     is.null <- base::is.null
[13:37:56.036]                     muffled <- FALSE
[13:37:56.036]                     if (inherits(cond, "message")) {
[13:37:56.036]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:56.036]                       if (muffled) 
[13:37:56.036]                         invokeRestart("muffleMessage")
[13:37:56.036]                     }
[13:37:56.036]                     else if (inherits(cond, "warning")) {
[13:37:56.036]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:56.036]                       if (muffled) 
[13:37:56.036]                         invokeRestart("muffleWarning")
[13:37:56.036]                     }
[13:37:56.036]                     else if (inherits(cond, "condition")) {
[13:37:56.036]                       if (!is.null(pattern)) {
[13:37:56.036]                         computeRestarts <- base::computeRestarts
[13:37:56.036]                         grepl <- base::grepl
[13:37:56.036]                         restarts <- computeRestarts(cond)
[13:37:56.036]                         for (restart in restarts) {
[13:37:56.036]                           name <- restart$name
[13:37:56.036]                           if (is.null(name)) 
[13:37:56.036]                             next
[13:37:56.036]                           if (!grepl(pattern, name)) 
[13:37:56.036]                             next
[13:37:56.036]                           invokeRestart(restart)
[13:37:56.036]                           muffled <- TRUE
[13:37:56.036]                           break
[13:37:56.036]                         }
[13:37:56.036]                       }
[13:37:56.036]                     }
[13:37:56.036]                     invisible(muffled)
[13:37:56.036]                   }
[13:37:56.036]                   muffleCondition(cond)
[13:37:56.036]                 })
[13:37:56.036]             }))
[13:37:56.036]             future::FutureResult(value = ...future.value$value, 
[13:37:56.036]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:56.036]                   ...future.rng), globalenv = if (FALSE) 
[13:37:56.036]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:56.036]                     ...future.globalenv.names))
[13:37:56.036]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:56.036]         }, condition = base::local({
[13:37:56.036]             c <- base::c
[13:37:56.036]             inherits <- base::inherits
[13:37:56.036]             invokeRestart <- base::invokeRestart
[13:37:56.036]             length <- base::length
[13:37:56.036]             list <- base::list
[13:37:56.036]             seq.int <- base::seq.int
[13:37:56.036]             signalCondition <- base::signalCondition
[13:37:56.036]             sys.calls <- base::sys.calls
[13:37:56.036]             `[[` <- base::`[[`
[13:37:56.036]             `+` <- base::`+`
[13:37:56.036]             `<<-` <- base::`<<-`
[13:37:56.036]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:56.036]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:56.036]                   3L)]
[13:37:56.036]             }
[13:37:56.036]             function(cond) {
[13:37:56.036]                 is_error <- inherits(cond, "error")
[13:37:56.036]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:56.036]                   NULL)
[13:37:56.036]                 if (is_error) {
[13:37:56.036]                   sessionInformation <- function() {
[13:37:56.036]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:56.036]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:56.036]                       search = base::search(), system = base::Sys.info())
[13:37:56.036]                   }
[13:37:56.036]                   ...future.conditions[[length(...future.conditions) + 
[13:37:56.036]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:56.036]                     cond$call), session = sessionInformation(), 
[13:37:56.036]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:56.036]                   signalCondition(cond)
[13:37:56.036]                 }
[13:37:56.036]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:56.036]                 "immediateCondition"))) {
[13:37:56.036]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:56.036]                   ...future.conditions[[length(...future.conditions) + 
[13:37:56.036]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:56.036]                   if (TRUE && !signal) {
[13:37:56.036]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:56.036]                     {
[13:37:56.036]                       inherits <- base::inherits
[13:37:56.036]                       invokeRestart <- base::invokeRestart
[13:37:56.036]                       is.null <- base::is.null
[13:37:56.036]                       muffled <- FALSE
[13:37:56.036]                       if (inherits(cond, "message")) {
[13:37:56.036]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:56.036]                         if (muffled) 
[13:37:56.036]                           invokeRestart("muffleMessage")
[13:37:56.036]                       }
[13:37:56.036]                       else if (inherits(cond, "warning")) {
[13:37:56.036]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:56.036]                         if (muffled) 
[13:37:56.036]                           invokeRestart("muffleWarning")
[13:37:56.036]                       }
[13:37:56.036]                       else if (inherits(cond, "condition")) {
[13:37:56.036]                         if (!is.null(pattern)) {
[13:37:56.036]                           computeRestarts <- base::computeRestarts
[13:37:56.036]                           grepl <- base::grepl
[13:37:56.036]                           restarts <- computeRestarts(cond)
[13:37:56.036]                           for (restart in restarts) {
[13:37:56.036]                             name <- restart$name
[13:37:56.036]                             if (is.null(name)) 
[13:37:56.036]                               next
[13:37:56.036]                             if (!grepl(pattern, name)) 
[13:37:56.036]                               next
[13:37:56.036]                             invokeRestart(restart)
[13:37:56.036]                             muffled <- TRUE
[13:37:56.036]                             break
[13:37:56.036]                           }
[13:37:56.036]                         }
[13:37:56.036]                       }
[13:37:56.036]                       invisible(muffled)
[13:37:56.036]                     }
[13:37:56.036]                     muffleCondition(cond, pattern = "^muffle")
[13:37:56.036]                   }
[13:37:56.036]                 }
[13:37:56.036]                 else {
[13:37:56.036]                   if (TRUE) {
[13:37:56.036]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:56.036]                     {
[13:37:56.036]                       inherits <- base::inherits
[13:37:56.036]                       invokeRestart <- base::invokeRestart
[13:37:56.036]                       is.null <- base::is.null
[13:37:56.036]                       muffled <- FALSE
[13:37:56.036]                       if (inherits(cond, "message")) {
[13:37:56.036]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:56.036]                         if (muffled) 
[13:37:56.036]                           invokeRestart("muffleMessage")
[13:37:56.036]                       }
[13:37:56.036]                       else if (inherits(cond, "warning")) {
[13:37:56.036]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:56.036]                         if (muffled) 
[13:37:56.036]                           invokeRestart("muffleWarning")
[13:37:56.036]                       }
[13:37:56.036]                       else if (inherits(cond, "condition")) {
[13:37:56.036]                         if (!is.null(pattern)) {
[13:37:56.036]                           computeRestarts <- base::computeRestarts
[13:37:56.036]                           grepl <- base::grepl
[13:37:56.036]                           restarts <- computeRestarts(cond)
[13:37:56.036]                           for (restart in restarts) {
[13:37:56.036]                             name <- restart$name
[13:37:56.036]                             if (is.null(name)) 
[13:37:56.036]                               next
[13:37:56.036]                             if (!grepl(pattern, name)) 
[13:37:56.036]                               next
[13:37:56.036]                             invokeRestart(restart)
[13:37:56.036]                             muffled <- TRUE
[13:37:56.036]                             break
[13:37:56.036]                           }
[13:37:56.036]                         }
[13:37:56.036]                       }
[13:37:56.036]                       invisible(muffled)
[13:37:56.036]                     }
[13:37:56.036]                     muffleCondition(cond, pattern = "^muffle")
[13:37:56.036]                   }
[13:37:56.036]                 }
[13:37:56.036]             }
[13:37:56.036]         }))
[13:37:56.036]     }, error = function(ex) {
[13:37:56.036]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:56.036]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:56.036]                 ...future.rng), started = ...future.startTime, 
[13:37:56.036]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:56.036]             version = "1.8"), class = "FutureResult")
[13:37:56.036]     }, finally = {
[13:37:56.036]         if (!identical(...future.workdir, getwd())) 
[13:37:56.036]             setwd(...future.workdir)
[13:37:56.036]         {
[13:37:56.036]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:56.036]                 ...future.oldOptions$nwarnings <- NULL
[13:37:56.036]             }
[13:37:56.036]             base::options(...future.oldOptions)
[13:37:56.036]             if (.Platform$OS.type == "windows") {
[13:37:56.036]                 old_names <- names(...future.oldEnvVars)
[13:37:56.036]                 envs <- base::Sys.getenv()
[13:37:56.036]                 names <- names(envs)
[13:37:56.036]                 common <- intersect(names, old_names)
[13:37:56.036]                 added <- setdiff(names, old_names)
[13:37:56.036]                 removed <- setdiff(old_names, names)
[13:37:56.036]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:56.036]                   envs[common]]
[13:37:56.036]                 NAMES <- toupper(changed)
[13:37:56.036]                 args <- list()
[13:37:56.036]                 for (kk in seq_along(NAMES)) {
[13:37:56.036]                   name <- changed[[kk]]
[13:37:56.036]                   NAME <- NAMES[[kk]]
[13:37:56.036]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:56.036]                     next
[13:37:56.036]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:56.036]                 }
[13:37:56.036]                 NAMES <- toupper(added)
[13:37:56.036]                 for (kk in seq_along(NAMES)) {
[13:37:56.036]                   name <- added[[kk]]
[13:37:56.036]                   NAME <- NAMES[[kk]]
[13:37:56.036]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:56.036]                     next
[13:37:56.036]                   args[[name]] <- ""
[13:37:56.036]                 }
[13:37:56.036]                 NAMES <- toupper(removed)
[13:37:56.036]                 for (kk in seq_along(NAMES)) {
[13:37:56.036]                   name <- removed[[kk]]
[13:37:56.036]                   NAME <- NAMES[[kk]]
[13:37:56.036]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:56.036]                     next
[13:37:56.036]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:56.036]                 }
[13:37:56.036]                 if (length(args) > 0) 
[13:37:56.036]                   base::do.call(base::Sys.setenv, args = args)
[13:37:56.036]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:56.036]             }
[13:37:56.036]             else {
[13:37:56.036]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:56.036]             }
[13:37:56.036]             {
[13:37:56.036]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:56.036]                   0L) {
[13:37:56.036]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:56.036]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:56.036]                   base::options(opts)
[13:37:56.036]                 }
[13:37:56.036]                 {
[13:37:56.036]                   {
[13:37:56.036]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:56.036]                     NULL
[13:37:56.036]                   }
[13:37:56.036]                   options(future.plan = NULL)
[13:37:56.036]                   if (is.na(NA_character_)) 
[13:37:56.036]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:56.036]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:56.036]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:56.036]                     .init = FALSE)
[13:37:56.036]                 }
[13:37:56.036]             }
[13:37:56.036]         }
[13:37:56.036]     })
[13:37:56.036]     if (TRUE) {
[13:37:56.036]         base::sink(type = "output", split = FALSE)
[13:37:56.036]         if (TRUE) {
[13:37:56.036]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:56.036]         }
[13:37:56.036]         else {
[13:37:56.036]             ...future.result["stdout"] <- base::list(NULL)
[13:37:56.036]         }
[13:37:56.036]         base::close(...future.stdout)
[13:37:56.036]         ...future.stdout <- NULL
[13:37:56.036]     }
[13:37:56.036]     ...future.result$conditions <- ...future.conditions
[13:37:56.036]     ...future.result$finished <- base::Sys.time()
[13:37:56.036]     ...future.result
[13:37:56.036] }
[13:37:56.038] Poll #1 (0): usedNodes() = 2, workers = 2
[13:37:56.048] receiveMessageFromWorker() for ClusterFuture ...
[13:37:56.048] - Validating connection of MultisessionFuture
[13:37:56.049] - received message: FutureResult
[13:37:56.049] - Received FutureResult
[13:37:56.049] - Erased future from FutureRegistry
[13:37:56.049] result() for ClusterFuture ...
[13:37:56.049] - result already collected: FutureResult
[13:37:56.049] result() for ClusterFuture ... done
[13:37:56.049] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:56.049] result() for ClusterFuture ...
[13:37:56.049] - result already collected: FutureResult
[13:37:56.050] result() for ClusterFuture ... done
[13:37:56.050] result() for ClusterFuture ...
[13:37:56.050] - result already collected: FutureResult
[13:37:56.050] result() for ClusterFuture ... done
[13:37:56.051] MultisessionFuture started
[13:37:56.051] - Launch lazy future ... done
[13:37:56.051] run() for ‘MultisessionFuture’ ... done
[13:37:56.051] getGlobalsAndPackages() ...
[13:37:56.052] Searching for globals...
[13:37:56.052] - globals found: [2] ‘list’, ‘stop’
[13:37:56.053] Searching for globals ... DONE
[13:37:56.053] Resolving globals: FALSE
[13:37:56.053] 
[13:37:56.053] 
[13:37:56.054] getGlobalsAndPackages() ... DONE
- result = TRUE, recursive = -1 ... DONE
- result = TRUE, recursive = 0 ...
[13:37:56.054] getGlobalsAndPackages() ...
[13:37:56.054] Searching for globals...
[13:37:56.055] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:37:56.055] Searching for globals ... DONE
[13:37:56.055] Resolving globals: FALSE
[13:37:56.056] 
[13:37:56.056] 
[13:37:56.056] getGlobalsAndPackages() ... DONE
[13:37:56.056] run() for ‘Future’ ...
[13:37:56.056] - state: ‘created’
[13:37:56.056] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:56.070] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:56.070] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:56.070]   - Field: ‘node’
[13:37:56.070]   - Field: ‘label’
[13:37:56.070]   - Field: ‘local’
[13:37:56.070]   - Field: ‘owner’
[13:37:56.070]   - Field: ‘envir’
[13:37:56.071]   - Field: ‘workers’
[13:37:56.071]   - Field: ‘packages’
[13:37:56.071]   - Field: ‘gc’
[13:37:56.071]   - Field: ‘conditions’
[13:37:56.071]   - Field: ‘persistent’
[13:37:56.071]   - Field: ‘expr’
[13:37:56.071]   - Field: ‘uuid’
[13:37:56.071]   - Field: ‘seed’
[13:37:56.071]   - Field: ‘version’
[13:37:56.071]   - Field: ‘result’
[13:37:56.071]   - Field: ‘asynchronous’
[13:37:56.071]   - Field: ‘calls’
[13:37:56.072]   - Field: ‘globals’
[13:37:56.072]   - Field: ‘stdout’
[13:37:56.072]   - Field: ‘earlySignal’
[13:37:56.072]   - Field: ‘lazy’
[13:37:56.072]   - Field: ‘state’
[13:37:56.072] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:56.072] - Launch lazy future ...
[13:37:56.072] Packages needed by the future expression (n = 0): <none>
[13:37:56.072] Packages needed by future strategies (n = 0): <none>
[13:37:56.073] {
[13:37:56.073]     {
[13:37:56.073]         {
[13:37:56.073]             ...future.startTime <- base::Sys.time()
[13:37:56.073]             {
[13:37:56.073]                 {
[13:37:56.073]                   {
[13:37:56.073]                     {
[13:37:56.073]                       base::local({
[13:37:56.073]                         has_future <- base::requireNamespace("future", 
[13:37:56.073]                           quietly = TRUE)
[13:37:56.073]                         if (has_future) {
[13:37:56.073]                           ns <- base::getNamespace("future")
[13:37:56.073]                           version <- ns[[".package"]][["version"]]
[13:37:56.073]                           if (is.null(version)) 
[13:37:56.073]                             version <- utils::packageVersion("future")
[13:37:56.073]                         }
[13:37:56.073]                         else {
[13:37:56.073]                           version <- NULL
[13:37:56.073]                         }
[13:37:56.073]                         if (!has_future || version < "1.8.0") {
[13:37:56.073]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:56.073]                             "", base::R.version$version.string), 
[13:37:56.073]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:56.073]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:56.073]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:56.073]                               "release", "version")], collapse = " "), 
[13:37:56.073]                             hostname = base::Sys.info()[["nodename"]])
[13:37:56.073]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:56.073]                             info)
[13:37:56.073]                           info <- base::paste(info, collapse = "; ")
[13:37:56.073]                           if (!has_future) {
[13:37:56.073]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:56.073]                               info)
[13:37:56.073]                           }
[13:37:56.073]                           else {
[13:37:56.073]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:56.073]                               info, version)
[13:37:56.073]                           }
[13:37:56.073]                           base::stop(msg)
[13:37:56.073]                         }
[13:37:56.073]                       })
[13:37:56.073]                     }
[13:37:56.073]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:56.073]                     base::options(mc.cores = 1L)
[13:37:56.073]                   }
[13:37:56.073]                   ...future.strategy.old <- future::plan("list")
[13:37:56.073]                   options(future.plan = NULL)
[13:37:56.073]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:56.073]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:56.073]                 }
[13:37:56.073]                 ...future.workdir <- getwd()
[13:37:56.073]             }
[13:37:56.073]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:56.073]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:56.073]         }
[13:37:56.073]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:56.073]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:56.073]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:56.073]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:56.073]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:56.073]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:56.073]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:56.073]             base::names(...future.oldOptions))
[13:37:56.073]     }
[13:37:56.073]     if (FALSE) {
[13:37:56.073]     }
[13:37:56.073]     else {
[13:37:56.073]         if (TRUE) {
[13:37:56.073]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:56.073]                 open = "w")
[13:37:56.073]         }
[13:37:56.073]         else {
[13:37:56.073]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:56.073]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:56.073]         }
[13:37:56.073]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:56.073]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:56.073]             base::sink(type = "output", split = FALSE)
[13:37:56.073]             base::close(...future.stdout)
[13:37:56.073]         }, add = TRUE)
[13:37:56.073]     }
[13:37:56.073]     ...future.frame <- base::sys.nframe()
[13:37:56.073]     ...future.conditions <- base::list()
[13:37:56.073]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:56.073]     if (FALSE) {
[13:37:56.073]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:56.073]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:56.073]     }
[13:37:56.073]     ...future.result <- base::tryCatch({
[13:37:56.073]         base::withCallingHandlers({
[13:37:56.073]             ...future.value <- base::withVisible(base::local({
[13:37:56.073]                 ...future.makeSendCondition <- base::local({
[13:37:56.073]                   sendCondition <- NULL
[13:37:56.073]                   function(frame = 1L) {
[13:37:56.073]                     if (is.function(sendCondition)) 
[13:37:56.073]                       return(sendCondition)
[13:37:56.073]                     ns <- getNamespace("parallel")
[13:37:56.073]                     if (exists("sendData", mode = "function", 
[13:37:56.073]                       envir = ns)) {
[13:37:56.073]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:56.073]                         envir = ns)
[13:37:56.073]                       envir <- sys.frame(frame)
[13:37:56.073]                       master <- NULL
[13:37:56.073]                       while (!identical(envir, .GlobalEnv) && 
[13:37:56.073]                         !identical(envir, emptyenv())) {
[13:37:56.073]                         if (exists("master", mode = "list", envir = envir, 
[13:37:56.073]                           inherits = FALSE)) {
[13:37:56.073]                           master <- get("master", mode = "list", 
[13:37:56.073]                             envir = envir, inherits = FALSE)
[13:37:56.073]                           if (inherits(master, c("SOCKnode", 
[13:37:56.073]                             "SOCK0node"))) {
[13:37:56.073]                             sendCondition <<- function(cond) {
[13:37:56.073]                               data <- list(type = "VALUE", value = cond, 
[13:37:56.073]                                 success = TRUE)
[13:37:56.073]                               parallel_sendData(master, data)
[13:37:56.073]                             }
[13:37:56.073]                             return(sendCondition)
[13:37:56.073]                           }
[13:37:56.073]                         }
[13:37:56.073]                         frame <- frame + 1L
[13:37:56.073]                         envir <- sys.frame(frame)
[13:37:56.073]                       }
[13:37:56.073]                     }
[13:37:56.073]                     sendCondition <<- function(cond) NULL
[13:37:56.073]                   }
[13:37:56.073]                 })
[13:37:56.073]                 withCallingHandlers({
[13:37:56.073]                   {
[13:37:56.073]                     Sys.sleep(0.5)
[13:37:56.073]                     list(a = 1, b = 42L)
[13:37:56.073]                   }
[13:37:56.073]                 }, immediateCondition = function(cond) {
[13:37:56.073]                   sendCondition <- ...future.makeSendCondition()
[13:37:56.073]                   sendCondition(cond)
[13:37:56.073]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:56.073]                   {
[13:37:56.073]                     inherits <- base::inherits
[13:37:56.073]                     invokeRestart <- base::invokeRestart
[13:37:56.073]                     is.null <- base::is.null
[13:37:56.073]                     muffled <- FALSE
[13:37:56.073]                     if (inherits(cond, "message")) {
[13:37:56.073]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:56.073]                       if (muffled) 
[13:37:56.073]                         invokeRestart("muffleMessage")
[13:37:56.073]                     }
[13:37:56.073]                     else if (inherits(cond, "warning")) {
[13:37:56.073]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:56.073]                       if (muffled) 
[13:37:56.073]                         invokeRestart("muffleWarning")
[13:37:56.073]                     }
[13:37:56.073]                     else if (inherits(cond, "condition")) {
[13:37:56.073]                       if (!is.null(pattern)) {
[13:37:56.073]                         computeRestarts <- base::computeRestarts
[13:37:56.073]                         grepl <- base::grepl
[13:37:56.073]                         restarts <- computeRestarts(cond)
[13:37:56.073]                         for (restart in restarts) {
[13:37:56.073]                           name <- restart$name
[13:37:56.073]                           if (is.null(name)) 
[13:37:56.073]                             next
[13:37:56.073]                           if (!grepl(pattern, name)) 
[13:37:56.073]                             next
[13:37:56.073]                           invokeRestart(restart)
[13:37:56.073]                           muffled <- TRUE
[13:37:56.073]                           break
[13:37:56.073]                         }
[13:37:56.073]                       }
[13:37:56.073]                     }
[13:37:56.073]                     invisible(muffled)
[13:37:56.073]                   }
[13:37:56.073]                   muffleCondition(cond)
[13:37:56.073]                 })
[13:37:56.073]             }))
[13:37:56.073]             future::FutureResult(value = ...future.value$value, 
[13:37:56.073]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:56.073]                   ...future.rng), globalenv = if (FALSE) 
[13:37:56.073]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:56.073]                     ...future.globalenv.names))
[13:37:56.073]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:56.073]         }, condition = base::local({
[13:37:56.073]             c <- base::c
[13:37:56.073]             inherits <- base::inherits
[13:37:56.073]             invokeRestart <- base::invokeRestart
[13:37:56.073]             length <- base::length
[13:37:56.073]             list <- base::list
[13:37:56.073]             seq.int <- base::seq.int
[13:37:56.073]             signalCondition <- base::signalCondition
[13:37:56.073]             sys.calls <- base::sys.calls
[13:37:56.073]             `[[` <- base::`[[`
[13:37:56.073]             `+` <- base::`+`
[13:37:56.073]             `<<-` <- base::`<<-`
[13:37:56.073]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:56.073]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:56.073]                   3L)]
[13:37:56.073]             }
[13:37:56.073]             function(cond) {
[13:37:56.073]                 is_error <- inherits(cond, "error")
[13:37:56.073]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:56.073]                   NULL)
[13:37:56.073]                 if (is_error) {
[13:37:56.073]                   sessionInformation <- function() {
[13:37:56.073]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:56.073]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:56.073]                       search = base::search(), system = base::Sys.info())
[13:37:56.073]                   }
[13:37:56.073]                   ...future.conditions[[length(...future.conditions) + 
[13:37:56.073]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:56.073]                     cond$call), session = sessionInformation(), 
[13:37:56.073]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:56.073]                   signalCondition(cond)
[13:37:56.073]                 }
[13:37:56.073]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:56.073]                 "immediateCondition"))) {
[13:37:56.073]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:56.073]                   ...future.conditions[[length(...future.conditions) + 
[13:37:56.073]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:56.073]                   if (TRUE && !signal) {
[13:37:56.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:56.073]                     {
[13:37:56.073]                       inherits <- base::inherits
[13:37:56.073]                       invokeRestart <- base::invokeRestart
[13:37:56.073]                       is.null <- base::is.null
[13:37:56.073]                       muffled <- FALSE
[13:37:56.073]                       if (inherits(cond, "message")) {
[13:37:56.073]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:56.073]                         if (muffled) 
[13:37:56.073]                           invokeRestart("muffleMessage")
[13:37:56.073]                       }
[13:37:56.073]                       else if (inherits(cond, "warning")) {
[13:37:56.073]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:56.073]                         if (muffled) 
[13:37:56.073]                           invokeRestart("muffleWarning")
[13:37:56.073]                       }
[13:37:56.073]                       else if (inherits(cond, "condition")) {
[13:37:56.073]                         if (!is.null(pattern)) {
[13:37:56.073]                           computeRestarts <- base::computeRestarts
[13:37:56.073]                           grepl <- base::grepl
[13:37:56.073]                           restarts <- computeRestarts(cond)
[13:37:56.073]                           for (restart in restarts) {
[13:37:56.073]                             name <- restart$name
[13:37:56.073]                             if (is.null(name)) 
[13:37:56.073]                               next
[13:37:56.073]                             if (!grepl(pattern, name)) 
[13:37:56.073]                               next
[13:37:56.073]                             invokeRestart(restart)
[13:37:56.073]                             muffled <- TRUE
[13:37:56.073]                             break
[13:37:56.073]                           }
[13:37:56.073]                         }
[13:37:56.073]                       }
[13:37:56.073]                       invisible(muffled)
[13:37:56.073]                     }
[13:37:56.073]                     muffleCondition(cond, pattern = "^muffle")
[13:37:56.073]                   }
[13:37:56.073]                 }
[13:37:56.073]                 else {
[13:37:56.073]                   if (TRUE) {
[13:37:56.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:56.073]                     {
[13:37:56.073]                       inherits <- base::inherits
[13:37:56.073]                       invokeRestart <- base::invokeRestart
[13:37:56.073]                       is.null <- base::is.null
[13:37:56.073]                       muffled <- FALSE
[13:37:56.073]                       if (inherits(cond, "message")) {
[13:37:56.073]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:56.073]                         if (muffled) 
[13:37:56.073]                           invokeRestart("muffleMessage")
[13:37:56.073]                       }
[13:37:56.073]                       else if (inherits(cond, "warning")) {
[13:37:56.073]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:56.073]                         if (muffled) 
[13:37:56.073]                           invokeRestart("muffleWarning")
[13:37:56.073]                       }
[13:37:56.073]                       else if (inherits(cond, "condition")) {
[13:37:56.073]                         if (!is.null(pattern)) {
[13:37:56.073]                           computeRestarts <- base::computeRestarts
[13:37:56.073]                           grepl <- base::grepl
[13:37:56.073]                           restarts <- computeRestarts(cond)
[13:37:56.073]                           for (restart in restarts) {
[13:37:56.073]                             name <- restart$name
[13:37:56.073]                             if (is.null(name)) 
[13:37:56.073]                               next
[13:37:56.073]                             if (!grepl(pattern, name)) 
[13:37:56.073]                               next
[13:37:56.073]                             invokeRestart(restart)
[13:37:56.073]                             muffled <- TRUE
[13:37:56.073]                             break
[13:37:56.073]                           }
[13:37:56.073]                         }
[13:37:56.073]                       }
[13:37:56.073]                       invisible(muffled)
[13:37:56.073]                     }
[13:37:56.073]                     muffleCondition(cond, pattern = "^muffle")
[13:37:56.073]                   }
[13:37:56.073]                 }
[13:37:56.073]             }
[13:37:56.073]         }))
[13:37:56.073]     }, error = function(ex) {
[13:37:56.073]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:56.073]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:56.073]                 ...future.rng), started = ...future.startTime, 
[13:37:56.073]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:56.073]             version = "1.8"), class = "FutureResult")
[13:37:56.073]     }, finally = {
[13:37:56.073]         if (!identical(...future.workdir, getwd())) 
[13:37:56.073]             setwd(...future.workdir)
[13:37:56.073]         {
[13:37:56.073]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:56.073]                 ...future.oldOptions$nwarnings <- NULL
[13:37:56.073]             }
[13:37:56.073]             base::options(...future.oldOptions)
[13:37:56.073]             if (.Platform$OS.type == "windows") {
[13:37:56.073]                 old_names <- names(...future.oldEnvVars)
[13:37:56.073]                 envs <- base::Sys.getenv()
[13:37:56.073]                 names <- names(envs)
[13:37:56.073]                 common <- intersect(names, old_names)
[13:37:56.073]                 added <- setdiff(names, old_names)
[13:37:56.073]                 removed <- setdiff(old_names, names)
[13:37:56.073]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:56.073]                   envs[common]]
[13:37:56.073]                 NAMES <- toupper(changed)
[13:37:56.073]                 args <- list()
[13:37:56.073]                 for (kk in seq_along(NAMES)) {
[13:37:56.073]                   name <- changed[[kk]]
[13:37:56.073]                   NAME <- NAMES[[kk]]
[13:37:56.073]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:56.073]                     next
[13:37:56.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:56.073]                 }
[13:37:56.073]                 NAMES <- toupper(added)
[13:37:56.073]                 for (kk in seq_along(NAMES)) {
[13:37:56.073]                   name <- added[[kk]]
[13:37:56.073]                   NAME <- NAMES[[kk]]
[13:37:56.073]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:56.073]                     next
[13:37:56.073]                   args[[name]] <- ""
[13:37:56.073]                 }
[13:37:56.073]                 NAMES <- toupper(removed)
[13:37:56.073]                 for (kk in seq_along(NAMES)) {
[13:37:56.073]                   name <- removed[[kk]]
[13:37:56.073]                   NAME <- NAMES[[kk]]
[13:37:56.073]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:56.073]                     next
[13:37:56.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:56.073]                 }
[13:37:56.073]                 if (length(args) > 0) 
[13:37:56.073]                   base::do.call(base::Sys.setenv, args = args)
[13:37:56.073]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:56.073]             }
[13:37:56.073]             else {
[13:37:56.073]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:56.073]             }
[13:37:56.073]             {
[13:37:56.073]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:56.073]                   0L) {
[13:37:56.073]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:56.073]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:56.073]                   base::options(opts)
[13:37:56.073]                 }
[13:37:56.073]                 {
[13:37:56.073]                   {
[13:37:56.073]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:56.073]                     NULL
[13:37:56.073]                   }
[13:37:56.073]                   options(future.plan = NULL)
[13:37:56.073]                   if (is.na(NA_character_)) 
[13:37:56.073]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:56.073]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:56.073]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:56.073]                     .init = FALSE)
[13:37:56.073]                 }
[13:37:56.073]             }
[13:37:56.073]         }
[13:37:56.073]     })
[13:37:56.073]     if (TRUE) {
[13:37:56.073]         base::sink(type = "output", split = FALSE)
[13:37:56.073]         if (TRUE) {
[13:37:56.073]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:56.073]         }
[13:37:56.073]         else {
[13:37:56.073]             ...future.result["stdout"] <- base::list(NULL)
[13:37:56.073]         }
[13:37:56.073]         base::close(...future.stdout)
[13:37:56.073]         ...future.stdout <- NULL
[13:37:56.073]     }
[13:37:56.073]     ...future.result$conditions <- ...future.conditions
[13:37:56.073]     ...future.result$finished <- base::Sys.time()
[13:37:56.073]     ...future.result
[13:37:56.073] }
[13:37:56.075] Poll #1 (0): usedNodes() = 2, workers = 2
[13:37:56.096] receiveMessageFromWorker() for ClusterFuture ...
[13:37:56.096] - Validating connection of MultisessionFuture
[13:37:56.097] - received message: FutureResult
[13:37:56.097] - Received FutureResult
[13:37:56.097] - Erased future from FutureRegistry
[13:37:56.097] result() for ClusterFuture ...
[13:37:56.097] - result already collected: FutureResult
[13:37:56.097] result() for ClusterFuture ... done
[13:37:56.097] signalConditions() ...
[13:37:56.097]  - include = ‘immediateCondition’
[13:37:56.097]  - exclude = 
[13:37:56.098]  - resignal = FALSE
[13:37:56.098]  - Number of conditions: 1
[13:37:56.098] signalConditions() ... done
[13:37:56.098] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:56.098] result() for ClusterFuture ...
[13:37:56.098] - result already collected: FutureResult
[13:37:56.098] result() for ClusterFuture ... done
[13:37:56.098] result() for ClusterFuture ...
[13:37:56.098] - result already collected: FutureResult
[13:37:56.098] result() for ClusterFuture ... done
[13:37:56.099] signalConditions() ...
[13:37:56.099]  - include = ‘immediateCondition’
[13:37:56.099]  - exclude = 
[13:37:56.099]  - resignal = FALSE
[13:37:56.099]  - Number of conditions: 1
[13:37:56.099] signalConditions() ... done
[13:37:56.100] MultisessionFuture started
[13:37:56.100] - Launch lazy future ... done
[13:37:56.100] run() for ‘MultisessionFuture’ ... done
[13:37:56.603] receiveMessageFromWorker() for ClusterFuture ...
[13:37:56.603] - Validating connection of MultisessionFuture
[13:37:56.603] - received message: FutureResult
[13:37:56.603] - Received FutureResult
[13:37:56.604] - Erased future from FutureRegistry
[13:37:56.604] result() for ClusterFuture ...
[13:37:56.604] - result already collected: FutureResult
[13:37:56.604] result() for ClusterFuture ... done
[13:37:56.604] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:56.604] A MultisessionFuture was resolved
[13:37:56.604] getGlobalsAndPackages() ...
[13:37:56.604] Searching for globals...
[13:37:56.605] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:37:56.606] Searching for globals ... DONE
[13:37:56.606] Resolving globals: FALSE
[13:37:56.606] 
[13:37:56.606] 
[13:37:56.606] getGlobalsAndPackages() ... DONE
[13:37:56.607] run() for ‘Future’ ...
[13:37:56.607] - state: ‘created’
[13:37:56.607] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:56.629] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:56.629] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:56.629]   - Field: ‘node’
[13:37:56.629]   - Field: ‘label’
[13:37:56.630]   - Field: ‘local’
[13:37:56.630]   - Field: ‘owner’
[13:37:56.630]   - Field: ‘envir’
[13:37:56.630]   - Field: ‘workers’
[13:37:56.630]   - Field: ‘packages’
[13:37:56.630]   - Field: ‘gc’
[13:37:56.630]   - Field: ‘conditions’
[13:37:56.630]   - Field: ‘persistent’
[13:37:56.630]   - Field: ‘expr’
[13:37:56.631]   - Field: ‘uuid’
[13:37:56.631]   - Field: ‘seed’
[13:37:56.631]   - Field: ‘version’
[13:37:56.631]   - Field: ‘result’
[13:37:56.631]   - Field: ‘asynchronous’
[13:37:56.631]   - Field: ‘calls’
[13:37:56.631]   - Field: ‘globals’
[13:37:56.631]   - Field: ‘stdout’
[13:37:56.631]   - Field: ‘earlySignal’
[13:37:56.631]   - Field: ‘lazy’
[13:37:56.632]   - Field: ‘state’
[13:37:56.632] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:56.632] - Launch lazy future ...
[13:37:56.632] Packages needed by the future expression (n = 0): <none>
[13:37:56.632] Packages needed by future strategies (n = 0): <none>
[13:37:56.633] {
[13:37:56.633]     {
[13:37:56.633]         {
[13:37:56.633]             ...future.startTime <- base::Sys.time()
[13:37:56.633]             {
[13:37:56.633]                 {
[13:37:56.633]                   {
[13:37:56.633]                     {
[13:37:56.633]                       base::local({
[13:37:56.633]                         has_future <- base::requireNamespace("future", 
[13:37:56.633]                           quietly = TRUE)
[13:37:56.633]                         if (has_future) {
[13:37:56.633]                           ns <- base::getNamespace("future")
[13:37:56.633]                           version <- ns[[".package"]][["version"]]
[13:37:56.633]                           if (is.null(version)) 
[13:37:56.633]                             version <- utils::packageVersion("future")
[13:37:56.633]                         }
[13:37:56.633]                         else {
[13:37:56.633]                           version <- NULL
[13:37:56.633]                         }
[13:37:56.633]                         if (!has_future || version < "1.8.0") {
[13:37:56.633]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:56.633]                             "", base::R.version$version.string), 
[13:37:56.633]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:56.633]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:56.633]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:56.633]                               "release", "version")], collapse = " "), 
[13:37:56.633]                             hostname = base::Sys.info()[["nodename"]])
[13:37:56.633]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:56.633]                             info)
[13:37:56.633]                           info <- base::paste(info, collapse = "; ")
[13:37:56.633]                           if (!has_future) {
[13:37:56.633]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:56.633]                               info)
[13:37:56.633]                           }
[13:37:56.633]                           else {
[13:37:56.633]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:56.633]                               info, version)
[13:37:56.633]                           }
[13:37:56.633]                           base::stop(msg)
[13:37:56.633]                         }
[13:37:56.633]                       })
[13:37:56.633]                     }
[13:37:56.633]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:56.633]                     base::options(mc.cores = 1L)
[13:37:56.633]                   }
[13:37:56.633]                   ...future.strategy.old <- future::plan("list")
[13:37:56.633]                   options(future.plan = NULL)
[13:37:56.633]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:56.633]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:56.633]                 }
[13:37:56.633]                 ...future.workdir <- getwd()
[13:37:56.633]             }
[13:37:56.633]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:56.633]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:56.633]         }
[13:37:56.633]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:56.633]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:56.633]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:56.633]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:56.633]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:56.633]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:56.633]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:56.633]             base::names(...future.oldOptions))
[13:37:56.633]     }
[13:37:56.633]     if (FALSE) {
[13:37:56.633]     }
[13:37:56.633]     else {
[13:37:56.633]         if (TRUE) {
[13:37:56.633]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:56.633]                 open = "w")
[13:37:56.633]         }
[13:37:56.633]         else {
[13:37:56.633]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:56.633]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:56.633]         }
[13:37:56.633]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:56.633]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:56.633]             base::sink(type = "output", split = FALSE)
[13:37:56.633]             base::close(...future.stdout)
[13:37:56.633]         }, add = TRUE)
[13:37:56.633]     }
[13:37:56.633]     ...future.frame <- base::sys.nframe()
[13:37:56.633]     ...future.conditions <- base::list()
[13:37:56.633]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:56.633]     if (FALSE) {
[13:37:56.633]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:56.633]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:56.633]     }
[13:37:56.633]     ...future.result <- base::tryCatch({
[13:37:56.633]         base::withCallingHandlers({
[13:37:56.633]             ...future.value <- base::withVisible(base::local({
[13:37:56.633]                 ...future.makeSendCondition <- base::local({
[13:37:56.633]                   sendCondition <- NULL
[13:37:56.633]                   function(frame = 1L) {
[13:37:56.633]                     if (is.function(sendCondition)) 
[13:37:56.633]                       return(sendCondition)
[13:37:56.633]                     ns <- getNamespace("parallel")
[13:37:56.633]                     if (exists("sendData", mode = "function", 
[13:37:56.633]                       envir = ns)) {
[13:37:56.633]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:56.633]                         envir = ns)
[13:37:56.633]                       envir <- sys.frame(frame)
[13:37:56.633]                       master <- NULL
[13:37:56.633]                       while (!identical(envir, .GlobalEnv) && 
[13:37:56.633]                         !identical(envir, emptyenv())) {
[13:37:56.633]                         if (exists("master", mode = "list", envir = envir, 
[13:37:56.633]                           inherits = FALSE)) {
[13:37:56.633]                           master <- get("master", mode = "list", 
[13:37:56.633]                             envir = envir, inherits = FALSE)
[13:37:56.633]                           if (inherits(master, c("SOCKnode", 
[13:37:56.633]                             "SOCK0node"))) {
[13:37:56.633]                             sendCondition <<- function(cond) {
[13:37:56.633]                               data <- list(type = "VALUE", value = cond, 
[13:37:56.633]                                 success = TRUE)
[13:37:56.633]                               parallel_sendData(master, data)
[13:37:56.633]                             }
[13:37:56.633]                             return(sendCondition)
[13:37:56.633]                           }
[13:37:56.633]                         }
[13:37:56.633]                         frame <- frame + 1L
[13:37:56.633]                         envir <- sys.frame(frame)
[13:37:56.633]                       }
[13:37:56.633]                     }
[13:37:56.633]                     sendCondition <<- function(cond) NULL
[13:37:56.633]                   }
[13:37:56.633]                 })
[13:37:56.633]                 withCallingHandlers({
[13:37:56.633]                   {
[13:37:56.633]                     Sys.sleep(0.5)
[13:37:56.633]                     list(a = 1, b = 42L)
[13:37:56.633]                   }
[13:37:56.633]                 }, immediateCondition = function(cond) {
[13:37:56.633]                   sendCondition <- ...future.makeSendCondition()
[13:37:56.633]                   sendCondition(cond)
[13:37:56.633]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:56.633]                   {
[13:37:56.633]                     inherits <- base::inherits
[13:37:56.633]                     invokeRestart <- base::invokeRestart
[13:37:56.633]                     is.null <- base::is.null
[13:37:56.633]                     muffled <- FALSE
[13:37:56.633]                     if (inherits(cond, "message")) {
[13:37:56.633]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:56.633]                       if (muffled) 
[13:37:56.633]                         invokeRestart("muffleMessage")
[13:37:56.633]                     }
[13:37:56.633]                     else if (inherits(cond, "warning")) {
[13:37:56.633]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:56.633]                       if (muffled) 
[13:37:56.633]                         invokeRestart("muffleWarning")
[13:37:56.633]                     }
[13:37:56.633]                     else if (inherits(cond, "condition")) {
[13:37:56.633]                       if (!is.null(pattern)) {
[13:37:56.633]                         computeRestarts <- base::computeRestarts
[13:37:56.633]                         grepl <- base::grepl
[13:37:56.633]                         restarts <- computeRestarts(cond)
[13:37:56.633]                         for (restart in restarts) {
[13:37:56.633]                           name <- restart$name
[13:37:56.633]                           if (is.null(name)) 
[13:37:56.633]                             next
[13:37:56.633]                           if (!grepl(pattern, name)) 
[13:37:56.633]                             next
[13:37:56.633]                           invokeRestart(restart)
[13:37:56.633]                           muffled <- TRUE
[13:37:56.633]                           break
[13:37:56.633]                         }
[13:37:56.633]                       }
[13:37:56.633]                     }
[13:37:56.633]                     invisible(muffled)
[13:37:56.633]                   }
[13:37:56.633]                   muffleCondition(cond)
[13:37:56.633]                 })
[13:37:56.633]             }))
[13:37:56.633]             future::FutureResult(value = ...future.value$value, 
[13:37:56.633]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:56.633]                   ...future.rng), globalenv = if (FALSE) 
[13:37:56.633]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:56.633]                     ...future.globalenv.names))
[13:37:56.633]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:56.633]         }, condition = base::local({
[13:37:56.633]             c <- base::c
[13:37:56.633]             inherits <- base::inherits
[13:37:56.633]             invokeRestart <- base::invokeRestart
[13:37:56.633]             length <- base::length
[13:37:56.633]             list <- base::list
[13:37:56.633]             seq.int <- base::seq.int
[13:37:56.633]             signalCondition <- base::signalCondition
[13:37:56.633]             sys.calls <- base::sys.calls
[13:37:56.633]             `[[` <- base::`[[`
[13:37:56.633]             `+` <- base::`+`
[13:37:56.633]             `<<-` <- base::`<<-`
[13:37:56.633]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:56.633]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:56.633]                   3L)]
[13:37:56.633]             }
[13:37:56.633]             function(cond) {
[13:37:56.633]                 is_error <- inherits(cond, "error")
[13:37:56.633]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:56.633]                   NULL)
[13:37:56.633]                 if (is_error) {
[13:37:56.633]                   sessionInformation <- function() {
[13:37:56.633]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:56.633]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:56.633]                       search = base::search(), system = base::Sys.info())
[13:37:56.633]                   }
[13:37:56.633]                   ...future.conditions[[length(...future.conditions) + 
[13:37:56.633]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:56.633]                     cond$call), session = sessionInformation(), 
[13:37:56.633]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:56.633]                   signalCondition(cond)
[13:37:56.633]                 }
[13:37:56.633]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:56.633]                 "immediateCondition"))) {
[13:37:56.633]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:56.633]                   ...future.conditions[[length(...future.conditions) + 
[13:37:56.633]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:56.633]                   if (TRUE && !signal) {
[13:37:56.633]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:56.633]                     {
[13:37:56.633]                       inherits <- base::inherits
[13:37:56.633]                       invokeRestart <- base::invokeRestart
[13:37:56.633]                       is.null <- base::is.null
[13:37:56.633]                       muffled <- FALSE
[13:37:56.633]                       if (inherits(cond, "message")) {
[13:37:56.633]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:56.633]                         if (muffled) 
[13:37:56.633]                           invokeRestart("muffleMessage")
[13:37:56.633]                       }
[13:37:56.633]                       else if (inherits(cond, "warning")) {
[13:37:56.633]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:56.633]                         if (muffled) 
[13:37:56.633]                           invokeRestart("muffleWarning")
[13:37:56.633]                       }
[13:37:56.633]                       else if (inherits(cond, "condition")) {
[13:37:56.633]                         if (!is.null(pattern)) {
[13:37:56.633]                           computeRestarts <- base::computeRestarts
[13:37:56.633]                           grepl <- base::grepl
[13:37:56.633]                           restarts <- computeRestarts(cond)
[13:37:56.633]                           for (restart in restarts) {
[13:37:56.633]                             name <- restart$name
[13:37:56.633]                             if (is.null(name)) 
[13:37:56.633]                               next
[13:37:56.633]                             if (!grepl(pattern, name)) 
[13:37:56.633]                               next
[13:37:56.633]                             invokeRestart(restart)
[13:37:56.633]                             muffled <- TRUE
[13:37:56.633]                             break
[13:37:56.633]                           }
[13:37:56.633]                         }
[13:37:56.633]                       }
[13:37:56.633]                       invisible(muffled)
[13:37:56.633]                     }
[13:37:56.633]                     muffleCondition(cond, pattern = "^muffle")
[13:37:56.633]                   }
[13:37:56.633]                 }
[13:37:56.633]                 else {
[13:37:56.633]                   if (TRUE) {
[13:37:56.633]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:56.633]                     {
[13:37:56.633]                       inherits <- base::inherits
[13:37:56.633]                       invokeRestart <- base::invokeRestart
[13:37:56.633]                       is.null <- base::is.null
[13:37:56.633]                       muffled <- FALSE
[13:37:56.633]                       if (inherits(cond, "message")) {
[13:37:56.633]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:56.633]                         if (muffled) 
[13:37:56.633]                           invokeRestart("muffleMessage")
[13:37:56.633]                       }
[13:37:56.633]                       else if (inherits(cond, "warning")) {
[13:37:56.633]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:56.633]                         if (muffled) 
[13:37:56.633]                           invokeRestart("muffleWarning")
[13:37:56.633]                       }
[13:37:56.633]                       else if (inherits(cond, "condition")) {
[13:37:56.633]                         if (!is.null(pattern)) {
[13:37:56.633]                           computeRestarts <- base::computeRestarts
[13:37:56.633]                           grepl <- base::grepl
[13:37:56.633]                           restarts <- computeRestarts(cond)
[13:37:56.633]                           for (restart in restarts) {
[13:37:56.633]                             name <- restart$name
[13:37:56.633]                             if (is.null(name)) 
[13:37:56.633]                               next
[13:37:56.633]                             if (!grepl(pattern, name)) 
[13:37:56.633]                               next
[13:37:56.633]                             invokeRestart(restart)
[13:37:56.633]                             muffled <- TRUE
[13:37:56.633]                             break
[13:37:56.633]                           }
[13:37:56.633]                         }
[13:37:56.633]                       }
[13:37:56.633]                       invisible(muffled)
[13:37:56.633]                     }
[13:37:56.633]                     muffleCondition(cond, pattern = "^muffle")
[13:37:56.633]                   }
[13:37:56.633]                 }
[13:37:56.633]             }
[13:37:56.633]         }))
[13:37:56.633]     }, error = function(ex) {
[13:37:56.633]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:56.633]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:56.633]                 ...future.rng), started = ...future.startTime, 
[13:37:56.633]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:56.633]             version = "1.8"), class = "FutureResult")
[13:37:56.633]     }, finally = {
[13:37:56.633]         if (!identical(...future.workdir, getwd())) 
[13:37:56.633]             setwd(...future.workdir)
[13:37:56.633]         {
[13:37:56.633]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:56.633]                 ...future.oldOptions$nwarnings <- NULL
[13:37:56.633]             }
[13:37:56.633]             base::options(...future.oldOptions)
[13:37:56.633]             if (.Platform$OS.type == "windows") {
[13:37:56.633]                 old_names <- names(...future.oldEnvVars)
[13:37:56.633]                 envs <- base::Sys.getenv()
[13:37:56.633]                 names <- names(envs)
[13:37:56.633]                 common <- intersect(names, old_names)
[13:37:56.633]                 added <- setdiff(names, old_names)
[13:37:56.633]                 removed <- setdiff(old_names, names)
[13:37:56.633]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:56.633]                   envs[common]]
[13:37:56.633]                 NAMES <- toupper(changed)
[13:37:56.633]                 args <- list()
[13:37:56.633]                 for (kk in seq_along(NAMES)) {
[13:37:56.633]                   name <- changed[[kk]]
[13:37:56.633]                   NAME <- NAMES[[kk]]
[13:37:56.633]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:56.633]                     next
[13:37:56.633]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:56.633]                 }
[13:37:56.633]                 NAMES <- toupper(added)
[13:37:56.633]                 for (kk in seq_along(NAMES)) {
[13:37:56.633]                   name <- added[[kk]]
[13:37:56.633]                   NAME <- NAMES[[kk]]
[13:37:56.633]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:56.633]                     next
[13:37:56.633]                   args[[name]] <- ""
[13:37:56.633]                 }
[13:37:56.633]                 NAMES <- toupper(removed)
[13:37:56.633]                 for (kk in seq_along(NAMES)) {
[13:37:56.633]                   name <- removed[[kk]]
[13:37:56.633]                   NAME <- NAMES[[kk]]
[13:37:56.633]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:56.633]                     next
[13:37:56.633]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:56.633]                 }
[13:37:56.633]                 if (length(args) > 0) 
[13:37:56.633]                   base::do.call(base::Sys.setenv, args = args)
[13:37:56.633]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:56.633]             }
[13:37:56.633]             else {
[13:37:56.633]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:56.633]             }
[13:37:56.633]             {
[13:37:56.633]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:56.633]                   0L) {
[13:37:56.633]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:56.633]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:56.633]                   base::options(opts)
[13:37:56.633]                 }
[13:37:56.633]                 {
[13:37:56.633]                   {
[13:37:56.633]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:56.633]                     NULL
[13:37:56.633]                   }
[13:37:56.633]                   options(future.plan = NULL)
[13:37:56.633]                   if (is.na(NA_character_)) 
[13:37:56.633]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:56.633]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:56.633]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:56.633]                     .init = FALSE)
[13:37:56.633]                 }
[13:37:56.633]             }
[13:37:56.633]         }
[13:37:56.633]     })
[13:37:56.633]     if (TRUE) {
[13:37:56.633]         base::sink(type = "output", split = FALSE)
[13:37:56.633]         if (TRUE) {
[13:37:56.633]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:56.633]         }
[13:37:56.633]         else {
[13:37:56.633]             ...future.result["stdout"] <- base::list(NULL)
[13:37:56.633]         }
[13:37:56.633]         base::close(...future.stdout)
[13:37:56.633]         ...future.stdout <- NULL
[13:37:56.633]     }
[13:37:56.633]     ...future.result$conditions <- ...future.conditions
[13:37:56.633]     ...future.result$finished <- base::Sys.time()
[13:37:56.633]     ...future.result
[13:37:56.633] }
[13:37:56.635] MultisessionFuture started
[13:37:56.636] - Launch lazy future ... done
[13:37:56.636] run() for ‘MultisessionFuture’ ... done
[13:37:57.138] receiveMessageFromWorker() for ClusterFuture ...
[13:37:57.139] - Validating connection of MultisessionFuture
[13:37:57.139] - received message: FutureResult
[13:37:57.139] - Received FutureResult
[13:37:57.139] - Erased future from FutureRegistry
[13:37:57.139] result() for ClusterFuture ...
[13:37:57.139] - result already collected: FutureResult
[13:37:57.139] result() for ClusterFuture ... done
[13:37:57.139] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:57.139] A MultisessionFuture was resolved
- w/ exception ...
[13:37:57.140] getGlobalsAndPackages() ...
[13:37:57.140] Searching for globals...
[13:37:57.140] - globals found: [2] ‘list’, ‘stop’
[13:37:57.141] Searching for globals ... DONE
[13:37:57.141] Resolving globals: FALSE
[13:37:57.141] 
[13:37:57.141] 
[13:37:57.141] getGlobalsAndPackages() ... DONE
[13:37:57.141] run() for ‘Future’ ...
[13:37:57.141] - state: ‘created’
[13:37:57.142] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:57.156] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:57.156] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:57.156]   - Field: ‘node’
[13:37:57.156]   - Field: ‘label’
[13:37:57.156]   - Field: ‘local’
[13:37:57.156]   - Field: ‘owner’
[13:37:57.156]   - Field: ‘envir’
[13:37:57.156]   - Field: ‘workers’
[13:37:57.156]   - Field: ‘packages’
[13:37:57.157]   - Field: ‘gc’
[13:37:57.157]   - Field: ‘conditions’
[13:37:57.157]   - Field: ‘persistent’
[13:37:57.157]   - Field: ‘expr’
[13:37:57.157]   - Field: ‘uuid’
[13:37:57.157]   - Field: ‘seed’
[13:37:57.157]   - Field: ‘version’
[13:37:57.157]   - Field: ‘result’
[13:37:57.157]   - Field: ‘asynchronous’
[13:37:57.157]   - Field: ‘calls’
[13:37:57.157]   - Field: ‘globals’
[13:37:57.158]   - Field: ‘stdout’
[13:37:57.158]   - Field: ‘earlySignal’
[13:37:57.158]   - Field: ‘lazy’
[13:37:57.158]   - Field: ‘state’
[13:37:57.158] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:57.158] - Launch lazy future ...
[13:37:57.158] Packages needed by the future expression (n = 0): <none>
[13:37:57.158] Packages needed by future strategies (n = 0): <none>
[13:37:57.159] {
[13:37:57.159]     {
[13:37:57.159]         {
[13:37:57.159]             ...future.startTime <- base::Sys.time()
[13:37:57.159]             {
[13:37:57.159]                 {
[13:37:57.159]                   {
[13:37:57.159]                     {
[13:37:57.159]                       base::local({
[13:37:57.159]                         has_future <- base::requireNamespace("future", 
[13:37:57.159]                           quietly = TRUE)
[13:37:57.159]                         if (has_future) {
[13:37:57.159]                           ns <- base::getNamespace("future")
[13:37:57.159]                           version <- ns[[".package"]][["version"]]
[13:37:57.159]                           if (is.null(version)) 
[13:37:57.159]                             version <- utils::packageVersion("future")
[13:37:57.159]                         }
[13:37:57.159]                         else {
[13:37:57.159]                           version <- NULL
[13:37:57.159]                         }
[13:37:57.159]                         if (!has_future || version < "1.8.0") {
[13:37:57.159]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:57.159]                             "", base::R.version$version.string), 
[13:37:57.159]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:57.159]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:57.159]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:57.159]                               "release", "version")], collapse = " "), 
[13:37:57.159]                             hostname = base::Sys.info()[["nodename"]])
[13:37:57.159]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:57.159]                             info)
[13:37:57.159]                           info <- base::paste(info, collapse = "; ")
[13:37:57.159]                           if (!has_future) {
[13:37:57.159]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:57.159]                               info)
[13:37:57.159]                           }
[13:37:57.159]                           else {
[13:37:57.159]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:57.159]                               info, version)
[13:37:57.159]                           }
[13:37:57.159]                           base::stop(msg)
[13:37:57.159]                         }
[13:37:57.159]                       })
[13:37:57.159]                     }
[13:37:57.159]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:57.159]                     base::options(mc.cores = 1L)
[13:37:57.159]                   }
[13:37:57.159]                   ...future.strategy.old <- future::plan("list")
[13:37:57.159]                   options(future.plan = NULL)
[13:37:57.159]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:57.159]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:57.159]                 }
[13:37:57.159]                 ...future.workdir <- getwd()
[13:37:57.159]             }
[13:37:57.159]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:57.159]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:57.159]         }
[13:37:57.159]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:57.159]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:57.159]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:57.159]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:57.159]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:57.159]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:57.159]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:57.159]             base::names(...future.oldOptions))
[13:37:57.159]     }
[13:37:57.159]     if (FALSE) {
[13:37:57.159]     }
[13:37:57.159]     else {
[13:37:57.159]         if (TRUE) {
[13:37:57.159]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:57.159]                 open = "w")
[13:37:57.159]         }
[13:37:57.159]         else {
[13:37:57.159]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:57.159]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:57.159]         }
[13:37:57.159]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:57.159]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:57.159]             base::sink(type = "output", split = FALSE)
[13:37:57.159]             base::close(...future.stdout)
[13:37:57.159]         }, add = TRUE)
[13:37:57.159]     }
[13:37:57.159]     ...future.frame <- base::sys.nframe()
[13:37:57.159]     ...future.conditions <- base::list()
[13:37:57.159]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:57.159]     if (FALSE) {
[13:37:57.159]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:57.159]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:57.159]     }
[13:37:57.159]     ...future.result <- base::tryCatch({
[13:37:57.159]         base::withCallingHandlers({
[13:37:57.159]             ...future.value <- base::withVisible(base::local({
[13:37:57.159]                 ...future.makeSendCondition <- base::local({
[13:37:57.159]                   sendCondition <- NULL
[13:37:57.159]                   function(frame = 1L) {
[13:37:57.159]                     if (is.function(sendCondition)) 
[13:37:57.159]                       return(sendCondition)
[13:37:57.159]                     ns <- getNamespace("parallel")
[13:37:57.159]                     if (exists("sendData", mode = "function", 
[13:37:57.159]                       envir = ns)) {
[13:37:57.159]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:57.159]                         envir = ns)
[13:37:57.159]                       envir <- sys.frame(frame)
[13:37:57.159]                       master <- NULL
[13:37:57.159]                       while (!identical(envir, .GlobalEnv) && 
[13:37:57.159]                         !identical(envir, emptyenv())) {
[13:37:57.159]                         if (exists("master", mode = "list", envir = envir, 
[13:37:57.159]                           inherits = FALSE)) {
[13:37:57.159]                           master <- get("master", mode = "list", 
[13:37:57.159]                             envir = envir, inherits = FALSE)
[13:37:57.159]                           if (inherits(master, c("SOCKnode", 
[13:37:57.159]                             "SOCK0node"))) {
[13:37:57.159]                             sendCondition <<- function(cond) {
[13:37:57.159]                               data <- list(type = "VALUE", value = cond, 
[13:37:57.159]                                 success = TRUE)
[13:37:57.159]                               parallel_sendData(master, data)
[13:37:57.159]                             }
[13:37:57.159]                             return(sendCondition)
[13:37:57.159]                           }
[13:37:57.159]                         }
[13:37:57.159]                         frame <- frame + 1L
[13:37:57.159]                         envir <- sys.frame(frame)
[13:37:57.159]                       }
[13:37:57.159]                     }
[13:37:57.159]                     sendCondition <<- function(cond) NULL
[13:37:57.159]                   }
[13:37:57.159]                 })
[13:37:57.159]                 withCallingHandlers({
[13:37:57.159]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:37:57.159]                 }, immediateCondition = function(cond) {
[13:37:57.159]                   sendCondition <- ...future.makeSendCondition()
[13:37:57.159]                   sendCondition(cond)
[13:37:57.159]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:57.159]                   {
[13:37:57.159]                     inherits <- base::inherits
[13:37:57.159]                     invokeRestart <- base::invokeRestart
[13:37:57.159]                     is.null <- base::is.null
[13:37:57.159]                     muffled <- FALSE
[13:37:57.159]                     if (inherits(cond, "message")) {
[13:37:57.159]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:57.159]                       if (muffled) 
[13:37:57.159]                         invokeRestart("muffleMessage")
[13:37:57.159]                     }
[13:37:57.159]                     else if (inherits(cond, "warning")) {
[13:37:57.159]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:57.159]                       if (muffled) 
[13:37:57.159]                         invokeRestart("muffleWarning")
[13:37:57.159]                     }
[13:37:57.159]                     else if (inherits(cond, "condition")) {
[13:37:57.159]                       if (!is.null(pattern)) {
[13:37:57.159]                         computeRestarts <- base::computeRestarts
[13:37:57.159]                         grepl <- base::grepl
[13:37:57.159]                         restarts <- computeRestarts(cond)
[13:37:57.159]                         for (restart in restarts) {
[13:37:57.159]                           name <- restart$name
[13:37:57.159]                           if (is.null(name)) 
[13:37:57.159]                             next
[13:37:57.159]                           if (!grepl(pattern, name)) 
[13:37:57.159]                             next
[13:37:57.159]                           invokeRestart(restart)
[13:37:57.159]                           muffled <- TRUE
[13:37:57.159]                           break
[13:37:57.159]                         }
[13:37:57.159]                       }
[13:37:57.159]                     }
[13:37:57.159]                     invisible(muffled)
[13:37:57.159]                   }
[13:37:57.159]                   muffleCondition(cond)
[13:37:57.159]                 })
[13:37:57.159]             }))
[13:37:57.159]             future::FutureResult(value = ...future.value$value, 
[13:37:57.159]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:57.159]                   ...future.rng), globalenv = if (FALSE) 
[13:37:57.159]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:57.159]                     ...future.globalenv.names))
[13:37:57.159]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:57.159]         }, condition = base::local({
[13:37:57.159]             c <- base::c
[13:37:57.159]             inherits <- base::inherits
[13:37:57.159]             invokeRestart <- base::invokeRestart
[13:37:57.159]             length <- base::length
[13:37:57.159]             list <- base::list
[13:37:57.159]             seq.int <- base::seq.int
[13:37:57.159]             signalCondition <- base::signalCondition
[13:37:57.159]             sys.calls <- base::sys.calls
[13:37:57.159]             `[[` <- base::`[[`
[13:37:57.159]             `+` <- base::`+`
[13:37:57.159]             `<<-` <- base::`<<-`
[13:37:57.159]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:57.159]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:57.159]                   3L)]
[13:37:57.159]             }
[13:37:57.159]             function(cond) {
[13:37:57.159]                 is_error <- inherits(cond, "error")
[13:37:57.159]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:57.159]                   NULL)
[13:37:57.159]                 if (is_error) {
[13:37:57.159]                   sessionInformation <- function() {
[13:37:57.159]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:57.159]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:57.159]                       search = base::search(), system = base::Sys.info())
[13:37:57.159]                   }
[13:37:57.159]                   ...future.conditions[[length(...future.conditions) + 
[13:37:57.159]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:57.159]                     cond$call), session = sessionInformation(), 
[13:37:57.159]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:57.159]                   signalCondition(cond)
[13:37:57.159]                 }
[13:37:57.159]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:57.159]                 "immediateCondition"))) {
[13:37:57.159]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:57.159]                   ...future.conditions[[length(...future.conditions) + 
[13:37:57.159]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:57.159]                   if (TRUE && !signal) {
[13:37:57.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:57.159]                     {
[13:37:57.159]                       inherits <- base::inherits
[13:37:57.159]                       invokeRestart <- base::invokeRestart
[13:37:57.159]                       is.null <- base::is.null
[13:37:57.159]                       muffled <- FALSE
[13:37:57.159]                       if (inherits(cond, "message")) {
[13:37:57.159]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:57.159]                         if (muffled) 
[13:37:57.159]                           invokeRestart("muffleMessage")
[13:37:57.159]                       }
[13:37:57.159]                       else if (inherits(cond, "warning")) {
[13:37:57.159]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:57.159]                         if (muffled) 
[13:37:57.159]                           invokeRestart("muffleWarning")
[13:37:57.159]                       }
[13:37:57.159]                       else if (inherits(cond, "condition")) {
[13:37:57.159]                         if (!is.null(pattern)) {
[13:37:57.159]                           computeRestarts <- base::computeRestarts
[13:37:57.159]                           grepl <- base::grepl
[13:37:57.159]                           restarts <- computeRestarts(cond)
[13:37:57.159]                           for (restart in restarts) {
[13:37:57.159]                             name <- restart$name
[13:37:57.159]                             if (is.null(name)) 
[13:37:57.159]                               next
[13:37:57.159]                             if (!grepl(pattern, name)) 
[13:37:57.159]                               next
[13:37:57.159]                             invokeRestart(restart)
[13:37:57.159]                             muffled <- TRUE
[13:37:57.159]                             break
[13:37:57.159]                           }
[13:37:57.159]                         }
[13:37:57.159]                       }
[13:37:57.159]                       invisible(muffled)
[13:37:57.159]                     }
[13:37:57.159]                     muffleCondition(cond, pattern = "^muffle")
[13:37:57.159]                   }
[13:37:57.159]                 }
[13:37:57.159]                 else {
[13:37:57.159]                   if (TRUE) {
[13:37:57.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:57.159]                     {
[13:37:57.159]                       inherits <- base::inherits
[13:37:57.159]                       invokeRestart <- base::invokeRestart
[13:37:57.159]                       is.null <- base::is.null
[13:37:57.159]                       muffled <- FALSE
[13:37:57.159]                       if (inherits(cond, "message")) {
[13:37:57.159]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:57.159]                         if (muffled) 
[13:37:57.159]                           invokeRestart("muffleMessage")
[13:37:57.159]                       }
[13:37:57.159]                       else if (inherits(cond, "warning")) {
[13:37:57.159]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:57.159]                         if (muffled) 
[13:37:57.159]                           invokeRestart("muffleWarning")
[13:37:57.159]                       }
[13:37:57.159]                       else if (inherits(cond, "condition")) {
[13:37:57.159]                         if (!is.null(pattern)) {
[13:37:57.159]                           computeRestarts <- base::computeRestarts
[13:37:57.159]                           grepl <- base::grepl
[13:37:57.159]                           restarts <- computeRestarts(cond)
[13:37:57.159]                           for (restart in restarts) {
[13:37:57.159]                             name <- restart$name
[13:37:57.159]                             if (is.null(name)) 
[13:37:57.159]                               next
[13:37:57.159]                             if (!grepl(pattern, name)) 
[13:37:57.159]                               next
[13:37:57.159]                             invokeRestart(restart)
[13:37:57.159]                             muffled <- TRUE
[13:37:57.159]                             break
[13:37:57.159]                           }
[13:37:57.159]                         }
[13:37:57.159]                       }
[13:37:57.159]                       invisible(muffled)
[13:37:57.159]                     }
[13:37:57.159]                     muffleCondition(cond, pattern = "^muffle")
[13:37:57.159]                   }
[13:37:57.159]                 }
[13:37:57.159]             }
[13:37:57.159]         }))
[13:37:57.159]     }, error = function(ex) {
[13:37:57.159]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:57.159]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:57.159]                 ...future.rng), started = ...future.startTime, 
[13:37:57.159]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:57.159]             version = "1.8"), class = "FutureResult")
[13:37:57.159]     }, finally = {
[13:37:57.159]         if (!identical(...future.workdir, getwd())) 
[13:37:57.159]             setwd(...future.workdir)
[13:37:57.159]         {
[13:37:57.159]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:57.159]                 ...future.oldOptions$nwarnings <- NULL
[13:37:57.159]             }
[13:37:57.159]             base::options(...future.oldOptions)
[13:37:57.159]             if (.Platform$OS.type == "windows") {
[13:37:57.159]                 old_names <- names(...future.oldEnvVars)
[13:37:57.159]                 envs <- base::Sys.getenv()
[13:37:57.159]                 names <- names(envs)
[13:37:57.159]                 common <- intersect(names, old_names)
[13:37:57.159]                 added <- setdiff(names, old_names)
[13:37:57.159]                 removed <- setdiff(old_names, names)
[13:37:57.159]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:57.159]                   envs[common]]
[13:37:57.159]                 NAMES <- toupper(changed)
[13:37:57.159]                 args <- list()
[13:37:57.159]                 for (kk in seq_along(NAMES)) {
[13:37:57.159]                   name <- changed[[kk]]
[13:37:57.159]                   NAME <- NAMES[[kk]]
[13:37:57.159]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:57.159]                     next
[13:37:57.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:57.159]                 }
[13:37:57.159]                 NAMES <- toupper(added)
[13:37:57.159]                 for (kk in seq_along(NAMES)) {
[13:37:57.159]                   name <- added[[kk]]
[13:37:57.159]                   NAME <- NAMES[[kk]]
[13:37:57.159]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:57.159]                     next
[13:37:57.159]                   args[[name]] <- ""
[13:37:57.159]                 }
[13:37:57.159]                 NAMES <- toupper(removed)
[13:37:57.159]                 for (kk in seq_along(NAMES)) {
[13:37:57.159]                   name <- removed[[kk]]
[13:37:57.159]                   NAME <- NAMES[[kk]]
[13:37:57.159]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:57.159]                     next
[13:37:57.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:57.159]                 }
[13:37:57.159]                 if (length(args) > 0) 
[13:37:57.159]                   base::do.call(base::Sys.setenv, args = args)
[13:37:57.159]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:57.159]             }
[13:37:57.159]             else {
[13:37:57.159]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:57.159]             }
[13:37:57.159]             {
[13:37:57.159]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:57.159]                   0L) {
[13:37:57.159]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:57.159]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:57.159]                   base::options(opts)
[13:37:57.159]                 }
[13:37:57.159]                 {
[13:37:57.159]                   {
[13:37:57.159]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:57.159]                     NULL
[13:37:57.159]                   }
[13:37:57.159]                   options(future.plan = NULL)
[13:37:57.159]                   if (is.na(NA_character_)) 
[13:37:57.159]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:57.159]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:57.159]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:57.159]                     .init = FALSE)
[13:37:57.159]                 }
[13:37:57.159]             }
[13:37:57.159]         }
[13:37:57.159]     })
[13:37:57.159]     if (TRUE) {
[13:37:57.159]         base::sink(type = "output", split = FALSE)
[13:37:57.159]         if (TRUE) {
[13:37:57.159]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:57.159]         }
[13:37:57.159]         else {
[13:37:57.159]             ...future.result["stdout"] <- base::list(NULL)
[13:37:57.159]         }
[13:37:57.159]         base::close(...future.stdout)
[13:37:57.159]         ...future.stdout <- NULL
[13:37:57.159]     }
[13:37:57.159]     ...future.result$conditions <- ...future.conditions
[13:37:57.159]     ...future.result$finished <- base::Sys.time()
[13:37:57.159]     ...future.result
[13:37:57.159] }
[13:37:57.162] MultisessionFuture started
[13:37:57.162] - Launch lazy future ... done
[13:37:57.162] run() for ‘MultisessionFuture’ ... done
[13:37:57.164] receiveMessageFromWorker() for ClusterFuture ...
[13:37:57.164] - Validating connection of MultisessionFuture
[13:37:57.165] - received message: FutureResult
[13:37:57.165] - Received FutureResult
[13:37:57.165] - Erased future from FutureRegistry
[13:37:57.165] result() for ClusterFuture ...
[13:37:57.165] - result already collected: FutureResult
[13:37:57.165] result() for ClusterFuture ... done
[13:37:57.165] signalConditions() ...
[13:37:57.165]  - include = ‘immediateCondition’
[13:37:57.165]  - exclude = 
[13:37:57.166]  - resignal = FALSE
[13:37:57.166]  - Number of conditions: 1
[13:37:57.166] signalConditions() ... done
[13:37:57.166] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:57.166] A MultisessionFuture was resolved
[13:37:57.166] getGlobalsAndPackages() ...
[13:37:57.166] Searching for globals...
[13:37:57.167] - globals found: [2] ‘list’, ‘stop’
[13:37:57.167] Searching for globals ... DONE
[13:37:57.167] Resolving globals: FALSE
[13:37:57.167] 
[13:37:57.167] 
[13:37:57.167] getGlobalsAndPackages() ... DONE
[13:37:57.168] run() for ‘Future’ ...
[13:37:57.168] - state: ‘created’
[13:37:57.168] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:57.182] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:57.182] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:57.182]   - Field: ‘node’
[13:37:57.183]   - Field: ‘label’
[13:37:57.183]   - Field: ‘local’
[13:37:57.183]   - Field: ‘owner’
[13:37:57.183]   - Field: ‘envir’
[13:37:57.183]   - Field: ‘workers’
[13:37:57.183]   - Field: ‘packages’
[13:37:57.183]   - Field: ‘gc’
[13:37:57.183]   - Field: ‘conditions’
[13:37:57.183]   - Field: ‘persistent’
[13:37:57.183]   - Field: ‘expr’
[13:37:57.184]   - Field: ‘uuid’
[13:37:57.184]   - Field: ‘seed’
[13:37:57.184]   - Field: ‘version’
[13:37:57.184]   - Field: ‘result’
[13:37:57.184]   - Field: ‘asynchronous’
[13:37:57.184]   - Field: ‘calls’
[13:37:57.184]   - Field: ‘globals’
[13:37:57.184]   - Field: ‘stdout’
[13:37:57.184]   - Field: ‘earlySignal’
[13:37:57.184]   - Field: ‘lazy’
[13:37:57.184]   - Field: ‘state’
[13:37:57.185] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:57.185] - Launch lazy future ...
[13:37:57.185] Packages needed by the future expression (n = 0): <none>
[13:37:57.185] Packages needed by future strategies (n = 0): <none>
[13:37:57.185] {
[13:37:57.185]     {
[13:37:57.185]         {
[13:37:57.185]             ...future.startTime <- base::Sys.time()
[13:37:57.185]             {
[13:37:57.185]                 {
[13:37:57.185]                   {
[13:37:57.185]                     {
[13:37:57.185]                       base::local({
[13:37:57.185]                         has_future <- base::requireNamespace("future", 
[13:37:57.185]                           quietly = TRUE)
[13:37:57.185]                         if (has_future) {
[13:37:57.185]                           ns <- base::getNamespace("future")
[13:37:57.185]                           version <- ns[[".package"]][["version"]]
[13:37:57.185]                           if (is.null(version)) 
[13:37:57.185]                             version <- utils::packageVersion("future")
[13:37:57.185]                         }
[13:37:57.185]                         else {
[13:37:57.185]                           version <- NULL
[13:37:57.185]                         }
[13:37:57.185]                         if (!has_future || version < "1.8.0") {
[13:37:57.185]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:57.185]                             "", base::R.version$version.string), 
[13:37:57.185]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:57.185]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:57.185]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:57.185]                               "release", "version")], collapse = " "), 
[13:37:57.185]                             hostname = base::Sys.info()[["nodename"]])
[13:37:57.185]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:57.185]                             info)
[13:37:57.185]                           info <- base::paste(info, collapse = "; ")
[13:37:57.185]                           if (!has_future) {
[13:37:57.185]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:57.185]                               info)
[13:37:57.185]                           }
[13:37:57.185]                           else {
[13:37:57.185]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:57.185]                               info, version)
[13:37:57.185]                           }
[13:37:57.185]                           base::stop(msg)
[13:37:57.185]                         }
[13:37:57.185]                       })
[13:37:57.185]                     }
[13:37:57.185]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:57.185]                     base::options(mc.cores = 1L)
[13:37:57.185]                   }
[13:37:57.185]                   ...future.strategy.old <- future::plan("list")
[13:37:57.185]                   options(future.plan = NULL)
[13:37:57.185]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:57.185]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:57.185]                 }
[13:37:57.185]                 ...future.workdir <- getwd()
[13:37:57.185]             }
[13:37:57.185]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:57.185]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:57.185]         }
[13:37:57.185]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:57.185]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:57.185]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:57.185]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:57.185]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:57.185]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:57.185]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:57.185]             base::names(...future.oldOptions))
[13:37:57.185]     }
[13:37:57.185]     if (FALSE) {
[13:37:57.185]     }
[13:37:57.185]     else {
[13:37:57.185]         if (TRUE) {
[13:37:57.185]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:57.185]                 open = "w")
[13:37:57.185]         }
[13:37:57.185]         else {
[13:37:57.185]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:57.185]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:57.185]         }
[13:37:57.185]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:57.185]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:57.185]             base::sink(type = "output", split = FALSE)
[13:37:57.185]             base::close(...future.stdout)
[13:37:57.185]         }, add = TRUE)
[13:37:57.185]     }
[13:37:57.185]     ...future.frame <- base::sys.nframe()
[13:37:57.185]     ...future.conditions <- base::list()
[13:37:57.185]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:57.185]     if (FALSE) {
[13:37:57.185]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:57.185]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:57.185]     }
[13:37:57.185]     ...future.result <- base::tryCatch({
[13:37:57.185]         base::withCallingHandlers({
[13:37:57.185]             ...future.value <- base::withVisible(base::local({
[13:37:57.185]                 ...future.makeSendCondition <- base::local({
[13:37:57.185]                   sendCondition <- NULL
[13:37:57.185]                   function(frame = 1L) {
[13:37:57.185]                     if (is.function(sendCondition)) 
[13:37:57.185]                       return(sendCondition)
[13:37:57.185]                     ns <- getNamespace("parallel")
[13:37:57.185]                     if (exists("sendData", mode = "function", 
[13:37:57.185]                       envir = ns)) {
[13:37:57.185]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:57.185]                         envir = ns)
[13:37:57.185]                       envir <- sys.frame(frame)
[13:37:57.185]                       master <- NULL
[13:37:57.185]                       while (!identical(envir, .GlobalEnv) && 
[13:37:57.185]                         !identical(envir, emptyenv())) {
[13:37:57.185]                         if (exists("master", mode = "list", envir = envir, 
[13:37:57.185]                           inherits = FALSE)) {
[13:37:57.185]                           master <- get("master", mode = "list", 
[13:37:57.185]                             envir = envir, inherits = FALSE)
[13:37:57.185]                           if (inherits(master, c("SOCKnode", 
[13:37:57.185]                             "SOCK0node"))) {
[13:37:57.185]                             sendCondition <<- function(cond) {
[13:37:57.185]                               data <- list(type = "VALUE", value = cond, 
[13:37:57.185]                                 success = TRUE)
[13:37:57.185]                               parallel_sendData(master, data)
[13:37:57.185]                             }
[13:37:57.185]                             return(sendCondition)
[13:37:57.185]                           }
[13:37:57.185]                         }
[13:37:57.185]                         frame <- frame + 1L
[13:37:57.185]                         envir <- sys.frame(frame)
[13:37:57.185]                       }
[13:37:57.185]                     }
[13:37:57.185]                     sendCondition <<- function(cond) NULL
[13:37:57.185]                   }
[13:37:57.185]                 })
[13:37:57.185]                 withCallingHandlers({
[13:37:57.185]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:37:57.185]                 }, immediateCondition = function(cond) {
[13:37:57.185]                   sendCondition <- ...future.makeSendCondition()
[13:37:57.185]                   sendCondition(cond)
[13:37:57.185]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:57.185]                   {
[13:37:57.185]                     inherits <- base::inherits
[13:37:57.185]                     invokeRestart <- base::invokeRestart
[13:37:57.185]                     is.null <- base::is.null
[13:37:57.185]                     muffled <- FALSE
[13:37:57.185]                     if (inherits(cond, "message")) {
[13:37:57.185]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:57.185]                       if (muffled) 
[13:37:57.185]                         invokeRestart("muffleMessage")
[13:37:57.185]                     }
[13:37:57.185]                     else if (inherits(cond, "warning")) {
[13:37:57.185]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:57.185]                       if (muffled) 
[13:37:57.185]                         invokeRestart("muffleWarning")
[13:37:57.185]                     }
[13:37:57.185]                     else if (inherits(cond, "condition")) {
[13:37:57.185]                       if (!is.null(pattern)) {
[13:37:57.185]                         computeRestarts <- base::computeRestarts
[13:37:57.185]                         grepl <- base::grepl
[13:37:57.185]                         restarts <- computeRestarts(cond)
[13:37:57.185]                         for (restart in restarts) {
[13:37:57.185]                           name <- restart$name
[13:37:57.185]                           if (is.null(name)) 
[13:37:57.185]                             next
[13:37:57.185]                           if (!grepl(pattern, name)) 
[13:37:57.185]                             next
[13:37:57.185]                           invokeRestart(restart)
[13:37:57.185]                           muffled <- TRUE
[13:37:57.185]                           break
[13:37:57.185]                         }
[13:37:57.185]                       }
[13:37:57.185]                     }
[13:37:57.185]                     invisible(muffled)
[13:37:57.185]                   }
[13:37:57.185]                   muffleCondition(cond)
[13:37:57.185]                 })
[13:37:57.185]             }))
[13:37:57.185]             future::FutureResult(value = ...future.value$value, 
[13:37:57.185]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:57.185]                   ...future.rng), globalenv = if (FALSE) 
[13:37:57.185]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:57.185]                     ...future.globalenv.names))
[13:37:57.185]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:57.185]         }, condition = base::local({
[13:37:57.185]             c <- base::c
[13:37:57.185]             inherits <- base::inherits
[13:37:57.185]             invokeRestart <- base::invokeRestart
[13:37:57.185]             length <- base::length
[13:37:57.185]             list <- base::list
[13:37:57.185]             seq.int <- base::seq.int
[13:37:57.185]             signalCondition <- base::signalCondition
[13:37:57.185]             sys.calls <- base::sys.calls
[13:37:57.185]             `[[` <- base::`[[`
[13:37:57.185]             `+` <- base::`+`
[13:37:57.185]             `<<-` <- base::`<<-`
[13:37:57.185]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:57.185]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:57.185]                   3L)]
[13:37:57.185]             }
[13:37:57.185]             function(cond) {
[13:37:57.185]                 is_error <- inherits(cond, "error")
[13:37:57.185]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:57.185]                   NULL)
[13:37:57.185]                 if (is_error) {
[13:37:57.185]                   sessionInformation <- function() {
[13:37:57.185]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:57.185]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:57.185]                       search = base::search(), system = base::Sys.info())
[13:37:57.185]                   }
[13:37:57.185]                   ...future.conditions[[length(...future.conditions) + 
[13:37:57.185]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:57.185]                     cond$call), session = sessionInformation(), 
[13:37:57.185]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:57.185]                   signalCondition(cond)
[13:37:57.185]                 }
[13:37:57.185]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:57.185]                 "immediateCondition"))) {
[13:37:57.185]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:57.185]                   ...future.conditions[[length(...future.conditions) + 
[13:37:57.185]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:57.185]                   if (TRUE && !signal) {
[13:37:57.185]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:57.185]                     {
[13:37:57.185]                       inherits <- base::inherits
[13:37:57.185]                       invokeRestart <- base::invokeRestart
[13:37:57.185]                       is.null <- base::is.null
[13:37:57.185]                       muffled <- FALSE
[13:37:57.185]                       if (inherits(cond, "message")) {
[13:37:57.185]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:57.185]                         if (muffled) 
[13:37:57.185]                           invokeRestart("muffleMessage")
[13:37:57.185]                       }
[13:37:57.185]                       else if (inherits(cond, "warning")) {
[13:37:57.185]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:57.185]                         if (muffled) 
[13:37:57.185]                           invokeRestart("muffleWarning")
[13:37:57.185]                       }
[13:37:57.185]                       else if (inherits(cond, "condition")) {
[13:37:57.185]                         if (!is.null(pattern)) {
[13:37:57.185]                           computeRestarts <- base::computeRestarts
[13:37:57.185]                           grepl <- base::grepl
[13:37:57.185]                           restarts <- computeRestarts(cond)
[13:37:57.185]                           for (restart in restarts) {
[13:37:57.185]                             name <- restart$name
[13:37:57.185]                             if (is.null(name)) 
[13:37:57.185]                               next
[13:37:57.185]                             if (!grepl(pattern, name)) 
[13:37:57.185]                               next
[13:37:57.185]                             invokeRestart(restart)
[13:37:57.185]                             muffled <- TRUE
[13:37:57.185]                             break
[13:37:57.185]                           }
[13:37:57.185]                         }
[13:37:57.185]                       }
[13:37:57.185]                       invisible(muffled)
[13:37:57.185]                     }
[13:37:57.185]                     muffleCondition(cond, pattern = "^muffle")
[13:37:57.185]                   }
[13:37:57.185]                 }
[13:37:57.185]                 else {
[13:37:57.185]                   if (TRUE) {
[13:37:57.185]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:57.185]                     {
[13:37:57.185]                       inherits <- base::inherits
[13:37:57.185]                       invokeRestart <- base::invokeRestart
[13:37:57.185]                       is.null <- base::is.null
[13:37:57.185]                       muffled <- FALSE
[13:37:57.185]                       if (inherits(cond, "message")) {
[13:37:57.185]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:57.185]                         if (muffled) 
[13:37:57.185]                           invokeRestart("muffleMessage")
[13:37:57.185]                       }
[13:37:57.185]                       else if (inherits(cond, "warning")) {
[13:37:57.185]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:57.185]                         if (muffled) 
[13:37:57.185]                           invokeRestart("muffleWarning")
[13:37:57.185]                       }
[13:37:57.185]                       else if (inherits(cond, "condition")) {
[13:37:57.185]                         if (!is.null(pattern)) {
[13:37:57.185]                           computeRestarts <- base::computeRestarts
[13:37:57.185]                           grepl <- base::grepl
[13:37:57.185]                           restarts <- computeRestarts(cond)
[13:37:57.185]                           for (restart in restarts) {
[13:37:57.185]                             name <- restart$name
[13:37:57.185]                             if (is.null(name)) 
[13:37:57.185]                               next
[13:37:57.185]                             if (!grepl(pattern, name)) 
[13:37:57.185]                               next
[13:37:57.185]                             invokeRestart(restart)
[13:37:57.185]                             muffled <- TRUE
[13:37:57.185]                             break
[13:37:57.185]                           }
[13:37:57.185]                         }
[13:37:57.185]                       }
[13:37:57.185]                       invisible(muffled)
[13:37:57.185]                     }
[13:37:57.185]                     muffleCondition(cond, pattern = "^muffle")
[13:37:57.185]                   }
[13:37:57.185]                 }
[13:37:57.185]             }
[13:37:57.185]         }))
[13:37:57.185]     }, error = function(ex) {
[13:37:57.185]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:57.185]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:57.185]                 ...future.rng), started = ...future.startTime, 
[13:37:57.185]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:57.185]             version = "1.8"), class = "FutureResult")
[13:37:57.185]     }, finally = {
[13:37:57.185]         if (!identical(...future.workdir, getwd())) 
[13:37:57.185]             setwd(...future.workdir)
[13:37:57.185]         {
[13:37:57.185]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:57.185]                 ...future.oldOptions$nwarnings <- NULL
[13:37:57.185]             }
[13:37:57.185]             base::options(...future.oldOptions)
[13:37:57.185]             if (.Platform$OS.type == "windows") {
[13:37:57.185]                 old_names <- names(...future.oldEnvVars)
[13:37:57.185]                 envs <- base::Sys.getenv()
[13:37:57.185]                 names <- names(envs)
[13:37:57.185]                 common <- intersect(names, old_names)
[13:37:57.185]                 added <- setdiff(names, old_names)
[13:37:57.185]                 removed <- setdiff(old_names, names)
[13:37:57.185]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:57.185]                   envs[common]]
[13:37:57.185]                 NAMES <- toupper(changed)
[13:37:57.185]                 args <- list()
[13:37:57.185]                 for (kk in seq_along(NAMES)) {
[13:37:57.185]                   name <- changed[[kk]]
[13:37:57.185]                   NAME <- NAMES[[kk]]
[13:37:57.185]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:57.185]                     next
[13:37:57.185]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:57.185]                 }
[13:37:57.185]                 NAMES <- toupper(added)
[13:37:57.185]                 for (kk in seq_along(NAMES)) {
[13:37:57.185]                   name <- added[[kk]]
[13:37:57.185]                   NAME <- NAMES[[kk]]
[13:37:57.185]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:57.185]                     next
[13:37:57.185]                   args[[name]] <- ""
[13:37:57.185]                 }
[13:37:57.185]                 NAMES <- toupper(removed)
[13:37:57.185]                 for (kk in seq_along(NAMES)) {
[13:37:57.185]                   name <- removed[[kk]]
[13:37:57.185]                   NAME <- NAMES[[kk]]
[13:37:57.185]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:57.185]                     next
[13:37:57.185]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:57.185]                 }
[13:37:57.185]                 if (length(args) > 0) 
[13:37:57.185]                   base::do.call(base::Sys.setenv, args = args)
[13:37:57.185]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:57.185]             }
[13:37:57.185]             else {
[13:37:57.185]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:57.185]             }
[13:37:57.185]             {
[13:37:57.185]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:57.185]                   0L) {
[13:37:57.185]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:57.185]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:57.185]                   base::options(opts)
[13:37:57.185]                 }
[13:37:57.185]                 {
[13:37:57.185]                   {
[13:37:57.185]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:57.185]                     NULL
[13:37:57.185]                   }
[13:37:57.185]                   options(future.plan = NULL)
[13:37:57.185]                   if (is.na(NA_character_)) 
[13:37:57.185]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:57.185]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:57.185]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:57.185]                     .init = FALSE)
[13:37:57.185]                 }
[13:37:57.185]             }
[13:37:57.185]         }
[13:37:57.185]     })
[13:37:57.185]     if (TRUE) {
[13:37:57.185]         base::sink(type = "output", split = FALSE)
[13:37:57.185]         if (TRUE) {
[13:37:57.185]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:57.185]         }
[13:37:57.185]         else {
[13:37:57.185]             ...future.result["stdout"] <- base::list(NULL)
[13:37:57.185]         }
[13:37:57.185]         base::close(...future.stdout)
[13:37:57.185]         ...future.stdout <- NULL
[13:37:57.185]     }
[13:37:57.185]     ...future.result$conditions <- ...future.conditions
[13:37:57.185]     ...future.result$finished <- base::Sys.time()
[13:37:57.185]     ...future.result
[13:37:57.185] }
[13:37:57.188] MultisessionFuture started
[13:37:57.188] - Launch lazy future ... done
[13:37:57.188] run() for ‘MultisessionFuture’ ... done
[13:37:57.190] receiveMessageFromWorker() for ClusterFuture ...
[13:37:57.190] - Validating connection of MultisessionFuture
[13:37:57.190] - received message: FutureResult
[13:37:57.191] - Received FutureResult
[13:37:57.191] - Erased future from FutureRegistry
[13:37:57.191] result() for ClusterFuture ...
[13:37:57.191] - result already collected: FutureResult
[13:37:57.191] result() for ClusterFuture ... done
[13:37:57.191] signalConditions() ...
[13:37:57.191]  - include = ‘immediateCondition’
[13:37:57.191]  - exclude = 
[13:37:57.191]  - resignal = FALSE
[13:37:57.191]  - Number of conditions: 1
[13:37:57.191] signalConditions() ... done
[13:37:57.192] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:57.192] A MultisessionFuture was resolved
- result = TRUE, recursive = 0 ... DONE
- result = TRUE, recursive = 1 ...
[13:37:57.192] getGlobalsAndPackages() ...
[13:37:57.192] Searching for globals...
[13:37:57.193] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:37:57.193] Searching for globals ... DONE
[13:37:57.193] Resolving globals: FALSE
[13:37:57.194] 
[13:37:57.194] 
[13:37:57.194] getGlobalsAndPackages() ... DONE
[13:37:57.194] run() for ‘Future’ ...
[13:37:57.194] - state: ‘created’
[13:37:57.194] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:57.207] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:57.208] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:57.208]   - Field: ‘node’
[13:37:57.208]   - Field: ‘label’
[13:37:57.208]   - Field: ‘local’
[13:37:57.208]   - Field: ‘owner’
[13:37:57.208]   - Field: ‘envir’
[13:37:57.208]   - Field: ‘workers’
[13:37:57.208]   - Field: ‘packages’
[13:37:57.208]   - Field: ‘gc’
[13:37:57.209]   - Field: ‘conditions’
[13:37:57.209]   - Field: ‘persistent’
[13:37:57.209]   - Field: ‘expr’
[13:37:57.209]   - Field: ‘uuid’
[13:37:57.209]   - Field: ‘seed’
[13:37:57.209]   - Field: ‘version’
[13:37:57.209]   - Field: ‘result’
[13:37:57.209]   - Field: ‘asynchronous’
[13:37:57.209]   - Field: ‘calls’
[13:37:57.209]   - Field: ‘globals’
[13:37:57.209]   - Field: ‘stdout’
[13:37:57.209]   - Field: ‘earlySignal’
[13:37:57.210]   - Field: ‘lazy’
[13:37:57.210]   - Field: ‘state’
[13:37:57.210] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:57.210] - Launch lazy future ...
[13:37:57.210] Packages needed by the future expression (n = 0): <none>
[13:37:57.210] Packages needed by future strategies (n = 0): <none>
[13:37:57.211] {
[13:37:57.211]     {
[13:37:57.211]         {
[13:37:57.211]             ...future.startTime <- base::Sys.time()
[13:37:57.211]             {
[13:37:57.211]                 {
[13:37:57.211]                   {
[13:37:57.211]                     {
[13:37:57.211]                       base::local({
[13:37:57.211]                         has_future <- base::requireNamespace("future", 
[13:37:57.211]                           quietly = TRUE)
[13:37:57.211]                         if (has_future) {
[13:37:57.211]                           ns <- base::getNamespace("future")
[13:37:57.211]                           version <- ns[[".package"]][["version"]]
[13:37:57.211]                           if (is.null(version)) 
[13:37:57.211]                             version <- utils::packageVersion("future")
[13:37:57.211]                         }
[13:37:57.211]                         else {
[13:37:57.211]                           version <- NULL
[13:37:57.211]                         }
[13:37:57.211]                         if (!has_future || version < "1.8.0") {
[13:37:57.211]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:57.211]                             "", base::R.version$version.string), 
[13:37:57.211]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:57.211]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:57.211]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:57.211]                               "release", "version")], collapse = " "), 
[13:37:57.211]                             hostname = base::Sys.info()[["nodename"]])
[13:37:57.211]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:57.211]                             info)
[13:37:57.211]                           info <- base::paste(info, collapse = "; ")
[13:37:57.211]                           if (!has_future) {
[13:37:57.211]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:57.211]                               info)
[13:37:57.211]                           }
[13:37:57.211]                           else {
[13:37:57.211]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:57.211]                               info, version)
[13:37:57.211]                           }
[13:37:57.211]                           base::stop(msg)
[13:37:57.211]                         }
[13:37:57.211]                       })
[13:37:57.211]                     }
[13:37:57.211]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:57.211]                     base::options(mc.cores = 1L)
[13:37:57.211]                   }
[13:37:57.211]                   ...future.strategy.old <- future::plan("list")
[13:37:57.211]                   options(future.plan = NULL)
[13:37:57.211]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:57.211]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:57.211]                 }
[13:37:57.211]                 ...future.workdir <- getwd()
[13:37:57.211]             }
[13:37:57.211]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:57.211]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:57.211]         }
[13:37:57.211]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:57.211]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:57.211]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:57.211]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:57.211]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:57.211]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:57.211]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:57.211]             base::names(...future.oldOptions))
[13:37:57.211]     }
[13:37:57.211]     if (FALSE) {
[13:37:57.211]     }
[13:37:57.211]     else {
[13:37:57.211]         if (TRUE) {
[13:37:57.211]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:57.211]                 open = "w")
[13:37:57.211]         }
[13:37:57.211]         else {
[13:37:57.211]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:57.211]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:57.211]         }
[13:37:57.211]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:57.211]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:57.211]             base::sink(type = "output", split = FALSE)
[13:37:57.211]             base::close(...future.stdout)
[13:37:57.211]         }, add = TRUE)
[13:37:57.211]     }
[13:37:57.211]     ...future.frame <- base::sys.nframe()
[13:37:57.211]     ...future.conditions <- base::list()
[13:37:57.211]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:57.211]     if (FALSE) {
[13:37:57.211]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:57.211]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:57.211]     }
[13:37:57.211]     ...future.result <- base::tryCatch({
[13:37:57.211]         base::withCallingHandlers({
[13:37:57.211]             ...future.value <- base::withVisible(base::local({
[13:37:57.211]                 ...future.makeSendCondition <- base::local({
[13:37:57.211]                   sendCondition <- NULL
[13:37:57.211]                   function(frame = 1L) {
[13:37:57.211]                     if (is.function(sendCondition)) 
[13:37:57.211]                       return(sendCondition)
[13:37:57.211]                     ns <- getNamespace("parallel")
[13:37:57.211]                     if (exists("sendData", mode = "function", 
[13:37:57.211]                       envir = ns)) {
[13:37:57.211]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:57.211]                         envir = ns)
[13:37:57.211]                       envir <- sys.frame(frame)
[13:37:57.211]                       master <- NULL
[13:37:57.211]                       while (!identical(envir, .GlobalEnv) && 
[13:37:57.211]                         !identical(envir, emptyenv())) {
[13:37:57.211]                         if (exists("master", mode = "list", envir = envir, 
[13:37:57.211]                           inherits = FALSE)) {
[13:37:57.211]                           master <- get("master", mode = "list", 
[13:37:57.211]                             envir = envir, inherits = FALSE)
[13:37:57.211]                           if (inherits(master, c("SOCKnode", 
[13:37:57.211]                             "SOCK0node"))) {
[13:37:57.211]                             sendCondition <<- function(cond) {
[13:37:57.211]                               data <- list(type = "VALUE", value = cond, 
[13:37:57.211]                                 success = TRUE)
[13:37:57.211]                               parallel_sendData(master, data)
[13:37:57.211]                             }
[13:37:57.211]                             return(sendCondition)
[13:37:57.211]                           }
[13:37:57.211]                         }
[13:37:57.211]                         frame <- frame + 1L
[13:37:57.211]                         envir <- sys.frame(frame)
[13:37:57.211]                       }
[13:37:57.211]                     }
[13:37:57.211]                     sendCondition <<- function(cond) NULL
[13:37:57.211]                   }
[13:37:57.211]                 })
[13:37:57.211]                 withCallingHandlers({
[13:37:57.211]                   {
[13:37:57.211]                     Sys.sleep(0.5)
[13:37:57.211]                     list(a = 1, b = 42L)
[13:37:57.211]                   }
[13:37:57.211]                 }, immediateCondition = function(cond) {
[13:37:57.211]                   sendCondition <- ...future.makeSendCondition()
[13:37:57.211]                   sendCondition(cond)
[13:37:57.211]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:57.211]                   {
[13:37:57.211]                     inherits <- base::inherits
[13:37:57.211]                     invokeRestart <- base::invokeRestart
[13:37:57.211]                     is.null <- base::is.null
[13:37:57.211]                     muffled <- FALSE
[13:37:57.211]                     if (inherits(cond, "message")) {
[13:37:57.211]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:57.211]                       if (muffled) 
[13:37:57.211]                         invokeRestart("muffleMessage")
[13:37:57.211]                     }
[13:37:57.211]                     else if (inherits(cond, "warning")) {
[13:37:57.211]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:57.211]                       if (muffled) 
[13:37:57.211]                         invokeRestart("muffleWarning")
[13:37:57.211]                     }
[13:37:57.211]                     else if (inherits(cond, "condition")) {
[13:37:57.211]                       if (!is.null(pattern)) {
[13:37:57.211]                         computeRestarts <- base::computeRestarts
[13:37:57.211]                         grepl <- base::grepl
[13:37:57.211]                         restarts <- computeRestarts(cond)
[13:37:57.211]                         for (restart in restarts) {
[13:37:57.211]                           name <- restart$name
[13:37:57.211]                           if (is.null(name)) 
[13:37:57.211]                             next
[13:37:57.211]                           if (!grepl(pattern, name)) 
[13:37:57.211]                             next
[13:37:57.211]                           invokeRestart(restart)
[13:37:57.211]                           muffled <- TRUE
[13:37:57.211]                           break
[13:37:57.211]                         }
[13:37:57.211]                       }
[13:37:57.211]                     }
[13:37:57.211]                     invisible(muffled)
[13:37:57.211]                   }
[13:37:57.211]                   muffleCondition(cond)
[13:37:57.211]                 })
[13:37:57.211]             }))
[13:37:57.211]             future::FutureResult(value = ...future.value$value, 
[13:37:57.211]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:57.211]                   ...future.rng), globalenv = if (FALSE) 
[13:37:57.211]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:57.211]                     ...future.globalenv.names))
[13:37:57.211]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:57.211]         }, condition = base::local({
[13:37:57.211]             c <- base::c
[13:37:57.211]             inherits <- base::inherits
[13:37:57.211]             invokeRestart <- base::invokeRestart
[13:37:57.211]             length <- base::length
[13:37:57.211]             list <- base::list
[13:37:57.211]             seq.int <- base::seq.int
[13:37:57.211]             signalCondition <- base::signalCondition
[13:37:57.211]             sys.calls <- base::sys.calls
[13:37:57.211]             `[[` <- base::`[[`
[13:37:57.211]             `+` <- base::`+`
[13:37:57.211]             `<<-` <- base::`<<-`
[13:37:57.211]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:57.211]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:57.211]                   3L)]
[13:37:57.211]             }
[13:37:57.211]             function(cond) {
[13:37:57.211]                 is_error <- inherits(cond, "error")
[13:37:57.211]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:57.211]                   NULL)
[13:37:57.211]                 if (is_error) {
[13:37:57.211]                   sessionInformation <- function() {
[13:37:57.211]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:57.211]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:57.211]                       search = base::search(), system = base::Sys.info())
[13:37:57.211]                   }
[13:37:57.211]                   ...future.conditions[[length(...future.conditions) + 
[13:37:57.211]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:57.211]                     cond$call), session = sessionInformation(), 
[13:37:57.211]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:57.211]                   signalCondition(cond)
[13:37:57.211]                 }
[13:37:57.211]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:57.211]                 "immediateCondition"))) {
[13:37:57.211]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:57.211]                   ...future.conditions[[length(...future.conditions) + 
[13:37:57.211]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:57.211]                   if (TRUE && !signal) {
[13:37:57.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:57.211]                     {
[13:37:57.211]                       inherits <- base::inherits
[13:37:57.211]                       invokeRestart <- base::invokeRestart
[13:37:57.211]                       is.null <- base::is.null
[13:37:57.211]                       muffled <- FALSE
[13:37:57.211]                       if (inherits(cond, "message")) {
[13:37:57.211]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:57.211]                         if (muffled) 
[13:37:57.211]                           invokeRestart("muffleMessage")
[13:37:57.211]                       }
[13:37:57.211]                       else if (inherits(cond, "warning")) {
[13:37:57.211]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:57.211]                         if (muffled) 
[13:37:57.211]                           invokeRestart("muffleWarning")
[13:37:57.211]                       }
[13:37:57.211]                       else if (inherits(cond, "condition")) {
[13:37:57.211]                         if (!is.null(pattern)) {
[13:37:57.211]                           computeRestarts <- base::computeRestarts
[13:37:57.211]                           grepl <- base::grepl
[13:37:57.211]                           restarts <- computeRestarts(cond)
[13:37:57.211]                           for (restart in restarts) {
[13:37:57.211]                             name <- restart$name
[13:37:57.211]                             if (is.null(name)) 
[13:37:57.211]                               next
[13:37:57.211]                             if (!grepl(pattern, name)) 
[13:37:57.211]                               next
[13:37:57.211]                             invokeRestart(restart)
[13:37:57.211]                             muffled <- TRUE
[13:37:57.211]                             break
[13:37:57.211]                           }
[13:37:57.211]                         }
[13:37:57.211]                       }
[13:37:57.211]                       invisible(muffled)
[13:37:57.211]                     }
[13:37:57.211]                     muffleCondition(cond, pattern = "^muffle")
[13:37:57.211]                   }
[13:37:57.211]                 }
[13:37:57.211]                 else {
[13:37:57.211]                   if (TRUE) {
[13:37:57.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:57.211]                     {
[13:37:57.211]                       inherits <- base::inherits
[13:37:57.211]                       invokeRestart <- base::invokeRestart
[13:37:57.211]                       is.null <- base::is.null
[13:37:57.211]                       muffled <- FALSE
[13:37:57.211]                       if (inherits(cond, "message")) {
[13:37:57.211]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:57.211]                         if (muffled) 
[13:37:57.211]                           invokeRestart("muffleMessage")
[13:37:57.211]                       }
[13:37:57.211]                       else if (inherits(cond, "warning")) {
[13:37:57.211]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:57.211]                         if (muffled) 
[13:37:57.211]                           invokeRestart("muffleWarning")
[13:37:57.211]                       }
[13:37:57.211]                       else if (inherits(cond, "condition")) {
[13:37:57.211]                         if (!is.null(pattern)) {
[13:37:57.211]                           computeRestarts <- base::computeRestarts
[13:37:57.211]                           grepl <- base::grepl
[13:37:57.211]                           restarts <- computeRestarts(cond)
[13:37:57.211]                           for (restart in restarts) {
[13:37:57.211]                             name <- restart$name
[13:37:57.211]                             if (is.null(name)) 
[13:37:57.211]                               next
[13:37:57.211]                             if (!grepl(pattern, name)) 
[13:37:57.211]                               next
[13:37:57.211]                             invokeRestart(restart)
[13:37:57.211]                             muffled <- TRUE
[13:37:57.211]                             break
[13:37:57.211]                           }
[13:37:57.211]                         }
[13:37:57.211]                       }
[13:37:57.211]                       invisible(muffled)
[13:37:57.211]                     }
[13:37:57.211]                     muffleCondition(cond, pattern = "^muffle")
[13:37:57.211]                   }
[13:37:57.211]                 }
[13:37:57.211]             }
[13:37:57.211]         }))
[13:37:57.211]     }, error = function(ex) {
[13:37:57.211]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:57.211]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:57.211]                 ...future.rng), started = ...future.startTime, 
[13:37:57.211]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:57.211]             version = "1.8"), class = "FutureResult")
[13:37:57.211]     }, finally = {
[13:37:57.211]         if (!identical(...future.workdir, getwd())) 
[13:37:57.211]             setwd(...future.workdir)
[13:37:57.211]         {
[13:37:57.211]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:57.211]                 ...future.oldOptions$nwarnings <- NULL
[13:37:57.211]             }
[13:37:57.211]             base::options(...future.oldOptions)
[13:37:57.211]             if (.Platform$OS.type == "windows") {
[13:37:57.211]                 old_names <- names(...future.oldEnvVars)
[13:37:57.211]                 envs <- base::Sys.getenv()
[13:37:57.211]                 names <- names(envs)
[13:37:57.211]                 common <- intersect(names, old_names)
[13:37:57.211]                 added <- setdiff(names, old_names)
[13:37:57.211]                 removed <- setdiff(old_names, names)
[13:37:57.211]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:57.211]                   envs[common]]
[13:37:57.211]                 NAMES <- toupper(changed)
[13:37:57.211]                 args <- list()
[13:37:57.211]                 for (kk in seq_along(NAMES)) {
[13:37:57.211]                   name <- changed[[kk]]
[13:37:57.211]                   NAME <- NAMES[[kk]]
[13:37:57.211]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:57.211]                     next
[13:37:57.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:57.211]                 }
[13:37:57.211]                 NAMES <- toupper(added)
[13:37:57.211]                 for (kk in seq_along(NAMES)) {
[13:37:57.211]                   name <- added[[kk]]
[13:37:57.211]                   NAME <- NAMES[[kk]]
[13:37:57.211]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:57.211]                     next
[13:37:57.211]                   args[[name]] <- ""
[13:37:57.211]                 }
[13:37:57.211]                 NAMES <- toupper(removed)
[13:37:57.211]                 for (kk in seq_along(NAMES)) {
[13:37:57.211]                   name <- removed[[kk]]
[13:37:57.211]                   NAME <- NAMES[[kk]]
[13:37:57.211]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:57.211]                     next
[13:37:57.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:57.211]                 }
[13:37:57.211]                 if (length(args) > 0) 
[13:37:57.211]                   base::do.call(base::Sys.setenv, args = args)
[13:37:57.211]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:57.211]             }
[13:37:57.211]             else {
[13:37:57.211]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:57.211]             }
[13:37:57.211]             {
[13:37:57.211]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:57.211]                   0L) {
[13:37:57.211]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:57.211]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:57.211]                   base::options(opts)
[13:37:57.211]                 }
[13:37:57.211]                 {
[13:37:57.211]                   {
[13:37:57.211]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:57.211]                     NULL
[13:37:57.211]                   }
[13:37:57.211]                   options(future.plan = NULL)
[13:37:57.211]                   if (is.na(NA_character_)) 
[13:37:57.211]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:57.211]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:57.211]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:57.211]                     .init = FALSE)
[13:37:57.211]                 }
[13:37:57.211]             }
[13:37:57.211]         }
[13:37:57.211]     })
[13:37:57.211]     if (TRUE) {
[13:37:57.211]         base::sink(type = "output", split = FALSE)
[13:37:57.211]         if (TRUE) {
[13:37:57.211]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:57.211]         }
[13:37:57.211]         else {
[13:37:57.211]             ...future.result["stdout"] <- base::list(NULL)
[13:37:57.211]         }
[13:37:57.211]         base::close(...future.stdout)
[13:37:57.211]         ...future.stdout <- NULL
[13:37:57.211]     }
[13:37:57.211]     ...future.result$conditions <- ...future.conditions
[13:37:57.211]     ...future.result$finished <- base::Sys.time()
[13:37:57.211]     ...future.result
[13:37:57.211] }
[13:37:57.214] MultisessionFuture started
[13:37:57.214] - Launch lazy future ... done
[13:37:57.214] run() for ‘MultisessionFuture’ ... done
[13:37:57.716] receiveMessageFromWorker() for ClusterFuture ...
[13:37:57.716] - Validating connection of MultisessionFuture
[13:37:57.717] - received message: FutureResult
[13:37:57.717] - Received FutureResult
[13:37:57.717] - Erased future from FutureRegistry
[13:37:57.717] result() for ClusterFuture ...
[13:37:57.717] - result already collected: FutureResult
[13:37:57.717] result() for ClusterFuture ... done
[13:37:57.717] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:57.717] resolve() on list ...
[13:37:57.718]  recursive: 0
[13:37:57.718]  length: 2
[13:37:57.718]  elements: ‘a’, ‘b’
[13:37:57.718]  length: 1 (resolved future 1)
[13:37:57.718]  length: 0 (resolved future 2)
[13:37:57.718] resolve() on list ... DONE
[13:37:57.718] A MultisessionFuture was resolved (and resolved itself)
[13:37:57.718] getGlobalsAndPackages() ...
[13:37:57.718] Searching for globals...
[13:37:57.720] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:37:57.720] Searching for globals ... DONE
[13:37:57.720] Resolving globals: FALSE
[13:37:57.720] 
[13:37:57.720] 
[13:37:57.720] getGlobalsAndPackages() ... DONE
[13:37:57.721] run() for ‘Future’ ...
[13:37:57.721] - state: ‘created’
[13:37:57.721] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:57.735] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:57.735] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:57.735]   - Field: ‘node’
[13:37:57.735]   - Field: ‘label’
[13:37:57.735]   - Field: ‘local’
[13:37:57.735]   - Field: ‘owner’
[13:37:57.735]   - Field: ‘envir’
[13:37:57.735]   - Field: ‘workers’
[13:37:57.736]   - Field: ‘packages’
[13:37:57.736]   - Field: ‘gc’
[13:37:57.736]   - Field: ‘conditions’
[13:37:57.736]   - Field: ‘persistent’
[13:37:57.736]   - Field: ‘expr’
[13:37:57.736]   - Field: ‘uuid’
[13:37:57.736]   - Field: ‘seed’
[13:37:57.736]   - Field: ‘version’
[13:37:57.736]   - Field: ‘result’
[13:37:57.736]   - Field: ‘asynchronous’
[13:37:57.736]   - Field: ‘calls’
[13:37:57.737]   - Field: ‘globals’
[13:37:57.737]   - Field: ‘stdout’
[13:37:57.737]   - Field: ‘earlySignal’
[13:37:57.737]   - Field: ‘lazy’
[13:37:57.737]   - Field: ‘state’
[13:37:57.737] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:57.737] - Launch lazy future ...
[13:37:57.737] Packages needed by the future expression (n = 0): <none>
[13:37:57.737] Packages needed by future strategies (n = 0): <none>
[13:37:57.738] {
[13:37:57.738]     {
[13:37:57.738]         {
[13:37:57.738]             ...future.startTime <- base::Sys.time()
[13:37:57.738]             {
[13:37:57.738]                 {
[13:37:57.738]                   {
[13:37:57.738]                     {
[13:37:57.738]                       base::local({
[13:37:57.738]                         has_future <- base::requireNamespace("future", 
[13:37:57.738]                           quietly = TRUE)
[13:37:57.738]                         if (has_future) {
[13:37:57.738]                           ns <- base::getNamespace("future")
[13:37:57.738]                           version <- ns[[".package"]][["version"]]
[13:37:57.738]                           if (is.null(version)) 
[13:37:57.738]                             version <- utils::packageVersion("future")
[13:37:57.738]                         }
[13:37:57.738]                         else {
[13:37:57.738]                           version <- NULL
[13:37:57.738]                         }
[13:37:57.738]                         if (!has_future || version < "1.8.0") {
[13:37:57.738]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:57.738]                             "", base::R.version$version.string), 
[13:37:57.738]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:57.738]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:57.738]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:57.738]                               "release", "version")], collapse = " "), 
[13:37:57.738]                             hostname = base::Sys.info()[["nodename"]])
[13:37:57.738]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:57.738]                             info)
[13:37:57.738]                           info <- base::paste(info, collapse = "; ")
[13:37:57.738]                           if (!has_future) {
[13:37:57.738]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:57.738]                               info)
[13:37:57.738]                           }
[13:37:57.738]                           else {
[13:37:57.738]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:57.738]                               info, version)
[13:37:57.738]                           }
[13:37:57.738]                           base::stop(msg)
[13:37:57.738]                         }
[13:37:57.738]                       })
[13:37:57.738]                     }
[13:37:57.738]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:57.738]                     base::options(mc.cores = 1L)
[13:37:57.738]                   }
[13:37:57.738]                   ...future.strategy.old <- future::plan("list")
[13:37:57.738]                   options(future.plan = NULL)
[13:37:57.738]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:57.738]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:57.738]                 }
[13:37:57.738]                 ...future.workdir <- getwd()
[13:37:57.738]             }
[13:37:57.738]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:57.738]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:57.738]         }
[13:37:57.738]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:57.738]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:57.738]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:57.738]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:57.738]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:57.738]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:57.738]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:57.738]             base::names(...future.oldOptions))
[13:37:57.738]     }
[13:37:57.738]     if (FALSE) {
[13:37:57.738]     }
[13:37:57.738]     else {
[13:37:57.738]         if (TRUE) {
[13:37:57.738]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:57.738]                 open = "w")
[13:37:57.738]         }
[13:37:57.738]         else {
[13:37:57.738]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:57.738]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:57.738]         }
[13:37:57.738]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:57.738]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:57.738]             base::sink(type = "output", split = FALSE)
[13:37:57.738]             base::close(...future.stdout)
[13:37:57.738]         }, add = TRUE)
[13:37:57.738]     }
[13:37:57.738]     ...future.frame <- base::sys.nframe()
[13:37:57.738]     ...future.conditions <- base::list()
[13:37:57.738]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:57.738]     if (FALSE) {
[13:37:57.738]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:57.738]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:57.738]     }
[13:37:57.738]     ...future.result <- base::tryCatch({
[13:37:57.738]         base::withCallingHandlers({
[13:37:57.738]             ...future.value <- base::withVisible(base::local({
[13:37:57.738]                 ...future.makeSendCondition <- base::local({
[13:37:57.738]                   sendCondition <- NULL
[13:37:57.738]                   function(frame = 1L) {
[13:37:57.738]                     if (is.function(sendCondition)) 
[13:37:57.738]                       return(sendCondition)
[13:37:57.738]                     ns <- getNamespace("parallel")
[13:37:57.738]                     if (exists("sendData", mode = "function", 
[13:37:57.738]                       envir = ns)) {
[13:37:57.738]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:57.738]                         envir = ns)
[13:37:57.738]                       envir <- sys.frame(frame)
[13:37:57.738]                       master <- NULL
[13:37:57.738]                       while (!identical(envir, .GlobalEnv) && 
[13:37:57.738]                         !identical(envir, emptyenv())) {
[13:37:57.738]                         if (exists("master", mode = "list", envir = envir, 
[13:37:57.738]                           inherits = FALSE)) {
[13:37:57.738]                           master <- get("master", mode = "list", 
[13:37:57.738]                             envir = envir, inherits = FALSE)
[13:37:57.738]                           if (inherits(master, c("SOCKnode", 
[13:37:57.738]                             "SOCK0node"))) {
[13:37:57.738]                             sendCondition <<- function(cond) {
[13:37:57.738]                               data <- list(type = "VALUE", value = cond, 
[13:37:57.738]                                 success = TRUE)
[13:37:57.738]                               parallel_sendData(master, data)
[13:37:57.738]                             }
[13:37:57.738]                             return(sendCondition)
[13:37:57.738]                           }
[13:37:57.738]                         }
[13:37:57.738]                         frame <- frame + 1L
[13:37:57.738]                         envir <- sys.frame(frame)
[13:37:57.738]                       }
[13:37:57.738]                     }
[13:37:57.738]                     sendCondition <<- function(cond) NULL
[13:37:57.738]                   }
[13:37:57.738]                 })
[13:37:57.738]                 withCallingHandlers({
[13:37:57.738]                   {
[13:37:57.738]                     Sys.sleep(0.5)
[13:37:57.738]                     list(a = 1, b = 42L)
[13:37:57.738]                   }
[13:37:57.738]                 }, immediateCondition = function(cond) {
[13:37:57.738]                   sendCondition <- ...future.makeSendCondition()
[13:37:57.738]                   sendCondition(cond)
[13:37:57.738]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:57.738]                   {
[13:37:57.738]                     inherits <- base::inherits
[13:37:57.738]                     invokeRestart <- base::invokeRestart
[13:37:57.738]                     is.null <- base::is.null
[13:37:57.738]                     muffled <- FALSE
[13:37:57.738]                     if (inherits(cond, "message")) {
[13:37:57.738]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:57.738]                       if (muffled) 
[13:37:57.738]                         invokeRestart("muffleMessage")
[13:37:57.738]                     }
[13:37:57.738]                     else if (inherits(cond, "warning")) {
[13:37:57.738]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:57.738]                       if (muffled) 
[13:37:57.738]                         invokeRestart("muffleWarning")
[13:37:57.738]                     }
[13:37:57.738]                     else if (inherits(cond, "condition")) {
[13:37:57.738]                       if (!is.null(pattern)) {
[13:37:57.738]                         computeRestarts <- base::computeRestarts
[13:37:57.738]                         grepl <- base::grepl
[13:37:57.738]                         restarts <- computeRestarts(cond)
[13:37:57.738]                         for (restart in restarts) {
[13:37:57.738]                           name <- restart$name
[13:37:57.738]                           if (is.null(name)) 
[13:37:57.738]                             next
[13:37:57.738]                           if (!grepl(pattern, name)) 
[13:37:57.738]                             next
[13:37:57.738]                           invokeRestart(restart)
[13:37:57.738]                           muffled <- TRUE
[13:37:57.738]                           break
[13:37:57.738]                         }
[13:37:57.738]                       }
[13:37:57.738]                     }
[13:37:57.738]                     invisible(muffled)
[13:37:57.738]                   }
[13:37:57.738]                   muffleCondition(cond)
[13:37:57.738]                 })
[13:37:57.738]             }))
[13:37:57.738]             future::FutureResult(value = ...future.value$value, 
[13:37:57.738]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:57.738]                   ...future.rng), globalenv = if (FALSE) 
[13:37:57.738]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:57.738]                     ...future.globalenv.names))
[13:37:57.738]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:57.738]         }, condition = base::local({
[13:37:57.738]             c <- base::c
[13:37:57.738]             inherits <- base::inherits
[13:37:57.738]             invokeRestart <- base::invokeRestart
[13:37:57.738]             length <- base::length
[13:37:57.738]             list <- base::list
[13:37:57.738]             seq.int <- base::seq.int
[13:37:57.738]             signalCondition <- base::signalCondition
[13:37:57.738]             sys.calls <- base::sys.calls
[13:37:57.738]             `[[` <- base::`[[`
[13:37:57.738]             `+` <- base::`+`
[13:37:57.738]             `<<-` <- base::`<<-`
[13:37:57.738]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:57.738]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:57.738]                   3L)]
[13:37:57.738]             }
[13:37:57.738]             function(cond) {
[13:37:57.738]                 is_error <- inherits(cond, "error")
[13:37:57.738]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:57.738]                   NULL)
[13:37:57.738]                 if (is_error) {
[13:37:57.738]                   sessionInformation <- function() {
[13:37:57.738]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:57.738]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:57.738]                       search = base::search(), system = base::Sys.info())
[13:37:57.738]                   }
[13:37:57.738]                   ...future.conditions[[length(...future.conditions) + 
[13:37:57.738]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:57.738]                     cond$call), session = sessionInformation(), 
[13:37:57.738]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:57.738]                   signalCondition(cond)
[13:37:57.738]                 }
[13:37:57.738]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:57.738]                 "immediateCondition"))) {
[13:37:57.738]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:57.738]                   ...future.conditions[[length(...future.conditions) + 
[13:37:57.738]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:57.738]                   if (TRUE && !signal) {
[13:37:57.738]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:57.738]                     {
[13:37:57.738]                       inherits <- base::inherits
[13:37:57.738]                       invokeRestart <- base::invokeRestart
[13:37:57.738]                       is.null <- base::is.null
[13:37:57.738]                       muffled <- FALSE
[13:37:57.738]                       if (inherits(cond, "message")) {
[13:37:57.738]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:57.738]                         if (muffled) 
[13:37:57.738]                           invokeRestart("muffleMessage")
[13:37:57.738]                       }
[13:37:57.738]                       else if (inherits(cond, "warning")) {
[13:37:57.738]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:57.738]                         if (muffled) 
[13:37:57.738]                           invokeRestart("muffleWarning")
[13:37:57.738]                       }
[13:37:57.738]                       else if (inherits(cond, "condition")) {
[13:37:57.738]                         if (!is.null(pattern)) {
[13:37:57.738]                           computeRestarts <- base::computeRestarts
[13:37:57.738]                           grepl <- base::grepl
[13:37:57.738]                           restarts <- computeRestarts(cond)
[13:37:57.738]                           for (restart in restarts) {
[13:37:57.738]                             name <- restart$name
[13:37:57.738]                             if (is.null(name)) 
[13:37:57.738]                               next
[13:37:57.738]                             if (!grepl(pattern, name)) 
[13:37:57.738]                               next
[13:37:57.738]                             invokeRestart(restart)
[13:37:57.738]                             muffled <- TRUE
[13:37:57.738]                             break
[13:37:57.738]                           }
[13:37:57.738]                         }
[13:37:57.738]                       }
[13:37:57.738]                       invisible(muffled)
[13:37:57.738]                     }
[13:37:57.738]                     muffleCondition(cond, pattern = "^muffle")
[13:37:57.738]                   }
[13:37:57.738]                 }
[13:37:57.738]                 else {
[13:37:57.738]                   if (TRUE) {
[13:37:57.738]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:57.738]                     {
[13:37:57.738]                       inherits <- base::inherits
[13:37:57.738]                       invokeRestart <- base::invokeRestart
[13:37:57.738]                       is.null <- base::is.null
[13:37:57.738]                       muffled <- FALSE
[13:37:57.738]                       if (inherits(cond, "message")) {
[13:37:57.738]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:57.738]                         if (muffled) 
[13:37:57.738]                           invokeRestart("muffleMessage")
[13:37:57.738]                       }
[13:37:57.738]                       else if (inherits(cond, "warning")) {
[13:37:57.738]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:57.738]                         if (muffled) 
[13:37:57.738]                           invokeRestart("muffleWarning")
[13:37:57.738]                       }
[13:37:57.738]                       else if (inherits(cond, "condition")) {
[13:37:57.738]                         if (!is.null(pattern)) {
[13:37:57.738]                           computeRestarts <- base::computeRestarts
[13:37:57.738]                           grepl <- base::grepl
[13:37:57.738]                           restarts <- computeRestarts(cond)
[13:37:57.738]                           for (restart in restarts) {
[13:37:57.738]                             name <- restart$name
[13:37:57.738]                             if (is.null(name)) 
[13:37:57.738]                               next
[13:37:57.738]                             if (!grepl(pattern, name)) 
[13:37:57.738]                               next
[13:37:57.738]                             invokeRestart(restart)
[13:37:57.738]                             muffled <- TRUE
[13:37:57.738]                             break
[13:37:57.738]                           }
[13:37:57.738]                         }
[13:37:57.738]                       }
[13:37:57.738]                       invisible(muffled)
[13:37:57.738]                     }
[13:37:57.738]                     muffleCondition(cond, pattern = "^muffle")
[13:37:57.738]                   }
[13:37:57.738]                 }
[13:37:57.738]             }
[13:37:57.738]         }))
[13:37:57.738]     }, error = function(ex) {
[13:37:57.738]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:57.738]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:57.738]                 ...future.rng), started = ...future.startTime, 
[13:37:57.738]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:57.738]             version = "1.8"), class = "FutureResult")
[13:37:57.738]     }, finally = {
[13:37:57.738]         if (!identical(...future.workdir, getwd())) 
[13:37:57.738]             setwd(...future.workdir)
[13:37:57.738]         {
[13:37:57.738]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:57.738]                 ...future.oldOptions$nwarnings <- NULL
[13:37:57.738]             }
[13:37:57.738]             base::options(...future.oldOptions)
[13:37:57.738]             if (.Platform$OS.type == "windows") {
[13:37:57.738]                 old_names <- names(...future.oldEnvVars)
[13:37:57.738]                 envs <- base::Sys.getenv()
[13:37:57.738]                 names <- names(envs)
[13:37:57.738]                 common <- intersect(names, old_names)
[13:37:57.738]                 added <- setdiff(names, old_names)
[13:37:57.738]                 removed <- setdiff(old_names, names)
[13:37:57.738]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:57.738]                   envs[common]]
[13:37:57.738]                 NAMES <- toupper(changed)
[13:37:57.738]                 args <- list()
[13:37:57.738]                 for (kk in seq_along(NAMES)) {
[13:37:57.738]                   name <- changed[[kk]]
[13:37:57.738]                   NAME <- NAMES[[kk]]
[13:37:57.738]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:57.738]                     next
[13:37:57.738]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:57.738]                 }
[13:37:57.738]                 NAMES <- toupper(added)
[13:37:57.738]                 for (kk in seq_along(NAMES)) {
[13:37:57.738]                   name <- added[[kk]]
[13:37:57.738]                   NAME <- NAMES[[kk]]
[13:37:57.738]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:57.738]                     next
[13:37:57.738]                   args[[name]] <- ""
[13:37:57.738]                 }
[13:37:57.738]                 NAMES <- toupper(removed)
[13:37:57.738]                 for (kk in seq_along(NAMES)) {
[13:37:57.738]                   name <- removed[[kk]]
[13:37:57.738]                   NAME <- NAMES[[kk]]
[13:37:57.738]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:57.738]                     next
[13:37:57.738]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:57.738]                 }
[13:37:57.738]                 if (length(args) > 0) 
[13:37:57.738]                   base::do.call(base::Sys.setenv, args = args)
[13:37:57.738]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:57.738]             }
[13:37:57.738]             else {
[13:37:57.738]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:57.738]             }
[13:37:57.738]             {
[13:37:57.738]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:57.738]                   0L) {
[13:37:57.738]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:57.738]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:57.738]                   base::options(opts)
[13:37:57.738]                 }
[13:37:57.738]                 {
[13:37:57.738]                   {
[13:37:57.738]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:57.738]                     NULL
[13:37:57.738]                   }
[13:37:57.738]                   options(future.plan = NULL)
[13:37:57.738]                   if (is.na(NA_character_)) 
[13:37:57.738]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:57.738]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:57.738]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:57.738]                     .init = FALSE)
[13:37:57.738]                 }
[13:37:57.738]             }
[13:37:57.738]         }
[13:37:57.738]     })
[13:37:57.738]     if (TRUE) {
[13:37:57.738]         base::sink(type = "output", split = FALSE)
[13:37:57.738]         if (TRUE) {
[13:37:57.738]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:57.738]         }
[13:37:57.738]         else {
[13:37:57.738]             ...future.result["stdout"] <- base::list(NULL)
[13:37:57.738]         }
[13:37:57.738]         base::close(...future.stdout)
[13:37:57.738]         ...future.stdout <- NULL
[13:37:57.738]     }
[13:37:57.738]     ...future.result$conditions <- ...future.conditions
[13:37:57.738]     ...future.result$finished <- base::Sys.time()
[13:37:57.738]     ...future.result
[13:37:57.738] }
[13:37:57.741] MultisessionFuture started
[13:37:57.741] - Launch lazy future ... done
[13:37:57.741] run() for ‘MultisessionFuture’ ... done
[13:37:58.244] receiveMessageFromWorker() for ClusterFuture ...
[13:37:58.244] - Validating connection of MultisessionFuture
[13:37:58.244] - received message: FutureResult
[13:37:58.244] - Received FutureResult
[13:37:58.245] - Erased future from FutureRegistry
[13:37:58.245] result() for ClusterFuture ...
[13:37:58.245] - result already collected: FutureResult
[13:37:58.245] result() for ClusterFuture ... done
[13:37:58.245] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:58.245] resolve() on list ...
[13:37:58.245]  recursive: 0
[13:37:58.245]  length: 2
[13:37:58.245]  elements: ‘a’, ‘b’
[13:37:58.246]  length: 1 (resolved future 1)
[13:37:58.246]  length: 0 (resolved future 2)
[13:37:58.246] resolve() on list ... DONE
[13:37:58.246] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[13:37:58.246] getGlobalsAndPackages() ...
[13:37:58.249] Searching for globals...
[13:37:58.250] - globals found: [2] ‘list’, ‘stop’
[13:37:58.250] Searching for globals ... DONE
[13:37:58.250] Resolving globals: FALSE
[13:37:58.250] 
[13:37:58.250] 
[13:37:58.250] getGlobalsAndPackages() ... DONE
[13:37:58.251] run() for ‘Future’ ...
[13:37:58.251] - state: ‘created’
[13:37:58.251] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:58.265] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:58.265] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:58.265]   - Field: ‘node’
[13:37:58.265]   - Field: ‘label’
[13:37:58.266]   - Field: ‘local’
[13:37:58.266]   - Field: ‘owner’
[13:37:58.266]   - Field: ‘envir’
[13:37:58.266]   - Field: ‘workers’
[13:37:58.266]   - Field: ‘packages’
[13:37:58.266]   - Field: ‘gc’
[13:37:58.266]   - Field: ‘conditions’
[13:37:58.266]   - Field: ‘persistent’
[13:37:58.266]   - Field: ‘expr’
[13:37:58.266]   - Field: ‘uuid’
[13:37:58.267]   - Field: ‘seed’
[13:37:58.267]   - Field: ‘version’
[13:37:58.267]   - Field: ‘result’
[13:37:58.267]   - Field: ‘asynchronous’
[13:37:58.267]   - Field: ‘calls’
[13:37:58.267]   - Field: ‘globals’
[13:37:58.267]   - Field: ‘stdout’
[13:37:58.267]   - Field: ‘earlySignal’
[13:37:58.267]   - Field: ‘lazy’
[13:37:58.267]   - Field: ‘state’
[13:37:58.267] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:58.267] - Launch lazy future ...
[13:37:58.268] Packages needed by the future expression (n = 0): <none>
[13:37:58.268] Packages needed by future strategies (n = 0): <none>
[13:37:58.268] {
[13:37:58.268]     {
[13:37:58.268]         {
[13:37:58.268]             ...future.startTime <- base::Sys.time()
[13:37:58.268]             {
[13:37:58.268]                 {
[13:37:58.268]                   {
[13:37:58.268]                     {
[13:37:58.268]                       base::local({
[13:37:58.268]                         has_future <- base::requireNamespace("future", 
[13:37:58.268]                           quietly = TRUE)
[13:37:58.268]                         if (has_future) {
[13:37:58.268]                           ns <- base::getNamespace("future")
[13:37:58.268]                           version <- ns[[".package"]][["version"]]
[13:37:58.268]                           if (is.null(version)) 
[13:37:58.268]                             version <- utils::packageVersion("future")
[13:37:58.268]                         }
[13:37:58.268]                         else {
[13:37:58.268]                           version <- NULL
[13:37:58.268]                         }
[13:37:58.268]                         if (!has_future || version < "1.8.0") {
[13:37:58.268]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:58.268]                             "", base::R.version$version.string), 
[13:37:58.268]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:58.268]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:58.268]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:58.268]                               "release", "version")], collapse = " "), 
[13:37:58.268]                             hostname = base::Sys.info()[["nodename"]])
[13:37:58.268]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:58.268]                             info)
[13:37:58.268]                           info <- base::paste(info, collapse = "; ")
[13:37:58.268]                           if (!has_future) {
[13:37:58.268]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:58.268]                               info)
[13:37:58.268]                           }
[13:37:58.268]                           else {
[13:37:58.268]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:58.268]                               info, version)
[13:37:58.268]                           }
[13:37:58.268]                           base::stop(msg)
[13:37:58.268]                         }
[13:37:58.268]                       })
[13:37:58.268]                     }
[13:37:58.268]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:58.268]                     base::options(mc.cores = 1L)
[13:37:58.268]                   }
[13:37:58.268]                   ...future.strategy.old <- future::plan("list")
[13:37:58.268]                   options(future.plan = NULL)
[13:37:58.268]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:58.268]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:58.268]                 }
[13:37:58.268]                 ...future.workdir <- getwd()
[13:37:58.268]             }
[13:37:58.268]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:58.268]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:58.268]         }
[13:37:58.268]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:58.268]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:58.268]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:58.268]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:58.268]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:58.268]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:58.268]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:58.268]             base::names(...future.oldOptions))
[13:37:58.268]     }
[13:37:58.268]     if (FALSE) {
[13:37:58.268]     }
[13:37:58.268]     else {
[13:37:58.268]         if (TRUE) {
[13:37:58.268]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:58.268]                 open = "w")
[13:37:58.268]         }
[13:37:58.268]         else {
[13:37:58.268]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:58.268]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:58.268]         }
[13:37:58.268]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:58.268]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:58.268]             base::sink(type = "output", split = FALSE)
[13:37:58.268]             base::close(...future.stdout)
[13:37:58.268]         }, add = TRUE)
[13:37:58.268]     }
[13:37:58.268]     ...future.frame <- base::sys.nframe()
[13:37:58.268]     ...future.conditions <- base::list()
[13:37:58.268]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:58.268]     if (FALSE) {
[13:37:58.268]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:58.268]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:58.268]     }
[13:37:58.268]     ...future.result <- base::tryCatch({
[13:37:58.268]         base::withCallingHandlers({
[13:37:58.268]             ...future.value <- base::withVisible(base::local({
[13:37:58.268]                 ...future.makeSendCondition <- base::local({
[13:37:58.268]                   sendCondition <- NULL
[13:37:58.268]                   function(frame = 1L) {
[13:37:58.268]                     if (is.function(sendCondition)) 
[13:37:58.268]                       return(sendCondition)
[13:37:58.268]                     ns <- getNamespace("parallel")
[13:37:58.268]                     if (exists("sendData", mode = "function", 
[13:37:58.268]                       envir = ns)) {
[13:37:58.268]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:58.268]                         envir = ns)
[13:37:58.268]                       envir <- sys.frame(frame)
[13:37:58.268]                       master <- NULL
[13:37:58.268]                       while (!identical(envir, .GlobalEnv) && 
[13:37:58.268]                         !identical(envir, emptyenv())) {
[13:37:58.268]                         if (exists("master", mode = "list", envir = envir, 
[13:37:58.268]                           inherits = FALSE)) {
[13:37:58.268]                           master <- get("master", mode = "list", 
[13:37:58.268]                             envir = envir, inherits = FALSE)
[13:37:58.268]                           if (inherits(master, c("SOCKnode", 
[13:37:58.268]                             "SOCK0node"))) {
[13:37:58.268]                             sendCondition <<- function(cond) {
[13:37:58.268]                               data <- list(type = "VALUE", value = cond, 
[13:37:58.268]                                 success = TRUE)
[13:37:58.268]                               parallel_sendData(master, data)
[13:37:58.268]                             }
[13:37:58.268]                             return(sendCondition)
[13:37:58.268]                           }
[13:37:58.268]                         }
[13:37:58.268]                         frame <- frame + 1L
[13:37:58.268]                         envir <- sys.frame(frame)
[13:37:58.268]                       }
[13:37:58.268]                     }
[13:37:58.268]                     sendCondition <<- function(cond) NULL
[13:37:58.268]                   }
[13:37:58.268]                 })
[13:37:58.268]                 withCallingHandlers({
[13:37:58.268]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:37:58.268]                 }, immediateCondition = function(cond) {
[13:37:58.268]                   sendCondition <- ...future.makeSendCondition()
[13:37:58.268]                   sendCondition(cond)
[13:37:58.268]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:58.268]                   {
[13:37:58.268]                     inherits <- base::inherits
[13:37:58.268]                     invokeRestart <- base::invokeRestart
[13:37:58.268]                     is.null <- base::is.null
[13:37:58.268]                     muffled <- FALSE
[13:37:58.268]                     if (inherits(cond, "message")) {
[13:37:58.268]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:58.268]                       if (muffled) 
[13:37:58.268]                         invokeRestart("muffleMessage")
[13:37:58.268]                     }
[13:37:58.268]                     else if (inherits(cond, "warning")) {
[13:37:58.268]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:58.268]                       if (muffled) 
[13:37:58.268]                         invokeRestart("muffleWarning")
[13:37:58.268]                     }
[13:37:58.268]                     else if (inherits(cond, "condition")) {
[13:37:58.268]                       if (!is.null(pattern)) {
[13:37:58.268]                         computeRestarts <- base::computeRestarts
[13:37:58.268]                         grepl <- base::grepl
[13:37:58.268]                         restarts <- computeRestarts(cond)
[13:37:58.268]                         for (restart in restarts) {
[13:37:58.268]                           name <- restart$name
[13:37:58.268]                           if (is.null(name)) 
[13:37:58.268]                             next
[13:37:58.268]                           if (!grepl(pattern, name)) 
[13:37:58.268]                             next
[13:37:58.268]                           invokeRestart(restart)
[13:37:58.268]                           muffled <- TRUE
[13:37:58.268]                           break
[13:37:58.268]                         }
[13:37:58.268]                       }
[13:37:58.268]                     }
[13:37:58.268]                     invisible(muffled)
[13:37:58.268]                   }
[13:37:58.268]                   muffleCondition(cond)
[13:37:58.268]                 })
[13:37:58.268]             }))
[13:37:58.268]             future::FutureResult(value = ...future.value$value, 
[13:37:58.268]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:58.268]                   ...future.rng), globalenv = if (FALSE) 
[13:37:58.268]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:58.268]                     ...future.globalenv.names))
[13:37:58.268]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:58.268]         }, condition = base::local({
[13:37:58.268]             c <- base::c
[13:37:58.268]             inherits <- base::inherits
[13:37:58.268]             invokeRestart <- base::invokeRestart
[13:37:58.268]             length <- base::length
[13:37:58.268]             list <- base::list
[13:37:58.268]             seq.int <- base::seq.int
[13:37:58.268]             signalCondition <- base::signalCondition
[13:37:58.268]             sys.calls <- base::sys.calls
[13:37:58.268]             `[[` <- base::`[[`
[13:37:58.268]             `+` <- base::`+`
[13:37:58.268]             `<<-` <- base::`<<-`
[13:37:58.268]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:58.268]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:58.268]                   3L)]
[13:37:58.268]             }
[13:37:58.268]             function(cond) {
[13:37:58.268]                 is_error <- inherits(cond, "error")
[13:37:58.268]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:58.268]                   NULL)
[13:37:58.268]                 if (is_error) {
[13:37:58.268]                   sessionInformation <- function() {
[13:37:58.268]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:58.268]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:58.268]                       search = base::search(), system = base::Sys.info())
[13:37:58.268]                   }
[13:37:58.268]                   ...future.conditions[[length(...future.conditions) + 
[13:37:58.268]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:58.268]                     cond$call), session = sessionInformation(), 
[13:37:58.268]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:58.268]                   signalCondition(cond)
[13:37:58.268]                 }
[13:37:58.268]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:58.268]                 "immediateCondition"))) {
[13:37:58.268]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:58.268]                   ...future.conditions[[length(...future.conditions) + 
[13:37:58.268]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:58.268]                   if (TRUE && !signal) {
[13:37:58.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:58.268]                     {
[13:37:58.268]                       inherits <- base::inherits
[13:37:58.268]                       invokeRestart <- base::invokeRestart
[13:37:58.268]                       is.null <- base::is.null
[13:37:58.268]                       muffled <- FALSE
[13:37:58.268]                       if (inherits(cond, "message")) {
[13:37:58.268]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:58.268]                         if (muffled) 
[13:37:58.268]                           invokeRestart("muffleMessage")
[13:37:58.268]                       }
[13:37:58.268]                       else if (inherits(cond, "warning")) {
[13:37:58.268]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:58.268]                         if (muffled) 
[13:37:58.268]                           invokeRestart("muffleWarning")
[13:37:58.268]                       }
[13:37:58.268]                       else if (inherits(cond, "condition")) {
[13:37:58.268]                         if (!is.null(pattern)) {
[13:37:58.268]                           computeRestarts <- base::computeRestarts
[13:37:58.268]                           grepl <- base::grepl
[13:37:58.268]                           restarts <- computeRestarts(cond)
[13:37:58.268]                           for (restart in restarts) {
[13:37:58.268]                             name <- restart$name
[13:37:58.268]                             if (is.null(name)) 
[13:37:58.268]                               next
[13:37:58.268]                             if (!grepl(pattern, name)) 
[13:37:58.268]                               next
[13:37:58.268]                             invokeRestart(restart)
[13:37:58.268]                             muffled <- TRUE
[13:37:58.268]                             break
[13:37:58.268]                           }
[13:37:58.268]                         }
[13:37:58.268]                       }
[13:37:58.268]                       invisible(muffled)
[13:37:58.268]                     }
[13:37:58.268]                     muffleCondition(cond, pattern = "^muffle")
[13:37:58.268]                   }
[13:37:58.268]                 }
[13:37:58.268]                 else {
[13:37:58.268]                   if (TRUE) {
[13:37:58.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:58.268]                     {
[13:37:58.268]                       inherits <- base::inherits
[13:37:58.268]                       invokeRestart <- base::invokeRestart
[13:37:58.268]                       is.null <- base::is.null
[13:37:58.268]                       muffled <- FALSE
[13:37:58.268]                       if (inherits(cond, "message")) {
[13:37:58.268]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:58.268]                         if (muffled) 
[13:37:58.268]                           invokeRestart("muffleMessage")
[13:37:58.268]                       }
[13:37:58.268]                       else if (inherits(cond, "warning")) {
[13:37:58.268]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:58.268]                         if (muffled) 
[13:37:58.268]                           invokeRestart("muffleWarning")
[13:37:58.268]                       }
[13:37:58.268]                       else if (inherits(cond, "condition")) {
[13:37:58.268]                         if (!is.null(pattern)) {
[13:37:58.268]                           computeRestarts <- base::computeRestarts
[13:37:58.268]                           grepl <- base::grepl
[13:37:58.268]                           restarts <- computeRestarts(cond)
[13:37:58.268]                           for (restart in restarts) {
[13:37:58.268]                             name <- restart$name
[13:37:58.268]                             if (is.null(name)) 
[13:37:58.268]                               next
[13:37:58.268]                             if (!grepl(pattern, name)) 
[13:37:58.268]                               next
[13:37:58.268]                             invokeRestart(restart)
[13:37:58.268]                             muffled <- TRUE
[13:37:58.268]                             break
[13:37:58.268]                           }
[13:37:58.268]                         }
[13:37:58.268]                       }
[13:37:58.268]                       invisible(muffled)
[13:37:58.268]                     }
[13:37:58.268]                     muffleCondition(cond, pattern = "^muffle")
[13:37:58.268]                   }
[13:37:58.268]                 }
[13:37:58.268]             }
[13:37:58.268]         }))
[13:37:58.268]     }, error = function(ex) {
[13:37:58.268]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:58.268]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:58.268]                 ...future.rng), started = ...future.startTime, 
[13:37:58.268]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:58.268]             version = "1.8"), class = "FutureResult")
[13:37:58.268]     }, finally = {
[13:37:58.268]         if (!identical(...future.workdir, getwd())) 
[13:37:58.268]             setwd(...future.workdir)
[13:37:58.268]         {
[13:37:58.268]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:58.268]                 ...future.oldOptions$nwarnings <- NULL
[13:37:58.268]             }
[13:37:58.268]             base::options(...future.oldOptions)
[13:37:58.268]             if (.Platform$OS.type == "windows") {
[13:37:58.268]                 old_names <- names(...future.oldEnvVars)
[13:37:58.268]                 envs <- base::Sys.getenv()
[13:37:58.268]                 names <- names(envs)
[13:37:58.268]                 common <- intersect(names, old_names)
[13:37:58.268]                 added <- setdiff(names, old_names)
[13:37:58.268]                 removed <- setdiff(old_names, names)
[13:37:58.268]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:58.268]                   envs[common]]
[13:37:58.268]                 NAMES <- toupper(changed)
[13:37:58.268]                 args <- list()
[13:37:58.268]                 for (kk in seq_along(NAMES)) {
[13:37:58.268]                   name <- changed[[kk]]
[13:37:58.268]                   NAME <- NAMES[[kk]]
[13:37:58.268]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:58.268]                     next
[13:37:58.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:58.268]                 }
[13:37:58.268]                 NAMES <- toupper(added)
[13:37:58.268]                 for (kk in seq_along(NAMES)) {
[13:37:58.268]                   name <- added[[kk]]
[13:37:58.268]                   NAME <- NAMES[[kk]]
[13:37:58.268]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:58.268]                     next
[13:37:58.268]                   args[[name]] <- ""
[13:37:58.268]                 }
[13:37:58.268]                 NAMES <- toupper(removed)
[13:37:58.268]                 for (kk in seq_along(NAMES)) {
[13:37:58.268]                   name <- removed[[kk]]
[13:37:58.268]                   NAME <- NAMES[[kk]]
[13:37:58.268]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:58.268]                     next
[13:37:58.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:58.268]                 }
[13:37:58.268]                 if (length(args) > 0) 
[13:37:58.268]                   base::do.call(base::Sys.setenv, args = args)
[13:37:58.268]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:58.268]             }
[13:37:58.268]             else {
[13:37:58.268]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:58.268]             }
[13:37:58.268]             {
[13:37:58.268]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:58.268]                   0L) {
[13:37:58.268]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:58.268]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:58.268]                   base::options(opts)
[13:37:58.268]                 }
[13:37:58.268]                 {
[13:37:58.268]                   {
[13:37:58.268]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:58.268]                     NULL
[13:37:58.268]                   }
[13:37:58.268]                   options(future.plan = NULL)
[13:37:58.268]                   if (is.na(NA_character_)) 
[13:37:58.268]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:58.268]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:58.268]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:58.268]                     .init = FALSE)
[13:37:58.268]                 }
[13:37:58.268]             }
[13:37:58.268]         }
[13:37:58.268]     })
[13:37:58.268]     if (TRUE) {
[13:37:58.268]         base::sink(type = "output", split = FALSE)
[13:37:58.268]         if (TRUE) {
[13:37:58.268]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:58.268]         }
[13:37:58.268]         else {
[13:37:58.268]             ...future.result["stdout"] <- base::list(NULL)
[13:37:58.268]         }
[13:37:58.268]         base::close(...future.stdout)
[13:37:58.268]         ...future.stdout <- NULL
[13:37:58.268]     }
[13:37:58.268]     ...future.result$conditions <- ...future.conditions
[13:37:58.268]     ...future.result$finished <- base::Sys.time()
[13:37:58.268]     ...future.result
[13:37:58.268] }
[13:37:58.271] MultisessionFuture started
[13:37:58.271] - Launch lazy future ... done
[13:37:58.272] run() for ‘MultisessionFuture’ ... done
[13:37:58.273] receiveMessageFromWorker() for ClusterFuture ...
[13:37:58.274] - Validating connection of MultisessionFuture
[13:37:58.274] - received message: FutureResult
[13:37:58.274] - Received FutureResult
[13:37:58.274] - Erased future from FutureRegistry
[13:37:58.274] result() for ClusterFuture ...
[13:37:58.275] - result already collected: FutureResult
[13:37:58.275] result() for ClusterFuture ... done
[13:37:58.275] signalConditions() ...
[13:37:58.275]  - include = ‘immediateCondition’
[13:37:58.275]  - exclude = 
[13:37:58.275]  - resignal = FALSE
[13:37:58.275]  - Number of conditions: 1
[13:37:58.275] signalConditions() ... done
[13:37:58.275] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:58.275] A MultisessionFuture was resolved
[13:37:58.275] getGlobalsAndPackages() ...
[13:37:58.275] Searching for globals...
[13:37:58.276] - globals found: [2] ‘list’, ‘stop’
[13:37:58.276] Searching for globals ... DONE
[13:37:58.276] Resolving globals: FALSE
[13:37:58.277] 
[13:37:58.277] 
[13:37:58.277] getGlobalsAndPackages() ... DONE
[13:37:58.277] run() for ‘Future’ ...
[13:37:58.277] - state: ‘created’
[13:37:58.277] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:58.291] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:58.291] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:58.291]   - Field: ‘node’
[13:37:58.291]   - Field: ‘label’
[13:37:58.291]   - Field: ‘local’
[13:37:58.291]   - Field: ‘owner’
[13:37:58.291]   - Field: ‘envir’
[13:37:58.291]   - Field: ‘workers’
[13:37:58.292]   - Field: ‘packages’
[13:37:58.292]   - Field: ‘gc’
[13:37:58.292]   - Field: ‘conditions’
[13:37:58.292]   - Field: ‘persistent’
[13:37:58.292]   - Field: ‘expr’
[13:37:58.292]   - Field: ‘uuid’
[13:37:58.292]   - Field: ‘seed’
[13:37:58.292]   - Field: ‘version’
[13:37:58.292]   - Field: ‘result’
[13:37:58.292]   - Field: ‘asynchronous’
[13:37:58.292]   - Field: ‘calls’
[13:37:58.293]   - Field: ‘globals’
[13:37:58.293]   - Field: ‘stdout’
[13:37:58.293]   - Field: ‘earlySignal’
[13:37:58.293]   - Field: ‘lazy’
[13:37:58.293]   - Field: ‘state’
[13:37:58.293] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:58.293] - Launch lazy future ...
[13:37:58.293] Packages needed by the future expression (n = 0): <none>
[13:37:58.293] Packages needed by future strategies (n = 0): <none>
[13:37:58.294] {
[13:37:58.294]     {
[13:37:58.294]         {
[13:37:58.294]             ...future.startTime <- base::Sys.time()
[13:37:58.294]             {
[13:37:58.294]                 {
[13:37:58.294]                   {
[13:37:58.294]                     {
[13:37:58.294]                       base::local({
[13:37:58.294]                         has_future <- base::requireNamespace("future", 
[13:37:58.294]                           quietly = TRUE)
[13:37:58.294]                         if (has_future) {
[13:37:58.294]                           ns <- base::getNamespace("future")
[13:37:58.294]                           version <- ns[[".package"]][["version"]]
[13:37:58.294]                           if (is.null(version)) 
[13:37:58.294]                             version <- utils::packageVersion("future")
[13:37:58.294]                         }
[13:37:58.294]                         else {
[13:37:58.294]                           version <- NULL
[13:37:58.294]                         }
[13:37:58.294]                         if (!has_future || version < "1.8.0") {
[13:37:58.294]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:58.294]                             "", base::R.version$version.string), 
[13:37:58.294]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:58.294]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:58.294]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:58.294]                               "release", "version")], collapse = " "), 
[13:37:58.294]                             hostname = base::Sys.info()[["nodename"]])
[13:37:58.294]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:58.294]                             info)
[13:37:58.294]                           info <- base::paste(info, collapse = "; ")
[13:37:58.294]                           if (!has_future) {
[13:37:58.294]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:58.294]                               info)
[13:37:58.294]                           }
[13:37:58.294]                           else {
[13:37:58.294]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:58.294]                               info, version)
[13:37:58.294]                           }
[13:37:58.294]                           base::stop(msg)
[13:37:58.294]                         }
[13:37:58.294]                       })
[13:37:58.294]                     }
[13:37:58.294]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:58.294]                     base::options(mc.cores = 1L)
[13:37:58.294]                   }
[13:37:58.294]                   ...future.strategy.old <- future::plan("list")
[13:37:58.294]                   options(future.plan = NULL)
[13:37:58.294]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:58.294]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:58.294]                 }
[13:37:58.294]                 ...future.workdir <- getwd()
[13:37:58.294]             }
[13:37:58.294]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:58.294]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:58.294]         }
[13:37:58.294]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:58.294]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:58.294]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:58.294]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:58.294]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:58.294]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:58.294]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:58.294]             base::names(...future.oldOptions))
[13:37:58.294]     }
[13:37:58.294]     if (FALSE) {
[13:37:58.294]     }
[13:37:58.294]     else {
[13:37:58.294]         if (TRUE) {
[13:37:58.294]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:58.294]                 open = "w")
[13:37:58.294]         }
[13:37:58.294]         else {
[13:37:58.294]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:58.294]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:58.294]         }
[13:37:58.294]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:58.294]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:58.294]             base::sink(type = "output", split = FALSE)
[13:37:58.294]             base::close(...future.stdout)
[13:37:58.294]         }, add = TRUE)
[13:37:58.294]     }
[13:37:58.294]     ...future.frame <- base::sys.nframe()
[13:37:58.294]     ...future.conditions <- base::list()
[13:37:58.294]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:58.294]     if (FALSE) {
[13:37:58.294]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:58.294]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:58.294]     }
[13:37:58.294]     ...future.result <- base::tryCatch({
[13:37:58.294]         base::withCallingHandlers({
[13:37:58.294]             ...future.value <- base::withVisible(base::local({
[13:37:58.294]                 ...future.makeSendCondition <- base::local({
[13:37:58.294]                   sendCondition <- NULL
[13:37:58.294]                   function(frame = 1L) {
[13:37:58.294]                     if (is.function(sendCondition)) 
[13:37:58.294]                       return(sendCondition)
[13:37:58.294]                     ns <- getNamespace("parallel")
[13:37:58.294]                     if (exists("sendData", mode = "function", 
[13:37:58.294]                       envir = ns)) {
[13:37:58.294]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:58.294]                         envir = ns)
[13:37:58.294]                       envir <- sys.frame(frame)
[13:37:58.294]                       master <- NULL
[13:37:58.294]                       while (!identical(envir, .GlobalEnv) && 
[13:37:58.294]                         !identical(envir, emptyenv())) {
[13:37:58.294]                         if (exists("master", mode = "list", envir = envir, 
[13:37:58.294]                           inherits = FALSE)) {
[13:37:58.294]                           master <- get("master", mode = "list", 
[13:37:58.294]                             envir = envir, inherits = FALSE)
[13:37:58.294]                           if (inherits(master, c("SOCKnode", 
[13:37:58.294]                             "SOCK0node"))) {
[13:37:58.294]                             sendCondition <<- function(cond) {
[13:37:58.294]                               data <- list(type = "VALUE", value = cond, 
[13:37:58.294]                                 success = TRUE)
[13:37:58.294]                               parallel_sendData(master, data)
[13:37:58.294]                             }
[13:37:58.294]                             return(sendCondition)
[13:37:58.294]                           }
[13:37:58.294]                         }
[13:37:58.294]                         frame <- frame + 1L
[13:37:58.294]                         envir <- sys.frame(frame)
[13:37:58.294]                       }
[13:37:58.294]                     }
[13:37:58.294]                     sendCondition <<- function(cond) NULL
[13:37:58.294]                   }
[13:37:58.294]                 })
[13:37:58.294]                 withCallingHandlers({
[13:37:58.294]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:37:58.294]                 }, immediateCondition = function(cond) {
[13:37:58.294]                   sendCondition <- ...future.makeSendCondition()
[13:37:58.294]                   sendCondition(cond)
[13:37:58.294]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:58.294]                   {
[13:37:58.294]                     inherits <- base::inherits
[13:37:58.294]                     invokeRestart <- base::invokeRestart
[13:37:58.294]                     is.null <- base::is.null
[13:37:58.294]                     muffled <- FALSE
[13:37:58.294]                     if (inherits(cond, "message")) {
[13:37:58.294]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:58.294]                       if (muffled) 
[13:37:58.294]                         invokeRestart("muffleMessage")
[13:37:58.294]                     }
[13:37:58.294]                     else if (inherits(cond, "warning")) {
[13:37:58.294]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:58.294]                       if (muffled) 
[13:37:58.294]                         invokeRestart("muffleWarning")
[13:37:58.294]                     }
[13:37:58.294]                     else if (inherits(cond, "condition")) {
[13:37:58.294]                       if (!is.null(pattern)) {
[13:37:58.294]                         computeRestarts <- base::computeRestarts
[13:37:58.294]                         grepl <- base::grepl
[13:37:58.294]                         restarts <- computeRestarts(cond)
[13:37:58.294]                         for (restart in restarts) {
[13:37:58.294]                           name <- restart$name
[13:37:58.294]                           if (is.null(name)) 
[13:37:58.294]                             next
[13:37:58.294]                           if (!grepl(pattern, name)) 
[13:37:58.294]                             next
[13:37:58.294]                           invokeRestart(restart)
[13:37:58.294]                           muffled <- TRUE
[13:37:58.294]                           break
[13:37:58.294]                         }
[13:37:58.294]                       }
[13:37:58.294]                     }
[13:37:58.294]                     invisible(muffled)
[13:37:58.294]                   }
[13:37:58.294]                   muffleCondition(cond)
[13:37:58.294]                 })
[13:37:58.294]             }))
[13:37:58.294]             future::FutureResult(value = ...future.value$value, 
[13:37:58.294]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:58.294]                   ...future.rng), globalenv = if (FALSE) 
[13:37:58.294]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:58.294]                     ...future.globalenv.names))
[13:37:58.294]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:58.294]         }, condition = base::local({
[13:37:58.294]             c <- base::c
[13:37:58.294]             inherits <- base::inherits
[13:37:58.294]             invokeRestart <- base::invokeRestart
[13:37:58.294]             length <- base::length
[13:37:58.294]             list <- base::list
[13:37:58.294]             seq.int <- base::seq.int
[13:37:58.294]             signalCondition <- base::signalCondition
[13:37:58.294]             sys.calls <- base::sys.calls
[13:37:58.294]             `[[` <- base::`[[`
[13:37:58.294]             `+` <- base::`+`
[13:37:58.294]             `<<-` <- base::`<<-`
[13:37:58.294]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:58.294]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:58.294]                   3L)]
[13:37:58.294]             }
[13:37:58.294]             function(cond) {
[13:37:58.294]                 is_error <- inherits(cond, "error")
[13:37:58.294]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:58.294]                   NULL)
[13:37:58.294]                 if (is_error) {
[13:37:58.294]                   sessionInformation <- function() {
[13:37:58.294]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:58.294]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:58.294]                       search = base::search(), system = base::Sys.info())
[13:37:58.294]                   }
[13:37:58.294]                   ...future.conditions[[length(...future.conditions) + 
[13:37:58.294]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:58.294]                     cond$call), session = sessionInformation(), 
[13:37:58.294]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:58.294]                   signalCondition(cond)
[13:37:58.294]                 }
[13:37:58.294]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:58.294]                 "immediateCondition"))) {
[13:37:58.294]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:58.294]                   ...future.conditions[[length(...future.conditions) + 
[13:37:58.294]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:58.294]                   if (TRUE && !signal) {
[13:37:58.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:58.294]                     {
[13:37:58.294]                       inherits <- base::inherits
[13:37:58.294]                       invokeRestart <- base::invokeRestart
[13:37:58.294]                       is.null <- base::is.null
[13:37:58.294]                       muffled <- FALSE
[13:37:58.294]                       if (inherits(cond, "message")) {
[13:37:58.294]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:58.294]                         if (muffled) 
[13:37:58.294]                           invokeRestart("muffleMessage")
[13:37:58.294]                       }
[13:37:58.294]                       else if (inherits(cond, "warning")) {
[13:37:58.294]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:58.294]                         if (muffled) 
[13:37:58.294]                           invokeRestart("muffleWarning")
[13:37:58.294]                       }
[13:37:58.294]                       else if (inherits(cond, "condition")) {
[13:37:58.294]                         if (!is.null(pattern)) {
[13:37:58.294]                           computeRestarts <- base::computeRestarts
[13:37:58.294]                           grepl <- base::grepl
[13:37:58.294]                           restarts <- computeRestarts(cond)
[13:37:58.294]                           for (restart in restarts) {
[13:37:58.294]                             name <- restart$name
[13:37:58.294]                             if (is.null(name)) 
[13:37:58.294]                               next
[13:37:58.294]                             if (!grepl(pattern, name)) 
[13:37:58.294]                               next
[13:37:58.294]                             invokeRestart(restart)
[13:37:58.294]                             muffled <- TRUE
[13:37:58.294]                             break
[13:37:58.294]                           }
[13:37:58.294]                         }
[13:37:58.294]                       }
[13:37:58.294]                       invisible(muffled)
[13:37:58.294]                     }
[13:37:58.294]                     muffleCondition(cond, pattern = "^muffle")
[13:37:58.294]                   }
[13:37:58.294]                 }
[13:37:58.294]                 else {
[13:37:58.294]                   if (TRUE) {
[13:37:58.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:58.294]                     {
[13:37:58.294]                       inherits <- base::inherits
[13:37:58.294]                       invokeRestart <- base::invokeRestart
[13:37:58.294]                       is.null <- base::is.null
[13:37:58.294]                       muffled <- FALSE
[13:37:58.294]                       if (inherits(cond, "message")) {
[13:37:58.294]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:58.294]                         if (muffled) 
[13:37:58.294]                           invokeRestart("muffleMessage")
[13:37:58.294]                       }
[13:37:58.294]                       else if (inherits(cond, "warning")) {
[13:37:58.294]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:58.294]                         if (muffled) 
[13:37:58.294]                           invokeRestart("muffleWarning")
[13:37:58.294]                       }
[13:37:58.294]                       else if (inherits(cond, "condition")) {
[13:37:58.294]                         if (!is.null(pattern)) {
[13:37:58.294]                           computeRestarts <- base::computeRestarts
[13:37:58.294]                           grepl <- base::grepl
[13:37:58.294]                           restarts <- computeRestarts(cond)
[13:37:58.294]                           for (restart in restarts) {
[13:37:58.294]                             name <- restart$name
[13:37:58.294]                             if (is.null(name)) 
[13:37:58.294]                               next
[13:37:58.294]                             if (!grepl(pattern, name)) 
[13:37:58.294]                               next
[13:37:58.294]                             invokeRestart(restart)
[13:37:58.294]                             muffled <- TRUE
[13:37:58.294]                             break
[13:37:58.294]                           }
[13:37:58.294]                         }
[13:37:58.294]                       }
[13:37:58.294]                       invisible(muffled)
[13:37:58.294]                     }
[13:37:58.294]                     muffleCondition(cond, pattern = "^muffle")
[13:37:58.294]                   }
[13:37:58.294]                 }
[13:37:58.294]             }
[13:37:58.294]         }))
[13:37:58.294]     }, error = function(ex) {
[13:37:58.294]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:58.294]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:58.294]                 ...future.rng), started = ...future.startTime, 
[13:37:58.294]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:58.294]             version = "1.8"), class = "FutureResult")
[13:37:58.294]     }, finally = {
[13:37:58.294]         if (!identical(...future.workdir, getwd())) 
[13:37:58.294]             setwd(...future.workdir)
[13:37:58.294]         {
[13:37:58.294]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:58.294]                 ...future.oldOptions$nwarnings <- NULL
[13:37:58.294]             }
[13:37:58.294]             base::options(...future.oldOptions)
[13:37:58.294]             if (.Platform$OS.type == "windows") {
[13:37:58.294]                 old_names <- names(...future.oldEnvVars)
[13:37:58.294]                 envs <- base::Sys.getenv()
[13:37:58.294]                 names <- names(envs)
[13:37:58.294]                 common <- intersect(names, old_names)
[13:37:58.294]                 added <- setdiff(names, old_names)
[13:37:58.294]                 removed <- setdiff(old_names, names)
[13:37:58.294]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:58.294]                   envs[common]]
[13:37:58.294]                 NAMES <- toupper(changed)
[13:37:58.294]                 args <- list()
[13:37:58.294]                 for (kk in seq_along(NAMES)) {
[13:37:58.294]                   name <- changed[[kk]]
[13:37:58.294]                   NAME <- NAMES[[kk]]
[13:37:58.294]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:58.294]                     next
[13:37:58.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:58.294]                 }
[13:37:58.294]                 NAMES <- toupper(added)
[13:37:58.294]                 for (kk in seq_along(NAMES)) {
[13:37:58.294]                   name <- added[[kk]]
[13:37:58.294]                   NAME <- NAMES[[kk]]
[13:37:58.294]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:58.294]                     next
[13:37:58.294]                   args[[name]] <- ""
[13:37:58.294]                 }
[13:37:58.294]                 NAMES <- toupper(removed)
[13:37:58.294]                 for (kk in seq_along(NAMES)) {
[13:37:58.294]                   name <- removed[[kk]]
[13:37:58.294]                   NAME <- NAMES[[kk]]
[13:37:58.294]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:58.294]                     next
[13:37:58.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:58.294]                 }
[13:37:58.294]                 if (length(args) > 0) 
[13:37:58.294]                   base::do.call(base::Sys.setenv, args = args)
[13:37:58.294]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:58.294]             }
[13:37:58.294]             else {
[13:37:58.294]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:58.294]             }
[13:37:58.294]             {
[13:37:58.294]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:58.294]                   0L) {
[13:37:58.294]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:58.294]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:58.294]                   base::options(opts)
[13:37:58.294]                 }
[13:37:58.294]                 {
[13:37:58.294]                   {
[13:37:58.294]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:58.294]                     NULL
[13:37:58.294]                   }
[13:37:58.294]                   options(future.plan = NULL)
[13:37:58.294]                   if (is.na(NA_character_)) 
[13:37:58.294]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:58.294]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:58.294]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:58.294]                     .init = FALSE)
[13:37:58.294]                 }
[13:37:58.294]             }
[13:37:58.294]         }
[13:37:58.294]     })
[13:37:58.294]     if (TRUE) {
[13:37:58.294]         base::sink(type = "output", split = FALSE)
[13:37:58.294]         if (TRUE) {
[13:37:58.294]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:58.294]         }
[13:37:58.294]         else {
[13:37:58.294]             ...future.result["stdout"] <- base::list(NULL)
[13:37:58.294]         }
[13:37:58.294]         base::close(...future.stdout)
[13:37:58.294]         ...future.stdout <- NULL
[13:37:58.294]     }
[13:37:58.294]     ...future.result$conditions <- ...future.conditions
[13:37:58.294]     ...future.result$finished <- base::Sys.time()
[13:37:58.294]     ...future.result
[13:37:58.294] }
[13:37:58.297] MultisessionFuture started
[13:37:58.297] - Launch lazy future ... done
[13:37:58.297] run() for ‘MultisessionFuture’ ... done
[13:37:58.299] receiveMessageFromWorker() for ClusterFuture ...
[13:37:58.299] - Validating connection of MultisessionFuture
[13:37:58.299] - received message: FutureResult
[13:37:58.299] - Received FutureResult
[13:37:58.300] - Erased future from FutureRegistry
[13:37:58.300] result() for ClusterFuture ...
[13:37:58.300] - result already collected: FutureResult
[13:37:58.300] result() for ClusterFuture ... done
[13:37:58.300] signalConditions() ...
[13:37:58.300]  - include = ‘immediateCondition’
[13:37:58.300]  - exclude = 
[13:37:58.300]  - resignal = FALSE
[13:37:58.300]  - Number of conditions: 1
[13:37:58.300] signalConditions() ... done
[13:37:58.300] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:58.301] A MultisessionFuture was resolved
- result = TRUE, recursive = 1 ... DONE
- result = TRUE, recursive = 2 ...
[13:37:58.301] getGlobalsAndPackages() ...
[13:37:58.301] Searching for globals...
[13:37:58.302] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:37:58.302] Searching for globals ... DONE
[13:37:58.302] Resolving globals: FALSE
[13:37:58.303] 
[13:37:58.303] 
[13:37:58.303] getGlobalsAndPackages() ... DONE
[13:37:58.303] run() for ‘Future’ ...
[13:37:58.303] - state: ‘created’
[13:37:58.303] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:58.319] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:58.319] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:58.319]   - Field: ‘node’
[13:37:58.319]   - Field: ‘label’
[13:37:58.320]   - Field: ‘local’
[13:37:58.320]   - Field: ‘owner’
[13:37:58.320]   - Field: ‘envir’
[13:37:58.320]   - Field: ‘workers’
[13:37:58.320]   - Field: ‘packages’
[13:37:58.320]   - Field: ‘gc’
[13:37:58.320]   - Field: ‘conditions’
[13:37:58.320]   - Field: ‘persistent’
[13:37:58.320]   - Field: ‘expr’
[13:37:58.320]   - Field: ‘uuid’
[13:37:58.320]   - Field: ‘seed’
[13:37:58.321]   - Field: ‘version’
[13:37:58.321]   - Field: ‘result’
[13:37:58.321]   - Field: ‘asynchronous’
[13:37:58.321]   - Field: ‘calls’
[13:37:58.321]   - Field: ‘globals’
[13:37:58.321]   - Field: ‘stdout’
[13:37:58.321]   - Field: ‘earlySignal’
[13:37:58.321]   - Field: ‘lazy’
[13:37:58.321]   - Field: ‘state’
[13:37:58.321] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:58.321] - Launch lazy future ...
[13:37:58.322] Packages needed by the future expression (n = 0): <none>
[13:37:58.322] Packages needed by future strategies (n = 0): <none>
[13:37:58.322] {
[13:37:58.322]     {
[13:37:58.322]         {
[13:37:58.322]             ...future.startTime <- base::Sys.time()
[13:37:58.322]             {
[13:37:58.322]                 {
[13:37:58.322]                   {
[13:37:58.322]                     {
[13:37:58.322]                       base::local({
[13:37:58.322]                         has_future <- base::requireNamespace("future", 
[13:37:58.322]                           quietly = TRUE)
[13:37:58.322]                         if (has_future) {
[13:37:58.322]                           ns <- base::getNamespace("future")
[13:37:58.322]                           version <- ns[[".package"]][["version"]]
[13:37:58.322]                           if (is.null(version)) 
[13:37:58.322]                             version <- utils::packageVersion("future")
[13:37:58.322]                         }
[13:37:58.322]                         else {
[13:37:58.322]                           version <- NULL
[13:37:58.322]                         }
[13:37:58.322]                         if (!has_future || version < "1.8.0") {
[13:37:58.322]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:58.322]                             "", base::R.version$version.string), 
[13:37:58.322]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:58.322]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:58.322]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:58.322]                               "release", "version")], collapse = " "), 
[13:37:58.322]                             hostname = base::Sys.info()[["nodename"]])
[13:37:58.322]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:58.322]                             info)
[13:37:58.322]                           info <- base::paste(info, collapse = "; ")
[13:37:58.322]                           if (!has_future) {
[13:37:58.322]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:58.322]                               info)
[13:37:58.322]                           }
[13:37:58.322]                           else {
[13:37:58.322]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:58.322]                               info, version)
[13:37:58.322]                           }
[13:37:58.322]                           base::stop(msg)
[13:37:58.322]                         }
[13:37:58.322]                       })
[13:37:58.322]                     }
[13:37:58.322]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:58.322]                     base::options(mc.cores = 1L)
[13:37:58.322]                   }
[13:37:58.322]                   ...future.strategy.old <- future::plan("list")
[13:37:58.322]                   options(future.plan = NULL)
[13:37:58.322]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:58.322]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:58.322]                 }
[13:37:58.322]                 ...future.workdir <- getwd()
[13:37:58.322]             }
[13:37:58.322]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:58.322]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:58.322]         }
[13:37:58.322]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:58.322]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:58.322]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:58.322]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:58.322]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:58.322]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:58.322]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:58.322]             base::names(...future.oldOptions))
[13:37:58.322]     }
[13:37:58.322]     if (FALSE) {
[13:37:58.322]     }
[13:37:58.322]     else {
[13:37:58.322]         if (TRUE) {
[13:37:58.322]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:58.322]                 open = "w")
[13:37:58.322]         }
[13:37:58.322]         else {
[13:37:58.322]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:58.322]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:58.322]         }
[13:37:58.322]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:58.322]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:58.322]             base::sink(type = "output", split = FALSE)
[13:37:58.322]             base::close(...future.stdout)
[13:37:58.322]         }, add = TRUE)
[13:37:58.322]     }
[13:37:58.322]     ...future.frame <- base::sys.nframe()
[13:37:58.322]     ...future.conditions <- base::list()
[13:37:58.322]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:58.322]     if (FALSE) {
[13:37:58.322]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:58.322]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:58.322]     }
[13:37:58.322]     ...future.result <- base::tryCatch({
[13:37:58.322]         base::withCallingHandlers({
[13:37:58.322]             ...future.value <- base::withVisible(base::local({
[13:37:58.322]                 ...future.makeSendCondition <- base::local({
[13:37:58.322]                   sendCondition <- NULL
[13:37:58.322]                   function(frame = 1L) {
[13:37:58.322]                     if (is.function(sendCondition)) 
[13:37:58.322]                       return(sendCondition)
[13:37:58.322]                     ns <- getNamespace("parallel")
[13:37:58.322]                     if (exists("sendData", mode = "function", 
[13:37:58.322]                       envir = ns)) {
[13:37:58.322]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:58.322]                         envir = ns)
[13:37:58.322]                       envir <- sys.frame(frame)
[13:37:58.322]                       master <- NULL
[13:37:58.322]                       while (!identical(envir, .GlobalEnv) && 
[13:37:58.322]                         !identical(envir, emptyenv())) {
[13:37:58.322]                         if (exists("master", mode = "list", envir = envir, 
[13:37:58.322]                           inherits = FALSE)) {
[13:37:58.322]                           master <- get("master", mode = "list", 
[13:37:58.322]                             envir = envir, inherits = FALSE)
[13:37:58.322]                           if (inherits(master, c("SOCKnode", 
[13:37:58.322]                             "SOCK0node"))) {
[13:37:58.322]                             sendCondition <<- function(cond) {
[13:37:58.322]                               data <- list(type = "VALUE", value = cond, 
[13:37:58.322]                                 success = TRUE)
[13:37:58.322]                               parallel_sendData(master, data)
[13:37:58.322]                             }
[13:37:58.322]                             return(sendCondition)
[13:37:58.322]                           }
[13:37:58.322]                         }
[13:37:58.322]                         frame <- frame + 1L
[13:37:58.322]                         envir <- sys.frame(frame)
[13:37:58.322]                       }
[13:37:58.322]                     }
[13:37:58.322]                     sendCondition <<- function(cond) NULL
[13:37:58.322]                   }
[13:37:58.322]                 })
[13:37:58.322]                 withCallingHandlers({
[13:37:58.322]                   {
[13:37:58.322]                     Sys.sleep(0.5)
[13:37:58.322]                     list(a = 1, b = 42L)
[13:37:58.322]                   }
[13:37:58.322]                 }, immediateCondition = function(cond) {
[13:37:58.322]                   sendCondition <- ...future.makeSendCondition()
[13:37:58.322]                   sendCondition(cond)
[13:37:58.322]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:58.322]                   {
[13:37:58.322]                     inherits <- base::inherits
[13:37:58.322]                     invokeRestart <- base::invokeRestart
[13:37:58.322]                     is.null <- base::is.null
[13:37:58.322]                     muffled <- FALSE
[13:37:58.322]                     if (inherits(cond, "message")) {
[13:37:58.322]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:58.322]                       if (muffled) 
[13:37:58.322]                         invokeRestart("muffleMessage")
[13:37:58.322]                     }
[13:37:58.322]                     else if (inherits(cond, "warning")) {
[13:37:58.322]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:58.322]                       if (muffled) 
[13:37:58.322]                         invokeRestart("muffleWarning")
[13:37:58.322]                     }
[13:37:58.322]                     else if (inherits(cond, "condition")) {
[13:37:58.322]                       if (!is.null(pattern)) {
[13:37:58.322]                         computeRestarts <- base::computeRestarts
[13:37:58.322]                         grepl <- base::grepl
[13:37:58.322]                         restarts <- computeRestarts(cond)
[13:37:58.322]                         for (restart in restarts) {
[13:37:58.322]                           name <- restart$name
[13:37:58.322]                           if (is.null(name)) 
[13:37:58.322]                             next
[13:37:58.322]                           if (!grepl(pattern, name)) 
[13:37:58.322]                             next
[13:37:58.322]                           invokeRestart(restart)
[13:37:58.322]                           muffled <- TRUE
[13:37:58.322]                           break
[13:37:58.322]                         }
[13:37:58.322]                       }
[13:37:58.322]                     }
[13:37:58.322]                     invisible(muffled)
[13:37:58.322]                   }
[13:37:58.322]                   muffleCondition(cond)
[13:37:58.322]                 })
[13:37:58.322]             }))
[13:37:58.322]             future::FutureResult(value = ...future.value$value, 
[13:37:58.322]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:58.322]                   ...future.rng), globalenv = if (FALSE) 
[13:37:58.322]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:58.322]                     ...future.globalenv.names))
[13:37:58.322]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:58.322]         }, condition = base::local({
[13:37:58.322]             c <- base::c
[13:37:58.322]             inherits <- base::inherits
[13:37:58.322]             invokeRestart <- base::invokeRestart
[13:37:58.322]             length <- base::length
[13:37:58.322]             list <- base::list
[13:37:58.322]             seq.int <- base::seq.int
[13:37:58.322]             signalCondition <- base::signalCondition
[13:37:58.322]             sys.calls <- base::sys.calls
[13:37:58.322]             `[[` <- base::`[[`
[13:37:58.322]             `+` <- base::`+`
[13:37:58.322]             `<<-` <- base::`<<-`
[13:37:58.322]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:58.322]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:58.322]                   3L)]
[13:37:58.322]             }
[13:37:58.322]             function(cond) {
[13:37:58.322]                 is_error <- inherits(cond, "error")
[13:37:58.322]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:58.322]                   NULL)
[13:37:58.322]                 if (is_error) {
[13:37:58.322]                   sessionInformation <- function() {
[13:37:58.322]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:58.322]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:58.322]                       search = base::search(), system = base::Sys.info())
[13:37:58.322]                   }
[13:37:58.322]                   ...future.conditions[[length(...future.conditions) + 
[13:37:58.322]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:58.322]                     cond$call), session = sessionInformation(), 
[13:37:58.322]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:58.322]                   signalCondition(cond)
[13:37:58.322]                 }
[13:37:58.322]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:58.322]                 "immediateCondition"))) {
[13:37:58.322]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:58.322]                   ...future.conditions[[length(...future.conditions) + 
[13:37:58.322]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:58.322]                   if (TRUE && !signal) {
[13:37:58.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:58.322]                     {
[13:37:58.322]                       inherits <- base::inherits
[13:37:58.322]                       invokeRestart <- base::invokeRestart
[13:37:58.322]                       is.null <- base::is.null
[13:37:58.322]                       muffled <- FALSE
[13:37:58.322]                       if (inherits(cond, "message")) {
[13:37:58.322]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:58.322]                         if (muffled) 
[13:37:58.322]                           invokeRestart("muffleMessage")
[13:37:58.322]                       }
[13:37:58.322]                       else if (inherits(cond, "warning")) {
[13:37:58.322]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:58.322]                         if (muffled) 
[13:37:58.322]                           invokeRestart("muffleWarning")
[13:37:58.322]                       }
[13:37:58.322]                       else if (inherits(cond, "condition")) {
[13:37:58.322]                         if (!is.null(pattern)) {
[13:37:58.322]                           computeRestarts <- base::computeRestarts
[13:37:58.322]                           grepl <- base::grepl
[13:37:58.322]                           restarts <- computeRestarts(cond)
[13:37:58.322]                           for (restart in restarts) {
[13:37:58.322]                             name <- restart$name
[13:37:58.322]                             if (is.null(name)) 
[13:37:58.322]                               next
[13:37:58.322]                             if (!grepl(pattern, name)) 
[13:37:58.322]                               next
[13:37:58.322]                             invokeRestart(restart)
[13:37:58.322]                             muffled <- TRUE
[13:37:58.322]                             break
[13:37:58.322]                           }
[13:37:58.322]                         }
[13:37:58.322]                       }
[13:37:58.322]                       invisible(muffled)
[13:37:58.322]                     }
[13:37:58.322]                     muffleCondition(cond, pattern = "^muffle")
[13:37:58.322]                   }
[13:37:58.322]                 }
[13:37:58.322]                 else {
[13:37:58.322]                   if (TRUE) {
[13:37:58.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:58.322]                     {
[13:37:58.322]                       inherits <- base::inherits
[13:37:58.322]                       invokeRestart <- base::invokeRestart
[13:37:58.322]                       is.null <- base::is.null
[13:37:58.322]                       muffled <- FALSE
[13:37:58.322]                       if (inherits(cond, "message")) {
[13:37:58.322]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:58.322]                         if (muffled) 
[13:37:58.322]                           invokeRestart("muffleMessage")
[13:37:58.322]                       }
[13:37:58.322]                       else if (inherits(cond, "warning")) {
[13:37:58.322]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:58.322]                         if (muffled) 
[13:37:58.322]                           invokeRestart("muffleWarning")
[13:37:58.322]                       }
[13:37:58.322]                       else if (inherits(cond, "condition")) {
[13:37:58.322]                         if (!is.null(pattern)) {
[13:37:58.322]                           computeRestarts <- base::computeRestarts
[13:37:58.322]                           grepl <- base::grepl
[13:37:58.322]                           restarts <- computeRestarts(cond)
[13:37:58.322]                           for (restart in restarts) {
[13:37:58.322]                             name <- restart$name
[13:37:58.322]                             if (is.null(name)) 
[13:37:58.322]                               next
[13:37:58.322]                             if (!grepl(pattern, name)) 
[13:37:58.322]                               next
[13:37:58.322]                             invokeRestart(restart)
[13:37:58.322]                             muffled <- TRUE
[13:37:58.322]                             break
[13:37:58.322]                           }
[13:37:58.322]                         }
[13:37:58.322]                       }
[13:37:58.322]                       invisible(muffled)
[13:37:58.322]                     }
[13:37:58.322]                     muffleCondition(cond, pattern = "^muffle")
[13:37:58.322]                   }
[13:37:58.322]                 }
[13:37:58.322]             }
[13:37:58.322]         }))
[13:37:58.322]     }, error = function(ex) {
[13:37:58.322]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:58.322]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:58.322]                 ...future.rng), started = ...future.startTime, 
[13:37:58.322]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:58.322]             version = "1.8"), class = "FutureResult")
[13:37:58.322]     }, finally = {
[13:37:58.322]         if (!identical(...future.workdir, getwd())) 
[13:37:58.322]             setwd(...future.workdir)
[13:37:58.322]         {
[13:37:58.322]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:58.322]                 ...future.oldOptions$nwarnings <- NULL
[13:37:58.322]             }
[13:37:58.322]             base::options(...future.oldOptions)
[13:37:58.322]             if (.Platform$OS.type == "windows") {
[13:37:58.322]                 old_names <- names(...future.oldEnvVars)
[13:37:58.322]                 envs <- base::Sys.getenv()
[13:37:58.322]                 names <- names(envs)
[13:37:58.322]                 common <- intersect(names, old_names)
[13:37:58.322]                 added <- setdiff(names, old_names)
[13:37:58.322]                 removed <- setdiff(old_names, names)
[13:37:58.322]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:58.322]                   envs[common]]
[13:37:58.322]                 NAMES <- toupper(changed)
[13:37:58.322]                 args <- list()
[13:37:58.322]                 for (kk in seq_along(NAMES)) {
[13:37:58.322]                   name <- changed[[kk]]
[13:37:58.322]                   NAME <- NAMES[[kk]]
[13:37:58.322]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:58.322]                     next
[13:37:58.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:58.322]                 }
[13:37:58.322]                 NAMES <- toupper(added)
[13:37:58.322]                 for (kk in seq_along(NAMES)) {
[13:37:58.322]                   name <- added[[kk]]
[13:37:58.322]                   NAME <- NAMES[[kk]]
[13:37:58.322]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:58.322]                     next
[13:37:58.322]                   args[[name]] <- ""
[13:37:58.322]                 }
[13:37:58.322]                 NAMES <- toupper(removed)
[13:37:58.322]                 for (kk in seq_along(NAMES)) {
[13:37:58.322]                   name <- removed[[kk]]
[13:37:58.322]                   NAME <- NAMES[[kk]]
[13:37:58.322]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:58.322]                     next
[13:37:58.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:58.322]                 }
[13:37:58.322]                 if (length(args) > 0) 
[13:37:58.322]                   base::do.call(base::Sys.setenv, args = args)
[13:37:58.322]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:58.322]             }
[13:37:58.322]             else {
[13:37:58.322]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:58.322]             }
[13:37:58.322]             {
[13:37:58.322]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:58.322]                   0L) {
[13:37:58.322]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:58.322]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:58.322]                   base::options(opts)
[13:37:58.322]                 }
[13:37:58.322]                 {
[13:37:58.322]                   {
[13:37:58.322]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:58.322]                     NULL
[13:37:58.322]                   }
[13:37:58.322]                   options(future.plan = NULL)
[13:37:58.322]                   if (is.na(NA_character_)) 
[13:37:58.322]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:58.322]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:58.322]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:58.322]                     .init = FALSE)
[13:37:58.322]                 }
[13:37:58.322]             }
[13:37:58.322]         }
[13:37:58.322]     })
[13:37:58.322]     if (TRUE) {
[13:37:58.322]         base::sink(type = "output", split = FALSE)
[13:37:58.322]         if (TRUE) {
[13:37:58.322]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:58.322]         }
[13:37:58.322]         else {
[13:37:58.322]             ...future.result["stdout"] <- base::list(NULL)
[13:37:58.322]         }
[13:37:58.322]         base::close(...future.stdout)
[13:37:58.322]         ...future.stdout <- NULL
[13:37:58.322]     }
[13:37:58.322]     ...future.result$conditions <- ...future.conditions
[13:37:58.322]     ...future.result$finished <- base::Sys.time()
[13:37:58.322]     ...future.result
[13:37:58.322] }
[13:37:58.325] MultisessionFuture started
[13:37:58.325] - Launch lazy future ... done
[13:37:58.325] run() for ‘MultisessionFuture’ ... done
[13:37:58.827] receiveMessageFromWorker() for ClusterFuture ...
[13:37:58.828] - Validating connection of MultisessionFuture
[13:37:58.828] - received message: FutureResult
[13:37:58.828] - Received FutureResult
[13:37:58.828] - Erased future from FutureRegistry
[13:37:58.828] result() for ClusterFuture ...
[13:37:58.828] - result already collected: FutureResult
[13:37:58.828] result() for ClusterFuture ... done
[13:37:58.828] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:58.829] resolve() on list ...
[13:37:58.829]  recursive: 1
[13:37:58.829]  length: 2
[13:37:58.829]  elements: ‘a’, ‘b’
[13:37:58.829]  length: 1 (resolved future 1)
[13:37:58.829]  length: 0 (resolved future 2)
[13:37:58.829] resolve() on list ... DONE
[13:37:58.829] A MultisessionFuture was resolved (and resolved itself)
[13:37:58.829] getGlobalsAndPackages() ...
[13:37:58.829] Searching for globals...
[13:37:58.831] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:37:58.831] Searching for globals ... DONE
[13:37:58.831] Resolving globals: FALSE
[13:37:58.831] 
[13:37:58.831] 
[13:37:58.831] getGlobalsAndPackages() ... DONE
[13:37:58.832] run() for ‘Future’ ...
[13:37:58.832] - state: ‘created’
[13:37:58.832] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:58.846] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:58.846] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:58.846]   - Field: ‘node’
[13:37:58.846]   - Field: ‘label’
[13:37:58.846]   - Field: ‘local’
[13:37:58.846]   - Field: ‘owner’
[13:37:58.846]   - Field: ‘envir’
[13:37:58.847]   - Field: ‘workers’
[13:37:58.847]   - Field: ‘packages’
[13:37:58.847]   - Field: ‘gc’
[13:37:58.847]   - Field: ‘conditions’
[13:37:58.847]   - Field: ‘persistent’
[13:37:58.847]   - Field: ‘expr’
[13:37:58.847]   - Field: ‘uuid’
[13:37:58.847]   - Field: ‘seed’
[13:37:58.847]   - Field: ‘version’
[13:37:58.847]   - Field: ‘result’
[13:37:58.847]   - Field: ‘asynchronous’
[13:37:58.848]   - Field: ‘calls’
[13:37:58.848]   - Field: ‘globals’
[13:37:58.848]   - Field: ‘stdout’
[13:37:58.848]   - Field: ‘earlySignal’
[13:37:58.848]   - Field: ‘lazy’
[13:37:58.848]   - Field: ‘state’
[13:37:58.848] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:58.848] - Launch lazy future ...
[13:37:58.848] Packages needed by the future expression (n = 0): <none>
[13:37:58.849] Packages needed by future strategies (n = 0): <none>
[13:37:58.849] {
[13:37:58.849]     {
[13:37:58.849]         {
[13:37:58.849]             ...future.startTime <- base::Sys.time()
[13:37:58.849]             {
[13:37:58.849]                 {
[13:37:58.849]                   {
[13:37:58.849]                     {
[13:37:58.849]                       base::local({
[13:37:58.849]                         has_future <- base::requireNamespace("future", 
[13:37:58.849]                           quietly = TRUE)
[13:37:58.849]                         if (has_future) {
[13:37:58.849]                           ns <- base::getNamespace("future")
[13:37:58.849]                           version <- ns[[".package"]][["version"]]
[13:37:58.849]                           if (is.null(version)) 
[13:37:58.849]                             version <- utils::packageVersion("future")
[13:37:58.849]                         }
[13:37:58.849]                         else {
[13:37:58.849]                           version <- NULL
[13:37:58.849]                         }
[13:37:58.849]                         if (!has_future || version < "1.8.0") {
[13:37:58.849]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:58.849]                             "", base::R.version$version.string), 
[13:37:58.849]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:58.849]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:58.849]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:58.849]                               "release", "version")], collapse = " "), 
[13:37:58.849]                             hostname = base::Sys.info()[["nodename"]])
[13:37:58.849]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:58.849]                             info)
[13:37:58.849]                           info <- base::paste(info, collapse = "; ")
[13:37:58.849]                           if (!has_future) {
[13:37:58.849]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:58.849]                               info)
[13:37:58.849]                           }
[13:37:58.849]                           else {
[13:37:58.849]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:58.849]                               info, version)
[13:37:58.849]                           }
[13:37:58.849]                           base::stop(msg)
[13:37:58.849]                         }
[13:37:58.849]                       })
[13:37:58.849]                     }
[13:37:58.849]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:58.849]                     base::options(mc.cores = 1L)
[13:37:58.849]                   }
[13:37:58.849]                   ...future.strategy.old <- future::plan("list")
[13:37:58.849]                   options(future.plan = NULL)
[13:37:58.849]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:58.849]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:58.849]                 }
[13:37:58.849]                 ...future.workdir <- getwd()
[13:37:58.849]             }
[13:37:58.849]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:58.849]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:58.849]         }
[13:37:58.849]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:58.849]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:58.849]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:58.849]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:58.849]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:58.849]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:58.849]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:58.849]             base::names(...future.oldOptions))
[13:37:58.849]     }
[13:37:58.849]     if (FALSE) {
[13:37:58.849]     }
[13:37:58.849]     else {
[13:37:58.849]         if (TRUE) {
[13:37:58.849]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:58.849]                 open = "w")
[13:37:58.849]         }
[13:37:58.849]         else {
[13:37:58.849]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:58.849]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:58.849]         }
[13:37:58.849]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:58.849]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:58.849]             base::sink(type = "output", split = FALSE)
[13:37:58.849]             base::close(...future.stdout)
[13:37:58.849]         }, add = TRUE)
[13:37:58.849]     }
[13:37:58.849]     ...future.frame <- base::sys.nframe()
[13:37:58.849]     ...future.conditions <- base::list()
[13:37:58.849]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:58.849]     if (FALSE) {
[13:37:58.849]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:58.849]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:58.849]     }
[13:37:58.849]     ...future.result <- base::tryCatch({
[13:37:58.849]         base::withCallingHandlers({
[13:37:58.849]             ...future.value <- base::withVisible(base::local({
[13:37:58.849]                 ...future.makeSendCondition <- base::local({
[13:37:58.849]                   sendCondition <- NULL
[13:37:58.849]                   function(frame = 1L) {
[13:37:58.849]                     if (is.function(sendCondition)) 
[13:37:58.849]                       return(sendCondition)
[13:37:58.849]                     ns <- getNamespace("parallel")
[13:37:58.849]                     if (exists("sendData", mode = "function", 
[13:37:58.849]                       envir = ns)) {
[13:37:58.849]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:58.849]                         envir = ns)
[13:37:58.849]                       envir <- sys.frame(frame)
[13:37:58.849]                       master <- NULL
[13:37:58.849]                       while (!identical(envir, .GlobalEnv) && 
[13:37:58.849]                         !identical(envir, emptyenv())) {
[13:37:58.849]                         if (exists("master", mode = "list", envir = envir, 
[13:37:58.849]                           inherits = FALSE)) {
[13:37:58.849]                           master <- get("master", mode = "list", 
[13:37:58.849]                             envir = envir, inherits = FALSE)
[13:37:58.849]                           if (inherits(master, c("SOCKnode", 
[13:37:58.849]                             "SOCK0node"))) {
[13:37:58.849]                             sendCondition <<- function(cond) {
[13:37:58.849]                               data <- list(type = "VALUE", value = cond, 
[13:37:58.849]                                 success = TRUE)
[13:37:58.849]                               parallel_sendData(master, data)
[13:37:58.849]                             }
[13:37:58.849]                             return(sendCondition)
[13:37:58.849]                           }
[13:37:58.849]                         }
[13:37:58.849]                         frame <- frame + 1L
[13:37:58.849]                         envir <- sys.frame(frame)
[13:37:58.849]                       }
[13:37:58.849]                     }
[13:37:58.849]                     sendCondition <<- function(cond) NULL
[13:37:58.849]                   }
[13:37:58.849]                 })
[13:37:58.849]                 withCallingHandlers({
[13:37:58.849]                   {
[13:37:58.849]                     Sys.sleep(0.5)
[13:37:58.849]                     list(a = 1, b = 42L)
[13:37:58.849]                   }
[13:37:58.849]                 }, immediateCondition = function(cond) {
[13:37:58.849]                   sendCondition <- ...future.makeSendCondition()
[13:37:58.849]                   sendCondition(cond)
[13:37:58.849]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:58.849]                   {
[13:37:58.849]                     inherits <- base::inherits
[13:37:58.849]                     invokeRestart <- base::invokeRestart
[13:37:58.849]                     is.null <- base::is.null
[13:37:58.849]                     muffled <- FALSE
[13:37:58.849]                     if (inherits(cond, "message")) {
[13:37:58.849]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:58.849]                       if (muffled) 
[13:37:58.849]                         invokeRestart("muffleMessage")
[13:37:58.849]                     }
[13:37:58.849]                     else if (inherits(cond, "warning")) {
[13:37:58.849]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:58.849]                       if (muffled) 
[13:37:58.849]                         invokeRestart("muffleWarning")
[13:37:58.849]                     }
[13:37:58.849]                     else if (inherits(cond, "condition")) {
[13:37:58.849]                       if (!is.null(pattern)) {
[13:37:58.849]                         computeRestarts <- base::computeRestarts
[13:37:58.849]                         grepl <- base::grepl
[13:37:58.849]                         restarts <- computeRestarts(cond)
[13:37:58.849]                         for (restart in restarts) {
[13:37:58.849]                           name <- restart$name
[13:37:58.849]                           if (is.null(name)) 
[13:37:58.849]                             next
[13:37:58.849]                           if (!grepl(pattern, name)) 
[13:37:58.849]                             next
[13:37:58.849]                           invokeRestart(restart)
[13:37:58.849]                           muffled <- TRUE
[13:37:58.849]                           break
[13:37:58.849]                         }
[13:37:58.849]                       }
[13:37:58.849]                     }
[13:37:58.849]                     invisible(muffled)
[13:37:58.849]                   }
[13:37:58.849]                   muffleCondition(cond)
[13:37:58.849]                 })
[13:37:58.849]             }))
[13:37:58.849]             future::FutureResult(value = ...future.value$value, 
[13:37:58.849]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:58.849]                   ...future.rng), globalenv = if (FALSE) 
[13:37:58.849]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:58.849]                     ...future.globalenv.names))
[13:37:58.849]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:58.849]         }, condition = base::local({
[13:37:58.849]             c <- base::c
[13:37:58.849]             inherits <- base::inherits
[13:37:58.849]             invokeRestart <- base::invokeRestart
[13:37:58.849]             length <- base::length
[13:37:58.849]             list <- base::list
[13:37:58.849]             seq.int <- base::seq.int
[13:37:58.849]             signalCondition <- base::signalCondition
[13:37:58.849]             sys.calls <- base::sys.calls
[13:37:58.849]             `[[` <- base::`[[`
[13:37:58.849]             `+` <- base::`+`
[13:37:58.849]             `<<-` <- base::`<<-`
[13:37:58.849]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:58.849]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:58.849]                   3L)]
[13:37:58.849]             }
[13:37:58.849]             function(cond) {
[13:37:58.849]                 is_error <- inherits(cond, "error")
[13:37:58.849]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:58.849]                   NULL)
[13:37:58.849]                 if (is_error) {
[13:37:58.849]                   sessionInformation <- function() {
[13:37:58.849]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:58.849]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:58.849]                       search = base::search(), system = base::Sys.info())
[13:37:58.849]                   }
[13:37:58.849]                   ...future.conditions[[length(...future.conditions) + 
[13:37:58.849]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:58.849]                     cond$call), session = sessionInformation(), 
[13:37:58.849]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:58.849]                   signalCondition(cond)
[13:37:58.849]                 }
[13:37:58.849]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:58.849]                 "immediateCondition"))) {
[13:37:58.849]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:58.849]                   ...future.conditions[[length(...future.conditions) + 
[13:37:58.849]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:58.849]                   if (TRUE && !signal) {
[13:37:58.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:58.849]                     {
[13:37:58.849]                       inherits <- base::inherits
[13:37:58.849]                       invokeRestart <- base::invokeRestart
[13:37:58.849]                       is.null <- base::is.null
[13:37:58.849]                       muffled <- FALSE
[13:37:58.849]                       if (inherits(cond, "message")) {
[13:37:58.849]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:58.849]                         if (muffled) 
[13:37:58.849]                           invokeRestart("muffleMessage")
[13:37:58.849]                       }
[13:37:58.849]                       else if (inherits(cond, "warning")) {
[13:37:58.849]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:58.849]                         if (muffled) 
[13:37:58.849]                           invokeRestart("muffleWarning")
[13:37:58.849]                       }
[13:37:58.849]                       else if (inherits(cond, "condition")) {
[13:37:58.849]                         if (!is.null(pattern)) {
[13:37:58.849]                           computeRestarts <- base::computeRestarts
[13:37:58.849]                           grepl <- base::grepl
[13:37:58.849]                           restarts <- computeRestarts(cond)
[13:37:58.849]                           for (restart in restarts) {
[13:37:58.849]                             name <- restart$name
[13:37:58.849]                             if (is.null(name)) 
[13:37:58.849]                               next
[13:37:58.849]                             if (!grepl(pattern, name)) 
[13:37:58.849]                               next
[13:37:58.849]                             invokeRestart(restart)
[13:37:58.849]                             muffled <- TRUE
[13:37:58.849]                             break
[13:37:58.849]                           }
[13:37:58.849]                         }
[13:37:58.849]                       }
[13:37:58.849]                       invisible(muffled)
[13:37:58.849]                     }
[13:37:58.849]                     muffleCondition(cond, pattern = "^muffle")
[13:37:58.849]                   }
[13:37:58.849]                 }
[13:37:58.849]                 else {
[13:37:58.849]                   if (TRUE) {
[13:37:58.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:58.849]                     {
[13:37:58.849]                       inherits <- base::inherits
[13:37:58.849]                       invokeRestart <- base::invokeRestart
[13:37:58.849]                       is.null <- base::is.null
[13:37:58.849]                       muffled <- FALSE
[13:37:58.849]                       if (inherits(cond, "message")) {
[13:37:58.849]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:58.849]                         if (muffled) 
[13:37:58.849]                           invokeRestart("muffleMessage")
[13:37:58.849]                       }
[13:37:58.849]                       else if (inherits(cond, "warning")) {
[13:37:58.849]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:58.849]                         if (muffled) 
[13:37:58.849]                           invokeRestart("muffleWarning")
[13:37:58.849]                       }
[13:37:58.849]                       else if (inherits(cond, "condition")) {
[13:37:58.849]                         if (!is.null(pattern)) {
[13:37:58.849]                           computeRestarts <- base::computeRestarts
[13:37:58.849]                           grepl <- base::grepl
[13:37:58.849]                           restarts <- computeRestarts(cond)
[13:37:58.849]                           for (restart in restarts) {
[13:37:58.849]                             name <- restart$name
[13:37:58.849]                             if (is.null(name)) 
[13:37:58.849]                               next
[13:37:58.849]                             if (!grepl(pattern, name)) 
[13:37:58.849]                               next
[13:37:58.849]                             invokeRestart(restart)
[13:37:58.849]                             muffled <- TRUE
[13:37:58.849]                             break
[13:37:58.849]                           }
[13:37:58.849]                         }
[13:37:58.849]                       }
[13:37:58.849]                       invisible(muffled)
[13:37:58.849]                     }
[13:37:58.849]                     muffleCondition(cond, pattern = "^muffle")
[13:37:58.849]                   }
[13:37:58.849]                 }
[13:37:58.849]             }
[13:37:58.849]         }))
[13:37:58.849]     }, error = function(ex) {
[13:37:58.849]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:58.849]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:58.849]                 ...future.rng), started = ...future.startTime, 
[13:37:58.849]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:58.849]             version = "1.8"), class = "FutureResult")
[13:37:58.849]     }, finally = {
[13:37:58.849]         if (!identical(...future.workdir, getwd())) 
[13:37:58.849]             setwd(...future.workdir)
[13:37:58.849]         {
[13:37:58.849]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:58.849]                 ...future.oldOptions$nwarnings <- NULL
[13:37:58.849]             }
[13:37:58.849]             base::options(...future.oldOptions)
[13:37:58.849]             if (.Platform$OS.type == "windows") {
[13:37:58.849]                 old_names <- names(...future.oldEnvVars)
[13:37:58.849]                 envs <- base::Sys.getenv()
[13:37:58.849]                 names <- names(envs)
[13:37:58.849]                 common <- intersect(names, old_names)
[13:37:58.849]                 added <- setdiff(names, old_names)
[13:37:58.849]                 removed <- setdiff(old_names, names)
[13:37:58.849]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:58.849]                   envs[common]]
[13:37:58.849]                 NAMES <- toupper(changed)
[13:37:58.849]                 args <- list()
[13:37:58.849]                 for (kk in seq_along(NAMES)) {
[13:37:58.849]                   name <- changed[[kk]]
[13:37:58.849]                   NAME <- NAMES[[kk]]
[13:37:58.849]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:58.849]                     next
[13:37:58.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:58.849]                 }
[13:37:58.849]                 NAMES <- toupper(added)
[13:37:58.849]                 for (kk in seq_along(NAMES)) {
[13:37:58.849]                   name <- added[[kk]]
[13:37:58.849]                   NAME <- NAMES[[kk]]
[13:37:58.849]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:58.849]                     next
[13:37:58.849]                   args[[name]] <- ""
[13:37:58.849]                 }
[13:37:58.849]                 NAMES <- toupper(removed)
[13:37:58.849]                 for (kk in seq_along(NAMES)) {
[13:37:58.849]                   name <- removed[[kk]]
[13:37:58.849]                   NAME <- NAMES[[kk]]
[13:37:58.849]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:58.849]                     next
[13:37:58.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:58.849]                 }
[13:37:58.849]                 if (length(args) > 0) 
[13:37:58.849]                   base::do.call(base::Sys.setenv, args = args)
[13:37:58.849]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:58.849]             }
[13:37:58.849]             else {
[13:37:58.849]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:58.849]             }
[13:37:58.849]             {
[13:37:58.849]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:58.849]                   0L) {
[13:37:58.849]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:58.849]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:58.849]                   base::options(opts)
[13:37:58.849]                 }
[13:37:58.849]                 {
[13:37:58.849]                   {
[13:37:58.849]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:58.849]                     NULL
[13:37:58.849]                   }
[13:37:58.849]                   options(future.plan = NULL)
[13:37:58.849]                   if (is.na(NA_character_)) 
[13:37:58.849]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:58.849]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:58.849]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:58.849]                     .init = FALSE)
[13:37:58.849]                 }
[13:37:58.849]             }
[13:37:58.849]         }
[13:37:58.849]     })
[13:37:58.849]     if (TRUE) {
[13:37:58.849]         base::sink(type = "output", split = FALSE)
[13:37:58.849]         if (TRUE) {
[13:37:58.849]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:58.849]         }
[13:37:58.849]         else {
[13:37:58.849]             ...future.result["stdout"] <- base::list(NULL)
[13:37:58.849]         }
[13:37:58.849]         base::close(...future.stdout)
[13:37:58.849]         ...future.stdout <- NULL
[13:37:58.849]     }
[13:37:58.849]     ...future.result$conditions <- ...future.conditions
[13:37:58.849]     ...future.result$finished <- base::Sys.time()
[13:37:58.849]     ...future.result
[13:37:58.849] }
[13:37:58.852] MultisessionFuture started
[13:37:58.852] - Launch lazy future ... done
[13:37:58.852] run() for ‘MultisessionFuture’ ... done
[13:37:59.355] receiveMessageFromWorker() for ClusterFuture ...
[13:37:59.355] - Validating connection of MultisessionFuture
[13:37:59.355] - received message: FutureResult
[13:37:59.355] - Received FutureResult
[13:37:59.355] - Erased future from FutureRegistry
[13:37:59.355] result() for ClusterFuture ...
[13:37:59.355] - result already collected: FutureResult
[13:37:59.356] result() for ClusterFuture ... done
[13:37:59.356] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:59.356] resolve() on list ...
[13:37:59.356]  recursive: 1
[13:37:59.356]  length: 2
[13:37:59.356]  elements: ‘a’, ‘b’
[13:37:59.356]  length: 1 (resolved future 1)
[13:37:59.356]  length: 0 (resolved future 2)
[13:37:59.356] resolve() on list ... DONE
[13:37:59.356] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[13:37:59.357] getGlobalsAndPackages() ...
[13:37:59.357] Searching for globals...
[13:37:59.357] - globals found: [2] ‘list’, ‘stop’
[13:37:59.358] Searching for globals ... DONE
[13:37:59.358] Resolving globals: FALSE
[13:37:59.358] 
[13:37:59.358] 
[13:37:59.358] getGlobalsAndPackages() ... DONE
[13:37:59.358] run() for ‘Future’ ...
[13:37:59.359] - state: ‘created’
[13:37:59.359] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:59.372] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:59.373] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:59.373]   - Field: ‘node’
[13:37:59.373]   - Field: ‘label’
[13:37:59.373]   - Field: ‘local’
[13:37:59.373]   - Field: ‘owner’
[13:37:59.373]   - Field: ‘envir’
[13:37:59.373]   - Field: ‘workers’
[13:37:59.373]   - Field: ‘packages’
[13:37:59.373]   - Field: ‘gc’
[13:37:59.373]   - Field: ‘conditions’
[13:37:59.373]   - Field: ‘persistent’
[13:37:59.374]   - Field: ‘expr’
[13:37:59.374]   - Field: ‘uuid’
[13:37:59.374]   - Field: ‘seed’
[13:37:59.374]   - Field: ‘version’
[13:37:59.374]   - Field: ‘result’
[13:37:59.374]   - Field: ‘asynchronous’
[13:37:59.374]   - Field: ‘calls’
[13:37:59.374]   - Field: ‘globals’
[13:37:59.374]   - Field: ‘stdout’
[13:37:59.374]   - Field: ‘earlySignal’
[13:37:59.375]   - Field: ‘lazy’
[13:37:59.375]   - Field: ‘state’
[13:37:59.375] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:59.375] - Launch lazy future ...
[13:37:59.375] Packages needed by the future expression (n = 0): <none>
[13:37:59.375] Packages needed by future strategies (n = 0): <none>
[13:37:59.376] {
[13:37:59.376]     {
[13:37:59.376]         {
[13:37:59.376]             ...future.startTime <- base::Sys.time()
[13:37:59.376]             {
[13:37:59.376]                 {
[13:37:59.376]                   {
[13:37:59.376]                     {
[13:37:59.376]                       base::local({
[13:37:59.376]                         has_future <- base::requireNamespace("future", 
[13:37:59.376]                           quietly = TRUE)
[13:37:59.376]                         if (has_future) {
[13:37:59.376]                           ns <- base::getNamespace("future")
[13:37:59.376]                           version <- ns[[".package"]][["version"]]
[13:37:59.376]                           if (is.null(version)) 
[13:37:59.376]                             version <- utils::packageVersion("future")
[13:37:59.376]                         }
[13:37:59.376]                         else {
[13:37:59.376]                           version <- NULL
[13:37:59.376]                         }
[13:37:59.376]                         if (!has_future || version < "1.8.0") {
[13:37:59.376]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:59.376]                             "", base::R.version$version.string), 
[13:37:59.376]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:59.376]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:59.376]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:59.376]                               "release", "version")], collapse = " "), 
[13:37:59.376]                             hostname = base::Sys.info()[["nodename"]])
[13:37:59.376]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:59.376]                             info)
[13:37:59.376]                           info <- base::paste(info, collapse = "; ")
[13:37:59.376]                           if (!has_future) {
[13:37:59.376]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:59.376]                               info)
[13:37:59.376]                           }
[13:37:59.376]                           else {
[13:37:59.376]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:59.376]                               info, version)
[13:37:59.376]                           }
[13:37:59.376]                           base::stop(msg)
[13:37:59.376]                         }
[13:37:59.376]                       })
[13:37:59.376]                     }
[13:37:59.376]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:59.376]                     base::options(mc.cores = 1L)
[13:37:59.376]                   }
[13:37:59.376]                   ...future.strategy.old <- future::plan("list")
[13:37:59.376]                   options(future.plan = NULL)
[13:37:59.376]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:59.376]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:59.376]                 }
[13:37:59.376]                 ...future.workdir <- getwd()
[13:37:59.376]             }
[13:37:59.376]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:59.376]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:59.376]         }
[13:37:59.376]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:59.376]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:59.376]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:59.376]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:59.376]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:59.376]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:59.376]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:59.376]             base::names(...future.oldOptions))
[13:37:59.376]     }
[13:37:59.376]     if (FALSE) {
[13:37:59.376]     }
[13:37:59.376]     else {
[13:37:59.376]         if (TRUE) {
[13:37:59.376]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:59.376]                 open = "w")
[13:37:59.376]         }
[13:37:59.376]         else {
[13:37:59.376]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:59.376]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:59.376]         }
[13:37:59.376]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:59.376]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:59.376]             base::sink(type = "output", split = FALSE)
[13:37:59.376]             base::close(...future.stdout)
[13:37:59.376]         }, add = TRUE)
[13:37:59.376]     }
[13:37:59.376]     ...future.frame <- base::sys.nframe()
[13:37:59.376]     ...future.conditions <- base::list()
[13:37:59.376]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:59.376]     if (FALSE) {
[13:37:59.376]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:59.376]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:59.376]     }
[13:37:59.376]     ...future.result <- base::tryCatch({
[13:37:59.376]         base::withCallingHandlers({
[13:37:59.376]             ...future.value <- base::withVisible(base::local({
[13:37:59.376]                 ...future.makeSendCondition <- base::local({
[13:37:59.376]                   sendCondition <- NULL
[13:37:59.376]                   function(frame = 1L) {
[13:37:59.376]                     if (is.function(sendCondition)) 
[13:37:59.376]                       return(sendCondition)
[13:37:59.376]                     ns <- getNamespace("parallel")
[13:37:59.376]                     if (exists("sendData", mode = "function", 
[13:37:59.376]                       envir = ns)) {
[13:37:59.376]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:59.376]                         envir = ns)
[13:37:59.376]                       envir <- sys.frame(frame)
[13:37:59.376]                       master <- NULL
[13:37:59.376]                       while (!identical(envir, .GlobalEnv) && 
[13:37:59.376]                         !identical(envir, emptyenv())) {
[13:37:59.376]                         if (exists("master", mode = "list", envir = envir, 
[13:37:59.376]                           inherits = FALSE)) {
[13:37:59.376]                           master <- get("master", mode = "list", 
[13:37:59.376]                             envir = envir, inherits = FALSE)
[13:37:59.376]                           if (inherits(master, c("SOCKnode", 
[13:37:59.376]                             "SOCK0node"))) {
[13:37:59.376]                             sendCondition <<- function(cond) {
[13:37:59.376]                               data <- list(type = "VALUE", value = cond, 
[13:37:59.376]                                 success = TRUE)
[13:37:59.376]                               parallel_sendData(master, data)
[13:37:59.376]                             }
[13:37:59.376]                             return(sendCondition)
[13:37:59.376]                           }
[13:37:59.376]                         }
[13:37:59.376]                         frame <- frame + 1L
[13:37:59.376]                         envir <- sys.frame(frame)
[13:37:59.376]                       }
[13:37:59.376]                     }
[13:37:59.376]                     sendCondition <<- function(cond) NULL
[13:37:59.376]                   }
[13:37:59.376]                 })
[13:37:59.376]                 withCallingHandlers({
[13:37:59.376]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:37:59.376]                 }, immediateCondition = function(cond) {
[13:37:59.376]                   sendCondition <- ...future.makeSendCondition()
[13:37:59.376]                   sendCondition(cond)
[13:37:59.376]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:59.376]                   {
[13:37:59.376]                     inherits <- base::inherits
[13:37:59.376]                     invokeRestart <- base::invokeRestart
[13:37:59.376]                     is.null <- base::is.null
[13:37:59.376]                     muffled <- FALSE
[13:37:59.376]                     if (inherits(cond, "message")) {
[13:37:59.376]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:59.376]                       if (muffled) 
[13:37:59.376]                         invokeRestart("muffleMessage")
[13:37:59.376]                     }
[13:37:59.376]                     else if (inherits(cond, "warning")) {
[13:37:59.376]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:59.376]                       if (muffled) 
[13:37:59.376]                         invokeRestart("muffleWarning")
[13:37:59.376]                     }
[13:37:59.376]                     else if (inherits(cond, "condition")) {
[13:37:59.376]                       if (!is.null(pattern)) {
[13:37:59.376]                         computeRestarts <- base::computeRestarts
[13:37:59.376]                         grepl <- base::grepl
[13:37:59.376]                         restarts <- computeRestarts(cond)
[13:37:59.376]                         for (restart in restarts) {
[13:37:59.376]                           name <- restart$name
[13:37:59.376]                           if (is.null(name)) 
[13:37:59.376]                             next
[13:37:59.376]                           if (!grepl(pattern, name)) 
[13:37:59.376]                             next
[13:37:59.376]                           invokeRestart(restart)
[13:37:59.376]                           muffled <- TRUE
[13:37:59.376]                           break
[13:37:59.376]                         }
[13:37:59.376]                       }
[13:37:59.376]                     }
[13:37:59.376]                     invisible(muffled)
[13:37:59.376]                   }
[13:37:59.376]                   muffleCondition(cond)
[13:37:59.376]                 })
[13:37:59.376]             }))
[13:37:59.376]             future::FutureResult(value = ...future.value$value, 
[13:37:59.376]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:59.376]                   ...future.rng), globalenv = if (FALSE) 
[13:37:59.376]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:59.376]                     ...future.globalenv.names))
[13:37:59.376]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:59.376]         }, condition = base::local({
[13:37:59.376]             c <- base::c
[13:37:59.376]             inherits <- base::inherits
[13:37:59.376]             invokeRestart <- base::invokeRestart
[13:37:59.376]             length <- base::length
[13:37:59.376]             list <- base::list
[13:37:59.376]             seq.int <- base::seq.int
[13:37:59.376]             signalCondition <- base::signalCondition
[13:37:59.376]             sys.calls <- base::sys.calls
[13:37:59.376]             `[[` <- base::`[[`
[13:37:59.376]             `+` <- base::`+`
[13:37:59.376]             `<<-` <- base::`<<-`
[13:37:59.376]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:59.376]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:59.376]                   3L)]
[13:37:59.376]             }
[13:37:59.376]             function(cond) {
[13:37:59.376]                 is_error <- inherits(cond, "error")
[13:37:59.376]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:59.376]                   NULL)
[13:37:59.376]                 if (is_error) {
[13:37:59.376]                   sessionInformation <- function() {
[13:37:59.376]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:59.376]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:59.376]                       search = base::search(), system = base::Sys.info())
[13:37:59.376]                   }
[13:37:59.376]                   ...future.conditions[[length(...future.conditions) + 
[13:37:59.376]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:59.376]                     cond$call), session = sessionInformation(), 
[13:37:59.376]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:59.376]                   signalCondition(cond)
[13:37:59.376]                 }
[13:37:59.376]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:59.376]                 "immediateCondition"))) {
[13:37:59.376]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:59.376]                   ...future.conditions[[length(...future.conditions) + 
[13:37:59.376]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:59.376]                   if (TRUE && !signal) {
[13:37:59.376]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:59.376]                     {
[13:37:59.376]                       inherits <- base::inherits
[13:37:59.376]                       invokeRestart <- base::invokeRestart
[13:37:59.376]                       is.null <- base::is.null
[13:37:59.376]                       muffled <- FALSE
[13:37:59.376]                       if (inherits(cond, "message")) {
[13:37:59.376]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:59.376]                         if (muffled) 
[13:37:59.376]                           invokeRestart("muffleMessage")
[13:37:59.376]                       }
[13:37:59.376]                       else if (inherits(cond, "warning")) {
[13:37:59.376]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:59.376]                         if (muffled) 
[13:37:59.376]                           invokeRestart("muffleWarning")
[13:37:59.376]                       }
[13:37:59.376]                       else if (inherits(cond, "condition")) {
[13:37:59.376]                         if (!is.null(pattern)) {
[13:37:59.376]                           computeRestarts <- base::computeRestarts
[13:37:59.376]                           grepl <- base::grepl
[13:37:59.376]                           restarts <- computeRestarts(cond)
[13:37:59.376]                           for (restart in restarts) {
[13:37:59.376]                             name <- restart$name
[13:37:59.376]                             if (is.null(name)) 
[13:37:59.376]                               next
[13:37:59.376]                             if (!grepl(pattern, name)) 
[13:37:59.376]                               next
[13:37:59.376]                             invokeRestart(restart)
[13:37:59.376]                             muffled <- TRUE
[13:37:59.376]                             break
[13:37:59.376]                           }
[13:37:59.376]                         }
[13:37:59.376]                       }
[13:37:59.376]                       invisible(muffled)
[13:37:59.376]                     }
[13:37:59.376]                     muffleCondition(cond, pattern = "^muffle")
[13:37:59.376]                   }
[13:37:59.376]                 }
[13:37:59.376]                 else {
[13:37:59.376]                   if (TRUE) {
[13:37:59.376]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:59.376]                     {
[13:37:59.376]                       inherits <- base::inherits
[13:37:59.376]                       invokeRestart <- base::invokeRestart
[13:37:59.376]                       is.null <- base::is.null
[13:37:59.376]                       muffled <- FALSE
[13:37:59.376]                       if (inherits(cond, "message")) {
[13:37:59.376]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:59.376]                         if (muffled) 
[13:37:59.376]                           invokeRestart("muffleMessage")
[13:37:59.376]                       }
[13:37:59.376]                       else if (inherits(cond, "warning")) {
[13:37:59.376]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:59.376]                         if (muffled) 
[13:37:59.376]                           invokeRestart("muffleWarning")
[13:37:59.376]                       }
[13:37:59.376]                       else if (inherits(cond, "condition")) {
[13:37:59.376]                         if (!is.null(pattern)) {
[13:37:59.376]                           computeRestarts <- base::computeRestarts
[13:37:59.376]                           grepl <- base::grepl
[13:37:59.376]                           restarts <- computeRestarts(cond)
[13:37:59.376]                           for (restart in restarts) {
[13:37:59.376]                             name <- restart$name
[13:37:59.376]                             if (is.null(name)) 
[13:37:59.376]                               next
[13:37:59.376]                             if (!grepl(pattern, name)) 
[13:37:59.376]                               next
[13:37:59.376]                             invokeRestart(restart)
[13:37:59.376]                             muffled <- TRUE
[13:37:59.376]                             break
[13:37:59.376]                           }
[13:37:59.376]                         }
[13:37:59.376]                       }
[13:37:59.376]                       invisible(muffled)
[13:37:59.376]                     }
[13:37:59.376]                     muffleCondition(cond, pattern = "^muffle")
[13:37:59.376]                   }
[13:37:59.376]                 }
[13:37:59.376]             }
[13:37:59.376]         }))
[13:37:59.376]     }, error = function(ex) {
[13:37:59.376]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:59.376]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:59.376]                 ...future.rng), started = ...future.startTime, 
[13:37:59.376]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:59.376]             version = "1.8"), class = "FutureResult")
[13:37:59.376]     }, finally = {
[13:37:59.376]         if (!identical(...future.workdir, getwd())) 
[13:37:59.376]             setwd(...future.workdir)
[13:37:59.376]         {
[13:37:59.376]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:59.376]                 ...future.oldOptions$nwarnings <- NULL
[13:37:59.376]             }
[13:37:59.376]             base::options(...future.oldOptions)
[13:37:59.376]             if (.Platform$OS.type == "windows") {
[13:37:59.376]                 old_names <- names(...future.oldEnvVars)
[13:37:59.376]                 envs <- base::Sys.getenv()
[13:37:59.376]                 names <- names(envs)
[13:37:59.376]                 common <- intersect(names, old_names)
[13:37:59.376]                 added <- setdiff(names, old_names)
[13:37:59.376]                 removed <- setdiff(old_names, names)
[13:37:59.376]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:59.376]                   envs[common]]
[13:37:59.376]                 NAMES <- toupper(changed)
[13:37:59.376]                 args <- list()
[13:37:59.376]                 for (kk in seq_along(NAMES)) {
[13:37:59.376]                   name <- changed[[kk]]
[13:37:59.376]                   NAME <- NAMES[[kk]]
[13:37:59.376]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:59.376]                     next
[13:37:59.376]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:59.376]                 }
[13:37:59.376]                 NAMES <- toupper(added)
[13:37:59.376]                 for (kk in seq_along(NAMES)) {
[13:37:59.376]                   name <- added[[kk]]
[13:37:59.376]                   NAME <- NAMES[[kk]]
[13:37:59.376]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:59.376]                     next
[13:37:59.376]                   args[[name]] <- ""
[13:37:59.376]                 }
[13:37:59.376]                 NAMES <- toupper(removed)
[13:37:59.376]                 for (kk in seq_along(NAMES)) {
[13:37:59.376]                   name <- removed[[kk]]
[13:37:59.376]                   NAME <- NAMES[[kk]]
[13:37:59.376]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:59.376]                     next
[13:37:59.376]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:59.376]                 }
[13:37:59.376]                 if (length(args) > 0) 
[13:37:59.376]                   base::do.call(base::Sys.setenv, args = args)
[13:37:59.376]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:59.376]             }
[13:37:59.376]             else {
[13:37:59.376]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:59.376]             }
[13:37:59.376]             {
[13:37:59.376]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:59.376]                   0L) {
[13:37:59.376]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:59.376]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:59.376]                   base::options(opts)
[13:37:59.376]                 }
[13:37:59.376]                 {
[13:37:59.376]                   {
[13:37:59.376]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:59.376]                     NULL
[13:37:59.376]                   }
[13:37:59.376]                   options(future.plan = NULL)
[13:37:59.376]                   if (is.na(NA_character_)) 
[13:37:59.376]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:59.376]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:59.376]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:59.376]                     .init = FALSE)
[13:37:59.376]                 }
[13:37:59.376]             }
[13:37:59.376]         }
[13:37:59.376]     })
[13:37:59.376]     if (TRUE) {
[13:37:59.376]         base::sink(type = "output", split = FALSE)
[13:37:59.376]         if (TRUE) {
[13:37:59.376]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:59.376]         }
[13:37:59.376]         else {
[13:37:59.376]             ...future.result["stdout"] <- base::list(NULL)
[13:37:59.376]         }
[13:37:59.376]         base::close(...future.stdout)
[13:37:59.376]         ...future.stdout <- NULL
[13:37:59.376]     }
[13:37:59.376]     ...future.result$conditions <- ...future.conditions
[13:37:59.376]     ...future.result$finished <- base::Sys.time()
[13:37:59.376]     ...future.result
[13:37:59.376] }
[13:37:59.379] MultisessionFuture started
[13:37:59.379] - Launch lazy future ... done
[13:37:59.379] run() for ‘MultisessionFuture’ ... done
[13:37:59.381] receiveMessageFromWorker() for ClusterFuture ...
[13:37:59.381] - Validating connection of MultisessionFuture
[13:37:59.381] - received message: FutureResult
[13:37:59.381] - Received FutureResult
[13:37:59.382] - Erased future from FutureRegistry
[13:37:59.382] result() for ClusterFuture ...
[13:37:59.382] - result already collected: FutureResult
[13:37:59.382] result() for ClusterFuture ... done
[13:37:59.382] signalConditions() ...
[13:37:59.382]  - include = ‘immediateCondition’
[13:37:59.382]  - exclude = 
[13:37:59.382]  - resignal = FALSE
[13:37:59.382]  - Number of conditions: 1
[13:37:59.382] signalConditions() ... done
[13:37:59.383] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:59.383] A MultisessionFuture was resolved
[13:37:59.383] getGlobalsAndPackages() ...
[13:37:59.383] Searching for globals...
[13:37:59.386] - globals found: [2] ‘list’, ‘stop’
[13:37:59.386] Searching for globals ... DONE
[13:37:59.387] Resolving globals: FALSE
[13:37:59.387] 
[13:37:59.387] 
[13:37:59.387] getGlobalsAndPackages() ... DONE
[13:37:59.387] run() for ‘Future’ ...
[13:37:59.388] - state: ‘created’
[13:37:59.388] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:59.401] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:59.401] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:59.402]   - Field: ‘node’
[13:37:59.402]   - Field: ‘label’
[13:37:59.402]   - Field: ‘local’
[13:37:59.402]   - Field: ‘owner’
[13:37:59.402]   - Field: ‘envir’
[13:37:59.402]   - Field: ‘workers’
[13:37:59.402]   - Field: ‘packages’
[13:37:59.402]   - Field: ‘gc’
[13:37:59.402]   - Field: ‘conditions’
[13:37:59.402]   - Field: ‘persistent’
[13:37:59.403]   - Field: ‘expr’
[13:37:59.403]   - Field: ‘uuid’
[13:37:59.403]   - Field: ‘seed’
[13:37:59.403]   - Field: ‘version’
[13:37:59.403]   - Field: ‘result’
[13:37:59.403]   - Field: ‘asynchronous’
[13:37:59.403]   - Field: ‘calls’
[13:37:59.403]   - Field: ‘globals’
[13:37:59.403]   - Field: ‘stdout’
[13:37:59.403]   - Field: ‘earlySignal’
[13:37:59.403]   - Field: ‘lazy’
[13:37:59.404]   - Field: ‘state’
[13:37:59.404] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:59.404] - Launch lazy future ...
[13:37:59.404] Packages needed by the future expression (n = 0): <none>
[13:37:59.404] Packages needed by future strategies (n = 0): <none>
[13:37:59.404] {
[13:37:59.404]     {
[13:37:59.404]         {
[13:37:59.404]             ...future.startTime <- base::Sys.time()
[13:37:59.404]             {
[13:37:59.404]                 {
[13:37:59.404]                   {
[13:37:59.404]                     {
[13:37:59.404]                       base::local({
[13:37:59.404]                         has_future <- base::requireNamespace("future", 
[13:37:59.404]                           quietly = TRUE)
[13:37:59.404]                         if (has_future) {
[13:37:59.404]                           ns <- base::getNamespace("future")
[13:37:59.404]                           version <- ns[[".package"]][["version"]]
[13:37:59.404]                           if (is.null(version)) 
[13:37:59.404]                             version <- utils::packageVersion("future")
[13:37:59.404]                         }
[13:37:59.404]                         else {
[13:37:59.404]                           version <- NULL
[13:37:59.404]                         }
[13:37:59.404]                         if (!has_future || version < "1.8.0") {
[13:37:59.404]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:59.404]                             "", base::R.version$version.string), 
[13:37:59.404]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:59.404]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:59.404]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:59.404]                               "release", "version")], collapse = " "), 
[13:37:59.404]                             hostname = base::Sys.info()[["nodename"]])
[13:37:59.404]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:59.404]                             info)
[13:37:59.404]                           info <- base::paste(info, collapse = "; ")
[13:37:59.404]                           if (!has_future) {
[13:37:59.404]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:59.404]                               info)
[13:37:59.404]                           }
[13:37:59.404]                           else {
[13:37:59.404]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:59.404]                               info, version)
[13:37:59.404]                           }
[13:37:59.404]                           base::stop(msg)
[13:37:59.404]                         }
[13:37:59.404]                       })
[13:37:59.404]                     }
[13:37:59.404]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:59.404]                     base::options(mc.cores = 1L)
[13:37:59.404]                   }
[13:37:59.404]                   ...future.strategy.old <- future::plan("list")
[13:37:59.404]                   options(future.plan = NULL)
[13:37:59.404]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:59.404]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:59.404]                 }
[13:37:59.404]                 ...future.workdir <- getwd()
[13:37:59.404]             }
[13:37:59.404]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:59.404]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:59.404]         }
[13:37:59.404]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:59.404]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:59.404]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:59.404]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:59.404]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:59.404]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:59.404]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:59.404]             base::names(...future.oldOptions))
[13:37:59.404]     }
[13:37:59.404]     if (FALSE) {
[13:37:59.404]     }
[13:37:59.404]     else {
[13:37:59.404]         if (TRUE) {
[13:37:59.404]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:59.404]                 open = "w")
[13:37:59.404]         }
[13:37:59.404]         else {
[13:37:59.404]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:59.404]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:59.404]         }
[13:37:59.404]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:59.404]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:59.404]             base::sink(type = "output", split = FALSE)
[13:37:59.404]             base::close(...future.stdout)
[13:37:59.404]         }, add = TRUE)
[13:37:59.404]     }
[13:37:59.404]     ...future.frame <- base::sys.nframe()
[13:37:59.404]     ...future.conditions <- base::list()
[13:37:59.404]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:59.404]     if (FALSE) {
[13:37:59.404]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:59.404]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:59.404]     }
[13:37:59.404]     ...future.result <- base::tryCatch({
[13:37:59.404]         base::withCallingHandlers({
[13:37:59.404]             ...future.value <- base::withVisible(base::local({
[13:37:59.404]                 ...future.makeSendCondition <- base::local({
[13:37:59.404]                   sendCondition <- NULL
[13:37:59.404]                   function(frame = 1L) {
[13:37:59.404]                     if (is.function(sendCondition)) 
[13:37:59.404]                       return(sendCondition)
[13:37:59.404]                     ns <- getNamespace("parallel")
[13:37:59.404]                     if (exists("sendData", mode = "function", 
[13:37:59.404]                       envir = ns)) {
[13:37:59.404]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:59.404]                         envir = ns)
[13:37:59.404]                       envir <- sys.frame(frame)
[13:37:59.404]                       master <- NULL
[13:37:59.404]                       while (!identical(envir, .GlobalEnv) && 
[13:37:59.404]                         !identical(envir, emptyenv())) {
[13:37:59.404]                         if (exists("master", mode = "list", envir = envir, 
[13:37:59.404]                           inherits = FALSE)) {
[13:37:59.404]                           master <- get("master", mode = "list", 
[13:37:59.404]                             envir = envir, inherits = FALSE)
[13:37:59.404]                           if (inherits(master, c("SOCKnode", 
[13:37:59.404]                             "SOCK0node"))) {
[13:37:59.404]                             sendCondition <<- function(cond) {
[13:37:59.404]                               data <- list(type = "VALUE", value = cond, 
[13:37:59.404]                                 success = TRUE)
[13:37:59.404]                               parallel_sendData(master, data)
[13:37:59.404]                             }
[13:37:59.404]                             return(sendCondition)
[13:37:59.404]                           }
[13:37:59.404]                         }
[13:37:59.404]                         frame <- frame + 1L
[13:37:59.404]                         envir <- sys.frame(frame)
[13:37:59.404]                       }
[13:37:59.404]                     }
[13:37:59.404]                     sendCondition <<- function(cond) NULL
[13:37:59.404]                   }
[13:37:59.404]                 })
[13:37:59.404]                 withCallingHandlers({
[13:37:59.404]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:37:59.404]                 }, immediateCondition = function(cond) {
[13:37:59.404]                   sendCondition <- ...future.makeSendCondition()
[13:37:59.404]                   sendCondition(cond)
[13:37:59.404]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:59.404]                   {
[13:37:59.404]                     inherits <- base::inherits
[13:37:59.404]                     invokeRestart <- base::invokeRestart
[13:37:59.404]                     is.null <- base::is.null
[13:37:59.404]                     muffled <- FALSE
[13:37:59.404]                     if (inherits(cond, "message")) {
[13:37:59.404]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:59.404]                       if (muffled) 
[13:37:59.404]                         invokeRestart("muffleMessage")
[13:37:59.404]                     }
[13:37:59.404]                     else if (inherits(cond, "warning")) {
[13:37:59.404]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:59.404]                       if (muffled) 
[13:37:59.404]                         invokeRestart("muffleWarning")
[13:37:59.404]                     }
[13:37:59.404]                     else if (inherits(cond, "condition")) {
[13:37:59.404]                       if (!is.null(pattern)) {
[13:37:59.404]                         computeRestarts <- base::computeRestarts
[13:37:59.404]                         grepl <- base::grepl
[13:37:59.404]                         restarts <- computeRestarts(cond)
[13:37:59.404]                         for (restart in restarts) {
[13:37:59.404]                           name <- restart$name
[13:37:59.404]                           if (is.null(name)) 
[13:37:59.404]                             next
[13:37:59.404]                           if (!grepl(pattern, name)) 
[13:37:59.404]                             next
[13:37:59.404]                           invokeRestart(restart)
[13:37:59.404]                           muffled <- TRUE
[13:37:59.404]                           break
[13:37:59.404]                         }
[13:37:59.404]                       }
[13:37:59.404]                     }
[13:37:59.404]                     invisible(muffled)
[13:37:59.404]                   }
[13:37:59.404]                   muffleCondition(cond)
[13:37:59.404]                 })
[13:37:59.404]             }))
[13:37:59.404]             future::FutureResult(value = ...future.value$value, 
[13:37:59.404]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:59.404]                   ...future.rng), globalenv = if (FALSE) 
[13:37:59.404]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:59.404]                     ...future.globalenv.names))
[13:37:59.404]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:59.404]         }, condition = base::local({
[13:37:59.404]             c <- base::c
[13:37:59.404]             inherits <- base::inherits
[13:37:59.404]             invokeRestart <- base::invokeRestart
[13:37:59.404]             length <- base::length
[13:37:59.404]             list <- base::list
[13:37:59.404]             seq.int <- base::seq.int
[13:37:59.404]             signalCondition <- base::signalCondition
[13:37:59.404]             sys.calls <- base::sys.calls
[13:37:59.404]             `[[` <- base::`[[`
[13:37:59.404]             `+` <- base::`+`
[13:37:59.404]             `<<-` <- base::`<<-`
[13:37:59.404]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:59.404]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:59.404]                   3L)]
[13:37:59.404]             }
[13:37:59.404]             function(cond) {
[13:37:59.404]                 is_error <- inherits(cond, "error")
[13:37:59.404]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:59.404]                   NULL)
[13:37:59.404]                 if (is_error) {
[13:37:59.404]                   sessionInformation <- function() {
[13:37:59.404]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:59.404]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:59.404]                       search = base::search(), system = base::Sys.info())
[13:37:59.404]                   }
[13:37:59.404]                   ...future.conditions[[length(...future.conditions) + 
[13:37:59.404]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:59.404]                     cond$call), session = sessionInformation(), 
[13:37:59.404]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:59.404]                   signalCondition(cond)
[13:37:59.404]                 }
[13:37:59.404]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:59.404]                 "immediateCondition"))) {
[13:37:59.404]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:59.404]                   ...future.conditions[[length(...future.conditions) + 
[13:37:59.404]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:59.404]                   if (TRUE && !signal) {
[13:37:59.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:59.404]                     {
[13:37:59.404]                       inherits <- base::inherits
[13:37:59.404]                       invokeRestart <- base::invokeRestart
[13:37:59.404]                       is.null <- base::is.null
[13:37:59.404]                       muffled <- FALSE
[13:37:59.404]                       if (inherits(cond, "message")) {
[13:37:59.404]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:59.404]                         if (muffled) 
[13:37:59.404]                           invokeRestart("muffleMessage")
[13:37:59.404]                       }
[13:37:59.404]                       else if (inherits(cond, "warning")) {
[13:37:59.404]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:59.404]                         if (muffled) 
[13:37:59.404]                           invokeRestart("muffleWarning")
[13:37:59.404]                       }
[13:37:59.404]                       else if (inherits(cond, "condition")) {
[13:37:59.404]                         if (!is.null(pattern)) {
[13:37:59.404]                           computeRestarts <- base::computeRestarts
[13:37:59.404]                           grepl <- base::grepl
[13:37:59.404]                           restarts <- computeRestarts(cond)
[13:37:59.404]                           for (restart in restarts) {
[13:37:59.404]                             name <- restart$name
[13:37:59.404]                             if (is.null(name)) 
[13:37:59.404]                               next
[13:37:59.404]                             if (!grepl(pattern, name)) 
[13:37:59.404]                               next
[13:37:59.404]                             invokeRestart(restart)
[13:37:59.404]                             muffled <- TRUE
[13:37:59.404]                             break
[13:37:59.404]                           }
[13:37:59.404]                         }
[13:37:59.404]                       }
[13:37:59.404]                       invisible(muffled)
[13:37:59.404]                     }
[13:37:59.404]                     muffleCondition(cond, pattern = "^muffle")
[13:37:59.404]                   }
[13:37:59.404]                 }
[13:37:59.404]                 else {
[13:37:59.404]                   if (TRUE) {
[13:37:59.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:59.404]                     {
[13:37:59.404]                       inherits <- base::inherits
[13:37:59.404]                       invokeRestart <- base::invokeRestart
[13:37:59.404]                       is.null <- base::is.null
[13:37:59.404]                       muffled <- FALSE
[13:37:59.404]                       if (inherits(cond, "message")) {
[13:37:59.404]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:59.404]                         if (muffled) 
[13:37:59.404]                           invokeRestart("muffleMessage")
[13:37:59.404]                       }
[13:37:59.404]                       else if (inherits(cond, "warning")) {
[13:37:59.404]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:59.404]                         if (muffled) 
[13:37:59.404]                           invokeRestart("muffleWarning")
[13:37:59.404]                       }
[13:37:59.404]                       else if (inherits(cond, "condition")) {
[13:37:59.404]                         if (!is.null(pattern)) {
[13:37:59.404]                           computeRestarts <- base::computeRestarts
[13:37:59.404]                           grepl <- base::grepl
[13:37:59.404]                           restarts <- computeRestarts(cond)
[13:37:59.404]                           for (restart in restarts) {
[13:37:59.404]                             name <- restart$name
[13:37:59.404]                             if (is.null(name)) 
[13:37:59.404]                               next
[13:37:59.404]                             if (!grepl(pattern, name)) 
[13:37:59.404]                               next
[13:37:59.404]                             invokeRestart(restart)
[13:37:59.404]                             muffled <- TRUE
[13:37:59.404]                             break
[13:37:59.404]                           }
[13:37:59.404]                         }
[13:37:59.404]                       }
[13:37:59.404]                       invisible(muffled)
[13:37:59.404]                     }
[13:37:59.404]                     muffleCondition(cond, pattern = "^muffle")
[13:37:59.404]                   }
[13:37:59.404]                 }
[13:37:59.404]             }
[13:37:59.404]         }))
[13:37:59.404]     }, error = function(ex) {
[13:37:59.404]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:59.404]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:59.404]                 ...future.rng), started = ...future.startTime, 
[13:37:59.404]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:59.404]             version = "1.8"), class = "FutureResult")
[13:37:59.404]     }, finally = {
[13:37:59.404]         if (!identical(...future.workdir, getwd())) 
[13:37:59.404]             setwd(...future.workdir)
[13:37:59.404]         {
[13:37:59.404]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:59.404]                 ...future.oldOptions$nwarnings <- NULL
[13:37:59.404]             }
[13:37:59.404]             base::options(...future.oldOptions)
[13:37:59.404]             if (.Platform$OS.type == "windows") {
[13:37:59.404]                 old_names <- names(...future.oldEnvVars)
[13:37:59.404]                 envs <- base::Sys.getenv()
[13:37:59.404]                 names <- names(envs)
[13:37:59.404]                 common <- intersect(names, old_names)
[13:37:59.404]                 added <- setdiff(names, old_names)
[13:37:59.404]                 removed <- setdiff(old_names, names)
[13:37:59.404]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:59.404]                   envs[common]]
[13:37:59.404]                 NAMES <- toupper(changed)
[13:37:59.404]                 args <- list()
[13:37:59.404]                 for (kk in seq_along(NAMES)) {
[13:37:59.404]                   name <- changed[[kk]]
[13:37:59.404]                   NAME <- NAMES[[kk]]
[13:37:59.404]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:59.404]                     next
[13:37:59.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:59.404]                 }
[13:37:59.404]                 NAMES <- toupper(added)
[13:37:59.404]                 for (kk in seq_along(NAMES)) {
[13:37:59.404]                   name <- added[[kk]]
[13:37:59.404]                   NAME <- NAMES[[kk]]
[13:37:59.404]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:59.404]                     next
[13:37:59.404]                   args[[name]] <- ""
[13:37:59.404]                 }
[13:37:59.404]                 NAMES <- toupper(removed)
[13:37:59.404]                 for (kk in seq_along(NAMES)) {
[13:37:59.404]                   name <- removed[[kk]]
[13:37:59.404]                   NAME <- NAMES[[kk]]
[13:37:59.404]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:59.404]                     next
[13:37:59.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:59.404]                 }
[13:37:59.404]                 if (length(args) > 0) 
[13:37:59.404]                   base::do.call(base::Sys.setenv, args = args)
[13:37:59.404]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:59.404]             }
[13:37:59.404]             else {
[13:37:59.404]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:59.404]             }
[13:37:59.404]             {
[13:37:59.404]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:59.404]                   0L) {
[13:37:59.404]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:59.404]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:59.404]                   base::options(opts)
[13:37:59.404]                 }
[13:37:59.404]                 {
[13:37:59.404]                   {
[13:37:59.404]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:59.404]                     NULL
[13:37:59.404]                   }
[13:37:59.404]                   options(future.plan = NULL)
[13:37:59.404]                   if (is.na(NA_character_)) 
[13:37:59.404]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:59.404]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:59.404]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:59.404]                     .init = FALSE)
[13:37:59.404]                 }
[13:37:59.404]             }
[13:37:59.404]         }
[13:37:59.404]     })
[13:37:59.404]     if (TRUE) {
[13:37:59.404]         base::sink(type = "output", split = FALSE)
[13:37:59.404]         if (TRUE) {
[13:37:59.404]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:59.404]         }
[13:37:59.404]         else {
[13:37:59.404]             ...future.result["stdout"] <- base::list(NULL)
[13:37:59.404]         }
[13:37:59.404]         base::close(...future.stdout)
[13:37:59.404]         ...future.stdout <- NULL
[13:37:59.404]     }
[13:37:59.404]     ...future.result$conditions <- ...future.conditions
[13:37:59.404]     ...future.result$finished <- base::Sys.time()
[13:37:59.404]     ...future.result
[13:37:59.404] }
[13:37:59.407] MultisessionFuture started
[13:37:59.408] - Launch lazy future ... done
[13:37:59.408] run() for ‘MultisessionFuture’ ... done
[13:37:59.409] receiveMessageFromWorker() for ClusterFuture ...
[13:37:59.409] - Validating connection of MultisessionFuture
[13:37:59.410] - received message: FutureResult
[13:37:59.410] - Received FutureResult
[13:37:59.410] - Erased future from FutureRegistry
[13:37:59.410] result() for ClusterFuture ...
[13:37:59.410] - result already collected: FutureResult
[13:37:59.410] result() for ClusterFuture ... done
[13:37:59.410] signalConditions() ...
[13:37:59.410]  - include = ‘immediateCondition’
[13:37:59.410]  - exclude = 
[13:37:59.410]  - resignal = FALSE
[13:37:59.410]  - Number of conditions: 1
[13:37:59.411] signalConditions() ... done
[13:37:59.411] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:59.411] A MultisessionFuture was resolved
- result = TRUE, recursive = 2 ... DONE
- result = TRUE, recursive = Inf ...
[13:37:59.411] getGlobalsAndPackages() ...
[13:37:59.411] Searching for globals...
[13:37:59.412] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:37:59.412] Searching for globals ... DONE
[13:37:59.412] Resolving globals: FALSE
[13:37:59.413] 
[13:37:59.413] 
[13:37:59.413] getGlobalsAndPackages() ... DONE
[13:37:59.413] run() for ‘Future’ ...
[13:37:59.413] - state: ‘created’
[13:37:59.413] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:59.427] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:59.427] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:59.427]   - Field: ‘node’
[13:37:59.427]   - Field: ‘label’
[13:37:59.428]   - Field: ‘local’
[13:37:59.428]   - Field: ‘owner’
[13:37:59.428]   - Field: ‘envir’
[13:37:59.428]   - Field: ‘workers’
[13:37:59.428]   - Field: ‘packages’
[13:37:59.428]   - Field: ‘gc’
[13:37:59.428]   - Field: ‘conditions’
[13:37:59.428]   - Field: ‘persistent’
[13:37:59.428]   - Field: ‘expr’
[13:37:59.428]   - Field: ‘uuid’
[13:37:59.428]   - Field: ‘seed’
[13:37:59.429]   - Field: ‘version’
[13:37:59.429]   - Field: ‘result’
[13:37:59.429]   - Field: ‘asynchronous’
[13:37:59.429]   - Field: ‘calls’
[13:37:59.429]   - Field: ‘globals’
[13:37:59.429]   - Field: ‘stdout’
[13:37:59.429]   - Field: ‘earlySignal’
[13:37:59.429]   - Field: ‘lazy’
[13:37:59.429]   - Field: ‘state’
[13:37:59.429] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:59.429] - Launch lazy future ...
[13:37:59.430] Packages needed by the future expression (n = 0): <none>
[13:37:59.430] Packages needed by future strategies (n = 0): <none>
[13:37:59.430] {
[13:37:59.430]     {
[13:37:59.430]         {
[13:37:59.430]             ...future.startTime <- base::Sys.time()
[13:37:59.430]             {
[13:37:59.430]                 {
[13:37:59.430]                   {
[13:37:59.430]                     {
[13:37:59.430]                       base::local({
[13:37:59.430]                         has_future <- base::requireNamespace("future", 
[13:37:59.430]                           quietly = TRUE)
[13:37:59.430]                         if (has_future) {
[13:37:59.430]                           ns <- base::getNamespace("future")
[13:37:59.430]                           version <- ns[[".package"]][["version"]]
[13:37:59.430]                           if (is.null(version)) 
[13:37:59.430]                             version <- utils::packageVersion("future")
[13:37:59.430]                         }
[13:37:59.430]                         else {
[13:37:59.430]                           version <- NULL
[13:37:59.430]                         }
[13:37:59.430]                         if (!has_future || version < "1.8.0") {
[13:37:59.430]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:59.430]                             "", base::R.version$version.string), 
[13:37:59.430]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:59.430]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:59.430]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:59.430]                               "release", "version")], collapse = " "), 
[13:37:59.430]                             hostname = base::Sys.info()[["nodename"]])
[13:37:59.430]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:59.430]                             info)
[13:37:59.430]                           info <- base::paste(info, collapse = "; ")
[13:37:59.430]                           if (!has_future) {
[13:37:59.430]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:59.430]                               info)
[13:37:59.430]                           }
[13:37:59.430]                           else {
[13:37:59.430]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:59.430]                               info, version)
[13:37:59.430]                           }
[13:37:59.430]                           base::stop(msg)
[13:37:59.430]                         }
[13:37:59.430]                       })
[13:37:59.430]                     }
[13:37:59.430]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:59.430]                     base::options(mc.cores = 1L)
[13:37:59.430]                   }
[13:37:59.430]                   ...future.strategy.old <- future::plan("list")
[13:37:59.430]                   options(future.plan = NULL)
[13:37:59.430]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:59.430]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:59.430]                 }
[13:37:59.430]                 ...future.workdir <- getwd()
[13:37:59.430]             }
[13:37:59.430]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:59.430]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:59.430]         }
[13:37:59.430]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:59.430]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:59.430]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:59.430]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:59.430]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:59.430]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:59.430]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:59.430]             base::names(...future.oldOptions))
[13:37:59.430]     }
[13:37:59.430]     if (FALSE) {
[13:37:59.430]     }
[13:37:59.430]     else {
[13:37:59.430]         if (TRUE) {
[13:37:59.430]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:59.430]                 open = "w")
[13:37:59.430]         }
[13:37:59.430]         else {
[13:37:59.430]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:59.430]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:59.430]         }
[13:37:59.430]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:59.430]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:59.430]             base::sink(type = "output", split = FALSE)
[13:37:59.430]             base::close(...future.stdout)
[13:37:59.430]         }, add = TRUE)
[13:37:59.430]     }
[13:37:59.430]     ...future.frame <- base::sys.nframe()
[13:37:59.430]     ...future.conditions <- base::list()
[13:37:59.430]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:59.430]     if (FALSE) {
[13:37:59.430]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:59.430]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:59.430]     }
[13:37:59.430]     ...future.result <- base::tryCatch({
[13:37:59.430]         base::withCallingHandlers({
[13:37:59.430]             ...future.value <- base::withVisible(base::local({
[13:37:59.430]                 ...future.makeSendCondition <- base::local({
[13:37:59.430]                   sendCondition <- NULL
[13:37:59.430]                   function(frame = 1L) {
[13:37:59.430]                     if (is.function(sendCondition)) 
[13:37:59.430]                       return(sendCondition)
[13:37:59.430]                     ns <- getNamespace("parallel")
[13:37:59.430]                     if (exists("sendData", mode = "function", 
[13:37:59.430]                       envir = ns)) {
[13:37:59.430]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:59.430]                         envir = ns)
[13:37:59.430]                       envir <- sys.frame(frame)
[13:37:59.430]                       master <- NULL
[13:37:59.430]                       while (!identical(envir, .GlobalEnv) && 
[13:37:59.430]                         !identical(envir, emptyenv())) {
[13:37:59.430]                         if (exists("master", mode = "list", envir = envir, 
[13:37:59.430]                           inherits = FALSE)) {
[13:37:59.430]                           master <- get("master", mode = "list", 
[13:37:59.430]                             envir = envir, inherits = FALSE)
[13:37:59.430]                           if (inherits(master, c("SOCKnode", 
[13:37:59.430]                             "SOCK0node"))) {
[13:37:59.430]                             sendCondition <<- function(cond) {
[13:37:59.430]                               data <- list(type = "VALUE", value = cond, 
[13:37:59.430]                                 success = TRUE)
[13:37:59.430]                               parallel_sendData(master, data)
[13:37:59.430]                             }
[13:37:59.430]                             return(sendCondition)
[13:37:59.430]                           }
[13:37:59.430]                         }
[13:37:59.430]                         frame <- frame + 1L
[13:37:59.430]                         envir <- sys.frame(frame)
[13:37:59.430]                       }
[13:37:59.430]                     }
[13:37:59.430]                     sendCondition <<- function(cond) NULL
[13:37:59.430]                   }
[13:37:59.430]                 })
[13:37:59.430]                 withCallingHandlers({
[13:37:59.430]                   {
[13:37:59.430]                     Sys.sleep(0.5)
[13:37:59.430]                     list(a = 1, b = 42L)
[13:37:59.430]                   }
[13:37:59.430]                 }, immediateCondition = function(cond) {
[13:37:59.430]                   sendCondition <- ...future.makeSendCondition()
[13:37:59.430]                   sendCondition(cond)
[13:37:59.430]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:59.430]                   {
[13:37:59.430]                     inherits <- base::inherits
[13:37:59.430]                     invokeRestart <- base::invokeRestart
[13:37:59.430]                     is.null <- base::is.null
[13:37:59.430]                     muffled <- FALSE
[13:37:59.430]                     if (inherits(cond, "message")) {
[13:37:59.430]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:59.430]                       if (muffled) 
[13:37:59.430]                         invokeRestart("muffleMessage")
[13:37:59.430]                     }
[13:37:59.430]                     else if (inherits(cond, "warning")) {
[13:37:59.430]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:59.430]                       if (muffled) 
[13:37:59.430]                         invokeRestart("muffleWarning")
[13:37:59.430]                     }
[13:37:59.430]                     else if (inherits(cond, "condition")) {
[13:37:59.430]                       if (!is.null(pattern)) {
[13:37:59.430]                         computeRestarts <- base::computeRestarts
[13:37:59.430]                         grepl <- base::grepl
[13:37:59.430]                         restarts <- computeRestarts(cond)
[13:37:59.430]                         for (restart in restarts) {
[13:37:59.430]                           name <- restart$name
[13:37:59.430]                           if (is.null(name)) 
[13:37:59.430]                             next
[13:37:59.430]                           if (!grepl(pattern, name)) 
[13:37:59.430]                             next
[13:37:59.430]                           invokeRestart(restart)
[13:37:59.430]                           muffled <- TRUE
[13:37:59.430]                           break
[13:37:59.430]                         }
[13:37:59.430]                       }
[13:37:59.430]                     }
[13:37:59.430]                     invisible(muffled)
[13:37:59.430]                   }
[13:37:59.430]                   muffleCondition(cond)
[13:37:59.430]                 })
[13:37:59.430]             }))
[13:37:59.430]             future::FutureResult(value = ...future.value$value, 
[13:37:59.430]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:59.430]                   ...future.rng), globalenv = if (FALSE) 
[13:37:59.430]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:59.430]                     ...future.globalenv.names))
[13:37:59.430]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:59.430]         }, condition = base::local({
[13:37:59.430]             c <- base::c
[13:37:59.430]             inherits <- base::inherits
[13:37:59.430]             invokeRestart <- base::invokeRestart
[13:37:59.430]             length <- base::length
[13:37:59.430]             list <- base::list
[13:37:59.430]             seq.int <- base::seq.int
[13:37:59.430]             signalCondition <- base::signalCondition
[13:37:59.430]             sys.calls <- base::sys.calls
[13:37:59.430]             `[[` <- base::`[[`
[13:37:59.430]             `+` <- base::`+`
[13:37:59.430]             `<<-` <- base::`<<-`
[13:37:59.430]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:59.430]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:59.430]                   3L)]
[13:37:59.430]             }
[13:37:59.430]             function(cond) {
[13:37:59.430]                 is_error <- inherits(cond, "error")
[13:37:59.430]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:59.430]                   NULL)
[13:37:59.430]                 if (is_error) {
[13:37:59.430]                   sessionInformation <- function() {
[13:37:59.430]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:59.430]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:59.430]                       search = base::search(), system = base::Sys.info())
[13:37:59.430]                   }
[13:37:59.430]                   ...future.conditions[[length(...future.conditions) + 
[13:37:59.430]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:59.430]                     cond$call), session = sessionInformation(), 
[13:37:59.430]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:59.430]                   signalCondition(cond)
[13:37:59.430]                 }
[13:37:59.430]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:59.430]                 "immediateCondition"))) {
[13:37:59.430]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:59.430]                   ...future.conditions[[length(...future.conditions) + 
[13:37:59.430]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:59.430]                   if (TRUE && !signal) {
[13:37:59.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:59.430]                     {
[13:37:59.430]                       inherits <- base::inherits
[13:37:59.430]                       invokeRestart <- base::invokeRestart
[13:37:59.430]                       is.null <- base::is.null
[13:37:59.430]                       muffled <- FALSE
[13:37:59.430]                       if (inherits(cond, "message")) {
[13:37:59.430]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:59.430]                         if (muffled) 
[13:37:59.430]                           invokeRestart("muffleMessage")
[13:37:59.430]                       }
[13:37:59.430]                       else if (inherits(cond, "warning")) {
[13:37:59.430]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:59.430]                         if (muffled) 
[13:37:59.430]                           invokeRestart("muffleWarning")
[13:37:59.430]                       }
[13:37:59.430]                       else if (inherits(cond, "condition")) {
[13:37:59.430]                         if (!is.null(pattern)) {
[13:37:59.430]                           computeRestarts <- base::computeRestarts
[13:37:59.430]                           grepl <- base::grepl
[13:37:59.430]                           restarts <- computeRestarts(cond)
[13:37:59.430]                           for (restart in restarts) {
[13:37:59.430]                             name <- restart$name
[13:37:59.430]                             if (is.null(name)) 
[13:37:59.430]                               next
[13:37:59.430]                             if (!grepl(pattern, name)) 
[13:37:59.430]                               next
[13:37:59.430]                             invokeRestart(restart)
[13:37:59.430]                             muffled <- TRUE
[13:37:59.430]                             break
[13:37:59.430]                           }
[13:37:59.430]                         }
[13:37:59.430]                       }
[13:37:59.430]                       invisible(muffled)
[13:37:59.430]                     }
[13:37:59.430]                     muffleCondition(cond, pattern = "^muffle")
[13:37:59.430]                   }
[13:37:59.430]                 }
[13:37:59.430]                 else {
[13:37:59.430]                   if (TRUE) {
[13:37:59.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:59.430]                     {
[13:37:59.430]                       inherits <- base::inherits
[13:37:59.430]                       invokeRestart <- base::invokeRestart
[13:37:59.430]                       is.null <- base::is.null
[13:37:59.430]                       muffled <- FALSE
[13:37:59.430]                       if (inherits(cond, "message")) {
[13:37:59.430]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:59.430]                         if (muffled) 
[13:37:59.430]                           invokeRestart("muffleMessage")
[13:37:59.430]                       }
[13:37:59.430]                       else if (inherits(cond, "warning")) {
[13:37:59.430]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:59.430]                         if (muffled) 
[13:37:59.430]                           invokeRestart("muffleWarning")
[13:37:59.430]                       }
[13:37:59.430]                       else if (inherits(cond, "condition")) {
[13:37:59.430]                         if (!is.null(pattern)) {
[13:37:59.430]                           computeRestarts <- base::computeRestarts
[13:37:59.430]                           grepl <- base::grepl
[13:37:59.430]                           restarts <- computeRestarts(cond)
[13:37:59.430]                           for (restart in restarts) {
[13:37:59.430]                             name <- restart$name
[13:37:59.430]                             if (is.null(name)) 
[13:37:59.430]                               next
[13:37:59.430]                             if (!grepl(pattern, name)) 
[13:37:59.430]                               next
[13:37:59.430]                             invokeRestart(restart)
[13:37:59.430]                             muffled <- TRUE
[13:37:59.430]                             break
[13:37:59.430]                           }
[13:37:59.430]                         }
[13:37:59.430]                       }
[13:37:59.430]                       invisible(muffled)
[13:37:59.430]                     }
[13:37:59.430]                     muffleCondition(cond, pattern = "^muffle")
[13:37:59.430]                   }
[13:37:59.430]                 }
[13:37:59.430]             }
[13:37:59.430]         }))
[13:37:59.430]     }, error = function(ex) {
[13:37:59.430]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:59.430]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:59.430]                 ...future.rng), started = ...future.startTime, 
[13:37:59.430]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:59.430]             version = "1.8"), class = "FutureResult")
[13:37:59.430]     }, finally = {
[13:37:59.430]         if (!identical(...future.workdir, getwd())) 
[13:37:59.430]             setwd(...future.workdir)
[13:37:59.430]         {
[13:37:59.430]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:59.430]                 ...future.oldOptions$nwarnings <- NULL
[13:37:59.430]             }
[13:37:59.430]             base::options(...future.oldOptions)
[13:37:59.430]             if (.Platform$OS.type == "windows") {
[13:37:59.430]                 old_names <- names(...future.oldEnvVars)
[13:37:59.430]                 envs <- base::Sys.getenv()
[13:37:59.430]                 names <- names(envs)
[13:37:59.430]                 common <- intersect(names, old_names)
[13:37:59.430]                 added <- setdiff(names, old_names)
[13:37:59.430]                 removed <- setdiff(old_names, names)
[13:37:59.430]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:59.430]                   envs[common]]
[13:37:59.430]                 NAMES <- toupper(changed)
[13:37:59.430]                 args <- list()
[13:37:59.430]                 for (kk in seq_along(NAMES)) {
[13:37:59.430]                   name <- changed[[kk]]
[13:37:59.430]                   NAME <- NAMES[[kk]]
[13:37:59.430]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:59.430]                     next
[13:37:59.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:59.430]                 }
[13:37:59.430]                 NAMES <- toupper(added)
[13:37:59.430]                 for (kk in seq_along(NAMES)) {
[13:37:59.430]                   name <- added[[kk]]
[13:37:59.430]                   NAME <- NAMES[[kk]]
[13:37:59.430]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:59.430]                     next
[13:37:59.430]                   args[[name]] <- ""
[13:37:59.430]                 }
[13:37:59.430]                 NAMES <- toupper(removed)
[13:37:59.430]                 for (kk in seq_along(NAMES)) {
[13:37:59.430]                   name <- removed[[kk]]
[13:37:59.430]                   NAME <- NAMES[[kk]]
[13:37:59.430]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:59.430]                     next
[13:37:59.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:59.430]                 }
[13:37:59.430]                 if (length(args) > 0) 
[13:37:59.430]                   base::do.call(base::Sys.setenv, args = args)
[13:37:59.430]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:59.430]             }
[13:37:59.430]             else {
[13:37:59.430]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:59.430]             }
[13:37:59.430]             {
[13:37:59.430]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:59.430]                   0L) {
[13:37:59.430]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:59.430]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:59.430]                   base::options(opts)
[13:37:59.430]                 }
[13:37:59.430]                 {
[13:37:59.430]                   {
[13:37:59.430]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:59.430]                     NULL
[13:37:59.430]                   }
[13:37:59.430]                   options(future.plan = NULL)
[13:37:59.430]                   if (is.na(NA_character_)) 
[13:37:59.430]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:59.430]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:59.430]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:59.430]                     .init = FALSE)
[13:37:59.430]                 }
[13:37:59.430]             }
[13:37:59.430]         }
[13:37:59.430]     })
[13:37:59.430]     if (TRUE) {
[13:37:59.430]         base::sink(type = "output", split = FALSE)
[13:37:59.430]         if (TRUE) {
[13:37:59.430]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:59.430]         }
[13:37:59.430]         else {
[13:37:59.430]             ...future.result["stdout"] <- base::list(NULL)
[13:37:59.430]         }
[13:37:59.430]         base::close(...future.stdout)
[13:37:59.430]         ...future.stdout <- NULL
[13:37:59.430]     }
[13:37:59.430]     ...future.result$conditions <- ...future.conditions
[13:37:59.430]     ...future.result$finished <- base::Sys.time()
[13:37:59.430]     ...future.result
[13:37:59.430] }
[13:37:59.433] MultisessionFuture started
[13:37:59.433] - Launch lazy future ... done
[13:37:59.433] run() for ‘MultisessionFuture’ ... done
[13:37:59.935] receiveMessageFromWorker() for ClusterFuture ...
[13:37:59.936] - Validating connection of MultisessionFuture
[13:37:59.936] - received message: FutureResult
[13:37:59.936] - Received FutureResult
[13:37:59.936] - Erased future from FutureRegistry
[13:37:59.936] result() for ClusterFuture ...
[13:37:59.936] - result already collected: FutureResult
[13:37:59.936] result() for ClusterFuture ... done
[13:37:59.936] receiveMessageFromWorker() for ClusterFuture ... done
[13:37:59.937] resolve() on list ...
[13:37:59.937]  recursive: Inf
[13:37:59.937]  length: 2
[13:37:59.937]  elements: ‘a’, ‘b’
[13:37:59.937]  length: 1 (resolved future 1)
[13:37:59.937]  length: 0 (resolved future 2)
[13:37:59.937] resolve() on list ... DONE
[13:37:59.937] A MultisessionFuture was resolved (and resolved itself)
[13:37:59.937] getGlobalsAndPackages() ...
[13:37:59.937] Searching for globals...
[13:37:59.939] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:37:59.939] Searching for globals ... DONE
[13:37:59.939] Resolving globals: FALSE
[13:37:59.939] 
[13:37:59.939] 
[13:37:59.939] getGlobalsAndPackages() ... DONE
[13:37:59.940] run() for ‘Future’ ...
[13:37:59.940] - state: ‘created’
[13:37:59.940] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:37:59.953] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:37:59.954] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:37:59.954]   - Field: ‘node’
[13:37:59.954]   - Field: ‘label’
[13:37:59.954]   - Field: ‘local’
[13:37:59.954]   - Field: ‘owner’
[13:37:59.954]   - Field: ‘envir’
[13:37:59.954]   - Field: ‘workers’
[13:37:59.954]   - Field: ‘packages’
[13:37:59.954]   - Field: ‘gc’
[13:37:59.955]   - Field: ‘conditions’
[13:37:59.955]   - Field: ‘persistent’
[13:37:59.955]   - Field: ‘expr’
[13:37:59.955]   - Field: ‘uuid’
[13:37:59.955]   - Field: ‘seed’
[13:37:59.955]   - Field: ‘version’
[13:37:59.955]   - Field: ‘result’
[13:37:59.955]   - Field: ‘asynchronous’
[13:37:59.955]   - Field: ‘calls’
[13:37:59.955]   - Field: ‘globals’
[13:37:59.955]   - Field: ‘stdout’
[13:37:59.956]   - Field: ‘earlySignal’
[13:37:59.956]   - Field: ‘lazy’
[13:37:59.956]   - Field: ‘state’
[13:37:59.956] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:37:59.956] - Launch lazy future ...
[13:37:59.956] Packages needed by the future expression (n = 0): <none>
[13:37:59.956] Packages needed by future strategies (n = 0): <none>
[13:37:59.957] {
[13:37:59.957]     {
[13:37:59.957]         {
[13:37:59.957]             ...future.startTime <- base::Sys.time()
[13:37:59.957]             {
[13:37:59.957]                 {
[13:37:59.957]                   {
[13:37:59.957]                     {
[13:37:59.957]                       base::local({
[13:37:59.957]                         has_future <- base::requireNamespace("future", 
[13:37:59.957]                           quietly = TRUE)
[13:37:59.957]                         if (has_future) {
[13:37:59.957]                           ns <- base::getNamespace("future")
[13:37:59.957]                           version <- ns[[".package"]][["version"]]
[13:37:59.957]                           if (is.null(version)) 
[13:37:59.957]                             version <- utils::packageVersion("future")
[13:37:59.957]                         }
[13:37:59.957]                         else {
[13:37:59.957]                           version <- NULL
[13:37:59.957]                         }
[13:37:59.957]                         if (!has_future || version < "1.8.0") {
[13:37:59.957]                           info <- base::c(r_version = base::gsub("R version ", 
[13:37:59.957]                             "", base::R.version$version.string), 
[13:37:59.957]                             platform = base::sprintf("%s (%s-bit)", 
[13:37:59.957]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:37:59.957]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:37:59.957]                               "release", "version")], collapse = " "), 
[13:37:59.957]                             hostname = base::Sys.info()[["nodename"]])
[13:37:59.957]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:37:59.957]                             info)
[13:37:59.957]                           info <- base::paste(info, collapse = "; ")
[13:37:59.957]                           if (!has_future) {
[13:37:59.957]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:37:59.957]                               info)
[13:37:59.957]                           }
[13:37:59.957]                           else {
[13:37:59.957]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:37:59.957]                               info, version)
[13:37:59.957]                           }
[13:37:59.957]                           base::stop(msg)
[13:37:59.957]                         }
[13:37:59.957]                       })
[13:37:59.957]                     }
[13:37:59.957]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:37:59.957]                     base::options(mc.cores = 1L)
[13:37:59.957]                   }
[13:37:59.957]                   ...future.strategy.old <- future::plan("list")
[13:37:59.957]                   options(future.plan = NULL)
[13:37:59.957]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:37:59.957]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:37:59.957]                 }
[13:37:59.957]                 ...future.workdir <- getwd()
[13:37:59.957]             }
[13:37:59.957]             ...future.oldOptions <- base::as.list(base::.Options)
[13:37:59.957]             ...future.oldEnvVars <- base::Sys.getenv()
[13:37:59.957]         }
[13:37:59.957]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:37:59.957]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:37:59.957]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:37:59.957]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:37:59.957]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:37:59.957]             future.stdout.windows.reencode = NULL, width = 80L)
[13:37:59.957]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:37:59.957]             base::names(...future.oldOptions))
[13:37:59.957]     }
[13:37:59.957]     if (FALSE) {
[13:37:59.957]     }
[13:37:59.957]     else {
[13:37:59.957]         if (TRUE) {
[13:37:59.957]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:37:59.957]                 open = "w")
[13:37:59.957]         }
[13:37:59.957]         else {
[13:37:59.957]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:37:59.957]                 windows = "NUL", "/dev/null"), open = "w")
[13:37:59.957]         }
[13:37:59.957]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:37:59.957]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:37:59.957]             base::sink(type = "output", split = FALSE)
[13:37:59.957]             base::close(...future.stdout)
[13:37:59.957]         }, add = TRUE)
[13:37:59.957]     }
[13:37:59.957]     ...future.frame <- base::sys.nframe()
[13:37:59.957]     ...future.conditions <- base::list()
[13:37:59.957]     ...future.rng <- base::globalenv()$.Random.seed
[13:37:59.957]     if (FALSE) {
[13:37:59.957]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:37:59.957]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:37:59.957]     }
[13:37:59.957]     ...future.result <- base::tryCatch({
[13:37:59.957]         base::withCallingHandlers({
[13:37:59.957]             ...future.value <- base::withVisible(base::local({
[13:37:59.957]                 ...future.makeSendCondition <- base::local({
[13:37:59.957]                   sendCondition <- NULL
[13:37:59.957]                   function(frame = 1L) {
[13:37:59.957]                     if (is.function(sendCondition)) 
[13:37:59.957]                       return(sendCondition)
[13:37:59.957]                     ns <- getNamespace("parallel")
[13:37:59.957]                     if (exists("sendData", mode = "function", 
[13:37:59.957]                       envir = ns)) {
[13:37:59.957]                       parallel_sendData <- get("sendData", mode = "function", 
[13:37:59.957]                         envir = ns)
[13:37:59.957]                       envir <- sys.frame(frame)
[13:37:59.957]                       master <- NULL
[13:37:59.957]                       while (!identical(envir, .GlobalEnv) && 
[13:37:59.957]                         !identical(envir, emptyenv())) {
[13:37:59.957]                         if (exists("master", mode = "list", envir = envir, 
[13:37:59.957]                           inherits = FALSE)) {
[13:37:59.957]                           master <- get("master", mode = "list", 
[13:37:59.957]                             envir = envir, inherits = FALSE)
[13:37:59.957]                           if (inherits(master, c("SOCKnode", 
[13:37:59.957]                             "SOCK0node"))) {
[13:37:59.957]                             sendCondition <<- function(cond) {
[13:37:59.957]                               data <- list(type = "VALUE", value = cond, 
[13:37:59.957]                                 success = TRUE)
[13:37:59.957]                               parallel_sendData(master, data)
[13:37:59.957]                             }
[13:37:59.957]                             return(sendCondition)
[13:37:59.957]                           }
[13:37:59.957]                         }
[13:37:59.957]                         frame <- frame + 1L
[13:37:59.957]                         envir <- sys.frame(frame)
[13:37:59.957]                       }
[13:37:59.957]                     }
[13:37:59.957]                     sendCondition <<- function(cond) NULL
[13:37:59.957]                   }
[13:37:59.957]                 })
[13:37:59.957]                 withCallingHandlers({
[13:37:59.957]                   {
[13:37:59.957]                     Sys.sleep(0.5)
[13:37:59.957]                     list(a = 1, b = 42L)
[13:37:59.957]                   }
[13:37:59.957]                 }, immediateCondition = function(cond) {
[13:37:59.957]                   sendCondition <- ...future.makeSendCondition()
[13:37:59.957]                   sendCondition(cond)
[13:37:59.957]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:59.957]                   {
[13:37:59.957]                     inherits <- base::inherits
[13:37:59.957]                     invokeRestart <- base::invokeRestart
[13:37:59.957]                     is.null <- base::is.null
[13:37:59.957]                     muffled <- FALSE
[13:37:59.957]                     if (inherits(cond, "message")) {
[13:37:59.957]                       muffled <- grepl(pattern, "muffleMessage")
[13:37:59.957]                       if (muffled) 
[13:37:59.957]                         invokeRestart("muffleMessage")
[13:37:59.957]                     }
[13:37:59.957]                     else if (inherits(cond, "warning")) {
[13:37:59.957]                       muffled <- grepl(pattern, "muffleWarning")
[13:37:59.957]                       if (muffled) 
[13:37:59.957]                         invokeRestart("muffleWarning")
[13:37:59.957]                     }
[13:37:59.957]                     else if (inherits(cond, "condition")) {
[13:37:59.957]                       if (!is.null(pattern)) {
[13:37:59.957]                         computeRestarts <- base::computeRestarts
[13:37:59.957]                         grepl <- base::grepl
[13:37:59.957]                         restarts <- computeRestarts(cond)
[13:37:59.957]                         for (restart in restarts) {
[13:37:59.957]                           name <- restart$name
[13:37:59.957]                           if (is.null(name)) 
[13:37:59.957]                             next
[13:37:59.957]                           if (!grepl(pattern, name)) 
[13:37:59.957]                             next
[13:37:59.957]                           invokeRestart(restart)
[13:37:59.957]                           muffled <- TRUE
[13:37:59.957]                           break
[13:37:59.957]                         }
[13:37:59.957]                       }
[13:37:59.957]                     }
[13:37:59.957]                     invisible(muffled)
[13:37:59.957]                   }
[13:37:59.957]                   muffleCondition(cond)
[13:37:59.957]                 })
[13:37:59.957]             }))
[13:37:59.957]             future::FutureResult(value = ...future.value$value, 
[13:37:59.957]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:59.957]                   ...future.rng), globalenv = if (FALSE) 
[13:37:59.957]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:37:59.957]                     ...future.globalenv.names))
[13:37:59.957]                 else NULL, started = ...future.startTime, version = "1.8")
[13:37:59.957]         }, condition = base::local({
[13:37:59.957]             c <- base::c
[13:37:59.957]             inherits <- base::inherits
[13:37:59.957]             invokeRestart <- base::invokeRestart
[13:37:59.957]             length <- base::length
[13:37:59.957]             list <- base::list
[13:37:59.957]             seq.int <- base::seq.int
[13:37:59.957]             signalCondition <- base::signalCondition
[13:37:59.957]             sys.calls <- base::sys.calls
[13:37:59.957]             `[[` <- base::`[[`
[13:37:59.957]             `+` <- base::`+`
[13:37:59.957]             `<<-` <- base::`<<-`
[13:37:59.957]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:37:59.957]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:37:59.957]                   3L)]
[13:37:59.957]             }
[13:37:59.957]             function(cond) {
[13:37:59.957]                 is_error <- inherits(cond, "error")
[13:37:59.957]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:37:59.957]                   NULL)
[13:37:59.957]                 if (is_error) {
[13:37:59.957]                   sessionInformation <- function() {
[13:37:59.957]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:37:59.957]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:37:59.957]                       search = base::search(), system = base::Sys.info())
[13:37:59.957]                   }
[13:37:59.957]                   ...future.conditions[[length(...future.conditions) + 
[13:37:59.957]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:37:59.957]                     cond$call), session = sessionInformation(), 
[13:37:59.957]                     timestamp = base::Sys.time(), signaled = 0L)
[13:37:59.957]                   signalCondition(cond)
[13:37:59.957]                 }
[13:37:59.957]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:37:59.957]                 "immediateCondition"))) {
[13:37:59.957]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:37:59.957]                   ...future.conditions[[length(...future.conditions) + 
[13:37:59.957]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:37:59.957]                   if (TRUE && !signal) {
[13:37:59.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:59.957]                     {
[13:37:59.957]                       inherits <- base::inherits
[13:37:59.957]                       invokeRestart <- base::invokeRestart
[13:37:59.957]                       is.null <- base::is.null
[13:37:59.957]                       muffled <- FALSE
[13:37:59.957]                       if (inherits(cond, "message")) {
[13:37:59.957]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:59.957]                         if (muffled) 
[13:37:59.957]                           invokeRestart("muffleMessage")
[13:37:59.957]                       }
[13:37:59.957]                       else if (inherits(cond, "warning")) {
[13:37:59.957]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:59.957]                         if (muffled) 
[13:37:59.957]                           invokeRestart("muffleWarning")
[13:37:59.957]                       }
[13:37:59.957]                       else if (inherits(cond, "condition")) {
[13:37:59.957]                         if (!is.null(pattern)) {
[13:37:59.957]                           computeRestarts <- base::computeRestarts
[13:37:59.957]                           grepl <- base::grepl
[13:37:59.957]                           restarts <- computeRestarts(cond)
[13:37:59.957]                           for (restart in restarts) {
[13:37:59.957]                             name <- restart$name
[13:37:59.957]                             if (is.null(name)) 
[13:37:59.957]                               next
[13:37:59.957]                             if (!grepl(pattern, name)) 
[13:37:59.957]                               next
[13:37:59.957]                             invokeRestart(restart)
[13:37:59.957]                             muffled <- TRUE
[13:37:59.957]                             break
[13:37:59.957]                           }
[13:37:59.957]                         }
[13:37:59.957]                       }
[13:37:59.957]                       invisible(muffled)
[13:37:59.957]                     }
[13:37:59.957]                     muffleCondition(cond, pattern = "^muffle")
[13:37:59.957]                   }
[13:37:59.957]                 }
[13:37:59.957]                 else {
[13:37:59.957]                   if (TRUE) {
[13:37:59.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:37:59.957]                     {
[13:37:59.957]                       inherits <- base::inherits
[13:37:59.957]                       invokeRestart <- base::invokeRestart
[13:37:59.957]                       is.null <- base::is.null
[13:37:59.957]                       muffled <- FALSE
[13:37:59.957]                       if (inherits(cond, "message")) {
[13:37:59.957]                         muffled <- grepl(pattern, "muffleMessage")
[13:37:59.957]                         if (muffled) 
[13:37:59.957]                           invokeRestart("muffleMessage")
[13:37:59.957]                       }
[13:37:59.957]                       else if (inherits(cond, "warning")) {
[13:37:59.957]                         muffled <- grepl(pattern, "muffleWarning")
[13:37:59.957]                         if (muffled) 
[13:37:59.957]                           invokeRestart("muffleWarning")
[13:37:59.957]                       }
[13:37:59.957]                       else if (inherits(cond, "condition")) {
[13:37:59.957]                         if (!is.null(pattern)) {
[13:37:59.957]                           computeRestarts <- base::computeRestarts
[13:37:59.957]                           grepl <- base::grepl
[13:37:59.957]                           restarts <- computeRestarts(cond)
[13:37:59.957]                           for (restart in restarts) {
[13:37:59.957]                             name <- restart$name
[13:37:59.957]                             if (is.null(name)) 
[13:37:59.957]                               next
[13:37:59.957]                             if (!grepl(pattern, name)) 
[13:37:59.957]                               next
[13:37:59.957]                             invokeRestart(restart)
[13:37:59.957]                             muffled <- TRUE
[13:37:59.957]                             break
[13:37:59.957]                           }
[13:37:59.957]                         }
[13:37:59.957]                       }
[13:37:59.957]                       invisible(muffled)
[13:37:59.957]                     }
[13:37:59.957]                     muffleCondition(cond, pattern = "^muffle")
[13:37:59.957]                   }
[13:37:59.957]                 }
[13:37:59.957]             }
[13:37:59.957]         }))
[13:37:59.957]     }, error = function(ex) {
[13:37:59.957]         base::structure(base::list(value = NULL, visible = NULL, 
[13:37:59.957]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:37:59.957]                 ...future.rng), started = ...future.startTime, 
[13:37:59.957]             finished = Sys.time(), session_uuid = NA_character_, 
[13:37:59.957]             version = "1.8"), class = "FutureResult")
[13:37:59.957]     }, finally = {
[13:37:59.957]         if (!identical(...future.workdir, getwd())) 
[13:37:59.957]             setwd(...future.workdir)
[13:37:59.957]         {
[13:37:59.957]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:37:59.957]                 ...future.oldOptions$nwarnings <- NULL
[13:37:59.957]             }
[13:37:59.957]             base::options(...future.oldOptions)
[13:37:59.957]             if (.Platform$OS.type == "windows") {
[13:37:59.957]                 old_names <- names(...future.oldEnvVars)
[13:37:59.957]                 envs <- base::Sys.getenv()
[13:37:59.957]                 names <- names(envs)
[13:37:59.957]                 common <- intersect(names, old_names)
[13:37:59.957]                 added <- setdiff(names, old_names)
[13:37:59.957]                 removed <- setdiff(old_names, names)
[13:37:59.957]                 changed <- common[...future.oldEnvVars[common] != 
[13:37:59.957]                   envs[common]]
[13:37:59.957]                 NAMES <- toupper(changed)
[13:37:59.957]                 args <- list()
[13:37:59.957]                 for (kk in seq_along(NAMES)) {
[13:37:59.957]                   name <- changed[[kk]]
[13:37:59.957]                   NAME <- NAMES[[kk]]
[13:37:59.957]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:59.957]                     next
[13:37:59.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:59.957]                 }
[13:37:59.957]                 NAMES <- toupper(added)
[13:37:59.957]                 for (kk in seq_along(NAMES)) {
[13:37:59.957]                   name <- added[[kk]]
[13:37:59.957]                   NAME <- NAMES[[kk]]
[13:37:59.957]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:59.957]                     next
[13:37:59.957]                   args[[name]] <- ""
[13:37:59.957]                 }
[13:37:59.957]                 NAMES <- toupper(removed)
[13:37:59.957]                 for (kk in seq_along(NAMES)) {
[13:37:59.957]                   name <- removed[[kk]]
[13:37:59.957]                   NAME <- NAMES[[kk]]
[13:37:59.957]                   if (name != NAME && is.element(NAME, old_names)) 
[13:37:59.957]                     next
[13:37:59.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:37:59.957]                 }
[13:37:59.957]                 if (length(args) > 0) 
[13:37:59.957]                   base::do.call(base::Sys.setenv, args = args)
[13:37:59.957]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:37:59.957]             }
[13:37:59.957]             else {
[13:37:59.957]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:37:59.957]             }
[13:37:59.957]             {
[13:37:59.957]                 if (base::length(...future.futureOptionsAdded) > 
[13:37:59.957]                   0L) {
[13:37:59.957]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:37:59.957]                   base::names(opts) <- ...future.futureOptionsAdded
[13:37:59.957]                   base::options(opts)
[13:37:59.957]                 }
[13:37:59.957]                 {
[13:37:59.957]                   {
[13:37:59.957]                     base::options(mc.cores = ...future.mc.cores.old)
[13:37:59.957]                     NULL
[13:37:59.957]                   }
[13:37:59.957]                   options(future.plan = NULL)
[13:37:59.957]                   if (is.na(NA_character_)) 
[13:37:59.957]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:37:59.957]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:37:59.957]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:37:59.957]                     .init = FALSE)
[13:37:59.957]                 }
[13:37:59.957]             }
[13:37:59.957]         }
[13:37:59.957]     })
[13:37:59.957]     if (TRUE) {
[13:37:59.957]         base::sink(type = "output", split = FALSE)
[13:37:59.957]         if (TRUE) {
[13:37:59.957]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:37:59.957]         }
[13:37:59.957]         else {
[13:37:59.957]             ...future.result["stdout"] <- base::list(NULL)
[13:37:59.957]         }
[13:37:59.957]         base::close(...future.stdout)
[13:37:59.957]         ...future.stdout <- NULL
[13:37:59.957]     }
[13:37:59.957]     ...future.result$conditions <- ...future.conditions
[13:37:59.957]     ...future.result$finished <- base::Sys.time()
[13:37:59.957]     ...future.result
[13:37:59.957] }
[13:37:59.960] MultisessionFuture started
[13:37:59.960] - Launch lazy future ... done
[13:37:59.960] run() for ‘MultisessionFuture’ ... done
[13:38:00.462] receiveMessageFromWorker() for ClusterFuture ...
[13:38:00.463] - Validating connection of MultisessionFuture
[13:38:00.463] - received message: FutureResult
[13:38:00.463] - Received FutureResult
[13:38:00.463] - Erased future from FutureRegistry
[13:38:00.463] result() for ClusterFuture ...
[13:38:00.463] - result already collected: FutureResult
[13:38:00.463] result() for ClusterFuture ... done
[13:38:00.464] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:00.464] resolve() on list ...
[13:38:00.464]  recursive: Inf
[13:38:00.464]  length: 2
[13:38:00.464]  elements: ‘a’, ‘b’
[13:38:00.464]  length: 1 (resolved future 1)
[13:38:00.464]  length: 0 (resolved future 2)
[13:38:00.464] resolve() on list ... DONE
[13:38:00.464] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[13:38:00.464] getGlobalsAndPackages() ...
[13:38:00.465] Searching for globals...
[13:38:00.465] - globals found: [2] ‘list’, ‘stop’
[13:38:00.465] Searching for globals ... DONE
[13:38:00.465] Resolving globals: FALSE
[13:38:00.466] 
[13:38:00.466] 
[13:38:00.466] getGlobalsAndPackages() ... DONE
[13:38:00.466] run() for ‘Future’ ...
[13:38:00.466] - state: ‘created’
[13:38:00.466] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:00.480] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:00.480] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:00.480]   - Field: ‘node’
[13:38:00.481]   - Field: ‘label’
[13:38:00.481]   - Field: ‘local’
[13:38:00.481]   - Field: ‘owner’
[13:38:00.481]   - Field: ‘envir’
[13:38:00.481]   - Field: ‘workers’
[13:38:00.481]   - Field: ‘packages’
[13:38:00.481]   - Field: ‘gc’
[13:38:00.481]   - Field: ‘conditions’
[13:38:00.481]   - Field: ‘persistent’
[13:38:00.481]   - Field: ‘expr’
[13:38:00.481]   - Field: ‘uuid’
[13:38:00.482]   - Field: ‘seed’
[13:38:00.482]   - Field: ‘version’
[13:38:00.482]   - Field: ‘result’
[13:38:00.482]   - Field: ‘asynchronous’
[13:38:00.482]   - Field: ‘calls’
[13:38:00.482]   - Field: ‘globals’
[13:38:00.482]   - Field: ‘stdout’
[13:38:00.482]   - Field: ‘earlySignal’
[13:38:00.482]   - Field: ‘lazy’
[13:38:00.482]   - Field: ‘state’
[13:38:00.482] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:00.483] - Launch lazy future ...
[13:38:00.483] Packages needed by the future expression (n = 0): <none>
[13:38:00.483] Packages needed by future strategies (n = 0): <none>
[13:38:00.483] {
[13:38:00.483]     {
[13:38:00.483]         {
[13:38:00.483]             ...future.startTime <- base::Sys.time()
[13:38:00.483]             {
[13:38:00.483]                 {
[13:38:00.483]                   {
[13:38:00.483]                     {
[13:38:00.483]                       base::local({
[13:38:00.483]                         has_future <- base::requireNamespace("future", 
[13:38:00.483]                           quietly = TRUE)
[13:38:00.483]                         if (has_future) {
[13:38:00.483]                           ns <- base::getNamespace("future")
[13:38:00.483]                           version <- ns[[".package"]][["version"]]
[13:38:00.483]                           if (is.null(version)) 
[13:38:00.483]                             version <- utils::packageVersion("future")
[13:38:00.483]                         }
[13:38:00.483]                         else {
[13:38:00.483]                           version <- NULL
[13:38:00.483]                         }
[13:38:00.483]                         if (!has_future || version < "1.8.0") {
[13:38:00.483]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:00.483]                             "", base::R.version$version.string), 
[13:38:00.483]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:00.483]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:00.483]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:00.483]                               "release", "version")], collapse = " "), 
[13:38:00.483]                             hostname = base::Sys.info()[["nodename"]])
[13:38:00.483]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:00.483]                             info)
[13:38:00.483]                           info <- base::paste(info, collapse = "; ")
[13:38:00.483]                           if (!has_future) {
[13:38:00.483]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:00.483]                               info)
[13:38:00.483]                           }
[13:38:00.483]                           else {
[13:38:00.483]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:00.483]                               info, version)
[13:38:00.483]                           }
[13:38:00.483]                           base::stop(msg)
[13:38:00.483]                         }
[13:38:00.483]                       })
[13:38:00.483]                     }
[13:38:00.483]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:00.483]                     base::options(mc.cores = 1L)
[13:38:00.483]                   }
[13:38:00.483]                   ...future.strategy.old <- future::plan("list")
[13:38:00.483]                   options(future.plan = NULL)
[13:38:00.483]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:00.483]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:00.483]                 }
[13:38:00.483]                 ...future.workdir <- getwd()
[13:38:00.483]             }
[13:38:00.483]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:00.483]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:00.483]         }
[13:38:00.483]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:00.483]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:00.483]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:00.483]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:00.483]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:00.483]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:00.483]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:00.483]             base::names(...future.oldOptions))
[13:38:00.483]     }
[13:38:00.483]     if (FALSE) {
[13:38:00.483]     }
[13:38:00.483]     else {
[13:38:00.483]         if (TRUE) {
[13:38:00.483]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:00.483]                 open = "w")
[13:38:00.483]         }
[13:38:00.483]         else {
[13:38:00.483]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:00.483]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:00.483]         }
[13:38:00.483]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:00.483]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:00.483]             base::sink(type = "output", split = FALSE)
[13:38:00.483]             base::close(...future.stdout)
[13:38:00.483]         }, add = TRUE)
[13:38:00.483]     }
[13:38:00.483]     ...future.frame <- base::sys.nframe()
[13:38:00.483]     ...future.conditions <- base::list()
[13:38:00.483]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:00.483]     if (FALSE) {
[13:38:00.483]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:00.483]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:00.483]     }
[13:38:00.483]     ...future.result <- base::tryCatch({
[13:38:00.483]         base::withCallingHandlers({
[13:38:00.483]             ...future.value <- base::withVisible(base::local({
[13:38:00.483]                 ...future.makeSendCondition <- base::local({
[13:38:00.483]                   sendCondition <- NULL
[13:38:00.483]                   function(frame = 1L) {
[13:38:00.483]                     if (is.function(sendCondition)) 
[13:38:00.483]                       return(sendCondition)
[13:38:00.483]                     ns <- getNamespace("parallel")
[13:38:00.483]                     if (exists("sendData", mode = "function", 
[13:38:00.483]                       envir = ns)) {
[13:38:00.483]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:00.483]                         envir = ns)
[13:38:00.483]                       envir <- sys.frame(frame)
[13:38:00.483]                       master <- NULL
[13:38:00.483]                       while (!identical(envir, .GlobalEnv) && 
[13:38:00.483]                         !identical(envir, emptyenv())) {
[13:38:00.483]                         if (exists("master", mode = "list", envir = envir, 
[13:38:00.483]                           inherits = FALSE)) {
[13:38:00.483]                           master <- get("master", mode = "list", 
[13:38:00.483]                             envir = envir, inherits = FALSE)
[13:38:00.483]                           if (inherits(master, c("SOCKnode", 
[13:38:00.483]                             "SOCK0node"))) {
[13:38:00.483]                             sendCondition <<- function(cond) {
[13:38:00.483]                               data <- list(type = "VALUE", value = cond, 
[13:38:00.483]                                 success = TRUE)
[13:38:00.483]                               parallel_sendData(master, data)
[13:38:00.483]                             }
[13:38:00.483]                             return(sendCondition)
[13:38:00.483]                           }
[13:38:00.483]                         }
[13:38:00.483]                         frame <- frame + 1L
[13:38:00.483]                         envir <- sys.frame(frame)
[13:38:00.483]                       }
[13:38:00.483]                     }
[13:38:00.483]                     sendCondition <<- function(cond) NULL
[13:38:00.483]                   }
[13:38:00.483]                 })
[13:38:00.483]                 withCallingHandlers({
[13:38:00.483]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:38:00.483]                 }, immediateCondition = function(cond) {
[13:38:00.483]                   sendCondition <- ...future.makeSendCondition()
[13:38:00.483]                   sendCondition(cond)
[13:38:00.483]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.483]                   {
[13:38:00.483]                     inherits <- base::inherits
[13:38:00.483]                     invokeRestart <- base::invokeRestart
[13:38:00.483]                     is.null <- base::is.null
[13:38:00.483]                     muffled <- FALSE
[13:38:00.483]                     if (inherits(cond, "message")) {
[13:38:00.483]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:00.483]                       if (muffled) 
[13:38:00.483]                         invokeRestart("muffleMessage")
[13:38:00.483]                     }
[13:38:00.483]                     else if (inherits(cond, "warning")) {
[13:38:00.483]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:00.483]                       if (muffled) 
[13:38:00.483]                         invokeRestart("muffleWarning")
[13:38:00.483]                     }
[13:38:00.483]                     else if (inherits(cond, "condition")) {
[13:38:00.483]                       if (!is.null(pattern)) {
[13:38:00.483]                         computeRestarts <- base::computeRestarts
[13:38:00.483]                         grepl <- base::grepl
[13:38:00.483]                         restarts <- computeRestarts(cond)
[13:38:00.483]                         for (restart in restarts) {
[13:38:00.483]                           name <- restart$name
[13:38:00.483]                           if (is.null(name)) 
[13:38:00.483]                             next
[13:38:00.483]                           if (!grepl(pattern, name)) 
[13:38:00.483]                             next
[13:38:00.483]                           invokeRestart(restart)
[13:38:00.483]                           muffled <- TRUE
[13:38:00.483]                           break
[13:38:00.483]                         }
[13:38:00.483]                       }
[13:38:00.483]                     }
[13:38:00.483]                     invisible(muffled)
[13:38:00.483]                   }
[13:38:00.483]                   muffleCondition(cond)
[13:38:00.483]                 })
[13:38:00.483]             }))
[13:38:00.483]             future::FutureResult(value = ...future.value$value, 
[13:38:00.483]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:00.483]                   ...future.rng), globalenv = if (FALSE) 
[13:38:00.483]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:00.483]                     ...future.globalenv.names))
[13:38:00.483]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:00.483]         }, condition = base::local({
[13:38:00.483]             c <- base::c
[13:38:00.483]             inherits <- base::inherits
[13:38:00.483]             invokeRestart <- base::invokeRestart
[13:38:00.483]             length <- base::length
[13:38:00.483]             list <- base::list
[13:38:00.483]             seq.int <- base::seq.int
[13:38:00.483]             signalCondition <- base::signalCondition
[13:38:00.483]             sys.calls <- base::sys.calls
[13:38:00.483]             `[[` <- base::`[[`
[13:38:00.483]             `+` <- base::`+`
[13:38:00.483]             `<<-` <- base::`<<-`
[13:38:00.483]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:00.483]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:00.483]                   3L)]
[13:38:00.483]             }
[13:38:00.483]             function(cond) {
[13:38:00.483]                 is_error <- inherits(cond, "error")
[13:38:00.483]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:00.483]                   NULL)
[13:38:00.483]                 if (is_error) {
[13:38:00.483]                   sessionInformation <- function() {
[13:38:00.483]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:00.483]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:00.483]                       search = base::search(), system = base::Sys.info())
[13:38:00.483]                   }
[13:38:00.483]                   ...future.conditions[[length(...future.conditions) + 
[13:38:00.483]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:00.483]                     cond$call), session = sessionInformation(), 
[13:38:00.483]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:00.483]                   signalCondition(cond)
[13:38:00.483]                 }
[13:38:00.483]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:00.483]                 "immediateCondition"))) {
[13:38:00.483]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:00.483]                   ...future.conditions[[length(...future.conditions) + 
[13:38:00.483]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:00.483]                   if (TRUE && !signal) {
[13:38:00.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.483]                     {
[13:38:00.483]                       inherits <- base::inherits
[13:38:00.483]                       invokeRestart <- base::invokeRestart
[13:38:00.483]                       is.null <- base::is.null
[13:38:00.483]                       muffled <- FALSE
[13:38:00.483]                       if (inherits(cond, "message")) {
[13:38:00.483]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:00.483]                         if (muffled) 
[13:38:00.483]                           invokeRestart("muffleMessage")
[13:38:00.483]                       }
[13:38:00.483]                       else if (inherits(cond, "warning")) {
[13:38:00.483]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:00.483]                         if (muffled) 
[13:38:00.483]                           invokeRestart("muffleWarning")
[13:38:00.483]                       }
[13:38:00.483]                       else if (inherits(cond, "condition")) {
[13:38:00.483]                         if (!is.null(pattern)) {
[13:38:00.483]                           computeRestarts <- base::computeRestarts
[13:38:00.483]                           grepl <- base::grepl
[13:38:00.483]                           restarts <- computeRestarts(cond)
[13:38:00.483]                           for (restart in restarts) {
[13:38:00.483]                             name <- restart$name
[13:38:00.483]                             if (is.null(name)) 
[13:38:00.483]                               next
[13:38:00.483]                             if (!grepl(pattern, name)) 
[13:38:00.483]                               next
[13:38:00.483]                             invokeRestart(restart)
[13:38:00.483]                             muffled <- TRUE
[13:38:00.483]                             break
[13:38:00.483]                           }
[13:38:00.483]                         }
[13:38:00.483]                       }
[13:38:00.483]                       invisible(muffled)
[13:38:00.483]                     }
[13:38:00.483]                     muffleCondition(cond, pattern = "^muffle")
[13:38:00.483]                   }
[13:38:00.483]                 }
[13:38:00.483]                 else {
[13:38:00.483]                   if (TRUE) {
[13:38:00.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.483]                     {
[13:38:00.483]                       inherits <- base::inherits
[13:38:00.483]                       invokeRestart <- base::invokeRestart
[13:38:00.483]                       is.null <- base::is.null
[13:38:00.483]                       muffled <- FALSE
[13:38:00.483]                       if (inherits(cond, "message")) {
[13:38:00.483]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:00.483]                         if (muffled) 
[13:38:00.483]                           invokeRestart("muffleMessage")
[13:38:00.483]                       }
[13:38:00.483]                       else if (inherits(cond, "warning")) {
[13:38:00.483]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:00.483]                         if (muffled) 
[13:38:00.483]                           invokeRestart("muffleWarning")
[13:38:00.483]                       }
[13:38:00.483]                       else if (inherits(cond, "condition")) {
[13:38:00.483]                         if (!is.null(pattern)) {
[13:38:00.483]                           computeRestarts <- base::computeRestarts
[13:38:00.483]                           grepl <- base::grepl
[13:38:00.483]                           restarts <- computeRestarts(cond)
[13:38:00.483]                           for (restart in restarts) {
[13:38:00.483]                             name <- restart$name
[13:38:00.483]                             if (is.null(name)) 
[13:38:00.483]                               next
[13:38:00.483]                             if (!grepl(pattern, name)) 
[13:38:00.483]                               next
[13:38:00.483]                             invokeRestart(restart)
[13:38:00.483]                             muffled <- TRUE
[13:38:00.483]                             break
[13:38:00.483]                           }
[13:38:00.483]                         }
[13:38:00.483]                       }
[13:38:00.483]                       invisible(muffled)
[13:38:00.483]                     }
[13:38:00.483]                     muffleCondition(cond, pattern = "^muffle")
[13:38:00.483]                   }
[13:38:00.483]                 }
[13:38:00.483]             }
[13:38:00.483]         }))
[13:38:00.483]     }, error = function(ex) {
[13:38:00.483]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:00.483]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:00.483]                 ...future.rng), started = ...future.startTime, 
[13:38:00.483]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:00.483]             version = "1.8"), class = "FutureResult")
[13:38:00.483]     }, finally = {
[13:38:00.483]         if (!identical(...future.workdir, getwd())) 
[13:38:00.483]             setwd(...future.workdir)
[13:38:00.483]         {
[13:38:00.483]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:00.483]                 ...future.oldOptions$nwarnings <- NULL
[13:38:00.483]             }
[13:38:00.483]             base::options(...future.oldOptions)
[13:38:00.483]             if (.Platform$OS.type == "windows") {
[13:38:00.483]                 old_names <- names(...future.oldEnvVars)
[13:38:00.483]                 envs <- base::Sys.getenv()
[13:38:00.483]                 names <- names(envs)
[13:38:00.483]                 common <- intersect(names, old_names)
[13:38:00.483]                 added <- setdiff(names, old_names)
[13:38:00.483]                 removed <- setdiff(old_names, names)
[13:38:00.483]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:00.483]                   envs[common]]
[13:38:00.483]                 NAMES <- toupper(changed)
[13:38:00.483]                 args <- list()
[13:38:00.483]                 for (kk in seq_along(NAMES)) {
[13:38:00.483]                   name <- changed[[kk]]
[13:38:00.483]                   NAME <- NAMES[[kk]]
[13:38:00.483]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.483]                     next
[13:38:00.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:00.483]                 }
[13:38:00.483]                 NAMES <- toupper(added)
[13:38:00.483]                 for (kk in seq_along(NAMES)) {
[13:38:00.483]                   name <- added[[kk]]
[13:38:00.483]                   NAME <- NAMES[[kk]]
[13:38:00.483]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.483]                     next
[13:38:00.483]                   args[[name]] <- ""
[13:38:00.483]                 }
[13:38:00.483]                 NAMES <- toupper(removed)
[13:38:00.483]                 for (kk in seq_along(NAMES)) {
[13:38:00.483]                   name <- removed[[kk]]
[13:38:00.483]                   NAME <- NAMES[[kk]]
[13:38:00.483]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.483]                     next
[13:38:00.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:00.483]                 }
[13:38:00.483]                 if (length(args) > 0) 
[13:38:00.483]                   base::do.call(base::Sys.setenv, args = args)
[13:38:00.483]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:00.483]             }
[13:38:00.483]             else {
[13:38:00.483]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:00.483]             }
[13:38:00.483]             {
[13:38:00.483]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:00.483]                   0L) {
[13:38:00.483]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:00.483]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:00.483]                   base::options(opts)
[13:38:00.483]                 }
[13:38:00.483]                 {
[13:38:00.483]                   {
[13:38:00.483]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:00.483]                     NULL
[13:38:00.483]                   }
[13:38:00.483]                   options(future.plan = NULL)
[13:38:00.483]                   if (is.na(NA_character_)) 
[13:38:00.483]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:00.483]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:00.483]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:00.483]                     .init = FALSE)
[13:38:00.483]                 }
[13:38:00.483]             }
[13:38:00.483]         }
[13:38:00.483]     })
[13:38:00.483]     if (TRUE) {
[13:38:00.483]         base::sink(type = "output", split = FALSE)
[13:38:00.483]         if (TRUE) {
[13:38:00.483]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:00.483]         }
[13:38:00.483]         else {
[13:38:00.483]             ...future.result["stdout"] <- base::list(NULL)
[13:38:00.483]         }
[13:38:00.483]         base::close(...future.stdout)
[13:38:00.483]         ...future.stdout <- NULL
[13:38:00.483]     }
[13:38:00.483]     ...future.result$conditions <- ...future.conditions
[13:38:00.483]     ...future.result$finished <- base::Sys.time()
[13:38:00.483]     ...future.result
[13:38:00.483] }
[13:38:00.486] MultisessionFuture started
[13:38:00.486] - Launch lazy future ... done
[13:38:00.487] run() for ‘MultisessionFuture’ ... done
[13:38:00.488] receiveMessageFromWorker() for ClusterFuture ...
[13:38:00.488] - Validating connection of MultisessionFuture
[13:38:00.489] - received message: FutureResult
[13:38:00.489] - Received FutureResult
[13:38:00.489] - Erased future from FutureRegistry
[13:38:00.489] result() for ClusterFuture ...
[13:38:00.489] - result already collected: FutureResult
[13:38:00.489] result() for ClusterFuture ... done
[13:38:00.489] signalConditions() ...
[13:38:00.489]  - include = ‘immediateCondition’
[13:38:00.489]  - exclude = 
[13:38:00.489]  - resignal = FALSE
[13:38:00.489]  - Number of conditions: 1
[13:38:00.490] signalConditions() ... done
[13:38:00.490] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:00.490] A MultisessionFuture was resolved
[13:38:00.490] getGlobalsAndPackages() ...
[13:38:00.490] Searching for globals...
[13:38:00.491] - globals found: [2] ‘list’, ‘stop’
[13:38:00.491] Searching for globals ... DONE
[13:38:00.491] Resolving globals: FALSE
[13:38:00.491] 
[13:38:00.491] 
[13:38:00.491] getGlobalsAndPackages() ... DONE
[13:38:00.491] run() for ‘Future’ ...
[13:38:00.492] - state: ‘created’
[13:38:00.492] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:00.505] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:00.505] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:00.505]   - Field: ‘node’
[13:38:00.505]   - Field: ‘label’
[13:38:00.506]   - Field: ‘local’
[13:38:00.506]   - Field: ‘owner’
[13:38:00.506]   - Field: ‘envir’
[13:38:00.506]   - Field: ‘workers’
[13:38:00.506]   - Field: ‘packages’
[13:38:00.506]   - Field: ‘gc’
[13:38:00.506]   - Field: ‘conditions’
[13:38:00.506]   - Field: ‘persistent’
[13:38:00.506]   - Field: ‘expr’
[13:38:00.506]   - Field: ‘uuid’
[13:38:00.507]   - Field: ‘seed’
[13:38:00.507]   - Field: ‘version’
[13:38:00.507]   - Field: ‘result’
[13:38:00.507]   - Field: ‘asynchronous’
[13:38:00.507]   - Field: ‘calls’
[13:38:00.507]   - Field: ‘globals’
[13:38:00.507]   - Field: ‘stdout’
[13:38:00.507]   - Field: ‘earlySignal’
[13:38:00.507]   - Field: ‘lazy’
[13:38:00.507]   - Field: ‘state’
[13:38:00.507] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:00.508] - Launch lazy future ...
[13:38:00.508] Packages needed by the future expression (n = 0): <none>
[13:38:00.508] Packages needed by future strategies (n = 0): <none>
[13:38:00.508] {
[13:38:00.508]     {
[13:38:00.508]         {
[13:38:00.508]             ...future.startTime <- base::Sys.time()
[13:38:00.508]             {
[13:38:00.508]                 {
[13:38:00.508]                   {
[13:38:00.508]                     {
[13:38:00.508]                       base::local({
[13:38:00.508]                         has_future <- base::requireNamespace("future", 
[13:38:00.508]                           quietly = TRUE)
[13:38:00.508]                         if (has_future) {
[13:38:00.508]                           ns <- base::getNamespace("future")
[13:38:00.508]                           version <- ns[[".package"]][["version"]]
[13:38:00.508]                           if (is.null(version)) 
[13:38:00.508]                             version <- utils::packageVersion("future")
[13:38:00.508]                         }
[13:38:00.508]                         else {
[13:38:00.508]                           version <- NULL
[13:38:00.508]                         }
[13:38:00.508]                         if (!has_future || version < "1.8.0") {
[13:38:00.508]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:00.508]                             "", base::R.version$version.string), 
[13:38:00.508]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:00.508]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:00.508]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:00.508]                               "release", "version")], collapse = " "), 
[13:38:00.508]                             hostname = base::Sys.info()[["nodename"]])
[13:38:00.508]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:00.508]                             info)
[13:38:00.508]                           info <- base::paste(info, collapse = "; ")
[13:38:00.508]                           if (!has_future) {
[13:38:00.508]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:00.508]                               info)
[13:38:00.508]                           }
[13:38:00.508]                           else {
[13:38:00.508]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:00.508]                               info, version)
[13:38:00.508]                           }
[13:38:00.508]                           base::stop(msg)
[13:38:00.508]                         }
[13:38:00.508]                       })
[13:38:00.508]                     }
[13:38:00.508]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:00.508]                     base::options(mc.cores = 1L)
[13:38:00.508]                   }
[13:38:00.508]                   ...future.strategy.old <- future::plan("list")
[13:38:00.508]                   options(future.plan = NULL)
[13:38:00.508]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:00.508]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:00.508]                 }
[13:38:00.508]                 ...future.workdir <- getwd()
[13:38:00.508]             }
[13:38:00.508]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:00.508]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:00.508]         }
[13:38:00.508]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:00.508]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:00.508]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:00.508]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:00.508]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:00.508]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:00.508]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:00.508]             base::names(...future.oldOptions))
[13:38:00.508]     }
[13:38:00.508]     if (FALSE) {
[13:38:00.508]     }
[13:38:00.508]     else {
[13:38:00.508]         if (TRUE) {
[13:38:00.508]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:00.508]                 open = "w")
[13:38:00.508]         }
[13:38:00.508]         else {
[13:38:00.508]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:00.508]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:00.508]         }
[13:38:00.508]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:00.508]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:00.508]             base::sink(type = "output", split = FALSE)
[13:38:00.508]             base::close(...future.stdout)
[13:38:00.508]         }, add = TRUE)
[13:38:00.508]     }
[13:38:00.508]     ...future.frame <- base::sys.nframe()
[13:38:00.508]     ...future.conditions <- base::list()
[13:38:00.508]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:00.508]     if (FALSE) {
[13:38:00.508]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:00.508]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:00.508]     }
[13:38:00.508]     ...future.result <- base::tryCatch({
[13:38:00.508]         base::withCallingHandlers({
[13:38:00.508]             ...future.value <- base::withVisible(base::local({
[13:38:00.508]                 ...future.makeSendCondition <- base::local({
[13:38:00.508]                   sendCondition <- NULL
[13:38:00.508]                   function(frame = 1L) {
[13:38:00.508]                     if (is.function(sendCondition)) 
[13:38:00.508]                       return(sendCondition)
[13:38:00.508]                     ns <- getNamespace("parallel")
[13:38:00.508]                     if (exists("sendData", mode = "function", 
[13:38:00.508]                       envir = ns)) {
[13:38:00.508]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:00.508]                         envir = ns)
[13:38:00.508]                       envir <- sys.frame(frame)
[13:38:00.508]                       master <- NULL
[13:38:00.508]                       while (!identical(envir, .GlobalEnv) && 
[13:38:00.508]                         !identical(envir, emptyenv())) {
[13:38:00.508]                         if (exists("master", mode = "list", envir = envir, 
[13:38:00.508]                           inherits = FALSE)) {
[13:38:00.508]                           master <- get("master", mode = "list", 
[13:38:00.508]                             envir = envir, inherits = FALSE)
[13:38:00.508]                           if (inherits(master, c("SOCKnode", 
[13:38:00.508]                             "SOCK0node"))) {
[13:38:00.508]                             sendCondition <<- function(cond) {
[13:38:00.508]                               data <- list(type = "VALUE", value = cond, 
[13:38:00.508]                                 success = TRUE)
[13:38:00.508]                               parallel_sendData(master, data)
[13:38:00.508]                             }
[13:38:00.508]                             return(sendCondition)
[13:38:00.508]                           }
[13:38:00.508]                         }
[13:38:00.508]                         frame <- frame + 1L
[13:38:00.508]                         envir <- sys.frame(frame)
[13:38:00.508]                       }
[13:38:00.508]                     }
[13:38:00.508]                     sendCondition <<- function(cond) NULL
[13:38:00.508]                   }
[13:38:00.508]                 })
[13:38:00.508]                 withCallingHandlers({
[13:38:00.508]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:38:00.508]                 }, immediateCondition = function(cond) {
[13:38:00.508]                   sendCondition <- ...future.makeSendCondition()
[13:38:00.508]                   sendCondition(cond)
[13:38:00.508]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.508]                   {
[13:38:00.508]                     inherits <- base::inherits
[13:38:00.508]                     invokeRestart <- base::invokeRestart
[13:38:00.508]                     is.null <- base::is.null
[13:38:00.508]                     muffled <- FALSE
[13:38:00.508]                     if (inherits(cond, "message")) {
[13:38:00.508]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:00.508]                       if (muffled) 
[13:38:00.508]                         invokeRestart("muffleMessage")
[13:38:00.508]                     }
[13:38:00.508]                     else if (inherits(cond, "warning")) {
[13:38:00.508]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:00.508]                       if (muffled) 
[13:38:00.508]                         invokeRestart("muffleWarning")
[13:38:00.508]                     }
[13:38:00.508]                     else if (inherits(cond, "condition")) {
[13:38:00.508]                       if (!is.null(pattern)) {
[13:38:00.508]                         computeRestarts <- base::computeRestarts
[13:38:00.508]                         grepl <- base::grepl
[13:38:00.508]                         restarts <- computeRestarts(cond)
[13:38:00.508]                         for (restart in restarts) {
[13:38:00.508]                           name <- restart$name
[13:38:00.508]                           if (is.null(name)) 
[13:38:00.508]                             next
[13:38:00.508]                           if (!grepl(pattern, name)) 
[13:38:00.508]                             next
[13:38:00.508]                           invokeRestart(restart)
[13:38:00.508]                           muffled <- TRUE
[13:38:00.508]                           break
[13:38:00.508]                         }
[13:38:00.508]                       }
[13:38:00.508]                     }
[13:38:00.508]                     invisible(muffled)
[13:38:00.508]                   }
[13:38:00.508]                   muffleCondition(cond)
[13:38:00.508]                 })
[13:38:00.508]             }))
[13:38:00.508]             future::FutureResult(value = ...future.value$value, 
[13:38:00.508]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:00.508]                   ...future.rng), globalenv = if (FALSE) 
[13:38:00.508]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:00.508]                     ...future.globalenv.names))
[13:38:00.508]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:00.508]         }, condition = base::local({
[13:38:00.508]             c <- base::c
[13:38:00.508]             inherits <- base::inherits
[13:38:00.508]             invokeRestart <- base::invokeRestart
[13:38:00.508]             length <- base::length
[13:38:00.508]             list <- base::list
[13:38:00.508]             seq.int <- base::seq.int
[13:38:00.508]             signalCondition <- base::signalCondition
[13:38:00.508]             sys.calls <- base::sys.calls
[13:38:00.508]             `[[` <- base::`[[`
[13:38:00.508]             `+` <- base::`+`
[13:38:00.508]             `<<-` <- base::`<<-`
[13:38:00.508]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:00.508]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:00.508]                   3L)]
[13:38:00.508]             }
[13:38:00.508]             function(cond) {
[13:38:00.508]                 is_error <- inherits(cond, "error")
[13:38:00.508]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:00.508]                   NULL)
[13:38:00.508]                 if (is_error) {
[13:38:00.508]                   sessionInformation <- function() {
[13:38:00.508]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:00.508]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:00.508]                       search = base::search(), system = base::Sys.info())
[13:38:00.508]                   }
[13:38:00.508]                   ...future.conditions[[length(...future.conditions) + 
[13:38:00.508]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:00.508]                     cond$call), session = sessionInformation(), 
[13:38:00.508]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:00.508]                   signalCondition(cond)
[13:38:00.508]                 }
[13:38:00.508]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:00.508]                 "immediateCondition"))) {
[13:38:00.508]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:00.508]                   ...future.conditions[[length(...future.conditions) + 
[13:38:00.508]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:00.508]                   if (TRUE && !signal) {
[13:38:00.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.508]                     {
[13:38:00.508]                       inherits <- base::inherits
[13:38:00.508]                       invokeRestart <- base::invokeRestart
[13:38:00.508]                       is.null <- base::is.null
[13:38:00.508]                       muffled <- FALSE
[13:38:00.508]                       if (inherits(cond, "message")) {
[13:38:00.508]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:00.508]                         if (muffled) 
[13:38:00.508]                           invokeRestart("muffleMessage")
[13:38:00.508]                       }
[13:38:00.508]                       else if (inherits(cond, "warning")) {
[13:38:00.508]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:00.508]                         if (muffled) 
[13:38:00.508]                           invokeRestart("muffleWarning")
[13:38:00.508]                       }
[13:38:00.508]                       else if (inherits(cond, "condition")) {
[13:38:00.508]                         if (!is.null(pattern)) {
[13:38:00.508]                           computeRestarts <- base::computeRestarts
[13:38:00.508]                           grepl <- base::grepl
[13:38:00.508]                           restarts <- computeRestarts(cond)
[13:38:00.508]                           for (restart in restarts) {
[13:38:00.508]                             name <- restart$name
[13:38:00.508]                             if (is.null(name)) 
[13:38:00.508]                               next
[13:38:00.508]                             if (!grepl(pattern, name)) 
[13:38:00.508]                               next
[13:38:00.508]                             invokeRestart(restart)
[13:38:00.508]                             muffled <- TRUE
[13:38:00.508]                             break
[13:38:00.508]                           }
[13:38:00.508]                         }
[13:38:00.508]                       }
[13:38:00.508]                       invisible(muffled)
[13:38:00.508]                     }
[13:38:00.508]                     muffleCondition(cond, pattern = "^muffle")
[13:38:00.508]                   }
[13:38:00.508]                 }
[13:38:00.508]                 else {
[13:38:00.508]                   if (TRUE) {
[13:38:00.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.508]                     {
[13:38:00.508]                       inherits <- base::inherits
[13:38:00.508]                       invokeRestart <- base::invokeRestart
[13:38:00.508]                       is.null <- base::is.null
[13:38:00.508]                       muffled <- FALSE
[13:38:00.508]                       if (inherits(cond, "message")) {
[13:38:00.508]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:00.508]                         if (muffled) 
[13:38:00.508]                           invokeRestart("muffleMessage")
[13:38:00.508]                       }
[13:38:00.508]                       else if (inherits(cond, "warning")) {
[13:38:00.508]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:00.508]                         if (muffled) 
[13:38:00.508]                           invokeRestart("muffleWarning")
[13:38:00.508]                       }
[13:38:00.508]                       else if (inherits(cond, "condition")) {
[13:38:00.508]                         if (!is.null(pattern)) {
[13:38:00.508]                           computeRestarts <- base::computeRestarts
[13:38:00.508]                           grepl <- base::grepl
[13:38:00.508]                           restarts <- computeRestarts(cond)
[13:38:00.508]                           for (restart in restarts) {
[13:38:00.508]                             name <- restart$name
[13:38:00.508]                             if (is.null(name)) 
[13:38:00.508]                               next
[13:38:00.508]                             if (!grepl(pattern, name)) 
[13:38:00.508]                               next
[13:38:00.508]                             invokeRestart(restart)
[13:38:00.508]                             muffled <- TRUE
[13:38:00.508]                             break
[13:38:00.508]                           }
[13:38:00.508]                         }
[13:38:00.508]                       }
[13:38:00.508]                       invisible(muffled)
[13:38:00.508]                     }
[13:38:00.508]                     muffleCondition(cond, pattern = "^muffle")
[13:38:00.508]                   }
[13:38:00.508]                 }
[13:38:00.508]             }
[13:38:00.508]         }))
[13:38:00.508]     }, error = function(ex) {
[13:38:00.508]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:00.508]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:00.508]                 ...future.rng), started = ...future.startTime, 
[13:38:00.508]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:00.508]             version = "1.8"), class = "FutureResult")
[13:38:00.508]     }, finally = {
[13:38:00.508]         if (!identical(...future.workdir, getwd())) 
[13:38:00.508]             setwd(...future.workdir)
[13:38:00.508]         {
[13:38:00.508]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:00.508]                 ...future.oldOptions$nwarnings <- NULL
[13:38:00.508]             }
[13:38:00.508]             base::options(...future.oldOptions)
[13:38:00.508]             if (.Platform$OS.type == "windows") {
[13:38:00.508]                 old_names <- names(...future.oldEnvVars)
[13:38:00.508]                 envs <- base::Sys.getenv()
[13:38:00.508]                 names <- names(envs)
[13:38:00.508]                 common <- intersect(names, old_names)
[13:38:00.508]                 added <- setdiff(names, old_names)
[13:38:00.508]                 removed <- setdiff(old_names, names)
[13:38:00.508]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:00.508]                   envs[common]]
[13:38:00.508]                 NAMES <- toupper(changed)
[13:38:00.508]                 args <- list()
[13:38:00.508]                 for (kk in seq_along(NAMES)) {
[13:38:00.508]                   name <- changed[[kk]]
[13:38:00.508]                   NAME <- NAMES[[kk]]
[13:38:00.508]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.508]                     next
[13:38:00.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:00.508]                 }
[13:38:00.508]                 NAMES <- toupper(added)
[13:38:00.508]                 for (kk in seq_along(NAMES)) {
[13:38:00.508]                   name <- added[[kk]]
[13:38:00.508]                   NAME <- NAMES[[kk]]
[13:38:00.508]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.508]                     next
[13:38:00.508]                   args[[name]] <- ""
[13:38:00.508]                 }
[13:38:00.508]                 NAMES <- toupper(removed)
[13:38:00.508]                 for (kk in seq_along(NAMES)) {
[13:38:00.508]                   name <- removed[[kk]]
[13:38:00.508]                   NAME <- NAMES[[kk]]
[13:38:00.508]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.508]                     next
[13:38:00.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:00.508]                 }
[13:38:00.508]                 if (length(args) > 0) 
[13:38:00.508]                   base::do.call(base::Sys.setenv, args = args)
[13:38:00.508]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:00.508]             }
[13:38:00.508]             else {
[13:38:00.508]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:00.508]             }
[13:38:00.508]             {
[13:38:00.508]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:00.508]                   0L) {
[13:38:00.508]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:00.508]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:00.508]                   base::options(opts)
[13:38:00.508]                 }
[13:38:00.508]                 {
[13:38:00.508]                   {
[13:38:00.508]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:00.508]                     NULL
[13:38:00.508]                   }
[13:38:00.508]                   options(future.plan = NULL)
[13:38:00.508]                   if (is.na(NA_character_)) 
[13:38:00.508]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:00.508]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:00.508]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:00.508]                     .init = FALSE)
[13:38:00.508]                 }
[13:38:00.508]             }
[13:38:00.508]         }
[13:38:00.508]     })
[13:38:00.508]     if (TRUE) {
[13:38:00.508]         base::sink(type = "output", split = FALSE)
[13:38:00.508]         if (TRUE) {
[13:38:00.508]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:00.508]         }
[13:38:00.508]         else {
[13:38:00.508]             ...future.result["stdout"] <- base::list(NULL)
[13:38:00.508]         }
[13:38:00.508]         base::close(...future.stdout)
[13:38:00.508]         ...future.stdout <- NULL
[13:38:00.508]     }
[13:38:00.508]     ...future.result$conditions <- ...future.conditions
[13:38:00.508]     ...future.result$finished <- base::Sys.time()
[13:38:00.508]     ...future.result
[13:38:00.508] }
[13:38:00.511] MultisessionFuture started
[13:38:00.511] - Launch lazy future ... done
[13:38:00.511] run() for ‘MultisessionFuture’ ... done
[13:38:00.512] receiveMessageFromWorker() for ClusterFuture ...
[13:38:00.513] - Validating connection of MultisessionFuture
[13:38:00.513] - received message: FutureResult
[13:38:00.513] - Received FutureResult
[13:38:00.513] - Erased future from FutureRegistry
[13:38:00.513] result() for ClusterFuture ...
[13:38:00.513] - result already collected: FutureResult
[13:38:00.514] result() for ClusterFuture ... done
[13:38:00.514] signalConditions() ...
[13:38:00.514]  - include = ‘immediateCondition’
[13:38:00.514]  - exclude = 
[13:38:00.514]  - resignal = FALSE
[13:38:00.514]  - Number of conditions: 1
[13:38:00.514] signalConditions() ... done
[13:38:00.514] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:00.514] A MultisessionFuture was resolved
- result = TRUE, recursive = Inf ... DONE
*** resolve() for Future objects ... DONE
*** resolve() for lists ...
[13:38:00.515] resolve() on list ...
[13:38:00.515]  recursive: 0
[13:38:00.515]  length: 2
[13:38:00.515]  elements: ‘a’, ‘b’
[13:38:00.515]  length: 1 (resolved future 1)
[13:38:00.515]  length: 0 (resolved future 2)
[13:38:00.515] resolve() on list ... DONE
[13:38:00.518] getGlobalsAndPackages() ...
[13:38:00.518] Searching for globals...
[13:38:00.519] 
[13:38:00.519] Searching for globals ... DONE
[13:38:00.519] - globals: [0] <none>
[13:38:00.519] getGlobalsAndPackages() ... DONE
[13:38:00.519] run() for ‘Future’ ...
[13:38:00.519] - state: ‘created’
[13:38:00.519] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:00.533] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:00.533] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:00.533]   - Field: ‘node’
[13:38:00.533]   - Field: ‘label’
[13:38:00.534]   - Field: ‘local’
[13:38:00.534]   - Field: ‘owner’
[13:38:00.534]   - Field: ‘envir’
[13:38:00.534]   - Field: ‘workers’
[13:38:00.534]   - Field: ‘packages’
[13:38:00.534]   - Field: ‘gc’
[13:38:00.534]   - Field: ‘conditions’
[13:38:00.534]   - Field: ‘persistent’
[13:38:00.534]   - Field: ‘expr’
[13:38:00.534]   - Field: ‘uuid’
[13:38:00.535]   - Field: ‘seed’
[13:38:00.535]   - Field: ‘version’
[13:38:00.535]   - Field: ‘result’
[13:38:00.535]   - Field: ‘asynchronous’
[13:38:00.535]   - Field: ‘calls’
[13:38:00.535]   - Field: ‘globals’
[13:38:00.535]   - Field: ‘stdout’
[13:38:00.535]   - Field: ‘earlySignal’
[13:38:00.535]   - Field: ‘lazy’
[13:38:00.535]   - Field: ‘state’
[13:38:00.535] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:00.536] - Launch lazy future ...
[13:38:00.536] Packages needed by the future expression (n = 0): <none>
[13:38:00.536] Packages needed by future strategies (n = 0): <none>
[13:38:00.536] {
[13:38:00.536]     {
[13:38:00.536]         {
[13:38:00.536]             ...future.startTime <- base::Sys.time()
[13:38:00.536]             {
[13:38:00.536]                 {
[13:38:00.536]                   {
[13:38:00.536]                     {
[13:38:00.536]                       base::local({
[13:38:00.536]                         has_future <- base::requireNamespace("future", 
[13:38:00.536]                           quietly = TRUE)
[13:38:00.536]                         if (has_future) {
[13:38:00.536]                           ns <- base::getNamespace("future")
[13:38:00.536]                           version <- ns[[".package"]][["version"]]
[13:38:00.536]                           if (is.null(version)) 
[13:38:00.536]                             version <- utils::packageVersion("future")
[13:38:00.536]                         }
[13:38:00.536]                         else {
[13:38:00.536]                           version <- NULL
[13:38:00.536]                         }
[13:38:00.536]                         if (!has_future || version < "1.8.0") {
[13:38:00.536]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:00.536]                             "", base::R.version$version.string), 
[13:38:00.536]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:00.536]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:00.536]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:00.536]                               "release", "version")], collapse = " "), 
[13:38:00.536]                             hostname = base::Sys.info()[["nodename"]])
[13:38:00.536]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:00.536]                             info)
[13:38:00.536]                           info <- base::paste(info, collapse = "; ")
[13:38:00.536]                           if (!has_future) {
[13:38:00.536]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:00.536]                               info)
[13:38:00.536]                           }
[13:38:00.536]                           else {
[13:38:00.536]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:00.536]                               info, version)
[13:38:00.536]                           }
[13:38:00.536]                           base::stop(msg)
[13:38:00.536]                         }
[13:38:00.536]                       })
[13:38:00.536]                     }
[13:38:00.536]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:00.536]                     base::options(mc.cores = 1L)
[13:38:00.536]                   }
[13:38:00.536]                   ...future.strategy.old <- future::plan("list")
[13:38:00.536]                   options(future.plan = NULL)
[13:38:00.536]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:00.536]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:00.536]                 }
[13:38:00.536]                 ...future.workdir <- getwd()
[13:38:00.536]             }
[13:38:00.536]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:00.536]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:00.536]         }
[13:38:00.536]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:00.536]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:00.536]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:00.536]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:00.536]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:00.536]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:00.536]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:00.536]             base::names(...future.oldOptions))
[13:38:00.536]     }
[13:38:00.536]     if (FALSE) {
[13:38:00.536]     }
[13:38:00.536]     else {
[13:38:00.536]         if (TRUE) {
[13:38:00.536]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:00.536]                 open = "w")
[13:38:00.536]         }
[13:38:00.536]         else {
[13:38:00.536]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:00.536]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:00.536]         }
[13:38:00.536]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:00.536]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:00.536]             base::sink(type = "output", split = FALSE)
[13:38:00.536]             base::close(...future.stdout)
[13:38:00.536]         }, add = TRUE)
[13:38:00.536]     }
[13:38:00.536]     ...future.frame <- base::sys.nframe()
[13:38:00.536]     ...future.conditions <- base::list()
[13:38:00.536]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:00.536]     if (FALSE) {
[13:38:00.536]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:00.536]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:00.536]     }
[13:38:00.536]     ...future.result <- base::tryCatch({
[13:38:00.536]         base::withCallingHandlers({
[13:38:00.536]             ...future.value <- base::withVisible(base::local({
[13:38:00.536]                 ...future.makeSendCondition <- base::local({
[13:38:00.536]                   sendCondition <- NULL
[13:38:00.536]                   function(frame = 1L) {
[13:38:00.536]                     if (is.function(sendCondition)) 
[13:38:00.536]                       return(sendCondition)
[13:38:00.536]                     ns <- getNamespace("parallel")
[13:38:00.536]                     if (exists("sendData", mode = "function", 
[13:38:00.536]                       envir = ns)) {
[13:38:00.536]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:00.536]                         envir = ns)
[13:38:00.536]                       envir <- sys.frame(frame)
[13:38:00.536]                       master <- NULL
[13:38:00.536]                       while (!identical(envir, .GlobalEnv) && 
[13:38:00.536]                         !identical(envir, emptyenv())) {
[13:38:00.536]                         if (exists("master", mode = "list", envir = envir, 
[13:38:00.536]                           inherits = FALSE)) {
[13:38:00.536]                           master <- get("master", mode = "list", 
[13:38:00.536]                             envir = envir, inherits = FALSE)
[13:38:00.536]                           if (inherits(master, c("SOCKnode", 
[13:38:00.536]                             "SOCK0node"))) {
[13:38:00.536]                             sendCondition <<- function(cond) {
[13:38:00.536]                               data <- list(type = "VALUE", value = cond, 
[13:38:00.536]                                 success = TRUE)
[13:38:00.536]                               parallel_sendData(master, data)
[13:38:00.536]                             }
[13:38:00.536]                             return(sendCondition)
[13:38:00.536]                           }
[13:38:00.536]                         }
[13:38:00.536]                         frame <- frame + 1L
[13:38:00.536]                         envir <- sys.frame(frame)
[13:38:00.536]                       }
[13:38:00.536]                     }
[13:38:00.536]                     sendCondition <<- function(cond) NULL
[13:38:00.536]                   }
[13:38:00.536]                 })
[13:38:00.536]                 withCallingHandlers({
[13:38:00.536]                   1
[13:38:00.536]                 }, immediateCondition = function(cond) {
[13:38:00.536]                   sendCondition <- ...future.makeSendCondition()
[13:38:00.536]                   sendCondition(cond)
[13:38:00.536]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.536]                   {
[13:38:00.536]                     inherits <- base::inherits
[13:38:00.536]                     invokeRestart <- base::invokeRestart
[13:38:00.536]                     is.null <- base::is.null
[13:38:00.536]                     muffled <- FALSE
[13:38:00.536]                     if (inherits(cond, "message")) {
[13:38:00.536]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:00.536]                       if (muffled) 
[13:38:00.536]                         invokeRestart("muffleMessage")
[13:38:00.536]                     }
[13:38:00.536]                     else if (inherits(cond, "warning")) {
[13:38:00.536]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:00.536]                       if (muffled) 
[13:38:00.536]                         invokeRestart("muffleWarning")
[13:38:00.536]                     }
[13:38:00.536]                     else if (inherits(cond, "condition")) {
[13:38:00.536]                       if (!is.null(pattern)) {
[13:38:00.536]                         computeRestarts <- base::computeRestarts
[13:38:00.536]                         grepl <- base::grepl
[13:38:00.536]                         restarts <- computeRestarts(cond)
[13:38:00.536]                         for (restart in restarts) {
[13:38:00.536]                           name <- restart$name
[13:38:00.536]                           if (is.null(name)) 
[13:38:00.536]                             next
[13:38:00.536]                           if (!grepl(pattern, name)) 
[13:38:00.536]                             next
[13:38:00.536]                           invokeRestart(restart)
[13:38:00.536]                           muffled <- TRUE
[13:38:00.536]                           break
[13:38:00.536]                         }
[13:38:00.536]                       }
[13:38:00.536]                     }
[13:38:00.536]                     invisible(muffled)
[13:38:00.536]                   }
[13:38:00.536]                   muffleCondition(cond)
[13:38:00.536]                 })
[13:38:00.536]             }))
[13:38:00.536]             future::FutureResult(value = ...future.value$value, 
[13:38:00.536]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:00.536]                   ...future.rng), globalenv = if (FALSE) 
[13:38:00.536]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:00.536]                     ...future.globalenv.names))
[13:38:00.536]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:00.536]         }, condition = base::local({
[13:38:00.536]             c <- base::c
[13:38:00.536]             inherits <- base::inherits
[13:38:00.536]             invokeRestart <- base::invokeRestart
[13:38:00.536]             length <- base::length
[13:38:00.536]             list <- base::list
[13:38:00.536]             seq.int <- base::seq.int
[13:38:00.536]             signalCondition <- base::signalCondition
[13:38:00.536]             sys.calls <- base::sys.calls
[13:38:00.536]             `[[` <- base::`[[`
[13:38:00.536]             `+` <- base::`+`
[13:38:00.536]             `<<-` <- base::`<<-`
[13:38:00.536]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:00.536]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:00.536]                   3L)]
[13:38:00.536]             }
[13:38:00.536]             function(cond) {
[13:38:00.536]                 is_error <- inherits(cond, "error")
[13:38:00.536]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:00.536]                   NULL)
[13:38:00.536]                 if (is_error) {
[13:38:00.536]                   sessionInformation <- function() {
[13:38:00.536]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:00.536]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:00.536]                       search = base::search(), system = base::Sys.info())
[13:38:00.536]                   }
[13:38:00.536]                   ...future.conditions[[length(...future.conditions) + 
[13:38:00.536]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:00.536]                     cond$call), session = sessionInformation(), 
[13:38:00.536]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:00.536]                   signalCondition(cond)
[13:38:00.536]                 }
[13:38:00.536]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:00.536]                 "immediateCondition"))) {
[13:38:00.536]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:00.536]                   ...future.conditions[[length(...future.conditions) + 
[13:38:00.536]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:00.536]                   if (TRUE && !signal) {
[13:38:00.536]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.536]                     {
[13:38:00.536]                       inherits <- base::inherits
[13:38:00.536]                       invokeRestart <- base::invokeRestart
[13:38:00.536]                       is.null <- base::is.null
[13:38:00.536]                       muffled <- FALSE
[13:38:00.536]                       if (inherits(cond, "message")) {
[13:38:00.536]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:00.536]                         if (muffled) 
[13:38:00.536]                           invokeRestart("muffleMessage")
[13:38:00.536]                       }
[13:38:00.536]                       else if (inherits(cond, "warning")) {
[13:38:00.536]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:00.536]                         if (muffled) 
[13:38:00.536]                           invokeRestart("muffleWarning")
[13:38:00.536]                       }
[13:38:00.536]                       else if (inherits(cond, "condition")) {
[13:38:00.536]                         if (!is.null(pattern)) {
[13:38:00.536]                           computeRestarts <- base::computeRestarts
[13:38:00.536]                           grepl <- base::grepl
[13:38:00.536]                           restarts <- computeRestarts(cond)
[13:38:00.536]                           for (restart in restarts) {
[13:38:00.536]                             name <- restart$name
[13:38:00.536]                             if (is.null(name)) 
[13:38:00.536]                               next
[13:38:00.536]                             if (!grepl(pattern, name)) 
[13:38:00.536]                               next
[13:38:00.536]                             invokeRestart(restart)
[13:38:00.536]                             muffled <- TRUE
[13:38:00.536]                             break
[13:38:00.536]                           }
[13:38:00.536]                         }
[13:38:00.536]                       }
[13:38:00.536]                       invisible(muffled)
[13:38:00.536]                     }
[13:38:00.536]                     muffleCondition(cond, pattern = "^muffle")
[13:38:00.536]                   }
[13:38:00.536]                 }
[13:38:00.536]                 else {
[13:38:00.536]                   if (TRUE) {
[13:38:00.536]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.536]                     {
[13:38:00.536]                       inherits <- base::inherits
[13:38:00.536]                       invokeRestart <- base::invokeRestart
[13:38:00.536]                       is.null <- base::is.null
[13:38:00.536]                       muffled <- FALSE
[13:38:00.536]                       if (inherits(cond, "message")) {
[13:38:00.536]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:00.536]                         if (muffled) 
[13:38:00.536]                           invokeRestart("muffleMessage")
[13:38:00.536]                       }
[13:38:00.536]                       else if (inherits(cond, "warning")) {
[13:38:00.536]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:00.536]                         if (muffled) 
[13:38:00.536]                           invokeRestart("muffleWarning")
[13:38:00.536]                       }
[13:38:00.536]                       else if (inherits(cond, "condition")) {
[13:38:00.536]                         if (!is.null(pattern)) {
[13:38:00.536]                           computeRestarts <- base::computeRestarts
[13:38:00.536]                           grepl <- base::grepl
[13:38:00.536]                           restarts <- computeRestarts(cond)
[13:38:00.536]                           for (restart in restarts) {
[13:38:00.536]                             name <- restart$name
[13:38:00.536]                             if (is.null(name)) 
[13:38:00.536]                               next
[13:38:00.536]                             if (!grepl(pattern, name)) 
[13:38:00.536]                               next
[13:38:00.536]                             invokeRestart(restart)
[13:38:00.536]                             muffled <- TRUE
[13:38:00.536]                             break
[13:38:00.536]                           }
[13:38:00.536]                         }
[13:38:00.536]                       }
[13:38:00.536]                       invisible(muffled)
[13:38:00.536]                     }
[13:38:00.536]                     muffleCondition(cond, pattern = "^muffle")
[13:38:00.536]                   }
[13:38:00.536]                 }
[13:38:00.536]             }
[13:38:00.536]         }))
[13:38:00.536]     }, error = function(ex) {
[13:38:00.536]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:00.536]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:00.536]                 ...future.rng), started = ...future.startTime, 
[13:38:00.536]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:00.536]             version = "1.8"), class = "FutureResult")
[13:38:00.536]     }, finally = {
[13:38:00.536]         if (!identical(...future.workdir, getwd())) 
[13:38:00.536]             setwd(...future.workdir)
[13:38:00.536]         {
[13:38:00.536]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:00.536]                 ...future.oldOptions$nwarnings <- NULL
[13:38:00.536]             }
[13:38:00.536]             base::options(...future.oldOptions)
[13:38:00.536]             if (.Platform$OS.type == "windows") {
[13:38:00.536]                 old_names <- names(...future.oldEnvVars)
[13:38:00.536]                 envs <- base::Sys.getenv()
[13:38:00.536]                 names <- names(envs)
[13:38:00.536]                 common <- intersect(names, old_names)
[13:38:00.536]                 added <- setdiff(names, old_names)
[13:38:00.536]                 removed <- setdiff(old_names, names)
[13:38:00.536]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:00.536]                   envs[common]]
[13:38:00.536]                 NAMES <- toupper(changed)
[13:38:00.536]                 args <- list()
[13:38:00.536]                 for (kk in seq_along(NAMES)) {
[13:38:00.536]                   name <- changed[[kk]]
[13:38:00.536]                   NAME <- NAMES[[kk]]
[13:38:00.536]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.536]                     next
[13:38:00.536]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:00.536]                 }
[13:38:00.536]                 NAMES <- toupper(added)
[13:38:00.536]                 for (kk in seq_along(NAMES)) {
[13:38:00.536]                   name <- added[[kk]]
[13:38:00.536]                   NAME <- NAMES[[kk]]
[13:38:00.536]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.536]                     next
[13:38:00.536]                   args[[name]] <- ""
[13:38:00.536]                 }
[13:38:00.536]                 NAMES <- toupper(removed)
[13:38:00.536]                 for (kk in seq_along(NAMES)) {
[13:38:00.536]                   name <- removed[[kk]]
[13:38:00.536]                   NAME <- NAMES[[kk]]
[13:38:00.536]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.536]                     next
[13:38:00.536]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:00.536]                 }
[13:38:00.536]                 if (length(args) > 0) 
[13:38:00.536]                   base::do.call(base::Sys.setenv, args = args)
[13:38:00.536]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:00.536]             }
[13:38:00.536]             else {
[13:38:00.536]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:00.536]             }
[13:38:00.536]             {
[13:38:00.536]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:00.536]                   0L) {
[13:38:00.536]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:00.536]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:00.536]                   base::options(opts)
[13:38:00.536]                 }
[13:38:00.536]                 {
[13:38:00.536]                   {
[13:38:00.536]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:00.536]                     NULL
[13:38:00.536]                   }
[13:38:00.536]                   options(future.plan = NULL)
[13:38:00.536]                   if (is.na(NA_character_)) 
[13:38:00.536]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:00.536]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:00.536]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:00.536]                     .init = FALSE)
[13:38:00.536]                 }
[13:38:00.536]             }
[13:38:00.536]         }
[13:38:00.536]     })
[13:38:00.536]     if (TRUE) {
[13:38:00.536]         base::sink(type = "output", split = FALSE)
[13:38:00.536]         if (TRUE) {
[13:38:00.536]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:00.536]         }
[13:38:00.536]         else {
[13:38:00.536]             ...future.result["stdout"] <- base::list(NULL)
[13:38:00.536]         }
[13:38:00.536]         base::close(...future.stdout)
[13:38:00.536]         ...future.stdout <- NULL
[13:38:00.536]     }
[13:38:00.536]     ...future.result$conditions <- ...future.conditions
[13:38:00.536]     ...future.result$finished <- base::Sys.time()
[13:38:00.536]     ...future.result
[13:38:00.536] }
[13:38:00.539] MultisessionFuture started
[13:38:00.539] - Launch lazy future ... done
[13:38:00.539] run() for ‘MultisessionFuture’ ... done
[13:38:00.540] getGlobalsAndPackages() ...
[13:38:00.540] Searching for globals...
[13:38:00.540] 
[13:38:00.540] Searching for globals ... DONE
[13:38:00.541] - globals: [0] <none>
[13:38:00.541] getGlobalsAndPackages() ... DONE
[13:38:00.541] run() for ‘Future’ ...
[13:38:00.541] - state: ‘created’
[13:38:00.541] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:00.555] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:00.555] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:00.555]   - Field: ‘node’
[13:38:00.555]   - Field: ‘label’
[13:38:00.555]   - Field: ‘local’
[13:38:00.555]   - Field: ‘owner’
[13:38:00.555]   - Field: ‘envir’
[13:38:00.555]   - Field: ‘workers’
[13:38:00.555]   - Field: ‘packages’
[13:38:00.555]   - Field: ‘gc’
[13:38:00.556]   - Field: ‘conditions’
[13:38:00.556]   - Field: ‘persistent’
[13:38:00.556]   - Field: ‘expr’
[13:38:00.556]   - Field: ‘uuid’
[13:38:00.556]   - Field: ‘seed’
[13:38:00.556]   - Field: ‘version’
[13:38:00.556]   - Field: ‘result’
[13:38:00.556]   - Field: ‘asynchronous’
[13:38:00.556]   - Field: ‘calls’
[13:38:00.556]   - Field: ‘globals’
[13:38:00.556]   - Field: ‘stdout’
[13:38:00.557]   - Field: ‘earlySignal’
[13:38:00.557]   - Field: ‘lazy’
[13:38:00.557]   - Field: ‘state’
[13:38:00.557] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:00.557] - Launch lazy future ...
[13:38:00.557] Packages needed by the future expression (n = 0): <none>
[13:38:00.557] Packages needed by future strategies (n = 0): <none>
[13:38:00.558] {
[13:38:00.558]     {
[13:38:00.558]         {
[13:38:00.558]             ...future.startTime <- base::Sys.time()
[13:38:00.558]             {
[13:38:00.558]                 {
[13:38:00.558]                   {
[13:38:00.558]                     {
[13:38:00.558]                       base::local({
[13:38:00.558]                         has_future <- base::requireNamespace("future", 
[13:38:00.558]                           quietly = TRUE)
[13:38:00.558]                         if (has_future) {
[13:38:00.558]                           ns <- base::getNamespace("future")
[13:38:00.558]                           version <- ns[[".package"]][["version"]]
[13:38:00.558]                           if (is.null(version)) 
[13:38:00.558]                             version <- utils::packageVersion("future")
[13:38:00.558]                         }
[13:38:00.558]                         else {
[13:38:00.558]                           version <- NULL
[13:38:00.558]                         }
[13:38:00.558]                         if (!has_future || version < "1.8.0") {
[13:38:00.558]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:00.558]                             "", base::R.version$version.string), 
[13:38:00.558]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:00.558]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:00.558]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:00.558]                               "release", "version")], collapse = " "), 
[13:38:00.558]                             hostname = base::Sys.info()[["nodename"]])
[13:38:00.558]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:00.558]                             info)
[13:38:00.558]                           info <- base::paste(info, collapse = "; ")
[13:38:00.558]                           if (!has_future) {
[13:38:00.558]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:00.558]                               info)
[13:38:00.558]                           }
[13:38:00.558]                           else {
[13:38:00.558]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:00.558]                               info, version)
[13:38:00.558]                           }
[13:38:00.558]                           base::stop(msg)
[13:38:00.558]                         }
[13:38:00.558]                       })
[13:38:00.558]                     }
[13:38:00.558]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:00.558]                     base::options(mc.cores = 1L)
[13:38:00.558]                   }
[13:38:00.558]                   ...future.strategy.old <- future::plan("list")
[13:38:00.558]                   options(future.plan = NULL)
[13:38:00.558]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:00.558]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:00.558]                 }
[13:38:00.558]                 ...future.workdir <- getwd()
[13:38:00.558]             }
[13:38:00.558]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:00.558]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:00.558]         }
[13:38:00.558]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:00.558]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:00.558]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:00.558]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:00.558]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:00.558]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:00.558]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:00.558]             base::names(...future.oldOptions))
[13:38:00.558]     }
[13:38:00.558]     if (FALSE) {
[13:38:00.558]     }
[13:38:00.558]     else {
[13:38:00.558]         if (TRUE) {
[13:38:00.558]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:00.558]                 open = "w")
[13:38:00.558]         }
[13:38:00.558]         else {
[13:38:00.558]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:00.558]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:00.558]         }
[13:38:00.558]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:00.558]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:00.558]             base::sink(type = "output", split = FALSE)
[13:38:00.558]             base::close(...future.stdout)
[13:38:00.558]         }, add = TRUE)
[13:38:00.558]     }
[13:38:00.558]     ...future.frame <- base::sys.nframe()
[13:38:00.558]     ...future.conditions <- base::list()
[13:38:00.558]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:00.558]     if (FALSE) {
[13:38:00.558]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:00.558]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:00.558]     }
[13:38:00.558]     ...future.result <- base::tryCatch({
[13:38:00.558]         base::withCallingHandlers({
[13:38:00.558]             ...future.value <- base::withVisible(base::local({
[13:38:00.558]                 ...future.makeSendCondition <- base::local({
[13:38:00.558]                   sendCondition <- NULL
[13:38:00.558]                   function(frame = 1L) {
[13:38:00.558]                     if (is.function(sendCondition)) 
[13:38:00.558]                       return(sendCondition)
[13:38:00.558]                     ns <- getNamespace("parallel")
[13:38:00.558]                     if (exists("sendData", mode = "function", 
[13:38:00.558]                       envir = ns)) {
[13:38:00.558]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:00.558]                         envir = ns)
[13:38:00.558]                       envir <- sys.frame(frame)
[13:38:00.558]                       master <- NULL
[13:38:00.558]                       while (!identical(envir, .GlobalEnv) && 
[13:38:00.558]                         !identical(envir, emptyenv())) {
[13:38:00.558]                         if (exists("master", mode = "list", envir = envir, 
[13:38:00.558]                           inherits = FALSE)) {
[13:38:00.558]                           master <- get("master", mode = "list", 
[13:38:00.558]                             envir = envir, inherits = FALSE)
[13:38:00.558]                           if (inherits(master, c("SOCKnode", 
[13:38:00.558]                             "SOCK0node"))) {
[13:38:00.558]                             sendCondition <<- function(cond) {
[13:38:00.558]                               data <- list(type = "VALUE", value = cond, 
[13:38:00.558]                                 success = TRUE)
[13:38:00.558]                               parallel_sendData(master, data)
[13:38:00.558]                             }
[13:38:00.558]                             return(sendCondition)
[13:38:00.558]                           }
[13:38:00.558]                         }
[13:38:00.558]                         frame <- frame + 1L
[13:38:00.558]                         envir <- sys.frame(frame)
[13:38:00.558]                       }
[13:38:00.558]                     }
[13:38:00.558]                     sendCondition <<- function(cond) NULL
[13:38:00.558]                   }
[13:38:00.558]                 })
[13:38:00.558]                 withCallingHandlers({
[13:38:00.558]                   2
[13:38:00.558]                 }, immediateCondition = function(cond) {
[13:38:00.558]                   sendCondition <- ...future.makeSendCondition()
[13:38:00.558]                   sendCondition(cond)
[13:38:00.558]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.558]                   {
[13:38:00.558]                     inherits <- base::inherits
[13:38:00.558]                     invokeRestart <- base::invokeRestart
[13:38:00.558]                     is.null <- base::is.null
[13:38:00.558]                     muffled <- FALSE
[13:38:00.558]                     if (inherits(cond, "message")) {
[13:38:00.558]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:00.558]                       if (muffled) 
[13:38:00.558]                         invokeRestart("muffleMessage")
[13:38:00.558]                     }
[13:38:00.558]                     else if (inherits(cond, "warning")) {
[13:38:00.558]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:00.558]                       if (muffled) 
[13:38:00.558]                         invokeRestart("muffleWarning")
[13:38:00.558]                     }
[13:38:00.558]                     else if (inherits(cond, "condition")) {
[13:38:00.558]                       if (!is.null(pattern)) {
[13:38:00.558]                         computeRestarts <- base::computeRestarts
[13:38:00.558]                         grepl <- base::grepl
[13:38:00.558]                         restarts <- computeRestarts(cond)
[13:38:00.558]                         for (restart in restarts) {
[13:38:00.558]                           name <- restart$name
[13:38:00.558]                           if (is.null(name)) 
[13:38:00.558]                             next
[13:38:00.558]                           if (!grepl(pattern, name)) 
[13:38:00.558]                             next
[13:38:00.558]                           invokeRestart(restart)
[13:38:00.558]                           muffled <- TRUE
[13:38:00.558]                           break
[13:38:00.558]                         }
[13:38:00.558]                       }
[13:38:00.558]                     }
[13:38:00.558]                     invisible(muffled)
[13:38:00.558]                   }
[13:38:00.558]                   muffleCondition(cond)
[13:38:00.558]                 })
[13:38:00.558]             }))
[13:38:00.558]             future::FutureResult(value = ...future.value$value, 
[13:38:00.558]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:00.558]                   ...future.rng), globalenv = if (FALSE) 
[13:38:00.558]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:00.558]                     ...future.globalenv.names))
[13:38:00.558]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:00.558]         }, condition = base::local({
[13:38:00.558]             c <- base::c
[13:38:00.558]             inherits <- base::inherits
[13:38:00.558]             invokeRestart <- base::invokeRestart
[13:38:00.558]             length <- base::length
[13:38:00.558]             list <- base::list
[13:38:00.558]             seq.int <- base::seq.int
[13:38:00.558]             signalCondition <- base::signalCondition
[13:38:00.558]             sys.calls <- base::sys.calls
[13:38:00.558]             `[[` <- base::`[[`
[13:38:00.558]             `+` <- base::`+`
[13:38:00.558]             `<<-` <- base::`<<-`
[13:38:00.558]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:00.558]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:00.558]                   3L)]
[13:38:00.558]             }
[13:38:00.558]             function(cond) {
[13:38:00.558]                 is_error <- inherits(cond, "error")
[13:38:00.558]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:00.558]                   NULL)
[13:38:00.558]                 if (is_error) {
[13:38:00.558]                   sessionInformation <- function() {
[13:38:00.558]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:00.558]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:00.558]                       search = base::search(), system = base::Sys.info())
[13:38:00.558]                   }
[13:38:00.558]                   ...future.conditions[[length(...future.conditions) + 
[13:38:00.558]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:00.558]                     cond$call), session = sessionInformation(), 
[13:38:00.558]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:00.558]                   signalCondition(cond)
[13:38:00.558]                 }
[13:38:00.558]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:00.558]                 "immediateCondition"))) {
[13:38:00.558]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:00.558]                   ...future.conditions[[length(...future.conditions) + 
[13:38:00.558]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:00.558]                   if (TRUE && !signal) {
[13:38:00.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.558]                     {
[13:38:00.558]                       inherits <- base::inherits
[13:38:00.558]                       invokeRestart <- base::invokeRestart
[13:38:00.558]                       is.null <- base::is.null
[13:38:00.558]                       muffled <- FALSE
[13:38:00.558]                       if (inherits(cond, "message")) {
[13:38:00.558]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:00.558]                         if (muffled) 
[13:38:00.558]                           invokeRestart("muffleMessage")
[13:38:00.558]                       }
[13:38:00.558]                       else if (inherits(cond, "warning")) {
[13:38:00.558]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:00.558]                         if (muffled) 
[13:38:00.558]                           invokeRestart("muffleWarning")
[13:38:00.558]                       }
[13:38:00.558]                       else if (inherits(cond, "condition")) {
[13:38:00.558]                         if (!is.null(pattern)) {
[13:38:00.558]                           computeRestarts <- base::computeRestarts
[13:38:00.558]                           grepl <- base::grepl
[13:38:00.558]                           restarts <- computeRestarts(cond)
[13:38:00.558]                           for (restart in restarts) {
[13:38:00.558]                             name <- restart$name
[13:38:00.558]                             if (is.null(name)) 
[13:38:00.558]                               next
[13:38:00.558]                             if (!grepl(pattern, name)) 
[13:38:00.558]                               next
[13:38:00.558]                             invokeRestart(restart)
[13:38:00.558]                             muffled <- TRUE
[13:38:00.558]                             break
[13:38:00.558]                           }
[13:38:00.558]                         }
[13:38:00.558]                       }
[13:38:00.558]                       invisible(muffled)
[13:38:00.558]                     }
[13:38:00.558]                     muffleCondition(cond, pattern = "^muffle")
[13:38:00.558]                   }
[13:38:00.558]                 }
[13:38:00.558]                 else {
[13:38:00.558]                   if (TRUE) {
[13:38:00.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.558]                     {
[13:38:00.558]                       inherits <- base::inherits
[13:38:00.558]                       invokeRestart <- base::invokeRestart
[13:38:00.558]                       is.null <- base::is.null
[13:38:00.558]                       muffled <- FALSE
[13:38:00.558]                       if (inherits(cond, "message")) {
[13:38:00.558]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:00.558]                         if (muffled) 
[13:38:00.558]                           invokeRestart("muffleMessage")
[13:38:00.558]                       }
[13:38:00.558]                       else if (inherits(cond, "warning")) {
[13:38:00.558]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:00.558]                         if (muffled) 
[13:38:00.558]                           invokeRestart("muffleWarning")
[13:38:00.558]                       }
[13:38:00.558]                       else if (inherits(cond, "condition")) {
[13:38:00.558]                         if (!is.null(pattern)) {
[13:38:00.558]                           computeRestarts <- base::computeRestarts
[13:38:00.558]                           grepl <- base::grepl
[13:38:00.558]                           restarts <- computeRestarts(cond)
[13:38:00.558]                           for (restart in restarts) {
[13:38:00.558]                             name <- restart$name
[13:38:00.558]                             if (is.null(name)) 
[13:38:00.558]                               next
[13:38:00.558]                             if (!grepl(pattern, name)) 
[13:38:00.558]                               next
[13:38:00.558]                             invokeRestart(restart)
[13:38:00.558]                             muffled <- TRUE
[13:38:00.558]                             break
[13:38:00.558]                           }
[13:38:00.558]                         }
[13:38:00.558]                       }
[13:38:00.558]                       invisible(muffled)
[13:38:00.558]                     }
[13:38:00.558]                     muffleCondition(cond, pattern = "^muffle")
[13:38:00.558]                   }
[13:38:00.558]                 }
[13:38:00.558]             }
[13:38:00.558]         }))
[13:38:00.558]     }, error = function(ex) {
[13:38:00.558]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:00.558]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:00.558]                 ...future.rng), started = ...future.startTime, 
[13:38:00.558]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:00.558]             version = "1.8"), class = "FutureResult")
[13:38:00.558]     }, finally = {
[13:38:00.558]         if (!identical(...future.workdir, getwd())) 
[13:38:00.558]             setwd(...future.workdir)
[13:38:00.558]         {
[13:38:00.558]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:00.558]                 ...future.oldOptions$nwarnings <- NULL
[13:38:00.558]             }
[13:38:00.558]             base::options(...future.oldOptions)
[13:38:00.558]             if (.Platform$OS.type == "windows") {
[13:38:00.558]                 old_names <- names(...future.oldEnvVars)
[13:38:00.558]                 envs <- base::Sys.getenv()
[13:38:00.558]                 names <- names(envs)
[13:38:00.558]                 common <- intersect(names, old_names)
[13:38:00.558]                 added <- setdiff(names, old_names)
[13:38:00.558]                 removed <- setdiff(old_names, names)
[13:38:00.558]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:00.558]                   envs[common]]
[13:38:00.558]                 NAMES <- toupper(changed)
[13:38:00.558]                 args <- list()
[13:38:00.558]                 for (kk in seq_along(NAMES)) {
[13:38:00.558]                   name <- changed[[kk]]
[13:38:00.558]                   NAME <- NAMES[[kk]]
[13:38:00.558]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.558]                     next
[13:38:00.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:00.558]                 }
[13:38:00.558]                 NAMES <- toupper(added)
[13:38:00.558]                 for (kk in seq_along(NAMES)) {
[13:38:00.558]                   name <- added[[kk]]
[13:38:00.558]                   NAME <- NAMES[[kk]]
[13:38:00.558]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.558]                     next
[13:38:00.558]                   args[[name]] <- ""
[13:38:00.558]                 }
[13:38:00.558]                 NAMES <- toupper(removed)
[13:38:00.558]                 for (kk in seq_along(NAMES)) {
[13:38:00.558]                   name <- removed[[kk]]
[13:38:00.558]                   NAME <- NAMES[[kk]]
[13:38:00.558]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.558]                     next
[13:38:00.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:00.558]                 }
[13:38:00.558]                 if (length(args) > 0) 
[13:38:00.558]                   base::do.call(base::Sys.setenv, args = args)
[13:38:00.558]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:00.558]             }
[13:38:00.558]             else {
[13:38:00.558]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:00.558]             }
[13:38:00.558]             {
[13:38:00.558]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:00.558]                   0L) {
[13:38:00.558]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:00.558]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:00.558]                   base::options(opts)
[13:38:00.558]                 }
[13:38:00.558]                 {
[13:38:00.558]                   {
[13:38:00.558]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:00.558]                     NULL
[13:38:00.558]                   }
[13:38:00.558]                   options(future.plan = NULL)
[13:38:00.558]                   if (is.na(NA_character_)) 
[13:38:00.558]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:00.558]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:00.558]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:00.558]                     .init = FALSE)
[13:38:00.558]                 }
[13:38:00.558]             }
[13:38:00.558]         }
[13:38:00.558]     })
[13:38:00.558]     if (TRUE) {
[13:38:00.558]         base::sink(type = "output", split = FALSE)
[13:38:00.558]         if (TRUE) {
[13:38:00.558]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:00.558]         }
[13:38:00.558]         else {
[13:38:00.558]             ...future.result["stdout"] <- base::list(NULL)
[13:38:00.558]         }
[13:38:00.558]         base::close(...future.stdout)
[13:38:00.558]         ...future.stdout <- NULL
[13:38:00.558]     }
[13:38:00.558]     ...future.result$conditions <- ...future.conditions
[13:38:00.558]     ...future.result$finished <- base::Sys.time()
[13:38:00.558]     ...future.result
[13:38:00.558] }
[13:38:00.560] Poll #1 (0): usedNodes() = 2, workers = 2
[13:38:00.570] receiveMessageFromWorker() for ClusterFuture ...
[13:38:00.571] - Validating connection of MultisessionFuture
[13:38:00.571] - received message: FutureResult
[13:38:00.571] - Received FutureResult
[13:38:00.571] - Erased future from FutureRegistry
[13:38:00.571] result() for ClusterFuture ...
[13:38:00.571] - result already collected: FutureResult
[13:38:00.571] result() for ClusterFuture ... done
[13:38:00.571] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:00.571] result() for ClusterFuture ...
[13:38:00.571] - result already collected: FutureResult
[13:38:00.572] result() for ClusterFuture ... done
[13:38:00.572] result() for ClusterFuture ...
[13:38:00.572] - result already collected: FutureResult
[13:38:00.572] result() for ClusterFuture ... done
[13:38:00.573] MultisessionFuture started
[13:38:00.573] - Launch lazy future ... done
[13:38:00.573] run() for ‘MultisessionFuture’ ... done
[13:38:00.573] resolve() on list ...
[13:38:00.573]  recursive: 0
[13:38:00.573]  length: 3
[13:38:00.573]  elements: ‘a’, ‘b’, ‘’
[13:38:00.574] receiveMessageFromWorker() for ClusterFuture ...
[13:38:00.574] - Validating connection of MultisessionFuture
[13:38:00.574] - received message: FutureResult
[13:38:00.574] - Received FutureResult
[13:38:00.574] - Erased future from FutureRegistry
[13:38:00.574] result() for ClusterFuture ...
[13:38:00.574] - result already collected: FutureResult
[13:38:00.575] result() for ClusterFuture ... done
[13:38:00.575] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:00.575] Future #1
[13:38:00.575]  length: 2 (resolved future 1)
[13:38:00.575] receiveMessageFromWorker() for ClusterFuture ...
[13:38:00.575] - Validating connection of MultisessionFuture
[13:38:00.576] - received message: FutureResult
[13:38:00.576] - Received FutureResult
[13:38:00.576] - Erased future from FutureRegistry
[13:38:00.576] result() for ClusterFuture ...
[13:38:00.576] - result already collected: FutureResult
[13:38:00.576] result() for ClusterFuture ... done
[13:38:00.576] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:00.576] Future #2
[13:38:00.576]  length: 1 (resolved future 2)
[13:38:00.576]  length: 0 (resolved future 3)
[13:38:00.576] resolve() on list ... DONE
[13:38:00.577] getGlobalsAndPackages() ...
[13:38:00.577] Searching for globals...
[13:38:00.577] 
[13:38:00.577] Searching for globals ... DONE
[13:38:00.577] - globals: [0] <none>
[13:38:00.577] getGlobalsAndPackages() ... DONE
[13:38:00.577] getGlobalsAndPackages() ...
[13:38:00.578] Searching for globals...
[13:38:00.578] 
[13:38:00.578] Searching for globals ... DONE
[13:38:00.578] - globals: [0] <none>
[13:38:00.578] getGlobalsAndPackages() ... DONE
[13:38:00.578] run() for ‘Future’ ...
[13:38:00.578] - state: ‘created’
[13:38:00.579] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:00.593] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:00.593] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:00.593]   - Field: ‘node’
[13:38:00.593]   - Field: ‘label’
[13:38:00.594]   - Field: ‘local’
[13:38:00.594]   - Field: ‘owner’
[13:38:00.594]   - Field: ‘envir’
[13:38:00.594]   - Field: ‘workers’
[13:38:00.594]   - Field: ‘packages’
[13:38:00.594]   - Field: ‘gc’
[13:38:00.594]   - Field: ‘conditions’
[13:38:00.594]   - Field: ‘persistent’
[13:38:00.594]   - Field: ‘expr’
[13:38:00.594]   - Field: ‘uuid’
[13:38:00.595]   - Field: ‘seed’
[13:38:00.595]   - Field: ‘version’
[13:38:00.595]   - Field: ‘result’
[13:38:00.595]   - Field: ‘asynchronous’
[13:38:00.595]   - Field: ‘calls’
[13:38:00.595]   - Field: ‘globals’
[13:38:00.595]   - Field: ‘stdout’
[13:38:00.595]   - Field: ‘earlySignal’
[13:38:00.595]   - Field: ‘lazy’
[13:38:00.595]   - Field: ‘state’
[13:38:00.595] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:00.596] - Launch lazy future ...
[13:38:00.596] Packages needed by the future expression (n = 0): <none>
[13:38:00.596] Packages needed by future strategies (n = 0): <none>
[13:38:00.596] {
[13:38:00.596]     {
[13:38:00.596]         {
[13:38:00.596]             ...future.startTime <- base::Sys.time()
[13:38:00.596]             {
[13:38:00.596]                 {
[13:38:00.596]                   {
[13:38:00.596]                     {
[13:38:00.596]                       base::local({
[13:38:00.596]                         has_future <- base::requireNamespace("future", 
[13:38:00.596]                           quietly = TRUE)
[13:38:00.596]                         if (has_future) {
[13:38:00.596]                           ns <- base::getNamespace("future")
[13:38:00.596]                           version <- ns[[".package"]][["version"]]
[13:38:00.596]                           if (is.null(version)) 
[13:38:00.596]                             version <- utils::packageVersion("future")
[13:38:00.596]                         }
[13:38:00.596]                         else {
[13:38:00.596]                           version <- NULL
[13:38:00.596]                         }
[13:38:00.596]                         if (!has_future || version < "1.8.0") {
[13:38:00.596]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:00.596]                             "", base::R.version$version.string), 
[13:38:00.596]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:00.596]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:00.596]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:00.596]                               "release", "version")], collapse = " "), 
[13:38:00.596]                             hostname = base::Sys.info()[["nodename"]])
[13:38:00.596]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:00.596]                             info)
[13:38:00.596]                           info <- base::paste(info, collapse = "; ")
[13:38:00.596]                           if (!has_future) {
[13:38:00.596]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:00.596]                               info)
[13:38:00.596]                           }
[13:38:00.596]                           else {
[13:38:00.596]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:00.596]                               info, version)
[13:38:00.596]                           }
[13:38:00.596]                           base::stop(msg)
[13:38:00.596]                         }
[13:38:00.596]                       })
[13:38:00.596]                     }
[13:38:00.596]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:00.596]                     base::options(mc.cores = 1L)
[13:38:00.596]                   }
[13:38:00.596]                   ...future.strategy.old <- future::plan("list")
[13:38:00.596]                   options(future.plan = NULL)
[13:38:00.596]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:00.596]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:00.596]                 }
[13:38:00.596]                 ...future.workdir <- getwd()
[13:38:00.596]             }
[13:38:00.596]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:00.596]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:00.596]         }
[13:38:00.596]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:00.596]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:00.596]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:00.596]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:00.596]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:00.596]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:00.596]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:00.596]             base::names(...future.oldOptions))
[13:38:00.596]     }
[13:38:00.596]     if (FALSE) {
[13:38:00.596]     }
[13:38:00.596]     else {
[13:38:00.596]         if (TRUE) {
[13:38:00.596]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:00.596]                 open = "w")
[13:38:00.596]         }
[13:38:00.596]         else {
[13:38:00.596]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:00.596]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:00.596]         }
[13:38:00.596]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:00.596]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:00.596]             base::sink(type = "output", split = FALSE)
[13:38:00.596]             base::close(...future.stdout)
[13:38:00.596]         }, add = TRUE)
[13:38:00.596]     }
[13:38:00.596]     ...future.frame <- base::sys.nframe()
[13:38:00.596]     ...future.conditions <- base::list()
[13:38:00.596]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:00.596]     if (FALSE) {
[13:38:00.596]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:00.596]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:00.596]     }
[13:38:00.596]     ...future.result <- base::tryCatch({
[13:38:00.596]         base::withCallingHandlers({
[13:38:00.596]             ...future.value <- base::withVisible(base::local({
[13:38:00.596]                 ...future.makeSendCondition <- base::local({
[13:38:00.596]                   sendCondition <- NULL
[13:38:00.596]                   function(frame = 1L) {
[13:38:00.596]                     if (is.function(sendCondition)) 
[13:38:00.596]                       return(sendCondition)
[13:38:00.596]                     ns <- getNamespace("parallel")
[13:38:00.596]                     if (exists("sendData", mode = "function", 
[13:38:00.596]                       envir = ns)) {
[13:38:00.596]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:00.596]                         envir = ns)
[13:38:00.596]                       envir <- sys.frame(frame)
[13:38:00.596]                       master <- NULL
[13:38:00.596]                       while (!identical(envir, .GlobalEnv) && 
[13:38:00.596]                         !identical(envir, emptyenv())) {
[13:38:00.596]                         if (exists("master", mode = "list", envir = envir, 
[13:38:00.596]                           inherits = FALSE)) {
[13:38:00.596]                           master <- get("master", mode = "list", 
[13:38:00.596]                             envir = envir, inherits = FALSE)
[13:38:00.596]                           if (inherits(master, c("SOCKnode", 
[13:38:00.596]                             "SOCK0node"))) {
[13:38:00.596]                             sendCondition <<- function(cond) {
[13:38:00.596]                               data <- list(type = "VALUE", value = cond, 
[13:38:00.596]                                 success = TRUE)
[13:38:00.596]                               parallel_sendData(master, data)
[13:38:00.596]                             }
[13:38:00.596]                             return(sendCondition)
[13:38:00.596]                           }
[13:38:00.596]                         }
[13:38:00.596]                         frame <- frame + 1L
[13:38:00.596]                         envir <- sys.frame(frame)
[13:38:00.596]                       }
[13:38:00.596]                     }
[13:38:00.596]                     sendCondition <<- function(cond) NULL
[13:38:00.596]                   }
[13:38:00.596]                 })
[13:38:00.596]                 withCallingHandlers({
[13:38:00.596]                   2
[13:38:00.596]                 }, immediateCondition = function(cond) {
[13:38:00.596]                   sendCondition <- ...future.makeSendCondition()
[13:38:00.596]                   sendCondition(cond)
[13:38:00.596]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.596]                   {
[13:38:00.596]                     inherits <- base::inherits
[13:38:00.596]                     invokeRestart <- base::invokeRestart
[13:38:00.596]                     is.null <- base::is.null
[13:38:00.596]                     muffled <- FALSE
[13:38:00.596]                     if (inherits(cond, "message")) {
[13:38:00.596]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:00.596]                       if (muffled) 
[13:38:00.596]                         invokeRestart("muffleMessage")
[13:38:00.596]                     }
[13:38:00.596]                     else if (inherits(cond, "warning")) {
[13:38:00.596]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:00.596]                       if (muffled) 
[13:38:00.596]                         invokeRestart("muffleWarning")
[13:38:00.596]                     }
[13:38:00.596]                     else if (inherits(cond, "condition")) {
[13:38:00.596]                       if (!is.null(pattern)) {
[13:38:00.596]                         computeRestarts <- base::computeRestarts
[13:38:00.596]                         grepl <- base::grepl
[13:38:00.596]                         restarts <- computeRestarts(cond)
[13:38:00.596]                         for (restart in restarts) {
[13:38:00.596]                           name <- restart$name
[13:38:00.596]                           if (is.null(name)) 
[13:38:00.596]                             next
[13:38:00.596]                           if (!grepl(pattern, name)) 
[13:38:00.596]                             next
[13:38:00.596]                           invokeRestart(restart)
[13:38:00.596]                           muffled <- TRUE
[13:38:00.596]                           break
[13:38:00.596]                         }
[13:38:00.596]                       }
[13:38:00.596]                     }
[13:38:00.596]                     invisible(muffled)
[13:38:00.596]                   }
[13:38:00.596]                   muffleCondition(cond)
[13:38:00.596]                 })
[13:38:00.596]             }))
[13:38:00.596]             future::FutureResult(value = ...future.value$value, 
[13:38:00.596]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:00.596]                   ...future.rng), globalenv = if (FALSE) 
[13:38:00.596]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:00.596]                     ...future.globalenv.names))
[13:38:00.596]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:00.596]         }, condition = base::local({
[13:38:00.596]             c <- base::c
[13:38:00.596]             inherits <- base::inherits
[13:38:00.596]             invokeRestart <- base::invokeRestart
[13:38:00.596]             length <- base::length
[13:38:00.596]             list <- base::list
[13:38:00.596]             seq.int <- base::seq.int
[13:38:00.596]             signalCondition <- base::signalCondition
[13:38:00.596]             sys.calls <- base::sys.calls
[13:38:00.596]             `[[` <- base::`[[`
[13:38:00.596]             `+` <- base::`+`
[13:38:00.596]             `<<-` <- base::`<<-`
[13:38:00.596]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:00.596]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:00.596]                   3L)]
[13:38:00.596]             }
[13:38:00.596]             function(cond) {
[13:38:00.596]                 is_error <- inherits(cond, "error")
[13:38:00.596]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:00.596]                   NULL)
[13:38:00.596]                 if (is_error) {
[13:38:00.596]                   sessionInformation <- function() {
[13:38:00.596]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:00.596]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:00.596]                       search = base::search(), system = base::Sys.info())
[13:38:00.596]                   }
[13:38:00.596]                   ...future.conditions[[length(...future.conditions) + 
[13:38:00.596]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:00.596]                     cond$call), session = sessionInformation(), 
[13:38:00.596]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:00.596]                   signalCondition(cond)
[13:38:00.596]                 }
[13:38:00.596]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:00.596]                 "immediateCondition"))) {
[13:38:00.596]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:00.596]                   ...future.conditions[[length(...future.conditions) + 
[13:38:00.596]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:00.596]                   if (TRUE && !signal) {
[13:38:00.596]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.596]                     {
[13:38:00.596]                       inherits <- base::inherits
[13:38:00.596]                       invokeRestart <- base::invokeRestart
[13:38:00.596]                       is.null <- base::is.null
[13:38:00.596]                       muffled <- FALSE
[13:38:00.596]                       if (inherits(cond, "message")) {
[13:38:00.596]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:00.596]                         if (muffled) 
[13:38:00.596]                           invokeRestart("muffleMessage")
[13:38:00.596]                       }
[13:38:00.596]                       else if (inherits(cond, "warning")) {
[13:38:00.596]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:00.596]                         if (muffled) 
[13:38:00.596]                           invokeRestart("muffleWarning")
[13:38:00.596]                       }
[13:38:00.596]                       else if (inherits(cond, "condition")) {
[13:38:00.596]                         if (!is.null(pattern)) {
[13:38:00.596]                           computeRestarts <- base::computeRestarts
[13:38:00.596]                           grepl <- base::grepl
[13:38:00.596]                           restarts <- computeRestarts(cond)
[13:38:00.596]                           for (restart in restarts) {
[13:38:00.596]                             name <- restart$name
[13:38:00.596]                             if (is.null(name)) 
[13:38:00.596]                               next
[13:38:00.596]                             if (!grepl(pattern, name)) 
[13:38:00.596]                               next
[13:38:00.596]                             invokeRestart(restart)
[13:38:00.596]                             muffled <- TRUE
[13:38:00.596]                             break
[13:38:00.596]                           }
[13:38:00.596]                         }
[13:38:00.596]                       }
[13:38:00.596]                       invisible(muffled)
[13:38:00.596]                     }
[13:38:00.596]                     muffleCondition(cond, pattern = "^muffle")
[13:38:00.596]                   }
[13:38:00.596]                 }
[13:38:00.596]                 else {
[13:38:00.596]                   if (TRUE) {
[13:38:00.596]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.596]                     {
[13:38:00.596]                       inherits <- base::inherits
[13:38:00.596]                       invokeRestart <- base::invokeRestart
[13:38:00.596]                       is.null <- base::is.null
[13:38:00.596]                       muffled <- FALSE
[13:38:00.596]                       if (inherits(cond, "message")) {
[13:38:00.596]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:00.596]                         if (muffled) 
[13:38:00.596]                           invokeRestart("muffleMessage")
[13:38:00.596]                       }
[13:38:00.596]                       else if (inherits(cond, "warning")) {
[13:38:00.596]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:00.596]                         if (muffled) 
[13:38:00.596]                           invokeRestart("muffleWarning")
[13:38:00.596]                       }
[13:38:00.596]                       else if (inherits(cond, "condition")) {
[13:38:00.596]                         if (!is.null(pattern)) {
[13:38:00.596]                           computeRestarts <- base::computeRestarts
[13:38:00.596]                           grepl <- base::grepl
[13:38:00.596]                           restarts <- computeRestarts(cond)
[13:38:00.596]                           for (restart in restarts) {
[13:38:00.596]                             name <- restart$name
[13:38:00.596]                             if (is.null(name)) 
[13:38:00.596]                               next
[13:38:00.596]                             if (!grepl(pattern, name)) 
[13:38:00.596]                               next
[13:38:00.596]                             invokeRestart(restart)
[13:38:00.596]                             muffled <- TRUE
[13:38:00.596]                             break
[13:38:00.596]                           }
[13:38:00.596]                         }
[13:38:00.596]                       }
[13:38:00.596]                       invisible(muffled)
[13:38:00.596]                     }
[13:38:00.596]                     muffleCondition(cond, pattern = "^muffle")
[13:38:00.596]                   }
[13:38:00.596]                 }
[13:38:00.596]             }
[13:38:00.596]         }))
[13:38:00.596]     }, error = function(ex) {
[13:38:00.596]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:00.596]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:00.596]                 ...future.rng), started = ...future.startTime, 
[13:38:00.596]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:00.596]             version = "1.8"), class = "FutureResult")
[13:38:00.596]     }, finally = {
[13:38:00.596]         if (!identical(...future.workdir, getwd())) 
[13:38:00.596]             setwd(...future.workdir)
[13:38:00.596]         {
[13:38:00.596]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:00.596]                 ...future.oldOptions$nwarnings <- NULL
[13:38:00.596]             }
[13:38:00.596]             base::options(...future.oldOptions)
[13:38:00.596]             if (.Platform$OS.type == "windows") {
[13:38:00.596]                 old_names <- names(...future.oldEnvVars)
[13:38:00.596]                 envs <- base::Sys.getenv()
[13:38:00.596]                 names <- names(envs)
[13:38:00.596]                 common <- intersect(names, old_names)
[13:38:00.596]                 added <- setdiff(names, old_names)
[13:38:00.596]                 removed <- setdiff(old_names, names)
[13:38:00.596]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:00.596]                   envs[common]]
[13:38:00.596]                 NAMES <- toupper(changed)
[13:38:00.596]                 args <- list()
[13:38:00.596]                 for (kk in seq_along(NAMES)) {
[13:38:00.596]                   name <- changed[[kk]]
[13:38:00.596]                   NAME <- NAMES[[kk]]
[13:38:00.596]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.596]                     next
[13:38:00.596]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:00.596]                 }
[13:38:00.596]                 NAMES <- toupper(added)
[13:38:00.596]                 for (kk in seq_along(NAMES)) {
[13:38:00.596]                   name <- added[[kk]]
[13:38:00.596]                   NAME <- NAMES[[kk]]
[13:38:00.596]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.596]                     next
[13:38:00.596]                   args[[name]] <- ""
[13:38:00.596]                 }
[13:38:00.596]                 NAMES <- toupper(removed)
[13:38:00.596]                 for (kk in seq_along(NAMES)) {
[13:38:00.596]                   name <- removed[[kk]]
[13:38:00.596]                   NAME <- NAMES[[kk]]
[13:38:00.596]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.596]                     next
[13:38:00.596]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:00.596]                 }
[13:38:00.596]                 if (length(args) > 0) 
[13:38:00.596]                   base::do.call(base::Sys.setenv, args = args)
[13:38:00.596]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:00.596]             }
[13:38:00.596]             else {
[13:38:00.596]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:00.596]             }
[13:38:00.596]             {
[13:38:00.596]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:00.596]                   0L) {
[13:38:00.596]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:00.596]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:00.596]                   base::options(opts)
[13:38:00.596]                 }
[13:38:00.596]                 {
[13:38:00.596]                   {
[13:38:00.596]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:00.596]                     NULL
[13:38:00.596]                   }
[13:38:00.596]                   options(future.plan = NULL)
[13:38:00.596]                   if (is.na(NA_character_)) 
[13:38:00.596]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:00.596]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:00.596]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:00.596]                     .init = FALSE)
[13:38:00.596]                 }
[13:38:00.596]             }
[13:38:00.596]         }
[13:38:00.596]     })
[13:38:00.596]     if (TRUE) {
[13:38:00.596]         base::sink(type = "output", split = FALSE)
[13:38:00.596]         if (TRUE) {
[13:38:00.596]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:00.596]         }
[13:38:00.596]         else {
[13:38:00.596]             ...future.result["stdout"] <- base::list(NULL)
[13:38:00.596]         }
[13:38:00.596]         base::close(...future.stdout)
[13:38:00.596]         ...future.stdout <- NULL
[13:38:00.596]     }
[13:38:00.596]     ...future.result$conditions <- ...future.conditions
[13:38:00.596]     ...future.result$finished <- base::Sys.time()
[13:38:00.596]     ...future.result
[13:38:00.596] }
[13:38:00.599] MultisessionFuture started
[13:38:00.599] - Launch lazy future ... done
[13:38:00.599] run() for ‘MultisessionFuture’ ... done
[13:38:00.600] resolve() on list ...
[13:38:00.600]  recursive: 0
[13:38:00.600]  length: 3
[13:38:00.600]  elements: ‘a’, ‘b’, ‘’
[13:38:00.600] run() for ‘Future’ ...
[13:38:00.600] - state: ‘created’
[13:38:00.601] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:00.614] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:00.615] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:00.615]   - Field: ‘node’
[13:38:00.615]   - Field: ‘label’
[13:38:00.615]   - Field: ‘local’
[13:38:00.615]   - Field: ‘owner’
[13:38:00.615]   - Field: ‘envir’
[13:38:00.615]   - Field: ‘workers’
[13:38:00.615]   - Field: ‘packages’
[13:38:00.615]   - Field: ‘gc’
[13:38:00.615]   - Field: ‘conditions’
[13:38:00.616]   - Field: ‘persistent’
[13:38:00.616]   - Field: ‘expr’
[13:38:00.616]   - Field: ‘uuid’
[13:38:00.616]   - Field: ‘seed’
[13:38:00.616]   - Field: ‘version’
[13:38:00.616]   - Field: ‘result’
[13:38:00.616]   - Field: ‘asynchronous’
[13:38:00.616]   - Field: ‘calls’
[13:38:00.616]   - Field: ‘globals’
[13:38:00.616]   - Field: ‘stdout’
[13:38:00.616]   - Field: ‘earlySignal’
[13:38:00.617]   - Field: ‘lazy’
[13:38:00.617]   - Field: ‘state’
[13:38:00.617] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:00.617] - Launch lazy future ...
[13:38:00.617] Packages needed by the future expression (n = 0): <none>
[13:38:00.617] Packages needed by future strategies (n = 0): <none>
[13:38:00.618] {
[13:38:00.618]     {
[13:38:00.618]         {
[13:38:00.618]             ...future.startTime <- base::Sys.time()
[13:38:00.618]             {
[13:38:00.618]                 {
[13:38:00.618]                   {
[13:38:00.618]                     {
[13:38:00.618]                       base::local({
[13:38:00.618]                         has_future <- base::requireNamespace("future", 
[13:38:00.618]                           quietly = TRUE)
[13:38:00.618]                         if (has_future) {
[13:38:00.618]                           ns <- base::getNamespace("future")
[13:38:00.618]                           version <- ns[[".package"]][["version"]]
[13:38:00.618]                           if (is.null(version)) 
[13:38:00.618]                             version <- utils::packageVersion("future")
[13:38:00.618]                         }
[13:38:00.618]                         else {
[13:38:00.618]                           version <- NULL
[13:38:00.618]                         }
[13:38:00.618]                         if (!has_future || version < "1.8.0") {
[13:38:00.618]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:00.618]                             "", base::R.version$version.string), 
[13:38:00.618]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:00.618]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:00.618]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:00.618]                               "release", "version")], collapse = " "), 
[13:38:00.618]                             hostname = base::Sys.info()[["nodename"]])
[13:38:00.618]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:00.618]                             info)
[13:38:00.618]                           info <- base::paste(info, collapse = "; ")
[13:38:00.618]                           if (!has_future) {
[13:38:00.618]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:00.618]                               info)
[13:38:00.618]                           }
[13:38:00.618]                           else {
[13:38:00.618]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:00.618]                               info, version)
[13:38:00.618]                           }
[13:38:00.618]                           base::stop(msg)
[13:38:00.618]                         }
[13:38:00.618]                       })
[13:38:00.618]                     }
[13:38:00.618]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:00.618]                     base::options(mc.cores = 1L)
[13:38:00.618]                   }
[13:38:00.618]                   ...future.strategy.old <- future::plan("list")
[13:38:00.618]                   options(future.plan = NULL)
[13:38:00.618]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:00.618]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:00.618]                 }
[13:38:00.618]                 ...future.workdir <- getwd()
[13:38:00.618]             }
[13:38:00.618]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:00.618]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:00.618]         }
[13:38:00.618]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:00.618]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:00.618]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:00.618]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:00.618]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:00.618]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:00.618]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:00.618]             base::names(...future.oldOptions))
[13:38:00.618]     }
[13:38:00.618]     if (FALSE) {
[13:38:00.618]     }
[13:38:00.618]     else {
[13:38:00.618]         if (TRUE) {
[13:38:00.618]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:00.618]                 open = "w")
[13:38:00.618]         }
[13:38:00.618]         else {
[13:38:00.618]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:00.618]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:00.618]         }
[13:38:00.618]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:00.618]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:00.618]             base::sink(type = "output", split = FALSE)
[13:38:00.618]             base::close(...future.stdout)
[13:38:00.618]         }, add = TRUE)
[13:38:00.618]     }
[13:38:00.618]     ...future.frame <- base::sys.nframe()
[13:38:00.618]     ...future.conditions <- base::list()
[13:38:00.618]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:00.618]     if (FALSE) {
[13:38:00.618]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:00.618]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:00.618]     }
[13:38:00.618]     ...future.result <- base::tryCatch({
[13:38:00.618]         base::withCallingHandlers({
[13:38:00.618]             ...future.value <- base::withVisible(base::local({
[13:38:00.618]                 ...future.makeSendCondition <- base::local({
[13:38:00.618]                   sendCondition <- NULL
[13:38:00.618]                   function(frame = 1L) {
[13:38:00.618]                     if (is.function(sendCondition)) 
[13:38:00.618]                       return(sendCondition)
[13:38:00.618]                     ns <- getNamespace("parallel")
[13:38:00.618]                     if (exists("sendData", mode = "function", 
[13:38:00.618]                       envir = ns)) {
[13:38:00.618]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:00.618]                         envir = ns)
[13:38:00.618]                       envir <- sys.frame(frame)
[13:38:00.618]                       master <- NULL
[13:38:00.618]                       while (!identical(envir, .GlobalEnv) && 
[13:38:00.618]                         !identical(envir, emptyenv())) {
[13:38:00.618]                         if (exists("master", mode = "list", envir = envir, 
[13:38:00.618]                           inherits = FALSE)) {
[13:38:00.618]                           master <- get("master", mode = "list", 
[13:38:00.618]                             envir = envir, inherits = FALSE)
[13:38:00.618]                           if (inherits(master, c("SOCKnode", 
[13:38:00.618]                             "SOCK0node"))) {
[13:38:00.618]                             sendCondition <<- function(cond) {
[13:38:00.618]                               data <- list(type = "VALUE", value = cond, 
[13:38:00.618]                                 success = TRUE)
[13:38:00.618]                               parallel_sendData(master, data)
[13:38:00.618]                             }
[13:38:00.618]                             return(sendCondition)
[13:38:00.618]                           }
[13:38:00.618]                         }
[13:38:00.618]                         frame <- frame + 1L
[13:38:00.618]                         envir <- sys.frame(frame)
[13:38:00.618]                       }
[13:38:00.618]                     }
[13:38:00.618]                     sendCondition <<- function(cond) NULL
[13:38:00.618]                   }
[13:38:00.618]                 })
[13:38:00.618]                 withCallingHandlers({
[13:38:00.618]                   1
[13:38:00.618]                 }, immediateCondition = function(cond) {
[13:38:00.618]                   sendCondition <- ...future.makeSendCondition()
[13:38:00.618]                   sendCondition(cond)
[13:38:00.618]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.618]                   {
[13:38:00.618]                     inherits <- base::inherits
[13:38:00.618]                     invokeRestart <- base::invokeRestart
[13:38:00.618]                     is.null <- base::is.null
[13:38:00.618]                     muffled <- FALSE
[13:38:00.618]                     if (inherits(cond, "message")) {
[13:38:00.618]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:00.618]                       if (muffled) 
[13:38:00.618]                         invokeRestart("muffleMessage")
[13:38:00.618]                     }
[13:38:00.618]                     else if (inherits(cond, "warning")) {
[13:38:00.618]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:00.618]                       if (muffled) 
[13:38:00.618]                         invokeRestart("muffleWarning")
[13:38:00.618]                     }
[13:38:00.618]                     else if (inherits(cond, "condition")) {
[13:38:00.618]                       if (!is.null(pattern)) {
[13:38:00.618]                         computeRestarts <- base::computeRestarts
[13:38:00.618]                         grepl <- base::grepl
[13:38:00.618]                         restarts <- computeRestarts(cond)
[13:38:00.618]                         for (restart in restarts) {
[13:38:00.618]                           name <- restart$name
[13:38:00.618]                           if (is.null(name)) 
[13:38:00.618]                             next
[13:38:00.618]                           if (!grepl(pattern, name)) 
[13:38:00.618]                             next
[13:38:00.618]                           invokeRestart(restart)
[13:38:00.618]                           muffled <- TRUE
[13:38:00.618]                           break
[13:38:00.618]                         }
[13:38:00.618]                       }
[13:38:00.618]                     }
[13:38:00.618]                     invisible(muffled)
[13:38:00.618]                   }
[13:38:00.618]                   muffleCondition(cond)
[13:38:00.618]                 })
[13:38:00.618]             }))
[13:38:00.618]             future::FutureResult(value = ...future.value$value, 
[13:38:00.618]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:00.618]                   ...future.rng), globalenv = if (FALSE) 
[13:38:00.618]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:00.618]                     ...future.globalenv.names))
[13:38:00.618]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:00.618]         }, condition = base::local({
[13:38:00.618]             c <- base::c
[13:38:00.618]             inherits <- base::inherits
[13:38:00.618]             invokeRestart <- base::invokeRestart
[13:38:00.618]             length <- base::length
[13:38:00.618]             list <- base::list
[13:38:00.618]             seq.int <- base::seq.int
[13:38:00.618]             signalCondition <- base::signalCondition
[13:38:00.618]             sys.calls <- base::sys.calls
[13:38:00.618]             `[[` <- base::`[[`
[13:38:00.618]             `+` <- base::`+`
[13:38:00.618]             `<<-` <- base::`<<-`
[13:38:00.618]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:00.618]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:00.618]                   3L)]
[13:38:00.618]             }
[13:38:00.618]             function(cond) {
[13:38:00.618]                 is_error <- inherits(cond, "error")
[13:38:00.618]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:00.618]                   NULL)
[13:38:00.618]                 if (is_error) {
[13:38:00.618]                   sessionInformation <- function() {
[13:38:00.618]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:00.618]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:00.618]                       search = base::search(), system = base::Sys.info())
[13:38:00.618]                   }
[13:38:00.618]                   ...future.conditions[[length(...future.conditions) + 
[13:38:00.618]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:00.618]                     cond$call), session = sessionInformation(), 
[13:38:00.618]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:00.618]                   signalCondition(cond)
[13:38:00.618]                 }
[13:38:00.618]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:00.618]                 "immediateCondition"))) {
[13:38:00.618]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:00.618]                   ...future.conditions[[length(...future.conditions) + 
[13:38:00.618]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:00.618]                   if (TRUE && !signal) {
[13:38:00.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.618]                     {
[13:38:00.618]                       inherits <- base::inherits
[13:38:00.618]                       invokeRestart <- base::invokeRestart
[13:38:00.618]                       is.null <- base::is.null
[13:38:00.618]                       muffled <- FALSE
[13:38:00.618]                       if (inherits(cond, "message")) {
[13:38:00.618]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:00.618]                         if (muffled) 
[13:38:00.618]                           invokeRestart("muffleMessage")
[13:38:00.618]                       }
[13:38:00.618]                       else if (inherits(cond, "warning")) {
[13:38:00.618]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:00.618]                         if (muffled) 
[13:38:00.618]                           invokeRestart("muffleWarning")
[13:38:00.618]                       }
[13:38:00.618]                       else if (inherits(cond, "condition")) {
[13:38:00.618]                         if (!is.null(pattern)) {
[13:38:00.618]                           computeRestarts <- base::computeRestarts
[13:38:00.618]                           grepl <- base::grepl
[13:38:00.618]                           restarts <- computeRestarts(cond)
[13:38:00.618]                           for (restart in restarts) {
[13:38:00.618]                             name <- restart$name
[13:38:00.618]                             if (is.null(name)) 
[13:38:00.618]                               next
[13:38:00.618]                             if (!grepl(pattern, name)) 
[13:38:00.618]                               next
[13:38:00.618]                             invokeRestart(restart)
[13:38:00.618]                             muffled <- TRUE
[13:38:00.618]                             break
[13:38:00.618]                           }
[13:38:00.618]                         }
[13:38:00.618]                       }
[13:38:00.618]                       invisible(muffled)
[13:38:00.618]                     }
[13:38:00.618]                     muffleCondition(cond, pattern = "^muffle")
[13:38:00.618]                   }
[13:38:00.618]                 }
[13:38:00.618]                 else {
[13:38:00.618]                   if (TRUE) {
[13:38:00.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.618]                     {
[13:38:00.618]                       inherits <- base::inherits
[13:38:00.618]                       invokeRestart <- base::invokeRestart
[13:38:00.618]                       is.null <- base::is.null
[13:38:00.618]                       muffled <- FALSE
[13:38:00.618]                       if (inherits(cond, "message")) {
[13:38:00.618]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:00.618]                         if (muffled) 
[13:38:00.618]                           invokeRestart("muffleMessage")
[13:38:00.618]                       }
[13:38:00.618]                       else if (inherits(cond, "warning")) {
[13:38:00.618]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:00.618]                         if (muffled) 
[13:38:00.618]                           invokeRestart("muffleWarning")
[13:38:00.618]                       }
[13:38:00.618]                       else if (inherits(cond, "condition")) {
[13:38:00.618]                         if (!is.null(pattern)) {
[13:38:00.618]                           computeRestarts <- base::computeRestarts
[13:38:00.618]                           grepl <- base::grepl
[13:38:00.618]                           restarts <- computeRestarts(cond)
[13:38:00.618]                           for (restart in restarts) {
[13:38:00.618]                             name <- restart$name
[13:38:00.618]                             if (is.null(name)) 
[13:38:00.618]                               next
[13:38:00.618]                             if (!grepl(pattern, name)) 
[13:38:00.618]                               next
[13:38:00.618]                             invokeRestart(restart)
[13:38:00.618]                             muffled <- TRUE
[13:38:00.618]                             break
[13:38:00.618]                           }
[13:38:00.618]                         }
[13:38:00.618]                       }
[13:38:00.618]                       invisible(muffled)
[13:38:00.618]                     }
[13:38:00.618]                     muffleCondition(cond, pattern = "^muffle")
[13:38:00.618]                   }
[13:38:00.618]                 }
[13:38:00.618]             }
[13:38:00.618]         }))
[13:38:00.618]     }, error = function(ex) {
[13:38:00.618]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:00.618]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:00.618]                 ...future.rng), started = ...future.startTime, 
[13:38:00.618]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:00.618]             version = "1.8"), class = "FutureResult")
[13:38:00.618]     }, finally = {
[13:38:00.618]         if (!identical(...future.workdir, getwd())) 
[13:38:00.618]             setwd(...future.workdir)
[13:38:00.618]         {
[13:38:00.618]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:00.618]                 ...future.oldOptions$nwarnings <- NULL
[13:38:00.618]             }
[13:38:00.618]             base::options(...future.oldOptions)
[13:38:00.618]             if (.Platform$OS.type == "windows") {
[13:38:00.618]                 old_names <- names(...future.oldEnvVars)
[13:38:00.618]                 envs <- base::Sys.getenv()
[13:38:00.618]                 names <- names(envs)
[13:38:00.618]                 common <- intersect(names, old_names)
[13:38:00.618]                 added <- setdiff(names, old_names)
[13:38:00.618]                 removed <- setdiff(old_names, names)
[13:38:00.618]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:00.618]                   envs[common]]
[13:38:00.618]                 NAMES <- toupper(changed)
[13:38:00.618]                 args <- list()
[13:38:00.618]                 for (kk in seq_along(NAMES)) {
[13:38:00.618]                   name <- changed[[kk]]
[13:38:00.618]                   NAME <- NAMES[[kk]]
[13:38:00.618]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.618]                     next
[13:38:00.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:00.618]                 }
[13:38:00.618]                 NAMES <- toupper(added)
[13:38:00.618]                 for (kk in seq_along(NAMES)) {
[13:38:00.618]                   name <- added[[kk]]
[13:38:00.618]                   NAME <- NAMES[[kk]]
[13:38:00.618]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.618]                     next
[13:38:00.618]                   args[[name]] <- ""
[13:38:00.618]                 }
[13:38:00.618]                 NAMES <- toupper(removed)
[13:38:00.618]                 for (kk in seq_along(NAMES)) {
[13:38:00.618]                   name <- removed[[kk]]
[13:38:00.618]                   NAME <- NAMES[[kk]]
[13:38:00.618]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.618]                     next
[13:38:00.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:00.618]                 }
[13:38:00.618]                 if (length(args) > 0) 
[13:38:00.618]                   base::do.call(base::Sys.setenv, args = args)
[13:38:00.618]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:00.618]             }
[13:38:00.618]             else {
[13:38:00.618]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:00.618]             }
[13:38:00.618]             {
[13:38:00.618]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:00.618]                   0L) {
[13:38:00.618]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:00.618]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:00.618]                   base::options(opts)
[13:38:00.618]                 }
[13:38:00.618]                 {
[13:38:00.618]                   {
[13:38:00.618]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:00.618]                     NULL
[13:38:00.618]                   }
[13:38:00.618]                   options(future.plan = NULL)
[13:38:00.618]                   if (is.na(NA_character_)) 
[13:38:00.618]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:00.618]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:00.618]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:00.618]                     .init = FALSE)
[13:38:00.618]                 }
[13:38:00.618]             }
[13:38:00.618]         }
[13:38:00.618]     })
[13:38:00.618]     if (TRUE) {
[13:38:00.618]         base::sink(type = "output", split = FALSE)
[13:38:00.618]         if (TRUE) {
[13:38:00.618]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:00.618]         }
[13:38:00.618]         else {
[13:38:00.618]             ...future.result["stdout"] <- base::list(NULL)
[13:38:00.618]         }
[13:38:00.618]         base::close(...future.stdout)
[13:38:00.618]         ...future.stdout <- NULL
[13:38:00.618]     }
[13:38:00.618]     ...future.result$conditions <- ...future.conditions
[13:38:00.618]     ...future.result$finished <- base::Sys.time()
[13:38:00.618]     ...future.result
[13:38:00.618] }
[13:38:00.620] MultisessionFuture started
[13:38:00.620] - Launch lazy future ... done
[13:38:00.621] run() for ‘MultisessionFuture’ ... done
[13:38:00.622] receiveMessageFromWorker() for ClusterFuture ...
[13:38:00.622] - Validating connection of MultisessionFuture
[13:38:00.622] - received message: FutureResult
[13:38:00.622] - Received FutureResult
[13:38:00.622] - Erased future from FutureRegistry
[13:38:00.623] result() for ClusterFuture ...
[13:38:00.623] - result already collected: FutureResult
[13:38:00.623] result() for ClusterFuture ... done
[13:38:00.623] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:00.623] Future #1
[13:38:00.623]  length: 2 (resolved future 1)
[13:38:00.623] receiveMessageFromWorker() for ClusterFuture ...
[13:38:00.623] - Validating connection of MultisessionFuture
[13:38:00.624] - received message: FutureResult
[13:38:00.624] - Received FutureResult
[13:38:00.624] - Erased future from FutureRegistry
[13:38:00.624] result() for ClusterFuture ...
[13:38:00.624] - result already collected: FutureResult
[13:38:00.624] result() for ClusterFuture ... done
[13:38:00.624] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:00.624] Future #2
[13:38:00.624]  length: 1 (resolved future 2)
[13:38:00.624]  length: 0 (resolved future 3)
[13:38:00.625] resolve() on list ... DONE
[13:38:00.625] getGlobalsAndPackages() ...
[13:38:00.625] Searching for globals...
[13:38:00.625] 
[13:38:00.625] Searching for globals ... DONE
[13:38:00.625] - globals: [0] <none>
[13:38:00.625] getGlobalsAndPackages() ... DONE
[13:38:00.626] getGlobalsAndPackages() ...
[13:38:00.626] Searching for globals...
[13:38:00.626] 
[13:38:00.626] Searching for globals ... DONE
[13:38:00.626] - globals: [0] <none>
[13:38:00.626] getGlobalsAndPackages() ... DONE
[13:38:00.626] resolve() on list ...
[13:38:00.627]  recursive: 0
[13:38:00.627]  length: 3
[13:38:00.627]  elements: ‘a’, ‘b’, ‘’
[13:38:00.627] run() for ‘Future’ ...
[13:38:00.627] - state: ‘created’
[13:38:00.627] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:00.640] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:00.640] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:00.641]   - Field: ‘node’
[13:38:00.641]   - Field: ‘label’
[13:38:00.641]   - Field: ‘local’
[13:38:00.641]   - Field: ‘owner’
[13:38:00.641]   - Field: ‘envir’
[13:38:00.641]   - Field: ‘workers’
[13:38:00.641]   - Field: ‘packages’
[13:38:00.641]   - Field: ‘gc’
[13:38:00.641]   - Field: ‘conditions’
[13:38:00.641]   - Field: ‘persistent’
[13:38:00.641]   - Field: ‘expr’
[13:38:00.642]   - Field: ‘uuid’
[13:38:00.642]   - Field: ‘seed’
[13:38:00.642]   - Field: ‘version’
[13:38:00.642]   - Field: ‘result’
[13:38:00.642]   - Field: ‘asynchronous’
[13:38:00.642]   - Field: ‘calls’
[13:38:00.642]   - Field: ‘globals’
[13:38:00.642]   - Field: ‘stdout’
[13:38:00.642]   - Field: ‘earlySignal’
[13:38:00.642]   - Field: ‘lazy’
[13:38:00.643]   - Field: ‘state’
[13:38:00.643] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:00.643] - Launch lazy future ...
[13:38:00.643] Packages needed by the future expression (n = 0): <none>
[13:38:00.643] Packages needed by future strategies (n = 0): <none>
[13:38:00.643] {
[13:38:00.643]     {
[13:38:00.643]         {
[13:38:00.643]             ...future.startTime <- base::Sys.time()
[13:38:00.643]             {
[13:38:00.643]                 {
[13:38:00.643]                   {
[13:38:00.643]                     {
[13:38:00.643]                       base::local({
[13:38:00.643]                         has_future <- base::requireNamespace("future", 
[13:38:00.643]                           quietly = TRUE)
[13:38:00.643]                         if (has_future) {
[13:38:00.643]                           ns <- base::getNamespace("future")
[13:38:00.643]                           version <- ns[[".package"]][["version"]]
[13:38:00.643]                           if (is.null(version)) 
[13:38:00.643]                             version <- utils::packageVersion("future")
[13:38:00.643]                         }
[13:38:00.643]                         else {
[13:38:00.643]                           version <- NULL
[13:38:00.643]                         }
[13:38:00.643]                         if (!has_future || version < "1.8.0") {
[13:38:00.643]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:00.643]                             "", base::R.version$version.string), 
[13:38:00.643]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:00.643]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:00.643]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:00.643]                               "release", "version")], collapse = " "), 
[13:38:00.643]                             hostname = base::Sys.info()[["nodename"]])
[13:38:00.643]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:00.643]                             info)
[13:38:00.643]                           info <- base::paste(info, collapse = "; ")
[13:38:00.643]                           if (!has_future) {
[13:38:00.643]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:00.643]                               info)
[13:38:00.643]                           }
[13:38:00.643]                           else {
[13:38:00.643]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:00.643]                               info, version)
[13:38:00.643]                           }
[13:38:00.643]                           base::stop(msg)
[13:38:00.643]                         }
[13:38:00.643]                       })
[13:38:00.643]                     }
[13:38:00.643]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:00.643]                     base::options(mc.cores = 1L)
[13:38:00.643]                   }
[13:38:00.643]                   ...future.strategy.old <- future::plan("list")
[13:38:00.643]                   options(future.plan = NULL)
[13:38:00.643]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:00.643]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:00.643]                 }
[13:38:00.643]                 ...future.workdir <- getwd()
[13:38:00.643]             }
[13:38:00.643]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:00.643]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:00.643]         }
[13:38:00.643]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:00.643]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:00.643]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:00.643]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:00.643]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:00.643]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:00.643]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:00.643]             base::names(...future.oldOptions))
[13:38:00.643]     }
[13:38:00.643]     if (FALSE) {
[13:38:00.643]     }
[13:38:00.643]     else {
[13:38:00.643]         if (TRUE) {
[13:38:00.643]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:00.643]                 open = "w")
[13:38:00.643]         }
[13:38:00.643]         else {
[13:38:00.643]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:00.643]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:00.643]         }
[13:38:00.643]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:00.643]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:00.643]             base::sink(type = "output", split = FALSE)
[13:38:00.643]             base::close(...future.stdout)
[13:38:00.643]         }, add = TRUE)
[13:38:00.643]     }
[13:38:00.643]     ...future.frame <- base::sys.nframe()
[13:38:00.643]     ...future.conditions <- base::list()
[13:38:00.643]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:00.643]     if (FALSE) {
[13:38:00.643]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:00.643]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:00.643]     }
[13:38:00.643]     ...future.result <- base::tryCatch({
[13:38:00.643]         base::withCallingHandlers({
[13:38:00.643]             ...future.value <- base::withVisible(base::local({
[13:38:00.643]                 ...future.makeSendCondition <- base::local({
[13:38:00.643]                   sendCondition <- NULL
[13:38:00.643]                   function(frame = 1L) {
[13:38:00.643]                     if (is.function(sendCondition)) 
[13:38:00.643]                       return(sendCondition)
[13:38:00.643]                     ns <- getNamespace("parallel")
[13:38:00.643]                     if (exists("sendData", mode = "function", 
[13:38:00.643]                       envir = ns)) {
[13:38:00.643]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:00.643]                         envir = ns)
[13:38:00.643]                       envir <- sys.frame(frame)
[13:38:00.643]                       master <- NULL
[13:38:00.643]                       while (!identical(envir, .GlobalEnv) && 
[13:38:00.643]                         !identical(envir, emptyenv())) {
[13:38:00.643]                         if (exists("master", mode = "list", envir = envir, 
[13:38:00.643]                           inherits = FALSE)) {
[13:38:00.643]                           master <- get("master", mode = "list", 
[13:38:00.643]                             envir = envir, inherits = FALSE)
[13:38:00.643]                           if (inherits(master, c("SOCKnode", 
[13:38:00.643]                             "SOCK0node"))) {
[13:38:00.643]                             sendCondition <<- function(cond) {
[13:38:00.643]                               data <- list(type = "VALUE", value = cond, 
[13:38:00.643]                                 success = TRUE)
[13:38:00.643]                               parallel_sendData(master, data)
[13:38:00.643]                             }
[13:38:00.643]                             return(sendCondition)
[13:38:00.643]                           }
[13:38:00.643]                         }
[13:38:00.643]                         frame <- frame + 1L
[13:38:00.643]                         envir <- sys.frame(frame)
[13:38:00.643]                       }
[13:38:00.643]                     }
[13:38:00.643]                     sendCondition <<- function(cond) NULL
[13:38:00.643]                   }
[13:38:00.643]                 })
[13:38:00.643]                 withCallingHandlers({
[13:38:00.643]                   1
[13:38:00.643]                 }, immediateCondition = function(cond) {
[13:38:00.643]                   sendCondition <- ...future.makeSendCondition()
[13:38:00.643]                   sendCondition(cond)
[13:38:00.643]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.643]                   {
[13:38:00.643]                     inherits <- base::inherits
[13:38:00.643]                     invokeRestart <- base::invokeRestart
[13:38:00.643]                     is.null <- base::is.null
[13:38:00.643]                     muffled <- FALSE
[13:38:00.643]                     if (inherits(cond, "message")) {
[13:38:00.643]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:00.643]                       if (muffled) 
[13:38:00.643]                         invokeRestart("muffleMessage")
[13:38:00.643]                     }
[13:38:00.643]                     else if (inherits(cond, "warning")) {
[13:38:00.643]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:00.643]                       if (muffled) 
[13:38:00.643]                         invokeRestart("muffleWarning")
[13:38:00.643]                     }
[13:38:00.643]                     else if (inherits(cond, "condition")) {
[13:38:00.643]                       if (!is.null(pattern)) {
[13:38:00.643]                         computeRestarts <- base::computeRestarts
[13:38:00.643]                         grepl <- base::grepl
[13:38:00.643]                         restarts <- computeRestarts(cond)
[13:38:00.643]                         for (restart in restarts) {
[13:38:00.643]                           name <- restart$name
[13:38:00.643]                           if (is.null(name)) 
[13:38:00.643]                             next
[13:38:00.643]                           if (!grepl(pattern, name)) 
[13:38:00.643]                             next
[13:38:00.643]                           invokeRestart(restart)
[13:38:00.643]                           muffled <- TRUE
[13:38:00.643]                           break
[13:38:00.643]                         }
[13:38:00.643]                       }
[13:38:00.643]                     }
[13:38:00.643]                     invisible(muffled)
[13:38:00.643]                   }
[13:38:00.643]                   muffleCondition(cond)
[13:38:00.643]                 })
[13:38:00.643]             }))
[13:38:00.643]             future::FutureResult(value = ...future.value$value, 
[13:38:00.643]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:00.643]                   ...future.rng), globalenv = if (FALSE) 
[13:38:00.643]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:00.643]                     ...future.globalenv.names))
[13:38:00.643]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:00.643]         }, condition = base::local({
[13:38:00.643]             c <- base::c
[13:38:00.643]             inherits <- base::inherits
[13:38:00.643]             invokeRestart <- base::invokeRestart
[13:38:00.643]             length <- base::length
[13:38:00.643]             list <- base::list
[13:38:00.643]             seq.int <- base::seq.int
[13:38:00.643]             signalCondition <- base::signalCondition
[13:38:00.643]             sys.calls <- base::sys.calls
[13:38:00.643]             `[[` <- base::`[[`
[13:38:00.643]             `+` <- base::`+`
[13:38:00.643]             `<<-` <- base::`<<-`
[13:38:00.643]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:00.643]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:00.643]                   3L)]
[13:38:00.643]             }
[13:38:00.643]             function(cond) {
[13:38:00.643]                 is_error <- inherits(cond, "error")
[13:38:00.643]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:00.643]                   NULL)
[13:38:00.643]                 if (is_error) {
[13:38:00.643]                   sessionInformation <- function() {
[13:38:00.643]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:00.643]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:00.643]                       search = base::search(), system = base::Sys.info())
[13:38:00.643]                   }
[13:38:00.643]                   ...future.conditions[[length(...future.conditions) + 
[13:38:00.643]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:00.643]                     cond$call), session = sessionInformation(), 
[13:38:00.643]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:00.643]                   signalCondition(cond)
[13:38:00.643]                 }
[13:38:00.643]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:00.643]                 "immediateCondition"))) {
[13:38:00.643]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:00.643]                   ...future.conditions[[length(...future.conditions) + 
[13:38:00.643]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:00.643]                   if (TRUE && !signal) {
[13:38:00.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.643]                     {
[13:38:00.643]                       inherits <- base::inherits
[13:38:00.643]                       invokeRestart <- base::invokeRestart
[13:38:00.643]                       is.null <- base::is.null
[13:38:00.643]                       muffled <- FALSE
[13:38:00.643]                       if (inherits(cond, "message")) {
[13:38:00.643]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:00.643]                         if (muffled) 
[13:38:00.643]                           invokeRestart("muffleMessage")
[13:38:00.643]                       }
[13:38:00.643]                       else if (inherits(cond, "warning")) {
[13:38:00.643]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:00.643]                         if (muffled) 
[13:38:00.643]                           invokeRestart("muffleWarning")
[13:38:00.643]                       }
[13:38:00.643]                       else if (inherits(cond, "condition")) {
[13:38:00.643]                         if (!is.null(pattern)) {
[13:38:00.643]                           computeRestarts <- base::computeRestarts
[13:38:00.643]                           grepl <- base::grepl
[13:38:00.643]                           restarts <- computeRestarts(cond)
[13:38:00.643]                           for (restart in restarts) {
[13:38:00.643]                             name <- restart$name
[13:38:00.643]                             if (is.null(name)) 
[13:38:00.643]                               next
[13:38:00.643]                             if (!grepl(pattern, name)) 
[13:38:00.643]                               next
[13:38:00.643]                             invokeRestart(restart)
[13:38:00.643]                             muffled <- TRUE
[13:38:00.643]                             break
[13:38:00.643]                           }
[13:38:00.643]                         }
[13:38:00.643]                       }
[13:38:00.643]                       invisible(muffled)
[13:38:00.643]                     }
[13:38:00.643]                     muffleCondition(cond, pattern = "^muffle")
[13:38:00.643]                   }
[13:38:00.643]                 }
[13:38:00.643]                 else {
[13:38:00.643]                   if (TRUE) {
[13:38:00.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.643]                     {
[13:38:00.643]                       inherits <- base::inherits
[13:38:00.643]                       invokeRestart <- base::invokeRestart
[13:38:00.643]                       is.null <- base::is.null
[13:38:00.643]                       muffled <- FALSE
[13:38:00.643]                       if (inherits(cond, "message")) {
[13:38:00.643]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:00.643]                         if (muffled) 
[13:38:00.643]                           invokeRestart("muffleMessage")
[13:38:00.643]                       }
[13:38:00.643]                       else if (inherits(cond, "warning")) {
[13:38:00.643]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:00.643]                         if (muffled) 
[13:38:00.643]                           invokeRestart("muffleWarning")
[13:38:00.643]                       }
[13:38:00.643]                       else if (inherits(cond, "condition")) {
[13:38:00.643]                         if (!is.null(pattern)) {
[13:38:00.643]                           computeRestarts <- base::computeRestarts
[13:38:00.643]                           grepl <- base::grepl
[13:38:00.643]                           restarts <- computeRestarts(cond)
[13:38:00.643]                           for (restart in restarts) {
[13:38:00.643]                             name <- restart$name
[13:38:00.643]                             if (is.null(name)) 
[13:38:00.643]                               next
[13:38:00.643]                             if (!grepl(pattern, name)) 
[13:38:00.643]                               next
[13:38:00.643]                             invokeRestart(restart)
[13:38:00.643]                             muffled <- TRUE
[13:38:00.643]                             break
[13:38:00.643]                           }
[13:38:00.643]                         }
[13:38:00.643]                       }
[13:38:00.643]                       invisible(muffled)
[13:38:00.643]                     }
[13:38:00.643]                     muffleCondition(cond, pattern = "^muffle")
[13:38:00.643]                   }
[13:38:00.643]                 }
[13:38:00.643]             }
[13:38:00.643]         }))
[13:38:00.643]     }, error = function(ex) {
[13:38:00.643]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:00.643]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:00.643]                 ...future.rng), started = ...future.startTime, 
[13:38:00.643]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:00.643]             version = "1.8"), class = "FutureResult")
[13:38:00.643]     }, finally = {
[13:38:00.643]         if (!identical(...future.workdir, getwd())) 
[13:38:00.643]             setwd(...future.workdir)
[13:38:00.643]         {
[13:38:00.643]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:00.643]                 ...future.oldOptions$nwarnings <- NULL
[13:38:00.643]             }
[13:38:00.643]             base::options(...future.oldOptions)
[13:38:00.643]             if (.Platform$OS.type == "windows") {
[13:38:00.643]                 old_names <- names(...future.oldEnvVars)
[13:38:00.643]                 envs <- base::Sys.getenv()
[13:38:00.643]                 names <- names(envs)
[13:38:00.643]                 common <- intersect(names, old_names)
[13:38:00.643]                 added <- setdiff(names, old_names)
[13:38:00.643]                 removed <- setdiff(old_names, names)
[13:38:00.643]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:00.643]                   envs[common]]
[13:38:00.643]                 NAMES <- toupper(changed)
[13:38:00.643]                 args <- list()
[13:38:00.643]                 for (kk in seq_along(NAMES)) {
[13:38:00.643]                   name <- changed[[kk]]
[13:38:00.643]                   NAME <- NAMES[[kk]]
[13:38:00.643]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.643]                     next
[13:38:00.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:00.643]                 }
[13:38:00.643]                 NAMES <- toupper(added)
[13:38:00.643]                 for (kk in seq_along(NAMES)) {
[13:38:00.643]                   name <- added[[kk]]
[13:38:00.643]                   NAME <- NAMES[[kk]]
[13:38:00.643]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.643]                     next
[13:38:00.643]                   args[[name]] <- ""
[13:38:00.643]                 }
[13:38:00.643]                 NAMES <- toupper(removed)
[13:38:00.643]                 for (kk in seq_along(NAMES)) {
[13:38:00.643]                   name <- removed[[kk]]
[13:38:00.643]                   NAME <- NAMES[[kk]]
[13:38:00.643]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.643]                     next
[13:38:00.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:00.643]                 }
[13:38:00.643]                 if (length(args) > 0) 
[13:38:00.643]                   base::do.call(base::Sys.setenv, args = args)
[13:38:00.643]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:00.643]             }
[13:38:00.643]             else {
[13:38:00.643]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:00.643]             }
[13:38:00.643]             {
[13:38:00.643]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:00.643]                   0L) {
[13:38:00.643]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:00.643]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:00.643]                   base::options(opts)
[13:38:00.643]                 }
[13:38:00.643]                 {
[13:38:00.643]                   {
[13:38:00.643]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:00.643]                     NULL
[13:38:00.643]                   }
[13:38:00.643]                   options(future.plan = NULL)
[13:38:00.643]                   if (is.na(NA_character_)) 
[13:38:00.643]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:00.643]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:00.643]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:00.643]                     .init = FALSE)
[13:38:00.643]                 }
[13:38:00.643]             }
[13:38:00.643]         }
[13:38:00.643]     })
[13:38:00.643]     if (TRUE) {
[13:38:00.643]         base::sink(type = "output", split = FALSE)
[13:38:00.643]         if (TRUE) {
[13:38:00.643]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:00.643]         }
[13:38:00.643]         else {
[13:38:00.643]             ...future.result["stdout"] <- base::list(NULL)
[13:38:00.643]         }
[13:38:00.643]         base::close(...future.stdout)
[13:38:00.643]         ...future.stdout <- NULL
[13:38:00.643]     }
[13:38:00.643]     ...future.result$conditions <- ...future.conditions
[13:38:00.643]     ...future.result$finished <- base::Sys.time()
[13:38:00.643]     ...future.result
[13:38:00.643] }
[13:38:00.646] MultisessionFuture started
[13:38:00.646] - Launch lazy future ... done
[13:38:00.646] run() for ‘MultisessionFuture’ ... done
[13:38:00.657] run() for ‘Future’ ...
[13:38:00.657] - state: ‘created’
[13:38:00.657] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:00.671] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:00.671] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:00.671]   - Field: ‘node’
[13:38:00.671]   - Field: ‘label’
[13:38:00.671]   - Field: ‘local’
[13:38:00.672]   - Field: ‘owner’
[13:38:00.672]   - Field: ‘envir’
[13:38:00.672]   - Field: ‘workers’
[13:38:00.672]   - Field: ‘packages’
[13:38:00.672]   - Field: ‘gc’
[13:38:00.672]   - Field: ‘conditions’
[13:38:00.672]   - Field: ‘persistent’
[13:38:00.672]   - Field: ‘expr’
[13:38:00.672]   - Field: ‘uuid’
[13:38:00.672]   - Field: ‘seed’
[13:38:00.672]   - Field: ‘version’
[13:38:00.673]   - Field: ‘result’
[13:38:00.673]   - Field: ‘asynchronous’
[13:38:00.673]   - Field: ‘calls’
[13:38:00.673]   - Field: ‘globals’
[13:38:00.673]   - Field: ‘stdout’
[13:38:00.673]   - Field: ‘earlySignal’
[13:38:00.673]   - Field: ‘lazy’
[13:38:00.673]   - Field: ‘state’
[13:38:00.673] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:00.673] - Launch lazy future ...
[13:38:00.674] Packages needed by the future expression (n = 0): <none>
[13:38:00.674] Packages needed by future strategies (n = 0): <none>
[13:38:00.674] {
[13:38:00.674]     {
[13:38:00.674]         {
[13:38:00.674]             ...future.startTime <- base::Sys.time()
[13:38:00.674]             {
[13:38:00.674]                 {
[13:38:00.674]                   {
[13:38:00.674]                     {
[13:38:00.674]                       base::local({
[13:38:00.674]                         has_future <- base::requireNamespace("future", 
[13:38:00.674]                           quietly = TRUE)
[13:38:00.674]                         if (has_future) {
[13:38:00.674]                           ns <- base::getNamespace("future")
[13:38:00.674]                           version <- ns[[".package"]][["version"]]
[13:38:00.674]                           if (is.null(version)) 
[13:38:00.674]                             version <- utils::packageVersion("future")
[13:38:00.674]                         }
[13:38:00.674]                         else {
[13:38:00.674]                           version <- NULL
[13:38:00.674]                         }
[13:38:00.674]                         if (!has_future || version < "1.8.0") {
[13:38:00.674]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:00.674]                             "", base::R.version$version.string), 
[13:38:00.674]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:00.674]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:00.674]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:00.674]                               "release", "version")], collapse = " "), 
[13:38:00.674]                             hostname = base::Sys.info()[["nodename"]])
[13:38:00.674]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:00.674]                             info)
[13:38:00.674]                           info <- base::paste(info, collapse = "; ")
[13:38:00.674]                           if (!has_future) {
[13:38:00.674]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:00.674]                               info)
[13:38:00.674]                           }
[13:38:00.674]                           else {
[13:38:00.674]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:00.674]                               info, version)
[13:38:00.674]                           }
[13:38:00.674]                           base::stop(msg)
[13:38:00.674]                         }
[13:38:00.674]                       })
[13:38:00.674]                     }
[13:38:00.674]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:00.674]                     base::options(mc.cores = 1L)
[13:38:00.674]                   }
[13:38:00.674]                   ...future.strategy.old <- future::plan("list")
[13:38:00.674]                   options(future.plan = NULL)
[13:38:00.674]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:00.674]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:00.674]                 }
[13:38:00.674]                 ...future.workdir <- getwd()
[13:38:00.674]             }
[13:38:00.674]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:00.674]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:00.674]         }
[13:38:00.674]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:00.674]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:00.674]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:00.674]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:00.674]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:00.674]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:00.674]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:00.674]             base::names(...future.oldOptions))
[13:38:00.674]     }
[13:38:00.674]     if (FALSE) {
[13:38:00.674]     }
[13:38:00.674]     else {
[13:38:00.674]         if (TRUE) {
[13:38:00.674]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:00.674]                 open = "w")
[13:38:00.674]         }
[13:38:00.674]         else {
[13:38:00.674]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:00.674]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:00.674]         }
[13:38:00.674]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:00.674]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:00.674]             base::sink(type = "output", split = FALSE)
[13:38:00.674]             base::close(...future.stdout)
[13:38:00.674]         }, add = TRUE)
[13:38:00.674]     }
[13:38:00.674]     ...future.frame <- base::sys.nframe()
[13:38:00.674]     ...future.conditions <- base::list()
[13:38:00.674]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:00.674]     if (FALSE) {
[13:38:00.674]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:00.674]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:00.674]     }
[13:38:00.674]     ...future.result <- base::tryCatch({
[13:38:00.674]         base::withCallingHandlers({
[13:38:00.674]             ...future.value <- base::withVisible(base::local({
[13:38:00.674]                 ...future.makeSendCondition <- base::local({
[13:38:00.674]                   sendCondition <- NULL
[13:38:00.674]                   function(frame = 1L) {
[13:38:00.674]                     if (is.function(sendCondition)) 
[13:38:00.674]                       return(sendCondition)
[13:38:00.674]                     ns <- getNamespace("parallel")
[13:38:00.674]                     if (exists("sendData", mode = "function", 
[13:38:00.674]                       envir = ns)) {
[13:38:00.674]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:00.674]                         envir = ns)
[13:38:00.674]                       envir <- sys.frame(frame)
[13:38:00.674]                       master <- NULL
[13:38:00.674]                       while (!identical(envir, .GlobalEnv) && 
[13:38:00.674]                         !identical(envir, emptyenv())) {
[13:38:00.674]                         if (exists("master", mode = "list", envir = envir, 
[13:38:00.674]                           inherits = FALSE)) {
[13:38:00.674]                           master <- get("master", mode = "list", 
[13:38:00.674]                             envir = envir, inherits = FALSE)
[13:38:00.674]                           if (inherits(master, c("SOCKnode", 
[13:38:00.674]                             "SOCK0node"))) {
[13:38:00.674]                             sendCondition <<- function(cond) {
[13:38:00.674]                               data <- list(type = "VALUE", value = cond, 
[13:38:00.674]                                 success = TRUE)
[13:38:00.674]                               parallel_sendData(master, data)
[13:38:00.674]                             }
[13:38:00.674]                             return(sendCondition)
[13:38:00.674]                           }
[13:38:00.674]                         }
[13:38:00.674]                         frame <- frame + 1L
[13:38:00.674]                         envir <- sys.frame(frame)
[13:38:00.674]                       }
[13:38:00.674]                     }
[13:38:00.674]                     sendCondition <<- function(cond) NULL
[13:38:00.674]                   }
[13:38:00.674]                 })
[13:38:00.674]                 withCallingHandlers({
[13:38:00.674]                   2
[13:38:00.674]                 }, immediateCondition = function(cond) {
[13:38:00.674]                   sendCondition <- ...future.makeSendCondition()
[13:38:00.674]                   sendCondition(cond)
[13:38:00.674]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.674]                   {
[13:38:00.674]                     inherits <- base::inherits
[13:38:00.674]                     invokeRestart <- base::invokeRestart
[13:38:00.674]                     is.null <- base::is.null
[13:38:00.674]                     muffled <- FALSE
[13:38:00.674]                     if (inherits(cond, "message")) {
[13:38:00.674]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:00.674]                       if (muffled) 
[13:38:00.674]                         invokeRestart("muffleMessage")
[13:38:00.674]                     }
[13:38:00.674]                     else if (inherits(cond, "warning")) {
[13:38:00.674]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:00.674]                       if (muffled) 
[13:38:00.674]                         invokeRestart("muffleWarning")
[13:38:00.674]                     }
[13:38:00.674]                     else if (inherits(cond, "condition")) {
[13:38:00.674]                       if (!is.null(pattern)) {
[13:38:00.674]                         computeRestarts <- base::computeRestarts
[13:38:00.674]                         grepl <- base::grepl
[13:38:00.674]                         restarts <- computeRestarts(cond)
[13:38:00.674]                         for (restart in restarts) {
[13:38:00.674]                           name <- restart$name
[13:38:00.674]                           if (is.null(name)) 
[13:38:00.674]                             next
[13:38:00.674]                           if (!grepl(pattern, name)) 
[13:38:00.674]                             next
[13:38:00.674]                           invokeRestart(restart)
[13:38:00.674]                           muffled <- TRUE
[13:38:00.674]                           break
[13:38:00.674]                         }
[13:38:00.674]                       }
[13:38:00.674]                     }
[13:38:00.674]                     invisible(muffled)
[13:38:00.674]                   }
[13:38:00.674]                   muffleCondition(cond)
[13:38:00.674]                 })
[13:38:00.674]             }))
[13:38:00.674]             future::FutureResult(value = ...future.value$value, 
[13:38:00.674]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:00.674]                   ...future.rng), globalenv = if (FALSE) 
[13:38:00.674]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:00.674]                     ...future.globalenv.names))
[13:38:00.674]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:00.674]         }, condition = base::local({
[13:38:00.674]             c <- base::c
[13:38:00.674]             inherits <- base::inherits
[13:38:00.674]             invokeRestart <- base::invokeRestart
[13:38:00.674]             length <- base::length
[13:38:00.674]             list <- base::list
[13:38:00.674]             seq.int <- base::seq.int
[13:38:00.674]             signalCondition <- base::signalCondition
[13:38:00.674]             sys.calls <- base::sys.calls
[13:38:00.674]             `[[` <- base::`[[`
[13:38:00.674]             `+` <- base::`+`
[13:38:00.674]             `<<-` <- base::`<<-`
[13:38:00.674]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:00.674]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:00.674]                   3L)]
[13:38:00.674]             }
[13:38:00.674]             function(cond) {
[13:38:00.674]                 is_error <- inherits(cond, "error")
[13:38:00.674]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:00.674]                   NULL)
[13:38:00.674]                 if (is_error) {
[13:38:00.674]                   sessionInformation <- function() {
[13:38:00.674]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:00.674]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:00.674]                       search = base::search(), system = base::Sys.info())
[13:38:00.674]                   }
[13:38:00.674]                   ...future.conditions[[length(...future.conditions) + 
[13:38:00.674]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:00.674]                     cond$call), session = sessionInformation(), 
[13:38:00.674]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:00.674]                   signalCondition(cond)
[13:38:00.674]                 }
[13:38:00.674]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:00.674]                 "immediateCondition"))) {
[13:38:00.674]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:00.674]                   ...future.conditions[[length(...future.conditions) + 
[13:38:00.674]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:00.674]                   if (TRUE && !signal) {
[13:38:00.674]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.674]                     {
[13:38:00.674]                       inherits <- base::inherits
[13:38:00.674]                       invokeRestart <- base::invokeRestart
[13:38:00.674]                       is.null <- base::is.null
[13:38:00.674]                       muffled <- FALSE
[13:38:00.674]                       if (inherits(cond, "message")) {
[13:38:00.674]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:00.674]                         if (muffled) 
[13:38:00.674]                           invokeRestart("muffleMessage")
[13:38:00.674]                       }
[13:38:00.674]                       else if (inherits(cond, "warning")) {
[13:38:00.674]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:00.674]                         if (muffled) 
[13:38:00.674]                           invokeRestart("muffleWarning")
[13:38:00.674]                       }
[13:38:00.674]                       else if (inherits(cond, "condition")) {
[13:38:00.674]                         if (!is.null(pattern)) {
[13:38:00.674]                           computeRestarts <- base::computeRestarts
[13:38:00.674]                           grepl <- base::grepl
[13:38:00.674]                           restarts <- computeRestarts(cond)
[13:38:00.674]                           for (restart in restarts) {
[13:38:00.674]                             name <- restart$name
[13:38:00.674]                             if (is.null(name)) 
[13:38:00.674]                               next
[13:38:00.674]                             if (!grepl(pattern, name)) 
[13:38:00.674]                               next
[13:38:00.674]                             invokeRestart(restart)
[13:38:00.674]                             muffled <- TRUE
[13:38:00.674]                             break
[13:38:00.674]                           }
[13:38:00.674]                         }
[13:38:00.674]                       }
[13:38:00.674]                       invisible(muffled)
[13:38:00.674]                     }
[13:38:00.674]                     muffleCondition(cond, pattern = "^muffle")
[13:38:00.674]                   }
[13:38:00.674]                 }
[13:38:00.674]                 else {
[13:38:00.674]                   if (TRUE) {
[13:38:00.674]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.674]                     {
[13:38:00.674]                       inherits <- base::inherits
[13:38:00.674]                       invokeRestart <- base::invokeRestart
[13:38:00.674]                       is.null <- base::is.null
[13:38:00.674]                       muffled <- FALSE
[13:38:00.674]                       if (inherits(cond, "message")) {
[13:38:00.674]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:00.674]                         if (muffled) 
[13:38:00.674]                           invokeRestart("muffleMessage")
[13:38:00.674]                       }
[13:38:00.674]                       else if (inherits(cond, "warning")) {
[13:38:00.674]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:00.674]                         if (muffled) 
[13:38:00.674]                           invokeRestart("muffleWarning")
[13:38:00.674]                       }
[13:38:00.674]                       else if (inherits(cond, "condition")) {
[13:38:00.674]                         if (!is.null(pattern)) {
[13:38:00.674]                           computeRestarts <- base::computeRestarts
[13:38:00.674]                           grepl <- base::grepl
[13:38:00.674]                           restarts <- computeRestarts(cond)
[13:38:00.674]                           for (restart in restarts) {
[13:38:00.674]                             name <- restart$name
[13:38:00.674]                             if (is.null(name)) 
[13:38:00.674]                               next
[13:38:00.674]                             if (!grepl(pattern, name)) 
[13:38:00.674]                               next
[13:38:00.674]                             invokeRestart(restart)
[13:38:00.674]                             muffled <- TRUE
[13:38:00.674]                             break
[13:38:00.674]                           }
[13:38:00.674]                         }
[13:38:00.674]                       }
[13:38:00.674]                       invisible(muffled)
[13:38:00.674]                     }
[13:38:00.674]                     muffleCondition(cond, pattern = "^muffle")
[13:38:00.674]                   }
[13:38:00.674]                 }
[13:38:00.674]             }
[13:38:00.674]         }))
[13:38:00.674]     }, error = function(ex) {
[13:38:00.674]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:00.674]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:00.674]                 ...future.rng), started = ...future.startTime, 
[13:38:00.674]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:00.674]             version = "1.8"), class = "FutureResult")
[13:38:00.674]     }, finally = {
[13:38:00.674]         if (!identical(...future.workdir, getwd())) 
[13:38:00.674]             setwd(...future.workdir)
[13:38:00.674]         {
[13:38:00.674]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:00.674]                 ...future.oldOptions$nwarnings <- NULL
[13:38:00.674]             }
[13:38:00.674]             base::options(...future.oldOptions)
[13:38:00.674]             if (.Platform$OS.type == "windows") {
[13:38:00.674]                 old_names <- names(...future.oldEnvVars)
[13:38:00.674]                 envs <- base::Sys.getenv()
[13:38:00.674]                 names <- names(envs)
[13:38:00.674]                 common <- intersect(names, old_names)
[13:38:00.674]                 added <- setdiff(names, old_names)
[13:38:00.674]                 removed <- setdiff(old_names, names)
[13:38:00.674]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:00.674]                   envs[common]]
[13:38:00.674]                 NAMES <- toupper(changed)
[13:38:00.674]                 args <- list()
[13:38:00.674]                 for (kk in seq_along(NAMES)) {
[13:38:00.674]                   name <- changed[[kk]]
[13:38:00.674]                   NAME <- NAMES[[kk]]
[13:38:00.674]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.674]                     next
[13:38:00.674]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:00.674]                 }
[13:38:00.674]                 NAMES <- toupper(added)
[13:38:00.674]                 for (kk in seq_along(NAMES)) {
[13:38:00.674]                   name <- added[[kk]]
[13:38:00.674]                   NAME <- NAMES[[kk]]
[13:38:00.674]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.674]                     next
[13:38:00.674]                   args[[name]] <- ""
[13:38:00.674]                 }
[13:38:00.674]                 NAMES <- toupper(removed)
[13:38:00.674]                 for (kk in seq_along(NAMES)) {
[13:38:00.674]                   name <- removed[[kk]]
[13:38:00.674]                   NAME <- NAMES[[kk]]
[13:38:00.674]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.674]                     next
[13:38:00.674]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:00.674]                 }
[13:38:00.674]                 if (length(args) > 0) 
[13:38:00.674]                   base::do.call(base::Sys.setenv, args = args)
[13:38:00.674]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:00.674]             }
[13:38:00.674]             else {
[13:38:00.674]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:00.674]             }
[13:38:00.674]             {
[13:38:00.674]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:00.674]                   0L) {
[13:38:00.674]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:00.674]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:00.674]                   base::options(opts)
[13:38:00.674]                 }
[13:38:00.674]                 {
[13:38:00.674]                   {
[13:38:00.674]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:00.674]                     NULL
[13:38:00.674]                   }
[13:38:00.674]                   options(future.plan = NULL)
[13:38:00.674]                   if (is.na(NA_character_)) 
[13:38:00.674]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:00.674]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:00.674]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:00.674]                     .init = FALSE)
[13:38:00.674]                 }
[13:38:00.674]             }
[13:38:00.674]         }
[13:38:00.674]     })
[13:38:00.674]     if (TRUE) {
[13:38:00.674]         base::sink(type = "output", split = FALSE)
[13:38:00.674]         if (TRUE) {
[13:38:00.674]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:00.674]         }
[13:38:00.674]         else {
[13:38:00.674]             ...future.result["stdout"] <- base::list(NULL)
[13:38:00.674]         }
[13:38:00.674]         base::close(...future.stdout)
[13:38:00.674]         ...future.stdout <- NULL
[13:38:00.674]     }
[13:38:00.674]     ...future.result$conditions <- ...future.conditions
[13:38:00.674]     ...future.result$finished <- base::Sys.time()
[13:38:00.674]     ...future.result
[13:38:00.674] }
[13:38:00.677] MultisessionFuture started
[13:38:00.677] - Launch lazy future ... done
[13:38:00.677] run() for ‘MultisessionFuture’ ... done
[13:38:00.680] receiveMessageFromWorker() for ClusterFuture ...
[13:38:00.681] - Validating connection of MultisessionFuture
[13:38:00.681] - received message: FutureResult
[13:38:00.681] - Received FutureResult
[13:38:00.681] - Erased future from FutureRegistry
[13:38:00.681] result() for ClusterFuture ...
[13:38:00.681] - result already collected: FutureResult
[13:38:00.681] result() for ClusterFuture ... done
[13:38:00.682] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:00.682] Future #2
[13:38:00.682]  length: 2 (resolved future 2)
[13:38:00.682]  length: 1 (resolved future 3)
[13:38:00.692] receiveMessageFromWorker() for ClusterFuture ...
[13:38:00.693] - Validating connection of MultisessionFuture
[13:38:00.693] - received message: FutureResult
[13:38:00.693] - Received FutureResult
[13:38:00.693] - Erased future from FutureRegistry
[13:38:00.693] result() for ClusterFuture ...
[13:38:00.693] - result already collected: FutureResult
[13:38:00.693] result() for ClusterFuture ... done
[13:38:00.693] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:00.693] Future #1
[13:38:00.693]  length: 0 (resolved future 1)
[13:38:00.694] resolve() on list ... DONE
[13:38:00.694] getGlobalsAndPackages() ...
[13:38:00.694] Searching for globals...
[13:38:00.694] 
[13:38:00.694] Searching for globals ... DONE
[13:38:00.694] - globals: [0] <none>
[13:38:00.694] getGlobalsAndPackages() ... DONE
[13:38:00.695] run() for ‘Future’ ...
[13:38:00.695] - state: ‘created’
[13:38:00.695] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:00.708] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:00.708] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:00.709]   - Field: ‘node’
[13:38:00.709]   - Field: ‘label’
[13:38:00.709]   - Field: ‘local’
[13:38:00.709]   - Field: ‘owner’
[13:38:00.709]   - Field: ‘envir’
[13:38:00.709]   - Field: ‘workers’
[13:38:00.709]   - Field: ‘packages’
[13:38:00.709]   - Field: ‘gc’
[13:38:00.709]   - Field: ‘conditions’
[13:38:00.709]   - Field: ‘persistent’
[13:38:00.710]   - Field: ‘expr’
[13:38:00.710]   - Field: ‘uuid’
[13:38:00.710]   - Field: ‘seed’
[13:38:00.710]   - Field: ‘version’
[13:38:00.710]   - Field: ‘result’
[13:38:00.710]   - Field: ‘asynchronous’
[13:38:00.710]   - Field: ‘calls’
[13:38:00.710]   - Field: ‘globals’
[13:38:00.710]   - Field: ‘stdout’
[13:38:00.710]   - Field: ‘earlySignal’
[13:38:00.710]   - Field: ‘lazy’
[13:38:00.711]   - Field: ‘state’
[13:38:00.711] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:00.711] - Launch lazy future ...
[13:38:00.711] Packages needed by the future expression (n = 0): <none>
[13:38:00.714] Packages needed by future strategies (n = 0): <none>
[13:38:00.714] {
[13:38:00.714]     {
[13:38:00.714]         {
[13:38:00.714]             ...future.startTime <- base::Sys.time()
[13:38:00.714]             {
[13:38:00.714]                 {
[13:38:00.714]                   {
[13:38:00.714]                     {
[13:38:00.714]                       base::local({
[13:38:00.714]                         has_future <- base::requireNamespace("future", 
[13:38:00.714]                           quietly = TRUE)
[13:38:00.714]                         if (has_future) {
[13:38:00.714]                           ns <- base::getNamespace("future")
[13:38:00.714]                           version <- ns[[".package"]][["version"]]
[13:38:00.714]                           if (is.null(version)) 
[13:38:00.714]                             version <- utils::packageVersion("future")
[13:38:00.714]                         }
[13:38:00.714]                         else {
[13:38:00.714]                           version <- NULL
[13:38:00.714]                         }
[13:38:00.714]                         if (!has_future || version < "1.8.0") {
[13:38:00.714]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:00.714]                             "", base::R.version$version.string), 
[13:38:00.714]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:00.714]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:00.714]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:00.714]                               "release", "version")], collapse = " "), 
[13:38:00.714]                             hostname = base::Sys.info()[["nodename"]])
[13:38:00.714]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:00.714]                             info)
[13:38:00.714]                           info <- base::paste(info, collapse = "; ")
[13:38:00.714]                           if (!has_future) {
[13:38:00.714]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:00.714]                               info)
[13:38:00.714]                           }
[13:38:00.714]                           else {
[13:38:00.714]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:00.714]                               info, version)
[13:38:00.714]                           }
[13:38:00.714]                           base::stop(msg)
[13:38:00.714]                         }
[13:38:00.714]                       })
[13:38:00.714]                     }
[13:38:00.714]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:00.714]                     base::options(mc.cores = 1L)
[13:38:00.714]                   }
[13:38:00.714]                   ...future.strategy.old <- future::plan("list")
[13:38:00.714]                   options(future.plan = NULL)
[13:38:00.714]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:00.714]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:00.714]                 }
[13:38:00.714]                 ...future.workdir <- getwd()
[13:38:00.714]             }
[13:38:00.714]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:00.714]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:00.714]         }
[13:38:00.714]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:00.714]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:00.714]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:00.714]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:00.714]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:00.714]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:00.714]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:00.714]             base::names(...future.oldOptions))
[13:38:00.714]     }
[13:38:00.714]     if (FALSE) {
[13:38:00.714]     }
[13:38:00.714]     else {
[13:38:00.714]         if (TRUE) {
[13:38:00.714]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:00.714]                 open = "w")
[13:38:00.714]         }
[13:38:00.714]         else {
[13:38:00.714]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:00.714]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:00.714]         }
[13:38:00.714]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:00.714]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:00.714]             base::sink(type = "output", split = FALSE)
[13:38:00.714]             base::close(...future.stdout)
[13:38:00.714]         }, add = TRUE)
[13:38:00.714]     }
[13:38:00.714]     ...future.frame <- base::sys.nframe()
[13:38:00.714]     ...future.conditions <- base::list()
[13:38:00.714]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:00.714]     if (FALSE) {
[13:38:00.714]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:00.714]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:00.714]     }
[13:38:00.714]     ...future.result <- base::tryCatch({
[13:38:00.714]         base::withCallingHandlers({
[13:38:00.714]             ...future.value <- base::withVisible(base::local({
[13:38:00.714]                 ...future.makeSendCondition <- base::local({
[13:38:00.714]                   sendCondition <- NULL
[13:38:00.714]                   function(frame = 1L) {
[13:38:00.714]                     if (is.function(sendCondition)) 
[13:38:00.714]                       return(sendCondition)
[13:38:00.714]                     ns <- getNamespace("parallel")
[13:38:00.714]                     if (exists("sendData", mode = "function", 
[13:38:00.714]                       envir = ns)) {
[13:38:00.714]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:00.714]                         envir = ns)
[13:38:00.714]                       envir <- sys.frame(frame)
[13:38:00.714]                       master <- NULL
[13:38:00.714]                       while (!identical(envir, .GlobalEnv) && 
[13:38:00.714]                         !identical(envir, emptyenv())) {
[13:38:00.714]                         if (exists("master", mode = "list", envir = envir, 
[13:38:00.714]                           inherits = FALSE)) {
[13:38:00.714]                           master <- get("master", mode = "list", 
[13:38:00.714]                             envir = envir, inherits = FALSE)
[13:38:00.714]                           if (inherits(master, c("SOCKnode", 
[13:38:00.714]                             "SOCK0node"))) {
[13:38:00.714]                             sendCondition <<- function(cond) {
[13:38:00.714]                               data <- list(type = "VALUE", value = cond, 
[13:38:00.714]                                 success = TRUE)
[13:38:00.714]                               parallel_sendData(master, data)
[13:38:00.714]                             }
[13:38:00.714]                             return(sendCondition)
[13:38:00.714]                           }
[13:38:00.714]                         }
[13:38:00.714]                         frame <- frame + 1L
[13:38:00.714]                         envir <- sys.frame(frame)
[13:38:00.714]                       }
[13:38:00.714]                     }
[13:38:00.714]                     sendCondition <<- function(cond) NULL
[13:38:00.714]                   }
[13:38:00.714]                 })
[13:38:00.714]                 withCallingHandlers({
[13:38:00.714]                   1
[13:38:00.714]                 }, immediateCondition = function(cond) {
[13:38:00.714]                   sendCondition <- ...future.makeSendCondition()
[13:38:00.714]                   sendCondition(cond)
[13:38:00.714]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.714]                   {
[13:38:00.714]                     inherits <- base::inherits
[13:38:00.714]                     invokeRestart <- base::invokeRestart
[13:38:00.714]                     is.null <- base::is.null
[13:38:00.714]                     muffled <- FALSE
[13:38:00.714]                     if (inherits(cond, "message")) {
[13:38:00.714]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:00.714]                       if (muffled) 
[13:38:00.714]                         invokeRestart("muffleMessage")
[13:38:00.714]                     }
[13:38:00.714]                     else if (inherits(cond, "warning")) {
[13:38:00.714]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:00.714]                       if (muffled) 
[13:38:00.714]                         invokeRestart("muffleWarning")
[13:38:00.714]                     }
[13:38:00.714]                     else if (inherits(cond, "condition")) {
[13:38:00.714]                       if (!is.null(pattern)) {
[13:38:00.714]                         computeRestarts <- base::computeRestarts
[13:38:00.714]                         grepl <- base::grepl
[13:38:00.714]                         restarts <- computeRestarts(cond)
[13:38:00.714]                         for (restart in restarts) {
[13:38:00.714]                           name <- restart$name
[13:38:00.714]                           if (is.null(name)) 
[13:38:00.714]                             next
[13:38:00.714]                           if (!grepl(pattern, name)) 
[13:38:00.714]                             next
[13:38:00.714]                           invokeRestart(restart)
[13:38:00.714]                           muffled <- TRUE
[13:38:00.714]                           break
[13:38:00.714]                         }
[13:38:00.714]                       }
[13:38:00.714]                     }
[13:38:00.714]                     invisible(muffled)
[13:38:00.714]                   }
[13:38:00.714]                   muffleCondition(cond)
[13:38:00.714]                 })
[13:38:00.714]             }))
[13:38:00.714]             future::FutureResult(value = ...future.value$value, 
[13:38:00.714]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:00.714]                   ...future.rng), globalenv = if (FALSE) 
[13:38:00.714]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:00.714]                     ...future.globalenv.names))
[13:38:00.714]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:00.714]         }, condition = base::local({
[13:38:00.714]             c <- base::c
[13:38:00.714]             inherits <- base::inherits
[13:38:00.714]             invokeRestart <- base::invokeRestart
[13:38:00.714]             length <- base::length
[13:38:00.714]             list <- base::list
[13:38:00.714]             seq.int <- base::seq.int
[13:38:00.714]             signalCondition <- base::signalCondition
[13:38:00.714]             sys.calls <- base::sys.calls
[13:38:00.714]             `[[` <- base::`[[`
[13:38:00.714]             `+` <- base::`+`
[13:38:00.714]             `<<-` <- base::`<<-`
[13:38:00.714]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:00.714]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:00.714]                   3L)]
[13:38:00.714]             }
[13:38:00.714]             function(cond) {
[13:38:00.714]                 is_error <- inherits(cond, "error")
[13:38:00.714]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:00.714]                   NULL)
[13:38:00.714]                 if (is_error) {
[13:38:00.714]                   sessionInformation <- function() {
[13:38:00.714]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:00.714]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:00.714]                       search = base::search(), system = base::Sys.info())
[13:38:00.714]                   }
[13:38:00.714]                   ...future.conditions[[length(...future.conditions) + 
[13:38:00.714]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:00.714]                     cond$call), session = sessionInformation(), 
[13:38:00.714]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:00.714]                   signalCondition(cond)
[13:38:00.714]                 }
[13:38:00.714]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:00.714]                 "immediateCondition"))) {
[13:38:00.714]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:00.714]                   ...future.conditions[[length(...future.conditions) + 
[13:38:00.714]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:00.714]                   if (TRUE && !signal) {
[13:38:00.714]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.714]                     {
[13:38:00.714]                       inherits <- base::inherits
[13:38:00.714]                       invokeRestart <- base::invokeRestart
[13:38:00.714]                       is.null <- base::is.null
[13:38:00.714]                       muffled <- FALSE
[13:38:00.714]                       if (inherits(cond, "message")) {
[13:38:00.714]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:00.714]                         if (muffled) 
[13:38:00.714]                           invokeRestart("muffleMessage")
[13:38:00.714]                       }
[13:38:00.714]                       else if (inherits(cond, "warning")) {
[13:38:00.714]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:00.714]                         if (muffled) 
[13:38:00.714]                           invokeRestart("muffleWarning")
[13:38:00.714]                       }
[13:38:00.714]                       else if (inherits(cond, "condition")) {
[13:38:00.714]                         if (!is.null(pattern)) {
[13:38:00.714]                           computeRestarts <- base::computeRestarts
[13:38:00.714]                           grepl <- base::grepl
[13:38:00.714]                           restarts <- computeRestarts(cond)
[13:38:00.714]                           for (restart in restarts) {
[13:38:00.714]                             name <- restart$name
[13:38:00.714]                             if (is.null(name)) 
[13:38:00.714]                               next
[13:38:00.714]                             if (!grepl(pattern, name)) 
[13:38:00.714]                               next
[13:38:00.714]                             invokeRestart(restart)
[13:38:00.714]                             muffled <- TRUE
[13:38:00.714]                             break
[13:38:00.714]                           }
[13:38:00.714]                         }
[13:38:00.714]                       }
[13:38:00.714]                       invisible(muffled)
[13:38:00.714]                     }
[13:38:00.714]                     muffleCondition(cond, pattern = "^muffle")
[13:38:00.714]                   }
[13:38:00.714]                 }
[13:38:00.714]                 else {
[13:38:00.714]                   if (TRUE) {
[13:38:00.714]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.714]                     {
[13:38:00.714]                       inherits <- base::inherits
[13:38:00.714]                       invokeRestart <- base::invokeRestart
[13:38:00.714]                       is.null <- base::is.null
[13:38:00.714]                       muffled <- FALSE
[13:38:00.714]                       if (inherits(cond, "message")) {
[13:38:00.714]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:00.714]                         if (muffled) 
[13:38:00.714]                           invokeRestart("muffleMessage")
[13:38:00.714]                       }
[13:38:00.714]                       else if (inherits(cond, "warning")) {
[13:38:00.714]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:00.714]                         if (muffled) 
[13:38:00.714]                           invokeRestart("muffleWarning")
[13:38:00.714]                       }
[13:38:00.714]                       else if (inherits(cond, "condition")) {
[13:38:00.714]                         if (!is.null(pattern)) {
[13:38:00.714]                           computeRestarts <- base::computeRestarts
[13:38:00.714]                           grepl <- base::grepl
[13:38:00.714]                           restarts <- computeRestarts(cond)
[13:38:00.714]                           for (restart in restarts) {
[13:38:00.714]                             name <- restart$name
[13:38:00.714]                             if (is.null(name)) 
[13:38:00.714]                               next
[13:38:00.714]                             if (!grepl(pattern, name)) 
[13:38:00.714]                               next
[13:38:00.714]                             invokeRestart(restart)
[13:38:00.714]                             muffled <- TRUE
[13:38:00.714]                             break
[13:38:00.714]                           }
[13:38:00.714]                         }
[13:38:00.714]                       }
[13:38:00.714]                       invisible(muffled)
[13:38:00.714]                     }
[13:38:00.714]                     muffleCondition(cond, pattern = "^muffle")
[13:38:00.714]                   }
[13:38:00.714]                 }
[13:38:00.714]             }
[13:38:00.714]         }))
[13:38:00.714]     }, error = function(ex) {
[13:38:00.714]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:00.714]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:00.714]                 ...future.rng), started = ...future.startTime, 
[13:38:00.714]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:00.714]             version = "1.8"), class = "FutureResult")
[13:38:00.714]     }, finally = {
[13:38:00.714]         if (!identical(...future.workdir, getwd())) 
[13:38:00.714]             setwd(...future.workdir)
[13:38:00.714]         {
[13:38:00.714]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:00.714]                 ...future.oldOptions$nwarnings <- NULL
[13:38:00.714]             }
[13:38:00.714]             base::options(...future.oldOptions)
[13:38:00.714]             if (.Platform$OS.type == "windows") {
[13:38:00.714]                 old_names <- names(...future.oldEnvVars)
[13:38:00.714]                 envs <- base::Sys.getenv()
[13:38:00.714]                 names <- names(envs)
[13:38:00.714]                 common <- intersect(names, old_names)
[13:38:00.714]                 added <- setdiff(names, old_names)
[13:38:00.714]                 removed <- setdiff(old_names, names)
[13:38:00.714]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:00.714]                   envs[common]]
[13:38:00.714]                 NAMES <- toupper(changed)
[13:38:00.714]                 args <- list()
[13:38:00.714]                 for (kk in seq_along(NAMES)) {
[13:38:00.714]                   name <- changed[[kk]]
[13:38:00.714]                   NAME <- NAMES[[kk]]
[13:38:00.714]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.714]                     next
[13:38:00.714]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:00.714]                 }
[13:38:00.714]                 NAMES <- toupper(added)
[13:38:00.714]                 for (kk in seq_along(NAMES)) {
[13:38:00.714]                   name <- added[[kk]]
[13:38:00.714]                   NAME <- NAMES[[kk]]
[13:38:00.714]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.714]                     next
[13:38:00.714]                   args[[name]] <- ""
[13:38:00.714]                 }
[13:38:00.714]                 NAMES <- toupper(removed)
[13:38:00.714]                 for (kk in seq_along(NAMES)) {
[13:38:00.714]                   name <- removed[[kk]]
[13:38:00.714]                   NAME <- NAMES[[kk]]
[13:38:00.714]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.714]                     next
[13:38:00.714]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:00.714]                 }
[13:38:00.714]                 if (length(args) > 0) 
[13:38:00.714]                   base::do.call(base::Sys.setenv, args = args)
[13:38:00.714]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:00.714]             }
[13:38:00.714]             else {
[13:38:00.714]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:00.714]             }
[13:38:00.714]             {
[13:38:00.714]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:00.714]                   0L) {
[13:38:00.714]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:00.714]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:00.714]                   base::options(opts)
[13:38:00.714]                 }
[13:38:00.714]                 {
[13:38:00.714]                   {
[13:38:00.714]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:00.714]                     NULL
[13:38:00.714]                   }
[13:38:00.714]                   options(future.plan = NULL)
[13:38:00.714]                   if (is.na(NA_character_)) 
[13:38:00.714]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:00.714]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:00.714]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:00.714]                     .init = FALSE)
[13:38:00.714]                 }
[13:38:00.714]             }
[13:38:00.714]         }
[13:38:00.714]     })
[13:38:00.714]     if (TRUE) {
[13:38:00.714]         base::sink(type = "output", split = FALSE)
[13:38:00.714]         if (TRUE) {
[13:38:00.714]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:00.714]         }
[13:38:00.714]         else {
[13:38:00.714]             ...future.result["stdout"] <- base::list(NULL)
[13:38:00.714]         }
[13:38:00.714]         base::close(...future.stdout)
[13:38:00.714]         ...future.stdout <- NULL
[13:38:00.714]     }
[13:38:00.714]     ...future.result$conditions <- ...future.conditions
[13:38:00.714]     ...future.result$finished <- base::Sys.time()
[13:38:00.714]     ...future.result
[13:38:00.714] }
[13:38:00.717] MultisessionFuture started
[13:38:00.718] - Launch lazy future ... done
[13:38:00.718] run() for ‘MultisessionFuture’ ... done
[13:38:00.718] getGlobalsAndPackages() ...
[13:38:00.718] Searching for globals...
[13:38:00.720] - globals found: [2] ‘{’, ‘Sys.sleep’
[13:38:00.720] Searching for globals ... DONE
[13:38:00.720] Resolving globals: FALSE
[13:38:00.720] 
[13:38:00.720] 
[13:38:00.720] getGlobalsAndPackages() ... DONE
[13:38:00.721] run() for ‘Future’ ...
[13:38:00.721] - state: ‘created’
[13:38:00.721] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:00.734] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:00.734] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:00.735]   - Field: ‘node’
[13:38:00.735]   - Field: ‘label’
[13:38:00.735]   - Field: ‘local’
[13:38:00.735]   - Field: ‘owner’
[13:38:00.735]   - Field: ‘envir’
[13:38:00.735]   - Field: ‘workers’
[13:38:00.735]   - Field: ‘packages’
[13:38:00.735]   - Field: ‘gc’
[13:38:00.735]   - Field: ‘conditions’
[13:38:00.735]   - Field: ‘persistent’
[13:38:00.735]   - Field: ‘expr’
[13:38:00.736]   - Field: ‘uuid’
[13:38:00.736]   - Field: ‘seed’
[13:38:00.736]   - Field: ‘version’
[13:38:00.736]   - Field: ‘result’
[13:38:00.736]   - Field: ‘asynchronous’
[13:38:00.736]   - Field: ‘calls’
[13:38:00.736]   - Field: ‘globals’
[13:38:00.736]   - Field: ‘stdout’
[13:38:00.736]   - Field: ‘earlySignal’
[13:38:00.736]   - Field: ‘lazy’
[13:38:00.736]   - Field: ‘state’
[13:38:00.737] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:00.737] - Launch lazy future ...
[13:38:00.737] Packages needed by the future expression (n = 0): <none>
[13:38:00.737] Packages needed by future strategies (n = 0): <none>
[13:38:00.737] {
[13:38:00.737]     {
[13:38:00.737]         {
[13:38:00.737]             ...future.startTime <- base::Sys.time()
[13:38:00.737]             {
[13:38:00.737]                 {
[13:38:00.737]                   {
[13:38:00.737]                     {
[13:38:00.737]                       base::local({
[13:38:00.737]                         has_future <- base::requireNamespace("future", 
[13:38:00.737]                           quietly = TRUE)
[13:38:00.737]                         if (has_future) {
[13:38:00.737]                           ns <- base::getNamespace("future")
[13:38:00.737]                           version <- ns[[".package"]][["version"]]
[13:38:00.737]                           if (is.null(version)) 
[13:38:00.737]                             version <- utils::packageVersion("future")
[13:38:00.737]                         }
[13:38:00.737]                         else {
[13:38:00.737]                           version <- NULL
[13:38:00.737]                         }
[13:38:00.737]                         if (!has_future || version < "1.8.0") {
[13:38:00.737]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:00.737]                             "", base::R.version$version.string), 
[13:38:00.737]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:00.737]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:00.737]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:00.737]                               "release", "version")], collapse = " "), 
[13:38:00.737]                             hostname = base::Sys.info()[["nodename"]])
[13:38:00.737]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:00.737]                             info)
[13:38:00.737]                           info <- base::paste(info, collapse = "; ")
[13:38:00.737]                           if (!has_future) {
[13:38:00.737]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:00.737]                               info)
[13:38:00.737]                           }
[13:38:00.737]                           else {
[13:38:00.737]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:00.737]                               info, version)
[13:38:00.737]                           }
[13:38:00.737]                           base::stop(msg)
[13:38:00.737]                         }
[13:38:00.737]                       })
[13:38:00.737]                     }
[13:38:00.737]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:00.737]                     base::options(mc.cores = 1L)
[13:38:00.737]                   }
[13:38:00.737]                   ...future.strategy.old <- future::plan("list")
[13:38:00.737]                   options(future.plan = NULL)
[13:38:00.737]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:00.737]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:00.737]                 }
[13:38:00.737]                 ...future.workdir <- getwd()
[13:38:00.737]             }
[13:38:00.737]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:00.737]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:00.737]         }
[13:38:00.737]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:00.737]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:00.737]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:00.737]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:00.737]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:00.737]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:00.737]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:00.737]             base::names(...future.oldOptions))
[13:38:00.737]     }
[13:38:00.737]     if (FALSE) {
[13:38:00.737]     }
[13:38:00.737]     else {
[13:38:00.737]         if (TRUE) {
[13:38:00.737]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:00.737]                 open = "w")
[13:38:00.737]         }
[13:38:00.737]         else {
[13:38:00.737]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:00.737]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:00.737]         }
[13:38:00.737]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:00.737]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:00.737]             base::sink(type = "output", split = FALSE)
[13:38:00.737]             base::close(...future.stdout)
[13:38:00.737]         }, add = TRUE)
[13:38:00.737]     }
[13:38:00.737]     ...future.frame <- base::sys.nframe()
[13:38:00.737]     ...future.conditions <- base::list()
[13:38:00.737]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:00.737]     if (FALSE) {
[13:38:00.737]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:00.737]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:00.737]     }
[13:38:00.737]     ...future.result <- base::tryCatch({
[13:38:00.737]         base::withCallingHandlers({
[13:38:00.737]             ...future.value <- base::withVisible(base::local({
[13:38:00.737]                 ...future.makeSendCondition <- base::local({
[13:38:00.737]                   sendCondition <- NULL
[13:38:00.737]                   function(frame = 1L) {
[13:38:00.737]                     if (is.function(sendCondition)) 
[13:38:00.737]                       return(sendCondition)
[13:38:00.737]                     ns <- getNamespace("parallel")
[13:38:00.737]                     if (exists("sendData", mode = "function", 
[13:38:00.737]                       envir = ns)) {
[13:38:00.737]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:00.737]                         envir = ns)
[13:38:00.737]                       envir <- sys.frame(frame)
[13:38:00.737]                       master <- NULL
[13:38:00.737]                       while (!identical(envir, .GlobalEnv) && 
[13:38:00.737]                         !identical(envir, emptyenv())) {
[13:38:00.737]                         if (exists("master", mode = "list", envir = envir, 
[13:38:00.737]                           inherits = FALSE)) {
[13:38:00.737]                           master <- get("master", mode = "list", 
[13:38:00.737]                             envir = envir, inherits = FALSE)
[13:38:00.737]                           if (inherits(master, c("SOCKnode", 
[13:38:00.737]                             "SOCK0node"))) {
[13:38:00.737]                             sendCondition <<- function(cond) {
[13:38:00.737]                               data <- list(type = "VALUE", value = cond, 
[13:38:00.737]                                 success = TRUE)
[13:38:00.737]                               parallel_sendData(master, data)
[13:38:00.737]                             }
[13:38:00.737]                             return(sendCondition)
[13:38:00.737]                           }
[13:38:00.737]                         }
[13:38:00.737]                         frame <- frame + 1L
[13:38:00.737]                         envir <- sys.frame(frame)
[13:38:00.737]                       }
[13:38:00.737]                     }
[13:38:00.737]                     sendCondition <<- function(cond) NULL
[13:38:00.737]                   }
[13:38:00.737]                 })
[13:38:00.737]                 withCallingHandlers({
[13:38:00.737]                   {
[13:38:00.737]                     Sys.sleep(0.5)
[13:38:00.737]                     2
[13:38:00.737]                   }
[13:38:00.737]                 }, immediateCondition = function(cond) {
[13:38:00.737]                   sendCondition <- ...future.makeSendCondition()
[13:38:00.737]                   sendCondition(cond)
[13:38:00.737]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.737]                   {
[13:38:00.737]                     inherits <- base::inherits
[13:38:00.737]                     invokeRestart <- base::invokeRestart
[13:38:00.737]                     is.null <- base::is.null
[13:38:00.737]                     muffled <- FALSE
[13:38:00.737]                     if (inherits(cond, "message")) {
[13:38:00.737]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:00.737]                       if (muffled) 
[13:38:00.737]                         invokeRestart("muffleMessage")
[13:38:00.737]                     }
[13:38:00.737]                     else if (inherits(cond, "warning")) {
[13:38:00.737]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:00.737]                       if (muffled) 
[13:38:00.737]                         invokeRestart("muffleWarning")
[13:38:00.737]                     }
[13:38:00.737]                     else if (inherits(cond, "condition")) {
[13:38:00.737]                       if (!is.null(pattern)) {
[13:38:00.737]                         computeRestarts <- base::computeRestarts
[13:38:00.737]                         grepl <- base::grepl
[13:38:00.737]                         restarts <- computeRestarts(cond)
[13:38:00.737]                         for (restart in restarts) {
[13:38:00.737]                           name <- restart$name
[13:38:00.737]                           if (is.null(name)) 
[13:38:00.737]                             next
[13:38:00.737]                           if (!grepl(pattern, name)) 
[13:38:00.737]                             next
[13:38:00.737]                           invokeRestart(restart)
[13:38:00.737]                           muffled <- TRUE
[13:38:00.737]                           break
[13:38:00.737]                         }
[13:38:00.737]                       }
[13:38:00.737]                     }
[13:38:00.737]                     invisible(muffled)
[13:38:00.737]                   }
[13:38:00.737]                   muffleCondition(cond)
[13:38:00.737]                 })
[13:38:00.737]             }))
[13:38:00.737]             future::FutureResult(value = ...future.value$value, 
[13:38:00.737]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:00.737]                   ...future.rng), globalenv = if (FALSE) 
[13:38:00.737]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:00.737]                     ...future.globalenv.names))
[13:38:00.737]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:00.737]         }, condition = base::local({
[13:38:00.737]             c <- base::c
[13:38:00.737]             inherits <- base::inherits
[13:38:00.737]             invokeRestart <- base::invokeRestart
[13:38:00.737]             length <- base::length
[13:38:00.737]             list <- base::list
[13:38:00.737]             seq.int <- base::seq.int
[13:38:00.737]             signalCondition <- base::signalCondition
[13:38:00.737]             sys.calls <- base::sys.calls
[13:38:00.737]             `[[` <- base::`[[`
[13:38:00.737]             `+` <- base::`+`
[13:38:00.737]             `<<-` <- base::`<<-`
[13:38:00.737]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:00.737]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:00.737]                   3L)]
[13:38:00.737]             }
[13:38:00.737]             function(cond) {
[13:38:00.737]                 is_error <- inherits(cond, "error")
[13:38:00.737]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:00.737]                   NULL)
[13:38:00.737]                 if (is_error) {
[13:38:00.737]                   sessionInformation <- function() {
[13:38:00.737]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:00.737]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:00.737]                       search = base::search(), system = base::Sys.info())
[13:38:00.737]                   }
[13:38:00.737]                   ...future.conditions[[length(...future.conditions) + 
[13:38:00.737]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:00.737]                     cond$call), session = sessionInformation(), 
[13:38:00.737]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:00.737]                   signalCondition(cond)
[13:38:00.737]                 }
[13:38:00.737]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:00.737]                 "immediateCondition"))) {
[13:38:00.737]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:00.737]                   ...future.conditions[[length(...future.conditions) + 
[13:38:00.737]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:00.737]                   if (TRUE && !signal) {
[13:38:00.737]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.737]                     {
[13:38:00.737]                       inherits <- base::inherits
[13:38:00.737]                       invokeRestart <- base::invokeRestart
[13:38:00.737]                       is.null <- base::is.null
[13:38:00.737]                       muffled <- FALSE
[13:38:00.737]                       if (inherits(cond, "message")) {
[13:38:00.737]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:00.737]                         if (muffled) 
[13:38:00.737]                           invokeRestart("muffleMessage")
[13:38:00.737]                       }
[13:38:00.737]                       else if (inherits(cond, "warning")) {
[13:38:00.737]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:00.737]                         if (muffled) 
[13:38:00.737]                           invokeRestart("muffleWarning")
[13:38:00.737]                       }
[13:38:00.737]                       else if (inherits(cond, "condition")) {
[13:38:00.737]                         if (!is.null(pattern)) {
[13:38:00.737]                           computeRestarts <- base::computeRestarts
[13:38:00.737]                           grepl <- base::grepl
[13:38:00.737]                           restarts <- computeRestarts(cond)
[13:38:00.737]                           for (restart in restarts) {
[13:38:00.737]                             name <- restart$name
[13:38:00.737]                             if (is.null(name)) 
[13:38:00.737]                               next
[13:38:00.737]                             if (!grepl(pattern, name)) 
[13:38:00.737]                               next
[13:38:00.737]                             invokeRestart(restart)
[13:38:00.737]                             muffled <- TRUE
[13:38:00.737]                             break
[13:38:00.737]                           }
[13:38:00.737]                         }
[13:38:00.737]                       }
[13:38:00.737]                       invisible(muffled)
[13:38:00.737]                     }
[13:38:00.737]                     muffleCondition(cond, pattern = "^muffle")
[13:38:00.737]                   }
[13:38:00.737]                 }
[13:38:00.737]                 else {
[13:38:00.737]                   if (TRUE) {
[13:38:00.737]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:00.737]                     {
[13:38:00.737]                       inherits <- base::inherits
[13:38:00.737]                       invokeRestart <- base::invokeRestart
[13:38:00.737]                       is.null <- base::is.null
[13:38:00.737]                       muffled <- FALSE
[13:38:00.737]                       if (inherits(cond, "message")) {
[13:38:00.737]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:00.737]                         if (muffled) 
[13:38:00.737]                           invokeRestart("muffleMessage")
[13:38:00.737]                       }
[13:38:00.737]                       else if (inherits(cond, "warning")) {
[13:38:00.737]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:00.737]                         if (muffled) 
[13:38:00.737]                           invokeRestart("muffleWarning")
[13:38:00.737]                       }
[13:38:00.737]                       else if (inherits(cond, "condition")) {
[13:38:00.737]                         if (!is.null(pattern)) {
[13:38:00.737]                           computeRestarts <- base::computeRestarts
[13:38:00.737]                           grepl <- base::grepl
[13:38:00.737]                           restarts <- computeRestarts(cond)
[13:38:00.737]                           for (restart in restarts) {
[13:38:00.737]                             name <- restart$name
[13:38:00.737]                             if (is.null(name)) 
[13:38:00.737]                               next
[13:38:00.737]                             if (!grepl(pattern, name)) 
[13:38:00.737]                               next
[13:38:00.737]                             invokeRestart(restart)
[13:38:00.737]                             muffled <- TRUE
[13:38:00.737]                             break
[13:38:00.737]                           }
[13:38:00.737]                         }
[13:38:00.737]                       }
[13:38:00.737]                       invisible(muffled)
[13:38:00.737]                     }
[13:38:00.737]                     muffleCondition(cond, pattern = "^muffle")
[13:38:00.737]                   }
[13:38:00.737]                 }
[13:38:00.737]             }
[13:38:00.737]         }))
[13:38:00.737]     }, error = function(ex) {
[13:38:00.737]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:00.737]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:00.737]                 ...future.rng), started = ...future.startTime, 
[13:38:00.737]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:00.737]             version = "1.8"), class = "FutureResult")
[13:38:00.737]     }, finally = {
[13:38:00.737]         if (!identical(...future.workdir, getwd())) 
[13:38:00.737]             setwd(...future.workdir)
[13:38:00.737]         {
[13:38:00.737]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:00.737]                 ...future.oldOptions$nwarnings <- NULL
[13:38:00.737]             }
[13:38:00.737]             base::options(...future.oldOptions)
[13:38:00.737]             if (.Platform$OS.type == "windows") {
[13:38:00.737]                 old_names <- names(...future.oldEnvVars)
[13:38:00.737]                 envs <- base::Sys.getenv()
[13:38:00.737]                 names <- names(envs)
[13:38:00.737]                 common <- intersect(names, old_names)
[13:38:00.737]                 added <- setdiff(names, old_names)
[13:38:00.737]                 removed <- setdiff(old_names, names)
[13:38:00.737]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:00.737]                   envs[common]]
[13:38:00.737]                 NAMES <- toupper(changed)
[13:38:00.737]                 args <- list()
[13:38:00.737]                 for (kk in seq_along(NAMES)) {
[13:38:00.737]                   name <- changed[[kk]]
[13:38:00.737]                   NAME <- NAMES[[kk]]
[13:38:00.737]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.737]                     next
[13:38:00.737]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:00.737]                 }
[13:38:00.737]                 NAMES <- toupper(added)
[13:38:00.737]                 for (kk in seq_along(NAMES)) {
[13:38:00.737]                   name <- added[[kk]]
[13:38:00.737]                   NAME <- NAMES[[kk]]
[13:38:00.737]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.737]                     next
[13:38:00.737]                   args[[name]] <- ""
[13:38:00.737]                 }
[13:38:00.737]                 NAMES <- toupper(removed)
[13:38:00.737]                 for (kk in seq_along(NAMES)) {
[13:38:00.737]                   name <- removed[[kk]]
[13:38:00.737]                   NAME <- NAMES[[kk]]
[13:38:00.737]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:00.737]                     next
[13:38:00.737]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:00.737]                 }
[13:38:00.737]                 if (length(args) > 0) 
[13:38:00.737]                   base::do.call(base::Sys.setenv, args = args)
[13:38:00.737]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:00.737]             }
[13:38:00.737]             else {
[13:38:00.737]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:00.737]             }
[13:38:00.737]             {
[13:38:00.737]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:00.737]                   0L) {
[13:38:00.737]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:00.737]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:00.737]                   base::options(opts)
[13:38:00.737]                 }
[13:38:00.737]                 {
[13:38:00.737]                   {
[13:38:00.737]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:00.737]                     NULL
[13:38:00.737]                   }
[13:38:00.737]                   options(future.plan = NULL)
[13:38:00.737]                   if (is.na(NA_character_)) 
[13:38:00.737]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:00.737]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:00.737]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:00.737]                     .init = FALSE)
[13:38:00.737]                 }
[13:38:00.737]             }
[13:38:00.737]         }
[13:38:00.737]     })
[13:38:00.737]     if (TRUE) {
[13:38:00.737]         base::sink(type = "output", split = FALSE)
[13:38:00.737]         if (TRUE) {
[13:38:00.737]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:00.737]         }
[13:38:00.737]         else {
[13:38:00.737]             ...future.result["stdout"] <- base::list(NULL)
[13:38:00.737]         }
[13:38:00.737]         base::close(...future.stdout)
[13:38:00.737]         ...future.stdout <- NULL
[13:38:00.737]     }
[13:38:00.737]     ...future.result$conditions <- ...future.conditions
[13:38:00.737]     ...future.result$finished <- base::Sys.time()
[13:38:00.737]     ...future.result
[13:38:00.737] }
[13:38:00.740] MultisessionFuture started
[13:38:00.740] - Launch lazy future ... done
[13:38:00.740] run() for ‘MultisessionFuture’ ... done
[13:38:00.741] resolve() on list ...
[13:38:00.741]  recursive: 0
[13:38:00.741]  length: 1
[13:38:00.741] 
[13:38:00.741] receiveMessageFromWorker() for ClusterFuture ...
[13:38:00.742] - Validating connection of MultisessionFuture
[13:38:00.742] - received message: FutureResult
[13:38:00.742] - Received FutureResult
[13:38:00.742] - Erased future from FutureRegistry
[13:38:00.742] result() for ClusterFuture ...
[13:38:00.742] - result already collected: FutureResult
[13:38:00.742] result() for ClusterFuture ... done
[13:38:00.742] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:00.742] Future #1
[13:38:00.743]  length: 0 (resolved future 1)
[13:38:00.743] resolve() on list ... DONE
[13:38:00.743] resolve() on list ...
[13:38:00.743]  recursive: 0
[13:38:00.743]  length: 1
[13:38:00.743] 
[13:38:01.243] receiveMessageFromWorker() for ClusterFuture ...
[13:38:01.243] - Validating connection of MultisessionFuture
[13:38:01.243] - received message: FutureResult
[13:38:01.244] - Received FutureResult
[13:38:01.244] - Erased future from FutureRegistry
[13:38:01.244] result() for ClusterFuture ...
[13:38:01.244] - result already collected: FutureResult
[13:38:01.244] result() for ClusterFuture ... done
[13:38:01.244] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:01.244] Future #1
[13:38:01.244]  length: 0 (resolved future 1)
[13:38:01.244] resolve() on list ... DONE
[13:38:01.245] resolve() on list ...
[13:38:01.245]  recursive: 0
[13:38:01.245]  length: 1
[13:38:01.245] 
[13:38:01.245]  length: 0 (resolved future 1)
[13:38:01.245] resolve() on list ... DONE
[13:38:01.245] resolve() on list ...
[13:38:01.245]  recursive: 0
[13:38:01.245]  length: 4
[13:38:01.246] 
[13:38:01.246] Future #1
[13:38:01.246]  length: 3 (resolved future 1)
[13:38:01.246] Future #2
[13:38:01.246]  length: 2 (resolved future 2)
[13:38:01.246]  length: 1 (resolved future 3)
[13:38:01.246]  length: 0 (resolved future 4)
[13:38:01.246] resolve() on list ... DONE
[13:38:01.246] resolve() on list ...
[13:38:01.247]  recursive: 0
[13:38:01.247]  length: 4
[13:38:01.247] 
[13:38:01.247] Future #1
[13:38:01.247]  length: 3 (resolved future 1)
[13:38:01.247] Future #2
[13:38:01.247]  length: 2 (resolved future 2)
[13:38:01.247]  length: 1 (resolved future 3)
[13:38:01.247]  length: 0 (resolved future 4)
[13:38:01.247] resolve() on list ... DONE
[13:38:01.248] resolve() on list ...
[13:38:01.248]  recursive: 0
[13:38:01.248]  length: 1
[13:38:01.248] 
[13:38:01.248]  length: 0 (resolved future 1)
[13:38:01.248] resolve() on list ... DONE
[13:38:01.248] getGlobalsAndPackages() ...
[13:38:01.248] Searching for globals...
[13:38:01.249] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:38:01.249] Searching for globals ... DONE
[13:38:01.250] Resolving globals: FALSE
[13:38:01.250] The total size of the 1 globals is 56 bytes (56 bytes)
[13:38:01.250] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:38:01.250] - globals: [1] ‘kk’
[13:38:01.251] 
[13:38:01.251] getGlobalsAndPackages() ... DONE
[13:38:01.251] run() for ‘Future’ ...
[13:38:01.251] - state: ‘created’
[13:38:01.251] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:01.265] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:01.265] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:01.265]   - Field: ‘node’
[13:38:01.265]   - Field: ‘label’
[13:38:01.266]   - Field: ‘local’
[13:38:01.266]   - Field: ‘owner’
[13:38:01.266]   - Field: ‘envir’
[13:38:01.266]   - Field: ‘workers’
[13:38:01.266]   - Field: ‘packages’
[13:38:01.266]   - Field: ‘gc’
[13:38:01.266]   - Field: ‘conditions’
[13:38:01.266]   - Field: ‘persistent’
[13:38:01.266]   - Field: ‘expr’
[13:38:01.266]   - Field: ‘uuid’
[13:38:01.267]   - Field: ‘seed’
[13:38:01.267]   - Field: ‘version’
[13:38:01.267]   - Field: ‘result’
[13:38:01.267]   - Field: ‘asynchronous’
[13:38:01.267]   - Field: ‘calls’
[13:38:01.267]   - Field: ‘globals’
[13:38:01.267]   - Field: ‘stdout’
[13:38:01.267]   - Field: ‘earlySignal’
[13:38:01.267]   - Field: ‘lazy’
[13:38:01.267]   - Field: ‘state’
[13:38:01.267] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:01.268] - Launch lazy future ...
[13:38:01.268] Packages needed by the future expression (n = 0): <none>
[13:38:01.268] Packages needed by future strategies (n = 0): <none>
[13:38:01.268] {
[13:38:01.268]     {
[13:38:01.268]         {
[13:38:01.268]             ...future.startTime <- base::Sys.time()
[13:38:01.268]             {
[13:38:01.268]                 {
[13:38:01.268]                   {
[13:38:01.268]                     {
[13:38:01.268]                       base::local({
[13:38:01.268]                         has_future <- base::requireNamespace("future", 
[13:38:01.268]                           quietly = TRUE)
[13:38:01.268]                         if (has_future) {
[13:38:01.268]                           ns <- base::getNamespace("future")
[13:38:01.268]                           version <- ns[[".package"]][["version"]]
[13:38:01.268]                           if (is.null(version)) 
[13:38:01.268]                             version <- utils::packageVersion("future")
[13:38:01.268]                         }
[13:38:01.268]                         else {
[13:38:01.268]                           version <- NULL
[13:38:01.268]                         }
[13:38:01.268]                         if (!has_future || version < "1.8.0") {
[13:38:01.268]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:01.268]                             "", base::R.version$version.string), 
[13:38:01.268]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:01.268]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:01.268]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:01.268]                               "release", "version")], collapse = " "), 
[13:38:01.268]                             hostname = base::Sys.info()[["nodename"]])
[13:38:01.268]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:01.268]                             info)
[13:38:01.268]                           info <- base::paste(info, collapse = "; ")
[13:38:01.268]                           if (!has_future) {
[13:38:01.268]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:01.268]                               info)
[13:38:01.268]                           }
[13:38:01.268]                           else {
[13:38:01.268]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:01.268]                               info, version)
[13:38:01.268]                           }
[13:38:01.268]                           base::stop(msg)
[13:38:01.268]                         }
[13:38:01.268]                       })
[13:38:01.268]                     }
[13:38:01.268]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:01.268]                     base::options(mc.cores = 1L)
[13:38:01.268]                   }
[13:38:01.268]                   ...future.strategy.old <- future::plan("list")
[13:38:01.268]                   options(future.plan = NULL)
[13:38:01.268]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.268]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:01.268]                 }
[13:38:01.268]                 ...future.workdir <- getwd()
[13:38:01.268]             }
[13:38:01.268]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:01.268]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:01.268]         }
[13:38:01.268]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:01.268]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:01.268]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:01.268]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:01.268]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:01.268]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:01.268]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:01.268]             base::names(...future.oldOptions))
[13:38:01.268]     }
[13:38:01.268]     if (FALSE) {
[13:38:01.268]     }
[13:38:01.268]     else {
[13:38:01.268]         if (TRUE) {
[13:38:01.268]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:01.268]                 open = "w")
[13:38:01.268]         }
[13:38:01.268]         else {
[13:38:01.268]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:01.268]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:01.268]         }
[13:38:01.268]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:01.268]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:01.268]             base::sink(type = "output", split = FALSE)
[13:38:01.268]             base::close(...future.stdout)
[13:38:01.268]         }, add = TRUE)
[13:38:01.268]     }
[13:38:01.268]     ...future.frame <- base::sys.nframe()
[13:38:01.268]     ...future.conditions <- base::list()
[13:38:01.268]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:01.268]     if (FALSE) {
[13:38:01.268]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:01.268]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:01.268]     }
[13:38:01.268]     ...future.result <- base::tryCatch({
[13:38:01.268]         base::withCallingHandlers({
[13:38:01.268]             ...future.value <- base::withVisible(base::local({
[13:38:01.268]                 ...future.makeSendCondition <- base::local({
[13:38:01.268]                   sendCondition <- NULL
[13:38:01.268]                   function(frame = 1L) {
[13:38:01.268]                     if (is.function(sendCondition)) 
[13:38:01.268]                       return(sendCondition)
[13:38:01.268]                     ns <- getNamespace("parallel")
[13:38:01.268]                     if (exists("sendData", mode = "function", 
[13:38:01.268]                       envir = ns)) {
[13:38:01.268]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:01.268]                         envir = ns)
[13:38:01.268]                       envir <- sys.frame(frame)
[13:38:01.268]                       master <- NULL
[13:38:01.268]                       while (!identical(envir, .GlobalEnv) && 
[13:38:01.268]                         !identical(envir, emptyenv())) {
[13:38:01.268]                         if (exists("master", mode = "list", envir = envir, 
[13:38:01.268]                           inherits = FALSE)) {
[13:38:01.268]                           master <- get("master", mode = "list", 
[13:38:01.268]                             envir = envir, inherits = FALSE)
[13:38:01.268]                           if (inherits(master, c("SOCKnode", 
[13:38:01.268]                             "SOCK0node"))) {
[13:38:01.268]                             sendCondition <<- function(cond) {
[13:38:01.268]                               data <- list(type = "VALUE", value = cond, 
[13:38:01.268]                                 success = TRUE)
[13:38:01.268]                               parallel_sendData(master, data)
[13:38:01.268]                             }
[13:38:01.268]                             return(sendCondition)
[13:38:01.268]                           }
[13:38:01.268]                         }
[13:38:01.268]                         frame <- frame + 1L
[13:38:01.268]                         envir <- sys.frame(frame)
[13:38:01.268]                       }
[13:38:01.268]                     }
[13:38:01.268]                     sendCondition <<- function(cond) NULL
[13:38:01.268]                   }
[13:38:01.268]                 })
[13:38:01.268]                 withCallingHandlers({
[13:38:01.268]                   {
[13:38:01.268]                     Sys.sleep(0.1)
[13:38:01.268]                     kk
[13:38:01.268]                   }
[13:38:01.268]                 }, immediateCondition = function(cond) {
[13:38:01.268]                   sendCondition <- ...future.makeSendCondition()
[13:38:01.268]                   sendCondition(cond)
[13:38:01.268]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.268]                   {
[13:38:01.268]                     inherits <- base::inherits
[13:38:01.268]                     invokeRestart <- base::invokeRestart
[13:38:01.268]                     is.null <- base::is.null
[13:38:01.268]                     muffled <- FALSE
[13:38:01.268]                     if (inherits(cond, "message")) {
[13:38:01.268]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:01.268]                       if (muffled) 
[13:38:01.268]                         invokeRestart("muffleMessage")
[13:38:01.268]                     }
[13:38:01.268]                     else if (inherits(cond, "warning")) {
[13:38:01.268]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:01.268]                       if (muffled) 
[13:38:01.268]                         invokeRestart("muffleWarning")
[13:38:01.268]                     }
[13:38:01.268]                     else if (inherits(cond, "condition")) {
[13:38:01.268]                       if (!is.null(pattern)) {
[13:38:01.268]                         computeRestarts <- base::computeRestarts
[13:38:01.268]                         grepl <- base::grepl
[13:38:01.268]                         restarts <- computeRestarts(cond)
[13:38:01.268]                         for (restart in restarts) {
[13:38:01.268]                           name <- restart$name
[13:38:01.268]                           if (is.null(name)) 
[13:38:01.268]                             next
[13:38:01.268]                           if (!grepl(pattern, name)) 
[13:38:01.268]                             next
[13:38:01.268]                           invokeRestart(restart)
[13:38:01.268]                           muffled <- TRUE
[13:38:01.268]                           break
[13:38:01.268]                         }
[13:38:01.268]                       }
[13:38:01.268]                     }
[13:38:01.268]                     invisible(muffled)
[13:38:01.268]                   }
[13:38:01.268]                   muffleCondition(cond)
[13:38:01.268]                 })
[13:38:01.268]             }))
[13:38:01.268]             future::FutureResult(value = ...future.value$value, 
[13:38:01.268]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.268]                   ...future.rng), globalenv = if (FALSE) 
[13:38:01.268]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:01.268]                     ...future.globalenv.names))
[13:38:01.268]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:01.268]         }, condition = base::local({
[13:38:01.268]             c <- base::c
[13:38:01.268]             inherits <- base::inherits
[13:38:01.268]             invokeRestart <- base::invokeRestart
[13:38:01.268]             length <- base::length
[13:38:01.268]             list <- base::list
[13:38:01.268]             seq.int <- base::seq.int
[13:38:01.268]             signalCondition <- base::signalCondition
[13:38:01.268]             sys.calls <- base::sys.calls
[13:38:01.268]             `[[` <- base::`[[`
[13:38:01.268]             `+` <- base::`+`
[13:38:01.268]             `<<-` <- base::`<<-`
[13:38:01.268]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:01.268]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:01.268]                   3L)]
[13:38:01.268]             }
[13:38:01.268]             function(cond) {
[13:38:01.268]                 is_error <- inherits(cond, "error")
[13:38:01.268]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:01.268]                   NULL)
[13:38:01.268]                 if (is_error) {
[13:38:01.268]                   sessionInformation <- function() {
[13:38:01.268]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:01.268]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:01.268]                       search = base::search(), system = base::Sys.info())
[13:38:01.268]                   }
[13:38:01.268]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.268]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:01.268]                     cond$call), session = sessionInformation(), 
[13:38:01.268]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:01.268]                   signalCondition(cond)
[13:38:01.268]                 }
[13:38:01.268]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:01.268]                 "immediateCondition"))) {
[13:38:01.268]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:01.268]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.268]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:01.268]                   if (TRUE && !signal) {
[13:38:01.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.268]                     {
[13:38:01.268]                       inherits <- base::inherits
[13:38:01.268]                       invokeRestart <- base::invokeRestart
[13:38:01.268]                       is.null <- base::is.null
[13:38:01.268]                       muffled <- FALSE
[13:38:01.268]                       if (inherits(cond, "message")) {
[13:38:01.268]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.268]                         if (muffled) 
[13:38:01.268]                           invokeRestart("muffleMessage")
[13:38:01.268]                       }
[13:38:01.268]                       else if (inherits(cond, "warning")) {
[13:38:01.268]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.268]                         if (muffled) 
[13:38:01.268]                           invokeRestart("muffleWarning")
[13:38:01.268]                       }
[13:38:01.268]                       else if (inherits(cond, "condition")) {
[13:38:01.268]                         if (!is.null(pattern)) {
[13:38:01.268]                           computeRestarts <- base::computeRestarts
[13:38:01.268]                           grepl <- base::grepl
[13:38:01.268]                           restarts <- computeRestarts(cond)
[13:38:01.268]                           for (restart in restarts) {
[13:38:01.268]                             name <- restart$name
[13:38:01.268]                             if (is.null(name)) 
[13:38:01.268]                               next
[13:38:01.268]                             if (!grepl(pattern, name)) 
[13:38:01.268]                               next
[13:38:01.268]                             invokeRestart(restart)
[13:38:01.268]                             muffled <- TRUE
[13:38:01.268]                             break
[13:38:01.268]                           }
[13:38:01.268]                         }
[13:38:01.268]                       }
[13:38:01.268]                       invisible(muffled)
[13:38:01.268]                     }
[13:38:01.268]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.268]                   }
[13:38:01.268]                 }
[13:38:01.268]                 else {
[13:38:01.268]                   if (TRUE) {
[13:38:01.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.268]                     {
[13:38:01.268]                       inherits <- base::inherits
[13:38:01.268]                       invokeRestart <- base::invokeRestart
[13:38:01.268]                       is.null <- base::is.null
[13:38:01.268]                       muffled <- FALSE
[13:38:01.268]                       if (inherits(cond, "message")) {
[13:38:01.268]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.268]                         if (muffled) 
[13:38:01.268]                           invokeRestart("muffleMessage")
[13:38:01.268]                       }
[13:38:01.268]                       else if (inherits(cond, "warning")) {
[13:38:01.268]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.268]                         if (muffled) 
[13:38:01.268]                           invokeRestart("muffleWarning")
[13:38:01.268]                       }
[13:38:01.268]                       else if (inherits(cond, "condition")) {
[13:38:01.268]                         if (!is.null(pattern)) {
[13:38:01.268]                           computeRestarts <- base::computeRestarts
[13:38:01.268]                           grepl <- base::grepl
[13:38:01.268]                           restarts <- computeRestarts(cond)
[13:38:01.268]                           for (restart in restarts) {
[13:38:01.268]                             name <- restart$name
[13:38:01.268]                             if (is.null(name)) 
[13:38:01.268]                               next
[13:38:01.268]                             if (!grepl(pattern, name)) 
[13:38:01.268]                               next
[13:38:01.268]                             invokeRestart(restart)
[13:38:01.268]                             muffled <- TRUE
[13:38:01.268]                             break
[13:38:01.268]                           }
[13:38:01.268]                         }
[13:38:01.268]                       }
[13:38:01.268]                       invisible(muffled)
[13:38:01.268]                     }
[13:38:01.268]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.268]                   }
[13:38:01.268]                 }
[13:38:01.268]             }
[13:38:01.268]         }))
[13:38:01.268]     }, error = function(ex) {
[13:38:01.268]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:01.268]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.268]                 ...future.rng), started = ...future.startTime, 
[13:38:01.268]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:01.268]             version = "1.8"), class = "FutureResult")
[13:38:01.268]     }, finally = {
[13:38:01.268]         if (!identical(...future.workdir, getwd())) 
[13:38:01.268]             setwd(...future.workdir)
[13:38:01.268]         {
[13:38:01.268]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:01.268]                 ...future.oldOptions$nwarnings <- NULL
[13:38:01.268]             }
[13:38:01.268]             base::options(...future.oldOptions)
[13:38:01.268]             if (.Platform$OS.type == "windows") {
[13:38:01.268]                 old_names <- names(...future.oldEnvVars)
[13:38:01.268]                 envs <- base::Sys.getenv()
[13:38:01.268]                 names <- names(envs)
[13:38:01.268]                 common <- intersect(names, old_names)
[13:38:01.268]                 added <- setdiff(names, old_names)
[13:38:01.268]                 removed <- setdiff(old_names, names)
[13:38:01.268]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:01.268]                   envs[common]]
[13:38:01.268]                 NAMES <- toupper(changed)
[13:38:01.268]                 args <- list()
[13:38:01.268]                 for (kk in seq_along(NAMES)) {
[13:38:01.268]                   name <- changed[[kk]]
[13:38:01.268]                   NAME <- NAMES[[kk]]
[13:38:01.268]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.268]                     next
[13:38:01.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.268]                 }
[13:38:01.268]                 NAMES <- toupper(added)
[13:38:01.268]                 for (kk in seq_along(NAMES)) {
[13:38:01.268]                   name <- added[[kk]]
[13:38:01.268]                   NAME <- NAMES[[kk]]
[13:38:01.268]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.268]                     next
[13:38:01.268]                   args[[name]] <- ""
[13:38:01.268]                 }
[13:38:01.268]                 NAMES <- toupper(removed)
[13:38:01.268]                 for (kk in seq_along(NAMES)) {
[13:38:01.268]                   name <- removed[[kk]]
[13:38:01.268]                   NAME <- NAMES[[kk]]
[13:38:01.268]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.268]                     next
[13:38:01.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.268]                 }
[13:38:01.268]                 if (length(args) > 0) 
[13:38:01.268]                   base::do.call(base::Sys.setenv, args = args)
[13:38:01.268]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:01.268]             }
[13:38:01.268]             else {
[13:38:01.268]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:01.268]             }
[13:38:01.268]             {
[13:38:01.268]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:01.268]                   0L) {
[13:38:01.268]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:01.268]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:01.268]                   base::options(opts)
[13:38:01.268]                 }
[13:38:01.268]                 {
[13:38:01.268]                   {
[13:38:01.268]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:01.268]                     NULL
[13:38:01.268]                   }
[13:38:01.268]                   options(future.plan = NULL)
[13:38:01.268]                   if (is.na(NA_character_)) 
[13:38:01.268]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.268]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:01.268]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:01.268]                     .init = FALSE)
[13:38:01.268]                 }
[13:38:01.268]             }
[13:38:01.268]         }
[13:38:01.268]     })
[13:38:01.268]     if (TRUE) {
[13:38:01.268]         base::sink(type = "output", split = FALSE)
[13:38:01.268]         if (TRUE) {
[13:38:01.268]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:01.268]         }
[13:38:01.268]         else {
[13:38:01.268]             ...future.result["stdout"] <- base::list(NULL)
[13:38:01.268]         }
[13:38:01.268]         base::close(...future.stdout)
[13:38:01.268]         ...future.stdout <- NULL
[13:38:01.268]     }
[13:38:01.268]     ...future.result$conditions <- ...future.conditions
[13:38:01.268]     ...future.result$finished <- base::Sys.time()
[13:38:01.268]     ...future.result
[13:38:01.268] }
[13:38:01.271] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:38:01.271] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[13:38:01.272] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[13:38:01.272] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:38:01.272] MultisessionFuture started
[13:38:01.272] - Launch lazy future ... done
[13:38:01.273] run() for ‘MultisessionFuture’ ... done
[13:38:01.273] getGlobalsAndPackages() ...
[13:38:01.273] Searching for globals...
[13:38:01.274] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:38:01.274] Searching for globals ... DONE
[13:38:01.274] Resolving globals: FALSE
[13:38:01.275] The total size of the 1 globals is 56 bytes (56 bytes)
[13:38:01.275] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:38:01.275] - globals: [1] ‘kk’
[13:38:01.275] 
[13:38:01.275] getGlobalsAndPackages() ... DONE
[13:38:01.276] run() for ‘Future’ ...
[13:38:01.276] - state: ‘created’
[13:38:01.276] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:01.289] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:01.290] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:01.290]   - Field: ‘node’
[13:38:01.290]   - Field: ‘label’
[13:38:01.290]   - Field: ‘local’
[13:38:01.290]   - Field: ‘owner’
[13:38:01.290]   - Field: ‘envir’
[13:38:01.290]   - Field: ‘workers’
[13:38:01.290]   - Field: ‘packages’
[13:38:01.290]   - Field: ‘gc’
[13:38:01.290]   - Field: ‘conditions’
[13:38:01.291]   - Field: ‘persistent’
[13:38:01.291]   - Field: ‘expr’
[13:38:01.291]   - Field: ‘uuid’
[13:38:01.291]   - Field: ‘seed’
[13:38:01.291]   - Field: ‘version’
[13:38:01.291]   - Field: ‘result’
[13:38:01.291]   - Field: ‘asynchronous’
[13:38:01.291]   - Field: ‘calls’
[13:38:01.291]   - Field: ‘globals’
[13:38:01.291]   - Field: ‘stdout’
[13:38:01.291]   - Field: ‘earlySignal’
[13:38:01.292]   - Field: ‘lazy’
[13:38:01.292]   - Field: ‘state’
[13:38:01.292] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:01.292] - Launch lazy future ...
[13:38:01.292] Packages needed by the future expression (n = 0): <none>
[13:38:01.292] Packages needed by future strategies (n = 0): <none>
[13:38:01.293] {
[13:38:01.293]     {
[13:38:01.293]         {
[13:38:01.293]             ...future.startTime <- base::Sys.time()
[13:38:01.293]             {
[13:38:01.293]                 {
[13:38:01.293]                   {
[13:38:01.293]                     {
[13:38:01.293]                       base::local({
[13:38:01.293]                         has_future <- base::requireNamespace("future", 
[13:38:01.293]                           quietly = TRUE)
[13:38:01.293]                         if (has_future) {
[13:38:01.293]                           ns <- base::getNamespace("future")
[13:38:01.293]                           version <- ns[[".package"]][["version"]]
[13:38:01.293]                           if (is.null(version)) 
[13:38:01.293]                             version <- utils::packageVersion("future")
[13:38:01.293]                         }
[13:38:01.293]                         else {
[13:38:01.293]                           version <- NULL
[13:38:01.293]                         }
[13:38:01.293]                         if (!has_future || version < "1.8.0") {
[13:38:01.293]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:01.293]                             "", base::R.version$version.string), 
[13:38:01.293]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:01.293]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:01.293]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:01.293]                               "release", "version")], collapse = " "), 
[13:38:01.293]                             hostname = base::Sys.info()[["nodename"]])
[13:38:01.293]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:01.293]                             info)
[13:38:01.293]                           info <- base::paste(info, collapse = "; ")
[13:38:01.293]                           if (!has_future) {
[13:38:01.293]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:01.293]                               info)
[13:38:01.293]                           }
[13:38:01.293]                           else {
[13:38:01.293]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:01.293]                               info, version)
[13:38:01.293]                           }
[13:38:01.293]                           base::stop(msg)
[13:38:01.293]                         }
[13:38:01.293]                       })
[13:38:01.293]                     }
[13:38:01.293]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:01.293]                     base::options(mc.cores = 1L)
[13:38:01.293]                   }
[13:38:01.293]                   ...future.strategy.old <- future::plan("list")
[13:38:01.293]                   options(future.plan = NULL)
[13:38:01.293]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.293]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:01.293]                 }
[13:38:01.293]                 ...future.workdir <- getwd()
[13:38:01.293]             }
[13:38:01.293]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:01.293]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:01.293]         }
[13:38:01.293]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:01.293]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:01.293]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:01.293]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:01.293]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:01.293]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:01.293]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:01.293]             base::names(...future.oldOptions))
[13:38:01.293]     }
[13:38:01.293]     if (FALSE) {
[13:38:01.293]     }
[13:38:01.293]     else {
[13:38:01.293]         if (TRUE) {
[13:38:01.293]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:01.293]                 open = "w")
[13:38:01.293]         }
[13:38:01.293]         else {
[13:38:01.293]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:01.293]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:01.293]         }
[13:38:01.293]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:01.293]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:01.293]             base::sink(type = "output", split = FALSE)
[13:38:01.293]             base::close(...future.stdout)
[13:38:01.293]         }, add = TRUE)
[13:38:01.293]     }
[13:38:01.293]     ...future.frame <- base::sys.nframe()
[13:38:01.293]     ...future.conditions <- base::list()
[13:38:01.293]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:01.293]     if (FALSE) {
[13:38:01.293]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:01.293]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:01.293]     }
[13:38:01.293]     ...future.result <- base::tryCatch({
[13:38:01.293]         base::withCallingHandlers({
[13:38:01.293]             ...future.value <- base::withVisible(base::local({
[13:38:01.293]                 ...future.makeSendCondition <- base::local({
[13:38:01.293]                   sendCondition <- NULL
[13:38:01.293]                   function(frame = 1L) {
[13:38:01.293]                     if (is.function(sendCondition)) 
[13:38:01.293]                       return(sendCondition)
[13:38:01.293]                     ns <- getNamespace("parallel")
[13:38:01.293]                     if (exists("sendData", mode = "function", 
[13:38:01.293]                       envir = ns)) {
[13:38:01.293]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:01.293]                         envir = ns)
[13:38:01.293]                       envir <- sys.frame(frame)
[13:38:01.293]                       master <- NULL
[13:38:01.293]                       while (!identical(envir, .GlobalEnv) && 
[13:38:01.293]                         !identical(envir, emptyenv())) {
[13:38:01.293]                         if (exists("master", mode = "list", envir = envir, 
[13:38:01.293]                           inherits = FALSE)) {
[13:38:01.293]                           master <- get("master", mode = "list", 
[13:38:01.293]                             envir = envir, inherits = FALSE)
[13:38:01.293]                           if (inherits(master, c("SOCKnode", 
[13:38:01.293]                             "SOCK0node"))) {
[13:38:01.293]                             sendCondition <<- function(cond) {
[13:38:01.293]                               data <- list(type = "VALUE", value = cond, 
[13:38:01.293]                                 success = TRUE)
[13:38:01.293]                               parallel_sendData(master, data)
[13:38:01.293]                             }
[13:38:01.293]                             return(sendCondition)
[13:38:01.293]                           }
[13:38:01.293]                         }
[13:38:01.293]                         frame <- frame + 1L
[13:38:01.293]                         envir <- sys.frame(frame)
[13:38:01.293]                       }
[13:38:01.293]                     }
[13:38:01.293]                     sendCondition <<- function(cond) NULL
[13:38:01.293]                   }
[13:38:01.293]                 })
[13:38:01.293]                 withCallingHandlers({
[13:38:01.293]                   {
[13:38:01.293]                     Sys.sleep(0.1)
[13:38:01.293]                     kk
[13:38:01.293]                   }
[13:38:01.293]                 }, immediateCondition = function(cond) {
[13:38:01.293]                   sendCondition <- ...future.makeSendCondition()
[13:38:01.293]                   sendCondition(cond)
[13:38:01.293]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.293]                   {
[13:38:01.293]                     inherits <- base::inherits
[13:38:01.293]                     invokeRestart <- base::invokeRestart
[13:38:01.293]                     is.null <- base::is.null
[13:38:01.293]                     muffled <- FALSE
[13:38:01.293]                     if (inherits(cond, "message")) {
[13:38:01.293]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:01.293]                       if (muffled) 
[13:38:01.293]                         invokeRestart("muffleMessage")
[13:38:01.293]                     }
[13:38:01.293]                     else if (inherits(cond, "warning")) {
[13:38:01.293]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:01.293]                       if (muffled) 
[13:38:01.293]                         invokeRestart("muffleWarning")
[13:38:01.293]                     }
[13:38:01.293]                     else if (inherits(cond, "condition")) {
[13:38:01.293]                       if (!is.null(pattern)) {
[13:38:01.293]                         computeRestarts <- base::computeRestarts
[13:38:01.293]                         grepl <- base::grepl
[13:38:01.293]                         restarts <- computeRestarts(cond)
[13:38:01.293]                         for (restart in restarts) {
[13:38:01.293]                           name <- restart$name
[13:38:01.293]                           if (is.null(name)) 
[13:38:01.293]                             next
[13:38:01.293]                           if (!grepl(pattern, name)) 
[13:38:01.293]                             next
[13:38:01.293]                           invokeRestart(restart)
[13:38:01.293]                           muffled <- TRUE
[13:38:01.293]                           break
[13:38:01.293]                         }
[13:38:01.293]                       }
[13:38:01.293]                     }
[13:38:01.293]                     invisible(muffled)
[13:38:01.293]                   }
[13:38:01.293]                   muffleCondition(cond)
[13:38:01.293]                 })
[13:38:01.293]             }))
[13:38:01.293]             future::FutureResult(value = ...future.value$value, 
[13:38:01.293]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.293]                   ...future.rng), globalenv = if (FALSE) 
[13:38:01.293]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:01.293]                     ...future.globalenv.names))
[13:38:01.293]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:01.293]         }, condition = base::local({
[13:38:01.293]             c <- base::c
[13:38:01.293]             inherits <- base::inherits
[13:38:01.293]             invokeRestart <- base::invokeRestart
[13:38:01.293]             length <- base::length
[13:38:01.293]             list <- base::list
[13:38:01.293]             seq.int <- base::seq.int
[13:38:01.293]             signalCondition <- base::signalCondition
[13:38:01.293]             sys.calls <- base::sys.calls
[13:38:01.293]             `[[` <- base::`[[`
[13:38:01.293]             `+` <- base::`+`
[13:38:01.293]             `<<-` <- base::`<<-`
[13:38:01.293]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:01.293]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:01.293]                   3L)]
[13:38:01.293]             }
[13:38:01.293]             function(cond) {
[13:38:01.293]                 is_error <- inherits(cond, "error")
[13:38:01.293]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:01.293]                   NULL)
[13:38:01.293]                 if (is_error) {
[13:38:01.293]                   sessionInformation <- function() {
[13:38:01.293]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:01.293]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:01.293]                       search = base::search(), system = base::Sys.info())
[13:38:01.293]                   }
[13:38:01.293]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.293]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:01.293]                     cond$call), session = sessionInformation(), 
[13:38:01.293]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:01.293]                   signalCondition(cond)
[13:38:01.293]                 }
[13:38:01.293]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:01.293]                 "immediateCondition"))) {
[13:38:01.293]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:01.293]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.293]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:01.293]                   if (TRUE && !signal) {
[13:38:01.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.293]                     {
[13:38:01.293]                       inherits <- base::inherits
[13:38:01.293]                       invokeRestart <- base::invokeRestart
[13:38:01.293]                       is.null <- base::is.null
[13:38:01.293]                       muffled <- FALSE
[13:38:01.293]                       if (inherits(cond, "message")) {
[13:38:01.293]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.293]                         if (muffled) 
[13:38:01.293]                           invokeRestart("muffleMessage")
[13:38:01.293]                       }
[13:38:01.293]                       else if (inherits(cond, "warning")) {
[13:38:01.293]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.293]                         if (muffled) 
[13:38:01.293]                           invokeRestart("muffleWarning")
[13:38:01.293]                       }
[13:38:01.293]                       else if (inherits(cond, "condition")) {
[13:38:01.293]                         if (!is.null(pattern)) {
[13:38:01.293]                           computeRestarts <- base::computeRestarts
[13:38:01.293]                           grepl <- base::grepl
[13:38:01.293]                           restarts <- computeRestarts(cond)
[13:38:01.293]                           for (restart in restarts) {
[13:38:01.293]                             name <- restart$name
[13:38:01.293]                             if (is.null(name)) 
[13:38:01.293]                               next
[13:38:01.293]                             if (!grepl(pattern, name)) 
[13:38:01.293]                               next
[13:38:01.293]                             invokeRestart(restart)
[13:38:01.293]                             muffled <- TRUE
[13:38:01.293]                             break
[13:38:01.293]                           }
[13:38:01.293]                         }
[13:38:01.293]                       }
[13:38:01.293]                       invisible(muffled)
[13:38:01.293]                     }
[13:38:01.293]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.293]                   }
[13:38:01.293]                 }
[13:38:01.293]                 else {
[13:38:01.293]                   if (TRUE) {
[13:38:01.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.293]                     {
[13:38:01.293]                       inherits <- base::inherits
[13:38:01.293]                       invokeRestart <- base::invokeRestart
[13:38:01.293]                       is.null <- base::is.null
[13:38:01.293]                       muffled <- FALSE
[13:38:01.293]                       if (inherits(cond, "message")) {
[13:38:01.293]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.293]                         if (muffled) 
[13:38:01.293]                           invokeRestart("muffleMessage")
[13:38:01.293]                       }
[13:38:01.293]                       else if (inherits(cond, "warning")) {
[13:38:01.293]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.293]                         if (muffled) 
[13:38:01.293]                           invokeRestart("muffleWarning")
[13:38:01.293]                       }
[13:38:01.293]                       else if (inherits(cond, "condition")) {
[13:38:01.293]                         if (!is.null(pattern)) {
[13:38:01.293]                           computeRestarts <- base::computeRestarts
[13:38:01.293]                           grepl <- base::grepl
[13:38:01.293]                           restarts <- computeRestarts(cond)
[13:38:01.293]                           for (restart in restarts) {
[13:38:01.293]                             name <- restart$name
[13:38:01.293]                             if (is.null(name)) 
[13:38:01.293]                               next
[13:38:01.293]                             if (!grepl(pattern, name)) 
[13:38:01.293]                               next
[13:38:01.293]                             invokeRestart(restart)
[13:38:01.293]                             muffled <- TRUE
[13:38:01.293]                             break
[13:38:01.293]                           }
[13:38:01.293]                         }
[13:38:01.293]                       }
[13:38:01.293]                       invisible(muffled)
[13:38:01.293]                     }
[13:38:01.293]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.293]                   }
[13:38:01.293]                 }
[13:38:01.293]             }
[13:38:01.293]         }))
[13:38:01.293]     }, error = function(ex) {
[13:38:01.293]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:01.293]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.293]                 ...future.rng), started = ...future.startTime, 
[13:38:01.293]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:01.293]             version = "1.8"), class = "FutureResult")
[13:38:01.293]     }, finally = {
[13:38:01.293]         if (!identical(...future.workdir, getwd())) 
[13:38:01.293]             setwd(...future.workdir)
[13:38:01.293]         {
[13:38:01.293]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:01.293]                 ...future.oldOptions$nwarnings <- NULL
[13:38:01.293]             }
[13:38:01.293]             base::options(...future.oldOptions)
[13:38:01.293]             if (.Platform$OS.type == "windows") {
[13:38:01.293]                 old_names <- names(...future.oldEnvVars)
[13:38:01.293]                 envs <- base::Sys.getenv()
[13:38:01.293]                 names <- names(envs)
[13:38:01.293]                 common <- intersect(names, old_names)
[13:38:01.293]                 added <- setdiff(names, old_names)
[13:38:01.293]                 removed <- setdiff(old_names, names)
[13:38:01.293]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:01.293]                   envs[common]]
[13:38:01.293]                 NAMES <- toupper(changed)
[13:38:01.293]                 args <- list()
[13:38:01.293]                 for (kk in seq_along(NAMES)) {
[13:38:01.293]                   name <- changed[[kk]]
[13:38:01.293]                   NAME <- NAMES[[kk]]
[13:38:01.293]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.293]                     next
[13:38:01.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.293]                 }
[13:38:01.293]                 NAMES <- toupper(added)
[13:38:01.293]                 for (kk in seq_along(NAMES)) {
[13:38:01.293]                   name <- added[[kk]]
[13:38:01.293]                   NAME <- NAMES[[kk]]
[13:38:01.293]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.293]                     next
[13:38:01.293]                   args[[name]] <- ""
[13:38:01.293]                 }
[13:38:01.293]                 NAMES <- toupper(removed)
[13:38:01.293]                 for (kk in seq_along(NAMES)) {
[13:38:01.293]                   name <- removed[[kk]]
[13:38:01.293]                   NAME <- NAMES[[kk]]
[13:38:01.293]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.293]                     next
[13:38:01.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.293]                 }
[13:38:01.293]                 if (length(args) > 0) 
[13:38:01.293]                   base::do.call(base::Sys.setenv, args = args)
[13:38:01.293]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:01.293]             }
[13:38:01.293]             else {
[13:38:01.293]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:01.293]             }
[13:38:01.293]             {
[13:38:01.293]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:01.293]                   0L) {
[13:38:01.293]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:01.293]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:01.293]                   base::options(opts)
[13:38:01.293]                 }
[13:38:01.293]                 {
[13:38:01.293]                   {
[13:38:01.293]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:01.293]                     NULL
[13:38:01.293]                   }
[13:38:01.293]                   options(future.plan = NULL)
[13:38:01.293]                   if (is.na(NA_character_)) 
[13:38:01.293]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.293]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:01.293]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:01.293]                     .init = FALSE)
[13:38:01.293]                 }
[13:38:01.293]             }
[13:38:01.293]         }
[13:38:01.293]     })
[13:38:01.293]     if (TRUE) {
[13:38:01.293]         base::sink(type = "output", split = FALSE)
[13:38:01.293]         if (TRUE) {
[13:38:01.293]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:01.293]         }
[13:38:01.293]         else {
[13:38:01.293]             ...future.result["stdout"] <- base::list(NULL)
[13:38:01.293]         }
[13:38:01.293]         base::close(...future.stdout)
[13:38:01.293]         ...future.stdout <- NULL
[13:38:01.293]     }
[13:38:01.293]     ...future.result$conditions <- ...future.conditions
[13:38:01.293]     ...future.result$finished <- base::Sys.time()
[13:38:01.293]     ...future.result
[13:38:01.293] }
[13:38:01.295] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[13:38:01.295] Exporting ‘kk’ (56 bytes) to cluster node #2 ...
[13:38:01.296] Exporting ‘kk’ (56 bytes) to cluster node #2 ... DONE
[13:38:01.296] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[13:38:01.296] MultisessionFuture started
[13:38:01.297] - Launch lazy future ... done
[13:38:01.297] run() for ‘MultisessionFuture’ ... done
[13:38:01.297] getGlobalsAndPackages() ...
[13:38:01.297] Searching for globals...
[13:38:01.298] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:38:01.299] Searching for globals ... DONE
[13:38:01.299] Resolving globals: FALSE
[13:38:01.299] The total size of the 1 globals is 56 bytes (56 bytes)
[13:38:01.299] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:38:01.299] - globals: [1] ‘kk’
[13:38:01.300] 
[13:38:01.300] getGlobalsAndPackages() ... DONE
[13:38:01.300] run() for ‘Future’ ...
[13:38:01.300] - state: ‘created’
[13:38:01.300] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:01.313] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:01.314] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:01.314]   - Field: ‘node’
[13:38:01.314]   - Field: ‘label’
[13:38:01.314]   - Field: ‘local’
[13:38:01.314]   - Field: ‘owner’
[13:38:01.314]   - Field: ‘envir’
[13:38:01.314]   - Field: ‘workers’
[13:38:01.314]   - Field: ‘packages’
[13:38:01.314]   - Field: ‘gc’
[13:38:01.314]   - Field: ‘conditions’
[13:38:01.315]   - Field: ‘persistent’
[13:38:01.315]   - Field: ‘expr’
[13:38:01.315]   - Field: ‘uuid’
[13:38:01.315]   - Field: ‘seed’
[13:38:01.315]   - Field: ‘version’
[13:38:01.315]   - Field: ‘result’
[13:38:01.315]   - Field: ‘asynchronous’
[13:38:01.315]   - Field: ‘calls’
[13:38:01.315]   - Field: ‘globals’
[13:38:01.315]   - Field: ‘stdout’
[13:38:01.315]   - Field: ‘earlySignal’
[13:38:01.316]   - Field: ‘lazy’
[13:38:01.316]   - Field: ‘state’
[13:38:01.316] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:01.316] - Launch lazy future ...
[13:38:01.316] Packages needed by the future expression (n = 0): <none>
[13:38:01.316] Packages needed by future strategies (n = 0): <none>
[13:38:01.317] {
[13:38:01.317]     {
[13:38:01.317]         {
[13:38:01.317]             ...future.startTime <- base::Sys.time()
[13:38:01.317]             {
[13:38:01.317]                 {
[13:38:01.317]                   {
[13:38:01.317]                     {
[13:38:01.317]                       base::local({
[13:38:01.317]                         has_future <- base::requireNamespace("future", 
[13:38:01.317]                           quietly = TRUE)
[13:38:01.317]                         if (has_future) {
[13:38:01.317]                           ns <- base::getNamespace("future")
[13:38:01.317]                           version <- ns[[".package"]][["version"]]
[13:38:01.317]                           if (is.null(version)) 
[13:38:01.317]                             version <- utils::packageVersion("future")
[13:38:01.317]                         }
[13:38:01.317]                         else {
[13:38:01.317]                           version <- NULL
[13:38:01.317]                         }
[13:38:01.317]                         if (!has_future || version < "1.8.0") {
[13:38:01.317]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:01.317]                             "", base::R.version$version.string), 
[13:38:01.317]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:01.317]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:01.317]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:01.317]                               "release", "version")], collapse = " "), 
[13:38:01.317]                             hostname = base::Sys.info()[["nodename"]])
[13:38:01.317]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:01.317]                             info)
[13:38:01.317]                           info <- base::paste(info, collapse = "; ")
[13:38:01.317]                           if (!has_future) {
[13:38:01.317]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:01.317]                               info)
[13:38:01.317]                           }
[13:38:01.317]                           else {
[13:38:01.317]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:01.317]                               info, version)
[13:38:01.317]                           }
[13:38:01.317]                           base::stop(msg)
[13:38:01.317]                         }
[13:38:01.317]                       })
[13:38:01.317]                     }
[13:38:01.317]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:01.317]                     base::options(mc.cores = 1L)
[13:38:01.317]                   }
[13:38:01.317]                   ...future.strategy.old <- future::plan("list")
[13:38:01.317]                   options(future.plan = NULL)
[13:38:01.317]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.317]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:01.317]                 }
[13:38:01.317]                 ...future.workdir <- getwd()
[13:38:01.317]             }
[13:38:01.317]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:01.317]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:01.317]         }
[13:38:01.317]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:01.317]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:01.317]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:01.317]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:01.317]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:01.317]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:01.317]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:01.317]             base::names(...future.oldOptions))
[13:38:01.317]     }
[13:38:01.317]     if (FALSE) {
[13:38:01.317]     }
[13:38:01.317]     else {
[13:38:01.317]         if (TRUE) {
[13:38:01.317]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:01.317]                 open = "w")
[13:38:01.317]         }
[13:38:01.317]         else {
[13:38:01.317]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:01.317]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:01.317]         }
[13:38:01.317]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:01.317]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:01.317]             base::sink(type = "output", split = FALSE)
[13:38:01.317]             base::close(...future.stdout)
[13:38:01.317]         }, add = TRUE)
[13:38:01.317]     }
[13:38:01.317]     ...future.frame <- base::sys.nframe()
[13:38:01.317]     ...future.conditions <- base::list()
[13:38:01.317]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:01.317]     if (FALSE) {
[13:38:01.317]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:01.317]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:01.317]     }
[13:38:01.317]     ...future.result <- base::tryCatch({
[13:38:01.317]         base::withCallingHandlers({
[13:38:01.317]             ...future.value <- base::withVisible(base::local({
[13:38:01.317]                 ...future.makeSendCondition <- base::local({
[13:38:01.317]                   sendCondition <- NULL
[13:38:01.317]                   function(frame = 1L) {
[13:38:01.317]                     if (is.function(sendCondition)) 
[13:38:01.317]                       return(sendCondition)
[13:38:01.317]                     ns <- getNamespace("parallel")
[13:38:01.317]                     if (exists("sendData", mode = "function", 
[13:38:01.317]                       envir = ns)) {
[13:38:01.317]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:01.317]                         envir = ns)
[13:38:01.317]                       envir <- sys.frame(frame)
[13:38:01.317]                       master <- NULL
[13:38:01.317]                       while (!identical(envir, .GlobalEnv) && 
[13:38:01.317]                         !identical(envir, emptyenv())) {
[13:38:01.317]                         if (exists("master", mode = "list", envir = envir, 
[13:38:01.317]                           inherits = FALSE)) {
[13:38:01.317]                           master <- get("master", mode = "list", 
[13:38:01.317]                             envir = envir, inherits = FALSE)
[13:38:01.317]                           if (inherits(master, c("SOCKnode", 
[13:38:01.317]                             "SOCK0node"))) {
[13:38:01.317]                             sendCondition <<- function(cond) {
[13:38:01.317]                               data <- list(type = "VALUE", value = cond, 
[13:38:01.317]                                 success = TRUE)
[13:38:01.317]                               parallel_sendData(master, data)
[13:38:01.317]                             }
[13:38:01.317]                             return(sendCondition)
[13:38:01.317]                           }
[13:38:01.317]                         }
[13:38:01.317]                         frame <- frame + 1L
[13:38:01.317]                         envir <- sys.frame(frame)
[13:38:01.317]                       }
[13:38:01.317]                     }
[13:38:01.317]                     sendCondition <<- function(cond) NULL
[13:38:01.317]                   }
[13:38:01.317]                 })
[13:38:01.317]                 withCallingHandlers({
[13:38:01.317]                   {
[13:38:01.317]                     Sys.sleep(0.1)
[13:38:01.317]                     kk
[13:38:01.317]                   }
[13:38:01.317]                 }, immediateCondition = function(cond) {
[13:38:01.317]                   sendCondition <- ...future.makeSendCondition()
[13:38:01.317]                   sendCondition(cond)
[13:38:01.317]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.317]                   {
[13:38:01.317]                     inherits <- base::inherits
[13:38:01.317]                     invokeRestart <- base::invokeRestart
[13:38:01.317]                     is.null <- base::is.null
[13:38:01.317]                     muffled <- FALSE
[13:38:01.317]                     if (inherits(cond, "message")) {
[13:38:01.317]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:01.317]                       if (muffled) 
[13:38:01.317]                         invokeRestart("muffleMessage")
[13:38:01.317]                     }
[13:38:01.317]                     else if (inherits(cond, "warning")) {
[13:38:01.317]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:01.317]                       if (muffled) 
[13:38:01.317]                         invokeRestart("muffleWarning")
[13:38:01.317]                     }
[13:38:01.317]                     else if (inherits(cond, "condition")) {
[13:38:01.317]                       if (!is.null(pattern)) {
[13:38:01.317]                         computeRestarts <- base::computeRestarts
[13:38:01.317]                         grepl <- base::grepl
[13:38:01.317]                         restarts <- computeRestarts(cond)
[13:38:01.317]                         for (restart in restarts) {
[13:38:01.317]                           name <- restart$name
[13:38:01.317]                           if (is.null(name)) 
[13:38:01.317]                             next
[13:38:01.317]                           if (!grepl(pattern, name)) 
[13:38:01.317]                             next
[13:38:01.317]                           invokeRestart(restart)
[13:38:01.317]                           muffled <- TRUE
[13:38:01.317]                           break
[13:38:01.317]                         }
[13:38:01.317]                       }
[13:38:01.317]                     }
[13:38:01.317]                     invisible(muffled)
[13:38:01.317]                   }
[13:38:01.317]                   muffleCondition(cond)
[13:38:01.317]                 })
[13:38:01.317]             }))
[13:38:01.317]             future::FutureResult(value = ...future.value$value, 
[13:38:01.317]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.317]                   ...future.rng), globalenv = if (FALSE) 
[13:38:01.317]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:01.317]                     ...future.globalenv.names))
[13:38:01.317]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:01.317]         }, condition = base::local({
[13:38:01.317]             c <- base::c
[13:38:01.317]             inherits <- base::inherits
[13:38:01.317]             invokeRestart <- base::invokeRestart
[13:38:01.317]             length <- base::length
[13:38:01.317]             list <- base::list
[13:38:01.317]             seq.int <- base::seq.int
[13:38:01.317]             signalCondition <- base::signalCondition
[13:38:01.317]             sys.calls <- base::sys.calls
[13:38:01.317]             `[[` <- base::`[[`
[13:38:01.317]             `+` <- base::`+`
[13:38:01.317]             `<<-` <- base::`<<-`
[13:38:01.317]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:01.317]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:01.317]                   3L)]
[13:38:01.317]             }
[13:38:01.317]             function(cond) {
[13:38:01.317]                 is_error <- inherits(cond, "error")
[13:38:01.317]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:01.317]                   NULL)
[13:38:01.317]                 if (is_error) {
[13:38:01.317]                   sessionInformation <- function() {
[13:38:01.317]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:01.317]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:01.317]                       search = base::search(), system = base::Sys.info())
[13:38:01.317]                   }
[13:38:01.317]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.317]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:01.317]                     cond$call), session = sessionInformation(), 
[13:38:01.317]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:01.317]                   signalCondition(cond)
[13:38:01.317]                 }
[13:38:01.317]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:01.317]                 "immediateCondition"))) {
[13:38:01.317]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:01.317]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.317]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:01.317]                   if (TRUE && !signal) {
[13:38:01.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.317]                     {
[13:38:01.317]                       inherits <- base::inherits
[13:38:01.317]                       invokeRestart <- base::invokeRestart
[13:38:01.317]                       is.null <- base::is.null
[13:38:01.317]                       muffled <- FALSE
[13:38:01.317]                       if (inherits(cond, "message")) {
[13:38:01.317]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.317]                         if (muffled) 
[13:38:01.317]                           invokeRestart("muffleMessage")
[13:38:01.317]                       }
[13:38:01.317]                       else if (inherits(cond, "warning")) {
[13:38:01.317]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.317]                         if (muffled) 
[13:38:01.317]                           invokeRestart("muffleWarning")
[13:38:01.317]                       }
[13:38:01.317]                       else if (inherits(cond, "condition")) {
[13:38:01.317]                         if (!is.null(pattern)) {
[13:38:01.317]                           computeRestarts <- base::computeRestarts
[13:38:01.317]                           grepl <- base::grepl
[13:38:01.317]                           restarts <- computeRestarts(cond)
[13:38:01.317]                           for (restart in restarts) {
[13:38:01.317]                             name <- restart$name
[13:38:01.317]                             if (is.null(name)) 
[13:38:01.317]                               next
[13:38:01.317]                             if (!grepl(pattern, name)) 
[13:38:01.317]                               next
[13:38:01.317]                             invokeRestart(restart)
[13:38:01.317]                             muffled <- TRUE
[13:38:01.317]                             break
[13:38:01.317]                           }
[13:38:01.317]                         }
[13:38:01.317]                       }
[13:38:01.317]                       invisible(muffled)
[13:38:01.317]                     }
[13:38:01.317]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.317]                   }
[13:38:01.317]                 }
[13:38:01.317]                 else {
[13:38:01.317]                   if (TRUE) {
[13:38:01.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.317]                     {
[13:38:01.317]                       inherits <- base::inherits
[13:38:01.317]                       invokeRestart <- base::invokeRestart
[13:38:01.317]                       is.null <- base::is.null
[13:38:01.317]                       muffled <- FALSE
[13:38:01.317]                       if (inherits(cond, "message")) {
[13:38:01.317]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.317]                         if (muffled) 
[13:38:01.317]                           invokeRestart("muffleMessage")
[13:38:01.317]                       }
[13:38:01.317]                       else if (inherits(cond, "warning")) {
[13:38:01.317]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.317]                         if (muffled) 
[13:38:01.317]                           invokeRestart("muffleWarning")
[13:38:01.317]                       }
[13:38:01.317]                       else if (inherits(cond, "condition")) {
[13:38:01.317]                         if (!is.null(pattern)) {
[13:38:01.317]                           computeRestarts <- base::computeRestarts
[13:38:01.317]                           grepl <- base::grepl
[13:38:01.317]                           restarts <- computeRestarts(cond)
[13:38:01.317]                           for (restart in restarts) {
[13:38:01.317]                             name <- restart$name
[13:38:01.317]                             if (is.null(name)) 
[13:38:01.317]                               next
[13:38:01.317]                             if (!grepl(pattern, name)) 
[13:38:01.317]                               next
[13:38:01.317]                             invokeRestart(restart)
[13:38:01.317]                             muffled <- TRUE
[13:38:01.317]                             break
[13:38:01.317]                           }
[13:38:01.317]                         }
[13:38:01.317]                       }
[13:38:01.317]                       invisible(muffled)
[13:38:01.317]                     }
[13:38:01.317]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.317]                   }
[13:38:01.317]                 }
[13:38:01.317]             }
[13:38:01.317]         }))
[13:38:01.317]     }, error = function(ex) {
[13:38:01.317]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:01.317]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.317]                 ...future.rng), started = ...future.startTime, 
[13:38:01.317]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:01.317]             version = "1.8"), class = "FutureResult")
[13:38:01.317]     }, finally = {
[13:38:01.317]         if (!identical(...future.workdir, getwd())) 
[13:38:01.317]             setwd(...future.workdir)
[13:38:01.317]         {
[13:38:01.317]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:01.317]                 ...future.oldOptions$nwarnings <- NULL
[13:38:01.317]             }
[13:38:01.317]             base::options(...future.oldOptions)
[13:38:01.317]             if (.Platform$OS.type == "windows") {
[13:38:01.317]                 old_names <- names(...future.oldEnvVars)
[13:38:01.317]                 envs <- base::Sys.getenv()
[13:38:01.317]                 names <- names(envs)
[13:38:01.317]                 common <- intersect(names, old_names)
[13:38:01.317]                 added <- setdiff(names, old_names)
[13:38:01.317]                 removed <- setdiff(old_names, names)
[13:38:01.317]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:01.317]                   envs[common]]
[13:38:01.317]                 NAMES <- toupper(changed)
[13:38:01.317]                 args <- list()
[13:38:01.317]                 for (kk in seq_along(NAMES)) {
[13:38:01.317]                   name <- changed[[kk]]
[13:38:01.317]                   NAME <- NAMES[[kk]]
[13:38:01.317]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.317]                     next
[13:38:01.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.317]                 }
[13:38:01.317]                 NAMES <- toupper(added)
[13:38:01.317]                 for (kk in seq_along(NAMES)) {
[13:38:01.317]                   name <- added[[kk]]
[13:38:01.317]                   NAME <- NAMES[[kk]]
[13:38:01.317]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.317]                     next
[13:38:01.317]                   args[[name]] <- ""
[13:38:01.317]                 }
[13:38:01.317]                 NAMES <- toupper(removed)
[13:38:01.317]                 for (kk in seq_along(NAMES)) {
[13:38:01.317]                   name <- removed[[kk]]
[13:38:01.317]                   NAME <- NAMES[[kk]]
[13:38:01.317]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.317]                     next
[13:38:01.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.317]                 }
[13:38:01.317]                 if (length(args) > 0) 
[13:38:01.317]                   base::do.call(base::Sys.setenv, args = args)
[13:38:01.317]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:01.317]             }
[13:38:01.317]             else {
[13:38:01.317]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:01.317]             }
[13:38:01.317]             {
[13:38:01.317]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:01.317]                   0L) {
[13:38:01.317]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:01.317]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:01.317]                   base::options(opts)
[13:38:01.317]                 }
[13:38:01.317]                 {
[13:38:01.317]                   {
[13:38:01.317]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:01.317]                     NULL
[13:38:01.317]                   }
[13:38:01.317]                   options(future.plan = NULL)
[13:38:01.317]                   if (is.na(NA_character_)) 
[13:38:01.317]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.317]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:01.317]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:01.317]                     .init = FALSE)
[13:38:01.317]                 }
[13:38:01.317]             }
[13:38:01.317]         }
[13:38:01.317]     })
[13:38:01.317]     if (TRUE) {
[13:38:01.317]         base::sink(type = "output", split = FALSE)
[13:38:01.317]         if (TRUE) {
[13:38:01.317]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:01.317]         }
[13:38:01.317]         else {
[13:38:01.317]             ...future.result["stdout"] <- base::list(NULL)
[13:38:01.317]         }
[13:38:01.317]         base::close(...future.stdout)
[13:38:01.317]         ...future.stdout <- NULL
[13:38:01.317]     }
[13:38:01.317]     ...future.result$conditions <- ...future.conditions
[13:38:01.317]     ...future.result$finished <- base::Sys.time()
[13:38:01.317]     ...future.result
[13:38:01.317] }
[13:38:01.319] Poll #1 (0): usedNodes() = 2, workers = 2
[13:38:01.350] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[13:38:01.381] Poll #3 (0.06 secs): usedNodes() = 2, workers = 2
[13:38:01.392] receiveMessageFromWorker() for ClusterFuture ...
[13:38:01.392] - Validating connection of MultisessionFuture
[13:38:01.393] - received message: FutureResult
[13:38:01.393] - Received FutureResult
[13:38:01.393] - Erased future from FutureRegistry
[13:38:01.393] result() for ClusterFuture ...
[13:38:01.393] - result already collected: FutureResult
[13:38:01.393] result() for ClusterFuture ... done
[13:38:01.393] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:01.393] result() for ClusterFuture ...
[13:38:01.393] - result already collected: FutureResult
[13:38:01.394] result() for ClusterFuture ... done
[13:38:01.394] result() for ClusterFuture ...
[13:38:01.394] - result already collected: FutureResult
[13:38:01.394] result() for ClusterFuture ... done
[13:38:01.394] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:38:01.395] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[13:38:01.395] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[13:38:01.395] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:38:01.395] MultisessionFuture started
[13:38:01.396] - Launch lazy future ... done
[13:38:01.396] run() for ‘MultisessionFuture’ ... done
[13:38:01.396] resolve() on list ...
[13:38:01.396]  recursive: 0
[13:38:01.396]  length: 3
[13:38:01.396] 
[13:38:01.396] Future #1
[13:38:01.396]  length: 2 (resolved future 1)
[13:38:01.399] receiveMessageFromWorker() for ClusterFuture ...
[13:38:01.399] - Validating connection of MultisessionFuture
[13:38:01.399] - received message: FutureResult
[13:38:01.399] - Received FutureResult
[13:38:01.399] - Erased future from FutureRegistry
[13:38:01.399] result() for ClusterFuture ...
[13:38:01.400] - result already collected: FutureResult
[13:38:01.400] result() for ClusterFuture ... done
[13:38:01.400] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:01.400] Future #2
[13:38:01.400]  length: 1 (resolved future 2)
[13:38:01.503] receiveMessageFromWorker() for ClusterFuture ...
[13:38:01.503] - Validating connection of MultisessionFuture
[13:38:01.503] - received message: FutureResult
[13:38:01.504] - Received FutureResult
[13:38:01.504] - Erased future from FutureRegistry
[13:38:01.504] result() for ClusterFuture ...
[13:38:01.504] - result already collected: FutureResult
[13:38:01.504] result() for ClusterFuture ... done
[13:38:01.504] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:01.504] Future #3
[13:38:01.504]  length: 0 (resolved future 3)
[13:38:01.504] resolve() on list ... DONE
[13:38:01.505] getGlobalsAndPackages() ...
[13:38:01.505] Searching for globals...
[13:38:01.506] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:38:01.506] Searching for globals ... DONE
[13:38:01.506] Resolving globals: FALSE
[13:38:01.506] The total size of the 1 globals is 56 bytes (56 bytes)
[13:38:01.507] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:38:01.507] - globals: [1] ‘kk’
[13:38:01.507] 
[13:38:01.507] getGlobalsAndPackages() ... DONE
[13:38:01.507] getGlobalsAndPackages() ...
[13:38:01.507] Searching for globals...
[13:38:01.511] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:38:01.512] Searching for globals ... DONE
[13:38:01.512] Resolving globals: FALSE
[13:38:01.512] The total size of the 1 globals is 56 bytes (56 bytes)
[13:38:01.512] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:38:01.513] - globals: [1] ‘kk’
[13:38:01.513] 
[13:38:01.513] getGlobalsAndPackages() ... DONE
[13:38:01.513] getGlobalsAndPackages() ...
[13:38:01.513] Searching for globals...
[13:38:01.514] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:38:01.514] Searching for globals ... DONE
[13:38:01.514] Resolving globals: FALSE
[13:38:01.515] The total size of the 1 globals is 56 bytes (56 bytes)
[13:38:01.515] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:38:01.515] - globals: [1] ‘kk’
[13:38:01.515] 
[13:38:01.515] getGlobalsAndPackages() ... DONE
[13:38:01.515] resolve() on list ...
[13:38:01.516]  recursive: 0
[13:38:01.516]  length: 3
[13:38:01.516] 
[13:38:01.516] run() for ‘Future’ ...
[13:38:01.516] - state: ‘created’
[13:38:01.516] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:01.530] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:01.530] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:01.531]   - Field: ‘node’
[13:38:01.531]   - Field: ‘label’
[13:38:01.531]   - Field: ‘local’
[13:38:01.531]   - Field: ‘owner’
[13:38:01.531]   - Field: ‘envir’
[13:38:01.531]   - Field: ‘workers’
[13:38:01.531]   - Field: ‘packages’
[13:38:01.531]   - Field: ‘gc’
[13:38:01.531]   - Field: ‘conditions’
[13:38:01.531]   - Field: ‘persistent’
[13:38:01.531]   - Field: ‘expr’
[13:38:01.532]   - Field: ‘uuid’
[13:38:01.532]   - Field: ‘seed’
[13:38:01.532]   - Field: ‘version’
[13:38:01.532]   - Field: ‘result’
[13:38:01.532]   - Field: ‘asynchronous’
[13:38:01.532]   - Field: ‘calls’
[13:38:01.532]   - Field: ‘globals’
[13:38:01.532]   - Field: ‘stdout’
[13:38:01.532]   - Field: ‘earlySignal’
[13:38:01.532]   - Field: ‘lazy’
[13:38:01.532]   - Field: ‘state’
[13:38:01.533] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:01.533] - Launch lazy future ...
[13:38:01.533] Packages needed by the future expression (n = 0): <none>
[13:38:01.533] Packages needed by future strategies (n = 0): <none>
[13:38:01.533] {
[13:38:01.533]     {
[13:38:01.533]         {
[13:38:01.533]             ...future.startTime <- base::Sys.time()
[13:38:01.533]             {
[13:38:01.533]                 {
[13:38:01.533]                   {
[13:38:01.533]                     {
[13:38:01.533]                       base::local({
[13:38:01.533]                         has_future <- base::requireNamespace("future", 
[13:38:01.533]                           quietly = TRUE)
[13:38:01.533]                         if (has_future) {
[13:38:01.533]                           ns <- base::getNamespace("future")
[13:38:01.533]                           version <- ns[[".package"]][["version"]]
[13:38:01.533]                           if (is.null(version)) 
[13:38:01.533]                             version <- utils::packageVersion("future")
[13:38:01.533]                         }
[13:38:01.533]                         else {
[13:38:01.533]                           version <- NULL
[13:38:01.533]                         }
[13:38:01.533]                         if (!has_future || version < "1.8.0") {
[13:38:01.533]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:01.533]                             "", base::R.version$version.string), 
[13:38:01.533]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:01.533]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:01.533]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:01.533]                               "release", "version")], collapse = " "), 
[13:38:01.533]                             hostname = base::Sys.info()[["nodename"]])
[13:38:01.533]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:01.533]                             info)
[13:38:01.533]                           info <- base::paste(info, collapse = "; ")
[13:38:01.533]                           if (!has_future) {
[13:38:01.533]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:01.533]                               info)
[13:38:01.533]                           }
[13:38:01.533]                           else {
[13:38:01.533]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:01.533]                               info, version)
[13:38:01.533]                           }
[13:38:01.533]                           base::stop(msg)
[13:38:01.533]                         }
[13:38:01.533]                       })
[13:38:01.533]                     }
[13:38:01.533]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:01.533]                     base::options(mc.cores = 1L)
[13:38:01.533]                   }
[13:38:01.533]                   ...future.strategy.old <- future::plan("list")
[13:38:01.533]                   options(future.plan = NULL)
[13:38:01.533]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.533]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:01.533]                 }
[13:38:01.533]                 ...future.workdir <- getwd()
[13:38:01.533]             }
[13:38:01.533]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:01.533]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:01.533]         }
[13:38:01.533]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:01.533]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:01.533]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:01.533]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:01.533]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:01.533]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:01.533]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:01.533]             base::names(...future.oldOptions))
[13:38:01.533]     }
[13:38:01.533]     if (FALSE) {
[13:38:01.533]     }
[13:38:01.533]     else {
[13:38:01.533]         if (TRUE) {
[13:38:01.533]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:01.533]                 open = "w")
[13:38:01.533]         }
[13:38:01.533]         else {
[13:38:01.533]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:01.533]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:01.533]         }
[13:38:01.533]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:01.533]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:01.533]             base::sink(type = "output", split = FALSE)
[13:38:01.533]             base::close(...future.stdout)
[13:38:01.533]         }, add = TRUE)
[13:38:01.533]     }
[13:38:01.533]     ...future.frame <- base::sys.nframe()
[13:38:01.533]     ...future.conditions <- base::list()
[13:38:01.533]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:01.533]     if (FALSE) {
[13:38:01.533]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:01.533]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:01.533]     }
[13:38:01.533]     ...future.result <- base::tryCatch({
[13:38:01.533]         base::withCallingHandlers({
[13:38:01.533]             ...future.value <- base::withVisible(base::local({
[13:38:01.533]                 ...future.makeSendCondition <- base::local({
[13:38:01.533]                   sendCondition <- NULL
[13:38:01.533]                   function(frame = 1L) {
[13:38:01.533]                     if (is.function(sendCondition)) 
[13:38:01.533]                       return(sendCondition)
[13:38:01.533]                     ns <- getNamespace("parallel")
[13:38:01.533]                     if (exists("sendData", mode = "function", 
[13:38:01.533]                       envir = ns)) {
[13:38:01.533]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:01.533]                         envir = ns)
[13:38:01.533]                       envir <- sys.frame(frame)
[13:38:01.533]                       master <- NULL
[13:38:01.533]                       while (!identical(envir, .GlobalEnv) && 
[13:38:01.533]                         !identical(envir, emptyenv())) {
[13:38:01.533]                         if (exists("master", mode = "list", envir = envir, 
[13:38:01.533]                           inherits = FALSE)) {
[13:38:01.533]                           master <- get("master", mode = "list", 
[13:38:01.533]                             envir = envir, inherits = FALSE)
[13:38:01.533]                           if (inherits(master, c("SOCKnode", 
[13:38:01.533]                             "SOCK0node"))) {
[13:38:01.533]                             sendCondition <<- function(cond) {
[13:38:01.533]                               data <- list(type = "VALUE", value = cond, 
[13:38:01.533]                                 success = TRUE)
[13:38:01.533]                               parallel_sendData(master, data)
[13:38:01.533]                             }
[13:38:01.533]                             return(sendCondition)
[13:38:01.533]                           }
[13:38:01.533]                         }
[13:38:01.533]                         frame <- frame + 1L
[13:38:01.533]                         envir <- sys.frame(frame)
[13:38:01.533]                       }
[13:38:01.533]                     }
[13:38:01.533]                     sendCondition <<- function(cond) NULL
[13:38:01.533]                   }
[13:38:01.533]                 })
[13:38:01.533]                 withCallingHandlers({
[13:38:01.533]                   {
[13:38:01.533]                     Sys.sleep(0.1)
[13:38:01.533]                     kk
[13:38:01.533]                   }
[13:38:01.533]                 }, immediateCondition = function(cond) {
[13:38:01.533]                   sendCondition <- ...future.makeSendCondition()
[13:38:01.533]                   sendCondition(cond)
[13:38:01.533]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.533]                   {
[13:38:01.533]                     inherits <- base::inherits
[13:38:01.533]                     invokeRestart <- base::invokeRestart
[13:38:01.533]                     is.null <- base::is.null
[13:38:01.533]                     muffled <- FALSE
[13:38:01.533]                     if (inherits(cond, "message")) {
[13:38:01.533]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:01.533]                       if (muffled) 
[13:38:01.533]                         invokeRestart("muffleMessage")
[13:38:01.533]                     }
[13:38:01.533]                     else if (inherits(cond, "warning")) {
[13:38:01.533]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:01.533]                       if (muffled) 
[13:38:01.533]                         invokeRestart("muffleWarning")
[13:38:01.533]                     }
[13:38:01.533]                     else if (inherits(cond, "condition")) {
[13:38:01.533]                       if (!is.null(pattern)) {
[13:38:01.533]                         computeRestarts <- base::computeRestarts
[13:38:01.533]                         grepl <- base::grepl
[13:38:01.533]                         restarts <- computeRestarts(cond)
[13:38:01.533]                         for (restart in restarts) {
[13:38:01.533]                           name <- restart$name
[13:38:01.533]                           if (is.null(name)) 
[13:38:01.533]                             next
[13:38:01.533]                           if (!grepl(pattern, name)) 
[13:38:01.533]                             next
[13:38:01.533]                           invokeRestart(restart)
[13:38:01.533]                           muffled <- TRUE
[13:38:01.533]                           break
[13:38:01.533]                         }
[13:38:01.533]                       }
[13:38:01.533]                     }
[13:38:01.533]                     invisible(muffled)
[13:38:01.533]                   }
[13:38:01.533]                   muffleCondition(cond)
[13:38:01.533]                 })
[13:38:01.533]             }))
[13:38:01.533]             future::FutureResult(value = ...future.value$value, 
[13:38:01.533]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.533]                   ...future.rng), globalenv = if (FALSE) 
[13:38:01.533]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:01.533]                     ...future.globalenv.names))
[13:38:01.533]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:01.533]         }, condition = base::local({
[13:38:01.533]             c <- base::c
[13:38:01.533]             inherits <- base::inherits
[13:38:01.533]             invokeRestart <- base::invokeRestart
[13:38:01.533]             length <- base::length
[13:38:01.533]             list <- base::list
[13:38:01.533]             seq.int <- base::seq.int
[13:38:01.533]             signalCondition <- base::signalCondition
[13:38:01.533]             sys.calls <- base::sys.calls
[13:38:01.533]             `[[` <- base::`[[`
[13:38:01.533]             `+` <- base::`+`
[13:38:01.533]             `<<-` <- base::`<<-`
[13:38:01.533]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:01.533]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:01.533]                   3L)]
[13:38:01.533]             }
[13:38:01.533]             function(cond) {
[13:38:01.533]                 is_error <- inherits(cond, "error")
[13:38:01.533]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:01.533]                   NULL)
[13:38:01.533]                 if (is_error) {
[13:38:01.533]                   sessionInformation <- function() {
[13:38:01.533]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:01.533]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:01.533]                       search = base::search(), system = base::Sys.info())
[13:38:01.533]                   }
[13:38:01.533]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.533]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:01.533]                     cond$call), session = sessionInformation(), 
[13:38:01.533]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:01.533]                   signalCondition(cond)
[13:38:01.533]                 }
[13:38:01.533]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:01.533]                 "immediateCondition"))) {
[13:38:01.533]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:01.533]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.533]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:01.533]                   if (TRUE && !signal) {
[13:38:01.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.533]                     {
[13:38:01.533]                       inherits <- base::inherits
[13:38:01.533]                       invokeRestart <- base::invokeRestart
[13:38:01.533]                       is.null <- base::is.null
[13:38:01.533]                       muffled <- FALSE
[13:38:01.533]                       if (inherits(cond, "message")) {
[13:38:01.533]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.533]                         if (muffled) 
[13:38:01.533]                           invokeRestart("muffleMessage")
[13:38:01.533]                       }
[13:38:01.533]                       else if (inherits(cond, "warning")) {
[13:38:01.533]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.533]                         if (muffled) 
[13:38:01.533]                           invokeRestart("muffleWarning")
[13:38:01.533]                       }
[13:38:01.533]                       else if (inherits(cond, "condition")) {
[13:38:01.533]                         if (!is.null(pattern)) {
[13:38:01.533]                           computeRestarts <- base::computeRestarts
[13:38:01.533]                           grepl <- base::grepl
[13:38:01.533]                           restarts <- computeRestarts(cond)
[13:38:01.533]                           for (restart in restarts) {
[13:38:01.533]                             name <- restart$name
[13:38:01.533]                             if (is.null(name)) 
[13:38:01.533]                               next
[13:38:01.533]                             if (!grepl(pattern, name)) 
[13:38:01.533]                               next
[13:38:01.533]                             invokeRestart(restart)
[13:38:01.533]                             muffled <- TRUE
[13:38:01.533]                             break
[13:38:01.533]                           }
[13:38:01.533]                         }
[13:38:01.533]                       }
[13:38:01.533]                       invisible(muffled)
[13:38:01.533]                     }
[13:38:01.533]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.533]                   }
[13:38:01.533]                 }
[13:38:01.533]                 else {
[13:38:01.533]                   if (TRUE) {
[13:38:01.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.533]                     {
[13:38:01.533]                       inherits <- base::inherits
[13:38:01.533]                       invokeRestart <- base::invokeRestart
[13:38:01.533]                       is.null <- base::is.null
[13:38:01.533]                       muffled <- FALSE
[13:38:01.533]                       if (inherits(cond, "message")) {
[13:38:01.533]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.533]                         if (muffled) 
[13:38:01.533]                           invokeRestart("muffleMessage")
[13:38:01.533]                       }
[13:38:01.533]                       else if (inherits(cond, "warning")) {
[13:38:01.533]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.533]                         if (muffled) 
[13:38:01.533]                           invokeRestart("muffleWarning")
[13:38:01.533]                       }
[13:38:01.533]                       else if (inherits(cond, "condition")) {
[13:38:01.533]                         if (!is.null(pattern)) {
[13:38:01.533]                           computeRestarts <- base::computeRestarts
[13:38:01.533]                           grepl <- base::grepl
[13:38:01.533]                           restarts <- computeRestarts(cond)
[13:38:01.533]                           for (restart in restarts) {
[13:38:01.533]                             name <- restart$name
[13:38:01.533]                             if (is.null(name)) 
[13:38:01.533]                               next
[13:38:01.533]                             if (!grepl(pattern, name)) 
[13:38:01.533]                               next
[13:38:01.533]                             invokeRestart(restart)
[13:38:01.533]                             muffled <- TRUE
[13:38:01.533]                             break
[13:38:01.533]                           }
[13:38:01.533]                         }
[13:38:01.533]                       }
[13:38:01.533]                       invisible(muffled)
[13:38:01.533]                     }
[13:38:01.533]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.533]                   }
[13:38:01.533]                 }
[13:38:01.533]             }
[13:38:01.533]         }))
[13:38:01.533]     }, error = function(ex) {
[13:38:01.533]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:01.533]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.533]                 ...future.rng), started = ...future.startTime, 
[13:38:01.533]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:01.533]             version = "1.8"), class = "FutureResult")
[13:38:01.533]     }, finally = {
[13:38:01.533]         if (!identical(...future.workdir, getwd())) 
[13:38:01.533]             setwd(...future.workdir)
[13:38:01.533]         {
[13:38:01.533]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:01.533]                 ...future.oldOptions$nwarnings <- NULL
[13:38:01.533]             }
[13:38:01.533]             base::options(...future.oldOptions)
[13:38:01.533]             if (.Platform$OS.type == "windows") {
[13:38:01.533]                 old_names <- names(...future.oldEnvVars)
[13:38:01.533]                 envs <- base::Sys.getenv()
[13:38:01.533]                 names <- names(envs)
[13:38:01.533]                 common <- intersect(names, old_names)
[13:38:01.533]                 added <- setdiff(names, old_names)
[13:38:01.533]                 removed <- setdiff(old_names, names)
[13:38:01.533]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:01.533]                   envs[common]]
[13:38:01.533]                 NAMES <- toupper(changed)
[13:38:01.533]                 args <- list()
[13:38:01.533]                 for (kk in seq_along(NAMES)) {
[13:38:01.533]                   name <- changed[[kk]]
[13:38:01.533]                   NAME <- NAMES[[kk]]
[13:38:01.533]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.533]                     next
[13:38:01.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.533]                 }
[13:38:01.533]                 NAMES <- toupper(added)
[13:38:01.533]                 for (kk in seq_along(NAMES)) {
[13:38:01.533]                   name <- added[[kk]]
[13:38:01.533]                   NAME <- NAMES[[kk]]
[13:38:01.533]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.533]                     next
[13:38:01.533]                   args[[name]] <- ""
[13:38:01.533]                 }
[13:38:01.533]                 NAMES <- toupper(removed)
[13:38:01.533]                 for (kk in seq_along(NAMES)) {
[13:38:01.533]                   name <- removed[[kk]]
[13:38:01.533]                   NAME <- NAMES[[kk]]
[13:38:01.533]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.533]                     next
[13:38:01.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.533]                 }
[13:38:01.533]                 if (length(args) > 0) 
[13:38:01.533]                   base::do.call(base::Sys.setenv, args = args)
[13:38:01.533]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:01.533]             }
[13:38:01.533]             else {
[13:38:01.533]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:01.533]             }
[13:38:01.533]             {
[13:38:01.533]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:01.533]                   0L) {
[13:38:01.533]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:01.533]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:01.533]                   base::options(opts)
[13:38:01.533]                 }
[13:38:01.533]                 {
[13:38:01.533]                   {
[13:38:01.533]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:01.533]                     NULL
[13:38:01.533]                   }
[13:38:01.533]                   options(future.plan = NULL)
[13:38:01.533]                   if (is.na(NA_character_)) 
[13:38:01.533]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.533]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:01.533]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:01.533]                     .init = FALSE)
[13:38:01.533]                 }
[13:38:01.533]             }
[13:38:01.533]         }
[13:38:01.533]     })
[13:38:01.533]     if (TRUE) {
[13:38:01.533]         base::sink(type = "output", split = FALSE)
[13:38:01.533]         if (TRUE) {
[13:38:01.533]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:01.533]         }
[13:38:01.533]         else {
[13:38:01.533]             ...future.result["stdout"] <- base::list(NULL)
[13:38:01.533]         }
[13:38:01.533]         base::close(...future.stdout)
[13:38:01.533]         ...future.stdout <- NULL
[13:38:01.533]     }
[13:38:01.533]     ...future.result$conditions <- ...future.conditions
[13:38:01.533]     ...future.result$finished <- base::Sys.time()
[13:38:01.533]     ...future.result
[13:38:01.533] }
[13:38:01.536] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:38:01.536] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[13:38:01.536] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[13:38:01.537] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:38:01.537] MultisessionFuture started
[13:38:01.537] - Launch lazy future ... done
[13:38:01.537] run() for ‘MultisessionFuture’ ... done
[13:38:01.548] run() for ‘Future’ ...
[13:38:01.548] - state: ‘created’
[13:38:01.548] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:01.562] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:01.562] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:01.562]   - Field: ‘node’
[13:38:01.563]   - Field: ‘label’
[13:38:01.563]   - Field: ‘local’
[13:38:01.563]   - Field: ‘owner’
[13:38:01.563]   - Field: ‘envir’
[13:38:01.563]   - Field: ‘workers’
[13:38:01.563]   - Field: ‘packages’
[13:38:01.563]   - Field: ‘gc’
[13:38:01.563]   - Field: ‘conditions’
[13:38:01.563]   - Field: ‘persistent’
[13:38:01.563]   - Field: ‘expr’
[13:38:01.563]   - Field: ‘uuid’
[13:38:01.564]   - Field: ‘seed’
[13:38:01.564]   - Field: ‘version’
[13:38:01.564]   - Field: ‘result’
[13:38:01.564]   - Field: ‘asynchronous’
[13:38:01.564]   - Field: ‘calls’
[13:38:01.564]   - Field: ‘globals’
[13:38:01.564]   - Field: ‘stdout’
[13:38:01.564]   - Field: ‘earlySignal’
[13:38:01.564]   - Field: ‘lazy’
[13:38:01.564]   - Field: ‘state’
[13:38:01.565] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:01.565] - Launch lazy future ...
[13:38:01.565] Packages needed by the future expression (n = 0): <none>
[13:38:01.565] Packages needed by future strategies (n = 0): <none>
[13:38:01.565] {
[13:38:01.565]     {
[13:38:01.565]         {
[13:38:01.565]             ...future.startTime <- base::Sys.time()
[13:38:01.565]             {
[13:38:01.565]                 {
[13:38:01.565]                   {
[13:38:01.565]                     {
[13:38:01.565]                       base::local({
[13:38:01.565]                         has_future <- base::requireNamespace("future", 
[13:38:01.565]                           quietly = TRUE)
[13:38:01.565]                         if (has_future) {
[13:38:01.565]                           ns <- base::getNamespace("future")
[13:38:01.565]                           version <- ns[[".package"]][["version"]]
[13:38:01.565]                           if (is.null(version)) 
[13:38:01.565]                             version <- utils::packageVersion("future")
[13:38:01.565]                         }
[13:38:01.565]                         else {
[13:38:01.565]                           version <- NULL
[13:38:01.565]                         }
[13:38:01.565]                         if (!has_future || version < "1.8.0") {
[13:38:01.565]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:01.565]                             "", base::R.version$version.string), 
[13:38:01.565]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:01.565]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:01.565]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:01.565]                               "release", "version")], collapse = " "), 
[13:38:01.565]                             hostname = base::Sys.info()[["nodename"]])
[13:38:01.565]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:01.565]                             info)
[13:38:01.565]                           info <- base::paste(info, collapse = "; ")
[13:38:01.565]                           if (!has_future) {
[13:38:01.565]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:01.565]                               info)
[13:38:01.565]                           }
[13:38:01.565]                           else {
[13:38:01.565]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:01.565]                               info, version)
[13:38:01.565]                           }
[13:38:01.565]                           base::stop(msg)
[13:38:01.565]                         }
[13:38:01.565]                       })
[13:38:01.565]                     }
[13:38:01.565]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:01.565]                     base::options(mc.cores = 1L)
[13:38:01.565]                   }
[13:38:01.565]                   ...future.strategy.old <- future::plan("list")
[13:38:01.565]                   options(future.plan = NULL)
[13:38:01.565]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.565]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:01.565]                 }
[13:38:01.565]                 ...future.workdir <- getwd()
[13:38:01.565]             }
[13:38:01.565]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:01.565]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:01.565]         }
[13:38:01.565]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:01.565]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:01.565]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:01.565]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:01.565]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:01.565]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:01.565]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:01.565]             base::names(...future.oldOptions))
[13:38:01.565]     }
[13:38:01.565]     if (FALSE) {
[13:38:01.565]     }
[13:38:01.565]     else {
[13:38:01.565]         if (TRUE) {
[13:38:01.565]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:01.565]                 open = "w")
[13:38:01.565]         }
[13:38:01.565]         else {
[13:38:01.565]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:01.565]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:01.565]         }
[13:38:01.565]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:01.565]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:01.565]             base::sink(type = "output", split = FALSE)
[13:38:01.565]             base::close(...future.stdout)
[13:38:01.565]         }, add = TRUE)
[13:38:01.565]     }
[13:38:01.565]     ...future.frame <- base::sys.nframe()
[13:38:01.565]     ...future.conditions <- base::list()
[13:38:01.565]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:01.565]     if (FALSE) {
[13:38:01.565]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:01.565]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:01.565]     }
[13:38:01.565]     ...future.result <- base::tryCatch({
[13:38:01.565]         base::withCallingHandlers({
[13:38:01.565]             ...future.value <- base::withVisible(base::local({
[13:38:01.565]                 ...future.makeSendCondition <- base::local({
[13:38:01.565]                   sendCondition <- NULL
[13:38:01.565]                   function(frame = 1L) {
[13:38:01.565]                     if (is.function(sendCondition)) 
[13:38:01.565]                       return(sendCondition)
[13:38:01.565]                     ns <- getNamespace("parallel")
[13:38:01.565]                     if (exists("sendData", mode = "function", 
[13:38:01.565]                       envir = ns)) {
[13:38:01.565]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:01.565]                         envir = ns)
[13:38:01.565]                       envir <- sys.frame(frame)
[13:38:01.565]                       master <- NULL
[13:38:01.565]                       while (!identical(envir, .GlobalEnv) && 
[13:38:01.565]                         !identical(envir, emptyenv())) {
[13:38:01.565]                         if (exists("master", mode = "list", envir = envir, 
[13:38:01.565]                           inherits = FALSE)) {
[13:38:01.565]                           master <- get("master", mode = "list", 
[13:38:01.565]                             envir = envir, inherits = FALSE)
[13:38:01.565]                           if (inherits(master, c("SOCKnode", 
[13:38:01.565]                             "SOCK0node"))) {
[13:38:01.565]                             sendCondition <<- function(cond) {
[13:38:01.565]                               data <- list(type = "VALUE", value = cond, 
[13:38:01.565]                                 success = TRUE)
[13:38:01.565]                               parallel_sendData(master, data)
[13:38:01.565]                             }
[13:38:01.565]                             return(sendCondition)
[13:38:01.565]                           }
[13:38:01.565]                         }
[13:38:01.565]                         frame <- frame + 1L
[13:38:01.565]                         envir <- sys.frame(frame)
[13:38:01.565]                       }
[13:38:01.565]                     }
[13:38:01.565]                     sendCondition <<- function(cond) NULL
[13:38:01.565]                   }
[13:38:01.565]                 })
[13:38:01.565]                 withCallingHandlers({
[13:38:01.565]                   {
[13:38:01.565]                     Sys.sleep(0.1)
[13:38:01.565]                     kk
[13:38:01.565]                   }
[13:38:01.565]                 }, immediateCondition = function(cond) {
[13:38:01.565]                   sendCondition <- ...future.makeSendCondition()
[13:38:01.565]                   sendCondition(cond)
[13:38:01.565]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.565]                   {
[13:38:01.565]                     inherits <- base::inherits
[13:38:01.565]                     invokeRestart <- base::invokeRestart
[13:38:01.565]                     is.null <- base::is.null
[13:38:01.565]                     muffled <- FALSE
[13:38:01.565]                     if (inherits(cond, "message")) {
[13:38:01.565]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:01.565]                       if (muffled) 
[13:38:01.565]                         invokeRestart("muffleMessage")
[13:38:01.565]                     }
[13:38:01.565]                     else if (inherits(cond, "warning")) {
[13:38:01.565]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:01.565]                       if (muffled) 
[13:38:01.565]                         invokeRestart("muffleWarning")
[13:38:01.565]                     }
[13:38:01.565]                     else if (inherits(cond, "condition")) {
[13:38:01.565]                       if (!is.null(pattern)) {
[13:38:01.565]                         computeRestarts <- base::computeRestarts
[13:38:01.565]                         grepl <- base::grepl
[13:38:01.565]                         restarts <- computeRestarts(cond)
[13:38:01.565]                         for (restart in restarts) {
[13:38:01.565]                           name <- restart$name
[13:38:01.565]                           if (is.null(name)) 
[13:38:01.565]                             next
[13:38:01.565]                           if (!grepl(pattern, name)) 
[13:38:01.565]                             next
[13:38:01.565]                           invokeRestart(restart)
[13:38:01.565]                           muffled <- TRUE
[13:38:01.565]                           break
[13:38:01.565]                         }
[13:38:01.565]                       }
[13:38:01.565]                     }
[13:38:01.565]                     invisible(muffled)
[13:38:01.565]                   }
[13:38:01.565]                   muffleCondition(cond)
[13:38:01.565]                 })
[13:38:01.565]             }))
[13:38:01.565]             future::FutureResult(value = ...future.value$value, 
[13:38:01.565]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.565]                   ...future.rng), globalenv = if (FALSE) 
[13:38:01.565]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:01.565]                     ...future.globalenv.names))
[13:38:01.565]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:01.565]         }, condition = base::local({
[13:38:01.565]             c <- base::c
[13:38:01.565]             inherits <- base::inherits
[13:38:01.565]             invokeRestart <- base::invokeRestart
[13:38:01.565]             length <- base::length
[13:38:01.565]             list <- base::list
[13:38:01.565]             seq.int <- base::seq.int
[13:38:01.565]             signalCondition <- base::signalCondition
[13:38:01.565]             sys.calls <- base::sys.calls
[13:38:01.565]             `[[` <- base::`[[`
[13:38:01.565]             `+` <- base::`+`
[13:38:01.565]             `<<-` <- base::`<<-`
[13:38:01.565]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:01.565]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:01.565]                   3L)]
[13:38:01.565]             }
[13:38:01.565]             function(cond) {
[13:38:01.565]                 is_error <- inherits(cond, "error")
[13:38:01.565]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:01.565]                   NULL)
[13:38:01.565]                 if (is_error) {
[13:38:01.565]                   sessionInformation <- function() {
[13:38:01.565]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:01.565]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:01.565]                       search = base::search(), system = base::Sys.info())
[13:38:01.565]                   }
[13:38:01.565]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.565]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:01.565]                     cond$call), session = sessionInformation(), 
[13:38:01.565]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:01.565]                   signalCondition(cond)
[13:38:01.565]                 }
[13:38:01.565]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:01.565]                 "immediateCondition"))) {
[13:38:01.565]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:01.565]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.565]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:01.565]                   if (TRUE && !signal) {
[13:38:01.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.565]                     {
[13:38:01.565]                       inherits <- base::inherits
[13:38:01.565]                       invokeRestart <- base::invokeRestart
[13:38:01.565]                       is.null <- base::is.null
[13:38:01.565]                       muffled <- FALSE
[13:38:01.565]                       if (inherits(cond, "message")) {
[13:38:01.565]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.565]                         if (muffled) 
[13:38:01.565]                           invokeRestart("muffleMessage")
[13:38:01.565]                       }
[13:38:01.565]                       else if (inherits(cond, "warning")) {
[13:38:01.565]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.565]                         if (muffled) 
[13:38:01.565]                           invokeRestart("muffleWarning")
[13:38:01.565]                       }
[13:38:01.565]                       else if (inherits(cond, "condition")) {
[13:38:01.565]                         if (!is.null(pattern)) {
[13:38:01.565]                           computeRestarts <- base::computeRestarts
[13:38:01.565]                           grepl <- base::grepl
[13:38:01.565]                           restarts <- computeRestarts(cond)
[13:38:01.565]                           for (restart in restarts) {
[13:38:01.565]                             name <- restart$name
[13:38:01.565]                             if (is.null(name)) 
[13:38:01.565]                               next
[13:38:01.565]                             if (!grepl(pattern, name)) 
[13:38:01.565]                               next
[13:38:01.565]                             invokeRestart(restart)
[13:38:01.565]                             muffled <- TRUE
[13:38:01.565]                             break
[13:38:01.565]                           }
[13:38:01.565]                         }
[13:38:01.565]                       }
[13:38:01.565]                       invisible(muffled)
[13:38:01.565]                     }
[13:38:01.565]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.565]                   }
[13:38:01.565]                 }
[13:38:01.565]                 else {
[13:38:01.565]                   if (TRUE) {
[13:38:01.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.565]                     {
[13:38:01.565]                       inherits <- base::inherits
[13:38:01.565]                       invokeRestart <- base::invokeRestart
[13:38:01.565]                       is.null <- base::is.null
[13:38:01.565]                       muffled <- FALSE
[13:38:01.565]                       if (inherits(cond, "message")) {
[13:38:01.565]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.565]                         if (muffled) 
[13:38:01.565]                           invokeRestart("muffleMessage")
[13:38:01.565]                       }
[13:38:01.565]                       else if (inherits(cond, "warning")) {
[13:38:01.565]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.565]                         if (muffled) 
[13:38:01.565]                           invokeRestart("muffleWarning")
[13:38:01.565]                       }
[13:38:01.565]                       else if (inherits(cond, "condition")) {
[13:38:01.565]                         if (!is.null(pattern)) {
[13:38:01.565]                           computeRestarts <- base::computeRestarts
[13:38:01.565]                           grepl <- base::grepl
[13:38:01.565]                           restarts <- computeRestarts(cond)
[13:38:01.565]                           for (restart in restarts) {
[13:38:01.565]                             name <- restart$name
[13:38:01.565]                             if (is.null(name)) 
[13:38:01.565]                               next
[13:38:01.565]                             if (!grepl(pattern, name)) 
[13:38:01.565]                               next
[13:38:01.565]                             invokeRestart(restart)
[13:38:01.565]                             muffled <- TRUE
[13:38:01.565]                             break
[13:38:01.565]                           }
[13:38:01.565]                         }
[13:38:01.565]                       }
[13:38:01.565]                       invisible(muffled)
[13:38:01.565]                     }
[13:38:01.565]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.565]                   }
[13:38:01.565]                 }
[13:38:01.565]             }
[13:38:01.565]         }))
[13:38:01.565]     }, error = function(ex) {
[13:38:01.565]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:01.565]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.565]                 ...future.rng), started = ...future.startTime, 
[13:38:01.565]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:01.565]             version = "1.8"), class = "FutureResult")
[13:38:01.565]     }, finally = {
[13:38:01.565]         if (!identical(...future.workdir, getwd())) 
[13:38:01.565]             setwd(...future.workdir)
[13:38:01.565]         {
[13:38:01.565]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:01.565]                 ...future.oldOptions$nwarnings <- NULL
[13:38:01.565]             }
[13:38:01.565]             base::options(...future.oldOptions)
[13:38:01.565]             if (.Platform$OS.type == "windows") {
[13:38:01.565]                 old_names <- names(...future.oldEnvVars)
[13:38:01.565]                 envs <- base::Sys.getenv()
[13:38:01.565]                 names <- names(envs)
[13:38:01.565]                 common <- intersect(names, old_names)
[13:38:01.565]                 added <- setdiff(names, old_names)
[13:38:01.565]                 removed <- setdiff(old_names, names)
[13:38:01.565]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:01.565]                   envs[common]]
[13:38:01.565]                 NAMES <- toupper(changed)
[13:38:01.565]                 args <- list()
[13:38:01.565]                 for (kk in seq_along(NAMES)) {
[13:38:01.565]                   name <- changed[[kk]]
[13:38:01.565]                   NAME <- NAMES[[kk]]
[13:38:01.565]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.565]                     next
[13:38:01.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.565]                 }
[13:38:01.565]                 NAMES <- toupper(added)
[13:38:01.565]                 for (kk in seq_along(NAMES)) {
[13:38:01.565]                   name <- added[[kk]]
[13:38:01.565]                   NAME <- NAMES[[kk]]
[13:38:01.565]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.565]                     next
[13:38:01.565]                   args[[name]] <- ""
[13:38:01.565]                 }
[13:38:01.565]                 NAMES <- toupper(removed)
[13:38:01.565]                 for (kk in seq_along(NAMES)) {
[13:38:01.565]                   name <- removed[[kk]]
[13:38:01.565]                   NAME <- NAMES[[kk]]
[13:38:01.565]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.565]                     next
[13:38:01.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.565]                 }
[13:38:01.565]                 if (length(args) > 0) 
[13:38:01.565]                   base::do.call(base::Sys.setenv, args = args)
[13:38:01.565]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:01.565]             }
[13:38:01.565]             else {
[13:38:01.565]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:01.565]             }
[13:38:01.565]             {
[13:38:01.565]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:01.565]                   0L) {
[13:38:01.565]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:01.565]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:01.565]                   base::options(opts)
[13:38:01.565]                 }
[13:38:01.565]                 {
[13:38:01.565]                   {
[13:38:01.565]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:01.565]                     NULL
[13:38:01.565]                   }
[13:38:01.565]                   options(future.plan = NULL)
[13:38:01.565]                   if (is.na(NA_character_)) 
[13:38:01.565]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.565]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:01.565]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:01.565]                     .init = FALSE)
[13:38:01.565]                 }
[13:38:01.565]             }
[13:38:01.565]         }
[13:38:01.565]     })
[13:38:01.565]     if (TRUE) {
[13:38:01.565]         base::sink(type = "output", split = FALSE)
[13:38:01.565]         if (TRUE) {
[13:38:01.565]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:01.565]         }
[13:38:01.565]         else {
[13:38:01.565]             ...future.result["stdout"] <- base::list(NULL)
[13:38:01.565]         }
[13:38:01.565]         base::close(...future.stdout)
[13:38:01.565]         ...future.stdout <- NULL
[13:38:01.565]     }
[13:38:01.565]     ...future.result$conditions <- ...future.conditions
[13:38:01.565]     ...future.result$finished <- base::Sys.time()
[13:38:01.565]     ...future.result
[13:38:01.565] }
[13:38:01.568] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[13:38:01.568] Exporting ‘kk’ (56 bytes) to cluster node #2 ...
[13:38:01.568] Exporting ‘kk’ (56 bytes) to cluster node #2 ... DONE
[13:38:01.568] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[13:38:01.569] MultisessionFuture started
[13:38:01.569] - Launch lazy future ... done
[13:38:01.569] run() for ‘MultisessionFuture’ ... done
[13:38:01.580] run() for ‘Future’ ...
[13:38:01.580] - state: ‘created’
[13:38:01.580] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:01.594] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:01.594] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:01.594]   - Field: ‘node’
[13:38:01.594]   - Field: ‘label’
[13:38:01.594]   - Field: ‘local’
[13:38:01.594]   - Field: ‘owner’
[13:38:01.595]   - Field: ‘envir’
[13:38:01.595]   - Field: ‘workers’
[13:38:01.595]   - Field: ‘packages’
[13:38:01.595]   - Field: ‘gc’
[13:38:01.595]   - Field: ‘conditions’
[13:38:01.595]   - Field: ‘persistent’
[13:38:01.595]   - Field: ‘expr’
[13:38:01.595]   - Field: ‘uuid’
[13:38:01.595]   - Field: ‘seed’
[13:38:01.595]   - Field: ‘version’
[13:38:01.595]   - Field: ‘result’
[13:38:01.596]   - Field: ‘asynchronous’
[13:38:01.596]   - Field: ‘calls’
[13:38:01.596]   - Field: ‘globals’
[13:38:01.596]   - Field: ‘stdout’
[13:38:01.596]   - Field: ‘earlySignal’
[13:38:01.596]   - Field: ‘lazy’
[13:38:01.596]   - Field: ‘state’
[13:38:01.596] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:01.596] - Launch lazy future ...
[13:38:01.597] Packages needed by the future expression (n = 0): <none>
[13:38:01.597] Packages needed by future strategies (n = 0): <none>
[13:38:01.597] {
[13:38:01.597]     {
[13:38:01.597]         {
[13:38:01.597]             ...future.startTime <- base::Sys.time()
[13:38:01.597]             {
[13:38:01.597]                 {
[13:38:01.597]                   {
[13:38:01.597]                     {
[13:38:01.597]                       base::local({
[13:38:01.597]                         has_future <- base::requireNamespace("future", 
[13:38:01.597]                           quietly = TRUE)
[13:38:01.597]                         if (has_future) {
[13:38:01.597]                           ns <- base::getNamespace("future")
[13:38:01.597]                           version <- ns[[".package"]][["version"]]
[13:38:01.597]                           if (is.null(version)) 
[13:38:01.597]                             version <- utils::packageVersion("future")
[13:38:01.597]                         }
[13:38:01.597]                         else {
[13:38:01.597]                           version <- NULL
[13:38:01.597]                         }
[13:38:01.597]                         if (!has_future || version < "1.8.0") {
[13:38:01.597]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:01.597]                             "", base::R.version$version.string), 
[13:38:01.597]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:01.597]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:01.597]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:01.597]                               "release", "version")], collapse = " "), 
[13:38:01.597]                             hostname = base::Sys.info()[["nodename"]])
[13:38:01.597]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:01.597]                             info)
[13:38:01.597]                           info <- base::paste(info, collapse = "; ")
[13:38:01.597]                           if (!has_future) {
[13:38:01.597]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:01.597]                               info)
[13:38:01.597]                           }
[13:38:01.597]                           else {
[13:38:01.597]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:01.597]                               info, version)
[13:38:01.597]                           }
[13:38:01.597]                           base::stop(msg)
[13:38:01.597]                         }
[13:38:01.597]                       })
[13:38:01.597]                     }
[13:38:01.597]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:01.597]                     base::options(mc.cores = 1L)
[13:38:01.597]                   }
[13:38:01.597]                   ...future.strategy.old <- future::plan("list")
[13:38:01.597]                   options(future.plan = NULL)
[13:38:01.597]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.597]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:01.597]                 }
[13:38:01.597]                 ...future.workdir <- getwd()
[13:38:01.597]             }
[13:38:01.597]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:01.597]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:01.597]         }
[13:38:01.597]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:01.597]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:01.597]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:01.597]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:01.597]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:01.597]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:01.597]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:01.597]             base::names(...future.oldOptions))
[13:38:01.597]     }
[13:38:01.597]     if (FALSE) {
[13:38:01.597]     }
[13:38:01.597]     else {
[13:38:01.597]         if (TRUE) {
[13:38:01.597]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:01.597]                 open = "w")
[13:38:01.597]         }
[13:38:01.597]         else {
[13:38:01.597]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:01.597]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:01.597]         }
[13:38:01.597]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:01.597]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:01.597]             base::sink(type = "output", split = FALSE)
[13:38:01.597]             base::close(...future.stdout)
[13:38:01.597]         }, add = TRUE)
[13:38:01.597]     }
[13:38:01.597]     ...future.frame <- base::sys.nframe()
[13:38:01.597]     ...future.conditions <- base::list()
[13:38:01.597]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:01.597]     if (FALSE) {
[13:38:01.597]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:01.597]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:01.597]     }
[13:38:01.597]     ...future.result <- base::tryCatch({
[13:38:01.597]         base::withCallingHandlers({
[13:38:01.597]             ...future.value <- base::withVisible(base::local({
[13:38:01.597]                 ...future.makeSendCondition <- base::local({
[13:38:01.597]                   sendCondition <- NULL
[13:38:01.597]                   function(frame = 1L) {
[13:38:01.597]                     if (is.function(sendCondition)) 
[13:38:01.597]                       return(sendCondition)
[13:38:01.597]                     ns <- getNamespace("parallel")
[13:38:01.597]                     if (exists("sendData", mode = "function", 
[13:38:01.597]                       envir = ns)) {
[13:38:01.597]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:01.597]                         envir = ns)
[13:38:01.597]                       envir <- sys.frame(frame)
[13:38:01.597]                       master <- NULL
[13:38:01.597]                       while (!identical(envir, .GlobalEnv) && 
[13:38:01.597]                         !identical(envir, emptyenv())) {
[13:38:01.597]                         if (exists("master", mode = "list", envir = envir, 
[13:38:01.597]                           inherits = FALSE)) {
[13:38:01.597]                           master <- get("master", mode = "list", 
[13:38:01.597]                             envir = envir, inherits = FALSE)
[13:38:01.597]                           if (inherits(master, c("SOCKnode", 
[13:38:01.597]                             "SOCK0node"))) {
[13:38:01.597]                             sendCondition <<- function(cond) {
[13:38:01.597]                               data <- list(type = "VALUE", value = cond, 
[13:38:01.597]                                 success = TRUE)
[13:38:01.597]                               parallel_sendData(master, data)
[13:38:01.597]                             }
[13:38:01.597]                             return(sendCondition)
[13:38:01.597]                           }
[13:38:01.597]                         }
[13:38:01.597]                         frame <- frame + 1L
[13:38:01.597]                         envir <- sys.frame(frame)
[13:38:01.597]                       }
[13:38:01.597]                     }
[13:38:01.597]                     sendCondition <<- function(cond) NULL
[13:38:01.597]                   }
[13:38:01.597]                 })
[13:38:01.597]                 withCallingHandlers({
[13:38:01.597]                   {
[13:38:01.597]                     Sys.sleep(0.1)
[13:38:01.597]                     kk
[13:38:01.597]                   }
[13:38:01.597]                 }, immediateCondition = function(cond) {
[13:38:01.597]                   sendCondition <- ...future.makeSendCondition()
[13:38:01.597]                   sendCondition(cond)
[13:38:01.597]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.597]                   {
[13:38:01.597]                     inherits <- base::inherits
[13:38:01.597]                     invokeRestart <- base::invokeRestart
[13:38:01.597]                     is.null <- base::is.null
[13:38:01.597]                     muffled <- FALSE
[13:38:01.597]                     if (inherits(cond, "message")) {
[13:38:01.597]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:01.597]                       if (muffled) 
[13:38:01.597]                         invokeRestart("muffleMessage")
[13:38:01.597]                     }
[13:38:01.597]                     else if (inherits(cond, "warning")) {
[13:38:01.597]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:01.597]                       if (muffled) 
[13:38:01.597]                         invokeRestart("muffleWarning")
[13:38:01.597]                     }
[13:38:01.597]                     else if (inherits(cond, "condition")) {
[13:38:01.597]                       if (!is.null(pattern)) {
[13:38:01.597]                         computeRestarts <- base::computeRestarts
[13:38:01.597]                         grepl <- base::grepl
[13:38:01.597]                         restarts <- computeRestarts(cond)
[13:38:01.597]                         for (restart in restarts) {
[13:38:01.597]                           name <- restart$name
[13:38:01.597]                           if (is.null(name)) 
[13:38:01.597]                             next
[13:38:01.597]                           if (!grepl(pattern, name)) 
[13:38:01.597]                             next
[13:38:01.597]                           invokeRestart(restart)
[13:38:01.597]                           muffled <- TRUE
[13:38:01.597]                           break
[13:38:01.597]                         }
[13:38:01.597]                       }
[13:38:01.597]                     }
[13:38:01.597]                     invisible(muffled)
[13:38:01.597]                   }
[13:38:01.597]                   muffleCondition(cond)
[13:38:01.597]                 })
[13:38:01.597]             }))
[13:38:01.597]             future::FutureResult(value = ...future.value$value, 
[13:38:01.597]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.597]                   ...future.rng), globalenv = if (FALSE) 
[13:38:01.597]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:01.597]                     ...future.globalenv.names))
[13:38:01.597]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:01.597]         }, condition = base::local({
[13:38:01.597]             c <- base::c
[13:38:01.597]             inherits <- base::inherits
[13:38:01.597]             invokeRestart <- base::invokeRestart
[13:38:01.597]             length <- base::length
[13:38:01.597]             list <- base::list
[13:38:01.597]             seq.int <- base::seq.int
[13:38:01.597]             signalCondition <- base::signalCondition
[13:38:01.597]             sys.calls <- base::sys.calls
[13:38:01.597]             `[[` <- base::`[[`
[13:38:01.597]             `+` <- base::`+`
[13:38:01.597]             `<<-` <- base::`<<-`
[13:38:01.597]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:01.597]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:01.597]                   3L)]
[13:38:01.597]             }
[13:38:01.597]             function(cond) {
[13:38:01.597]                 is_error <- inherits(cond, "error")
[13:38:01.597]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:01.597]                   NULL)
[13:38:01.597]                 if (is_error) {
[13:38:01.597]                   sessionInformation <- function() {
[13:38:01.597]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:01.597]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:01.597]                       search = base::search(), system = base::Sys.info())
[13:38:01.597]                   }
[13:38:01.597]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.597]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:01.597]                     cond$call), session = sessionInformation(), 
[13:38:01.597]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:01.597]                   signalCondition(cond)
[13:38:01.597]                 }
[13:38:01.597]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:01.597]                 "immediateCondition"))) {
[13:38:01.597]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:01.597]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.597]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:01.597]                   if (TRUE && !signal) {
[13:38:01.597]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.597]                     {
[13:38:01.597]                       inherits <- base::inherits
[13:38:01.597]                       invokeRestart <- base::invokeRestart
[13:38:01.597]                       is.null <- base::is.null
[13:38:01.597]                       muffled <- FALSE
[13:38:01.597]                       if (inherits(cond, "message")) {
[13:38:01.597]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.597]                         if (muffled) 
[13:38:01.597]                           invokeRestart("muffleMessage")
[13:38:01.597]                       }
[13:38:01.597]                       else if (inherits(cond, "warning")) {
[13:38:01.597]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.597]                         if (muffled) 
[13:38:01.597]                           invokeRestart("muffleWarning")
[13:38:01.597]                       }
[13:38:01.597]                       else if (inherits(cond, "condition")) {
[13:38:01.597]                         if (!is.null(pattern)) {
[13:38:01.597]                           computeRestarts <- base::computeRestarts
[13:38:01.597]                           grepl <- base::grepl
[13:38:01.597]                           restarts <- computeRestarts(cond)
[13:38:01.597]                           for (restart in restarts) {
[13:38:01.597]                             name <- restart$name
[13:38:01.597]                             if (is.null(name)) 
[13:38:01.597]                               next
[13:38:01.597]                             if (!grepl(pattern, name)) 
[13:38:01.597]                               next
[13:38:01.597]                             invokeRestart(restart)
[13:38:01.597]                             muffled <- TRUE
[13:38:01.597]                             break
[13:38:01.597]                           }
[13:38:01.597]                         }
[13:38:01.597]                       }
[13:38:01.597]                       invisible(muffled)
[13:38:01.597]                     }
[13:38:01.597]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.597]                   }
[13:38:01.597]                 }
[13:38:01.597]                 else {
[13:38:01.597]                   if (TRUE) {
[13:38:01.597]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.597]                     {
[13:38:01.597]                       inherits <- base::inherits
[13:38:01.597]                       invokeRestart <- base::invokeRestart
[13:38:01.597]                       is.null <- base::is.null
[13:38:01.597]                       muffled <- FALSE
[13:38:01.597]                       if (inherits(cond, "message")) {
[13:38:01.597]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.597]                         if (muffled) 
[13:38:01.597]                           invokeRestart("muffleMessage")
[13:38:01.597]                       }
[13:38:01.597]                       else if (inherits(cond, "warning")) {
[13:38:01.597]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.597]                         if (muffled) 
[13:38:01.597]                           invokeRestart("muffleWarning")
[13:38:01.597]                       }
[13:38:01.597]                       else if (inherits(cond, "condition")) {
[13:38:01.597]                         if (!is.null(pattern)) {
[13:38:01.597]                           computeRestarts <- base::computeRestarts
[13:38:01.597]                           grepl <- base::grepl
[13:38:01.597]                           restarts <- computeRestarts(cond)
[13:38:01.597]                           for (restart in restarts) {
[13:38:01.597]                             name <- restart$name
[13:38:01.597]                             if (is.null(name)) 
[13:38:01.597]                               next
[13:38:01.597]                             if (!grepl(pattern, name)) 
[13:38:01.597]                               next
[13:38:01.597]                             invokeRestart(restart)
[13:38:01.597]                             muffled <- TRUE
[13:38:01.597]                             break
[13:38:01.597]                           }
[13:38:01.597]                         }
[13:38:01.597]                       }
[13:38:01.597]                       invisible(muffled)
[13:38:01.597]                     }
[13:38:01.597]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.597]                   }
[13:38:01.597]                 }
[13:38:01.597]             }
[13:38:01.597]         }))
[13:38:01.597]     }, error = function(ex) {
[13:38:01.597]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:01.597]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.597]                 ...future.rng), started = ...future.startTime, 
[13:38:01.597]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:01.597]             version = "1.8"), class = "FutureResult")
[13:38:01.597]     }, finally = {
[13:38:01.597]         if (!identical(...future.workdir, getwd())) 
[13:38:01.597]             setwd(...future.workdir)
[13:38:01.597]         {
[13:38:01.597]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:01.597]                 ...future.oldOptions$nwarnings <- NULL
[13:38:01.597]             }
[13:38:01.597]             base::options(...future.oldOptions)
[13:38:01.597]             if (.Platform$OS.type == "windows") {
[13:38:01.597]                 old_names <- names(...future.oldEnvVars)
[13:38:01.597]                 envs <- base::Sys.getenv()
[13:38:01.597]                 names <- names(envs)
[13:38:01.597]                 common <- intersect(names, old_names)
[13:38:01.597]                 added <- setdiff(names, old_names)
[13:38:01.597]                 removed <- setdiff(old_names, names)
[13:38:01.597]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:01.597]                   envs[common]]
[13:38:01.597]                 NAMES <- toupper(changed)
[13:38:01.597]                 args <- list()
[13:38:01.597]                 for (kk in seq_along(NAMES)) {
[13:38:01.597]                   name <- changed[[kk]]
[13:38:01.597]                   NAME <- NAMES[[kk]]
[13:38:01.597]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.597]                     next
[13:38:01.597]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.597]                 }
[13:38:01.597]                 NAMES <- toupper(added)
[13:38:01.597]                 for (kk in seq_along(NAMES)) {
[13:38:01.597]                   name <- added[[kk]]
[13:38:01.597]                   NAME <- NAMES[[kk]]
[13:38:01.597]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.597]                     next
[13:38:01.597]                   args[[name]] <- ""
[13:38:01.597]                 }
[13:38:01.597]                 NAMES <- toupper(removed)
[13:38:01.597]                 for (kk in seq_along(NAMES)) {
[13:38:01.597]                   name <- removed[[kk]]
[13:38:01.597]                   NAME <- NAMES[[kk]]
[13:38:01.597]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.597]                     next
[13:38:01.597]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.597]                 }
[13:38:01.597]                 if (length(args) > 0) 
[13:38:01.597]                   base::do.call(base::Sys.setenv, args = args)
[13:38:01.597]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:01.597]             }
[13:38:01.597]             else {
[13:38:01.597]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:01.597]             }
[13:38:01.597]             {
[13:38:01.597]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:01.597]                   0L) {
[13:38:01.597]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:01.597]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:01.597]                   base::options(opts)
[13:38:01.597]                 }
[13:38:01.597]                 {
[13:38:01.597]                   {
[13:38:01.597]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:01.597]                     NULL
[13:38:01.597]                   }
[13:38:01.597]                   options(future.plan = NULL)
[13:38:01.597]                   if (is.na(NA_character_)) 
[13:38:01.597]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.597]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:01.597]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:01.597]                     .init = FALSE)
[13:38:01.597]                 }
[13:38:01.597]             }
[13:38:01.597]         }
[13:38:01.597]     })
[13:38:01.597]     if (TRUE) {
[13:38:01.597]         base::sink(type = "output", split = FALSE)
[13:38:01.597]         if (TRUE) {
[13:38:01.597]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:01.597]         }
[13:38:01.597]         else {
[13:38:01.597]             ...future.result["stdout"] <- base::list(NULL)
[13:38:01.597]         }
[13:38:01.597]         base::close(...future.stdout)
[13:38:01.597]         ...future.stdout <- NULL
[13:38:01.597]     }
[13:38:01.597]     ...future.result$conditions <- ...future.conditions
[13:38:01.597]     ...future.result$finished <- base::Sys.time()
[13:38:01.597]     ...future.result
[13:38:01.597] }
[13:38:01.599] Poll #1 (0): usedNodes() = 2, workers = 2
[13:38:01.631] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[13:38:01.641] receiveMessageFromWorker() for ClusterFuture ...
[13:38:01.642] - Validating connection of MultisessionFuture
[13:38:01.642] - received message: FutureResult
[13:38:01.642] - Received FutureResult
[13:38:01.642] - Erased future from FutureRegistry
[13:38:01.642] result() for ClusterFuture ...
[13:38:01.642] - result already collected: FutureResult
[13:38:01.642] result() for ClusterFuture ... done
[13:38:01.642] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:01.643] result() for ClusterFuture ...
[13:38:01.643] - result already collected: FutureResult
[13:38:01.643] result() for ClusterFuture ... done
[13:38:01.643] result() for ClusterFuture ...
[13:38:01.643] - result already collected: FutureResult
[13:38:01.643] result() for ClusterFuture ... done
[13:38:01.644] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:38:01.644] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[13:38:01.644] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[13:38:01.644] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:38:01.645] MultisessionFuture started
[13:38:01.645] - Launch lazy future ... done
[13:38:01.645] run() for ‘MultisessionFuture’ ... done
[13:38:01.665] Future #1
[13:38:01.666]  length: 2 (resolved future 1)
[13:38:01.671] receiveMessageFromWorker() for ClusterFuture ...
[13:38:01.671] - Validating connection of MultisessionFuture
[13:38:01.671] - received message: FutureResult
[13:38:01.671] - Received FutureResult
[13:38:01.672] - Erased future from FutureRegistry
[13:38:01.672] result() for ClusterFuture ...
[13:38:01.672] - result already collected: FutureResult
[13:38:01.672] result() for ClusterFuture ... done
[13:38:01.672] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:01.672] Future #2
[13:38:01.672]  length: 1 (resolved future 2)
[13:38:01.755] receiveMessageFromWorker() for ClusterFuture ...
[13:38:01.755] - Validating connection of MultisessionFuture
[13:38:01.755] - received message: FutureResult
[13:38:01.755] - Received FutureResult
[13:38:01.755] - Erased future from FutureRegistry
[13:38:01.756] result() for ClusterFuture ...
[13:38:01.756] - result already collected: FutureResult
[13:38:01.756] result() for ClusterFuture ... done
[13:38:01.756] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:01.756] Future #3
[13:38:01.756]  length: 0 (resolved future 3)
[13:38:01.756] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[13:38:01.757] resolve() on environment ...
[13:38:01.757]  recursive: 0
[13:38:01.757]  elements: [2] ‘a’, ‘b’
[13:38:01.757]  length: 1 (resolved future 1)
[13:38:01.757]  length: 0 (resolved future 2)
[13:38:01.758] resolve() on environment ... DONE
[13:38:01.758] getGlobalsAndPackages() ...
[13:38:01.758] Searching for globals...
[13:38:01.758] 
[13:38:01.758] Searching for globals ... DONE
[13:38:01.759] - globals: [0] <none>
[13:38:01.759] getGlobalsAndPackages() ... DONE
[13:38:01.759] run() for ‘Future’ ...
[13:38:01.759] - state: ‘created’
[13:38:01.759] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:01.773] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:01.773] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:01.773]   - Field: ‘node’
[13:38:01.773]   - Field: ‘label’
[13:38:01.773]   - Field: ‘local’
[13:38:01.773]   - Field: ‘owner’
[13:38:01.773]   - Field: ‘envir’
[13:38:01.773]   - Field: ‘workers’
[13:38:01.774]   - Field: ‘packages’
[13:38:01.774]   - Field: ‘gc’
[13:38:01.774]   - Field: ‘conditions’
[13:38:01.774]   - Field: ‘persistent’
[13:38:01.774]   - Field: ‘expr’
[13:38:01.774]   - Field: ‘uuid’
[13:38:01.774]   - Field: ‘seed’
[13:38:01.774]   - Field: ‘version’
[13:38:01.774]   - Field: ‘result’
[13:38:01.774]   - Field: ‘asynchronous’
[13:38:01.774]   - Field: ‘calls’
[13:38:01.775]   - Field: ‘globals’
[13:38:01.775]   - Field: ‘stdout’
[13:38:01.775]   - Field: ‘earlySignal’
[13:38:01.775]   - Field: ‘lazy’
[13:38:01.775]   - Field: ‘state’
[13:38:01.775] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:01.775] - Launch lazy future ...
[13:38:01.775] Packages needed by the future expression (n = 0): <none>
[13:38:01.775] Packages needed by future strategies (n = 0): <none>
[13:38:01.776] {
[13:38:01.776]     {
[13:38:01.776]         {
[13:38:01.776]             ...future.startTime <- base::Sys.time()
[13:38:01.776]             {
[13:38:01.776]                 {
[13:38:01.776]                   {
[13:38:01.776]                     {
[13:38:01.776]                       base::local({
[13:38:01.776]                         has_future <- base::requireNamespace("future", 
[13:38:01.776]                           quietly = TRUE)
[13:38:01.776]                         if (has_future) {
[13:38:01.776]                           ns <- base::getNamespace("future")
[13:38:01.776]                           version <- ns[[".package"]][["version"]]
[13:38:01.776]                           if (is.null(version)) 
[13:38:01.776]                             version <- utils::packageVersion("future")
[13:38:01.776]                         }
[13:38:01.776]                         else {
[13:38:01.776]                           version <- NULL
[13:38:01.776]                         }
[13:38:01.776]                         if (!has_future || version < "1.8.0") {
[13:38:01.776]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:01.776]                             "", base::R.version$version.string), 
[13:38:01.776]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:01.776]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:01.776]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:01.776]                               "release", "version")], collapse = " "), 
[13:38:01.776]                             hostname = base::Sys.info()[["nodename"]])
[13:38:01.776]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:01.776]                             info)
[13:38:01.776]                           info <- base::paste(info, collapse = "; ")
[13:38:01.776]                           if (!has_future) {
[13:38:01.776]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:01.776]                               info)
[13:38:01.776]                           }
[13:38:01.776]                           else {
[13:38:01.776]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:01.776]                               info, version)
[13:38:01.776]                           }
[13:38:01.776]                           base::stop(msg)
[13:38:01.776]                         }
[13:38:01.776]                       })
[13:38:01.776]                     }
[13:38:01.776]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:01.776]                     base::options(mc.cores = 1L)
[13:38:01.776]                   }
[13:38:01.776]                   ...future.strategy.old <- future::plan("list")
[13:38:01.776]                   options(future.plan = NULL)
[13:38:01.776]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.776]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:01.776]                 }
[13:38:01.776]                 ...future.workdir <- getwd()
[13:38:01.776]             }
[13:38:01.776]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:01.776]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:01.776]         }
[13:38:01.776]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:01.776]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:01.776]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:01.776]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:01.776]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:01.776]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:01.776]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:01.776]             base::names(...future.oldOptions))
[13:38:01.776]     }
[13:38:01.776]     if (FALSE) {
[13:38:01.776]     }
[13:38:01.776]     else {
[13:38:01.776]         if (TRUE) {
[13:38:01.776]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:01.776]                 open = "w")
[13:38:01.776]         }
[13:38:01.776]         else {
[13:38:01.776]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:01.776]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:01.776]         }
[13:38:01.776]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:01.776]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:01.776]             base::sink(type = "output", split = FALSE)
[13:38:01.776]             base::close(...future.stdout)
[13:38:01.776]         }, add = TRUE)
[13:38:01.776]     }
[13:38:01.776]     ...future.frame <- base::sys.nframe()
[13:38:01.776]     ...future.conditions <- base::list()
[13:38:01.776]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:01.776]     if (FALSE) {
[13:38:01.776]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:01.776]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:01.776]     }
[13:38:01.776]     ...future.result <- base::tryCatch({
[13:38:01.776]         base::withCallingHandlers({
[13:38:01.776]             ...future.value <- base::withVisible(base::local({
[13:38:01.776]                 ...future.makeSendCondition <- base::local({
[13:38:01.776]                   sendCondition <- NULL
[13:38:01.776]                   function(frame = 1L) {
[13:38:01.776]                     if (is.function(sendCondition)) 
[13:38:01.776]                       return(sendCondition)
[13:38:01.776]                     ns <- getNamespace("parallel")
[13:38:01.776]                     if (exists("sendData", mode = "function", 
[13:38:01.776]                       envir = ns)) {
[13:38:01.776]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:01.776]                         envir = ns)
[13:38:01.776]                       envir <- sys.frame(frame)
[13:38:01.776]                       master <- NULL
[13:38:01.776]                       while (!identical(envir, .GlobalEnv) && 
[13:38:01.776]                         !identical(envir, emptyenv())) {
[13:38:01.776]                         if (exists("master", mode = "list", envir = envir, 
[13:38:01.776]                           inherits = FALSE)) {
[13:38:01.776]                           master <- get("master", mode = "list", 
[13:38:01.776]                             envir = envir, inherits = FALSE)
[13:38:01.776]                           if (inherits(master, c("SOCKnode", 
[13:38:01.776]                             "SOCK0node"))) {
[13:38:01.776]                             sendCondition <<- function(cond) {
[13:38:01.776]                               data <- list(type = "VALUE", value = cond, 
[13:38:01.776]                                 success = TRUE)
[13:38:01.776]                               parallel_sendData(master, data)
[13:38:01.776]                             }
[13:38:01.776]                             return(sendCondition)
[13:38:01.776]                           }
[13:38:01.776]                         }
[13:38:01.776]                         frame <- frame + 1L
[13:38:01.776]                         envir <- sys.frame(frame)
[13:38:01.776]                       }
[13:38:01.776]                     }
[13:38:01.776]                     sendCondition <<- function(cond) NULL
[13:38:01.776]                   }
[13:38:01.776]                 })
[13:38:01.776]                 withCallingHandlers({
[13:38:01.776]                   1
[13:38:01.776]                 }, immediateCondition = function(cond) {
[13:38:01.776]                   sendCondition <- ...future.makeSendCondition()
[13:38:01.776]                   sendCondition(cond)
[13:38:01.776]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.776]                   {
[13:38:01.776]                     inherits <- base::inherits
[13:38:01.776]                     invokeRestart <- base::invokeRestart
[13:38:01.776]                     is.null <- base::is.null
[13:38:01.776]                     muffled <- FALSE
[13:38:01.776]                     if (inherits(cond, "message")) {
[13:38:01.776]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:01.776]                       if (muffled) 
[13:38:01.776]                         invokeRestart("muffleMessage")
[13:38:01.776]                     }
[13:38:01.776]                     else if (inherits(cond, "warning")) {
[13:38:01.776]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:01.776]                       if (muffled) 
[13:38:01.776]                         invokeRestart("muffleWarning")
[13:38:01.776]                     }
[13:38:01.776]                     else if (inherits(cond, "condition")) {
[13:38:01.776]                       if (!is.null(pattern)) {
[13:38:01.776]                         computeRestarts <- base::computeRestarts
[13:38:01.776]                         grepl <- base::grepl
[13:38:01.776]                         restarts <- computeRestarts(cond)
[13:38:01.776]                         for (restart in restarts) {
[13:38:01.776]                           name <- restart$name
[13:38:01.776]                           if (is.null(name)) 
[13:38:01.776]                             next
[13:38:01.776]                           if (!grepl(pattern, name)) 
[13:38:01.776]                             next
[13:38:01.776]                           invokeRestart(restart)
[13:38:01.776]                           muffled <- TRUE
[13:38:01.776]                           break
[13:38:01.776]                         }
[13:38:01.776]                       }
[13:38:01.776]                     }
[13:38:01.776]                     invisible(muffled)
[13:38:01.776]                   }
[13:38:01.776]                   muffleCondition(cond)
[13:38:01.776]                 })
[13:38:01.776]             }))
[13:38:01.776]             future::FutureResult(value = ...future.value$value, 
[13:38:01.776]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.776]                   ...future.rng), globalenv = if (FALSE) 
[13:38:01.776]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:01.776]                     ...future.globalenv.names))
[13:38:01.776]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:01.776]         }, condition = base::local({
[13:38:01.776]             c <- base::c
[13:38:01.776]             inherits <- base::inherits
[13:38:01.776]             invokeRestart <- base::invokeRestart
[13:38:01.776]             length <- base::length
[13:38:01.776]             list <- base::list
[13:38:01.776]             seq.int <- base::seq.int
[13:38:01.776]             signalCondition <- base::signalCondition
[13:38:01.776]             sys.calls <- base::sys.calls
[13:38:01.776]             `[[` <- base::`[[`
[13:38:01.776]             `+` <- base::`+`
[13:38:01.776]             `<<-` <- base::`<<-`
[13:38:01.776]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:01.776]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:01.776]                   3L)]
[13:38:01.776]             }
[13:38:01.776]             function(cond) {
[13:38:01.776]                 is_error <- inherits(cond, "error")
[13:38:01.776]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:01.776]                   NULL)
[13:38:01.776]                 if (is_error) {
[13:38:01.776]                   sessionInformation <- function() {
[13:38:01.776]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:01.776]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:01.776]                       search = base::search(), system = base::Sys.info())
[13:38:01.776]                   }
[13:38:01.776]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.776]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:01.776]                     cond$call), session = sessionInformation(), 
[13:38:01.776]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:01.776]                   signalCondition(cond)
[13:38:01.776]                 }
[13:38:01.776]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:01.776]                 "immediateCondition"))) {
[13:38:01.776]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:01.776]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.776]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:01.776]                   if (TRUE && !signal) {
[13:38:01.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.776]                     {
[13:38:01.776]                       inherits <- base::inherits
[13:38:01.776]                       invokeRestart <- base::invokeRestart
[13:38:01.776]                       is.null <- base::is.null
[13:38:01.776]                       muffled <- FALSE
[13:38:01.776]                       if (inherits(cond, "message")) {
[13:38:01.776]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.776]                         if (muffled) 
[13:38:01.776]                           invokeRestart("muffleMessage")
[13:38:01.776]                       }
[13:38:01.776]                       else if (inherits(cond, "warning")) {
[13:38:01.776]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.776]                         if (muffled) 
[13:38:01.776]                           invokeRestart("muffleWarning")
[13:38:01.776]                       }
[13:38:01.776]                       else if (inherits(cond, "condition")) {
[13:38:01.776]                         if (!is.null(pattern)) {
[13:38:01.776]                           computeRestarts <- base::computeRestarts
[13:38:01.776]                           grepl <- base::grepl
[13:38:01.776]                           restarts <- computeRestarts(cond)
[13:38:01.776]                           for (restart in restarts) {
[13:38:01.776]                             name <- restart$name
[13:38:01.776]                             if (is.null(name)) 
[13:38:01.776]                               next
[13:38:01.776]                             if (!grepl(pattern, name)) 
[13:38:01.776]                               next
[13:38:01.776]                             invokeRestart(restart)
[13:38:01.776]                             muffled <- TRUE
[13:38:01.776]                             break
[13:38:01.776]                           }
[13:38:01.776]                         }
[13:38:01.776]                       }
[13:38:01.776]                       invisible(muffled)
[13:38:01.776]                     }
[13:38:01.776]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.776]                   }
[13:38:01.776]                 }
[13:38:01.776]                 else {
[13:38:01.776]                   if (TRUE) {
[13:38:01.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.776]                     {
[13:38:01.776]                       inherits <- base::inherits
[13:38:01.776]                       invokeRestart <- base::invokeRestart
[13:38:01.776]                       is.null <- base::is.null
[13:38:01.776]                       muffled <- FALSE
[13:38:01.776]                       if (inherits(cond, "message")) {
[13:38:01.776]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.776]                         if (muffled) 
[13:38:01.776]                           invokeRestart("muffleMessage")
[13:38:01.776]                       }
[13:38:01.776]                       else if (inherits(cond, "warning")) {
[13:38:01.776]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.776]                         if (muffled) 
[13:38:01.776]                           invokeRestart("muffleWarning")
[13:38:01.776]                       }
[13:38:01.776]                       else if (inherits(cond, "condition")) {
[13:38:01.776]                         if (!is.null(pattern)) {
[13:38:01.776]                           computeRestarts <- base::computeRestarts
[13:38:01.776]                           grepl <- base::grepl
[13:38:01.776]                           restarts <- computeRestarts(cond)
[13:38:01.776]                           for (restart in restarts) {
[13:38:01.776]                             name <- restart$name
[13:38:01.776]                             if (is.null(name)) 
[13:38:01.776]                               next
[13:38:01.776]                             if (!grepl(pattern, name)) 
[13:38:01.776]                               next
[13:38:01.776]                             invokeRestart(restart)
[13:38:01.776]                             muffled <- TRUE
[13:38:01.776]                             break
[13:38:01.776]                           }
[13:38:01.776]                         }
[13:38:01.776]                       }
[13:38:01.776]                       invisible(muffled)
[13:38:01.776]                     }
[13:38:01.776]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.776]                   }
[13:38:01.776]                 }
[13:38:01.776]             }
[13:38:01.776]         }))
[13:38:01.776]     }, error = function(ex) {
[13:38:01.776]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:01.776]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.776]                 ...future.rng), started = ...future.startTime, 
[13:38:01.776]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:01.776]             version = "1.8"), class = "FutureResult")
[13:38:01.776]     }, finally = {
[13:38:01.776]         if (!identical(...future.workdir, getwd())) 
[13:38:01.776]             setwd(...future.workdir)
[13:38:01.776]         {
[13:38:01.776]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:01.776]                 ...future.oldOptions$nwarnings <- NULL
[13:38:01.776]             }
[13:38:01.776]             base::options(...future.oldOptions)
[13:38:01.776]             if (.Platform$OS.type == "windows") {
[13:38:01.776]                 old_names <- names(...future.oldEnvVars)
[13:38:01.776]                 envs <- base::Sys.getenv()
[13:38:01.776]                 names <- names(envs)
[13:38:01.776]                 common <- intersect(names, old_names)
[13:38:01.776]                 added <- setdiff(names, old_names)
[13:38:01.776]                 removed <- setdiff(old_names, names)
[13:38:01.776]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:01.776]                   envs[common]]
[13:38:01.776]                 NAMES <- toupper(changed)
[13:38:01.776]                 args <- list()
[13:38:01.776]                 for (kk in seq_along(NAMES)) {
[13:38:01.776]                   name <- changed[[kk]]
[13:38:01.776]                   NAME <- NAMES[[kk]]
[13:38:01.776]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.776]                     next
[13:38:01.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.776]                 }
[13:38:01.776]                 NAMES <- toupper(added)
[13:38:01.776]                 for (kk in seq_along(NAMES)) {
[13:38:01.776]                   name <- added[[kk]]
[13:38:01.776]                   NAME <- NAMES[[kk]]
[13:38:01.776]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.776]                     next
[13:38:01.776]                   args[[name]] <- ""
[13:38:01.776]                 }
[13:38:01.776]                 NAMES <- toupper(removed)
[13:38:01.776]                 for (kk in seq_along(NAMES)) {
[13:38:01.776]                   name <- removed[[kk]]
[13:38:01.776]                   NAME <- NAMES[[kk]]
[13:38:01.776]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.776]                     next
[13:38:01.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.776]                 }
[13:38:01.776]                 if (length(args) > 0) 
[13:38:01.776]                   base::do.call(base::Sys.setenv, args = args)
[13:38:01.776]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:01.776]             }
[13:38:01.776]             else {
[13:38:01.776]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:01.776]             }
[13:38:01.776]             {
[13:38:01.776]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:01.776]                   0L) {
[13:38:01.776]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:01.776]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:01.776]                   base::options(opts)
[13:38:01.776]                 }
[13:38:01.776]                 {
[13:38:01.776]                   {
[13:38:01.776]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:01.776]                     NULL
[13:38:01.776]                   }
[13:38:01.776]                   options(future.plan = NULL)
[13:38:01.776]                   if (is.na(NA_character_)) 
[13:38:01.776]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.776]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:01.776]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:01.776]                     .init = FALSE)
[13:38:01.776]                 }
[13:38:01.776]             }
[13:38:01.776]         }
[13:38:01.776]     })
[13:38:01.776]     if (TRUE) {
[13:38:01.776]         base::sink(type = "output", split = FALSE)
[13:38:01.776]         if (TRUE) {
[13:38:01.776]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:01.776]         }
[13:38:01.776]         else {
[13:38:01.776]             ...future.result["stdout"] <- base::list(NULL)
[13:38:01.776]         }
[13:38:01.776]         base::close(...future.stdout)
[13:38:01.776]         ...future.stdout <- NULL
[13:38:01.776]     }
[13:38:01.776]     ...future.result$conditions <- ...future.conditions
[13:38:01.776]     ...future.result$finished <- base::Sys.time()
[13:38:01.776]     ...future.result
[13:38:01.776] }
[13:38:01.779] MultisessionFuture started
[13:38:01.779] - Launch lazy future ... done
[13:38:01.779] run() for ‘MultisessionFuture’ ... done
[13:38:01.779] getGlobalsAndPackages() ...
[13:38:01.779] Searching for globals...
[13:38:01.780] 
[13:38:01.780] Searching for globals ... DONE
[13:38:01.780] - globals: [0] <none>
[13:38:01.780] getGlobalsAndPackages() ... DONE
[13:38:01.780] run() for ‘Future’ ...
[13:38:01.780] - state: ‘created’
[13:38:01.781] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:01.794] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:01.794] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:01.794]   - Field: ‘node’
[13:38:01.794]   - Field: ‘label’
[13:38:01.794]   - Field: ‘local’
[13:38:01.794]   - Field: ‘owner’
[13:38:01.794]   - Field: ‘envir’
[13:38:01.795]   - Field: ‘workers’
[13:38:01.795]   - Field: ‘packages’
[13:38:01.795]   - Field: ‘gc’
[13:38:01.795]   - Field: ‘conditions’
[13:38:01.795]   - Field: ‘persistent’
[13:38:01.795]   - Field: ‘expr’
[13:38:01.795]   - Field: ‘uuid’
[13:38:01.795]   - Field: ‘seed’
[13:38:01.795]   - Field: ‘version’
[13:38:01.795]   - Field: ‘result’
[13:38:01.795]   - Field: ‘asynchronous’
[13:38:01.796]   - Field: ‘calls’
[13:38:01.796]   - Field: ‘globals’
[13:38:01.796]   - Field: ‘stdout’
[13:38:01.796]   - Field: ‘earlySignal’
[13:38:01.796]   - Field: ‘lazy’
[13:38:01.796]   - Field: ‘state’
[13:38:01.796] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:01.796] - Launch lazy future ...
[13:38:01.796] Packages needed by the future expression (n = 0): <none>
[13:38:01.797] Packages needed by future strategies (n = 0): <none>
[13:38:01.797] {
[13:38:01.797]     {
[13:38:01.797]         {
[13:38:01.797]             ...future.startTime <- base::Sys.time()
[13:38:01.797]             {
[13:38:01.797]                 {
[13:38:01.797]                   {
[13:38:01.797]                     {
[13:38:01.797]                       base::local({
[13:38:01.797]                         has_future <- base::requireNamespace("future", 
[13:38:01.797]                           quietly = TRUE)
[13:38:01.797]                         if (has_future) {
[13:38:01.797]                           ns <- base::getNamespace("future")
[13:38:01.797]                           version <- ns[[".package"]][["version"]]
[13:38:01.797]                           if (is.null(version)) 
[13:38:01.797]                             version <- utils::packageVersion("future")
[13:38:01.797]                         }
[13:38:01.797]                         else {
[13:38:01.797]                           version <- NULL
[13:38:01.797]                         }
[13:38:01.797]                         if (!has_future || version < "1.8.0") {
[13:38:01.797]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:01.797]                             "", base::R.version$version.string), 
[13:38:01.797]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:01.797]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:01.797]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:01.797]                               "release", "version")], collapse = " "), 
[13:38:01.797]                             hostname = base::Sys.info()[["nodename"]])
[13:38:01.797]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:01.797]                             info)
[13:38:01.797]                           info <- base::paste(info, collapse = "; ")
[13:38:01.797]                           if (!has_future) {
[13:38:01.797]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:01.797]                               info)
[13:38:01.797]                           }
[13:38:01.797]                           else {
[13:38:01.797]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:01.797]                               info, version)
[13:38:01.797]                           }
[13:38:01.797]                           base::stop(msg)
[13:38:01.797]                         }
[13:38:01.797]                       })
[13:38:01.797]                     }
[13:38:01.797]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:01.797]                     base::options(mc.cores = 1L)
[13:38:01.797]                   }
[13:38:01.797]                   ...future.strategy.old <- future::plan("list")
[13:38:01.797]                   options(future.plan = NULL)
[13:38:01.797]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.797]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:01.797]                 }
[13:38:01.797]                 ...future.workdir <- getwd()
[13:38:01.797]             }
[13:38:01.797]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:01.797]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:01.797]         }
[13:38:01.797]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:01.797]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:01.797]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:01.797]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:01.797]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:01.797]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:01.797]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:01.797]             base::names(...future.oldOptions))
[13:38:01.797]     }
[13:38:01.797]     if (FALSE) {
[13:38:01.797]     }
[13:38:01.797]     else {
[13:38:01.797]         if (TRUE) {
[13:38:01.797]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:01.797]                 open = "w")
[13:38:01.797]         }
[13:38:01.797]         else {
[13:38:01.797]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:01.797]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:01.797]         }
[13:38:01.797]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:01.797]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:01.797]             base::sink(type = "output", split = FALSE)
[13:38:01.797]             base::close(...future.stdout)
[13:38:01.797]         }, add = TRUE)
[13:38:01.797]     }
[13:38:01.797]     ...future.frame <- base::sys.nframe()
[13:38:01.797]     ...future.conditions <- base::list()
[13:38:01.797]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:01.797]     if (FALSE) {
[13:38:01.797]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:01.797]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:01.797]     }
[13:38:01.797]     ...future.result <- base::tryCatch({
[13:38:01.797]         base::withCallingHandlers({
[13:38:01.797]             ...future.value <- base::withVisible(base::local({
[13:38:01.797]                 ...future.makeSendCondition <- base::local({
[13:38:01.797]                   sendCondition <- NULL
[13:38:01.797]                   function(frame = 1L) {
[13:38:01.797]                     if (is.function(sendCondition)) 
[13:38:01.797]                       return(sendCondition)
[13:38:01.797]                     ns <- getNamespace("parallel")
[13:38:01.797]                     if (exists("sendData", mode = "function", 
[13:38:01.797]                       envir = ns)) {
[13:38:01.797]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:01.797]                         envir = ns)
[13:38:01.797]                       envir <- sys.frame(frame)
[13:38:01.797]                       master <- NULL
[13:38:01.797]                       while (!identical(envir, .GlobalEnv) && 
[13:38:01.797]                         !identical(envir, emptyenv())) {
[13:38:01.797]                         if (exists("master", mode = "list", envir = envir, 
[13:38:01.797]                           inherits = FALSE)) {
[13:38:01.797]                           master <- get("master", mode = "list", 
[13:38:01.797]                             envir = envir, inherits = FALSE)
[13:38:01.797]                           if (inherits(master, c("SOCKnode", 
[13:38:01.797]                             "SOCK0node"))) {
[13:38:01.797]                             sendCondition <<- function(cond) {
[13:38:01.797]                               data <- list(type = "VALUE", value = cond, 
[13:38:01.797]                                 success = TRUE)
[13:38:01.797]                               parallel_sendData(master, data)
[13:38:01.797]                             }
[13:38:01.797]                             return(sendCondition)
[13:38:01.797]                           }
[13:38:01.797]                         }
[13:38:01.797]                         frame <- frame + 1L
[13:38:01.797]                         envir <- sys.frame(frame)
[13:38:01.797]                       }
[13:38:01.797]                     }
[13:38:01.797]                     sendCondition <<- function(cond) NULL
[13:38:01.797]                   }
[13:38:01.797]                 })
[13:38:01.797]                 withCallingHandlers({
[13:38:01.797]                   2
[13:38:01.797]                 }, immediateCondition = function(cond) {
[13:38:01.797]                   sendCondition <- ...future.makeSendCondition()
[13:38:01.797]                   sendCondition(cond)
[13:38:01.797]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.797]                   {
[13:38:01.797]                     inherits <- base::inherits
[13:38:01.797]                     invokeRestart <- base::invokeRestart
[13:38:01.797]                     is.null <- base::is.null
[13:38:01.797]                     muffled <- FALSE
[13:38:01.797]                     if (inherits(cond, "message")) {
[13:38:01.797]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:01.797]                       if (muffled) 
[13:38:01.797]                         invokeRestart("muffleMessage")
[13:38:01.797]                     }
[13:38:01.797]                     else if (inherits(cond, "warning")) {
[13:38:01.797]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:01.797]                       if (muffled) 
[13:38:01.797]                         invokeRestart("muffleWarning")
[13:38:01.797]                     }
[13:38:01.797]                     else if (inherits(cond, "condition")) {
[13:38:01.797]                       if (!is.null(pattern)) {
[13:38:01.797]                         computeRestarts <- base::computeRestarts
[13:38:01.797]                         grepl <- base::grepl
[13:38:01.797]                         restarts <- computeRestarts(cond)
[13:38:01.797]                         for (restart in restarts) {
[13:38:01.797]                           name <- restart$name
[13:38:01.797]                           if (is.null(name)) 
[13:38:01.797]                             next
[13:38:01.797]                           if (!grepl(pattern, name)) 
[13:38:01.797]                             next
[13:38:01.797]                           invokeRestart(restart)
[13:38:01.797]                           muffled <- TRUE
[13:38:01.797]                           break
[13:38:01.797]                         }
[13:38:01.797]                       }
[13:38:01.797]                     }
[13:38:01.797]                     invisible(muffled)
[13:38:01.797]                   }
[13:38:01.797]                   muffleCondition(cond)
[13:38:01.797]                 })
[13:38:01.797]             }))
[13:38:01.797]             future::FutureResult(value = ...future.value$value, 
[13:38:01.797]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.797]                   ...future.rng), globalenv = if (FALSE) 
[13:38:01.797]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:01.797]                     ...future.globalenv.names))
[13:38:01.797]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:01.797]         }, condition = base::local({
[13:38:01.797]             c <- base::c
[13:38:01.797]             inherits <- base::inherits
[13:38:01.797]             invokeRestart <- base::invokeRestart
[13:38:01.797]             length <- base::length
[13:38:01.797]             list <- base::list
[13:38:01.797]             seq.int <- base::seq.int
[13:38:01.797]             signalCondition <- base::signalCondition
[13:38:01.797]             sys.calls <- base::sys.calls
[13:38:01.797]             `[[` <- base::`[[`
[13:38:01.797]             `+` <- base::`+`
[13:38:01.797]             `<<-` <- base::`<<-`
[13:38:01.797]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:01.797]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:01.797]                   3L)]
[13:38:01.797]             }
[13:38:01.797]             function(cond) {
[13:38:01.797]                 is_error <- inherits(cond, "error")
[13:38:01.797]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:01.797]                   NULL)
[13:38:01.797]                 if (is_error) {
[13:38:01.797]                   sessionInformation <- function() {
[13:38:01.797]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:01.797]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:01.797]                       search = base::search(), system = base::Sys.info())
[13:38:01.797]                   }
[13:38:01.797]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.797]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:01.797]                     cond$call), session = sessionInformation(), 
[13:38:01.797]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:01.797]                   signalCondition(cond)
[13:38:01.797]                 }
[13:38:01.797]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:01.797]                 "immediateCondition"))) {
[13:38:01.797]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:01.797]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.797]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:01.797]                   if (TRUE && !signal) {
[13:38:01.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.797]                     {
[13:38:01.797]                       inherits <- base::inherits
[13:38:01.797]                       invokeRestart <- base::invokeRestart
[13:38:01.797]                       is.null <- base::is.null
[13:38:01.797]                       muffled <- FALSE
[13:38:01.797]                       if (inherits(cond, "message")) {
[13:38:01.797]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.797]                         if (muffled) 
[13:38:01.797]                           invokeRestart("muffleMessage")
[13:38:01.797]                       }
[13:38:01.797]                       else if (inherits(cond, "warning")) {
[13:38:01.797]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.797]                         if (muffled) 
[13:38:01.797]                           invokeRestart("muffleWarning")
[13:38:01.797]                       }
[13:38:01.797]                       else if (inherits(cond, "condition")) {
[13:38:01.797]                         if (!is.null(pattern)) {
[13:38:01.797]                           computeRestarts <- base::computeRestarts
[13:38:01.797]                           grepl <- base::grepl
[13:38:01.797]                           restarts <- computeRestarts(cond)
[13:38:01.797]                           for (restart in restarts) {
[13:38:01.797]                             name <- restart$name
[13:38:01.797]                             if (is.null(name)) 
[13:38:01.797]                               next
[13:38:01.797]                             if (!grepl(pattern, name)) 
[13:38:01.797]                               next
[13:38:01.797]                             invokeRestart(restart)
[13:38:01.797]                             muffled <- TRUE
[13:38:01.797]                             break
[13:38:01.797]                           }
[13:38:01.797]                         }
[13:38:01.797]                       }
[13:38:01.797]                       invisible(muffled)
[13:38:01.797]                     }
[13:38:01.797]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.797]                   }
[13:38:01.797]                 }
[13:38:01.797]                 else {
[13:38:01.797]                   if (TRUE) {
[13:38:01.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.797]                     {
[13:38:01.797]                       inherits <- base::inherits
[13:38:01.797]                       invokeRestart <- base::invokeRestart
[13:38:01.797]                       is.null <- base::is.null
[13:38:01.797]                       muffled <- FALSE
[13:38:01.797]                       if (inherits(cond, "message")) {
[13:38:01.797]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.797]                         if (muffled) 
[13:38:01.797]                           invokeRestart("muffleMessage")
[13:38:01.797]                       }
[13:38:01.797]                       else if (inherits(cond, "warning")) {
[13:38:01.797]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.797]                         if (muffled) 
[13:38:01.797]                           invokeRestart("muffleWarning")
[13:38:01.797]                       }
[13:38:01.797]                       else if (inherits(cond, "condition")) {
[13:38:01.797]                         if (!is.null(pattern)) {
[13:38:01.797]                           computeRestarts <- base::computeRestarts
[13:38:01.797]                           grepl <- base::grepl
[13:38:01.797]                           restarts <- computeRestarts(cond)
[13:38:01.797]                           for (restart in restarts) {
[13:38:01.797]                             name <- restart$name
[13:38:01.797]                             if (is.null(name)) 
[13:38:01.797]                               next
[13:38:01.797]                             if (!grepl(pattern, name)) 
[13:38:01.797]                               next
[13:38:01.797]                             invokeRestart(restart)
[13:38:01.797]                             muffled <- TRUE
[13:38:01.797]                             break
[13:38:01.797]                           }
[13:38:01.797]                         }
[13:38:01.797]                       }
[13:38:01.797]                       invisible(muffled)
[13:38:01.797]                     }
[13:38:01.797]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.797]                   }
[13:38:01.797]                 }
[13:38:01.797]             }
[13:38:01.797]         }))
[13:38:01.797]     }, error = function(ex) {
[13:38:01.797]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:01.797]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.797]                 ...future.rng), started = ...future.startTime, 
[13:38:01.797]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:01.797]             version = "1.8"), class = "FutureResult")
[13:38:01.797]     }, finally = {
[13:38:01.797]         if (!identical(...future.workdir, getwd())) 
[13:38:01.797]             setwd(...future.workdir)
[13:38:01.797]         {
[13:38:01.797]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:01.797]                 ...future.oldOptions$nwarnings <- NULL
[13:38:01.797]             }
[13:38:01.797]             base::options(...future.oldOptions)
[13:38:01.797]             if (.Platform$OS.type == "windows") {
[13:38:01.797]                 old_names <- names(...future.oldEnvVars)
[13:38:01.797]                 envs <- base::Sys.getenv()
[13:38:01.797]                 names <- names(envs)
[13:38:01.797]                 common <- intersect(names, old_names)
[13:38:01.797]                 added <- setdiff(names, old_names)
[13:38:01.797]                 removed <- setdiff(old_names, names)
[13:38:01.797]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:01.797]                   envs[common]]
[13:38:01.797]                 NAMES <- toupper(changed)
[13:38:01.797]                 args <- list()
[13:38:01.797]                 for (kk in seq_along(NAMES)) {
[13:38:01.797]                   name <- changed[[kk]]
[13:38:01.797]                   NAME <- NAMES[[kk]]
[13:38:01.797]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.797]                     next
[13:38:01.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.797]                 }
[13:38:01.797]                 NAMES <- toupper(added)
[13:38:01.797]                 for (kk in seq_along(NAMES)) {
[13:38:01.797]                   name <- added[[kk]]
[13:38:01.797]                   NAME <- NAMES[[kk]]
[13:38:01.797]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.797]                     next
[13:38:01.797]                   args[[name]] <- ""
[13:38:01.797]                 }
[13:38:01.797]                 NAMES <- toupper(removed)
[13:38:01.797]                 for (kk in seq_along(NAMES)) {
[13:38:01.797]                   name <- removed[[kk]]
[13:38:01.797]                   NAME <- NAMES[[kk]]
[13:38:01.797]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.797]                     next
[13:38:01.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.797]                 }
[13:38:01.797]                 if (length(args) > 0) 
[13:38:01.797]                   base::do.call(base::Sys.setenv, args = args)
[13:38:01.797]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:01.797]             }
[13:38:01.797]             else {
[13:38:01.797]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:01.797]             }
[13:38:01.797]             {
[13:38:01.797]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:01.797]                   0L) {
[13:38:01.797]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:01.797]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:01.797]                   base::options(opts)
[13:38:01.797]                 }
[13:38:01.797]                 {
[13:38:01.797]                   {
[13:38:01.797]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:01.797]                     NULL
[13:38:01.797]                   }
[13:38:01.797]                   options(future.plan = NULL)
[13:38:01.797]                   if (is.na(NA_character_)) 
[13:38:01.797]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.797]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:01.797]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:01.797]                     .init = FALSE)
[13:38:01.797]                 }
[13:38:01.797]             }
[13:38:01.797]         }
[13:38:01.797]     })
[13:38:01.797]     if (TRUE) {
[13:38:01.797]         base::sink(type = "output", split = FALSE)
[13:38:01.797]         if (TRUE) {
[13:38:01.797]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:01.797]         }
[13:38:01.797]         else {
[13:38:01.797]             ...future.result["stdout"] <- base::list(NULL)
[13:38:01.797]         }
[13:38:01.797]         base::close(...future.stdout)
[13:38:01.797]         ...future.stdout <- NULL
[13:38:01.797]     }
[13:38:01.797]     ...future.result$conditions <- ...future.conditions
[13:38:01.797]     ...future.result$finished <- base::Sys.time()
[13:38:01.797]     ...future.result
[13:38:01.797] }
[13:38:01.800] MultisessionFuture started
[13:38:01.800] - Launch lazy future ... done
[13:38:01.800] run() for ‘MultisessionFuture’ ... done
[13:38:01.801] resolve() on environment ...
[13:38:01.801]  recursive: 0
[13:38:01.802]  elements: [3] ‘a’, ‘b’, ‘c’
[13:38:01.803] receiveMessageFromWorker() for ClusterFuture ...
[13:38:01.803] - Validating connection of MultisessionFuture
[13:38:01.803] - received message: FutureResult
[13:38:01.803] - Received FutureResult
[13:38:01.803] - Erased future from FutureRegistry
[13:38:01.803] result() for ClusterFuture ...
[13:38:01.803] - result already collected: FutureResult
[13:38:01.803] result() for ClusterFuture ... done
[13:38:01.803] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:01.804] Future #1
[13:38:01.804]  length: 2 (resolved future 1)
[13:38:01.804] receiveMessageFromWorker() for ClusterFuture ...
[13:38:01.804] - Validating connection of MultisessionFuture
[13:38:01.804] - received message: FutureResult
[13:38:01.804] - Received FutureResult
[13:38:01.805] - Erased future from FutureRegistry
[13:38:01.805] result() for ClusterFuture ...
[13:38:01.805] - result already collected: FutureResult
[13:38:01.805] result() for ClusterFuture ... done
[13:38:01.805] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:01.805] Future #2
[13:38:01.805]  length: 1 (resolved future 2)
[13:38:01.805]  length: 0 (resolved future 3)
[13:38:01.805] resolve() on environment ... DONE
[13:38:01.806] getGlobalsAndPackages() ...
[13:38:01.806] Searching for globals...
[13:38:01.807] - globals found: [1] ‘{’
[13:38:01.807] Searching for globals ... DONE
[13:38:01.807] Resolving globals: FALSE
[13:38:01.807] 
[13:38:01.807] 
[13:38:01.807] getGlobalsAndPackages() ... DONE
[13:38:01.807] run() for ‘Future’ ...
[13:38:01.808] - state: ‘created’
[13:38:01.808] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:01.821] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:01.821] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:01.821]   - Field: ‘node’
[13:38:01.821]   - Field: ‘label’
[13:38:01.821]   - Field: ‘local’
[13:38:01.821]   - Field: ‘owner’
[13:38:01.822]   - Field: ‘envir’
[13:38:01.822]   - Field: ‘workers’
[13:38:01.822]   - Field: ‘packages’
[13:38:01.822]   - Field: ‘gc’
[13:38:01.822]   - Field: ‘conditions’
[13:38:01.822]   - Field: ‘persistent’
[13:38:01.822]   - Field: ‘expr’
[13:38:01.822]   - Field: ‘uuid’
[13:38:01.822]   - Field: ‘seed’
[13:38:01.822]   - Field: ‘version’
[13:38:01.822]   - Field: ‘result’
[13:38:01.823]   - Field: ‘asynchronous’
[13:38:01.823]   - Field: ‘calls’
[13:38:01.823]   - Field: ‘globals’
[13:38:01.823]   - Field: ‘stdout’
[13:38:01.823]   - Field: ‘earlySignal’
[13:38:01.823]   - Field: ‘lazy’
[13:38:01.823]   - Field: ‘state’
[13:38:01.823] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:01.823] - Launch lazy future ...
[13:38:01.824] Packages needed by the future expression (n = 0): <none>
[13:38:01.824] Packages needed by future strategies (n = 0): <none>
[13:38:01.824] {
[13:38:01.824]     {
[13:38:01.824]         {
[13:38:01.824]             ...future.startTime <- base::Sys.time()
[13:38:01.824]             {
[13:38:01.824]                 {
[13:38:01.824]                   {
[13:38:01.824]                     {
[13:38:01.824]                       base::local({
[13:38:01.824]                         has_future <- base::requireNamespace("future", 
[13:38:01.824]                           quietly = TRUE)
[13:38:01.824]                         if (has_future) {
[13:38:01.824]                           ns <- base::getNamespace("future")
[13:38:01.824]                           version <- ns[[".package"]][["version"]]
[13:38:01.824]                           if (is.null(version)) 
[13:38:01.824]                             version <- utils::packageVersion("future")
[13:38:01.824]                         }
[13:38:01.824]                         else {
[13:38:01.824]                           version <- NULL
[13:38:01.824]                         }
[13:38:01.824]                         if (!has_future || version < "1.8.0") {
[13:38:01.824]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:01.824]                             "", base::R.version$version.string), 
[13:38:01.824]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:01.824]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:01.824]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:01.824]                               "release", "version")], collapse = " "), 
[13:38:01.824]                             hostname = base::Sys.info()[["nodename"]])
[13:38:01.824]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:01.824]                             info)
[13:38:01.824]                           info <- base::paste(info, collapse = "; ")
[13:38:01.824]                           if (!has_future) {
[13:38:01.824]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:01.824]                               info)
[13:38:01.824]                           }
[13:38:01.824]                           else {
[13:38:01.824]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:01.824]                               info, version)
[13:38:01.824]                           }
[13:38:01.824]                           base::stop(msg)
[13:38:01.824]                         }
[13:38:01.824]                       })
[13:38:01.824]                     }
[13:38:01.824]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:01.824]                     base::options(mc.cores = 1L)
[13:38:01.824]                   }
[13:38:01.824]                   ...future.strategy.old <- future::plan("list")
[13:38:01.824]                   options(future.plan = NULL)
[13:38:01.824]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.824]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:01.824]                 }
[13:38:01.824]                 ...future.workdir <- getwd()
[13:38:01.824]             }
[13:38:01.824]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:01.824]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:01.824]         }
[13:38:01.824]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:01.824]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:01.824]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:01.824]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:01.824]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:01.824]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:01.824]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:01.824]             base::names(...future.oldOptions))
[13:38:01.824]     }
[13:38:01.824]     if (FALSE) {
[13:38:01.824]     }
[13:38:01.824]     else {
[13:38:01.824]         if (TRUE) {
[13:38:01.824]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:01.824]                 open = "w")
[13:38:01.824]         }
[13:38:01.824]         else {
[13:38:01.824]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:01.824]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:01.824]         }
[13:38:01.824]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:01.824]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:01.824]             base::sink(type = "output", split = FALSE)
[13:38:01.824]             base::close(...future.stdout)
[13:38:01.824]         }, add = TRUE)
[13:38:01.824]     }
[13:38:01.824]     ...future.frame <- base::sys.nframe()
[13:38:01.824]     ...future.conditions <- base::list()
[13:38:01.824]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:01.824]     if (FALSE) {
[13:38:01.824]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:01.824]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:01.824]     }
[13:38:01.824]     ...future.result <- base::tryCatch({
[13:38:01.824]         base::withCallingHandlers({
[13:38:01.824]             ...future.value <- base::withVisible(base::local({
[13:38:01.824]                 ...future.makeSendCondition <- base::local({
[13:38:01.824]                   sendCondition <- NULL
[13:38:01.824]                   function(frame = 1L) {
[13:38:01.824]                     if (is.function(sendCondition)) 
[13:38:01.824]                       return(sendCondition)
[13:38:01.824]                     ns <- getNamespace("parallel")
[13:38:01.824]                     if (exists("sendData", mode = "function", 
[13:38:01.824]                       envir = ns)) {
[13:38:01.824]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:01.824]                         envir = ns)
[13:38:01.824]                       envir <- sys.frame(frame)
[13:38:01.824]                       master <- NULL
[13:38:01.824]                       while (!identical(envir, .GlobalEnv) && 
[13:38:01.824]                         !identical(envir, emptyenv())) {
[13:38:01.824]                         if (exists("master", mode = "list", envir = envir, 
[13:38:01.824]                           inherits = FALSE)) {
[13:38:01.824]                           master <- get("master", mode = "list", 
[13:38:01.824]                             envir = envir, inherits = FALSE)
[13:38:01.824]                           if (inherits(master, c("SOCKnode", 
[13:38:01.824]                             "SOCK0node"))) {
[13:38:01.824]                             sendCondition <<- function(cond) {
[13:38:01.824]                               data <- list(type = "VALUE", value = cond, 
[13:38:01.824]                                 success = TRUE)
[13:38:01.824]                               parallel_sendData(master, data)
[13:38:01.824]                             }
[13:38:01.824]                             return(sendCondition)
[13:38:01.824]                           }
[13:38:01.824]                         }
[13:38:01.824]                         frame <- frame + 1L
[13:38:01.824]                         envir <- sys.frame(frame)
[13:38:01.824]                       }
[13:38:01.824]                     }
[13:38:01.824]                     sendCondition <<- function(cond) NULL
[13:38:01.824]                   }
[13:38:01.824]                 })
[13:38:01.824]                 withCallingHandlers({
[13:38:01.824]                   {
[13:38:01.824]                     1
[13:38:01.824]                   }
[13:38:01.824]                 }, immediateCondition = function(cond) {
[13:38:01.824]                   sendCondition <- ...future.makeSendCondition()
[13:38:01.824]                   sendCondition(cond)
[13:38:01.824]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.824]                   {
[13:38:01.824]                     inherits <- base::inherits
[13:38:01.824]                     invokeRestart <- base::invokeRestart
[13:38:01.824]                     is.null <- base::is.null
[13:38:01.824]                     muffled <- FALSE
[13:38:01.824]                     if (inherits(cond, "message")) {
[13:38:01.824]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:01.824]                       if (muffled) 
[13:38:01.824]                         invokeRestart("muffleMessage")
[13:38:01.824]                     }
[13:38:01.824]                     else if (inherits(cond, "warning")) {
[13:38:01.824]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:01.824]                       if (muffled) 
[13:38:01.824]                         invokeRestart("muffleWarning")
[13:38:01.824]                     }
[13:38:01.824]                     else if (inherits(cond, "condition")) {
[13:38:01.824]                       if (!is.null(pattern)) {
[13:38:01.824]                         computeRestarts <- base::computeRestarts
[13:38:01.824]                         grepl <- base::grepl
[13:38:01.824]                         restarts <- computeRestarts(cond)
[13:38:01.824]                         for (restart in restarts) {
[13:38:01.824]                           name <- restart$name
[13:38:01.824]                           if (is.null(name)) 
[13:38:01.824]                             next
[13:38:01.824]                           if (!grepl(pattern, name)) 
[13:38:01.824]                             next
[13:38:01.824]                           invokeRestart(restart)
[13:38:01.824]                           muffled <- TRUE
[13:38:01.824]                           break
[13:38:01.824]                         }
[13:38:01.824]                       }
[13:38:01.824]                     }
[13:38:01.824]                     invisible(muffled)
[13:38:01.824]                   }
[13:38:01.824]                   muffleCondition(cond)
[13:38:01.824]                 })
[13:38:01.824]             }))
[13:38:01.824]             future::FutureResult(value = ...future.value$value, 
[13:38:01.824]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.824]                   ...future.rng), globalenv = if (FALSE) 
[13:38:01.824]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:01.824]                     ...future.globalenv.names))
[13:38:01.824]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:01.824]         }, condition = base::local({
[13:38:01.824]             c <- base::c
[13:38:01.824]             inherits <- base::inherits
[13:38:01.824]             invokeRestart <- base::invokeRestart
[13:38:01.824]             length <- base::length
[13:38:01.824]             list <- base::list
[13:38:01.824]             seq.int <- base::seq.int
[13:38:01.824]             signalCondition <- base::signalCondition
[13:38:01.824]             sys.calls <- base::sys.calls
[13:38:01.824]             `[[` <- base::`[[`
[13:38:01.824]             `+` <- base::`+`
[13:38:01.824]             `<<-` <- base::`<<-`
[13:38:01.824]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:01.824]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:01.824]                   3L)]
[13:38:01.824]             }
[13:38:01.824]             function(cond) {
[13:38:01.824]                 is_error <- inherits(cond, "error")
[13:38:01.824]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:01.824]                   NULL)
[13:38:01.824]                 if (is_error) {
[13:38:01.824]                   sessionInformation <- function() {
[13:38:01.824]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:01.824]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:01.824]                       search = base::search(), system = base::Sys.info())
[13:38:01.824]                   }
[13:38:01.824]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.824]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:01.824]                     cond$call), session = sessionInformation(), 
[13:38:01.824]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:01.824]                   signalCondition(cond)
[13:38:01.824]                 }
[13:38:01.824]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:01.824]                 "immediateCondition"))) {
[13:38:01.824]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:01.824]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.824]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:01.824]                   if (TRUE && !signal) {
[13:38:01.824]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.824]                     {
[13:38:01.824]                       inherits <- base::inherits
[13:38:01.824]                       invokeRestart <- base::invokeRestart
[13:38:01.824]                       is.null <- base::is.null
[13:38:01.824]                       muffled <- FALSE
[13:38:01.824]                       if (inherits(cond, "message")) {
[13:38:01.824]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.824]                         if (muffled) 
[13:38:01.824]                           invokeRestart("muffleMessage")
[13:38:01.824]                       }
[13:38:01.824]                       else if (inherits(cond, "warning")) {
[13:38:01.824]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.824]                         if (muffled) 
[13:38:01.824]                           invokeRestart("muffleWarning")
[13:38:01.824]                       }
[13:38:01.824]                       else if (inherits(cond, "condition")) {
[13:38:01.824]                         if (!is.null(pattern)) {
[13:38:01.824]                           computeRestarts <- base::computeRestarts
[13:38:01.824]                           grepl <- base::grepl
[13:38:01.824]                           restarts <- computeRestarts(cond)
[13:38:01.824]                           for (restart in restarts) {
[13:38:01.824]                             name <- restart$name
[13:38:01.824]                             if (is.null(name)) 
[13:38:01.824]                               next
[13:38:01.824]                             if (!grepl(pattern, name)) 
[13:38:01.824]                               next
[13:38:01.824]                             invokeRestart(restart)
[13:38:01.824]                             muffled <- TRUE
[13:38:01.824]                             break
[13:38:01.824]                           }
[13:38:01.824]                         }
[13:38:01.824]                       }
[13:38:01.824]                       invisible(muffled)
[13:38:01.824]                     }
[13:38:01.824]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.824]                   }
[13:38:01.824]                 }
[13:38:01.824]                 else {
[13:38:01.824]                   if (TRUE) {
[13:38:01.824]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.824]                     {
[13:38:01.824]                       inherits <- base::inherits
[13:38:01.824]                       invokeRestart <- base::invokeRestart
[13:38:01.824]                       is.null <- base::is.null
[13:38:01.824]                       muffled <- FALSE
[13:38:01.824]                       if (inherits(cond, "message")) {
[13:38:01.824]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.824]                         if (muffled) 
[13:38:01.824]                           invokeRestart("muffleMessage")
[13:38:01.824]                       }
[13:38:01.824]                       else if (inherits(cond, "warning")) {
[13:38:01.824]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.824]                         if (muffled) 
[13:38:01.824]                           invokeRestart("muffleWarning")
[13:38:01.824]                       }
[13:38:01.824]                       else if (inherits(cond, "condition")) {
[13:38:01.824]                         if (!is.null(pattern)) {
[13:38:01.824]                           computeRestarts <- base::computeRestarts
[13:38:01.824]                           grepl <- base::grepl
[13:38:01.824]                           restarts <- computeRestarts(cond)
[13:38:01.824]                           for (restart in restarts) {
[13:38:01.824]                             name <- restart$name
[13:38:01.824]                             if (is.null(name)) 
[13:38:01.824]                               next
[13:38:01.824]                             if (!grepl(pattern, name)) 
[13:38:01.824]                               next
[13:38:01.824]                             invokeRestart(restart)
[13:38:01.824]                             muffled <- TRUE
[13:38:01.824]                             break
[13:38:01.824]                           }
[13:38:01.824]                         }
[13:38:01.824]                       }
[13:38:01.824]                       invisible(muffled)
[13:38:01.824]                     }
[13:38:01.824]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.824]                   }
[13:38:01.824]                 }
[13:38:01.824]             }
[13:38:01.824]         }))
[13:38:01.824]     }, error = function(ex) {
[13:38:01.824]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:01.824]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.824]                 ...future.rng), started = ...future.startTime, 
[13:38:01.824]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:01.824]             version = "1.8"), class = "FutureResult")
[13:38:01.824]     }, finally = {
[13:38:01.824]         if (!identical(...future.workdir, getwd())) 
[13:38:01.824]             setwd(...future.workdir)
[13:38:01.824]         {
[13:38:01.824]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:01.824]                 ...future.oldOptions$nwarnings <- NULL
[13:38:01.824]             }
[13:38:01.824]             base::options(...future.oldOptions)
[13:38:01.824]             if (.Platform$OS.type == "windows") {
[13:38:01.824]                 old_names <- names(...future.oldEnvVars)
[13:38:01.824]                 envs <- base::Sys.getenv()
[13:38:01.824]                 names <- names(envs)
[13:38:01.824]                 common <- intersect(names, old_names)
[13:38:01.824]                 added <- setdiff(names, old_names)
[13:38:01.824]                 removed <- setdiff(old_names, names)
[13:38:01.824]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:01.824]                   envs[common]]
[13:38:01.824]                 NAMES <- toupper(changed)
[13:38:01.824]                 args <- list()
[13:38:01.824]                 for (kk in seq_along(NAMES)) {
[13:38:01.824]                   name <- changed[[kk]]
[13:38:01.824]                   NAME <- NAMES[[kk]]
[13:38:01.824]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.824]                     next
[13:38:01.824]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.824]                 }
[13:38:01.824]                 NAMES <- toupper(added)
[13:38:01.824]                 for (kk in seq_along(NAMES)) {
[13:38:01.824]                   name <- added[[kk]]
[13:38:01.824]                   NAME <- NAMES[[kk]]
[13:38:01.824]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.824]                     next
[13:38:01.824]                   args[[name]] <- ""
[13:38:01.824]                 }
[13:38:01.824]                 NAMES <- toupper(removed)
[13:38:01.824]                 for (kk in seq_along(NAMES)) {
[13:38:01.824]                   name <- removed[[kk]]
[13:38:01.824]                   NAME <- NAMES[[kk]]
[13:38:01.824]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.824]                     next
[13:38:01.824]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.824]                 }
[13:38:01.824]                 if (length(args) > 0) 
[13:38:01.824]                   base::do.call(base::Sys.setenv, args = args)
[13:38:01.824]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:01.824]             }
[13:38:01.824]             else {
[13:38:01.824]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:01.824]             }
[13:38:01.824]             {
[13:38:01.824]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:01.824]                   0L) {
[13:38:01.824]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:01.824]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:01.824]                   base::options(opts)
[13:38:01.824]                 }
[13:38:01.824]                 {
[13:38:01.824]                   {
[13:38:01.824]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:01.824]                     NULL
[13:38:01.824]                   }
[13:38:01.824]                   options(future.plan = NULL)
[13:38:01.824]                   if (is.na(NA_character_)) 
[13:38:01.824]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.824]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:01.824]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:01.824]                     .init = FALSE)
[13:38:01.824]                 }
[13:38:01.824]             }
[13:38:01.824]         }
[13:38:01.824]     })
[13:38:01.824]     if (TRUE) {
[13:38:01.824]         base::sink(type = "output", split = FALSE)
[13:38:01.824]         if (TRUE) {
[13:38:01.824]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:01.824]         }
[13:38:01.824]         else {
[13:38:01.824]             ...future.result["stdout"] <- base::list(NULL)
[13:38:01.824]         }
[13:38:01.824]         base::close(...future.stdout)
[13:38:01.824]         ...future.stdout <- NULL
[13:38:01.824]     }
[13:38:01.824]     ...future.result$conditions <- ...future.conditions
[13:38:01.824]     ...future.result$finished <- base::Sys.time()
[13:38:01.824]     ...future.result
[13:38:01.824] }
[13:38:01.827] MultisessionFuture started
[13:38:01.830] - Launch lazy future ... done
[13:38:01.830] run() for ‘MultisessionFuture’ ... done
[13:38:01.831] getGlobalsAndPackages() ...
[13:38:01.831] Searching for globals...
[13:38:01.832] - globals found: [1] ‘{’
[13:38:01.832] Searching for globals ... DONE
[13:38:01.832] Resolving globals: FALSE
[13:38:01.832] 
[13:38:01.832] 
[13:38:01.832] getGlobalsAndPackages() ... DONE
[13:38:01.833] run() for ‘Future’ ...
[13:38:01.833] - state: ‘created’
[13:38:01.833] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:01.847] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:01.847] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:01.847]   - Field: ‘node’
[13:38:01.847]   - Field: ‘label’
[13:38:01.847]   - Field: ‘local’
[13:38:01.847]   - Field: ‘owner’
[13:38:01.847]   - Field: ‘envir’
[13:38:01.847]   - Field: ‘workers’
[13:38:01.847]   - Field: ‘packages’
[13:38:01.847]   - Field: ‘gc’
[13:38:01.847]   - Field: ‘conditions’
[13:38:01.848]   - Field: ‘persistent’
[13:38:01.848]   - Field: ‘expr’
[13:38:01.848]   - Field: ‘uuid’
[13:38:01.848]   - Field: ‘seed’
[13:38:01.848]   - Field: ‘version’
[13:38:01.848]   - Field: ‘result’
[13:38:01.848]   - Field: ‘asynchronous’
[13:38:01.848]   - Field: ‘calls’
[13:38:01.848]   - Field: ‘globals’
[13:38:01.848]   - Field: ‘stdout’
[13:38:01.848]   - Field: ‘earlySignal’
[13:38:01.849]   - Field: ‘lazy’
[13:38:01.849]   - Field: ‘state’
[13:38:01.849] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:01.849] - Launch lazy future ...
[13:38:01.849] Packages needed by the future expression (n = 0): <none>
[13:38:01.849] Packages needed by future strategies (n = 0): <none>
[13:38:01.850] {
[13:38:01.850]     {
[13:38:01.850]         {
[13:38:01.850]             ...future.startTime <- base::Sys.time()
[13:38:01.850]             {
[13:38:01.850]                 {
[13:38:01.850]                   {
[13:38:01.850]                     {
[13:38:01.850]                       base::local({
[13:38:01.850]                         has_future <- base::requireNamespace("future", 
[13:38:01.850]                           quietly = TRUE)
[13:38:01.850]                         if (has_future) {
[13:38:01.850]                           ns <- base::getNamespace("future")
[13:38:01.850]                           version <- ns[[".package"]][["version"]]
[13:38:01.850]                           if (is.null(version)) 
[13:38:01.850]                             version <- utils::packageVersion("future")
[13:38:01.850]                         }
[13:38:01.850]                         else {
[13:38:01.850]                           version <- NULL
[13:38:01.850]                         }
[13:38:01.850]                         if (!has_future || version < "1.8.0") {
[13:38:01.850]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:01.850]                             "", base::R.version$version.string), 
[13:38:01.850]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:01.850]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:01.850]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:01.850]                               "release", "version")], collapse = " "), 
[13:38:01.850]                             hostname = base::Sys.info()[["nodename"]])
[13:38:01.850]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:01.850]                             info)
[13:38:01.850]                           info <- base::paste(info, collapse = "; ")
[13:38:01.850]                           if (!has_future) {
[13:38:01.850]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:01.850]                               info)
[13:38:01.850]                           }
[13:38:01.850]                           else {
[13:38:01.850]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:01.850]                               info, version)
[13:38:01.850]                           }
[13:38:01.850]                           base::stop(msg)
[13:38:01.850]                         }
[13:38:01.850]                       })
[13:38:01.850]                     }
[13:38:01.850]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:01.850]                     base::options(mc.cores = 1L)
[13:38:01.850]                   }
[13:38:01.850]                   ...future.strategy.old <- future::plan("list")
[13:38:01.850]                   options(future.plan = NULL)
[13:38:01.850]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.850]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:01.850]                 }
[13:38:01.850]                 ...future.workdir <- getwd()
[13:38:01.850]             }
[13:38:01.850]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:01.850]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:01.850]         }
[13:38:01.850]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:01.850]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:01.850]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:01.850]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:01.850]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:01.850]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:01.850]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:01.850]             base::names(...future.oldOptions))
[13:38:01.850]     }
[13:38:01.850]     if (FALSE) {
[13:38:01.850]     }
[13:38:01.850]     else {
[13:38:01.850]         if (TRUE) {
[13:38:01.850]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:01.850]                 open = "w")
[13:38:01.850]         }
[13:38:01.850]         else {
[13:38:01.850]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:01.850]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:01.850]         }
[13:38:01.850]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:01.850]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:01.850]             base::sink(type = "output", split = FALSE)
[13:38:01.850]             base::close(...future.stdout)
[13:38:01.850]         }, add = TRUE)
[13:38:01.850]     }
[13:38:01.850]     ...future.frame <- base::sys.nframe()
[13:38:01.850]     ...future.conditions <- base::list()
[13:38:01.850]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:01.850]     if (FALSE) {
[13:38:01.850]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:01.850]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:01.850]     }
[13:38:01.850]     ...future.result <- base::tryCatch({
[13:38:01.850]         base::withCallingHandlers({
[13:38:01.850]             ...future.value <- base::withVisible(base::local({
[13:38:01.850]                 ...future.makeSendCondition <- base::local({
[13:38:01.850]                   sendCondition <- NULL
[13:38:01.850]                   function(frame = 1L) {
[13:38:01.850]                     if (is.function(sendCondition)) 
[13:38:01.850]                       return(sendCondition)
[13:38:01.850]                     ns <- getNamespace("parallel")
[13:38:01.850]                     if (exists("sendData", mode = "function", 
[13:38:01.850]                       envir = ns)) {
[13:38:01.850]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:01.850]                         envir = ns)
[13:38:01.850]                       envir <- sys.frame(frame)
[13:38:01.850]                       master <- NULL
[13:38:01.850]                       while (!identical(envir, .GlobalEnv) && 
[13:38:01.850]                         !identical(envir, emptyenv())) {
[13:38:01.850]                         if (exists("master", mode = "list", envir = envir, 
[13:38:01.850]                           inherits = FALSE)) {
[13:38:01.850]                           master <- get("master", mode = "list", 
[13:38:01.850]                             envir = envir, inherits = FALSE)
[13:38:01.850]                           if (inherits(master, c("SOCKnode", 
[13:38:01.850]                             "SOCK0node"))) {
[13:38:01.850]                             sendCondition <<- function(cond) {
[13:38:01.850]                               data <- list(type = "VALUE", value = cond, 
[13:38:01.850]                                 success = TRUE)
[13:38:01.850]                               parallel_sendData(master, data)
[13:38:01.850]                             }
[13:38:01.850]                             return(sendCondition)
[13:38:01.850]                           }
[13:38:01.850]                         }
[13:38:01.850]                         frame <- frame + 1L
[13:38:01.850]                         envir <- sys.frame(frame)
[13:38:01.850]                       }
[13:38:01.850]                     }
[13:38:01.850]                     sendCondition <<- function(cond) NULL
[13:38:01.850]                   }
[13:38:01.850]                 })
[13:38:01.850]                 withCallingHandlers({
[13:38:01.850]                   {
[13:38:01.850]                     2
[13:38:01.850]                   }
[13:38:01.850]                 }, immediateCondition = function(cond) {
[13:38:01.850]                   sendCondition <- ...future.makeSendCondition()
[13:38:01.850]                   sendCondition(cond)
[13:38:01.850]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.850]                   {
[13:38:01.850]                     inherits <- base::inherits
[13:38:01.850]                     invokeRestart <- base::invokeRestart
[13:38:01.850]                     is.null <- base::is.null
[13:38:01.850]                     muffled <- FALSE
[13:38:01.850]                     if (inherits(cond, "message")) {
[13:38:01.850]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:01.850]                       if (muffled) 
[13:38:01.850]                         invokeRestart("muffleMessage")
[13:38:01.850]                     }
[13:38:01.850]                     else if (inherits(cond, "warning")) {
[13:38:01.850]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:01.850]                       if (muffled) 
[13:38:01.850]                         invokeRestart("muffleWarning")
[13:38:01.850]                     }
[13:38:01.850]                     else if (inherits(cond, "condition")) {
[13:38:01.850]                       if (!is.null(pattern)) {
[13:38:01.850]                         computeRestarts <- base::computeRestarts
[13:38:01.850]                         grepl <- base::grepl
[13:38:01.850]                         restarts <- computeRestarts(cond)
[13:38:01.850]                         for (restart in restarts) {
[13:38:01.850]                           name <- restart$name
[13:38:01.850]                           if (is.null(name)) 
[13:38:01.850]                             next
[13:38:01.850]                           if (!grepl(pattern, name)) 
[13:38:01.850]                             next
[13:38:01.850]                           invokeRestart(restart)
[13:38:01.850]                           muffled <- TRUE
[13:38:01.850]                           break
[13:38:01.850]                         }
[13:38:01.850]                       }
[13:38:01.850]                     }
[13:38:01.850]                     invisible(muffled)
[13:38:01.850]                   }
[13:38:01.850]                   muffleCondition(cond)
[13:38:01.850]                 })
[13:38:01.850]             }))
[13:38:01.850]             future::FutureResult(value = ...future.value$value, 
[13:38:01.850]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.850]                   ...future.rng), globalenv = if (FALSE) 
[13:38:01.850]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:01.850]                     ...future.globalenv.names))
[13:38:01.850]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:01.850]         }, condition = base::local({
[13:38:01.850]             c <- base::c
[13:38:01.850]             inherits <- base::inherits
[13:38:01.850]             invokeRestart <- base::invokeRestart
[13:38:01.850]             length <- base::length
[13:38:01.850]             list <- base::list
[13:38:01.850]             seq.int <- base::seq.int
[13:38:01.850]             signalCondition <- base::signalCondition
[13:38:01.850]             sys.calls <- base::sys.calls
[13:38:01.850]             `[[` <- base::`[[`
[13:38:01.850]             `+` <- base::`+`
[13:38:01.850]             `<<-` <- base::`<<-`
[13:38:01.850]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:01.850]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:01.850]                   3L)]
[13:38:01.850]             }
[13:38:01.850]             function(cond) {
[13:38:01.850]                 is_error <- inherits(cond, "error")
[13:38:01.850]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:01.850]                   NULL)
[13:38:01.850]                 if (is_error) {
[13:38:01.850]                   sessionInformation <- function() {
[13:38:01.850]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:01.850]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:01.850]                       search = base::search(), system = base::Sys.info())
[13:38:01.850]                   }
[13:38:01.850]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.850]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:01.850]                     cond$call), session = sessionInformation(), 
[13:38:01.850]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:01.850]                   signalCondition(cond)
[13:38:01.850]                 }
[13:38:01.850]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:01.850]                 "immediateCondition"))) {
[13:38:01.850]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:01.850]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.850]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:01.850]                   if (TRUE && !signal) {
[13:38:01.850]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.850]                     {
[13:38:01.850]                       inherits <- base::inherits
[13:38:01.850]                       invokeRestart <- base::invokeRestart
[13:38:01.850]                       is.null <- base::is.null
[13:38:01.850]                       muffled <- FALSE
[13:38:01.850]                       if (inherits(cond, "message")) {
[13:38:01.850]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.850]                         if (muffled) 
[13:38:01.850]                           invokeRestart("muffleMessage")
[13:38:01.850]                       }
[13:38:01.850]                       else if (inherits(cond, "warning")) {
[13:38:01.850]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.850]                         if (muffled) 
[13:38:01.850]                           invokeRestart("muffleWarning")
[13:38:01.850]                       }
[13:38:01.850]                       else if (inherits(cond, "condition")) {
[13:38:01.850]                         if (!is.null(pattern)) {
[13:38:01.850]                           computeRestarts <- base::computeRestarts
[13:38:01.850]                           grepl <- base::grepl
[13:38:01.850]                           restarts <- computeRestarts(cond)
[13:38:01.850]                           for (restart in restarts) {
[13:38:01.850]                             name <- restart$name
[13:38:01.850]                             if (is.null(name)) 
[13:38:01.850]                               next
[13:38:01.850]                             if (!grepl(pattern, name)) 
[13:38:01.850]                               next
[13:38:01.850]                             invokeRestart(restart)
[13:38:01.850]                             muffled <- TRUE
[13:38:01.850]                             break
[13:38:01.850]                           }
[13:38:01.850]                         }
[13:38:01.850]                       }
[13:38:01.850]                       invisible(muffled)
[13:38:01.850]                     }
[13:38:01.850]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.850]                   }
[13:38:01.850]                 }
[13:38:01.850]                 else {
[13:38:01.850]                   if (TRUE) {
[13:38:01.850]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.850]                     {
[13:38:01.850]                       inherits <- base::inherits
[13:38:01.850]                       invokeRestart <- base::invokeRestart
[13:38:01.850]                       is.null <- base::is.null
[13:38:01.850]                       muffled <- FALSE
[13:38:01.850]                       if (inherits(cond, "message")) {
[13:38:01.850]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.850]                         if (muffled) 
[13:38:01.850]                           invokeRestart("muffleMessage")
[13:38:01.850]                       }
[13:38:01.850]                       else if (inherits(cond, "warning")) {
[13:38:01.850]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.850]                         if (muffled) 
[13:38:01.850]                           invokeRestart("muffleWarning")
[13:38:01.850]                       }
[13:38:01.850]                       else if (inherits(cond, "condition")) {
[13:38:01.850]                         if (!is.null(pattern)) {
[13:38:01.850]                           computeRestarts <- base::computeRestarts
[13:38:01.850]                           grepl <- base::grepl
[13:38:01.850]                           restarts <- computeRestarts(cond)
[13:38:01.850]                           for (restart in restarts) {
[13:38:01.850]                             name <- restart$name
[13:38:01.850]                             if (is.null(name)) 
[13:38:01.850]                               next
[13:38:01.850]                             if (!grepl(pattern, name)) 
[13:38:01.850]                               next
[13:38:01.850]                             invokeRestart(restart)
[13:38:01.850]                             muffled <- TRUE
[13:38:01.850]                             break
[13:38:01.850]                           }
[13:38:01.850]                         }
[13:38:01.850]                       }
[13:38:01.850]                       invisible(muffled)
[13:38:01.850]                     }
[13:38:01.850]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.850]                   }
[13:38:01.850]                 }
[13:38:01.850]             }
[13:38:01.850]         }))
[13:38:01.850]     }, error = function(ex) {
[13:38:01.850]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:01.850]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.850]                 ...future.rng), started = ...future.startTime, 
[13:38:01.850]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:01.850]             version = "1.8"), class = "FutureResult")
[13:38:01.850]     }, finally = {
[13:38:01.850]         if (!identical(...future.workdir, getwd())) 
[13:38:01.850]             setwd(...future.workdir)
[13:38:01.850]         {
[13:38:01.850]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:01.850]                 ...future.oldOptions$nwarnings <- NULL
[13:38:01.850]             }
[13:38:01.850]             base::options(...future.oldOptions)
[13:38:01.850]             if (.Platform$OS.type == "windows") {
[13:38:01.850]                 old_names <- names(...future.oldEnvVars)
[13:38:01.850]                 envs <- base::Sys.getenv()
[13:38:01.850]                 names <- names(envs)
[13:38:01.850]                 common <- intersect(names, old_names)
[13:38:01.850]                 added <- setdiff(names, old_names)
[13:38:01.850]                 removed <- setdiff(old_names, names)
[13:38:01.850]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:01.850]                   envs[common]]
[13:38:01.850]                 NAMES <- toupper(changed)
[13:38:01.850]                 args <- list()
[13:38:01.850]                 for (kk in seq_along(NAMES)) {
[13:38:01.850]                   name <- changed[[kk]]
[13:38:01.850]                   NAME <- NAMES[[kk]]
[13:38:01.850]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.850]                     next
[13:38:01.850]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.850]                 }
[13:38:01.850]                 NAMES <- toupper(added)
[13:38:01.850]                 for (kk in seq_along(NAMES)) {
[13:38:01.850]                   name <- added[[kk]]
[13:38:01.850]                   NAME <- NAMES[[kk]]
[13:38:01.850]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.850]                     next
[13:38:01.850]                   args[[name]] <- ""
[13:38:01.850]                 }
[13:38:01.850]                 NAMES <- toupper(removed)
[13:38:01.850]                 for (kk in seq_along(NAMES)) {
[13:38:01.850]                   name <- removed[[kk]]
[13:38:01.850]                   NAME <- NAMES[[kk]]
[13:38:01.850]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.850]                     next
[13:38:01.850]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.850]                 }
[13:38:01.850]                 if (length(args) > 0) 
[13:38:01.850]                   base::do.call(base::Sys.setenv, args = args)
[13:38:01.850]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:01.850]             }
[13:38:01.850]             else {
[13:38:01.850]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:01.850]             }
[13:38:01.850]             {
[13:38:01.850]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:01.850]                   0L) {
[13:38:01.850]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:01.850]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:01.850]                   base::options(opts)
[13:38:01.850]                 }
[13:38:01.850]                 {
[13:38:01.850]                   {
[13:38:01.850]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:01.850]                     NULL
[13:38:01.850]                   }
[13:38:01.850]                   options(future.plan = NULL)
[13:38:01.850]                   if (is.na(NA_character_)) 
[13:38:01.850]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.850]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:01.850]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:01.850]                     .init = FALSE)
[13:38:01.850]                 }
[13:38:01.850]             }
[13:38:01.850]         }
[13:38:01.850]     })
[13:38:01.850]     if (TRUE) {
[13:38:01.850]         base::sink(type = "output", split = FALSE)
[13:38:01.850]         if (TRUE) {
[13:38:01.850]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:01.850]         }
[13:38:01.850]         else {
[13:38:01.850]             ...future.result["stdout"] <- base::list(NULL)
[13:38:01.850]         }
[13:38:01.850]         base::close(...future.stdout)
[13:38:01.850]         ...future.stdout <- NULL
[13:38:01.850]     }
[13:38:01.850]     ...future.result$conditions <- ...future.conditions
[13:38:01.850]     ...future.result$finished <- base::Sys.time()
[13:38:01.850]     ...future.result
[13:38:01.850] }
[13:38:01.852] MultisessionFuture started
[13:38:01.853] - Launch lazy future ... done
[13:38:01.853] run() for ‘MultisessionFuture’ ... done
[13:38:01.854] resolve() on environment ...
[13:38:01.854]  recursive: 0
[13:38:01.854]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[13:38:01.855] receiveMessageFromWorker() for ClusterFuture ...
[13:38:01.855] - Validating connection of MultisessionFuture
[13:38:01.855] - received message: FutureResult
[13:38:01.855] - Received FutureResult
[13:38:01.856] - Erased future from FutureRegistry
[13:38:01.856] result() for ClusterFuture ...
[13:38:01.856] - result already collected: FutureResult
[13:38:01.856] result() for ClusterFuture ... done
[13:38:01.856] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:01.856] Future #1
[13:38:01.856]  length: 2 (resolved future 1)
[13:38:01.856] receiveMessageFromWorker() for ClusterFuture ...
[13:38:01.857] - Validating connection of MultisessionFuture
[13:38:01.857] - received message: FutureResult
[13:38:01.857] - Received FutureResult
[13:38:01.857] - Erased future from FutureRegistry
[13:38:01.857] result() for ClusterFuture ...
[13:38:01.857] - result already collected: FutureResult
[13:38:01.857] result() for ClusterFuture ... done
[13:38:01.857] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:01.857] Future #2
[13:38:01.857]  length: 1 (resolved future 2)
[13:38:01.858]  length: 0 (resolved future 3)
[13:38:01.858] resolve() on environment ... DONE
[13:38:01.858] getGlobalsAndPackages() ...
[13:38:01.858] Searching for globals...
[13:38:01.859] - globals found: [1] ‘{’
[13:38:01.859] Searching for globals ... DONE
[13:38:01.859] Resolving globals: FALSE
[13:38:01.859] 
[13:38:01.859] 
[13:38:01.859] getGlobalsAndPackages() ... DONE
[13:38:01.860] run() for ‘Future’ ...
[13:38:01.860] - state: ‘created’
[13:38:01.860] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:01.874] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:01.874] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:01.874]   - Field: ‘node’
[13:38:01.874]   - Field: ‘label’
[13:38:01.874]   - Field: ‘local’
[13:38:01.874]   - Field: ‘owner’
[13:38:01.874]   - Field: ‘envir’
[13:38:01.874]   - Field: ‘workers’
[13:38:01.875]   - Field: ‘packages’
[13:38:01.875]   - Field: ‘gc’
[13:38:01.875]   - Field: ‘conditions’
[13:38:01.875]   - Field: ‘persistent’
[13:38:01.875]   - Field: ‘expr’
[13:38:01.875]   - Field: ‘uuid’
[13:38:01.875]   - Field: ‘seed’
[13:38:01.875]   - Field: ‘version’
[13:38:01.875]   - Field: ‘result’
[13:38:01.875]   - Field: ‘asynchronous’
[13:38:01.875]   - Field: ‘calls’
[13:38:01.876]   - Field: ‘globals’
[13:38:01.876]   - Field: ‘stdout’
[13:38:01.876]   - Field: ‘earlySignal’
[13:38:01.876]   - Field: ‘lazy’
[13:38:01.876]   - Field: ‘state’
[13:38:01.876] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:01.876] - Launch lazy future ...
[13:38:01.876] Packages needed by the future expression (n = 0): <none>
[13:38:01.876] Packages needed by future strategies (n = 0): <none>
[13:38:01.877] {
[13:38:01.877]     {
[13:38:01.877]         {
[13:38:01.877]             ...future.startTime <- base::Sys.time()
[13:38:01.877]             {
[13:38:01.877]                 {
[13:38:01.877]                   {
[13:38:01.877]                     {
[13:38:01.877]                       base::local({
[13:38:01.877]                         has_future <- base::requireNamespace("future", 
[13:38:01.877]                           quietly = TRUE)
[13:38:01.877]                         if (has_future) {
[13:38:01.877]                           ns <- base::getNamespace("future")
[13:38:01.877]                           version <- ns[[".package"]][["version"]]
[13:38:01.877]                           if (is.null(version)) 
[13:38:01.877]                             version <- utils::packageVersion("future")
[13:38:01.877]                         }
[13:38:01.877]                         else {
[13:38:01.877]                           version <- NULL
[13:38:01.877]                         }
[13:38:01.877]                         if (!has_future || version < "1.8.0") {
[13:38:01.877]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:01.877]                             "", base::R.version$version.string), 
[13:38:01.877]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:01.877]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:01.877]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:01.877]                               "release", "version")], collapse = " "), 
[13:38:01.877]                             hostname = base::Sys.info()[["nodename"]])
[13:38:01.877]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:01.877]                             info)
[13:38:01.877]                           info <- base::paste(info, collapse = "; ")
[13:38:01.877]                           if (!has_future) {
[13:38:01.877]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:01.877]                               info)
[13:38:01.877]                           }
[13:38:01.877]                           else {
[13:38:01.877]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:01.877]                               info, version)
[13:38:01.877]                           }
[13:38:01.877]                           base::stop(msg)
[13:38:01.877]                         }
[13:38:01.877]                       })
[13:38:01.877]                     }
[13:38:01.877]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:01.877]                     base::options(mc.cores = 1L)
[13:38:01.877]                   }
[13:38:01.877]                   ...future.strategy.old <- future::plan("list")
[13:38:01.877]                   options(future.plan = NULL)
[13:38:01.877]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.877]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:01.877]                 }
[13:38:01.877]                 ...future.workdir <- getwd()
[13:38:01.877]             }
[13:38:01.877]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:01.877]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:01.877]         }
[13:38:01.877]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:01.877]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:01.877]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:01.877]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:01.877]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:01.877]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:01.877]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:01.877]             base::names(...future.oldOptions))
[13:38:01.877]     }
[13:38:01.877]     if (FALSE) {
[13:38:01.877]     }
[13:38:01.877]     else {
[13:38:01.877]         if (TRUE) {
[13:38:01.877]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:01.877]                 open = "w")
[13:38:01.877]         }
[13:38:01.877]         else {
[13:38:01.877]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:01.877]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:01.877]         }
[13:38:01.877]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:01.877]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:01.877]             base::sink(type = "output", split = FALSE)
[13:38:01.877]             base::close(...future.stdout)
[13:38:01.877]         }, add = TRUE)
[13:38:01.877]     }
[13:38:01.877]     ...future.frame <- base::sys.nframe()
[13:38:01.877]     ...future.conditions <- base::list()
[13:38:01.877]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:01.877]     if (FALSE) {
[13:38:01.877]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:01.877]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:01.877]     }
[13:38:01.877]     ...future.result <- base::tryCatch({
[13:38:01.877]         base::withCallingHandlers({
[13:38:01.877]             ...future.value <- base::withVisible(base::local({
[13:38:01.877]                 ...future.makeSendCondition <- base::local({
[13:38:01.877]                   sendCondition <- NULL
[13:38:01.877]                   function(frame = 1L) {
[13:38:01.877]                     if (is.function(sendCondition)) 
[13:38:01.877]                       return(sendCondition)
[13:38:01.877]                     ns <- getNamespace("parallel")
[13:38:01.877]                     if (exists("sendData", mode = "function", 
[13:38:01.877]                       envir = ns)) {
[13:38:01.877]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:01.877]                         envir = ns)
[13:38:01.877]                       envir <- sys.frame(frame)
[13:38:01.877]                       master <- NULL
[13:38:01.877]                       while (!identical(envir, .GlobalEnv) && 
[13:38:01.877]                         !identical(envir, emptyenv())) {
[13:38:01.877]                         if (exists("master", mode = "list", envir = envir, 
[13:38:01.877]                           inherits = FALSE)) {
[13:38:01.877]                           master <- get("master", mode = "list", 
[13:38:01.877]                             envir = envir, inherits = FALSE)
[13:38:01.877]                           if (inherits(master, c("SOCKnode", 
[13:38:01.877]                             "SOCK0node"))) {
[13:38:01.877]                             sendCondition <<- function(cond) {
[13:38:01.877]                               data <- list(type = "VALUE", value = cond, 
[13:38:01.877]                                 success = TRUE)
[13:38:01.877]                               parallel_sendData(master, data)
[13:38:01.877]                             }
[13:38:01.877]                             return(sendCondition)
[13:38:01.877]                           }
[13:38:01.877]                         }
[13:38:01.877]                         frame <- frame + 1L
[13:38:01.877]                         envir <- sys.frame(frame)
[13:38:01.877]                       }
[13:38:01.877]                     }
[13:38:01.877]                     sendCondition <<- function(cond) NULL
[13:38:01.877]                   }
[13:38:01.877]                 })
[13:38:01.877]                 withCallingHandlers({
[13:38:01.877]                   {
[13:38:01.877]                     1
[13:38:01.877]                   }
[13:38:01.877]                 }, immediateCondition = function(cond) {
[13:38:01.877]                   sendCondition <- ...future.makeSendCondition()
[13:38:01.877]                   sendCondition(cond)
[13:38:01.877]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.877]                   {
[13:38:01.877]                     inherits <- base::inherits
[13:38:01.877]                     invokeRestart <- base::invokeRestart
[13:38:01.877]                     is.null <- base::is.null
[13:38:01.877]                     muffled <- FALSE
[13:38:01.877]                     if (inherits(cond, "message")) {
[13:38:01.877]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:01.877]                       if (muffled) 
[13:38:01.877]                         invokeRestart("muffleMessage")
[13:38:01.877]                     }
[13:38:01.877]                     else if (inherits(cond, "warning")) {
[13:38:01.877]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:01.877]                       if (muffled) 
[13:38:01.877]                         invokeRestart("muffleWarning")
[13:38:01.877]                     }
[13:38:01.877]                     else if (inherits(cond, "condition")) {
[13:38:01.877]                       if (!is.null(pattern)) {
[13:38:01.877]                         computeRestarts <- base::computeRestarts
[13:38:01.877]                         grepl <- base::grepl
[13:38:01.877]                         restarts <- computeRestarts(cond)
[13:38:01.877]                         for (restart in restarts) {
[13:38:01.877]                           name <- restart$name
[13:38:01.877]                           if (is.null(name)) 
[13:38:01.877]                             next
[13:38:01.877]                           if (!grepl(pattern, name)) 
[13:38:01.877]                             next
[13:38:01.877]                           invokeRestart(restart)
[13:38:01.877]                           muffled <- TRUE
[13:38:01.877]                           break
[13:38:01.877]                         }
[13:38:01.877]                       }
[13:38:01.877]                     }
[13:38:01.877]                     invisible(muffled)
[13:38:01.877]                   }
[13:38:01.877]                   muffleCondition(cond)
[13:38:01.877]                 })
[13:38:01.877]             }))
[13:38:01.877]             future::FutureResult(value = ...future.value$value, 
[13:38:01.877]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.877]                   ...future.rng), globalenv = if (FALSE) 
[13:38:01.877]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:01.877]                     ...future.globalenv.names))
[13:38:01.877]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:01.877]         }, condition = base::local({
[13:38:01.877]             c <- base::c
[13:38:01.877]             inherits <- base::inherits
[13:38:01.877]             invokeRestart <- base::invokeRestart
[13:38:01.877]             length <- base::length
[13:38:01.877]             list <- base::list
[13:38:01.877]             seq.int <- base::seq.int
[13:38:01.877]             signalCondition <- base::signalCondition
[13:38:01.877]             sys.calls <- base::sys.calls
[13:38:01.877]             `[[` <- base::`[[`
[13:38:01.877]             `+` <- base::`+`
[13:38:01.877]             `<<-` <- base::`<<-`
[13:38:01.877]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:01.877]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:01.877]                   3L)]
[13:38:01.877]             }
[13:38:01.877]             function(cond) {
[13:38:01.877]                 is_error <- inherits(cond, "error")
[13:38:01.877]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:01.877]                   NULL)
[13:38:01.877]                 if (is_error) {
[13:38:01.877]                   sessionInformation <- function() {
[13:38:01.877]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:01.877]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:01.877]                       search = base::search(), system = base::Sys.info())
[13:38:01.877]                   }
[13:38:01.877]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.877]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:01.877]                     cond$call), session = sessionInformation(), 
[13:38:01.877]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:01.877]                   signalCondition(cond)
[13:38:01.877]                 }
[13:38:01.877]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:01.877]                 "immediateCondition"))) {
[13:38:01.877]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:01.877]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.877]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:01.877]                   if (TRUE && !signal) {
[13:38:01.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.877]                     {
[13:38:01.877]                       inherits <- base::inherits
[13:38:01.877]                       invokeRestart <- base::invokeRestart
[13:38:01.877]                       is.null <- base::is.null
[13:38:01.877]                       muffled <- FALSE
[13:38:01.877]                       if (inherits(cond, "message")) {
[13:38:01.877]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.877]                         if (muffled) 
[13:38:01.877]                           invokeRestart("muffleMessage")
[13:38:01.877]                       }
[13:38:01.877]                       else if (inherits(cond, "warning")) {
[13:38:01.877]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.877]                         if (muffled) 
[13:38:01.877]                           invokeRestart("muffleWarning")
[13:38:01.877]                       }
[13:38:01.877]                       else if (inherits(cond, "condition")) {
[13:38:01.877]                         if (!is.null(pattern)) {
[13:38:01.877]                           computeRestarts <- base::computeRestarts
[13:38:01.877]                           grepl <- base::grepl
[13:38:01.877]                           restarts <- computeRestarts(cond)
[13:38:01.877]                           for (restart in restarts) {
[13:38:01.877]                             name <- restart$name
[13:38:01.877]                             if (is.null(name)) 
[13:38:01.877]                               next
[13:38:01.877]                             if (!grepl(pattern, name)) 
[13:38:01.877]                               next
[13:38:01.877]                             invokeRestart(restart)
[13:38:01.877]                             muffled <- TRUE
[13:38:01.877]                             break
[13:38:01.877]                           }
[13:38:01.877]                         }
[13:38:01.877]                       }
[13:38:01.877]                       invisible(muffled)
[13:38:01.877]                     }
[13:38:01.877]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.877]                   }
[13:38:01.877]                 }
[13:38:01.877]                 else {
[13:38:01.877]                   if (TRUE) {
[13:38:01.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.877]                     {
[13:38:01.877]                       inherits <- base::inherits
[13:38:01.877]                       invokeRestart <- base::invokeRestart
[13:38:01.877]                       is.null <- base::is.null
[13:38:01.877]                       muffled <- FALSE
[13:38:01.877]                       if (inherits(cond, "message")) {
[13:38:01.877]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.877]                         if (muffled) 
[13:38:01.877]                           invokeRestart("muffleMessage")
[13:38:01.877]                       }
[13:38:01.877]                       else if (inherits(cond, "warning")) {
[13:38:01.877]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.877]                         if (muffled) 
[13:38:01.877]                           invokeRestart("muffleWarning")
[13:38:01.877]                       }
[13:38:01.877]                       else if (inherits(cond, "condition")) {
[13:38:01.877]                         if (!is.null(pattern)) {
[13:38:01.877]                           computeRestarts <- base::computeRestarts
[13:38:01.877]                           grepl <- base::grepl
[13:38:01.877]                           restarts <- computeRestarts(cond)
[13:38:01.877]                           for (restart in restarts) {
[13:38:01.877]                             name <- restart$name
[13:38:01.877]                             if (is.null(name)) 
[13:38:01.877]                               next
[13:38:01.877]                             if (!grepl(pattern, name)) 
[13:38:01.877]                               next
[13:38:01.877]                             invokeRestart(restart)
[13:38:01.877]                             muffled <- TRUE
[13:38:01.877]                             break
[13:38:01.877]                           }
[13:38:01.877]                         }
[13:38:01.877]                       }
[13:38:01.877]                       invisible(muffled)
[13:38:01.877]                     }
[13:38:01.877]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.877]                   }
[13:38:01.877]                 }
[13:38:01.877]             }
[13:38:01.877]         }))
[13:38:01.877]     }, error = function(ex) {
[13:38:01.877]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:01.877]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.877]                 ...future.rng), started = ...future.startTime, 
[13:38:01.877]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:01.877]             version = "1.8"), class = "FutureResult")
[13:38:01.877]     }, finally = {
[13:38:01.877]         if (!identical(...future.workdir, getwd())) 
[13:38:01.877]             setwd(...future.workdir)
[13:38:01.877]         {
[13:38:01.877]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:01.877]                 ...future.oldOptions$nwarnings <- NULL
[13:38:01.877]             }
[13:38:01.877]             base::options(...future.oldOptions)
[13:38:01.877]             if (.Platform$OS.type == "windows") {
[13:38:01.877]                 old_names <- names(...future.oldEnvVars)
[13:38:01.877]                 envs <- base::Sys.getenv()
[13:38:01.877]                 names <- names(envs)
[13:38:01.877]                 common <- intersect(names, old_names)
[13:38:01.877]                 added <- setdiff(names, old_names)
[13:38:01.877]                 removed <- setdiff(old_names, names)
[13:38:01.877]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:01.877]                   envs[common]]
[13:38:01.877]                 NAMES <- toupper(changed)
[13:38:01.877]                 args <- list()
[13:38:01.877]                 for (kk in seq_along(NAMES)) {
[13:38:01.877]                   name <- changed[[kk]]
[13:38:01.877]                   NAME <- NAMES[[kk]]
[13:38:01.877]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.877]                     next
[13:38:01.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.877]                 }
[13:38:01.877]                 NAMES <- toupper(added)
[13:38:01.877]                 for (kk in seq_along(NAMES)) {
[13:38:01.877]                   name <- added[[kk]]
[13:38:01.877]                   NAME <- NAMES[[kk]]
[13:38:01.877]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.877]                     next
[13:38:01.877]                   args[[name]] <- ""
[13:38:01.877]                 }
[13:38:01.877]                 NAMES <- toupper(removed)
[13:38:01.877]                 for (kk in seq_along(NAMES)) {
[13:38:01.877]                   name <- removed[[kk]]
[13:38:01.877]                   NAME <- NAMES[[kk]]
[13:38:01.877]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.877]                     next
[13:38:01.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.877]                 }
[13:38:01.877]                 if (length(args) > 0) 
[13:38:01.877]                   base::do.call(base::Sys.setenv, args = args)
[13:38:01.877]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:01.877]             }
[13:38:01.877]             else {
[13:38:01.877]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:01.877]             }
[13:38:01.877]             {
[13:38:01.877]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:01.877]                   0L) {
[13:38:01.877]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:01.877]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:01.877]                   base::options(opts)
[13:38:01.877]                 }
[13:38:01.877]                 {
[13:38:01.877]                   {
[13:38:01.877]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:01.877]                     NULL
[13:38:01.877]                   }
[13:38:01.877]                   options(future.plan = NULL)
[13:38:01.877]                   if (is.na(NA_character_)) 
[13:38:01.877]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.877]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:01.877]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:01.877]                     .init = FALSE)
[13:38:01.877]                 }
[13:38:01.877]             }
[13:38:01.877]         }
[13:38:01.877]     })
[13:38:01.877]     if (TRUE) {
[13:38:01.877]         base::sink(type = "output", split = FALSE)
[13:38:01.877]         if (TRUE) {
[13:38:01.877]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:01.877]         }
[13:38:01.877]         else {
[13:38:01.877]             ...future.result["stdout"] <- base::list(NULL)
[13:38:01.877]         }
[13:38:01.877]         base::close(...future.stdout)
[13:38:01.877]         ...future.stdout <- NULL
[13:38:01.877]     }
[13:38:01.877]     ...future.result$conditions <- ...future.conditions
[13:38:01.877]     ...future.result$finished <- base::Sys.time()
[13:38:01.877]     ...future.result
[13:38:01.877] }
[13:38:01.880] MultisessionFuture started
[13:38:01.880] - Launch lazy future ... done
[13:38:01.880] run() for ‘MultisessionFuture’ ... done
[13:38:01.880] getGlobalsAndPackages() ...
[13:38:01.880] Searching for globals...
[13:38:01.881] - globals found: [1] ‘{’
[13:38:01.881] Searching for globals ... DONE
[13:38:01.881] Resolving globals: FALSE
[13:38:01.881] 
[13:38:01.881] 
[13:38:01.882] getGlobalsAndPackages() ... DONE
[13:38:01.882] run() for ‘Future’ ...
[13:38:01.882] - state: ‘created’
[13:38:01.882] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:01.896] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:01.896] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:01.896]   - Field: ‘node’
[13:38:01.896]   - Field: ‘label’
[13:38:01.896]   - Field: ‘local’
[13:38:01.896]   - Field: ‘owner’
[13:38:01.897]   - Field: ‘envir’
[13:38:01.897]   - Field: ‘workers’
[13:38:01.897]   - Field: ‘packages’
[13:38:01.897]   - Field: ‘gc’
[13:38:01.897]   - Field: ‘conditions’
[13:38:01.897]   - Field: ‘persistent’
[13:38:01.897]   - Field: ‘expr’
[13:38:01.897]   - Field: ‘uuid’
[13:38:01.897]   - Field: ‘seed’
[13:38:01.897]   - Field: ‘version’
[13:38:01.897]   - Field: ‘result’
[13:38:01.898]   - Field: ‘asynchronous’
[13:38:01.898]   - Field: ‘calls’
[13:38:01.898]   - Field: ‘globals’
[13:38:01.898]   - Field: ‘stdout’
[13:38:01.898]   - Field: ‘earlySignal’
[13:38:01.898]   - Field: ‘lazy’
[13:38:01.898]   - Field: ‘state’
[13:38:01.898] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:01.898] - Launch lazy future ...
[13:38:01.899] Packages needed by the future expression (n = 0): <none>
[13:38:01.899] Packages needed by future strategies (n = 0): <none>
[13:38:01.899] {
[13:38:01.899]     {
[13:38:01.899]         {
[13:38:01.899]             ...future.startTime <- base::Sys.time()
[13:38:01.899]             {
[13:38:01.899]                 {
[13:38:01.899]                   {
[13:38:01.899]                     {
[13:38:01.899]                       base::local({
[13:38:01.899]                         has_future <- base::requireNamespace("future", 
[13:38:01.899]                           quietly = TRUE)
[13:38:01.899]                         if (has_future) {
[13:38:01.899]                           ns <- base::getNamespace("future")
[13:38:01.899]                           version <- ns[[".package"]][["version"]]
[13:38:01.899]                           if (is.null(version)) 
[13:38:01.899]                             version <- utils::packageVersion("future")
[13:38:01.899]                         }
[13:38:01.899]                         else {
[13:38:01.899]                           version <- NULL
[13:38:01.899]                         }
[13:38:01.899]                         if (!has_future || version < "1.8.0") {
[13:38:01.899]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:01.899]                             "", base::R.version$version.string), 
[13:38:01.899]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:01.899]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:01.899]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:01.899]                               "release", "version")], collapse = " "), 
[13:38:01.899]                             hostname = base::Sys.info()[["nodename"]])
[13:38:01.899]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:01.899]                             info)
[13:38:01.899]                           info <- base::paste(info, collapse = "; ")
[13:38:01.899]                           if (!has_future) {
[13:38:01.899]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:01.899]                               info)
[13:38:01.899]                           }
[13:38:01.899]                           else {
[13:38:01.899]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:01.899]                               info, version)
[13:38:01.899]                           }
[13:38:01.899]                           base::stop(msg)
[13:38:01.899]                         }
[13:38:01.899]                       })
[13:38:01.899]                     }
[13:38:01.899]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:01.899]                     base::options(mc.cores = 1L)
[13:38:01.899]                   }
[13:38:01.899]                   ...future.strategy.old <- future::plan("list")
[13:38:01.899]                   options(future.plan = NULL)
[13:38:01.899]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.899]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:01.899]                 }
[13:38:01.899]                 ...future.workdir <- getwd()
[13:38:01.899]             }
[13:38:01.899]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:01.899]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:01.899]         }
[13:38:01.899]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:01.899]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:01.899]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:01.899]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:01.899]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:01.899]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:01.899]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:01.899]             base::names(...future.oldOptions))
[13:38:01.899]     }
[13:38:01.899]     if (FALSE) {
[13:38:01.899]     }
[13:38:01.899]     else {
[13:38:01.899]         if (TRUE) {
[13:38:01.899]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:01.899]                 open = "w")
[13:38:01.899]         }
[13:38:01.899]         else {
[13:38:01.899]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:01.899]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:01.899]         }
[13:38:01.899]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:01.899]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:01.899]             base::sink(type = "output", split = FALSE)
[13:38:01.899]             base::close(...future.stdout)
[13:38:01.899]         }, add = TRUE)
[13:38:01.899]     }
[13:38:01.899]     ...future.frame <- base::sys.nframe()
[13:38:01.899]     ...future.conditions <- base::list()
[13:38:01.899]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:01.899]     if (FALSE) {
[13:38:01.899]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:01.899]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:01.899]     }
[13:38:01.899]     ...future.result <- base::tryCatch({
[13:38:01.899]         base::withCallingHandlers({
[13:38:01.899]             ...future.value <- base::withVisible(base::local({
[13:38:01.899]                 ...future.makeSendCondition <- base::local({
[13:38:01.899]                   sendCondition <- NULL
[13:38:01.899]                   function(frame = 1L) {
[13:38:01.899]                     if (is.function(sendCondition)) 
[13:38:01.899]                       return(sendCondition)
[13:38:01.899]                     ns <- getNamespace("parallel")
[13:38:01.899]                     if (exists("sendData", mode = "function", 
[13:38:01.899]                       envir = ns)) {
[13:38:01.899]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:01.899]                         envir = ns)
[13:38:01.899]                       envir <- sys.frame(frame)
[13:38:01.899]                       master <- NULL
[13:38:01.899]                       while (!identical(envir, .GlobalEnv) && 
[13:38:01.899]                         !identical(envir, emptyenv())) {
[13:38:01.899]                         if (exists("master", mode = "list", envir = envir, 
[13:38:01.899]                           inherits = FALSE)) {
[13:38:01.899]                           master <- get("master", mode = "list", 
[13:38:01.899]                             envir = envir, inherits = FALSE)
[13:38:01.899]                           if (inherits(master, c("SOCKnode", 
[13:38:01.899]                             "SOCK0node"))) {
[13:38:01.899]                             sendCondition <<- function(cond) {
[13:38:01.899]                               data <- list(type = "VALUE", value = cond, 
[13:38:01.899]                                 success = TRUE)
[13:38:01.899]                               parallel_sendData(master, data)
[13:38:01.899]                             }
[13:38:01.899]                             return(sendCondition)
[13:38:01.899]                           }
[13:38:01.899]                         }
[13:38:01.899]                         frame <- frame + 1L
[13:38:01.899]                         envir <- sys.frame(frame)
[13:38:01.899]                       }
[13:38:01.899]                     }
[13:38:01.899]                     sendCondition <<- function(cond) NULL
[13:38:01.899]                   }
[13:38:01.899]                 })
[13:38:01.899]                 withCallingHandlers({
[13:38:01.899]                   {
[13:38:01.899]                     2
[13:38:01.899]                   }
[13:38:01.899]                 }, immediateCondition = function(cond) {
[13:38:01.899]                   sendCondition <- ...future.makeSendCondition()
[13:38:01.899]                   sendCondition(cond)
[13:38:01.899]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.899]                   {
[13:38:01.899]                     inherits <- base::inherits
[13:38:01.899]                     invokeRestart <- base::invokeRestart
[13:38:01.899]                     is.null <- base::is.null
[13:38:01.899]                     muffled <- FALSE
[13:38:01.899]                     if (inherits(cond, "message")) {
[13:38:01.899]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:01.899]                       if (muffled) 
[13:38:01.899]                         invokeRestart("muffleMessage")
[13:38:01.899]                     }
[13:38:01.899]                     else if (inherits(cond, "warning")) {
[13:38:01.899]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:01.899]                       if (muffled) 
[13:38:01.899]                         invokeRestart("muffleWarning")
[13:38:01.899]                     }
[13:38:01.899]                     else if (inherits(cond, "condition")) {
[13:38:01.899]                       if (!is.null(pattern)) {
[13:38:01.899]                         computeRestarts <- base::computeRestarts
[13:38:01.899]                         grepl <- base::grepl
[13:38:01.899]                         restarts <- computeRestarts(cond)
[13:38:01.899]                         for (restart in restarts) {
[13:38:01.899]                           name <- restart$name
[13:38:01.899]                           if (is.null(name)) 
[13:38:01.899]                             next
[13:38:01.899]                           if (!grepl(pattern, name)) 
[13:38:01.899]                             next
[13:38:01.899]                           invokeRestart(restart)
[13:38:01.899]                           muffled <- TRUE
[13:38:01.899]                           break
[13:38:01.899]                         }
[13:38:01.899]                       }
[13:38:01.899]                     }
[13:38:01.899]                     invisible(muffled)
[13:38:01.899]                   }
[13:38:01.899]                   muffleCondition(cond)
[13:38:01.899]                 })
[13:38:01.899]             }))
[13:38:01.899]             future::FutureResult(value = ...future.value$value, 
[13:38:01.899]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.899]                   ...future.rng), globalenv = if (FALSE) 
[13:38:01.899]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:01.899]                     ...future.globalenv.names))
[13:38:01.899]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:01.899]         }, condition = base::local({
[13:38:01.899]             c <- base::c
[13:38:01.899]             inherits <- base::inherits
[13:38:01.899]             invokeRestart <- base::invokeRestart
[13:38:01.899]             length <- base::length
[13:38:01.899]             list <- base::list
[13:38:01.899]             seq.int <- base::seq.int
[13:38:01.899]             signalCondition <- base::signalCondition
[13:38:01.899]             sys.calls <- base::sys.calls
[13:38:01.899]             `[[` <- base::`[[`
[13:38:01.899]             `+` <- base::`+`
[13:38:01.899]             `<<-` <- base::`<<-`
[13:38:01.899]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:01.899]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:01.899]                   3L)]
[13:38:01.899]             }
[13:38:01.899]             function(cond) {
[13:38:01.899]                 is_error <- inherits(cond, "error")
[13:38:01.899]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:01.899]                   NULL)
[13:38:01.899]                 if (is_error) {
[13:38:01.899]                   sessionInformation <- function() {
[13:38:01.899]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:01.899]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:01.899]                       search = base::search(), system = base::Sys.info())
[13:38:01.899]                   }
[13:38:01.899]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.899]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:01.899]                     cond$call), session = sessionInformation(), 
[13:38:01.899]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:01.899]                   signalCondition(cond)
[13:38:01.899]                 }
[13:38:01.899]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:01.899]                 "immediateCondition"))) {
[13:38:01.899]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:01.899]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.899]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:01.899]                   if (TRUE && !signal) {
[13:38:01.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.899]                     {
[13:38:01.899]                       inherits <- base::inherits
[13:38:01.899]                       invokeRestart <- base::invokeRestart
[13:38:01.899]                       is.null <- base::is.null
[13:38:01.899]                       muffled <- FALSE
[13:38:01.899]                       if (inherits(cond, "message")) {
[13:38:01.899]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.899]                         if (muffled) 
[13:38:01.899]                           invokeRestart("muffleMessage")
[13:38:01.899]                       }
[13:38:01.899]                       else if (inherits(cond, "warning")) {
[13:38:01.899]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.899]                         if (muffled) 
[13:38:01.899]                           invokeRestart("muffleWarning")
[13:38:01.899]                       }
[13:38:01.899]                       else if (inherits(cond, "condition")) {
[13:38:01.899]                         if (!is.null(pattern)) {
[13:38:01.899]                           computeRestarts <- base::computeRestarts
[13:38:01.899]                           grepl <- base::grepl
[13:38:01.899]                           restarts <- computeRestarts(cond)
[13:38:01.899]                           for (restart in restarts) {
[13:38:01.899]                             name <- restart$name
[13:38:01.899]                             if (is.null(name)) 
[13:38:01.899]                               next
[13:38:01.899]                             if (!grepl(pattern, name)) 
[13:38:01.899]                               next
[13:38:01.899]                             invokeRestart(restart)
[13:38:01.899]                             muffled <- TRUE
[13:38:01.899]                             break
[13:38:01.899]                           }
[13:38:01.899]                         }
[13:38:01.899]                       }
[13:38:01.899]                       invisible(muffled)
[13:38:01.899]                     }
[13:38:01.899]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.899]                   }
[13:38:01.899]                 }
[13:38:01.899]                 else {
[13:38:01.899]                   if (TRUE) {
[13:38:01.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.899]                     {
[13:38:01.899]                       inherits <- base::inherits
[13:38:01.899]                       invokeRestart <- base::invokeRestart
[13:38:01.899]                       is.null <- base::is.null
[13:38:01.899]                       muffled <- FALSE
[13:38:01.899]                       if (inherits(cond, "message")) {
[13:38:01.899]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.899]                         if (muffled) 
[13:38:01.899]                           invokeRestart("muffleMessage")
[13:38:01.899]                       }
[13:38:01.899]                       else if (inherits(cond, "warning")) {
[13:38:01.899]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.899]                         if (muffled) 
[13:38:01.899]                           invokeRestart("muffleWarning")
[13:38:01.899]                       }
[13:38:01.899]                       else if (inherits(cond, "condition")) {
[13:38:01.899]                         if (!is.null(pattern)) {
[13:38:01.899]                           computeRestarts <- base::computeRestarts
[13:38:01.899]                           grepl <- base::grepl
[13:38:01.899]                           restarts <- computeRestarts(cond)
[13:38:01.899]                           for (restart in restarts) {
[13:38:01.899]                             name <- restart$name
[13:38:01.899]                             if (is.null(name)) 
[13:38:01.899]                               next
[13:38:01.899]                             if (!grepl(pattern, name)) 
[13:38:01.899]                               next
[13:38:01.899]                             invokeRestart(restart)
[13:38:01.899]                             muffled <- TRUE
[13:38:01.899]                             break
[13:38:01.899]                           }
[13:38:01.899]                         }
[13:38:01.899]                       }
[13:38:01.899]                       invisible(muffled)
[13:38:01.899]                     }
[13:38:01.899]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.899]                   }
[13:38:01.899]                 }
[13:38:01.899]             }
[13:38:01.899]         }))
[13:38:01.899]     }, error = function(ex) {
[13:38:01.899]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:01.899]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.899]                 ...future.rng), started = ...future.startTime, 
[13:38:01.899]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:01.899]             version = "1.8"), class = "FutureResult")
[13:38:01.899]     }, finally = {
[13:38:01.899]         if (!identical(...future.workdir, getwd())) 
[13:38:01.899]             setwd(...future.workdir)
[13:38:01.899]         {
[13:38:01.899]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:01.899]                 ...future.oldOptions$nwarnings <- NULL
[13:38:01.899]             }
[13:38:01.899]             base::options(...future.oldOptions)
[13:38:01.899]             if (.Platform$OS.type == "windows") {
[13:38:01.899]                 old_names <- names(...future.oldEnvVars)
[13:38:01.899]                 envs <- base::Sys.getenv()
[13:38:01.899]                 names <- names(envs)
[13:38:01.899]                 common <- intersect(names, old_names)
[13:38:01.899]                 added <- setdiff(names, old_names)
[13:38:01.899]                 removed <- setdiff(old_names, names)
[13:38:01.899]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:01.899]                   envs[common]]
[13:38:01.899]                 NAMES <- toupper(changed)
[13:38:01.899]                 args <- list()
[13:38:01.899]                 for (kk in seq_along(NAMES)) {
[13:38:01.899]                   name <- changed[[kk]]
[13:38:01.899]                   NAME <- NAMES[[kk]]
[13:38:01.899]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.899]                     next
[13:38:01.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.899]                 }
[13:38:01.899]                 NAMES <- toupper(added)
[13:38:01.899]                 for (kk in seq_along(NAMES)) {
[13:38:01.899]                   name <- added[[kk]]
[13:38:01.899]                   NAME <- NAMES[[kk]]
[13:38:01.899]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.899]                     next
[13:38:01.899]                   args[[name]] <- ""
[13:38:01.899]                 }
[13:38:01.899]                 NAMES <- toupper(removed)
[13:38:01.899]                 for (kk in seq_along(NAMES)) {
[13:38:01.899]                   name <- removed[[kk]]
[13:38:01.899]                   NAME <- NAMES[[kk]]
[13:38:01.899]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.899]                     next
[13:38:01.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.899]                 }
[13:38:01.899]                 if (length(args) > 0) 
[13:38:01.899]                   base::do.call(base::Sys.setenv, args = args)
[13:38:01.899]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:01.899]             }
[13:38:01.899]             else {
[13:38:01.899]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:01.899]             }
[13:38:01.899]             {
[13:38:01.899]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:01.899]                   0L) {
[13:38:01.899]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:01.899]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:01.899]                   base::options(opts)
[13:38:01.899]                 }
[13:38:01.899]                 {
[13:38:01.899]                   {
[13:38:01.899]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:01.899]                     NULL
[13:38:01.899]                   }
[13:38:01.899]                   options(future.plan = NULL)
[13:38:01.899]                   if (is.na(NA_character_)) 
[13:38:01.899]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.899]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:01.899]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:01.899]                     .init = FALSE)
[13:38:01.899]                 }
[13:38:01.899]             }
[13:38:01.899]         }
[13:38:01.899]     })
[13:38:01.899]     if (TRUE) {
[13:38:01.899]         base::sink(type = "output", split = FALSE)
[13:38:01.899]         if (TRUE) {
[13:38:01.899]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:01.899]         }
[13:38:01.899]         else {
[13:38:01.899]             ...future.result["stdout"] <- base::list(NULL)
[13:38:01.899]         }
[13:38:01.899]         base::close(...future.stdout)
[13:38:01.899]         ...future.stdout <- NULL
[13:38:01.899]     }
[13:38:01.899]     ...future.result$conditions <- ...future.conditions
[13:38:01.899]     ...future.result$finished <- base::Sys.time()
[13:38:01.899]     ...future.result
[13:38:01.899] }
[13:38:01.902] MultisessionFuture started
[13:38:01.902] - Launch lazy future ... done
[13:38:01.902] run() for ‘MultisessionFuture’ ... done
[13:38:01.903] resolve() on environment ...
[13:38:01.903]  recursive: 0
[13:38:01.903]  elements: [3] ‘a’
[13:38:01.904] receiveMessageFromWorker() for ClusterFuture ...
[13:38:01.904] - Validating connection of MultisessionFuture
[13:38:01.904] - received message: FutureResult
[13:38:01.904] - Received FutureResult
[13:38:01.904] - Erased future from FutureRegistry
[13:38:01.904] result() for ClusterFuture ...
[13:38:01.904] - result already collected: FutureResult
[13:38:01.904] result() for ClusterFuture ... done
[13:38:01.904] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:01.905] Future #1
[13:38:01.905]  length: 2 (resolved future 1)
[13:38:01.905] receiveMessageFromWorker() for ClusterFuture ...
[13:38:01.905] - Validating connection of MultisessionFuture
[13:38:01.905] - received message: FutureResult
[13:38:01.905] - Received FutureResult
[13:38:01.905] - Erased future from FutureRegistry
[13:38:01.906] result() for ClusterFuture ...
[13:38:01.906] - result already collected: FutureResult
[13:38:01.906] result() for ClusterFuture ... done
[13:38:01.906] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:01.906] Future #2
[13:38:01.906]  length: 1 (resolved future 2)
[13:38:01.906]  length: 0 (resolved future 3)
[13:38:01.906] resolve() on environment ... DONE
[13:38:01.907] resolve() on environment ...
[13:38:01.907]  recursive: 0
[13:38:01.907]  elements: [3] ‘b’
[13:38:01.907] Future #1
[13:38:01.907]  length: 2 (resolved future 1)
[13:38:01.908] Future #2
[13:38:01.908]  length: 1 (resolved future 2)
[13:38:01.908]  length: 0 (resolved future 3)
[13:38:01.908] resolve() on environment ... DONE
[13:38:01.908] resolve() on environment ...
[13:38:01.908]  recursive: 0
[13:38:01.909]  elements: [3] ‘c’
[13:38:01.909] Future #1
[13:38:01.909]  length: 2 (resolved future 1)
[13:38:01.909] Future #2
[13:38:01.909]  length: 1 (resolved future 2)
[13:38:01.909]  length: 0 (resolved future 3)
[13:38:01.909] resolve() on environment ... DONE
[13:38:01.910] resolve() on environment ...
[13:38:01.910]  recursive: 0
[13:38:01.910]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[13:38:01.911] Future #1
[13:38:01.911] result() for ClusterFuture ...
[13:38:01.911] - result already collected: FutureResult
[13:38:01.911] result() for ClusterFuture ... done
[13:38:01.911] result() for ClusterFuture ...
[13:38:01.911] - result already collected: FutureResult
[13:38:01.911] result() for ClusterFuture ... done
[13:38:01.911]  length: 2 (resolved future 1)
[13:38:01.911] Future #2
[13:38:01.911] result() for ClusterFuture ...
[13:38:01.911] - result already collected: FutureResult
[13:38:01.912] result() for ClusterFuture ... done
[13:38:01.912] result() for ClusterFuture ...
[13:38:01.912] - result already collected: FutureResult
[13:38:01.912] result() for ClusterFuture ... done
[13:38:01.912]  length: 1 (resolved future 2)
[13:38:01.912]  length: 0 (resolved future 3)
[13:38:01.912] resolve() on environment ... DONE
[13:38:01.913] resolve() on environment ...
[13:38:01.913]  recursive: 99
[13:38:01.913]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[13:38:01.913] Future #1
[13:38:01.913] result() for ClusterFuture ...
[13:38:01.913] - result already collected: FutureResult
[13:38:01.913] result() for ClusterFuture ... done
[13:38:01.914] result() for ClusterFuture ...
[13:38:01.914] - result already collected: FutureResult
[13:38:01.914] result() for ClusterFuture ... done
[13:38:01.914] A MultisessionFuture was resolved
[13:38:01.914]  length: 2 (resolved future 1)
[13:38:01.914] Future #2
[13:38:01.914] result() for ClusterFuture ...
[13:38:01.914] - result already collected: FutureResult
[13:38:01.914] result() for ClusterFuture ... done
[13:38:01.914] result() for ClusterFuture ...
[13:38:01.915] - result already collected: FutureResult
[13:38:01.915] result() for ClusterFuture ... done
[13:38:01.915] A MultisessionFuture was resolved
[13:38:01.915]  length: 1 (resolved future 2)
[13:38:01.915]  length: 0 (resolved future 3)
[13:38:01.915] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[13:38:01.916] resolve() on list environment ...
[13:38:01.916]  recursive: 0
[13:38:01.916]  length: 2
[13:38:01.916]  elements: ‘a’, ‘b’
[13:38:01.916]  length: 1 (resolved future 1)
[13:38:01.917]  length: 0 (resolved future 2)
[13:38:01.917] resolve() on list environment ... DONE
[13:38:01.917] getGlobalsAndPackages() ...
[13:38:01.917] Searching for globals...
[13:38:01.917] 
[13:38:01.917] Searching for globals ... DONE
[13:38:01.917] - globals: [0] <none>
[13:38:01.917] getGlobalsAndPackages() ... DONE
[13:38:01.918] run() for ‘Future’ ...
[13:38:01.918] - state: ‘created’
[13:38:01.918] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:01.931] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:01.931] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:01.931]   - Field: ‘node’
[13:38:01.931]   - Field: ‘label’
[13:38:01.931]   - Field: ‘local’
[13:38:01.932]   - Field: ‘owner’
[13:38:01.932]   - Field: ‘envir’
[13:38:01.932]   - Field: ‘workers’
[13:38:01.932]   - Field: ‘packages’
[13:38:01.932]   - Field: ‘gc’
[13:38:01.932]   - Field: ‘conditions’
[13:38:01.932]   - Field: ‘persistent’
[13:38:01.932]   - Field: ‘expr’
[13:38:01.932]   - Field: ‘uuid’
[13:38:01.932]   - Field: ‘seed’
[13:38:01.932]   - Field: ‘version’
[13:38:01.933]   - Field: ‘result’
[13:38:01.933]   - Field: ‘asynchronous’
[13:38:01.933]   - Field: ‘calls’
[13:38:01.933]   - Field: ‘globals’
[13:38:01.933]   - Field: ‘stdout’
[13:38:01.933]   - Field: ‘earlySignal’
[13:38:01.933]   - Field: ‘lazy’
[13:38:01.933]   - Field: ‘state’
[13:38:01.933] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:01.933] - Launch lazy future ...
[13:38:01.934] Packages needed by the future expression (n = 0): <none>
[13:38:01.934] Packages needed by future strategies (n = 0): <none>
[13:38:01.934] {
[13:38:01.934]     {
[13:38:01.934]         {
[13:38:01.934]             ...future.startTime <- base::Sys.time()
[13:38:01.934]             {
[13:38:01.934]                 {
[13:38:01.934]                   {
[13:38:01.934]                     {
[13:38:01.934]                       base::local({
[13:38:01.934]                         has_future <- base::requireNamespace("future", 
[13:38:01.934]                           quietly = TRUE)
[13:38:01.934]                         if (has_future) {
[13:38:01.934]                           ns <- base::getNamespace("future")
[13:38:01.934]                           version <- ns[[".package"]][["version"]]
[13:38:01.934]                           if (is.null(version)) 
[13:38:01.934]                             version <- utils::packageVersion("future")
[13:38:01.934]                         }
[13:38:01.934]                         else {
[13:38:01.934]                           version <- NULL
[13:38:01.934]                         }
[13:38:01.934]                         if (!has_future || version < "1.8.0") {
[13:38:01.934]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:01.934]                             "", base::R.version$version.string), 
[13:38:01.934]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:01.934]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:01.934]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:01.934]                               "release", "version")], collapse = " "), 
[13:38:01.934]                             hostname = base::Sys.info()[["nodename"]])
[13:38:01.934]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:01.934]                             info)
[13:38:01.934]                           info <- base::paste(info, collapse = "; ")
[13:38:01.934]                           if (!has_future) {
[13:38:01.934]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:01.934]                               info)
[13:38:01.934]                           }
[13:38:01.934]                           else {
[13:38:01.934]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:01.934]                               info, version)
[13:38:01.934]                           }
[13:38:01.934]                           base::stop(msg)
[13:38:01.934]                         }
[13:38:01.934]                       })
[13:38:01.934]                     }
[13:38:01.934]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:01.934]                     base::options(mc.cores = 1L)
[13:38:01.934]                   }
[13:38:01.934]                   ...future.strategy.old <- future::plan("list")
[13:38:01.934]                   options(future.plan = NULL)
[13:38:01.934]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.934]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:01.934]                 }
[13:38:01.934]                 ...future.workdir <- getwd()
[13:38:01.934]             }
[13:38:01.934]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:01.934]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:01.934]         }
[13:38:01.934]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:01.934]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:01.934]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:01.934]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:01.934]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:01.934]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:01.934]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:01.934]             base::names(...future.oldOptions))
[13:38:01.934]     }
[13:38:01.934]     if (FALSE) {
[13:38:01.934]     }
[13:38:01.934]     else {
[13:38:01.934]         if (TRUE) {
[13:38:01.934]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:01.934]                 open = "w")
[13:38:01.934]         }
[13:38:01.934]         else {
[13:38:01.934]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:01.934]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:01.934]         }
[13:38:01.934]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:01.934]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:01.934]             base::sink(type = "output", split = FALSE)
[13:38:01.934]             base::close(...future.stdout)
[13:38:01.934]         }, add = TRUE)
[13:38:01.934]     }
[13:38:01.934]     ...future.frame <- base::sys.nframe()
[13:38:01.934]     ...future.conditions <- base::list()
[13:38:01.934]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:01.934]     if (FALSE) {
[13:38:01.934]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:01.934]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:01.934]     }
[13:38:01.934]     ...future.result <- base::tryCatch({
[13:38:01.934]         base::withCallingHandlers({
[13:38:01.934]             ...future.value <- base::withVisible(base::local({
[13:38:01.934]                 ...future.makeSendCondition <- base::local({
[13:38:01.934]                   sendCondition <- NULL
[13:38:01.934]                   function(frame = 1L) {
[13:38:01.934]                     if (is.function(sendCondition)) 
[13:38:01.934]                       return(sendCondition)
[13:38:01.934]                     ns <- getNamespace("parallel")
[13:38:01.934]                     if (exists("sendData", mode = "function", 
[13:38:01.934]                       envir = ns)) {
[13:38:01.934]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:01.934]                         envir = ns)
[13:38:01.934]                       envir <- sys.frame(frame)
[13:38:01.934]                       master <- NULL
[13:38:01.934]                       while (!identical(envir, .GlobalEnv) && 
[13:38:01.934]                         !identical(envir, emptyenv())) {
[13:38:01.934]                         if (exists("master", mode = "list", envir = envir, 
[13:38:01.934]                           inherits = FALSE)) {
[13:38:01.934]                           master <- get("master", mode = "list", 
[13:38:01.934]                             envir = envir, inherits = FALSE)
[13:38:01.934]                           if (inherits(master, c("SOCKnode", 
[13:38:01.934]                             "SOCK0node"))) {
[13:38:01.934]                             sendCondition <<- function(cond) {
[13:38:01.934]                               data <- list(type = "VALUE", value = cond, 
[13:38:01.934]                                 success = TRUE)
[13:38:01.934]                               parallel_sendData(master, data)
[13:38:01.934]                             }
[13:38:01.934]                             return(sendCondition)
[13:38:01.934]                           }
[13:38:01.934]                         }
[13:38:01.934]                         frame <- frame + 1L
[13:38:01.934]                         envir <- sys.frame(frame)
[13:38:01.934]                       }
[13:38:01.934]                     }
[13:38:01.934]                     sendCondition <<- function(cond) NULL
[13:38:01.934]                   }
[13:38:01.934]                 })
[13:38:01.934]                 withCallingHandlers({
[13:38:01.934]                   1
[13:38:01.934]                 }, immediateCondition = function(cond) {
[13:38:01.934]                   sendCondition <- ...future.makeSendCondition()
[13:38:01.934]                   sendCondition(cond)
[13:38:01.934]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.934]                   {
[13:38:01.934]                     inherits <- base::inherits
[13:38:01.934]                     invokeRestart <- base::invokeRestart
[13:38:01.934]                     is.null <- base::is.null
[13:38:01.934]                     muffled <- FALSE
[13:38:01.934]                     if (inherits(cond, "message")) {
[13:38:01.934]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:01.934]                       if (muffled) 
[13:38:01.934]                         invokeRestart("muffleMessage")
[13:38:01.934]                     }
[13:38:01.934]                     else if (inherits(cond, "warning")) {
[13:38:01.934]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:01.934]                       if (muffled) 
[13:38:01.934]                         invokeRestart("muffleWarning")
[13:38:01.934]                     }
[13:38:01.934]                     else if (inherits(cond, "condition")) {
[13:38:01.934]                       if (!is.null(pattern)) {
[13:38:01.934]                         computeRestarts <- base::computeRestarts
[13:38:01.934]                         grepl <- base::grepl
[13:38:01.934]                         restarts <- computeRestarts(cond)
[13:38:01.934]                         for (restart in restarts) {
[13:38:01.934]                           name <- restart$name
[13:38:01.934]                           if (is.null(name)) 
[13:38:01.934]                             next
[13:38:01.934]                           if (!grepl(pattern, name)) 
[13:38:01.934]                             next
[13:38:01.934]                           invokeRestart(restart)
[13:38:01.934]                           muffled <- TRUE
[13:38:01.934]                           break
[13:38:01.934]                         }
[13:38:01.934]                       }
[13:38:01.934]                     }
[13:38:01.934]                     invisible(muffled)
[13:38:01.934]                   }
[13:38:01.934]                   muffleCondition(cond)
[13:38:01.934]                 })
[13:38:01.934]             }))
[13:38:01.934]             future::FutureResult(value = ...future.value$value, 
[13:38:01.934]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.934]                   ...future.rng), globalenv = if (FALSE) 
[13:38:01.934]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:01.934]                     ...future.globalenv.names))
[13:38:01.934]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:01.934]         }, condition = base::local({
[13:38:01.934]             c <- base::c
[13:38:01.934]             inherits <- base::inherits
[13:38:01.934]             invokeRestart <- base::invokeRestart
[13:38:01.934]             length <- base::length
[13:38:01.934]             list <- base::list
[13:38:01.934]             seq.int <- base::seq.int
[13:38:01.934]             signalCondition <- base::signalCondition
[13:38:01.934]             sys.calls <- base::sys.calls
[13:38:01.934]             `[[` <- base::`[[`
[13:38:01.934]             `+` <- base::`+`
[13:38:01.934]             `<<-` <- base::`<<-`
[13:38:01.934]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:01.934]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:01.934]                   3L)]
[13:38:01.934]             }
[13:38:01.934]             function(cond) {
[13:38:01.934]                 is_error <- inherits(cond, "error")
[13:38:01.934]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:01.934]                   NULL)
[13:38:01.934]                 if (is_error) {
[13:38:01.934]                   sessionInformation <- function() {
[13:38:01.934]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:01.934]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:01.934]                       search = base::search(), system = base::Sys.info())
[13:38:01.934]                   }
[13:38:01.934]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.934]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:01.934]                     cond$call), session = sessionInformation(), 
[13:38:01.934]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:01.934]                   signalCondition(cond)
[13:38:01.934]                 }
[13:38:01.934]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:01.934]                 "immediateCondition"))) {
[13:38:01.934]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:01.934]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.934]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:01.934]                   if (TRUE && !signal) {
[13:38:01.934]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.934]                     {
[13:38:01.934]                       inherits <- base::inherits
[13:38:01.934]                       invokeRestart <- base::invokeRestart
[13:38:01.934]                       is.null <- base::is.null
[13:38:01.934]                       muffled <- FALSE
[13:38:01.934]                       if (inherits(cond, "message")) {
[13:38:01.934]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.934]                         if (muffled) 
[13:38:01.934]                           invokeRestart("muffleMessage")
[13:38:01.934]                       }
[13:38:01.934]                       else if (inherits(cond, "warning")) {
[13:38:01.934]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.934]                         if (muffled) 
[13:38:01.934]                           invokeRestart("muffleWarning")
[13:38:01.934]                       }
[13:38:01.934]                       else if (inherits(cond, "condition")) {
[13:38:01.934]                         if (!is.null(pattern)) {
[13:38:01.934]                           computeRestarts <- base::computeRestarts
[13:38:01.934]                           grepl <- base::grepl
[13:38:01.934]                           restarts <- computeRestarts(cond)
[13:38:01.934]                           for (restart in restarts) {
[13:38:01.934]                             name <- restart$name
[13:38:01.934]                             if (is.null(name)) 
[13:38:01.934]                               next
[13:38:01.934]                             if (!grepl(pattern, name)) 
[13:38:01.934]                               next
[13:38:01.934]                             invokeRestart(restart)
[13:38:01.934]                             muffled <- TRUE
[13:38:01.934]                             break
[13:38:01.934]                           }
[13:38:01.934]                         }
[13:38:01.934]                       }
[13:38:01.934]                       invisible(muffled)
[13:38:01.934]                     }
[13:38:01.934]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.934]                   }
[13:38:01.934]                 }
[13:38:01.934]                 else {
[13:38:01.934]                   if (TRUE) {
[13:38:01.934]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.934]                     {
[13:38:01.934]                       inherits <- base::inherits
[13:38:01.934]                       invokeRestart <- base::invokeRestart
[13:38:01.934]                       is.null <- base::is.null
[13:38:01.934]                       muffled <- FALSE
[13:38:01.934]                       if (inherits(cond, "message")) {
[13:38:01.934]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.934]                         if (muffled) 
[13:38:01.934]                           invokeRestart("muffleMessage")
[13:38:01.934]                       }
[13:38:01.934]                       else if (inherits(cond, "warning")) {
[13:38:01.934]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.934]                         if (muffled) 
[13:38:01.934]                           invokeRestart("muffleWarning")
[13:38:01.934]                       }
[13:38:01.934]                       else if (inherits(cond, "condition")) {
[13:38:01.934]                         if (!is.null(pattern)) {
[13:38:01.934]                           computeRestarts <- base::computeRestarts
[13:38:01.934]                           grepl <- base::grepl
[13:38:01.934]                           restarts <- computeRestarts(cond)
[13:38:01.934]                           for (restart in restarts) {
[13:38:01.934]                             name <- restart$name
[13:38:01.934]                             if (is.null(name)) 
[13:38:01.934]                               next
[13:38:01.934]                             if (!grepl(pattern, name)) 
[13:38:01.934]                               next
[13:38:01.934]                             invokeRestart(restart)
[13:38:01.934]                             muffled <- TRUE
[13:38:01.934]                             break
[13:38:01.934]                           }
[13:38:01.934]                         }
[13:38:01.934]                       }
[13:38:01.934]                       invisible(muffled)
[13:38:01.934]                     }
[13:38:01.934]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.934]                   }
[13:38:01.934]                 }
[13:38:01.934]             }
[13:38:01.934]         }))
[13:38:01.934]     }, error = function(ex) {
[13:38:01.934]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:01.934]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.934]                 ...future.rng), started = ...future.startTime, 
[13:38:01.934]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:01.934]             version = "1.8"), class = "FutureResult")
[13:38:01.934]     }, finally = {
[13:38:01.934]         if (!identical(...future.workdir, getwd())) 
[13:38:01.934]             setwd(...future.workdir)
[13:38:01.934]         {
[13:38:01.934]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:01.934]                 ...future.oldOptions$nwarnings <- NULL
[13:38:01.934]             }
[13:38:01.934]             base::options(...future.oldOptions)
[13:38:01.934]             if (.Platform$OS.type == "windows") {
[13:38:01.934]                 old_names <- names(...future.oldEnvVars)
[13:38:01.934]                 envs <- base::Sys.getenv()
[13:38:01.934]                 names <- names(envs)
[13:38:01.934]                 common <- intersect(names, old_names)
[13:38:01.934]                 added <- setdiff(names, old_names)
[13:38:01.934]                 removed <- setdiff(old_names, names)
[13:38:01.934]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:01.934]                   envs[common]]
[13:38:01.934]                 NAMES <- toupper(changed)
[13:38:01.934]                 args <- list()
[13:38:01.934]                 for (kk in seq_along(NAMES)) {
[13:38:01.934]                   name <- changed[[kk]]
[13:38:01.934]                   NAME <- NAMES[[kk]]
[13:38:01.934]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.934]                     next
[13:38:01.934]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.934]                 }
[13:38:01.934]                 NAMES <- toupper(added)
[13:38:01.934]                 for (kk in seq_along(NAMES)) {
[13:38:01.934]                   name <- added[[kk]]
[13:38:01.934]                   NAME <- NAMES[[kk]]
[13:38:01.934]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.934]                     next
[13:38:01.934]                   args[[name]] <- ""
[13:38:01.934]                 }
[13:38:01.934]                 NAMES <- toupper(removed)
[13:38:01.934]                 for (kk in seq_along(NAMES)) {
[13:38:01.934]                   name <- removed[[kk]]
[13:38:01.934]                   NAME <- NAMES[[kk]]
[13:38:01.934]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.934]                     next
[13:38:01.934]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.934]                 }
[13:38:01.934]                 if (length(args) > 0) 
[13:38:01.934]                   base::do.call(base::Sys.setenv, args = args)
[13:38:01.934]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:01.934]             }
[13:38:01.934]             else {
[13:38:01.934]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:01.934]             }
[13:38:01.934]             {
[13:38:01.934]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:01.934]                   0L) {
[13:38:01.934]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:01.934]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:01.934]                   base::options(opts)
[13:38:01.934]                 }
[13:38:01.934]                 {
[13:38:01.934]                   {
[13:38:01.934]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:01.934]                     NULL
[13:38:01.934]                   }
[13:38:01.934]                   options(future.plan = NULL)
[13:38:01.934]                   if (is.na(NA_character_)) 
[13:38:01.934]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.934]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:01.934]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:01.934]                     .init = FALSE)
[13:38:01.934]                 }
[13:38:01.934]             }
[13:38:01.934]         }
[13:38:01.934]     })
[13:38:01.934]     if (TRUE) {
[13:38:01.934]         base::sink(type = "output", split = FALSE)
[13:38:01.934]         if (TRUE) {
[13:38:01.934]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:01.934]         }
[13:38:01.934]         else {
[13:38:01.934]             ...future.result["stdout"] <- base::list(NULL)
[13:38:01.934]         }
[13:38:01.934]         base::close(...future.stdout)
[13:38:01.934]         ...future.stdout <- NULL
[13:38:01.934]     }
[13:38:01.934]     ...future.result$conditions <- ...future.conditions
[13:38:01.934]     ...future.result$finished <- base::Sys.time()
[13:38:01.934]     ...future.result
[13:38:01.934] }
[13:38:01.937] MultisessionFuture started
[13:38:01.937] - Launch lazy future ... done
[13:38:01.937] run() for ‘MultisessionFuture’ ... done
[13:38:01.937] getGlobalsAndPackages() ...
[13:38:01.937] Searching for globals...
[13:38:01.938] 
[13:38:01.938] Searching for globals ... DONE
[13:38:01.938] - globals: [0] <none>
[13:38:01.938] getGlobalsAndPackages() ... DONE
[13:38:01.938] run() for ‘Future’ ...
[13:38:01.938] - state: ‘created’
[13:38:01.938] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:01.951] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:01.952] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:01.952]   - Field: ‘node’
[13:38:01.952]   - Field: ‘label’
[13:38:01.952]   - Field: ‘local’
[13:38:01.952]   - Field: ‘owner’
[13:38:01.952]   - Field: ‘envir’
[13:38:01.952]   - Field: ‘workers’
[13:38:01.952]   - Field: ‘packages’
[13:38:01.952]   - Field: ‘gc’
[13:38:01.952]   - Field: ‘conditions’
[13:38:01.953]   - Field: ‘persistent’
[13:38:01.953]   - Field: ‘expr’
[13:38:01.953]   - Field: ‘uuid’
[13:38:01.953]   - Field: ‘seed’
[13:38:01.953]   - Field: ‘version’
[13:38:01.953]   - Field: ‘result’
[13:38:01.953]   - Field: ‘asynchronous’
[13:38:01.953]   - Field: ‘calls’
[13:38:01.953]   - Field: ‘globals’
[13:38:01.953]   - Field: ‘stdout’
[13:38:01.953]   - Field: ‘earlySignal’
[13:38:01.954]   - Field: ‘lazy’
[13:38:01.954]   - Field: ‘state’
[13:38:01.954] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:01.954] - Launch lazy future ...
[13:38:01.954] Packages needed by the future expression (n = 0): <none>
[13:38:01.954] Packages needed by future strategies (n = 0): <none>
[13:38:01.955] {
[13:38:01.955]     {
[13:38:01.955]         {
[13:38:01.955]             ...future.startTime <- base::Sys.time()
[13:38:01.955]             {
[13:38:01.955]                 {
[13:38:01.955]                   {
[13:38:01.955]                     {
[13:38:01.955]                       base::local({
[13:38:01.955]                         has_future <- base::requireNamespace("future", 
[13:38:01.955]                           quietly = TRUE)
[13:38:01.955]                         if (has_future) {
[13:38:01.955]                           ns <- base::getNamespace("future")
[13:38:01.955]                           version <- ns[[".package"]][["version"]]
[13:38:01.955]                           if (is.null(version)) 
[13:38:01.955]                             version <- utils::packageVersion("future")
[13:38:01.955]                         }
[13:38:01.955]                         else {
[13:38:01.955]                           version <- NULL
[13:38:01.955]                         }
[13:38:01.955]                         if (!has_future || version < "1.8.0") {
[13:38:01.955]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:01.955]                             "", base::R.version$version.string), 
[13:38:01.955]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:01.955]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:01.955]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:01.955]                               "release", "version")], collapse = " "), 
[13:38:01.955]                             hostname = base::Sys.info()[["nodename"]])
[13:38:01.955]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:01.955]                             info)
[13:38:01.955]                           info <- base::paste(info, collapse = "; ")
[13:38:01.955]                           if (!has_future) {
[13:38:01.955]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:01.955]                               info)
[13:38:01.955]                           }
[13:38:01.955]                           else {
[13:38:01.955]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:01.955]                               info, version)
[13:38:01.955]                           }
[13:38:01.955]                           base::stop(msg)
[13:38:01.955]                         }
[13:38:01.955]                       })
[13:38:01.955]                     }
[13:38:01.955]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:01.955]                     base::options(mc.cores = 1L)
[13:38:01.955]                   }
[13:38:01.955]                   ...future.strategy.old <- future::plan("list")
[13:38:01.955]                   options(future.plan = NULL)
[13:38:01.955]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.955]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:01.955]                 }
[13:38:01.955]                 ...future.workdir <- getwd()
[13:38:01.955]             }
[13:38:01.955]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:01.955]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:01.955]         }
[13:38:01.955]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:01.955]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:01.955]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:01.955]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:01.955]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:01.955]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:01.955]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:01.955]             base::names(...future.oldOptions))
[13:38:01.955]     }
[13:38:01.955]     if (FALSE) {
[13:38:01.955]     }
[13:38:01.955]     else {
[13:38:01.955]         if (TRUE) {
[13:38:01.955]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:01.955]                 open = "w")
[13:38:01.955]         }
[13:38:01.955]         else {
[13:38:01.955]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:01.955]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:01.955]         }
[13:38:01.955]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:01.955]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:01.955]             base::sink(type = "output", split = FALSE)
[13:38:01.955]             base::close(...future.stdout)
[13:38:01.955]         }, add = TRUE)
[13:38:01.955]     }
[13:38:01.955]     ...future.frame <- base::sys.nframe()
[13:38:01.955]     ...future.conditions <- base::list()
[13:38:01.955]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:01.955]     if (FALSE) {
[13:38:01.955]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:01.955]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:01.955]     }
[13:38:01.955]     ...future.result <- base::tryCatch({
[13:38:01.955]         base::withCallingHandlers({
[13:38:01.955]             ...future.value <- base::withVisible(base::local({
[13:38:01.955]                 ...future.makeSendCondition <- base::local({
[13:38:01.955]                   sendCondition <- NULL
[13:38:01.955]                   function(frame = 1L) {
[13:38:01.955]                     if (is.function(sendCondition)) 
[13:38:01.955]                       return(sendCondition)
[13:38:01.955]                     ns <- getNamespace("parallel")
[13:38:01.955]                     if (exists("sendData", mode = "function", 
[13:38:01.955]                       envir = ns)) {
[13:38:01.955]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:01.955]                         envir = ns)
[13:38:01.955]                       envir <- sys.frame(frame)
[13:38:01.955]                       master <- NULL
[13:38:01.955]                       while (!identical(envir, .GlobalEnv) && 
[13:38:01.955]                         !identical(envir, emptyenv())) {
[13:38:01.955]                         if (exists("master", mode = "list", envir = envir, 
[13:38:01.955]                           inherits = FALSE)) {
[13:38:01.955]                           master <- get("master", mode = "list", 
[13:38:01.955]                             envir = envir, inherits = FALSE)
[13:38:01.955]                           if (inherits(master, c("SOCKnode", 
[13:38:01.955]                             "SOCK0node"))) {
[13:38:01.955]                             sendCondition <<- function(cond) {
[13:38:01.955]                               data <- list(type = "VALUE", value = cond, 
[13:38:01.955]                                 success = TRUE)
[13:38:01.955]                               parallel_sendData(master, data)
[13:38:01.955]                             }
[13:38:01.955]                             return(sendCondition)
[13:38:01.955]                           }
[13:38:01.955]                         }
[13:38:01.955]                         frame <- frame + 1L
[13:38:01.955]                         envir <- sys.frame(frame)
[13:38:01.955]                       }
[13:38:01.955]                     }
[13:38:01.955]                     sendCondition <<- function(cond) NULL
[13:38:01.955]                   }
[13:38:01.955]                 })
[13:38:01.955]                 withCallingHandlers({
[13:38:01.955]                   2
[13:38:01.955]                 }, immediateCondition = function(cond) {
[13:38:01.955]                   sendCondition <- ...future.makeSendCondition()
[13:38:01.955]                   sendCondition(cond)
[13:38:01.955]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.955]                   {
[13:38:01.955]                     inherits <- base::inherits
[13:38:01.955]                     invokeRestart <- base::invokeRestart
[13:38:01.955]                     is.null <- base::is.null
[13:38:01.955]                     muffled <- FALSE
[13:38:01.955]                     if (inherits(cond, "message")) {
[13:38:01.955]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:01.955]                       if (muffled) 
[13:38:01.955]                         invokeRestart("muffleMessage")
[13:38:01.955]                     }
[13:38:01.955]                     else if (inherits(cond, "warning")) {
[13:38:01.955]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:01.955]                       if (muffled) 
[13:38:01.955]                         invokeRestart("muffleWarning")
[13:38:01.955]                     }
[13:38:01.955]                     else if (inherits(cond, "condition")) {
[13:38:01.955]                       if (!is.null(pattern)) {
[13:38:01.955]                         computeRestarts <- base::computeRestarts
[13:38:01.955]                         grepl <- base::grepl
[13:38:01.955]                         restarts <- computeRestarts(cond)
[13:38:01.955]                         for (restart in restarts) {
[13:38:01.955]                           name <- restart$name
[13:38:01.955]                           if (is.null(name)) 
[13:38:01.955]                             next
[13:38:01.955]                           if (!grepl(pattern, name)) 
[13:38:01.955]                             next
[13:38:01.955]                           invokeRestart(restart)
[13:38:01.955]                           muffled <- TRUE
[13:38:01.955]                           break
[13:38:01.955]                         }
[13:38:01.955]                       }
[13:38:01.955]                     }
[13:38:01.955]                     invisible(muffled)
[13:38:01.955]                   }
[13:38:01.955]                   muffleCondition(cond)
[13:38:01.955]                 })
[13:38:01.955]             }))
[13:38:01.955]             future::FutureResult(value = ...future.value$value, 
[13:38:01.955]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.955]                   ...future.rng), globalenv = if (FALSE) 
[13:38:01.955]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:01.955]                     ...future.globalenv.names))
[13:38:01.955]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:01.955]         }, condition = base::local({
[13:38:01.955]             c <- base::c
[13:38:01.955]             inherits <- base::inherits
[13:38:01.955]             invokeRestart <- base::invokeRestart
[13:38:01.955]             length <- base::length
[13:38:01.955]             list <- base::list
[13:38:01.955]             seq.int <- base::seq.int
[13:38:01.955]             signalCondition <- base::signalCondition
[13:38:01.955]             sys.calls <- base::sys.calls
[13:38:01.955]             `[[` <- base::`[[`
[13:38:01.955]             `+` <- base::`+`
[13:38:01.955]             `<<-` <- base::`<<-`
[13:38:01.955]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:01.955]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:01.955]                   3L)]
[13:38:01.955]             }
[13:38:01.955]             function(cond) {
[13:38:01.955]                 is_error <- inherits(cond, "error")
[13:38:01.955]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:01.955]                   NULL)
[13:38:01.955]                 if (is_error) {
[13:38:01.955]                   sessionInformation <- function() {
[13:38:01.955]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:01.955]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:01.955]                       search = base::search(), system = base::Sys.info())
[13:38:01.955]                   }
[13:38:01.955]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.955]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:01.955]                     cond$call), session = sessionInformation(), 
[13:38:01.955]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:01.955]                   signalCondition(cond)
[13:38:01.955]                 }
[13:38:01.955]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:01.955]                 "immediateCondition"))) {
[13:38:01.955]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:01.955]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.955]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:01.955]                   if (TRUE && !signal) {
[13:38:01.955]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.955]                     {
[13:38:01.955]                       inherits <- base::inherits
[13:38:01.955]                       invokeRestart <- base::invokeRestart
[13:38:01.955]                       is.null <- base::is.null
[13:38:01.955]                       muffled <- FALSE
[13:38:01.955]                       if (inherits(cond, "message")) {
[13:38:01.955]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.955]                         if (muffled) 
[13:38:01.955]                           invokeRestart("muffleMessage")
[13:38:01.955]                       }
[13:38:01.955]                       else if (inherits(cond, "warning")) {
[13:38:01.955]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.955]                         if (muffled) 
[13:38:01.955]                           invokeRestart("muffleWarning")
[13:38:01.955]                       }
[13:38:01.955]                       else if (inherits(cond, "condition")) {
[13:38:01.955]                         if (!is.null(pattern)) {
[13:38:01.955]                           computeRestarts <- base::computeRestarts
[13:38:01.955]                           grepl <- base::grepl
[13:38:01.955]                           restarts <- computeRestarts(cond)
[13:38:01.955]                           for (restart in restarts) {
[13:38:01.955]                             name <- restart$name
[13:38:01.955]                             if (is.null(name)) 
[13:38:01.955]                               next
[13:38:01.955]                             if (!grepl(pattern, name)) 
[13:38:01.955]                               next
[13:38:01.955]                             invokeRestart(restart)
[13:38:01.955]                             muffled <- TRUE
[13:38:01.955]                             break
[13:38:01.955]                           }
[13:38:01.955]                         }
[13:38:01.955]                       }
[13:38:01.955]                       invisible(muffled)
[13:38:01.955]                     }
[13:38:01.955]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.955]                   }
[13:38:01.955]                 }
[13:38:01.955]                 else {
[13:38:01.955]                   if (TRUE) {
[13:38:01.955]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.955]                     {
[13:38:01.955]                       inherits <- base::inherits
[13:38:01.955]                       invokeRestart <- base::invokeRestart
[13:38:01.955]                       is.null <- base::is.null
[13:38:01.955]                       muffled <- FALSE
[13:38:01.955]                       if (inherits(cond, "message")) {
[13:38:01.955]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.955]                         if (muffled) 
[13:38:01.955]                           invokeRestart("muffleMessage")
[13:38:01.955]                       }
[13:38:01.955]                       else if (inherits(cond, "warning")) {
[13:38:01.955]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.955]                         if (muffled) 
[13:38:01.955]                           invokeRestart("muffleWarning")
[13:38:01.955]                       }
[13:38:01.955]                       else if (inherits(cond, "condition")) {
[13:38:01.955]                         if (!is.null(pattern)) {
[13:38:01.955]                           computeRestarts <- base::computeRestarts
[13:38:01.955]                           grepl <- base::grepl
[13:38:01.955]                           restarts <- computeRestarts(cond)
[13:38:01.955]                           for (restart in restarts) {
[13:38:01.955]                             name <- restart$name
[13:38:01.955]                             if (is.null(name)) 
[13:38:01.955]                               next
[13:38:01.955]                             if (!grepl(pattern, name)) 
[13:38:01.955]                               next
[13:38:01.955]                             invokeRestart(restart)
[13:38:01.955]                             muffled <- TRUE
[13:38:01.955]                             break
[13:38:01.955]                           }
[13:38:01.955]                         }
[13:38:01.955]                       }
[13:38:01.955]                       invisible(muffled)
[13:38:01.955]                     }
[13:38:01.955]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.955]                   }
[13:38:01.955]                 }
[13:38:01.955]             }
[13:38:01.955]         }))
[13:38:01.955]     }, error = function(ex) {
[13:38:01.955]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:01.955]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.955]                 ...future.rng), started = ...future.startTime, 
[13:38:01.955]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:01.955]             version = "1.8"), class = "FutureResult")
[13:38:01.955]     }, finally = {
[13:38:01.955]         if (!identical(...future.workdir, getwd())) 
[13:38:01.955]             setwd(...future.workdir)
[13:38:01.955]         {
[13:38:01.955]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:01.955]                 ...future.oldOptions$nwarnings <- NULL
[13:38:01.955]             }
[13:38:01.955]             base::options(...future.oldOptions)
[13:38:01.955]             if (.Platform$OS.type == "windows") {
[13:38:01.955]                 old_names <- names(...future.oldEnvVars)
[13:38:01.955]                 envs <- base::Sys.getenv()
[13:38:01.955]                 names <- names(envs)
[13:38:01.955]                 common <- intersect(names, old_names)
[13:38:01.955]                 added <- setdiff(names, old_names)
[13:38:01.955]                 removed <- setdiff(old_names, names)
[13:38:01.955]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:01.955]                   envs[common]]
[13:38:01.955]                 NAMES <- toupper(changed)
[13:38:01.955]                 args <- list()
[13:38:01.955]                 for (kk in seq_along(NAMES)) {
[13:38:01.955]                   name <- changed[[kk]]
[13:38:01.955]                   NAME <- NAMES[[kk]]
[13:38:01.955]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.955]                     next
[13:38:01.955]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.955]                 }
[13:38:01.955]                 NAMES <- toupper(added)
[13:38:01.955]                 for (kk in seq_along(NAMES)) {
[13:38:01.955]                   name <- added[[kk]]
[13:38:01.955]                   NAME <- NAMES[[kk]]
[13:38:01.955]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.955]                     next
[13:38:01.955]                   args[[name]] <- ""
[13:38:01.955]                 }
[13:38:01.955]                 NAMES <- toupper(removed)
[13:38:01.955]                 for (kk in seq_along(NAMES)) {
[13:38:01.955]                   name <- removed[[kk]]
[13:38:01.955]                   NAME <- NAMES[[kk]]
[13:38:01.955]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.955]                     next
[13:38:01.955]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.955]                 }
[13:38:01.955]                 if (length(args) > 0) 
[13:38:01.955]                   base::do.call(base::Sys.setenv, args = args)
[13:38:01.955]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:01.955]             }
[13:38:01.955]             else {
[13:38:01.955]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:01.955]             }
[13:38:01.955]             {
[13:38:01.955]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:01.955]                   0L) {
[13:38:01.955]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:01.955]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:01.955]                   base::options(opts)
[13:38:01.955]                 }
[13:38:01.955]                 {
[13:38:01.955]                   {
[13:38:01.955]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:01.955]                     NULL
[13:38:01.955]                   }
[13:38:01.955]                   options(future.plan = NULL)
[13:38:01.955]                   if (is.na(NA_character_)) 
[13:38:01.955]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.955]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:01.955]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:01.955]                     .init = FALSE)
[13:38:01.955]                 }
[13:38:01.955]             }
[13:38:01.955]         }
[13:38:01.955]     })
[13:38:01.955]     if (TRUE) {
[13:38:01.955]         base::sink(type = "output", split = FALSE)
[13:38:01.955]         if (TRUE) {
[13:38:01.955]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:01.955]         }
[13:38:01.955]         else {
[13:38:01.955]             ...future.result["stdout"] <- base::list(NULL)
[13:38:01.955]         }
[13:38:01.955]         base::close(...future.stdout)
[13:38:01.955]         ...future.stdout <- NULL
[13:38:01.955]     }
[13:38:01.955]     ...future.result$conditions <- ...future.conditions
[13:38:01.955]     ...future.result$finished <- base::Sys.time()
[13:38:01.955]     ...future.result
[13:38:01.955] }
[13:38:01.957] MultisessionFuture started
[13:38:01.958] - Launch lazy future ... done
[13:38:01.958] run() for ‘MultisessionFuture’ ... done
[13:38:01.959] resolve() on list environment ...
[13:38:01.959]  recursive: 0
[13:38:01.960]  length: 3
[13:38:01.960]  elements: ‘a’, ‘b’, ‘c’
[13:38:01.960] receiveMessageFromWorker() for ClusterFuture ...
[13:38:01.960] - Validating connection of MultisessionFuture
[13:38:01.961] - received message: FutureResult
[13:38:01.961] - Received FutureResult
[13:38:01.961] - Erased future from FutureRegistry
[13:38:01.961] result() for ClusterFuture ...
[13:38:01.961] - result already collected: FutureResult
[13:38:01.961] result() for ClusterFuture ... done
[13:38:01.961] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:01.961] Future #1
[13:38:01.961]  length: 2 (resolved future 1)
[13:38:01.965] receiveMessageFromWorker() for ClusterFuture ...
[13:38:01.965] - Validating connection of MultisessionFuture
[13:38:01.965] - received message: FutureResult
[13:38:01.966] - Received FutureResult
[13:38:01.966] - Erased future from FutureRegistry
[13:38:01.966] result() for ClusterFuture ...
[13:38:01.966] - result already collected: FutureResult
[13:38:01.966] result() for ClusterFuture ... done
[13:38:01.966] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:01.966] Future #2
[13:38:01.966]  length: 1 (resolved future 2)
[13:38:01.967]  length: 0 (resolved future 3)
[13:38:01.967] resolve() on list environment ... DONE
[13:38:01.967] getGlobalsAndPackages() ...
[13:38:01.967] Searching for globals...
[13:38:01.968] - globals found: [1] ‘{’
[13:38:01.968] Searching for globals ... DONE
[13:38:01.968] Resolving globals: FALSE
[13:38:01.968] 
[13:38:01.969] 
[13:38:01.969] getGlobalsAndPackages() ... DONE
[13:38:01.969] run() for ‘Future’ ...
[13:38:01.969] - state: ‘created’
[13:38:01.969] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:01.983] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:01.983] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:01.983]   - Field: ‘node’
[13:38:01.983]   - Field: ‘label’
[13:38:01.983]   - Field: ‘local’
[13:38:01.984]   - Field: ‘owner’
[13:38:01.984]   - Field: ‘envir’
[13:38:01.984]   - Field: ‘workers’
[13:38:01.984]   - Field: ‘packages’
[13:38:01.984]   - Field: ‘gc’
[13:38:01.984]   - Field: ‘conditions’
[13:38:01.984]   - Field: ‘persistent’
[13:38:01.984]   - Field: ‘expr’
[13:38:01.984]   - Field: ‘uuid’
[13:38:01.984]   - Field: ‘seed’
[13:38:01.984]   - Field: ‘version’
[13:38:01.985]   - Field: ‘result’
[13:38:01.985]   - Field: ‘asynchronous’
[13:38:01.985]   - Field: ‘calls’
[13:38:01.985]   - Field: ‘globals’
[13:38:01.985]   - Field: ‘stdout’
[13:38:01.985]   - Field: ‘earlySignal’
[13:38:01.985]   - Field: ‘lazy’
[13:38:01.985]   - Field: ‘state’
[13:38:01.985] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:01.985] - Launch lazy future ...
[13:38:01.986] Packages needed by the future expression (n = 0): <none>
[13:38:01.986] Packages needed by future strategies (n = 0): <none>
[13:38:01.986] {
[13:38:01.986]     {
[13:38:01.986]         {
[13:38:01.986]             ...future.startTime <- base::Sys.time()
[13:38:01.986]             {
[13:38:01.986]                 {
[13:38:01.986]                   {
[13:38:01.986]                     {
[13:38:01.986]                       base::local({
[13:38:01.986]                         has_future <- base::requireNamespace("future", 
[13:38:01.986]                           quietly = TRUE)
[13:38:01.986]                         if (has_future) {
[13:38:01.986]                           ns <- base::getNamespace("future")
[13:38:01.986]                           version <- ns[[".package"]][["version"]]
[13:38:01.986]                           if (is.null(version)) 
[13:38:01.986]                             version <- utils::packageVersion("future")
[13:38:01.986]                         }
[13:38:01.986]                         else {
[13:38:01.986]                           version <- NULL
[13:38:01.986]                         }
[13:38:01.986]                         if (!has_future || version < "1.8.0") {
[13:38:01.986]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:01.986]                             "", base::R.version$version.string), 
[13:38:01.986]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:01.986]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:01.986]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:01.986]                               "release", "version")], collapse = " "), 
[13:38:01.986]                             hostname = base::Sys.info()[["nodename"]])
[13:38:01.986]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:01.986]                             info)
[13:38:01.986]                           info <- base::paste(info, collapse = "; ")
[13:38:01.986]                           if (!has_future) {
[13:38:01.986]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:01.986]                               info)
[13:38:01.986]                           }
[13:38:01.986]                           else {
[13:38:01.986]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:01.986]                               info, version)
[13:38:01.986]                           }
[13:38:01.986]                           base::stop(msg)
[13:38:01.986]                         }
[13:38:01.986]                       })
[13:38:01.986]                     }
[13:38:01.986]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:01.986]                     base::options(mc.cores = 1L)
[13:38:01.986]                   }
[13:38:01.986]                   ...future.strategy.old <- future::plan("list")
[13:38:01.986]                   options(future.plan = NULL)
[13:38:01.986]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.986]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:01.986]                 }
[13:38:01.986]                 ...future.workdir <- getwd()
[13:38:01.986]             }
[13:38:01.986]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:01.986]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:01.986]         }
[13:38:01.986]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:01.986]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:01.986]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:01.986]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:01.986]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:01.986]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:01.986]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:01.986]             base::names(...future.oldOptions))
[13:38:01.986]     }
[13:38:01.986]     if (FALSE) {
[13:38:01.986]     }
[13:38:01.986]     else {
[13:38:01.986]         if (TRUE) {
[13:38:01.986]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:01.986]                 open = "w")
[13:38:01.986]         }
[13:38:01.986]         else {
[13:38:01.986]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:01.986]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:01.986]         }
[13:38:01.986]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:01.986]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:01.986]             base::sink(type = "output", split = FALSE)
[13:38:01.986]             base::close(...future.stdout)
[13:38:01.986]         }, add = TRUE)
[13:38:01.986]     }
[13:38:01.986]     ...future.frame <- base::sys.nframe()
[13:38:01.986]     ...future.conditions <- base::list()
[13:38:01.986]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:01.986]     if (FALSE) {
[13:38:01.986]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:01.986]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:01.986]     }
[13:38:01.986]     ...future.result <- base::tryCatch({
[13:38:01.986]         base::withCallingHandlers({
[13:38:01.986]             ...future.value <- base::withVisible(base::local({
[13:38:01.986]                 ...future.makeSendCondition <- base::local({
[13:38:01.986]                   sendCondition <- NULL
[13:38:01.986]                   function(frame = 1L) {
[13:38:01.986]                     if (is.function(sendCondition)) 
[13:38:01.986]                       return(sendCondition)
[13:38:01.986]                     ns <- getNamespace("parallel")
[13:38:01.986]                     if (exists("sendData", mode = "function", 
[13:38:01.986]                       envir = ns)) {
[13:38:01.986]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:01.986]                         envir = ns)
[13:38:01.986]                       envir <- sys.frame(frame)
[13:38:01.986]                       master <- NULL
[13:38:01.986]                       while (!identical(envir, .GlobalEnv) && 
[13:38:01.986]                         !identical(envir, emptyenv())) {
[13:38:01.986]                         if (exists("master", mode = "list", envir = envir, 
[13:38:01.986]                           inherits = FALSE)) {
[13:38:01.986]                           master <- get("master", mode = "list", 
[13:38:01.986]                             envir = envir, inherits = FALSE)
[13:38:01.986]                           if (inherits(master, c("SOCKnode", 
[13:38:01.986]                             "SOCK0node"))) {
[13:38:01.986]                             sendCondition <<- function(cond) {
[13:38:01.986]                               data <- list(type = "VALUE", value = cond, 
[13:38:01.986]                                 success = TRUE)
[13:38:01.986]                               parallel_sendData(master, data)
[13:38:01.986]                             }
[13:38:01.986]                             return(sendCondition)
[13:38:01.986]                           }
[13:38:01.986]                         }
[13:38:01.986]                         frame <- frame + 1L
[13:38:01.986]                         envir <- sys.frame(frame)
[13:38:01.986]                       }
[13:38:01.986]                     }
[13:38:01.986]                     sendCondition <<- function(cond) NULL
[13:38:01.986]                   }
[13:38:01.986]                 })
[13:38:01.986]                 withCallingHandlers({
[13:38:01.986]                   {
[13:38:01.986]                     1
[13:38:01.986]                   }
[13:38:01.986]                 }, immediateCondition = function(cond) {
[13:38:01.986]                   sendCondition <- ...future.makeSendCondition()
[13:38:01.986]                   sendCondition(cond)
[13:38:01.986]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.986]                   {
[13:38:01.986]                     inherits <- base::inherits
[13:38:01.986]                     invokeRestart <- base::invokeRestart
[13:38:01.986]                     is.null <- base::is.null
[13:38:01.986]                     muffled <- FALSE
[13:38:01.986]                     if (inherits(cond, "message")) {
[13:38:01.986]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:01.986]                       if (muffled) 
[13:38:01.986]                         invokeRestart("muffleMessage")
[13:38:01.986]                     }
[13:38:01.986]                     else if (inherits(cond, "warning")) {
[13:38:01.986]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:01.986]                       if (muffled) 
[13:38:01.986]                         invokeRestart("muffleWarning")
[13:38:01.986]                     }
[13:38:01.986]                     else if (inherits(cond, "condition")) {
[13:38:01.986]                       if (!is.null(pattern)) {
[13:38:01.986]                         computeRestarts <- base::computeRestarts
[13:38:01.986]                         grepl <- base::grepl
[13:38:01.986]                         restarts <- computeRestarts(cond)
[13:38:01.986]                         for (restart in restarts) {
[13:38:01.986]                           name <- restart$name
[13:38:01.986]                           if (is.null(name)) 
[13:38:01.986]                             next
[13:38:01.986]                           if (!grepl(pattern, name)) 
[13:38:01.986]                             next
[13:38:01.986]                           invokeRestart(restart)
[13:38:01.986]                           muffled <- TRUE
[13:38:01.986]                           break
[13:38:01.986]                         }
[13:38:01.986]                       }
[13:38:01.986]                     }
[13:38:01.986]                     invisible(muffled)
[13:38:01.986]                   }
[13:38:01.986]                   muffleCondition(cond)
[13:38:01.986]                 })
[13:38:01.986]             }))
[13:38:01.986]             future::FutureResult(value = ...future.value$value, 
[13:38:01.986]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.986]                   ...future.rng), globalenv = if (FALSE) 
[13:38:01.986]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:01.986]                     ...future.globalenv.names))
[13:38:01.986]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:01.986]         }, condition = base::local({
[13:38:01.986]             c <- base::c
[13:38:01.986]             inherits <- base::inherits
[13:38:01.986]             invokeRestart <- base::invokeRestart
[13:38:01.986]             length <- base::length
[13:38:01.986]             list <- base::list
[13:38:01.986]             seq.int <- base::seq.int
[13:38:01.986]             signalCondition <- base::signalCondition
[13:38:01.986]             sys.calls <- base::sys.calls
[13:38:01.986]             `[[` <- base::`[[`
[13:38:01.986]             `+` <- base::`+`
[13:38:01.986]             `<<-` <- base::`<<-`
[13:38:01.986]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:01.986]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:01.986]                   3L)]
[13:38:01.986]             }
[13:38:01.986]             function(cond) {
[13:38:01.986]                 is_error <- inherits(cond, "error")
[13:38:01.986]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:01.986]                   NULL)
[13:38:01.986]                 if (is_error) {
[13:38:01.986]                   sessionInformation <- function() {
[13:38:01.986]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:01.986]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:01.986]                       search = base::search(), system = base::Sys.info())
[13:38:01.986]                   }
[13:38:01.986]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.986]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:01.986]                     cond$call), session = sessionInformation(), 
[13:38:01.986]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:01.986]                   signalCondition(cond)
[13:38:01.986]                 }
[13:38:01.986]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:01.986]                 "immediateCondition"))) {
[13:38:01.986]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:01.986]                   ...future.conditions[[length(...future.conditions) + 
[13:38:01.986]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:01.986]                   if (TRUE && !signal) {
[13:38:01.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.986]                     {
[13:38:01.986]                       inherits <- base::inherits
[13:38:01.986]                       invokeRestart <- base::invokeRestart
[13:38:01.986]                       is.null <- base::is.null
[13:38:01.986]                       muffled <- FALSE
[13:38:01.986]                       if (inherits(cond, "message")) {
[13:38:01.986]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.986]                         if (muffled) 
[13:38:01.986]                           invokeRestart("muffleMessage")
[13:38:01.986]                       }
[13:38:01.986]                       else if (inherits(cond, "warning")) {
[13:38:01.986]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.986]                         if (muffled) 
[13:38:01.986]                           invokeRestart("muffleWarning")
[13:38:01.986]                       }
[13:38:01.986]                       else if (inherits(cond, "condition")) {
[13:38:01.986]                         if (!is.null(pattern)) {
[13:38:01.986]                           computeRestarts <- base::computeRestarts
[13:38:01.986]                           grepl <- base::grepl
[13:38:01.986]                           restarts <- computeRestarts(cond)
[13:38:01.986]                           for (restart in restarts) {
[13:38:01.986]                             name <- restart$name
[13:38:01.986]                             if (is.null(name)) 
[13:38:01.986]                               next
[13:38:01.986]                             if (!grepl(pattern, name)) 
[13:38:01.986]                               next
[13:38:01.986]                             invokeRestart(restart)
[13:38:01.986]                             muffled <- TRUE
[13:38:01.986]                             break
[13:38:01.986]                           }
[13:38:01.986]                         }
[13:38:01.986]                       }
[13:38:01.986]                       invisible(muffled)
[13:38:01.986]                     }
[13:38:01.986]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.986]                   }
[13:38:01.986]                 }
[13:38:01.986]                 else {
[13:38:01.986]                   if (TRUE) {
[13:38:01.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:01.986]                     {
[13:38:01.986]                       inherits <- base::inherits
[13:38:01.986]                       invokeRestart <- base::invokeRestart
[13:38:01.986]                       is.null <- base::is.null
[13:38:01.986]                       muffled <- FALSE
[13:38:01.986]                       if (inherits(cond, "message")) {
[13:38:01.986]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:01.986]                         if (muffled) 
[13:38:01.986]                           invokeRestart("muffleMessage")
[13:38:01.986]                       }
[13:38:01.986]                       else if (inherits(cond, "warning")) {
[13:38:01.986]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:01.986]                         if (muffled) 
[13:38:01.986]                           invokeRestart("muffleWarning")
[13:38:01.986]                       }
[13:38:01.986]                       else if (inherits(cond, "condition")) {
[13:38:01.986]                         if (!is.null(pattern)) {
[13:38:01.986]                           computeRestarts <- base::computeRestarts
[13:38:01.986]                           grepl <- base::grepl
[13:38:01.986]                           restarts <- computeRestarts(cond)
[13:38:01.986]                           for (restart in restarts) {
[13:38:01.986]                             name <- restart$name
[13:38:01.986]                             if (is.null(name)) 
[13:38:01.986]                               next
[13:38:01.986]                             if (!grepl(pattern, name)) 
[13:38:01.986]                               next
[13:38:01.986]                             invokeRestart(restart)
[13:38:01.986]                             muffled <- TRUE
[13:38:01.986]                             break
[13:38:01.986]                           }
[13:38:01.986]                         }
[13:38:01.986]                       }
[13:38:01.986]                       invisible(muffled)
[13:38:01.986]                     }
[13:38:01.986]                     muffleCondition(cond, pattern = "^muffle")
[13:38:01.986]                   }
[13:38:01.986]                 }
[13:38:01.986]             }
[13:38:01.986]         }))
[13:38:01.986]     }, error = function(ex) {
[13:38:01.986]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:01.986]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:01.986]                 ...future.rng), started = ...future.startTime, 
[13:38:01.986]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:01.986]             version = "1.8"), class = "FutureResult")
[13:38:01.986]     }, finally = {
[13:38:01.986]         if (!identical(...future.workdir, getwd())) 
[13:38:01.986]             setwd(...future.workdir)
[13:38:01.986]         {
[13:38:01.986]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:01.986]                 ...future.oldOptions$nwarnings <- NULL
[13:38:01.986]             }
[13:38:01.986]             base::options(...future.oldOptions)
[13:38:01.986]             if (.Platform$OS.type == "windows") {
[13:38:01.986]                 old_names <- names(...future.oldEnvVars)
[13:38:01.986]                 envs <- base::Sys.getenv()
[13:38:01.986]                 names <- names(envs)
[13:38:01.986]                 common <- intersect(names, old_names)
[13:38:01.986]                 added <- setdiff(names, old_names)
[13:38:01.986]                 removed <- setdiff(old_names, names)
[13:38:01.986]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:01.986]                   envs[common]]
[13:38:01.986]                 NAMES <- toupper(changed)
[13:38:01.986]                 args <- list()
[13:38:01.986]                 for (kk in seq_along(NAMES)) {
[13:38:01.986]                   name <- changed[[kk]]
[13:38:01.986]                   NAME <- NAMES[[kk]]
[13:38:01.986]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.986]                     next
[13:38:01.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.986]                 }
[13:38:01.986]                 NAMES <- toupper(added)
[13:38:01.986]                 for (kk in seq_along(NAMES)) {
[13:38:01.986]                   name <- added[[kk]]
[13:38:01.986]                   NAME <- NAMES[[kk]]
[13:38:01.986]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.986]                     next
[13:38:01.986]                   args[[name]] <- ""
[13:38:01.986]                 }
[13:38:01.986]                 NAMES <- toupper(removed)
[13:38:01.986]                 for (kk in seq_along(NAMES)) {
[13:38:01.986]                   name <- removed[[kk]]
[13:38:01.986]                   NAME <- NAMES[[kk]]
[13:38:01.986]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:01.986]                     next
[13:38:01.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:01.986]                 }
[13:38:01.986]                 if (length(args) > 0) 
[13:38:01.986]                   base::do.call(base::Sys.setenv, args = args)
[13:38:01.986]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:01.986]             }
[13:38:01.986]             else {
[13:38:01.986]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:01.986]             }
[13:38:01.986]             {
[13:38:01.986]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:01.986]                   0L) {
[13:38:01.986]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:01.986]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:01.986]                   base::options(opts)
[13:38:01.986]                 }
[13:38:01.986]                 {
[13:38:01.986]                   {
[13:38:01.986]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:01.986]                     NULL
[13:38:01.986]                   }
[13:38:01.986]                   options(future.plan = NULL)
[13:38:01.986]                   if (is.na(NA_character_)) 
[13:38:01.986]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:01.986]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:01.986]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:01.986]                     .init = FALSE)
[13:38:01.986]                 }
[13:38:01.986]             }
[13:38:01.986]         }
[13:38:01.986]     })
[13:38:01.986]     if (TRUE) {
[13:38:01.986]         base::sink(type = "output", split = FALSE)
[13:38:01.986]         if (TRUE) {
[13:38:01.986]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:01.986]         }
[13:38:01.986]         else {
[13:38:01.986]             ...future.result["stdout"] <- base::list(NULL)
[13:38:01.986]         }
[13:38:01.986]         base::close(...future.stdout)
[13:38:01.986]         ...future.stdout <- NULL
[13:38:01.986]     }
[13:38:01.986]     ...future.result$conditions <- ...future.conditions
[13:38:01.986]     ...future.result$finished <- base::Sys.time()
[13:38:01.986]     ...future.result
[13:38:01.986] }
[13:38:01.989] MultisessionFuture started
[13:38:01.989] - Launch lazy future ... done
[13:38:01.989] run() for ‘MultisessionFuture’ ... done
[13:38:01.990] getGlobalsAndPackages() ...
[13:38:01.990] Searching for globals...
[13:38:01.990] - globals found: [1] ‘{’
[13:38:01.990] Searching for globals ... DONE
[13:38:01.990] Resolving globals: FALSE
[13:38:01.991] 
[13:38:01.991] 
[13:38:01.991] getGlobalsAndPackages() ... DONE
[13:38:01.991] run() for ‘Future’ ...
[13:38:01.991] - state: ‘created’
[13:38:01.991] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:02.005] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:02.005] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:02.005]   - Field: ‘node’
[13:38:02.005]   - Field: ‘label’
[13:38:02.005]   - Field: ‘local’
[13:38:02.005]   - Field: ‘owner’
[13:38:02.005]   - Field: ‘envir’
[13:38:02.005]   - Field: ‘workers’
[13:38:02.005]   - Field: ‘packages’
[13:38:02.006]   - Field: ‘gc’
[13:38:02.006]   - Field: ‘conditions’
[13:38:02.006]   - Field: ‘persistent’
[13:38:02.006]   - Field: ‘expr’
[13:38:02.006]   - Field: ‘uuid’
[13:38:02.006]   - Field: ‘seed’
[13:38:02.006]   - Field: ‘version’
[13:38:02.006]   - Field: ‘result’
[13:38:02.006]   - Field: ‘asynchronous’
[13:38:02.006]   - Field: ‘calls’
[13:38:02.006]   - Field: ‘globals’
[13:38:02.007]   - Field: ‘stdout’
[13:38:02.007]   - Field: ‘earlySignal’
[13:38:02.007]   - Field: ‘lazy’
[13:38:02.007]   - Field: ‘state’
[13:38:02.007] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:02.007] - Launch lazy future ...
[13:38:02.007] Packages needed by the future expression (n = 0): <none>
[13:38:02.007] Packages needed by future strategies (n = 0): <none>
[13:38:02.008] {
[13:38:02.008]     {
[13:38:02.008]         {
[13:38:02.008]             ...future.startTime <- base::Sys.time()
[13:38:02.008]             {
[13:38:02.008]                 {
[13:38:02.008]                   {
[13:38:02.008]                     {
[13:38:02.008]                       base::local({
[13:38:02.008]                         has_future <- base::requireNamespace("future", 
[13:38:02.008]                           quietly = TRUE)
[13:38:02.008]                         if (has_future) {
[13:38:02.008]                           ns <- base::getNamespace("future")
[13:38:02.008]                           version <- ns[[".package"]][["version"]]
[13:38:02.008]                           if (is.null(version)) 
[13:38:02.008]                             version <- utils::packageVersion("future")
[13:38:02.008]                         }
[13:38:02.008]                         else {
[13:38:02.008]                           version <- NULL
[13:38:02.008]                         }
[13:38:02.008]                         if (!has_future || version < "1.8.0") {
[13:38:02.008]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:02.008]                             "", base::R.version$version.string), 
[13:38:02.008]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:02.008]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:02.008]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:02.008]                               "release", "version")], collapse = " "), 
[13:38:02.008]                             hostname = base::Sys.info()[["nodename"]])
[13:38:02.008]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:02.008]                             info)
[13:38:02.008]                           info <- base::paste(info, collapse = "; ")
[13:38:02.008]                           if (!has_future) {
[13:38:02.008]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:02.008]                               info)
[13:38:02.008]                           }
[13:38:02.008]                           else {
[13:38:02.008]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:02.008]                               info, version)
[13:38:02.008]                           }
[13:38:02.008]                           base::stop(msg)
[13:38:02.008]                         }
[13:38:02.008]                       })
[13:38:02.008]                     }
[13:38:02.008]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:02.008]                     base::options(mc.cores = 1L)
[13:38:02.008]                   }
[13:38:02.008]                   ...future.strategy.old <- future::plan("list")
[13:38:02.008]                   options(future.plan = NULL)
[13:38:02.008]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:02.008]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:02.008]                 }
[13:38:02.008]                 ...future.workdir <- getwd()
[13:38:02.008]             }
[13:38:02.008]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:02.008]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:02.008]         }
[13:38:02.008]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:02.008]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:02.008]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:02.008]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:02.008]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:02.008]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:02.008]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:02.008]             base::names(...future.oldOptions))
[13:38:02.008]     }
[13:38:02.008]     if (FALSE) {
[13:38:02.008]     }
[13:38:02.008]     else {
[13:38:02.008]         if (TRUE) {
[13:38:02.008]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:02.008]                 open = "w")
[13:38:02.008]         }
[13:38:02.008]         else {
[13:38:02.008]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:02.008]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:02.008]         }
[13:38:02.008]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:02.008]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:02.008]             base::sink(type = "output", split = FALSE)
[13:38:02.008]             base::close(...future.stdout)
[13:38:02.008]         }, add = TRUE)
[13:38:02.008]     }
[13:38:02.008]     ...future.frame <- base::sys.nframe()
[13:38:02.008]     ...future.conditions <- base::list()
[13:38:02.008]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:02.008]     if (FALSE) {
[13:38:02.008]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:02.008]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:02.008]     }
[13:38:02.008]     ...future.result <- base::tryCatch({
[13:38:02.008]         base::withCallingHandlers({
[13:38:02.008]             ...future.value <- base::withVisible(base::local({
[13:38:02.008]                 ...future.makeSendCondition <- base::local({
[13:38:02.008]                   sendCondition <- NULL
[13:38:02.008]                   function(frame = 1L) {
[13:38:02.008]                     if (is.function(sendCondition)) 
[13:38:02.008]                       return(sendCondition)
[13:38:02.008]                     ns <- getNamespace("parallel")
[13:38:02.008]                     if (exists("sendData", mode = "function", 
[13:38:02.008]                       envir = ns)) {
[13:38:02.008]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:02.008]                         envir = ns)
[13:38:02.008]                       envir <- sys.frame(frame)
[13:38:02.008]                       master <- NULL
[13:38:02.008]                       while (!identical(envir, .GlobalEnv) && 
[13:38:02.008]                         !identical(envir, emptyenv())) {
[13:38:02.008]                         if (exists("master", mode = "list", envir = envir, 
[13:38:02.008]                           inherits = FALSE)) {
[13:38:02.008]                           master <- get("master", mode = "list", 
[13:38:02.008]                             envir = envir, inherits = FALSE)
[13:38:02.008]                           if (inherits(master, c("SOCKnode", 
[13:38:02.008]                             "SOCK0node"))) {
[13:38:02.008]                             sendCondition <<- function(cond) {
[13:38:02.008]                               data <- list(type = "VALUE", value = cond, 
[13:38:02.008]                                 success = TRUE)
[13:38:02.008]                               parallel_sendData(master, data)
[13:38:02.008]                             }
[13:38:02.008]                             return(sendCondition)
[13:38:02.008]                           }
[13:38:02.008]                         }
[13:38:02.008]                         frame <- frame + 1L
[13:38:02.008]                         envir <- sys.frame(frame)
[13:38:02.008]                       }
[13:38:02.008]                     }
[13:38:02.008]                     sendCondition <<- function(cond) NULL
[13:38:02.008]                   }
[13:38:02.008]                 })
[13:38:02.008]                 withCallingHandlers({
[13:38:02.008]                   {
[13:38:02.008]                     2
[13:38:02.008]                   }
[13:38:02.008]                 }, immediateCondition = function(cond) {
[13:38:02.008]                   sendCondition <- ...future.makeSendCondition()
[13:38:02.008]                   sendCondition(cond)
[13:38:02.008]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:02.008]                   {
[13:38:02.008]                     inherits <- base::inherits
[13:38:02.008]                     invokeRestart <- base::invokeRestart
[13:38:02.008]                     is.null <- base::is.null
[13:38:02.008]                     muffled <- FALSE
[13:38:02.008]                     if (inherits(cond, "message")) {
[13:38:02.008]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:02.008]                       if (muffled) 
[13:38:02.008]                         invokeRestart("muffleMessage")
[13:38:02.008]                     }
[13:38:02.008]                     else if (inherits(cond, "warning")) {
[13:38:02.008]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:02.008]                       if (muffled) 
[13:38:02.008]                         invokeRestart("muffleWarning")
[13:38:02.008]                     }
[13:38:02.008]                     else if (inherits(cond, "condition")) {
[13:38:02.008]                       if (!is.null(pattern)) {
[13:38:02.008]                         computeRestarts <- base::computeRestarts
[13:38:02.008]                         grepl <- base::grepl
[13:38:02.008]                         restarts <- computeRestarts(cond)
[13:38:02.008]                         for (restart in restarts) {
[13:38:02.008]                           name <- restart$name
[13:38:02.008]                           if (is.null(name)) 
[13:38:02.008]                             next
[13:38:02.008]                           if (!grepl(pattern, name)) 
[13:38:02.008]                             next
[13:38:02.008]                           invokeRestart(restart)
[13:38:02.008]                           muffled <- TRUE
[13:38:02.008]                           break
[13:38:02.008]                         }
[13:38:02.008]                       }
[13:38:02.008]                     }
[13:38:02.008]                     invisible(muffled)
[13:38:02.008]                   }
[13:38:02.008]                   muffleCondition(cond)
[13:38:02.008]                 })
[13:38:02.008]             }))
[13:38:02.008]             future::FutureResult(value = ...future.value$value, 
[13:38:02.008]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:02.008]                   ...future.rng), globalenv = if (FALSE) 
[13:38:02.008]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:02.008]                     ...future.globalenv.names))
[13:38:02.008]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:02.008]         }, condition = base::local({
[13:38:02.008]             c <- base::c
[13:38:02.008]             inherits <- base::inherits
[13:38:02.008]             invokeRestart <- base::invokeRestart
[13:38:02.008]             length <- base::length
[13:38:02.008]             list <- base::list
[13:38:02.008]             seq.int <- base::seq.int
[13:38:02.008]             signalCondition <- base::signalCondition
[13:38:02.008]             sys.calls <- base::sys.calls
[13:38:02.008]             `[[` <- base::`[[`
[13:38:02.008]             `+` <- base::`+`
[13:38:02.008]             `<<-` <- base::`<<-`
[13:38:02.008]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:02.008]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:02.008]                   3L)]
[13:38:02.008]             }
[13:38:02.008]             function(cond) {
[13:38:02.008]                 is_error <- inherits(cond, "error")
[13:38:02.008]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:02.008]                   NULL)
[13:38:02.008]                 if (is_error) {
[13:38:02.008]                   sessionInformation <- function() {
[13:38:02.008]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:02.008]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:02.008]                       search = base::search(), system = base::Sys.info())
[13:38:02.008]                   }
[13:38:02.008]                   ...future.conditions[[length(...future.conditions) + 
[13:38:02.008]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:02.008]                     cond$call), session = sessionInformation(), 
[13:38:02.008]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:02.008]                   signalCondition(cond)
[13:38:02.008]                 }
[13:38:02.008]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:02.008]                 "immediateCondition"))) {
[13:38:02.008]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:02.008]                   ...future.conditions[[length(...future.conditions) + 
[13:38:02.008]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:02.008]                   if (TRUE && !signal) {
[13:38:02.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:02.008]                     {
[13:38:02.008]                       inherits <- base::inherits
[13:38:02.008]                       invokeRestart <- base::invokeRestart
[13:38:02.008]                       is.null <- base::is.null
[13:38:02.008]                       muffled <- FALSE
[13:38:02.008]                       if (inherits(cond, "message")) {
[13:38:02.008]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:02.008]                         if (muffled) 
[13:38:02.008]                           invokeRestart("muffleMessage")
[13:38:02.008]                       }
[13:38:02.008]                       else if (inherits(cond, "warning")) {
[13:38:02.008]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:02.008]                         if (muffled) 
[13:38:02.008]                           invokeRestart("muffleWarning")
[13:38:02.008]                       }
[13:38:02.008]                       else if (inherits(cond, "condition")) {
[13:38:02.008]                         if (!is.null(pattern)) {
[13:38:02.008]                           computeRestarts <- base::computeRestarts
[13:38:02.008]                           grepl <- base::grepl
[13:38:02.008]                           restarts <- computeRestarts(cond)
[13:38:02.008]                           for (restart in restarts) {
[13:38:02.008]                             name <- restart$name
[13:38:02.008]                             if (is.null(name)) 
[13:38:02.008]                               next
[13:38:02.008]                             if (!grepl(pattern, name)) 
[13:38:02.008]                               next
[13:38:02.008]                             invokeRestart(restart)
[13:38:02.008]                             muffled <- TRUE
[13:38:02.008]                             break
[13:38:02.008]                           }
[13:38:02.008]                         }
[13:38:02.008]                       }
[13:38:02.008]                       invisible(muffled)
[13:38:02.008]                     }
[13:38:02.008]                     muffleCondition(cond, pattern = "^muffle")
[13:38:02.008]                   }
[13:38:02.008]                 }
[13:38:02.008]                 else {
[13:38:02.008]                   if (TRUE) {
[13:38:02.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:02.008]                     {
[13:38:02.008]                       inherits <- base::inherits
[13:38:02.008]                       invokeRestart <- base::invokeRestart
[13:38:02.008]                       is.null <- base::is.null
[13:38:02.008]                       muffled <- FALSE
[13:38:02.008]                       if (inherits(cond, "message")) {
[13:38:02.008]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:02.008]                         if (muffled) 
[13:38:02.008]                           invokeRestart("muffleMessage")
[13:38:02.008]                       }
[13:38:02.008]                       else if (inherits(cond, "warning")) {
[13:38:02.008]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:02.008]                         if (muffled) 
[13:38:02.008]                           invokeRestart("muffleWarning")
[13:38:02.008]                       }
[13:38:02.008]                       else if (inherits(cond, "condition")) {
[13:38:02.008]                         if (!is.null(pattern)) {
[13:38:02.008]                           computeRestarts <- base::computeRestarts
[13:38:02.008]                           grepl <- base::grepl
[13:38:02.008]                           restarts <- computeRestarts(cond)
[13:38:02.008]                           for (restart in restarts) {
[13:38:02.008]                             name <- restart$name
[13:38:02.008]                             if (is.null(name)) 
[13:38:02.008]                               next
[13:38:02.008]                             if (!grepl(pattern, name)) 
[13:38:02.008]                               next
[13:38:02.008]                             invokeRestart(restart)
[13:38:02.008]                             muffled <- TRUE
[13:38:02.008]                             break
[13:38:02.008]                           }
[13:38:02.008]                         }
[13:38:02.008]                       }
[13:38:02.008]                       invisible(muffled)
[13:38:02.008]                     }
[13:38:02.008]                     muffleCondition(cond, pattern = "^muffle")
[13:38:02.008]                   }
[13:38:02.008]                 }
[13:38:02.008]             }
[13:38:02.008]         }))
[13:38:02.008]     }, error = function(ex) {
[13:38:02.008]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:02.008]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:02.008]                 ...future.rng), started = ...future.startTime, 
[13:38:02.008]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:02.008]             version = "1.8"), class = "FutureResult")
[13:38:02.008]     }, finally = {
[13:38:02.008]         if (!identical(...future.workdir, getwd())) 
[13:38:02.008]             setwd(...future.workdir)
[13:38:02.008]         {
[13:38:02.008]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:02.008]                 ...future.oldOptions$nwarnings <- NULL
[13:38:02.008]             }
[13:38:02.008]             base::options(...future.oldOptions)
[13:38:02.008]             if (.Platform$OS.type == "windows") {
[13:38:02.008]                 old_names <- names(...future.oldEnvVars)
[13:38:02.008]                 envs <- base::Sys.getenv()
[13:38:02.008]                 names <- names(envs)
[13:38:02.008]                 common <- intersect(names, old_names)
[13:38:02.008]                 added <- setdiff(names, old_names)
[13:38:02.008]                 removed <- setdiff(old_names, names)
[13:38:02.008]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:02.008]                   envs[common]]
[13:38:02.008]                 NAMES <- toupper(changed)
[13:38:02.008]                 args <- list()
[13:38:02.008]                 for (kk in seq_along(NAMES)) {
[13:38:02.008]                   name <- changed[[kk]]
[13:38:02.008]                   NAME <- NAMES[[kk]]
[13:38:02.008]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:02.008]                     next
[13:38:02.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:02.008]                 }
[13:38:02.008]                 NAMES <- toupper(added)
[13:38:02.008]                 for (kk in seq_along(NAMES)) {
[13:38:02.008]                   name <- added[[kk]]
[13:38:02.008]                   NAME <- NAMES[[kk]]
[13:38:02.008]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:02.008]                     next
[13:38:02.008]                   args[[name]] <- ""
[13:38:02.008]                 }
[13:38:02.008]                 NAMES <- toupper(removed)
[13:38:02.008]                 for (kk in seq_along(NAMES)) {
[13:38:02.008]                   name <- removed[[kk]]
[13:38:02.008]                   NAME <- NAMES[[kk]]
[13:38:02.008]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:02.008]                     next
[13:38:02.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:02.008]                 }
[13:38:02.008]                 if (length(args) > 0) 
[13:38:02.008]                   base::do.call(base::Sys.setenv, args = args)
[13:38:02.008]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:02.008]             }
[13:38:02.008]             else {
[13:38:02.008]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:02.008]             }
[13:38:02.008]             {
[13:38:02.008]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:02.008]                   0L) {
[13:38:02.008]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:02.008]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:02.008]                   base::options(opts)
[13:38:02.008]                 }
[13:38:02.008]                 {
[13:38:02.008]                   {
[13:38:02.008]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:02.008]                     NULL
[13:38:02.008]                   }
[13:38:02.008]                   options(future.plan = NULL)
[13:38:02.008]                   if (is.na(NA_character_)) 
[13:38:02.008]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:02.008]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:02.008]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:02.008]                     .init = FALSE)
[13:38:02.008]                 }
[13:38:02.008]             }
[13:38:02.008]         }
[13:38:02.008]     })
[13:38:02.008]     if (TRUE) {
[13:38:02.008]         base::sink(type = "output", split = FALSE)
[13:38:02.008]         if (TRUE) {
[13:38:02.008]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:02.008]         }
[13:38:02.008]         else {
[13:38:02.008]             ...future.result["stdout"] <- base::list(NULL)
[13:38:02.008]         }
[13:38:02.008]         base::close(...future.stdout)
[13:38:02.008]         ...future.stdout <- NULL
[13:38:02.008]     }
[13:38:02.008]     ...future.result$conditions <- ...future.conditions
[13:38:02.008]     ...future.result$finished <- base::Sys.time()
[13:38:02.008]     ...future.result
[13:38:02.008] }
[13:38:02.011] MultisessionFuture started
[13:38:02.011] - Launch lazy future ... done
[13:38:02.011] run() for ‘MultisessionFuture’ ... done
[13:38:02.011] resolve() on list environment ...
[13:38:02.011]  recursive: 0
[13:38:02.012]  length: 3
[13:38:02.012]  elements: ‘a’, ‘b’, ‘c’
[13:38:02.012] receiveMessageFromWorker() for ClusterFuture ...
[13:38:02.013] - Validating connection of MultisessionFuture
[13:38:02.013] - received message: FutureResult
[13:38:02.013] - Received FutureResult
[13:38:02.013] - Erased future from FutureRegistry
[13:38:02.013] result() for ClusterFuture ...
[13:38:02.013] - result already collected: FutureResult
[13:38:02.013] result() for ClusterFuture ... done
[13:38:02.013] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:02.013] Future #1
[13:38:02.013]  length: 2 (resolved future 1)
[13:38:02.014] receiveMessageFromWorker() for ClusterFuture ...
[13:38:02.014] - Validating connection of MultisessionFuture
[13:38:02.014] - received message: FutureResult
[13:38:02.014] - Received FutureResult
[13:38:02.014] - Erased future from FutureRegistry
[13:38:02.015] result() for ClusterFuture ...
[13:38:02.015] - result already collected: FutureResult
[13:38:02.015] result() for ClusterFuture ... done
[13:38:02.015] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:02.015] Future #2
[13:38:02.015]  length: 1 (resolved future 2)
[13:38:02.015]  length: 0 (resolved future 3)
[13:38:02.015] resolve() on list environment ... DONE
[13:38:02.016] getGlobalsAndPackages() ...
[13:38:02.016] Searching for globals...
[13:38:02.016] - globals found: [1] ‘{’
[13:38:02.016] Searching for globals ... DONE
[13:38:02.016] Resolving globals: FALSE
[13:38:02.017] 
[13:38:02.017] 
[13:38:02.017] getGlobalsAndPackages() ... DONE
[13:38:02.017] run() for ‘Future’ ...
[13:38:02.017] - state: ‘created’
[13:38:02.017] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:02.031] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:02.031] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:02.032]   - Field: ‘node’
[13:38:02.032]   - Field: ‘label’
[13:38:02.032]   - Field: ‘local’
[13:38:02.032]   - Field: ‘owner’
[13:38:02.032]   - Field: ‘envir’
[13:38:02.032]   - Field: ‘workers’
[13:38:02.032]   - Field: ‘packages’
[13:38:02.032]   - Field: ‘gc’
[13:38:02.032]   - Field: ‘conditions’
[13:38:02.032]   - Field: ‘persistent’
[13:38:02.033]   - Field: ‘expr’
[13:38:02.033]   - Field: ‘uuid’
[13:38:02.033]   - Field: ‘seed’
[13:38:02.033]   - Field: ‘version’
[13:38:02.033]   - Field: ‘result’
[13:38:02.033]   - Field: ‘asynchronous’
[13:38:02.033]   - Field: ‘calls’
[13:38:02.033]   - Field: ‘globals’
[13:38:02.033]   - Field: ‘stdout’
[13:38:02.033]   - Field: ‘earlySignal’
[13:38:02.033]   - Field: ‘lazy’
[13:38:02.034]   - Field: ‘state’
[13:38:02.034] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:02.034] - Launch lazy future ...
[13:38:02.034] Packages needed by the future expression (n = 0): <none>
[13:38:02.034] Packages needed by future strategies (n = 0): <none>
[13:38:02.035] {
[13:38:02.035]     {
[13:38:02.035]         {
[13:38:02.035]             ...future.startTime <- base::Sys.time()
[13:38:02.035]             {
[13:38:02.035]                 {
[13:38:02.035]                   {
[13:38:02.035]                     {
[13:38:02.035]                       base::local({
[13:38:02.035]                         has_future <- base::requireNamespace("future", 
[13:38:02.035]                           quietly = TRUE)
[13:38:02.035]                         if (has_future) {
[13:38:02.035]                           ns <- base::getNamespace("future")
[13:38:02.035]                           version <- ns[[".package"]][["version"]]
[13:38:02.035]                           if (is.null(version)) 
[13:38:02.035]                             version <- utils::packageVersion("future")
[13:38:02.035]                         }
[13:38:02.035]                         else {
[13:38:02.035]                           version <- NULL
[13:38:02.035]                         }
[13:38:02.035]                         if (!has_future || version < "1.8.0") {
[13:38:02.035]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:02.035]                             "", base::R.version$version.string), 
[13:38:02.035]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:02.035]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:02.035]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:02.035]                               "release", "version")], collapse = " "), 
[13:38:02.035]                             hostname = base::Sys.info()[["nodename"]])
[13:38:02.035]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:02.035]                             info)
[13:38:02.035]                           info <- base::paste(info, collapse = "; ")
[13:38:02.035]                           if (!has_future) {
[13:38:02.035]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:02.035]                               info)
[13:38:02.035]                           }
[13:38:02.035]                           else {
[13:38:02.035]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:02.035]                               info, version)
[13:38:02.035]                           }
[13:38:02.035]                           base::stop(msg)
[13:38:02.035]                         }
[13:38:02.035]                       })
[13:38:02.035]                     }
[13:38:02.035]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:02.035]                     base::options(mc.cores = 1L)
[13:38:02.035]                   }
[13:38:02.035]                   ...future.strategy.old <- future::plan("list")
[13:38:02.035]                   options(future.plan = NULL)
[13:38:02.035]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:02.035]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:02.035]                 }
[13:38:02.035]                 ...future.workdir <- getwd()
[13:38:02.035]             }
[13:38:02.035]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:02.035]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:02.035]         }
[13:38:02.035]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:02.035]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:02.035]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:02.035]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:02.035]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:02.035]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:02.035]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:02.035]             base::names(...future.oldOptions))
[13:38:02.035]     }
[13:38:02.035]     if (FALSE) {
[13:38:02.035]     }
[13:38:02.035]     else {
[13:38:02.035]         if (TRUE) {
[13:38:02.035]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:02.035]                 open = "w")
[13:38:02.035]         }
[13:38:02.035]         else {
[13:38:02.035]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:02.035]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:02.035]         }
[13:38:02.035]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:02.035]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:02.035]             base::sink(type = "output", split = FALSE)
[13:38:02.035]             base::close(...future.stdout)
[13:38:02.035]         }, add = TRUE)
[13:38:02.035]     }
[13:38:02.035]     ...future.frame <- base::sys.nframe()
[13:38:02.035]     ...future.conditions <- base::list()
[13:38:02.035]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:02.035]     if (FALSE) {
[13:38:02.035]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:02.035]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:02.035]     }
[13:38:02.035]     ...future.result <- base::tryCatch({
[13:38:02.035]         base::withCallingHandlers({
[13:38:02.035]             ...future.value <- base::withVisible(base::local({
[13:38:02.035]                 ...future.makeSendCondition <- base::local({
[13:38:02.035]                   sendCondition <- NULL
[13:38:02.035]                   function(frame = 1L) {
[13:38:02.035]                     if (is.function(sendCondition)) 
[13:38:02.035]                       return(sendCondition)
[13:38:02.035]                     ns <- getNamespace("parallel")
[13:38:02.035]                     if (exists("sendData", mode = "function", 
[13:38:02.035]                       envir = ns)) {
[13:38:02.035]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:02.035]                         envir = ns)
[13:38:02.035]                       envir <- sys.frame(frame)
[13:38:02.035]                       master <- NULL
[13:38:02.035]                       while (!identical(envir, .GlobalEnv) && 
[13:38:02.035]                         !identical(envir, emptyenv())) {
[13:38:02.035]                         if (exists("master", mode = "list", envir = envir, 
[13:38:02.035]                           inherits = FALSE)) {
[13:38:02.035]                           master <- get("master", mode = "list", 
[13:38:02.035]                             envir = envir, inherits = FALSE)
[13:38:02.035]                           if (inherits(master, c("SOCKnode", 
[13:38:02.035]                             "SOCK0node"))) {
[13:38:02.035]                             sendCondition <<- function(cond) {
[13:38:02.035]                               data <- list(type = "VALUE", value = cond, 
[13:38:02.035]                                 success = TRUE)
[13:38:02.035]                               parallel_sendData(master, data)
[13:38:02.035]                             }
[13:38:02.035]                             return(sendCondition)
[13:38:02.035]                           }
[13:38:02.035]                         }
[13:38:02.035]                         frame <- frame + 1L
[13:38:02.035]                         envir <- sys.frame(frame)
[13:38:02.035]                       }
[13:38:02.035]                     }
[13:38:02.035]                     sendCondition <<- function(cond) NULL
[13:38:02.035]                   }
[13:38:02.035]                 })
[13:38:02.035]                 withCallingHandlers({
[13:38:02.035]                   {
[13:38:02.035]                     1
[13:38:02.035]                   }
[13:38:02.035]                 }, immediateCondition = function(cond) {
[13:38:02.035]                   sendCondition <- ...future.makeSendCondition()
[13:38:02.035]                   sendCondition(cond)
[13:38:02.035]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:02.035]                   {
[13:38:02.035]                     inherits <- base::inherits
[13:38:02.035]                     invokeRestart <- base::invokeRestart
[13:38:02.035]                     is.null <- base::is.null
[13:38:02.035]                     muffled <- FALSE
[13:38:02.035]                     if (inherits(cond, "message")) {
[13:38:02.035]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:02.035]                       if (muffled) 
[13:38:02.035]                         invokeRestart("muffleMessage")
[13:38:02.035]                     }
[13:38:02.035]                     else if (inherits(cond, "warning")) {
[13:38:02.035]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:02.035]                       if (muffled) 
[13:38:02.035]                         invokeRestart("muffleWarning")
[13:38:02.035]                     }
[13:38:02.035]                     else if (inherits(cond, "condition")) {
[13:38:02.035]                       if (!is.null(pattern)) {
[13:38:02.035]                         computeRestarts <- base::computeRestarts
[13:38:02.035]                         grepl <- base::grepl
[13:38:02.035]                         restarts <- computeRestarts(cond)
[13:38:02.035]                         for (restart in restarts) {
[13:38:02.035]                           name <- restart$name
[13:38:02.035]                           if (is.null(name)) 
[13:38:02.035]                             next
[13:38:02.035]                           if (!grepl(pattern, name)) 
[13:38:02.035]                             next
[13:38:02.035]                           invokeRestart(restart)
[13:38:02.035]                           muffled <- TRUE
[13:38:02.035]                           break
[13:38:02.035]                         }
[13:38:02.035]                       }
[13:38:02.035]                     }
[13:38:02.035]                     invisible(muffled)
[13:38:02.035]                   }
[13:38:02.035]                   muffleCondition(cond)
[13:38:02.035]                 })
[13:38:02.035]             }))
[13:38:02.035]             future::FutureResult(value = ...future.value$value, 
[13:38:02.035]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:02.035]                   ...future.rng), globalenv = if (FALSE) 
[13:38:02.035]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:02.035]                     ...future.globalenv.names))
[13:38:02.035]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:02.035]         }, condition = base::local({
[13:38:02.035]             c <- base::c
[13:38:02.035]             inherits <- base::inherits
[13:38:02.035]             invokeRestart <- base::invokeRestart
[13:38:02.035]             length <- base::length
[13:38:02.035]             list <- base::list
[13:38:02.035]             seq.int <- base::seq.int
[13:38:02.035]             signalCondition <- base::signalCondition
[13:38:02.035]             sys.calls <- base::sys.calls
[13:38:02.035]             `[[` <- base::`[[`
[13:38:02.035]             `+` <- base::`+`
[13:38:02.035]             `<<-` <- base::`<<-`
[13:38:02.035]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:02.035]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:02.035]                   3L)]
[13:38:02.035]             }
[13:38:02.035]             function(cond) {
[13:38:02.035]                 is_error <- inherits(cond, "error")
[13:38:02.035]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:02.035]                   NULL)
[13:38:02.035]                 if (is_error) {
[13:38:02.035]                   sessionInformation <- function() {
[13:38:02.035]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:02.035]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:02.035]                       search = base::search(), system = base::Sys.info())
[13:38:02.035]                   }
[13:38:02.035]                   ...future.conditions[[length(...future.conditions) + 
[13:38:02.035]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:02.035]                     cond$call), session = sessionInformation(), 
[13:38:02.035]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:02.035]                   signalCondition(cond)
[13:38:02.035]                 }
[13:38:02.035]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:02.035]                 "immediateCondition"))) {
[13:38:02.035]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:02.035]                   ...future.conditions[[length(...future.conditions) + 
[13:38:02.035]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:02.035]                   if (TRUE && !signal) {
[13:38:02.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:02.035]                     {
[13:38:02.035]                       inherits <- base::inherits
[13:38:02.035]                       invokeRestart <- base::invokeRestart
[13:38:02.035]                       is.null <- base::is.null
[13:38:02.035]                       muffled <- FALSE
[13:38:02.035]                       if (inherits(cond, "message")) {
[13:38:02.035]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:02.035]                         if (muffled) 
[13:38:02.035]                           invokeRestart("muffleMessage")
[13:38:02.035]                       }
[13:38:02.035]                       else if (inherits(cond, "warning")) {
[13:38:02.035]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:02.035]                         if (muffled) 
[13:38:02.035]                           invokeRestart("muffleWarning")
[13:38:02.035]                       }
[13:38:02.035]                       else if (inherits(cond, "condition")) {
[13:38:02.035]                         if (!is.null(pattern)) {
[13:38:02.035]                           computeRestarts <- base::computeRestarts
[13:38:02.035]                           grepl <- base::grepl
[13:38:02.035]                           restarts <- computeRestarts(cond)
[13:38:02.035]                           for (restart in restarts) {
[13:38:02.035]                             name <- restart$name
[13:38:02.035]                             if (is.null(name)) 
[13:38:02.035]                               next
[13:38:02.035]                             if (!grepl(pattern, name)) 
[13:38:02.035]                               next
[13:38:02.035]                             invokeRestart(restart)
[13:38:02.035]                             muffled <- TRUE
[13:38:02.035]                             break
[13:38:02.035]                           }
[13:38:02.035]                         }
[13:38:02.035]                       }
[13:38:02.035]                       invisible(muffled)
[13:38:02.035]                     }
[13:38:02.035]                     muffleCondition(cond, pattern = "^muffle")
[13:38:02.035]                   }
[13:38:02.035]                 }
[13:38:02.035]                 else {
[13:38:02.035]                   if (TRUE) {
[13:38:02.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:02.035]                     {
[13:38:02.035]                       inherits <- base::inherits
[13:38:02.035]                       invokeRestart <- base::invokeRestart
[13:38:02.035]                       is.null <- base::is.null
[13:38:02.035]                       muffled <- FALSE
[13:38:02.035]                       if (inherits(cond, "message")) {
[13:38:02.035]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:02.035]                         if (muffled) 
[13:38:02.035]                           invokeRestart("muffleMessage")
[13:38:02.035]                       }
[13:38:02.035]                       else if (inherits(cond, "warning")) {
[13:38:02.035]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:02.035]                         if (muffled) 
[13:38:02.035]                           invokeRestart("muffleWarning")
[13:38:02.035]                       }
[13:38:02.035]                       else if (inherits(cond, "condition")) {
[13:38:02.035]                         if (!is.null(pattern)) {
[13:38:02.035]                           computeRestarts <- base::computeRestarts
[13:38:02.035]                           grepl <- base::grepl
[13:38:02.035]                           restarts <- computeRestarts(cond)
[13:38:02.035]                           for (restart in restarts) {
[13:38:02.035]                             name <- restart$name
[13:38:02.035]                             if (is.null(name)) 
[13:38:02.035]                               next
[13:38:02.035]                             if (!grepl(pattern, name)) 
[13:38:02.035]                               next
[13:38:02.035]                             invokeRestart(restart)
[13:38:02.035]                             muffled <- TRUE
[13:38:02.035]                             break
[13:38:02.035]                           }
[13:38:02.035]                         }
[13:38:02.035]                       }
[13:38:02.035]                       invisible(muffled)
[13:38:02.035]                     }
[13:38:02.035]                     muffleCondition(cond, pattern = "^muffle")
[13:38:02.035]                   }
[13:38:02.035]                 }
[13:38:02.035]             }
[13:38:02.035]         }))
[13:38:02.035]     }, error = function(ex) {
[13:38:02.035]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:02.035]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:02.035]                 ...future.rng), started = ...future.startTime, 
[13:38:02.035]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:02.035]             version = "1.8"), class = "FutureResult")
[13:38:02.035]     }, finally = {
[13:38:02.035]         if (!identical(...future.workdir, getwd())) 
[13:38:02.035]             setwd(...future.workdir)
[13:38:02.035]         {
[13:38:02.035]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:02.035]                 ...future.oldOptions$nwarnings <- NULL
[13:38:02.035]             }
[13:38:02.035]             base::options(...future.oldOptions)
[13:38:02.035]             if (.Platform$OS.type == "windows") {
[13:38:02.035]                 old_names <- names(...future.oldEnvVars)
[13:38:02.035]                 envs <- base::Sys.getenv()
[13:38:02.035]                 names <- names(envs)
[13:38:02.035]                 common <- intersect(names, old_names)
[13:38:02.035]                 added <- setdiff(names, old_names)
[13:38:02.035]                 removed <- setdiff(old_names, names)
[13:38:02.035]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:02.035]                   envs[common]]
[13:38:02.035]                 NAMES <- toupper(changed)
[13:38:02.035]                 args <- list()
[13:38:02.035]                 for (kk in seq_along(NAMES)) {
[13:38:02.035]                   name <- changed[[kk]]
[13:38:02.035]                   NAME <- NAMES[[kk]]
[13:38:02.035]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:02.035]                     next
[13:38:02.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:02.035]                 }
[13:38:02.035]                 NAMES <- toupper(added)
[13:38:02.035]                 for (kk in seq_along(NAMES)) {
[13:38:02.035]                   name <- added[[kk]]
[13:38:02.035]                   NAME <- NAMES[[kk]]
[13:38:02.035]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:02.035]                     next
[13:38:02.035]                   args[[name]] <- ""
[13:38:02.035]                 }
[13:38:02.035]                 NAMES <- toupper(removed)
[13:38:02.035]                 for (kk in seq_along(NAMES)) {
[13:38:02.035]                   name <- removed[[kk]]
[13:38:02.035]                   NAME <- NAMES[[kk]]
[13:38:02.035]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:02.035]                     next
[13:38:02.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:02.035]                 }
[13:38:02.035]                 if (length(args) > 0) 
[13:38:02.035]                   base::do.call(base::Sys.setenv, args = args)
[13:38:02.035]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:02.035]             }
[13:38:02.035]             else {
[13:38:02.035]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:02.035]             }
[13:38:02.035]             {
[13:38:02.035]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:02.035]                   0L) {
[13:38:02.035]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:02.035]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:02.035]                   base::options(opts)
[13:38:02.035]                 }
[13:38:02.035]                 {
[13:38:02.035]                   {
[13:38:02.035]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:02.035]                     NULL
[13:38:02.035]                   }
[13:38:02.035]                   options(future.plan = NULL)
[13:38:02.035]                   if (is.na(NA_character_)) 
[13:38:02.035]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:02.035]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:02.035]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:02.035]                     .init = FALSE)
[13:38:02.035]                 }
[13:38:02.035]             }
[13:38:02.035]         }
[13:38:02.035]     })
[13:38:02.035]     if (TRUE) {
[13:38:02.035]         base::sink(type = "output", split = FALSE)
[13:38:02.035]         if (TRUE) {
[13:38:02.035]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:02.035]         }
[13:38:02.035]         else {
[13:38:02.035]             ...future.result["stdout"] <- base::list(NULL)
[13:38:02.035]         }
[13:38:02.035]         base::close(...future.stdout)
[13:38:02.035]         ...future.stdout <- NULL
[13:38:02.035]     }
[13:38:02.035]     ...future.result$conditions <- ...future.conditions
[13:38:02.035]     ...future.result$finished <- base::Sys.time()
[13:38:02.035]     ...future.result
[13:38:02.035] }
[13:38:02.038] MultisessionFuture started
[13:38:02.038] - Launch lazy future ... done
[13:38:02.038] run() for ‘MultisessionFuture’ ... done
[13:38:02.038] getGlobalsAndPackages() ...
[13:38:02.038] Searching for globals...
[13:38:02.039] - globals found: [2] ‘{’, ‘Sys.sleep’
[13:38:02.039] Searching for globals ... DONE
[13:38:02.040] Resolving globals: FALSE
[13:38:02.040] 
[13:38:02.040] 
[13:38:02.040] getGlobalsAndPackages() ... DONE
[13:38:02.040] run() for ‘Future’ ...
[13:38:02.040] - state: ‘created’
[13:38:02.040] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:02.054] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:02.054] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:02.054]   - Field: ‘node’
[13:38:02.054]   - Field: ‘label’
[13:38:02.055]   - Field: ‘local’
[13:38:02.055]   - Field: ‘owner’
[13:38:02.055]   - Field: ‘envir’
[13:38:02.055]   - Field: ‘workers’
[13:38:02.055]   - Field: ‘packages’
[13:38:02.055]   - Field: ‘gc’
[13:38:02.055]   - Field: ‘conditions’
[13:38:02.055]   - Field: ‘persistent’
[13:38:02.055]   - Field: ‘expr’
[13:38:02.055]   - Field: ‘uuid’
[13:38:02.055]   - Field: ‘seed’
[13:38:02.056]   - Field: ‘version’
[13:38:02.056]   - Field: ‘result’
[13:38:02.056]   - Field: ‘asynchronous’
[13:38:02.056]   - Field: ‘calls’
[13:38:02.056]   - Field: ‘globals’
[13:38:02.056]   - Field: ‘stdout’
[13:38:02.056]   - Field: ‘earlySignal’
[13:38:02.056]   - Field: ‘lazy’
[13:38:02.056]   - Field: ‘state’
[13:38:02.056] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:02.056] - Launch lazy future ...
[13:38:02.057] Packages needed by the future expression (n = 0): <none>
[13:38:02.057] Packages needed by future strategies (n = 0): <none>
[13:38:02.057] {
[13:38:02.057]     {
[13:38:02.057]         {
[13:38:02.057]             ...future.startTime <- base::Sys.time()
[13:38:02.057]             {
[13:38:02.057]                 {
[13:38:02.057]                   {
[13:38:02.057]                     {
[13:38:02.057]                       base::local({
[13:38:02.057]                         has_future <- base::requireNamespace("future", 
[13:38:02.057]                           quietly = TRUE)
[13:38:02.057]                         if (has_future) {
[13:38:02.057]                           ns <- base::getNamespace("future")
[13:38:02.057]                           version <- ns[[".package"]][["version"]]
[13:38:02.057]                           if (is.null(version)) 
[13:38:02.057]                             version <- utils::packageVersion("future")
[13:38:02.057]                         }
[13:38:02.057]                         else {
[13:38:02.057]                           version <- NULL
[13:38:02.057]                         }
[13:38:02.057]                         if (!has_future || version < "1.8.0") {
[13:38:02.057]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:02.057]                             "", base::R.version$version.string), 
[13:38:02.057]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:02.057]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:02.057]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:02.057]                               "release", "version")], collapse = " "), 
[13:38:02.057]                             hostname = base::Sys.info()[["nodename"]])
[13:38:02.057]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:02.057]                             info)
[13:38:02.057]                           info <- base::paste(info, collapse = "; ")
[13:38:02.057]                           if (!has_future) {
[13:38:02.057]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:02.057]                               info)
[13:38:02.057]                           }
[13:38:02.057]                           else {
[13:38:02.057]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:02.057]                               info, version)
[13:38:02.057]                           }
[13:38:02.057]                           base::stop(msg)
[13:38:02.057]                         }
[13:38:02.057]                       })
[13:38:02.057]                     }
[13:38:02.057]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:02.057]                     base::options(mc.cores = 1L)
[13:38:02.057]                   }
[13:38:02.057]                   ...future.strategy.old <- future::plan("list")
[13:38:02.057]                   options(future.plan = NULL)
[13:38:02.057]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:02.057]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:02.057]                 }
[13:38:02.057]                 ...future.workdir <- getwd()
[13:38:02.057]             }
[13:38:02.057]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:02.057]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:02.057]         }
[13:38:02.057]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:02.057]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:02.057]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:02.057]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:02.057]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:02.057]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:02.057]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:02.057]             base::names(...future.oldOptions))
[13:38:02.057]     }
[13:38:02.057]     if (FALSE) {
[13:38:02.057]     }
[13:38:02.057]     else {
[13:38:02.057]         if (TRUE) {
[13:38:02.057]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:02.057]                 open = "w")
[13:38:02.057]         }
[13:38:02.057]         else {
[13:38:02.057]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:02.057]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:02.057]         }
[13:38:02.057]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:02.057]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:02.057]             base::sink(type = "output", split = FALSE)
[13:38:02.057]             base::close(...future.stdout)
[13:38:02.057]         }, add = TRUE)
[13:38:02.057]     }
[13:38:02.057]     ...future.frame <- base::sys.nframe()
[13:38:02.057]     ...future.conditions <- base::list()
[13:38:02.057]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:02.057]     if (FALSE) {
[13:38:02.057]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:02.057]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:02.057]     }
[13:38:02.057]     ...future.result <- base::tryCatch({
[13:38:02.057]         base::withCallingHandlers({
[13:38:02.057]             ...future.value <- base::withVisible(base::local({
[13:38:02.057]                 ...future.makeSendCondition <- base::local({
[13:38:02.057]                   sendCondition <- NULL
[13:38:02.057]                   function(frame = 1L) {
[13:38:02.057]                     if (is.function(sendCondition)) 
[13:38:02.057]                       return(sendCondition)
[13:38:02.057]                     ns <- getNamespace("parallel")
[13:38:02.057]                     if (exists("sendData", mode = "function", 
[13:38:02.057]                       envir = ns)) {
[13:38:02.057]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:02.057]                         envir = ns)
[13:38:02.057]                       envir <- sys.frame(frame)
[13:38:02.057]                       master <- NULL
[13:38:02.057]                       while (!identical(envir, .GlobalEnv) && 
[13:38:02.057]                         !identical(envir, emptyenv())) {
[13:38:02.057]                         if (exists("master", mode = "list", envir = envir, 
[13:38:02.057]                           inherits = FALSE)) {
[13:38:02.057]                           master <- get("master", mode = "list", 
[13:38:02.057]                             envir = envir, inherits = FALSE)
[13:38:02.057]                           if (inherits(master, c("SOCKnode", 
[13:38:02.057]                             "SOCK0node"))) {
[13:38:02.057]                             sendCondition <<- function(cond) {
[13:38:02.057]                               data <- list(type = "VALUE", value = cond, 
[13:38:02.057]                                 success = TRUE)
[13:38:02.057]                               parallel_sendData(master, data)
[13:38:02.057]                             }
[13:38:02.057]                             return(sendCondition)
[13:38:02.057]                           }
[13:38:02.057]                         }
[13:38:02.057]                         frame <- frame + 1L
[13:38:02.057]                         envir <- sys.frame(frame)
[13:38:02.057]                       }
[13:38:02.057]                     }
[13:38:02.057]                     sendCondition <<- function(cond) NULL
[13:38:02.057]                   }
[13:38:02.057]                 })
[13:38:02.057]                 withCallingHandlers({
[13:38:02.057]                   {
[13:38:02.057]                     Sys.sleep(0.5)
[13:38:02.057]                     2
[13:38:02.057]                   }
[13:38:02.057]                 }, immediateCondition = function(cond) {
[13:38:02.057]                   sendCondition <- ...future.makeSendCondition()
[13:38:02.057]                   sendCondition(cond)
[13:38:02.057]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:02.057]                   {
[13:38:02.057]                     inherits <- base::inherits
[13:38:02.057]                     invokeRestart <- base::invokeRestart
[13:38:02.057]                     is.null <- base::is.null
[13:38:02.057]                     muffled <- FALSE
[13:38:02.057]                     if (inherits(cond, "message")) {
[13:38:02.057]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:02.057]                       if (muffled) 
[13:38:02.057]                         invokeRestart("muffleMessage")
[13:38:02.057]                     }
[13:38:02.057]                     else if (inherits(cond, "warning")) {
[13:38:02.057]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:02.057]                       if (muffled) 
[13:38:02.057]                         invokeRestart("muffleWarning")
[13:38:02.057]                     }
[13:38:02.057]                     else if (inherits(cond, "condition")) {
[13:38:02.057]                       if (!is.null(pattern)) {
[13:38:02.057]                         computeRestarts <- base::computeRestarts
[13:38:02.057]                         grepl <- base::grepl
[13:38:02.057]                         restarts <- computeRestarts(cond)
[13:38:02.057]                         for (restart in restarts) {
[13:38:02.057]                           name <- restart$name
[13:38:02.057]                           if (is.null(name)) 
[13:38:02.057]                             next
[13:38:02.057]                           if (!grepl(pattern, name)) 
[13:38:02.057]                             next
[13:38:02.057]                           invokeRestart(restart)
[13:38:02.057]                           muffled <- TRUE
[13:38:02.057]                           break
[13:38:02.057]                         }
[13:38:02.057]                       }
[13:38:02.057]                     }
[13:38:02.057]                     invisible(muffled)
[13:38:02.057]                   }
[13:38:02.057]                   muffleCondition(cond)
[13:38:02.057]                 })
[13:38:02.057]             }))
[13:38:02.057]             future::FutureResult(value = ...future.value$value, 
[13:38:02.057]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:02.057]                   ...future.rng), globalenv = if (FALSE) 
[13:38:02.057]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:02.057]                     ...future.globalenv.names))
[13:38:02.057]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:02.057]         }, condition = base::local({
[13:38:02.057]             c <- base::c
[13:38:02.057]             inherits <- base::inherits
[13:38:02.057]             invokeRestart <- base::invokeRestart
[13:38:02.057]             length <- base::length
[13:38:02.057]             list <- base::list
[13:38:02.057]             seq.int <- base::seq.int
[13:38:02.057]             signalCondition <- base::signalCondition
[13:38:02.057]             sys.calls <- base::sys.calls
[13:38:02.057]             `[[` <- base::`[[`
[13:38:02.057]             `+` <- base::`+`
[13:38:02.057]             `<<-` <- base::`<<-`
[13:38:02.057]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:02.057]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:02.057]                   3L)]
[13:38:02.057]             }
[13:38:02.057]             function(cond) {
[13:38:02.057]                 is_error <- inherits(cond, "error")
[13:38:02.057]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:02.057]                   NULL)
[13:38:02.057]                 if (is_error) {
[13:38:02.057]                   sessionInformation <- function() {
[13:38:02.057]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:02.057]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:02.057]                       search = base::search(), system = base::Sys.info())
[13:38:02.057]                   }
[13:38:02.057]                   ...future.conditions[[length(...future.conditions) + 
[13:38:02.057]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:02.057]                     cond$call), session = sessionInformation(), 
[13:38:02.057]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:02.057]                   signalCondition(cond)
[13:38:02.057]                 }
[13:38:02.057]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:02.057]                 "immediateCondition"))) {
[13:38:02.057]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:02.057]                   ...future.conditions[[length(...future.conditions) + 
[13:38:02.057]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:02.057]                   if (TRUE && !signal) {
[13:38:02.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:02.057]                     {
[13:38:02.057]                       inherits <- base::inherits
[13:38:02.057]                       invokeRestart <- base::invokeRestart
[13:38:02.057]                       is.null <- base::is.null
[13:38:02.057]                       muffled <- FALSE
[13:38:02.057]                       if (inherits(cond, "message")) {
[13:38:02.057]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:02.057]                         if (muffled) 
[13:38:02.057]                           invokeRestart("muffleMessage")
[13:38:02.057]                       }
[13:38:02.057]                       else if (inherits(cond, "warning")) {
[13:38:02.057]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:02.057]                         if (muffled) 
[13:38:02.057]                           invokeRestart("muffleWarning")
[13:38:02.057]                       }
[13:38:02.057]                       else if (inherits(cond, "condition")) {
[13:38:02.057]                         if (!is.null(pattern)) {
[13:38:02.057]                           computeRestarts <- base::computeRestarts
[13:38:02.057]                           grepl <- base::grepl
[13:38:02.057]                           restarts <- computeRestarts(cond)
[13:38:02.057]                           for (restart in restarts) {
[13:38:02.057]                             name <- restart$name
[13:38:02.057]                             if (is.null(name)) 
[13:38:02.057]                               next
[13:38:02.057]                             if (!grepl(pattern, name)) 
[13:38:02.057]                               next
[13:38:02.057]                             invokeRestart(restart)
[13:38:02.057]                             muffled <- TRUE
[13:38:02.057]                             break
[13:38:02.057]                           }
[13:38:02.057]                         }
[13:38:02.057]                       }
[13:38:02.057]                       invisible(muffled)
[13:38:02.057]                     }
[13:38:02.057]                     muffleCondition(cond, pattern = "^muffle")
[13:38:02.057]                   }
[13:38:02.057]                 }
[13:38:02.057]                 else {
[13:38:02.057]                   if (TRUE) {
[13:38:02.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:02.057]                     {
[13:38:02.057]                       inherits <- base::inherits
[13:38:02.057]                       invokeRestart <- base::invokeRestart
[13:38:02.057]                       is.null <- base::is.null
[13:38:02.057]                       muffled <- FALSE
[13:38:02.057]                       if (inherits(cond, "message")) {
[13:38:02.057]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:02.057]                         if (muffled) 
[13:38:02.057]                           invokeRestart("muffleMessage")
[13:38:02.057]                       }
[13:38:02.057]                       else if (inherits(cond, "warning")) {
[13:38:02.057]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:02.057]                         if (muffled) 
[13:38:02.057]                           invokeRestart("muffleWarning")
[13:38:02.057]                       }
[13:38:02.057]                       else if (inherits(cond, "condition")) {
[13:38:02.057]                         if (!is.null(pattern)) {
[13:38:02.057]                           computeRestarts <- base::computeRestarts
[13:38:02.057]                           grepl <- base::grepl
[13:38:02.057]                           restarts <- computeRestarts(cond)
[13:38:02.057]                           for (restart in restarts) {
[13:38:02.057]                             name <- restart$name
[13:38:02.057]                             if (is.null(name)) 
[13:38:02.057]                               next
[13:38:02.057]                             if (!grepl(pattern, name)) 
[13:38:02.057]                               next
[13:38:02.057]                             invokeRestart(restart)
[13:38:02.057]                             muffled <- TRUE
[13:38:02.057]                             break
[13:38:02.057]                           }
[13:38:02.057]                         }
[13:38:02.057]                       }
[13:38:02.057]                       invisible(muffled)
[13:38:02.057]                     }
[13:38:02.057]                     muffleCondition(cond, pattern = "^muffle")
[13:38:02.057]                   }
[13:38:02.057]                 }
[13:38:02.057]             }
[13:38:02.057]         }))
[13:38:02.057]     }, error = function(ex) {
[13:38:02.057]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:02.057]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:02.057]                 ...future.rng), started = ...future.startTime, 
[13:38:02.057]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:02.057]             version = "1.8"), class = "FutureResult")
[13:38:02.057]     }, finally = {
[13:38:02.057]         if (!identical(...future.workdir, getwd())) 
[13:38:02.057]             setwd(...future.workdir)
[13:38:02.057]         {
[13:38:02.057]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:02.057]                 ...future.oldOptions$nwarnings <- NULL
[13:38:02.057]             }
[13:38:02.057]             base::options(...future.oldOptions)
[13:38:02.057]             if (.Platform$OS.type == "windows") {
[13:38:02.057]                 old_names <- names(...future.oldEnvVars)
[13:38:02.057]                 envs <- base::Sys.getenv()
[13:38:02.057]                 names <- names(envs)
[13:38:02.057]                 common <- intersect(names, old_names)
[13:38:02.057]                 added <- setdiff(names, old_names)
[13:38:02.057]                 removed <- setdiff(old_names, names)
[13:38:02.057]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:02.057]                   envs[common]]
[13:38:02.057]                 NAMES <- toupper(changed)
[13:38:02.057]                 args <- list()
[13:38:02.057]                 for (kk in seq_along(NAMES)) {
[13:38:02.057]                   name <- changed[[kk]]
[13:38:02.057]                   NAME <- NAMES[[kk]]
[13:38:02.057]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:02.057]                     next
[13:38:02.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:02.057]                 }
[13:38:02.057]                 NAMES <- toupper(added)
[13:38:02.057]                 for (kk in seq_along(NAMES)) {
[13:38:02.057]                   name <- added[[kk]]
[13:38:02.057]                   NAME <- NAMES[[kk]]
[13:38:02.057]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:02.057]                     next
[13:38:02.057]                   args[[name]] <- ""
[13:38:02.057]                 }
[13:38:02.057]                 NAMES <- toupper(removed)
[13:38:02.057]                 for (kk in seq_along(NAMES)) {
[13:38:02.057]                   name <- removed[[kk]]
[13:38:02.057]                   NAME <- NAMES[[kk]]
[13:38:02.057]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:02.057]                     next
[13:38:02.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:02.057]                 }
[13:38:02.057]                 if (length(args) > 0) 
[13:38:02.057]                   base::do.call(base::Sys.setenv, args = args)
[13:38:02.057]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:02.057]             }
[13:38:02.057]             else {
[13:38:02.057]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:02.057]             }
[13:38:02.057]             {
[13:38:02.057]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:02.057]                   0L) {
[13:38:02.057]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:02.057]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:02.057]                   base::options(opts)
[13:38:02.057]                 }
[13:38:02.057]                 {
[13:38:02.057]                   {
[13:38:02.057]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:02.057]                     NULL
[13:38:02.057]                   }
[13:38:02.057]                   options(future.plan = NULL)
[13:38:02.057]                   if (is.na(NA_character_)) 
[13:38:02.057]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:02.057]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:02.057]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:02.057]                     .init = FALSE)
[13:38:02.057]                 }
[13:38:02.057]             }
[13:38:02.057]         }
[13:38:02.057]     })
[13:38:02.057]     if (TRUE) {
[13:38:02.057]         base::sink(type = "output", split = FALSE)
[13:38:02.057]         if (TRUE) {
[13:38:02.057]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:02.057]         }
[13:38:02.057]         else {
[13:38:02.057]             ...future.result["stdout"] <- base::list(NULL)
[13:38:02.057]         }
[13:38:02.057]         base::close(...future.stdout)
[13:38:02.057]         ...future.stdout <- NULL
[13:38:02.057]     }
[13:38:02.057]     ...future.result$conditions <- ...future.conditions
[13:38:02.057]     ...future.result$finished <- base::Sys.time()
[13:38:02.057]     ...future.result
[13:38:02.057] }
[13:38:02.060] MultisessionFuture started
[13:38:02.061] - Launch lazy future ... done
[13:38:02.061] run() for ‘MultisessionFuture’ ... done
[13:38:02.061] getGlobalsAndPackages() ...
[13:38:02.061] Searching for globals...
[13:38:02.062] - globals found: [1] ‘{’
[13:38:02.062] Searching for globals ... DONE
[13:38:02.062] Resolving globals: FALSE
[13:38:02.063] 
[13:38:02.063] 
[13:38:02.063] getGlobalsAndPackages() ... DONE
[13:38:02.063] run() for ‘Future’ ...
[13:38:02.063] - state: ‘created’
[13:38:02.063] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:38:02.077] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:38:02.077] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:38:02.077]   - Field: ‘node’
[13:38:02.077]   - Field: ‘label’
[13:38:02.077]   - Field: ‘local’
[13:38:02.078]   - Field: ‘owner’
[13:38:02.078]   - Field: ‘envir’
[13:38:02.078]   - Field: ‘workers’
[13:38:02.078]   - Field: ‘packages’
[13:38:02.078]   - Field: ‘gc’
[13:38:02.078]   - Field: ‘conditions’
[13:38:02.078]   - Field: ‘persistent’
[13:38:02.078]   - Field: ‘expr’
[13:38:02.078]   - Field: ‘uuid’
[13:38:02.078]   - Field: ‘seed’
[13:38:02.079]   - Field: ‘version’
[13:38:02.079]   - Field: ‘result’
[13:38:02.079]   - Field: ‘asynchronous’
[13:38:02.079]   - Field: ‘calls’
[13:38:02.079]   - Field: ‘globals’
[13:38:02.079]   - Field: ‘stdout’
[13:38:02.079]   - Field: ‘earlySignal’
[13:38:02.079]   - Field: ‘lazy’
[13:38:02.079]   - Field: ‘state’
[13:38:02.079] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:38:02.079] - Launch lazy future ...
[13:38:02.080] Packages needed by the future expression (n = 0): <none>
[13:38:02.080] Packages needed by future strategies (n = 0): <none>
[13:38:02.080] {
[13:38:02.080]     {
[13:38:02.080]         {
[13:38:02.080]             ...future.startTime <- base::Sys.time()
[13:38:02.080]             {
[13:38:02.080]                 {
[13:38:02.080]                   {
[13:38:02.080]                     {
[13:38:02.080]                       base::local({
[13:38:02.080]                         has_future <- base::requireNamespace("future", 
[13:38:02.080]                           quietly = TRUE)
[13:38:02.080]                         if (has_future) {
[13:38:02.080]                           ns <- base::getNamespace("future")
[13:38:02.080]                           version <- ns[[".package"]][["version"]]
[13:38:02.080]                           if (is.null(version)) 
[13:38:02.080]                             version <- utils::packageVersion("future")
[13:38:02.080]                         }
[13:38:02.080]                         else {
[13:38:02.080]                           version <- NULL
[13:38:02.080]                         }
[13:38:02.080]                         if (!has_future || version < "1.8.0") {
[13:38:02.080]                           info <- base::c(r_version = base::gsub("R version ", 
[13:38:02.080]                             "", base::R.version$version.string), 
[13:38:02.080]                             platform = base::sprintf("%s (%s-bit)", 
[13:38:02.080]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:38:02.080]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:38:02.080]                               "release", "version")], collapse = " "), 
[13:38:02.080]                             hostname = base::Sys.info()[["nodename"]])
[13:38:02.080]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:38:02.080]                             info)
[13:38:02.080]                           info <- base::paste(info, collapse = "; ")
[13:38:02.080]                           if (!has_future) {
[13:38:02.080]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:38:02.080]                               info)
[13:38:02.080]                           }
[13:38:02.080]                           else {
[13:38:02.080]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:38:02.080]                               info, version)
[13:38:02.080]                           }
[13:38:02.080]                           base::stop(msg)
[13:38:02.080]                         }
[13:38:02.080]                       })
[13:38:02.080]                     }
[13:38:02.080]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:38:02.080]                     base::options(mc.cores = 1L)
[13:38:02.080]                   }
[13:38:02.080]                   ...future.strategy.old <- future::plan("list")
[13:38:02.080]                   options(future.plan = NULL)
[13:38:02.080]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:38:02.080]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:38:02.080]                 }
[13:38:02.080]                 ...future.workdir <- getwd()
[13:38:02.080]             }
[13:38:02.080]             ...future.oldOptions <- base::as.list(base::.Options)
[13:38:02.080]             ...future.oldEnvVars <- base::Sys.getenv()
[13:38:02.080]         }
[13:38:02.080]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:38:02.080]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:38:02.080]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:38:02.080]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:38:02.080]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:38:02.080]             future.stdout.windows.reencode = NULL, width = 80L)
[13:38:02.080]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:38:02.080]             base::names(...future.oldOptions))
[13:38:02.080]     }
[13:38:02.080]     if (FALSE) {
[13:38:02.080]     }
[13:38:02.080]     else {
[13:38:02.080]         if (TRUE) {
[13:38:02.080]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:38:02.080]                 open = "w")
[13:38:02.080]         }
[13:38:02.080]         else {
[13:38:02.080]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:38:02.080]                 windows = "NUL", "/dev/null"), open = "w")
[13:38:02.080]         }
[13:38:02.080]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:38:02.080]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:38:02.080]             base::sink(type = "output", split = FALSE)
[13:38:02.080]             base::close(...future.stdout)
[13:38:02.080]         }, add = TRUE)
[13:38:02.080]     }
[13:38:02.080]     ...future.frame <- base::sys.nframe()
[13:38:02.080]     ...future.conditions <- base::list()
[13:38:02.080]     ...future.rng <- base::globalenv()$.Random.seed
[13:38:02.080]     if (FALSE) {
[13:38:02.080]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:38:02.080]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:38:02.080]     }
[13:38:02.080]     ...future.result <- base::tryCatch({
[13:38:02.080]         base::withCallingHandlers({
[13:38:02.080]             ...future.value <- base::withVisible(base::local({
[13:38:02.080]                 ...future.makeSendCondition <- base::local({
[13:38:02.080]                   sendCondition <- NULL
[13:38:02.080]                   function(frame = 1L) {
[13:38:02.080]                     if (is.function(sendCondition)) 
[13:38:02.080]                       return(sendCondition)
[13:38:02.080]                     ns <- getNamespace("parallel")
[13:38:02.080]                     if (exists("sendData", mode = "function", 
[13:38:02.080]                       envir = ns)) {
[13:38:02.080]                       parallel_sendData <- get("sendData", mode = "function", 
[13:38:02.080]                         envir = ns)
[13:38:02.080]                       envir <- sys.frame(frame)
[13:38:02.080]                       master <- NULL
[13:38:02.080]                       while (!identical(envir, .GlobalEnv) && 
[13:38:02.080]                         !identical(envir, emptyenv())) {
[13:38:02.080]                         if (exists("master", mode = "list", envir = envir, 
[13:38:02.080]                           inherits = FALSE)) {
[13:38:02.080]                           master <- get("master", mode = "list", 
[13:38:02.080]                             envir = envir, inherits = FALSE)
[13:38:02.080]                           if (inherits(master, c("SOCKnode", 
[13:38:02.080]                             "SOCK0node"))) {
[13:38:02.080]                             sendCondition <<- function(cond) {
[13:38:02.080]                               data <- list(type = "VALUE", value = cond, 
[13:38:02.080]                                 success = TRUE)
[13:38:02.080]                               parallel_sendData(master, data)
[13:38:02.080]                             }
[13:38:02.080]                             return(sendCondition)
[13:38:02.080]                           }
[13:38:02.080]                         }
[13:38:02.080]                         frame <- frame + 1L
[13:38:02.080]                         envir <- sys.frame(frame)
[13:38:02.080]                       }
[13:38:02.080]                     }
[13:38:02.080]                     sendCondition <<- function(cond) NULL
[13:38:02.080]                   }
[13:38:02.080]                 })
[13:38:02.080]                 withCallingHandlers({
[13:38:02.080]                   {
[13:38:02.080]                     3
[13:38:02.080]                   }
[13:38:02.080]                 }, immediateCondition = function(cond) {
[13:38:02.080]                   sendCondition <- ...future.makeSendCondition()
[13:38:02.080]                   sendCondition(cond)
[13:38:02.080]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:02.080]                   {
[13:38:02.080]                     inherits <- base::inherits
[13:38:02.080]                     invokeRestart <- base::invokeRestart
[13:38:02.080]                     is.null <- base::is.null
[13:38:02.080]                     muffled <- FALSE
[13:38:02.080]                     if (inherits(cond, "message")) {
[13:38:02.080]                       muffled <- grepl(pattern, "muffleMessage")
[13:38:02.080]                       if (muffled) 
[13:38:02.080]                         invokeRestart("muffleMessage")
[13:38:02.080]                     }
[13:38:02.080]                     else if (inherits(cond, "warning")) {
[13:38:02.080]                       muffled <- grepl(pattern, "muffleWarning")
[13:38:02.080]                       if (muffled) 
[13:38:02.080]                         invokeRestart("muffleWarning")
[13:38:02.080]                     }
[13:38:02.080]                     else if (inherits(cond, "condition")) {
[13:38:02.080]                       if (!is.null(pattern)) {
[13:38:02.080]                         computeRestarts <- base::computeRestarts
[13:38:02.080]                         grepl <- base::grepl
[13:38:02.080]                         restarts <- computeRestarts(cond)
[13:38:02.080]                         for (restart in restarts) {
[13:38:02.080]                           name <- restart$name
[13:38:02.080]                           if (is.null(name)) 
[13:38:02.080]                             next
[13:38:02.080]                           if (!grepl(pattern, name)) 
[13:38:02.080]                             next
[13:38:02.080]                           invokeRestart(restart)
[13:38:02.080]                           muffled <- TRUE
[13:38:02.080]                           break
[13:38:02.080]                         }
[13:38:02.080]                       }
[13:38:02.080]                     }
[13:38:02.080]                     invisible(muffled)
[13:38:02.080]                   }
[13:38:02.080]                   muffleCondition(cond)
[13:38:02.080]                 })
[13:38:02.080]             }))
[13:38:02.080]             future::FutureResult(value = ...future.value$value, 
[13:38:02.080]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:02.080]                   ...future.rng), globalenv = if (FALSE) 
[13:38:02.080]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:38:02.080]                     ...future.globalenv.names))
[13:38:02.080]                 else NULL, started = ...future.startTime, version = "1.8")
[13:38:02.080]         }, condition = base::local({
[13:38:02.080]             c <- base::c
[13:38:02.080]             inherits <- base::inherits
[13:38:02.080]             invokeRestart <- base::invokeRestart
[13:38:02.080]             length <- base::length
[13:38:02.080]             list <- base::list
[13:38:02.080]             seq.int <- base::seq.int
[13:38:02.080]             signalCondition <- base::signalCondition
[13:38:02.080]             sys.calls <- base::sys.calls
[13:38:02.080]             `[[` <- base::`[[`
[13:38:02.080]             `+` <- base::`+`
[13:38:02.080]             `<<-` <- base::`<<-`
[13:38:02.080]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:38:02.080]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:38:02.080]                   3L)]
[13:38:02.080]             }
[13:38:02.080]             function(cond) {
[13:38:02.080]                 is_error <- inherits(cond, "error")
[13:38:02.080]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:38:02.080]                   NULL)
[13:38:02.080]                 if (is_error) {
[13:38:02.080]                   sessionInformation <- function() {
[13:38:02.080]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:38:02.080]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:38:02.080]                       search = base::search(), system = base::Sys.info())
[13:38:02.080]                   }
[13:38:02.080]                   ...future.conditions[[length(...future.conditions) + 
[13:38:02.080]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:38:02.080]                     cond$call), session = sessionInformation(), 
[13:38:02.080]                     timestamp = base::Sys.time(), signaled = 0L)
[13:38:02.080]                   signalCondition(cond)
[13:38:02.080]                 }
[13:38:02.080]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:38:02.080]                 "immediateCondition"))) {
[13:38:02.080]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:38:02.080]                   ...future.conditions[[length(...future.conditions) + 
[13:38:02.080]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:38:02.080]                   if (TRUE && !signal) {
[13:38:02.080]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:02.080]                     {
[13:38:02.080]                       inherits <- base::inherits
[13:38:02.080]                       invokeRestart <- base::invokeRestart
[13:38:02.080]                       is.null <- base::is.null
[13:38:02.080]                       muffled <- FALSE
[13:38:02.080]                       if (inherits(cond, "message")) {
[13:38:02.080]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:02.080]                         if (muffled) 
[13:38:02.080]                           invokeRestart("muffleMessage")
[13:38:02.080]                       }
[13:38:02.080]                       else if (inherits(cond, "warning")) {
[13:38:02.080]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:02.080]                         if (muffled) 
[13:38:02.080]                           invokeRestart("muffleWarning")
[13:38:02.080]                       }
[13:38:02.080]                       else if (inherits(cond, "condition")) {
[13:38:02.080]                         if (!is.null(pattern)) {
[13:38:02.080]                           computeRestarts <- base::computeRestarts
[13:38:02.080]                           grepl <- base::grepl
[13:38:02.080]                           restarts <- computeRestarts(cond)
[13:38:02.080]                           for (restart in restarts) {
[13:38:02.080]                             name <- restart$name
[13:38:02.080]                             if (is.null(name)) 
[13:38:02.080]                               next
[13:38:02.080]                             if (!grepl(pattern, name)) 
[13:38:02.080]                               next
[13:38:02.080]                             invokeRestart(restart)
[13:38:02.080]                             muffled <- TRUE
[13:38:02.080]                             break
[13:38:02.080]                           }
[13:38:02.080]                         }
[13:38:02.080]                       }
[13:38:02.080]                       invisible(muffled)
[13:38:02.080]                     }
[13:38:02.080]                     muffleCondition(cond, pattern = "^muffle")
[13:38:02.080]                   }
[13:38:02.080]                 }
[13:38:02.080]                 else {
[13:38:02.080]                   if (TRUE) {
[13:38:02.080]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:38:02.080]                     {
[13:38:02.080]                       inherits <- base::inherits
[13:38:02.080]                       invokeRestart <- base::invokeRestart
[13:38:02.080]                       is.null <- base::is.null
[13:38:02.080]                       muffled <- FALSE
[13:38:02.080]                       if (inherits(cond, "message")) {
[13:38:02.080]                         muffled <- grepl(pattern, "muffleMessage")
[13:38:02.080]                         if (muffled) 
[13:38:02.080]                           invokeRestart("muffleMessage")
[13:38:02.080]                       }
[13:38:02.080]                       else if (inherits(cond, "warning")) {
[13:38:02.080]                         muffled <- grepl(pattern, "muffleWarning")
[13:38:02.080]                         if (muffled) 
[13:38:02.080]                           invokeRestart("muffleWarning")
[13:38:02.080]                       }
[13:38:02.080]                       else if (inherits(cond, "condition")) {
[13:38:02.080]                         if (!is.null(pattern)) {
[13:38:02.080]                           computeRestarts <- base::computeRestarts
[13:38:02.080]                           grepl <- base::grepl
[13:38:02.080]                           restarts <- computeRestarts(cond)
[13:38:02.080]                           for (restart in restarts) {
[13:38:02.080]                             name <- restart$name
[13:38:02.080]                             if (is.null(name)) 
[13:38:02.080]                               next
[13:38:02.080]                             if (!grepl(pattern, name)) 
[13:38:02.080]                               next
[13:38:02.080]                             invokeRestart(restart)
[13:38:02.080]                             muffled <- TRUE
[13:38:02.080]                             break
[13:38:02.080]                           }
[13:38:02.080]                         }
[13:38:02.080]                       }
[13:38:02.080]                       invisible(muffled)
[13:38:02.080]                     }
[13:38:02.080]                     muffleCondition(cond, pattern = "^muffle")
[13:38:02.080]                   }
[13:38:02.080]                 }
[13:38:02.080]             }
[13:38:02.080]         }))
[13:38:02.080]     }, error = function(ex) {
[13:38:02.080]         base::structure(base::list(value = NULL, visible = NULL, 
[13:38:02.080]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:38:02.080]                 ...future.rng), started = ...future.startTime, 
[13:38:02.080]             finished = Sys.time(), session_uuid = NA_character_, 
[13:38:02.080]             version = "1.8"), class = "FutureResult")
[13:38:02.080]     }, finally = {
[13:38:02.080]         if (!identical(...future.workdir, getwd())) 
[13:38:02.080]             setwd(...future.workdir)
[13:38:02.080]         {
[13:38:02.080]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:38:02.080]                 ...future.oldOptions$nwarnings <- NULL
[13:38:02.080]             }
[13:38:02.080]             base::options(...future.oldOptions)
[13:38:02.080]             if (.Platform$OS.type == "windows") {
[13:38:02.080]                 old_names <- names(...future.oldEnvVars)
[13:38:02.080]                 envs <- base::Sys.getenv()
[13:38:02.080]                 names <- names(envs)
[13:38:02.080]                 common <- intersect(names, old_names)
[13:38:02.080]                 added <- setdiff(names, old_names)
[13:38:02.080]                 removed <- setdiff(old_names, names)
[13:38:02.080]                 changed <- common[...future.oldEnvVars[common] != 
[13:38:02.080]                   envs[common]]
[13:38:02.080]                 NAMES <- toupper(changed)
[13:38:02.080]                 args <- list()
[13:38:02.080]                 for (kk in seq_along(NAMES)) {
[13:38:02.080]                   name <- changed[[kk]]
[13:38:02.080]                   NAME <- NAMES[[kk]]
[13:38:02.080]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:02.080]                     next
[13:38:02.080]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:02.080]                 }
[13:38:02.080]                 NAMES <- toupper(added)
[13:38:02.080]                 for (kk in seq_along(NAMES)) {
[13:38:02.080]                   name <- added[[kk]]
[13:38:02.080]                   NAME <- NAMES[[kk]]
[13:38:02.080]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:02.080]                     next
[13:38:02.080]                   args[[name]] <- ""
[13:38:02.080]                 }
[13:38:02.080]                 NAMES <- toupper(removed)
[13:38:02.080]                 for (kk in seq_along(NAMES)) {
[13:38:02.080]                   name <- removed[[kk]]
[13:38:02.080]                   NAME <- NAMES[[kk]]
[13:38:02.080]                   if (name != NAME && is.element(NAME, old_names)) 
[13:38:02.080]                     next
[13:38:02.080]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:38:02.080]                 }
[13:38:02.080]                 if (length(args) > 0) 
[13:38:02.080]                   base::do.call(base::Sys.setenv, args = args)
[13:38:02.080]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:38:02.080]             }
[13:38:02.080]             else {
[13:38:02.080]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:38:02.080]             }
[13:38:02.080]             {
[13:38:02.080]                 if (base::length(...future.futureOptionsAdded) > 
[13:38:02.080]                   0L) {
[13:38:02.080]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:38:02.080]                   base::names(opts) <- ...future.futureOptionsAdded
[13:38:02.080]                   base::options(opts)
[13:38:02.080]                 }
[13:38:02.080]                 {
[13:38:02.080]                   {
[13:38:02.080]                     base::options(mc.cores = ...future.mc.cores.old)
[13:38:02.080]                     NULL
[13:38:02.080]                   }
[13:38:02.080]                   options(future.plan = NULL)
[13:38:02.080]                   if (is.na(NA_character_)) 
[13:38:02.080]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:38:02.080]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:38:02.080]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:38:02.080]                     .init = FALSE)
[13:38:02.080]                 }
[13:38:02.080]             }
[13:38:02.080]         }
[13:38:02.080]     })
[13:38:02.080]     if (TRUE) {
[13:38:02.080]         base::sink(type = "output", split = FALSE)
[13:38:02.080]         if (TRUE) {
[13:38:02.080]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:38:02.080]         }
[13:38:02.080]         else {
[13:38:02.080]             ...future.result["stdout"] <- base::list(NULL)
[13:38:02.080]         }
[13:38:02.080]         base::close(...future.stdout)
[13:38:02.080]         ...future.stdout <- NULL
[13:38:02.080]     }
[13:38:02.080]     ...future.result$conditions <- ...future.conditions
[13:38:02.080]     ...future.result$finished <- base::Sys.time()
[13:38:02.080]     ...future.result
[13:38:02.080] }
[13:38:02.082] Poll #1 (0): usedNodes() = 2, workers = 2
[13:38:02.093] receiveMessageFromWorker() for ClusterFuture ...
[13:38:02.093] - Validating connection of MultisessionFuture
[13:38:02.093] - received message: FutureResult
[13:38:02.093] - Received FutureResult
[13:38:02.094] - Erased future from FutureRegistry
[13:38:02.094] result() for ClusterFuture ...
[13:38:02.094] - result already collected: FutureResult
[13:38:02.094] result() for ClusterFuture ... done
[13:38:02.094] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:02.094] result() for ClusterFuture ...
[13:38:02.094] - result already collected: FutureResult
[13:38:02.094] result() for ClusterFuture ... done
[13:38:02.094] result() for ClusterFuture ...
[13:38:02.094] - result already collected: FutureResult
[13:38:02.095] result() for ClusterFuture ... done
[13:38:02.096] MultisessionFuture started
[13:38:02.096] - Launch lazy future ... done
[13:38:02.096] run() for ‘MultisessionFuture’ ... done
[13:38:02.096] resolve() on list environment ...
[13:38:02.096]  recursive: 0
[13:38:02.097]  length: 4
[13:38:02.097]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:38:02.097] Future #1
[13:38:02.097]  length: 3 (resolved future 1)
[13:38:02.108] receiveMessageFromWorker() for ClusterFuture ...
[13:38:02.108] - Validating connection of MultisessionFuture
[13:38:02.109] - received message: FutureResult
[13:38:02.109] - Received FutureResult
[13:38:02.109] - Erased future from FutureRegistry
[13:38:02.109] result() for ClusterFuture ...
[13:38:02.109] - result already collected: FutureResult
[13:38:02.109] result() for ClusterFuture ... done
[13:38:02.109] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:02.109] Future #3
[13:38:02.109]  length: 2 (resolved future 3)
[13:38:02.110]  length: 1 (resolved future 4)
[13:38:02.574] receiveMessageFromWorker() for ClusterFuture ...
[13:38:02.574] - Validating connection of MultisessionFuture
[13:38:02.574] - received message: FutureResult
[13:38:02.574] - Received FutureResult
[13:38:02.574] - Erased future from FutureRegistry
[13:38:02.575] result() for ClusterFuture ...
[13:38:02.575] - result already collected: FutureResult
[13:38:02.575] result() for ClusterFuture ... done
[13:38:02.575] receiveMessageFromWorker() for ClusterFuture ... done
[13:38:02.575] Future #2
[13:38:02.575]  length: 0 (resolved future 2)
[13:38:02.575] resolve() on list environment ... DONE
[13:38:02.575] resolve() on list environment ...
[13:38:02.576]  recursive: 0
[13:38:02.579]  length: 4
[13:38:02.579]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:38:02.580] Future #1
[13:38:02.580]  length: 3 (resolved future 1)
[13:38:02.580] Future #2
[13:38:02.580]  length: 2 (resolved future 2)
[13:38:02.580] Future #3
[13:38:02.580]  length: 1 (resolved future 3)
[13:38:02.580]  length: 0 (resolved future 4)
[13:38:02.580] resolve() on list environment ... DONE
[13:38:02.581] resolve() on list environment ...
[13:38:02.581]  recursive: 0
[13:38:02.582]  length: 4
[13:38:02.582]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:38:02.582] Future #1
[13:38:02.582]  length: 3 (resolved future 1)
[13:38:02.582] Future #2
[13:38:02.582]  length: 2 (resolved future 2)
[13:38:02.582] Future #3
[13:38:02.583]  length: 1 (resolved future 3)
[13:38:02.583]  length: 0 (resolved future 4)
[13:38:02.583] resolve() on list environment ... DONE
[13:38:02.583] resolve() on list environment ...
[13:38:02.583]  recursive: 0
[13:38:02.584]  length: 4
[13:38:02.584]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:38:02.584] Future #1
[13:38:02.584]  length: 3 (resolved future 1)
[13:38:02.584] Future #2
[13:38:02.584]  length: 2 (resolved future 2)
[13:38:02.584] Future #3
[13:38:02.585]  length: 1 (resolved future 3)
[13:38:02.585]  length: 0 (resolved future 4)
[13:38:02.585] resolve() on list environment ... DONE
[13:38:02.585] resolve() on list environment ...
[13:38:02.585]  recursive: 0
[13:38:02.586]  length: 4
[13:38:02.586]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:38:02.586] Future #1
[13:38:02.586] result() for ClusterFuture ...
[13:38:02.586] - result already collected: FutureResult
[13:38:02.586] result() for ClusterFuture ... done
[13:38:02.587] result() for ClusterFuture ...
[13:38:02.587] - result already collected: FutureResult
[13:38:02.587] result() for ClusterFuture ... done
[13:38:02.587]  length: 3 (resolved future 1)
[13:38:02.587] Future #2
[13:38:02.587] result() for ClusterFuture ...
[13:38:02.587] - result already collected: FutureResult
[13:38:02.587] result() for ClusterFuture ... done
[13:38:02.587] result() for ClusterFuture ...
[13:38:02.587] - result already collected: FutureResult
[13:38:02.587] result() for ClusterFuture ... done
[13:38:02.588]  length: 2 (resolved future 2)
[13:38:02.588] Future #3
[13:38:02.588] result() for ClusterFuture ...
[13:38:02.588] - result already collected: FutureResult
[13:38:02.588] result() for ClusterFuture ... done
[13:38:02.588] result() for ClusterFuture ...
[13:38:02.588] - result already collected: FutureResult
[13:38:02.588] result() for ClusterFuture ... done
[13:38:02.588]  length: 1 (resolved future 3)
[13:38:02.588]  length: 0 (resolved future 4)
[13:38:02.588] resolve() on list environment ... DONE
[13:38:02.589] resolve() on list environment ...
[13:38:02.589]  recursive: 99
[13:38:02.590]  length: 4
[13:38:02.590]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:38:02.590] Future #1
[13:38:02.590] result() for ClusterFuture ...
[13:38:02.590] - result already collected: FutureResult
[13:38:02.590] result() for ClusterFuture ... done
[13:38:02.590] result() for ClusterFuture ...
[13:38:02.590] - result already collected: FutureResult
[13:38:02.590] result() for ClusterFuture ... done
[13:38:02.590] A MultisessionFuture was resolved
[13:38:02.591]  length: 3 (resolved future 1)
[13:38:02.591] Future #2
[13:38:02.591] result() for ClusterFuture ...
[13:38:02.591] - result already collected: FutureResult
[13:38:02.591] result() for ClusterFuture ... done
[13:38:02.591] result() for ClusterFuture ...
[13:38:02.591] - result already collected: FutureResult
[13:38:02.591] result() for ClusterFuture ... done
[13:38:02.591] A MultisessionFuture was resolved
[13:38:02.591]  length: 2 (resolved future 2)
[13:38:02.592] Future #3
[13:38:02.592] result() for ClusterFuture ...
[13:38:02.592] - result already collected: FutureResult
[13:38:02.592] result() for ClusterFuture ... done
[13:38:02.592] result() for ClusterFuture ...
[13:38:02.592] - result already collected: FutureResult
[13:38:02.592] result() for ClusterFuture ... done
[13:38:02.592] A MultisessionFuture was resolved
[13:38:02.592]  length: 1 (resolved future 3)
[13:38:02.592]  length: 0 (resolved future 4)
[13:38:02.592] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multisession') ...
> 
> 
> message("*** resolve() - globals with non-trustful length() ...")
*** resolve() - globals with non-trustful length() ...
> 
> length.CantTrustLength <- function(x) length(unclass(x)) + 1L
> 
> .length <- future:::.length
> 
> x <- structure(as.list(1:3), class = c("CantTrustLength", "list"))
> str(list(n = length(x), n_true = .length(x)))
List of 2
 $ n     : int 4
 $ n_true: int 3
> stopifnot(length(x) > .length(x))
> x <- resolve(x)
[13:38:02.596] resolve() on list ...
[13:38:02.596]  recursive: 0
[13:38:02.596]  length: 3
[13:38:02.596] 
[13:38:02.596]  length: 2 (resolved future 1)
[13:38:02.596]  length: 1 (resolved future 2)
[13:38:02.596]  length: 0 (resolved future 3)
[13:38:02.596] resolve() on list ... DONE
> 
> message("*** resolve() - globals with non-trustful length() ... DONE")
*** resolve() - globals with non-trustful length() ... DONE
> 
> 
> message("*** resolved() - default ...")
*** resolved() - default ...
> 
> res <- resolved(42L)
> stopifnot(isTRUE(res))
> 
> message("*** resolved() - default ... DONE")
*** resolved() - default ... DONE
> 
> 
> message("*** resolve() ... DONE")
*** resolve() ... DONE
> 
> source("incl/end.R")
[13:38:02.597] plan(): Setting new future strategy stack:
[13:38:02.597] List of future strategies:
[13:38:02.597] 1. FutureStrategy:
[13:38:02.597]    - args: function (..., envir = parent.frame())
[13:38:02.597]    - tweaked: FALSE
[13:38:02.597]    - call: future::plan(oplan)
[13:38:02.598] plan(): nbrOfWorkers() = 1
> 
