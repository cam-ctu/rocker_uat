
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:32:21.479] plan(): Setting new future strategy stack:
[10:32:21.479] List of future strategies:
[10:32:21.479] 1. sequential:
[10:32:21.479]    - args: function (..., envir = parent.frame())
[10:32:21.479]    - tweaked: FALSE
[10:32:21.479]    - call: future::plan("sequential")
[10:32:21.493] plan(): nbrOfWorkers() = 1
> 
> message("*** Demos ...")
*** Demos ...
> 
> message("*** Fibonacci demo of the 'future' package ...")
*** Fibonacci demo of the 'future' package ...
> demo("fibonacci", package = "future", ask = FALSE)


	demo(fibonacci)
	---- ~~~~~~~~~

> library("future")

> library("listenv")

> ## IMPORTANT:
> ## 1. The below usage of lazy futures will only work when they are
> ##    all evaluated in the same process.
> ## 2. We disable the capturing of standard output (stdout=NA) to avoid
> ##    'sink stack is full' errors
> ## 3. We disable the capturing of most conditions (condition="error") to
> ##    avoid stacking up too many conditions
> oplan <- plan(sequential)
[10:32:21.508] plan(): Setting new future strategy stack:
[10:32:21.508] List of future strategies:
[10:32:21.508] 1. sequential:
[10:32:21.508]    - args: function (..., envir = parent.frame())
[10:32:21.508]    - tweaked: FALSE
[10:32:21.508]    - call: plan(sequential)
[10:32:21.519] plan(): nbrOfWorkers() = 1

> ## Defines the first 100 Fibonacci numbers
> ## (0, 1, 1, 2, 3, 5, 8, ...)
> ## but calculate only the ones need when
> ## a number is actually requested.
> 
> x <- listenv()

> x[[1]] <- 0

> x[[2]] <- 1

> for (i in 3:100) {
+   x[[i]] %<-% { x[[i - 2]] + x[[i - 1]] } %lazy% TRUE %stdout% NA %conditions% "error"
+ }
[10:32:21.526] getGlobalsAndPackages() ...
[10:32:21.526] Searching for globals...
[10:32:21.535] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.535] Searching for globals ... DONE
[10:32:21.535] Resolving globals: FALSE
[10:32:21.536] The total size of the 2 globals is 224 bytes (224 bytes)
[10:32:21.536] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 224 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (168 bytes of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.537] - globals: [2] ‘x’, ‘i’
[10:32:21.537] 
[10:32:21.537] getGlobalsAndPackages() ... DONE
[10:32:21.538] getGlobalsAndPackages() ...
[10:32:21.538] Searching for globals...
[10:32:21.539] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.539] Searching for globals ... DONE
[10:32:21.539] Resolving globals: FALSE
[10:32:21.540] The total size of the 2 globals is 8.41 KiB (8608 bytes)
[10:32:21.540] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 8.41 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (8.35 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.541] - globals: [2] ‘x’, ‘i’
[10:32:21.541] 
[10:32:21.541] getGlobalsAndPackages() ... DONE
[10:32:21.541] getGlobalsAndPackages() ...
[10:32:21.541] Searching for globals...
[10:32:21.543] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.543] Searching for globals ... DONE
[10:32:21.543] Resolving globals: FALSE
[10:32:21.544] The total size of the 2 globals is 16.76 KiB (17160 bytes)
[10:32:21.544] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 16.76 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (16.70 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.544] - globals: [2] ‘x’, ‘i’
[10:32:21.545] 
[10:32:21.545] getGlobalsAndPackages() ... DONE
[10:32:21.545] getGlobalsAndPackages() ...
[10:32:21.545] Searching for globals...
[10:32:21.547] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.547] Searching for globals ... DONE
[10:32:21.547] Resolving globals: FALSE
[10:32:21.548] The total size of the 2 globals is 25.11 KiB (25712 bytes)
[10:32:21.548] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 25.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (25.05 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.549] - globals: [2] ‘x’, ‘i’
[10:32:21.549] 
[10:32:21.549] getGlobalsAndPackages() ... DONE
[10:32:21.549] getGlobalsAndPackages() ...
[10:32:21.549] Searching for globals...
[10:32:21.551] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.551] Searching for globals ... DONE
[10:32:21.551] Resolving globals: FALSE
[10:32:21.552] The total size of the 2 globals is 33.46 KiB (34264 bytes)
[10:32:21.553] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 33.46 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (33.41 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.553] - globals: [2] ‘x’, ‘i’
[10:32:21.553] 
[10:32:21.553] getGlobalsAndPackages() ... DONE
[10:32:21.553] getGlobalsAndPackages() ...
[10:32:21.554] Searching for globals...
[10:32:21.555] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.555] Searching for globals ... DONE
[10:32:21.555] Resolving globals: FALSE
[10:32:21.558] The total size of the 2 globals is 41.81 KiB (42816 bytes)
[10:32:21.558] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 41.81 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (41.76 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.558] - globals: [2] ‘x’, ‘i’
[10:32:21.559] 
[10:32:21.559] getGlobalsAndPackages() ... DONE
[10:32:21.559] getGlobalsAndPackages() ...
[10:32:21.559] Searching for globals...
[10:32:21.561] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.561] Searching for globals ... DONE
[10:32:21.561] Resolving globals: FALSE
[10:32:21.563] The total size of the 2 globals is 50.16 KiB (51368 bytes)
[10:32:21.563] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 50.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (50.11 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.563] - globals: [2] ‘x’, ‘i’
[10:32:21.563] 
[10:32:21.563] getGlobalsAndPackages() ... DONE
[10:32:21.564] getGlobalsAndPackages() ...
[10:32:21.564] Searching for globals...
[10:32:21.565] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.566] Searching for globals ... DONE
[10:32:21.566] Resolving globals: FALSE
[10:32:21.568] The total size of the 2 globals is 58.52 KiB (59920 bytes)
[10:32:21.568] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 58.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (58.46 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.568] - globals: [2] ‘x’, ‘i’
[10:32:21.568] 
[10:32:21.568] getGlobalsAndPackages() ... DONE
[10:32:21.569] getGlobalsAndPackages() ...
[10:32:21.569] Searching for globals...
[10:32:21.570] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.571] Searching for globals ... DONE
[10:32:21.571] Resolving globals: FALSE
[10:32:21.573] The total size of the 2 globals is 66.87 KiB (68472 bytes)
[10:32:21.573] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 66.87 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (66.81 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.574] - globals: [2] ‘x’, ‘i’
[10:32:21.574] 
[10:32:21.574] getGlobalsAndPackages() ... DONE
[10:32:21.574] getGlobalsAndPackages() ...
[10:32:21.574] Searching for globals...
[10:32:21.576] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.576] Searching for globals ... DONE
[10:32:21.576] Resolving globals: FALSE
[10:32:21.579] The total size of the 2 globals is 75.22 KiB (77024 bytes)
[10:32:21.580] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 75.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (75.16 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.580] - globals: [2] ‘x’, ‘i’
[10:32:21.580] 
[10:32:21.580] getGlobalsAndPackages() ... DONE
[10:32:21.581] getGlobalsAndPackages() ...
[10:32:21.581] Searching for globals...
[10:32:21.582] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.582] Searching for globals ... DONE
[10:32:21.582] Resolving globals: FALSE
[10:32:21.585] The total size of the 2 globals is 83.57 KiB (85576 bytes)
[10:32:21.586] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 83.57 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (83.52 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.586] - globals: [2] ‘x’, ‘i’
[10:32:21.586] 
[10:32:21.586] getGlobalsAndPackages() ... DONE
[10:32:21.586] getGlobalsAndPackages() ...
[10:32:21.587] Searching for globals...
[10:32:21.588] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.588] Searching for globals ... DONE
[10:32:21.588] Resolving globals: FALSE
[10:32:21.591] The total size of the 2 globals is 91.92 KiB (94128 bytes)
[10:32:21.592] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 91.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (91.87 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.592] - globals: [2] ‘x’, ‘i’
[10:32:21.592] 
[10:32:21.592] getGlobalsAndPackages() ... DONE
[10:32:21.592] getGlobalsAndPackages() ...
[10:32:21.592] Searching for globals...
[10:32:21.594] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.594] Searching for globals ... DONE
[10:32:21.594] Resolving globals: FALSE
[10:32:21.598] The total size of the 2 globals is 100.27 KiB (102680 bytes)
[10:32:21.599] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 100.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (100.22 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.599] - globals: [2] ‘x’, ‘i’
[10:32:21.599] 
[10:32:21.599] getGlobalsAndPackages() ... DONE
[10:32:21.600] getGlobalsAndPackages() ...
[10:32:21.600] Searching for globals...
[10:32:21.601] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.601] Searching for globals ... DONE
[10:32:21.601] Resolving globals: FALSE
[10:32:21.605] The total size of the 2 globals is 108.62 KiB (111232 bytes)
[10:32:21.605] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 108.62 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (108.57 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.605] - globals: [2] ‘x’, ‘i’
[10:32:21.606] 
[10:32:21.606] getGlobalsAndPackages() ... DONE
[10:32:21.606] getGlobalsAndPackages() ...
[10:32:21.606] Searching for globals...
[10:32:21.608] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.608] Searching for globals ... DONE
[10:32:21.608] Resolving globals: FALSE
[10:32:21.612] The total size of the 2 globals is 116.98 KiB (119784 bytes)
[10:32:21.612] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 116.98 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (116.92 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.612] - globals: [2] ‘x’, ‘i’
[10:32:21.612] 
[10:32:21.612] getGlobalsAndPackages() ... DONE
[10:32:21.613] getGlobalsAndPackages() ...
[10:32:21.613] Searching for globals...
[10:32:21.614] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.615] Searching for globals ... DONE
[10:32:21.615] Resolving globals: FALSE
[10:32:21.620] The total size of the 2 globals is 125.33 KiB (128336 bytes)
[10:32:21.620] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 125.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (125.27 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.620] - globals: [2] ‘x’, ‘i’
[10:32:21.620] 
[10:32:21.620] getGlobalsAndPackages() ... DONE
[10:32:21.621] getGlobalsAndPackages() ...
[10:32:21.621] Searching for globals...
[10:32:21.622] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.622] Searching for globals ... DONE
[10:32:21.622] Resolving globals: FALSE
[10:32:21.627] The total size of the 2 globals is 133.68 KiB (136888 bytes)
[10:32:21.627] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 133.68 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (133.62 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.627] - globals: [2] ‘x’, ‘i’
[10:32:21.627] 
[10:32:21.627] getGlobalsAndPackages() ... DONE
[10:32:21.628] getGlobalsAndPackages() ...
[10:32:21.628] Searching for globals...
[10:32:21.629] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.629] Searching for globals ... DONE
[10:32:21.630] Resolving globals: FALSE
[10:32:21.635] The total size of the 2 globals is 142.03 KiB (145440 bytes)
[10:32:21.635] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 142.03 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (141.98 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.635] - globals: [2] ‘x’, ‘i’
[10:32:21.635] 
[10:32:21.636] getGlobalsAndPackages() ... DONE
[10:32:21.636] getGlobalsAndPackages() ...
[10:32:21.636] Searching for globals...
[10:32:21.638] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.638] Searching for globals ... DONE
[10:32:21.638] Resolving globals: FALSE
[10:32:21.643] The total size of the 2 globals is 150.38 KiB (153992 bytes)
[10:32:21.643] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 150.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (150.33 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.643] - globals: [2] ‘x’, ‘i’
[10:32:21.643] 
[10:32:21.643] getGlobalsAndPackages() ... DONE
[10:32:21.644] getGlobalsAndPackages() ...
[10:32:21.644] Searching for globals...
[10:32:21.645] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.645] Searching for globals ... DONE
[10:32:21.645] Resolving globals: FALSE
[10:32:21.651] The total size of the 2 globals is 158.73 KiB (162544 bytes)
[10:32:21.652] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 158.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (158.68 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.652] - globals: [2] ‘x’, ‘i’
[10:32:21.652] 
[10:32:21.652] getGlobalsAndPackages() ... DONE
[10:32:21.652] getGlobalsAndPackages() ...
[10:32:21.653] Searching for globals...
[10:32:21.654] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.654] Searching for globals ... DONE
[10:32:21.654] Resolving globals: FALSE
[10:32:21.660] The total size of the 2 globals is 167.09 KiB (171096 bytes)
[10:32:21.660] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 167.09 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (167.03 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.660] - globals: [2] ‘x’, ‘i’
[10:32:21.660] 
[10:32:21.660] getGlobalsAndPackages() ... DONE
[10:32:21.661] getGlobalsAndPackages() ...
[10:32:21.661] Searching for globals...
[10:32:21.662] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.663] Searching for globals ... DONE
[10:32:21.663] Resolving globals: FALSE
[10:32:21.670] The total size of the 2 globals is 175.44 KiB (179648 bytes)
[10:32:21.670] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 175.44 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (175.38 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.670] - globals: [2] ‘x’, ‘i’
[10:32:21.670] 
[10:32:21.670] getGlobalsAndPackages() ... DONE
[10:32:21.671] getGlobalsAndPackages() ...
[10:32:21.671] Searching for globals...
[10:32:21.672] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.673] Searching for globals ... DONE
[10:32:21.673] Resolving globals: FALSE
[10:32:21.680] The total size of the 2 globals is 183.79 KiB (188200 bytes)
[10:32:21.681] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 183.79 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (183.73 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.681] - globals: [2] ‘x’, ‘i’
[10:32:21.681] 
[10:32:21.681] getGlobalsAndPackages() ... DONE
[10:32:21.682] getGlobalsAndPackages() ...
[10:32:21.682] Searching for globals...
[10:32:21.684] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.684] Searching for globals ... DONE
[10:32:21.684] Resolving globals: FALSE
[10:32:21.692] The total size of the 2 globals is 192.14 KiB (196752 bytes)
[10:32:21.692] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 192.14 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (192.09 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.692] - globals: [2] ‘x’, ‘i’
[10:32:21.693] 
[10:32:21.693] getGlobalsAndPackages() ... DONE
[10:32:21.693] getGlobalsAndPackages() ...
[10:32:21.693] Searching for globals...
[10:32:21.695] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.695] Searching for globals ... DONE
[10:32:21.695] Resolving globals: FALSE
[10:32:21.701] The total size of the 2 globals is 200.49 KiB (205304 bytes)
[10:32:21.702] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 200.49 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (200.44 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.702] - globals: [2] ‘x’, ‘i’
[10:32:21.702] 
[10:32:21.702] getGlobalsAndPackages() ... DONE
[10:32:21.703] getGlobalsAndPackages() ...
[10:32:21.703] Searching for globals...
[10:32:21.704] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.704] Searching for globals ... DONE
[10:32:21.704] Resolving globals: FALSE
[10:32:21.712] The total size of the 2 globals is 208.84 KiB (213856 bytes)
[10:32:21.712] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 208.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (208.79 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.713] - globals: [2] ‘x’, ‘i’
[10:32:21.713] 
[10:32:21.713] getGlobalsAndPackages() ... DONE
[10:32:21.713] getGlobalsAndPackages() ...
[10:32:21.713] Searching for globals...
[10:32:21.715] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.715] Searching for globals ... DONE
[10:32:21.715] Resolving globals: FALSE
[10:32:21.722] The total size of the 2 globals is 217.20 KiB (222408 bytes)
[10:32:21.723] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 217.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (217.14 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.723] - globals: [2] ‘x’, ‘i’
[10:32:21.724] 
[10:32:21.724] getGlobalsAndPackages() ... DONE
[10:32:21.724] getGlobalsAndPackages() ...
[10:32:21.724] Searching for globals...
[10:32:21.726] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.726] Searching for globals ... DONE
[10:32:21.726] Resolving globals: FALSE
[10:32:21.733] The total size of the 2 globals is 225.55 KiB (230960 bytes)
[10:32:21.733] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 225.55 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (225.49 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.734] - globals: [2] ‘x’, ‘i’
[10:32:21.734] 
[10:32:21.734] getGlobalsAndPackages() ... DONE
[10:32:21.734] getGlobalsAndPackages() ...
[10:32:21.734] Searching for globals...
[10:32:21.736] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.736] Searching for globals ... DONE
[10:32:21.736] Resolving globals: FALSE
[10:32:21.744] The total size of the 2 globals is 233.90 KiB (239512 bytes)
[10:32:21.745] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 233.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (233.84 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.745] - globals: [2] ‘x’, ‘i’
[10:32:21.745] 
[10:32:21.745] getGlobalsAndPackages() ... DONE
[10:32:21.745] getGlobalsAndPackages() ...
[10:32:21.746] Searching for globals...
[10:32:21.747] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.747] Searching for globals ... DONE
[10:32:21.747] Resolving globals: FALSE
[10:32:21.755] The total size of the 2 globals is 242.25 KiB (248064 bytes)
[10:32:21.756] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 242.25 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (242.20 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.756] - globals: [2] ‘x’, ‘i’
[10:32:21.756] 
[10:32:21.756] getGlobalsAndPackages() ... DONE
[10:32:21.757] getGlobalsAndPackages() ...
[10:32:21.757] Searching for globals...
[10:32:21.758] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.758] Searching for globals ... DONE
[10:32:21.758] Resolving globals: FALSE
[10:32:21.766] The total size of the 2 globals is 250.60 KiB (256616 bytes)
[10:32:21.767] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 250.60 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (250.55 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.767] - globals: [2] ‘x’, ‘i’
[10:32:21.767] 
[10:32:21.767] getGlobalsAndPackages() ... DONE
[10:32:21.767] getGlobalsAndPackages() ...
[10:32:21.767] Searching for globals...
[10:32:21.769] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.769] Searching for globals ... DONE
[10:32:21.769] Resolving globals: FALSE
[10:32:21.778] The total size of the 2 globals is 258.95 KiB (265168 bytes)
[10:32:21.778] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 258.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (258.90 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.779] - globals: [2] ‘x’, ‘i’
[10:32:21.779] 
[10:32:21.779] getGlobalsAndPackages() ... DONE
[10:32:21.779] getGlobalsAndPackages() ...
[10:32:21.779] Searching for globals...
[10:32:21.781] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.781] Searching for globals ... DONE
[10:32:21.781] Resolving globals: FALSE
[10:32:21.790] The total size of the 2 globals is 267.30 KiB (273720 bytes)
[10:32:21.790] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 267.30 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (267.25 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.791] - globals: [2] ‘x’, ‘i’
[10:32:21.791] 
[10:32:21.791] getGlobalsAndPackages() ... DONE
[10:32:21.791] getGlobalsAndPackages() ...
[10:32:21.791] Searching for globals...
[10:32:21.793] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.793] Searching for globals ... DONE
[10:32:21.793] Resolving globals: FALSE
[10:32:21.802] The total size of the 2 globals is 275.66 KiB (282272 bytes)
[10:32:21.802] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 275.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (275.60 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.802] - globals: [2] ‘x’, ‘i’
[10:32:21.802] 
[10:32:21.802] getGlobalsAndPackages() ... DONE
[10:32:21.803] getGlobalsAndPackages() ...
[10:32:21.803] Searching for globals...
[10:32:21.805] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.805] Searching for globals ... DONE
[10:32:21.805] Resolving globals: FALSE
[10:32:21.815] The total size of the 2 globals is 284.01 KiB (290824 bytes)
[10:32:21.815] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 284.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (283.95 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.815] - globals: [2] ‘x’, ‘i’
[10:32:21.815] 
[10:32:21.815] getGlobalsAndPackages() ... DONE
[10:32:21.816] getGlobalsAndPackages() ...
[10:32:21.816] Searching for globals...
[10:32:21.817] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.818] Searching for globals ... DONE
[10:32:21.818] Resolving globals: FALSE
[10:32:21.828] The total size of the 2 globals is 292.36 KiB (299376 bytes)
[10:32:21.828] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 292.36 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (292.30 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.829] - globals: [2] ‘x’, ‘i’
[10:32:21.829] 
[10:32:21.829] getGlobalsAndPackages() ... DONE
[10:32:21.829] getGlobalsAndPackages() ...
[10:32:21.829] Searching for globals...
[10:32:21.831] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.831] Searching for globals ... DONE
[10:32:21.831] Resolving globals: FALSE
[10:32:21.842] The total size of the 2 globals is 300.71 KiB (307928 bytes)
[10:32:21.842] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 300.71 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (300.66 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.842] - globals: [2] ‘x’, ‘i’
[10:32:21.842] 
[10:32:21.842] getGlobalsAndPackages() ... DONE
[10:32:21.843] getGlobalsAndPackages() ...
[10:32:21.843] Searching for globals...
[10:32:21.844] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.844] Searching for globals ... DONE
[10:32:21.844] Resolving globals: FALSE
[10:32:21.877] The total size of the 2 globals is 309.06 KiB (316480 bytes)
[10:32:21.878] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 309.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (309.01 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.878] - globals: [2] ‘x’, ‘i’
[10:32:21.878] 
[10:32:21.878] getGlobalsAndPackages() ... DONE
[10:32:21.878] getGlobalsAndPackages() ...
[10:32:21.879] Searching for globals...
[10:32:21.880] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.880] Searching for globals ... DONE
[10:32:21.880] Resolving globals: FALSE
[10:32:21.891] The total size of the 2 globals is 317.41 KiB (325032 bytes)
[10:32:21.892] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 317.41 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (317.36 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.892] - globals: [2] ‘x’, ‘i’
[10:32:21.892] 
[10:32:21.892] getGlobalsAndPackages() ... DONE
[10:32:21.893] getGlobalsAndPackages() ...
[10:32:21.893] Searching for globals...
[10:32:21.894] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.894] Searching for globals ... DONE
[10:32:21.894] Resolving globals: FALSE
[10:32:21.905] The total size of the 2 globals is 325.77 KiB (333584 bytes)
[10:32:21.905] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 325.77 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (325.71 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.905] - globals: [2] ‘x’, ‘i’
[10:32:21.906] 
[10:32:21.906] getGlobalsAndPackages() ... DONE
[10:32:21.906] getGlobalsAndPackages() ...
[10:32:21.906] Searching for globals...
[10:32:21.909] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.909] Searching for globals ... DONE
[10:32:21.909] Resolving globals: FALSE
[10:32:21.921] The total size of the 2 globals is 334.12 KiB (342136 bytes)
[10:32:21.921] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 334.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (334.06 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.921] - globals: [2] ‘x’, ‘i’
[10:32:21.921] 
[10:32:21.921] getGlobalsAndPackages() ... DONE
[10:32:21.922] getGlobalsAndPackages() ...
[10:32:21.922] Searching for globals...
[10:32:21.923] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.924] Searching for globals ... DONE
[10:32:21.924] Resolving globals: FALSE
[10:32:21.936] The total size of the 2 globals is 342.47 KiB (350688 bytes)
[10:32:21.937] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 342.47 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (342.41 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.937] - globals: [2] ‘x’, ‘i’
[10:32:21.937] 
[10:32:21.937] getGlobalsAndPackages() ... DONE
[10:32:21.937] getGlobalsAndPackages() ...
[10:32:21.938] Searching for globals...
[10:32:21.939] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.939] Searching for globals ... DONE
[10:32:21.939] Resolving globals: FALSE
[10:32:21.952] The total size of the 2 globals is 350.82 KiB (359240 bytes)
[10:32:21.953] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 350.82 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (350.77 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.953] - globals: [2] ‘x’, ‘i’
[10:32:21.953] 
[10:32:21.953] getGlobalsAndPackages() ... DONE
[10:32:21.954] getGlobalsAndPackages() ...
[10:32:21.954] Searching for globals...
[10:32:21.955] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.956] Searching for globals ... DONE
[10:32:21.956] Resolving globals: FALSE
[10:32:21.969] The total size of the 2 globals is 359.17 KiB (367792 bytes)
[10:32:21.969] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 359.17 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (359.12 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.970] - globals: [2] ‘x’, ‘i’
[10:32:21.970] 
[10:32:21.970] getGlobalsAndPackages() ... DONE
[10:32:21.970] getGlobalsAndPackages() ...
[10:32:21.970] Searching for globals...
[10:32:21.972] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.972] Searching for globals ... DONE
[10:32:21.972] Resolving globals: FALSE
[10:32:21.986] The total size of the 2 globals is 367.52 KiB (376344 bytes)
[10:32:21.986] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 367.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (367.47 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:21.986] - globals: [2] ‘x’, ‘i’
[10:32:21.987] 
[10:32:21.987] getGlobalsAndPackages() ... DONE
[10:32:21.987] getGlobalsAndPackages() ...
[10:32:21.987] Searching for globals...
[10:32:21.989] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:21.989] Searching for globals ... DONE
[10:32:21.989] Resolving globals: FALSE
[10:32:22.003] The total size of the 2 globals is 375.88 KiB (384896 bytes)
[10:32:22.003] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 375.88 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (375.82 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.003] - globals: [2] ‘x’, ‘i’
[10:32:22.003] 
[10:32:22.003] getGlobalsAndPackages() ... DONE
[10:32:22.004] getGlobalsAndPackages() ...
[10:32:22.004] Searching for globals...
[10:32:22.005] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.006] Searching for globals ... DONE
[10:32:22.006] Resolving globals: FALSE
[10:32:22.019] The total size of the 2 globals is 384.23 KiB (393448 bytes)
[10:32:22.020] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 384.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (384.17 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.020] - globals: [2] ‘x’, ‘i’
[10:32:22.020] 
[10:32:22.020] getGlobalsAndPackages() ... DONE
[10:32:22.021] getGlobalsAndPackages() ...
[10:32:22.021] Searching for globals...
[10:32:22.022] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.022] Searching for globals ... DONE
[10:32:22.022] Resolving globals: FALSE
[10:32:22.036] The total size of the 2 globals is 392.58 KiB (402000 bytes)
[10:32:22.037] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 392.58 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (392.52 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.037] - globals: [2] ‘x’, ‘i’
[10:32:22.037] 
[10:32:22.037] getGlobalsAndPackages() ... DONE
[10:32:22.037] getGlobalsAndPackages() ...
[10:32:22.037] Searching for globals...
[10:32:22.039] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.039] Searching for globals ... DONE
[10:32:22.039] Resolving globals: FALSE
[10:32:22.053] The total size of the 2 globals is 400.93 KiB (410552 bytes)
[10:32:22.053] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 400.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (400.88 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.053] - globals: [2] ‘x’, ‘i’
[10:32:22.053] 
[10:32:22.054] getGlobalsAndPackages() ... DONE
[10:32:22.054] getGlobalsAndPackages() ...
[10:32:22.054] Searching for globals...
[10:32:22.055] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.056] Searching for globals ... DONE
[10:32:22.056] Resolving globals: FALSE
[10:32:22.069] The total size of the 2 globals is 409.28 KiB (419104 bytes)
[10:32:22.070] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 409.28 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (409.23 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.070] - globals: [2] ‘x’, ‘i’
[10:32:22.070] 
[10:32:22.070] getGlobalsAndPackages() ... DONE
[10:32:22.070] getGlobalsAndPackages() ...
[10:32:22.071] Searching for globals...
[10:32:22.072] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.072] Searching for globals ... DONE
[10:32:22.072] Resolving globals: FALSE
[10:32:22.086] The total size of the 2 globals is 417.63 KiB (427656 bytes)
[10:32:22.086] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 417.63 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (417.58 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.086] - globals: [2] ‘x’, ‘i’
[10:32:22.087] 
[10:32:22.087] getGlobalsAndPackages() ... DONE
[10:32:22.087] getGlobalsAndPackages() ...
[10:32:22.087] Searching for globals...
[10:32:22.089] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.089] Searching for globals ... DONE
[10:32:22.090] Resolving globals: FALSE
[10:32:22.104] The total size of the 2 globals is 425.98 KiB (436208 bytes)
[10:32:22.104] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 425.98 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (425.93 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.104] - globals: [2] ‘x’, ‘i’
[10:32:22.105] 
[10:32:22.105] getGlobalsAndPackages() ... DONE
[10:32:22.105] getGlobalsAndPackages() ...
[10:32:22.105] Searching for globals...
[10:32:22.107] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.107] Searching for globals ... DONE
[10:32:22.107] Resolving globals: FALSE
[10:32:22.129] The total size of the 2 globals is 434.34 KiB (444760 bytes)
[10:32:22.129] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 434.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (434.28 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.129] - globals: [2] ‘x’, ‘i’
[10:32:22.130] 
[10:32:22.130] getGlobalsAndPackages() ... DONE
[10:32:22.130] getGlobalsAndPackages() ...
[10:32:22.130] Searching for globals...
[10:32:22.132] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.132] Searching for globals ... DONE
[10:32:22.132] Resolving globals: FALSE
[10:32:22.150] The total size of the 2 globals is 442.69 KiB (453312 bytes)
[10:32:22.150] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 442.69 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (442.63 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.150] - globals: [2] ‘x’, ‘i’
[10:32:22.150] 
[10:32:22.150] getGlobalsAndPackages() ... DONE
[10:32:22.151] getGlobalsAndPackages() ...
[10:32:22.151] Searching for globals...
[10:32:22.153] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.153] Searching for globals ... DONE
[10:32:22.153] Resolving globals: FALSE
[10:32:22.170] The total size of the 2 globals is 451.04 KiB (461864 bytes)
[10:32:22.171] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 451.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (450.98 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.171] - globals: [2] ‘x’, ‘i’
[10:32:22.171] 
[10:32:22.171] getGlobalsAndPackages() ... DONE
[10:32:22.172] getGlobalsAndPackages() ...
[10:32:22.172] Searching for globals...
[10:32:22.174] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.174] Searching for globals ... DONE
[10:32:22.174] Resolving globals: FALSE
[10:32:22.194] The total size of the 2 globals is 459.39 KiB (470416 bytes)
[10:32:22.195] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 459.39 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (459.34 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.195] - globals: [2] ‘x’, ‘i’
[10:32:22.195] 
[10:32:22.195] getGlobalsAndPackages() ... DONE
[10:32:22.197] getGlobalsAndPackages() ...
[10:32:22.197] Searching for globals...
[10:32:22.198] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.198] Searching for globals ... DONE
[10:32:22.199] Resolving globals: FALSE
[10:32:22.215] The total size of the 2 globals is 467.74 KiB (478968 bytes)
[10:32:22.215] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 467.74 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (467.69 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.215] - globals: [2] ‘x’, ‘i’
[10:32:22.215] 
[10:32:22.215] getGlobalsAndPackages() ... DONE
[10:32:22.216] getGlobalsAndPackages() ...
[10:32:22.216] Searching for globals...
[10:32:22.217] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.218] Searching for globals ... DONE
[10:32:22.218] Resolving globals: FALSE
[10:32:22.235] The total size of the 2 globals is 476.09 KiB (487520 bytes)
[10:32:22.235] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 476.09 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (476.04 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.235] - globals: [2] ‘x’, ‘i’
[10:32:22.235] 
[10:32:22.235] getGlobalsAndPackages() ... DONE
[10:32:22.236] getGlobalsAndPackages() ...
[10:32:22.236] Searching for globals...
[10:32:22.238] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.238] Searching for globals ... DONE
[10:32:22.238] Resolving globals: FALSE
[10:32:22.255] The total size of the 2 globals is 484.45 KiB (496072 bytes)
[10:32:22.256] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 484.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (484.39 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.256] - globals: [2] ‘x’, ‘i’
[10:32:22.256] 
[10:32:22.256] getGlobalsAndPackages() ... DONE
[10:32:22.256] getGlobalsAndPackages() ...
[10:32:22.257] Searching for globals...
[10:32:22.258] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.258] Searching for globals ... DONE
[10:32:22.258] Resolving globals: FALSE
[10:32:22.276] The total size of the 2 globals is 492.80 KiB (504624 bytes)
[10:32:22.277] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 492.80 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (492.74 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.277] - globals: [2] ‘x’, ‘i’
[10:32:22.277] 
[10:32:22.277] getGlobalsAndPackages() ... DONE
[10:32:22.278] getGlobalsAndPackages() ...
[10:32:22.278] Searching for globals...
[10:32:22.279] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.279] Searching for globals ... DONE
[10:32:22.280] Resolving globals: FALSE
[10:32:22.297] The total size of the 2 globals is 501.15 KiB (513176 bytes)
[10:32:22.297] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 501.15 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (501.09 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.297] - globals: [2] ‘x’, ‘i’
[10:32:22.297] 
[10:32:22.298] getGlobalsAndPackages() ... DONE
[10:32:22.298] getGlobalsAndPackages() ...
[10:32:22.298] Searching for globals...
[10:32:22.300] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.300] Searching for globals ... DONE
[10:32:22.300] Resolving globals: FALSE
[10:32:22.318] The total size of the 2 globals is 509.50 KiB (521728 bytes)
[10:32:22.318] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 509.50 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (509.45 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.318] - globals: [2] ‘x’, ‘i’
[10:32:22.318] 
[10:32:22.319] getGlobalsAndPackages() ... DONE
[10:32:22.319] getGlobalsAndPackages() ...
[10:32:22.319] Searching for globals...
[10:32:22.321] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.321] Searching for globals ... DONE
[10:32:22.321] Resolving globals: FALSE
[10:32:22.341] The total size of the 2 globals is 517.85 KiB (530280 bytes)
[10:32:22.341] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 517.85 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (517.80 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.341] - globals: [2] ‘x’, ‘i’
[10:32:22.341] 
[10:32:22.341] getGlobalsAndPackages() ... DONE
[10:32:22.342] getGlobalsAndPackages() ...
[10:32:22.342] Searching for globals...
[10:32:22.344] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.344] Searching for globals ... DONE
[10:32:22.344] Resolving globals: FALSE
[10:32:22.363] The total size of the 2 globals is 526.20 KiB (538832 bytes)
[10:32:22.364] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 526.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (526.15 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.364] - globals: [2] ‘x’, ‘i’
[10:32:22.364] 
[10:32:22.364] getGlobalsAndPackages() ... DONE
[10:32:22.364] getGlobalsAndPackages() ...
[10:32:22.365] Searching for globals...
[10:32:22.366] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.366] Searching for globals ... DONE
[10:32:22.366] Resolving globals: FALSE
[10:32:22.386] The total size of the 2 globals is 534.55 KiB (547384 bytes)
[10:32:22.386] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 534.55 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (534.50 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.386] - globals: [2] ‘x’, ‘i’
[10:32:22.387] 
[10:32:22.387] getGlobalsAndPackages() ... DONE
[10:32:22.387] getGlobalsAndPackages() ...
[10:32:22.387] Searching for globals...
[10:32:22.389] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.389] Searching for globals ... DONE
[10:32:22.389] Resolving globals: FALSE
[10:32:22.408] The total size of the 2 globals is 542.91 KiB (555936 bytes)
[10:32:22.408] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 542.91 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (542.85 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.408] - globals: [2] ‘x’, ‘i’
[10:32:22.408] 
[10:32:22.408] getGlobalsAndPackages() ... DONE
[10:32:22.409] getGlobalsAndPackages() ...
[10:32:22.409] Searching for globals...
[10:32:22.411] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.411] Searching for globals ... DONE
[10:32:22.411] Resolving globals: FALSE
[10:32:22.430] The total size of the 2 globals is 551.26 KiB (564488 bytes)
[10:32:22.430] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 551.26 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (551.20 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.430] - globals: [2] ‘x’, ‘i’
[10:32:22.430] 
[10:32:22.430] getGlobalsAndPackages() ... DONE
[10:32:22.431] getGlobalsAndPackages() ...
[10:32:22.431] Searching for globals...
[10:32:22.432] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.433] Searching for globals ... DONE
[10:32:22.433] Resolving globals: FALSE
[10:32:22.452] The total size of the 2 globals is 559.61 KiB (573040 bytes)
[10:32:22.452] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 559.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (559.55 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.452] - globals: [2] ‘x’, ‘i’
[10:32:22.452] 
[10:32:22.453] getGlobalsAndPackages() ... DONE
[10:32:22.453] getGlobalsAndPackages() ...
[10:32:22.453] Searching for globals...
[10:32:22.455] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.455] Searching for globals ... DONE
[10:32:22.455] Resolving globals: FALSE
[10:32:22.475] The total size of the 2 globals is 567.96 KiB (581592 bytes)
[10:32:22.475] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 567.96 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (567.91 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.475] - globals: [2] ‘x’, ‘i’
[10:32:22.475] 
[10:32:22.475] getGlobalsAndPackages() ... DONE
[10:32:22.476] getGlobalsAndPackages() ...
[10:32:22.476] Searching for globals...
[10:32:22.477] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.478] Searching for globals ... DONE
[10:32:22.478] Resolving globals: FALSE
[10:32:22.497] The total size of the 2 globals is 576.31 KiB (590144 bytes)
[10:32:22.498] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 576.31 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (576.26 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.498] - globals: [2] ‘x’, ‘i’
[10:32:22.498] 
[10:32:22.498] getGlobalsAndPackages() ... DONE
[10:32:22.498] getGlobalsAndPackages() ...
[10:32:22.499] Searching for globals...
[10:32:22.500] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.500] Searching for globals ... DONE
[10:32:22.500] Resolving globals: FALSE
[10:32:22.522] The total size of the 2 globals is 584.66 KiB (598696 bytes)
[10:32:22.522] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 584.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (584.61 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.522] - globals: [2] ‘x’, ‘i’
[10:32:22.522] 
[10:32:22.522] getGlobalsAndPackages() ... DONE
[10:32:22.523] getGlobalsAndPackages() ...
[10:32:22.523] Searching for globals...
[10:32:22.524] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.525] Searching for globals ... DONE
[10:32:22.525] Resolving globals: FALSE
[10:32:22.546] The total size of the 2 globals is 593.02 KiB (607248 bytes)
[10:32:22.546] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 593.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (592.96 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.546] - globals: [2] ‘x’, ‘i’
[10:32:22.546] 
[10:32:22.546] getGlobalsAndPackages() ... DONE
[10:32:22.547] getGlobalsAndPackages() ...
[10:32:22.547] Searching for globals...
[10:32:22.548] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.549] Searching for globals ... DONE
[10:32:22.549] Resolving globals: FALSE
[10:32:22.570] The total size of the 2 globals is 601.37 KiB (615800 bytes)
[10:32:22.571] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 601.37 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (601.31 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.571] - globals: [2] ‘x’, ‘i’
[10:32:22.571] 
[10:32:22.571] getGlobalsAndPackages() ... DONE
[10:32:22.572] getGlobalsAndPackages() ...
[10:32:22.572] Searching for globals...
[10:32:22.573] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.574] Searching for globals ... DONE
[10:32:22.574] Resolving globals: FALSE
[10:32:22.597] The total size of the 2 globals is 609.72 KiB (624352 bytes)
[10:32:22.597] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 609.72 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (609.66 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.598] - globals: [2] ‘x’, ‘i’
[10:32:22.598] 
[10:32:22.598] getGlobalsAndPackages() ... DONE
[10:32:22.598] getGlobalsAndPackages() ...
[10:32:22.598] Searching for globals...
[10:32:22.600] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.600] Searching for globals ... DONE
[10:32:22.600] Resolving globals: FALSE
[10:32:22.624] The total size of the 2 globals is 618.07 KiB (632904 bytes)
[10:32:22.624] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 618.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (618.02 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.624] - globals: [2] ‘x’, ‘i’
[10:32:22.624] 
[10:32:22.624] getGlobalsAndPackages() ... DONE
[10:32:22.625] getGlobalsAndPackages() ...
[10:32:22.625] Searching for globals...
[10:32:22.627] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.627] Searching for globals ... DONE
[10:32:22.627] Resolving globals: FALSE
[10:32:22.650] The total size of the 2 globals is 626.42 KiB (641456 bytes)
[10:32:22.650] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 626.42 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (626.37 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.650] - globals: [2] ‘x’, ‘i’
[10:32:22.650] 
[10:32:22.650] getGlobalsAndPackages() ... DONE
[10:32:22.651] getGlobalsAndPackages() ...
[10:32:22.651] Searching for globals...
[10:32:22.654] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.654] Searching for globals ... DONE
[10:32:22.654] Resolving globals: FALSE
[10:32:22.677] The total size of the 2 globals is 634.77 KiB (650008 bytes)
[10:32:22.677] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 634.77 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (634.72 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.677] - globals: [2] ‘x’, ‘i’
[10:32:22.678] 
[10:32:22.678] getGlobalsAndPackages() ... DONE
[10:32:22.678] getGlobalsAndPackages() ...
[10:32:22.678] Searching for globals...
[10:32:22.680] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.680] Searching for globals ... DONE
[10:32:22.680] Resolving globals: FALSE
[10:32:22.704] The total size of the 2 globals is 643.12 KiB (658560 bytes)
[10:32:22.704] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 643.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (643.07 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.705] - globals: [2] ‘x’, ‘i’
[10:32:22.705] 
[10:32:22.705] getGlobalsAndPackages() ... DONE
[10:32:22.705] getGlobalsAndPackages() ...
[10:32:22.705] Searching for globals...
[10:32:22.707] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.707] Searching for globals ... DONE
[10:32:22.707] Resolving globals: FALSE
[10:32:22.730] The total size of the 2 globals is 651.48 KiB (667112 bytes)
[10:32:22.730] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 651.48 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (651.42 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.730] - globals: [2] ‘x’, ‘i’
[10:32:22.731] 
[10:32:22.731] getGlobalsAndPackages() ... DONE
[10:32:22.731] getGlobalsAndPackages() ...
[10:32:22.731] Searching for globals...
[10:32:22.733] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.733] Searching for globals ... DONE
[10:32:22.733] Resolving globals: FALSE
[10:32:22.755] The total size of the 2 globals is 659.83 KiB (675664 bytes)
[10:32:22.756] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 659.83 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (659.77 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.756] - globals: [2] ‘x’, ‘i’
[10:32:22.756] 
[10:32:22.756] getGlobalsAndPackages() ... DONE
[10:32:22.757] getGlobalsAndPackages() ...
[10:32:22.757] Searching for globals...
[10:32:22.758] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.758] Searching for globals ... DONE
[10:32:22.758] Resolving globals: FALSE
[10:32:22.782] The total size of the 2 globals is 668.18 KiB (684216 bytes)
[10:32:22.782] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 668.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (668.12 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.782] - globals: [2] ‘x’, ‘i’
[10:32:22.782] 
[10:32:22.782] getGlobalsAndPackages() ... DONE
[10:32:22.783] getGlobalsAndPackages() ...
[10:32:22.783] Searching for globals...
[10:32:22.785] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.785] Searching for globals ... DONE
[10:32:22.785] Resolving globals: FALSE
[10:32:22.808] The total size of the 2 globals is 676.53 KiB (692768 bytes)
[10:32:22.809] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 676.53 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (676.48 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.809] - globals: [2] ‘x’, ‘i’
[10:32:22.809] 
[10:32:22.810] getGlobalsAndPackages() ... DONE
[10:32:22.810] getGlobalsAndPackages() ...
[10:32:22.810] Searching for globals...
[10:32:22.812] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.812] Searching for globals ... DONE
[10:32:22.812] Resolving globals: FALSE
[10:32:22.835] The total size of the 2 globals is 684.88 KiB (701320 bytes)
[10:32:22.835] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 684.88 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (684.83 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.836] - globals: [2] ‘x’, ‘i’
[10:32:22.836] 
[10:32:22.836] getGlobalsAndPackages() ... DONE
[10:32:22.836] getGlobalsAndPackages() ...
[10:32:22.836] Searching for globals...
[10:32:22.838] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.839] Searching for globals ... DONE
[10:32:22.839] Resolving globals: FALSE
[10:32:22.863] The total size of the 2 globals is 693.23 KiB (709872 bytes)
[10:32:22.863] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 693.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (693.18 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.863] - globals: [2] ‘x’, ‘i’
[10:32:22.863] 
[10:32:22.863] getGlobalsAndPackages() ... DONE
[10:32:22.864] getGlobalsAndPackages() ...
[10:32:22.864] Searching for globals...
[10:32:22.866] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.866] Searching for globals ... DONE
[10:32:22.866] Resolving globals: FALSE
[10:32:22.890] The total size of the 2 globals is 701.59 KiB (718424 bytes)
[10:32:22.891] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 701.59 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (701.53 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.891] - globals: [2] ‘x’, ‘i’
[10:32:22.891] 
[10:32:22.891] getGlobalsAndPackages() ... DONE
[10:32:22.891] getGlobalsAndPackages() ...
[10:32:22.892] Searching for globals...
[10:32:22.894] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.894] Searching for globals ... DONE
[10:32:22.894] Resolving globals: FALSE
[10:32:22.919] The total size of the 2 globals is 709.94 KiB (726976 bytes)
[10:32:22.919] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 709.94 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (709.88 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.919] - globals: [2] ‘x’, ‘i’
[10:32:22.919] 
[10:32:22.919] getGlobalsAndPackages() ... DONE
[10:32:22.920] getGlobalsAndPackages() ...
[10:32:22.920] Searching for globals...
[10:32:22.923] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.923] Searching for globals ... DONE
[10:32:22.923] Resolving globals: FALSE
[10:32:22.948] The total size of the 2 globals is 718.29 KiB (735528 bytes)
[10:32:22.948] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 718.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (718.23 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.948] - globals: [2] ‘x’, ‘i’
[10:32:22.948] 
[10:32:22.948] getGlobalsAndPackages() ... DONE
[10:32:22.950] getGlobalsAndPackages() ...
[10:32:22.950] Searching for globals...
[10:32:22.951] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.951] Searching for globals ... DONE
[10:32:22.951] Resolving globals: FALSE
[10:32:22.977] The total size of the 2 globals is 726.64 KiB (744080 bytes)
[10:32:22.977] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 726.64 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (726.59 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:22.977] - globals: [2] ‘x’, ‘i’
[10:32:22.977] 
[10:32:22.978] getGlobalsAndPackages() ... DONE
[10:32:22.978] getGlobalsAndPackages() ...
[10:32:22.978] Searching for globals...
[10:32:22.980] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:22.980] Searching for globals ... DONE
[10:32:22.980] Resolving globals: FALSE
[10:32:23.006] The total size of the 2 globals is 734.99 KiB (752632 bytes)
[10:32:23.007] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 734.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (734.94 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:23.007] - globals: [2] ‘x’, ‘i’
[10:32:23.007] 
[10:32:23.007] getGlobalsAndPackages() ... DONE
[10:32:23.008] getGlobalsAndPackages() ...
[10:32:23.008] Searching for globals...
[10:32:23.009] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:23.010] Searching for globals ... DONE
[10:32:23.010] Resolving globals: FALSE
[10:32:23.036] The total size of the 2 globals is 743.34 KiB (761184 bytes)
[10:32:23.036] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 743.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (743.29 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:23.036] - globals: [2] ‘x’, ‘i’
[10:32:23.037] 
[10:32:23.037] getGlobalsAndPackages() ... DONE
[10:32:23.037] getGlobalsAndPackages() ...
[10:32:23.037] Searching for globals...
[10:32:23.039] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:23.039] Searching for globals ... DONE
[10:32:23.039] Resolving globals: FALSE
[10:32:23.065] The total size of the 2 globals is 751.70 KiB (769736 bytes)
[10:32:23.066] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 751.70 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (751.64 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:23.066] - globals: [2] ‘x’, ‘i’
[10:32:23.066] 
[10:32:23.066] getGlobalsAndPackages() ... DONE
[10:32:23.067] getGlobalsAndPackages() ...
[10:32:23.067] Searching for globals...
[10:32:23.068] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:23.068] Searching for globals ... DONE
[10:32:23.068] Resolving globals: FALSE
[10:32:23.095] The total size of the 2 globals is 760.05 KiB (778288 bytes)
[10:32:23.095] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 760.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (759.99 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:23.095] - globals: [2] ‘x’, ‘i’
[10:32:23.095] 
[10:32:23.095] getGlobalsAndPackages() ... DONE
[10:32:23.096] getGlobalsAndPackages() ...
[10:32:23.096] Searching for globals...
[10:32:23.097] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:23.098] Searching for globals ... DONE
[10:32:23.098] Resolving globals: FALSE
[10:32:23.126] The total size of the 2 globals is 768.40 KiB (786840 bytes)
[10:32:23.126] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 768.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (768.34 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:23.126] - globals: [2] ‘x’, ‘i’
[10:32:23.126] 
[10:32:23.126] getGlobalsAndPackages() ... DONE
[10:32:23.127] getGlobalsAndPackages() ...
[10:32:23.127] Searching for globals...
[10:32:23.129] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:23.129] Searching for globals ... DONE
[10:32:23.129] Resolving globals: FALSE
[10:32:23.156] The total size of the 2 globals is 776.75 KiB (795392 bytes)
[10:32:23.157] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 776.75 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (776.70 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:23.157] - globals: [2] ‘x’, ‘i’
[10:32:23.157] 
[10:32:23.157] getGlobalsAndPackages() ... DONE
[10:32:23.158] getGlobalsAndPackages() ...
[10:32:23.158] Searching for globals...
[10:32:23.159] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:23.159] Searching for globals ... DONE
[10:32:23.159] Resolving globals: FALSE
[10:32:23.187] The total size of the 2 globals is 785.10 KiB (803944 bytes)
[10:32:23.187] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 785.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (785.05 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:23.188] - globals: [2] ‘x’, ‘i’
[10:32:23.188] 
[10:32:23.188] getGlobalsAndPackages() ... DONE
[10:32:23.188] getGlobalsAndPackages() ...
[10:32:23.188] Searching for globals...
[10:32:23.190] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:23.190] Searching for globals ... DONE
[10:32:23.190] Resolving globals: FALSE
[10:32:23.218] The total size of the 2 globals is 793.45 KiB (812496 bytes)
[10:32:23.218] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 793.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (793.40 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:23.218] - globals: [2] ‘x’, ‘i’
[10:32:23.218] 
[10:32:23.219] getGlobalsAndPackages() ... DONE
[10:32:23.219] getGlobalsAndPackages() ...
[10:32:23.219] Searching for globals...
[10:32:23.222] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:23.222] Searching for globals ... DONE
[10:32:23.222] Resolving globals: FALSE
[10:32:23.251] The total size of the 2 globals is 801.80 KiB (821048 bytes)
[10:32:23.252] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 801.80 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (801.75 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:23.252] - globals: [2] ‘x’, ‘i’
[10:32:23.252] 
[10:32:23.252] getGlobalsAndPackages() ... DONE
[10:32:23.253] getGlobalsAndPackages() ...
[10:32:23.253] Searching for globals...
[10:32:23.254] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[10:32:23.254] Searching for globals ... DONE
[10:32:23.254] Resolving globals: FALSE
[10:32:23.283] The total size of the 2 globals is 810.16 KiB (829600 bytes)
[10:32:23.284] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 810.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (810.10 KiB of class ‘environment’) and ‘i’ (56 bytes of class ‘numeric’)
[10:32:23.284] - globals: [2] ‘x’, ‘i’
[10:32:23.284] 
[10:32:23.284] getGlobalsAndPackages() ... DONE

> ## At this point nothing has been calculated,
> ## because lazy evaluation is in place.
> 
> ## Get the 7:th Fibonnaci numbers (should be 8)
> print(x[[7]])
[10:32:23.285] run() for ‘Future’ ...
[10:32:23.285] - state: ‘created’
[10:32:23.285] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:23.286] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:23.286] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:23.286]   - Field: ‘label’
[10:32:23.286]   - Field: ‘local’
[10:32:23.286]   - Field: ‘owner’
[10:32:23.286]   - Field: ‘envir’
[10:32:23.286]   - Field: ‘packages’
[10:32:23.286]   - Field: ‘gc’
[10:32:23.286]   - Field: ‘conditions’
[10:32:23.286]   - Field: ‘expr’
[10:32:23.286]   - Field: ‘uuid’
[10:32:23.287]   - Field: ‘seed’
[10:32:23.287]   - Field: ‘version’
[10:32:23.287]   - Field: ‘result’
[10:32:23.287]   - Field: ‘asynchronous’
[10:32:23.287]   - Field: ‘calls’
[10:32:23.287]   - Field: ‘globals’
[10:32:23.287]   - Field: ‘stdout’
[10:32:23.287]   - Field: ‘earlySignal’
[10:32:23.287]   - Field: ‘lazy’
[10:32:23.287]   - Field: ‘state’
[10:32:23.287] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:23.288] - Launch lazy future ...
[10:32:23.288] Packages needed by the future expression (n = 0): <none>
[10:32:23.288] Packages needed by future strategies (n = 0): <none>
[10:32:23.289] {
[10:32:23.289]     {
[10:32:23.289]         {
[10:32:23.289]             ...future.startTime <- base::Sys.time()
[10:32:23.289]             {
[10:32:23.289]                 {
[10:32:23.289]                   {
[10:32:23.289]                     base::local({
[10:32:23.289]                       has_future <- base::requireNamespace("future", 
[10:32:23.289]                         quietly = TRUE)
[10:32:23.289]                       if (has_future) {
[10:32:23.289]                         ns <- base::getNamespace("future")
[10:32:23.289]                         version <- ns[[".package"]][["version"]]
[10:32:23.289]                         if (is.null(version)) 
[10:32:23.289]                           version <- utils::packageVersion("future")
[10:32:23.289]                       }
[10:32:23.289]                       else {
[10:32:23.289]                         version <- NULL
[10:32:23.289]                       }
[10:32:23.289]                       if (!has_future || version < "1.8.0") {
[10:32:23.289]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:23.289]                           "", base::R.version$version.string), 
[10:32:23.289]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:23.289]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:23.289]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:23.289]                             "release", "version")], collapse = " "), 
[10:32:23.289]                           hostname = base::Sys.info()[["nodename"]])
[10:32:23.289]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:23.289]                           info)
[10:32:23.289]                         info <- base::paste(info, collapse = "; ")
[10:32:23.289]                         if (!has_future) {
[10:32:23.289]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:23.289]                             info)
[10:32:23.289]                         }
[10:32:23.289]                         else {
[10:32:23.289]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:23.289]                             info, version)
[10:32:23.289]                         }
[10:32:23.289]                         base::stop(msg)
[10:32:23.289]                       }
[10:32:23.289]                     })
[10:32:23.289]                   }
[10:32:23.289]                   ...future.strategy.old <- future::plan("list")
[10:32:23.289]                   options(future.plan = NULL)
[10:32:23.289]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:23.289]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:23.289]                 }
[10:32:23.289]                 ...future.workdir <- getwd()
[10:32:23.289]             }
[10:32:23.289]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:23.289]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:23.289]         }
[10:32:23.289]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:23.289]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:23.289]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:23.289]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:23.289]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:23.289]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:23.289]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:23.289]             base::names(...future.oldOptions))
[10:32:23.289]     }
[10:32:23.289]     if (TRUE) {
[10:32:23.289]     }
[10:32:23.289]     else {
[10:32:23.289]         if (NA) {
[10:32:23.289]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:23.289]                 open = "w")
[10:32:23.289]         }
[10:32:23.289]         else {
[10:32:23.289]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:23.289]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:23.289]         }
[10:32:23.289]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:23.289]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:23.289]             base::sink(type = "output", split = FALSE)
[10:32:23.289]             base::close(...future.stdout)
[10:32:23.289]         }, add = TRUE)
[10:32:23.289]     }
[10:32:23.289]     ...future.frame <- base::sys.nframe()
[10:32:23.289]     ...future.conditions <- base::list()
[10:32:23.289]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:23.289]     if (FALSE) {
[10:32:23.289]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:23.289]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:23.289]     }
[10:32:23.289]     ...future.result <- base::tryCatch({
[10:32:23.289]         base::withCallingHandlers({
[10:32:23.289]             ...future.value <- base::withVisible(base::local({
[10:32:23.289]                 x[[i - 2]] + x[[i - 1]]
[10:32:23.289]             }))
[10:32:23.289]             future::FutureResult(value = ...future.value$value, 
[10:32:23.289]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:23.289]                   ...future.rng), globalenv = if (FALSE) 
[10:32:23.289]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:23.289]                     ...future.globalenv.names))
[10:32:23.289]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:23.289]         }, condition = base::local({
[10:32:23.289]             c <- base::c
[10:32:23.289]             inherits <- base::inherits
[10:32:23.289]             invokeRestart <- base::invokeRestart
[10:32:23.289]             length <- base::length
[10:32:23.289]             list <- base::list
[10:32:23.289]             seq.int <- base::seq.int
[10:32:23.289]             signalCondition <- base::signalCondition
[10:32:23.289]             sys.calls <- base::sys.calls
[10:32:23.289]             `[[` <- base::`[[`
[10:32:23.289]             `+` <- base::`+`
[10:32:23.289]             `<<-` <- base::`<<-`
[10:32:23.289]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:23.289]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:23.289]                   3L)]
[10:32:23.289]             }
[10:32:23.289]             function(cond) {
[10:32:23.289]                 is_error <- inherits(cond, "error")
[10:32:23.289]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:23.289]                   NULL)
[10:32:23.289]                 if (is_error) {
[10:32:23.289]                   sessionInformation <- function() {
[10:32:23.289]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:23.289]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:23.289]                       search = base::search(), system = base::Sys.info())
[10:32:23.289]                   }
[10:32:23.289]                   ...future.conditions[[length(...future.conditions) + 
[10:32:23.289]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:23.289]                     cond$call), session = sessionInformation(), 
[10:32:23.289]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:23.289]                   signalCondition(cond)
[10:32:23.289]                 }
[10:32:23.289]                 else if (!ignore && TRUE && inherits(cond, c("error", 
[10:32:23.289]                 "immediateCondition"))) {
[10:32:23.289]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:23.289]                   ...future.conditions[[length(...future.conditions) + 
[10:32:23.289]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:23.289]                   if (TRUE && !signal) {
[10:32:23.289]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:23.289]                     {
[10:32:23.289]                       inherits <- base::inherits
[10:32:23.289]                       invokeRestart <- base::invokeRestart
[10:32:23.289]                       is.null <- base::is.null
[10:32:23.289]                       muffled <- FALSE
[10:32:23.289]                       if (inherits(cond, "message")) {
[10:32:23.289]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:23.289]                         if (muffled) 
[10:32:23.289]                           invokeRestart("muffleMessage")
[10:32:23.289]                       }
[10:32:23.289]                       else if (inherits(cond, "warning")) {
[10:32:23.289]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:23.289]                         if (muffled) 
[10:32:23.289]                           invokeRestart("muffleWarning")
[10:32:23.289]                       }
[10:32:23.289]                       else if (inherits(cond, "condition")) {
[10:32:23.289]                         if (!is.null(pattern)) {
[10:32:23.289]                           computeRestarts <- base::computeRestarts
[10:32:23.289]                           grepl <- base::grepl
[10:32:23.289]                           restarts <- computeRestarts(cond)
[10:32:23.289]                           for (restart in restarts) {
[10:32:23.289]                             name <- restart$name
[10:32:23.289]                             if (is.null(name)) 
[10:32:23.289]                               next
[10:32:23.289]                             if (!grepl(pattern, name)) 
[10:32:23.289]                               next
[10:32:23.289]                             invokeRestart(restart)
[10:32:23.289]                             muffled <- TRUE
[10:32:23.289]                             break
[10:32:23.289]                           }
[10:32:23.289]                         }
[10:32:23.289]                       }
[10:32:23.289]                       invisible(muffled)
[10:32:23.289]                     }
[10:32:23.289]                     muffleCondition(cond, pattern = "^muffle")
[10:32:23.289]                   }
[10:32:23.289]                 }
[10:32:23.289]                 else {
[10:32:23.289]                   if (TRUE) {
[10:32:23.289]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:23.289]                     {
[10:32:23.289]                       inherits <- base::inherits
[10:32:23.289]                       invokeRestart <- base::invokeRestart
[10:32:23.289]                       is.null <- base::is.null
[10:32:23.289]                       muffled <- FALSE
[10:32:23.289]                       if (inherits(cond, "message")) {
[10:32:23.289]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:23.289]                         if (muffled) 
[10:32:23.289]                           invokeRestart("muffleMessage")
[10:32:23.289]                       }
[10:32:23.289]                       else if (inherits(cond, "warning")) {
[10:32:23.289]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:23.289]                         if (muffled) 
[10:32:23.289]                           invokeRestart("muffleWarning")
[10:32:23.289]                       }
[10:32:23.289]                       else if (inherits(cond, "condition")) {
[10:32:23.289]                         if (!is.null(pattern)) {
[10:32:23.289]                           computeRestarts <- base::computeRestarts
[10:32:23.289]                           grepl <- base::grepl
[10:32:23.289]                           restarts <- computeRestarts(cond)
[10:32:23.289]                           for (restart in restarts) {
[10:32:23.289]                             name <- restart$name
[10:32:23.289]                             if (is.null(name)) 
[10:32:23.289]                               next
[10:32:23.289]                             if (!grepl(pattern, name)) 
[10:32:23.289]                               next
[10:32:23.289]                             invokeRestart(restart)
[10:32:23.289]                             muffled <- TRUE
[10:32:23.289]                             break
[10:32:23.289]                           }
[10:32:23.289]                         }
[10:32:23.289]                       }
[10:32:23.289]                       invisible(muffled)
[10:32:23.289]                     }
[10:32:23.289]                     muffleCondition(cond, pattern = "^muffle")
[10:32:23.289]                   }
[10:32:23.289]                 }
[10:32:23.289]             }
[10:32:23.289]         }))
[10:32:23.289]     }, error = function(ex) {
[10:32:23.289]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:23.289]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:23.289]                 ...future.rng), started = ...future.startTime, 
[10:32:23.289]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:23.289]             version = "1.8"), class = "FutureResult")
[10:32:23.289]     }, finally = {
[10:32:23.289]         if (!identical(...future.workdir, getwd())) 
[10:32:23.289]             setwd(...future.workdir)
[10:32:23.289]         {
[10:32:23.289]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:23.289]                 ...future.oldOptions$nwarnings <- NULL
[10:32:23.289]             }
[10:32:23.289]             base::options(...future.oldOptions)
[10:32:23.289]             if (.Platform$OS.type == "windows") {
[10:32:23.289]                 old_names <- names(...future.oldEnvVars)
[10:32:23.289]                 envs <- base::Sys.getenv()
[10:32:23.289]                 names <- names(envs)
[10:32:23.289]                 common <- intersect(names, old_names)
[10:32:23.289]                 added <- setdiff(names, old_names)
[10:32:23.289]                 removed <- setdiff(old_names, names)
[10:32:23.289]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:23.289]                   envs[common]]
[10:32:23.289]                 NAMES <- toupper(changed)
[10:32:23.289]                 args <- list()
[10:32:23.289]                 for (kk in seq_along(NAMES)) {
[10:32:23.289]                   name <- changed[[kk]]
[10:32:23.289]                   NAME <- NAMES[[kk]]
[10:32:23.289]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:23.289]                     next
[10:32:23.289]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:23.289]                 }
[10:32:23.289]                 NAMES <- toupper(added)
[10:32:23.289]                 for (kk in seq_along(NAMES)) {
[10:32:23.289]                   name <- added[[kk]]
[10:32:23.289]                   NAME <- NAMES[[kk]]
[10:32:23.289]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:23.289]                     next
[10:32:23.289]                   args[[name]] <- ""
[10:32:23.289]                 }
[10:32:23.289]                 NAMES <- toupper(removed)
[10:32:23.289]                 for (kk in seq_along(NAMES)) {
[10:32:23.289]                   name <- removed[[kk]]
[10:32:23.289]                   NAME <- NAMES[[kk]]
[10:32:23.289]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:23.289]                     next
[10:32:23.289]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:23.289]                 }
[10:32:23.289]                 if (length(args) > 0) 
[10:32:23.289]                   base::do.call(base::Sys.setenv, args = args)
[10:32:23.289]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:23.289]             }
[10:32:23.289]             else {
[10:32:23.289]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:23.289]             }
[10:32:23.289]             {
[10:32:23.289]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:23.289]                   0L) {
[10:32:23.289]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:23.289]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:23.289]                   base::options(opts)
[10:32:23.289]                 }
[10:32:23.289]                 {
[10:32:23.289]                   {
[10:32:23.289]                     NULL
[10:32:23.289]                     RNGkind("Mersenne-Twister")
[10:32:23.289]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:23.289]                       inherits = FALSE)
[10:32:23.289]                   }
[10:32:23.289]                   options(future.plan = NULL)
[10:32:23.289]                   if (is.na(NA_character_)) 
[10:32:23.289]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:23.289]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:23.289]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:23.289]                     .init = FALSE)
[10:32:23.289]                 }
[10:32:23.289]             }
[10:32:23.289]         }
[10:32:23.289]     })
[10:32:23.289]     if (FALSE) {
[10:32:23.289]         base::sink(type = "output", split = FALSE)
[10:32:23.289]         if (NA) {
[10:32:23.289]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:23.289]         }
[10:32:23.289]         else {
[10:32:23.289]             ...future.result["stdout"] <- base::list(NULL)
[10:32:23.289]         }
[10:32:23.289]         base::close(...future.stdout)
[10:32:23.289]         ...future.stdout <- NULL
[10:32:23.289]     }
[10:32:23.289]     ...future.result$conditions <- ...future.conditions
[10:32:23.289]     ...future.result$finished <- base::Sys.time()
[10:32:23.289]     ...future.result
[10:32:23.289] }
[10:32:23.291] assign_globals() ...
[10:32:23.291] List of 2
[10:32:23.291]  $ x:Classes 'listenv', 'environment' <environment: 0x5583e21b4b98> 
[10:32:23.291]  $ i: int 7
[10:32:23.291]  - attr(*, "where")=List of 2
[10:32:23.291]   ..$ x:<environment: R_EmptyEnv> 
[10:32:23.291]   ..$ i:<environment: R_EmptyEnv> 
[10:32:23.291]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:23.291]  - attr(*, "resolved")= logi FALSE
[10:32:23.291]  - attr(*, "total_size")= num 34264
[10:32:23.291]  - attr(*, "already-done")= logi TRUE
[10:32:23.298] - copied ‘x’ to environment
[10:32:23.298] - copied ‘i’ to environment
[10:32:23.298] assign_globals() ... done
[10:32:23.298] plan(): Setting new future strategy stack:
[10:32:23.298] List of future strategies:
[10:32:23.298] 1. sequential:
[10:32:23.298]    - args: function (..., envir = parent.frame())
[10:32:23.298]    - tweaked: FALSE
[10:32:23.298]    - call: NULL
[10:32:23.299] plan(): nbrOfWorkers() = 1
[10:32:23.376] plan(): Setting new future strategy stack:
[10:32:23.376] List of future strategies:
[10:32:23.376] 1. sequential:
[10:32:23.376]    - args: function (..., envir = parent.frame())
[10:32:23.376]    - tweaked: FALSE
[10:32:23.376]    - call: plan(sequential)
[10:32:23.377] plan(): nbrOfWorkers() = 1
[10:32:23.377] SequentialFuture started (and completed)
[10:32:23.377] - Launch lazy future ... done
[10:32:23.377] run() for ‘SequentialFuture’ ... done
[1] 8

> ## At this point x[1:7] have been calculated,
> ## but nothing beyond.
> 
> ## Let's get the 50:th number.
> print(x[[50]])
[10:32:23.378] run() for ‘Future’ ...
[10:32:23.378] - state: ‘created’
[10:32:23.378] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:23.378] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:23.378] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:23.378]   - Field: ‘label’
[10:32:23.378]   - Field: ‘local’
[10:32:23.379]   - Field: ‘owner’
[10:32:23.379]   - Field: ‘envir’
[10:32:23.379]   - Field: ‘packages’
[10:32:23.379]   - Field: ‘gc’
[10:32:23.379]   - Field: ‘conditions’
[10:32:23.379]   - Field: ‘expr’
[10:32:23.379]   - Field: ‘uuid’
[10:32:23.379]   - Field: ‘seed’
[10:32:23.379]   - Field: ‘version’
[10:32:23.379]   - Field: ‘result’
[10:32:23.379]   - Field: ‘asynchronous’
[10:32:23.380]   - Field: ‘calls’
[10:32:23.380]   - Field: ‘globals’
[10:32:23.380]   - Field: ‘stdout’
[10:32:23.380]   - Field: ‘earlySignal’
[10:32:23.380]   - Field: ‘lazy’
[10:32:23.380]   - Field: ‘state’
[10:32:23.380] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:23.380] - Launch lazy future ...
[10:32:23.380] Packages needed by the future expression (n = 0): <none>
[10:32:23.381] Packages needed by future strategies (n = 0): <none>
[10:32:23.381] {
[10:32:23.381]     {
[10:32:23.381]         {
[10:32:23.381]             ...future.startTime <- base::Sys.time()
[10:32:23.381]             {
[10:32:23.381]                 {
[10:32:23.381]                   {
[10:32:23.381]                     base::local({
[10:32:23.381]                       has_future <- base::requireNamespace("future", 
[10:32:23.381]                         quietly = TRUE)
[10:32:23.381]                       if (has_future) {
[10:32:23.381]                         ns <- base::getNamespace("future")
[10:32:23.381]                         version <- ns[[".package"]][["version"]]
[10:32:23.381]                         if (is.null(version)) 
[10:32:23.381]                           version <- utils::packageVersion("future")
[10:32:23.381]                       }
[10:32:23.381]                       else {
[10:32:23.381]                         version <- NULL
[10:32:23.381]                       }
[10:32:23.381]                       if (!has_future || version < "1.8.0") {
[10:32:23.381]                         info <- base::c(r_version = base::gsub("R version ", 
[10:32:23.381]                           "", base::R.version$version.string), 
[10:32:23.381]                           platform = base::sprintf("%s (%s-bit)", 
[10:32:23.381]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:23.381]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:23.381]                             "release", "version")], collapse = " "), 
[10:32:23.381]                           hostname = base::Sys.info()[["nodename"]])
[10:32:23.381]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:32:23.381]                           info)
[10:32:23.381]                         info <- base::paste(info, collapse = "; ")
[10:32:23.381]                         if (!has_future) {
[10:32:23.381]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:23.381]                             info)
[10:32:23.381]                         }
[10:32:23.381]                         else {
[10:32:23.381]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:23.381]                             info, version)
[10:32:23.381]                         }
[10:32:23.381]                         base::stop(msg)
[10:32:23.381]                       }
[10:32:23.381]                     })
[10:32:23.381]                   }
[10:32:23.381]                   ...future.strategy.old <- future::plan("list")
[10:32:23.381]                   options(future.plan = NULL)
[10:32:23.381]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:23.381]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:23.381]                 }
[10:32:23.381]                 ...future.workdir <- getwd()
[10:32:23.381]             }
[10:32:23.381]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:23.381]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:23.381]         }
[10:32:23.381]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:23.381]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:23.381]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:23.381]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:23.381]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:23.381]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:23.381]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:23.381]             base::names(...future.oldOptions))
[10:32:23.381]     }
[10:32:23.381]     if (TRUE) {
[10:32:23.381]     }
[10:32:23.381]     else {
[10:32:23.381]         if (NA) {
[10:32:23.381]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:23.381]                 open = "w")
[10:32:23.381]         }
[10:32:23.381]         else {
[10:32:23.381]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:23.381]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:23.381]         }
[10:32:23.381]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:23.381]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:23.381]             base::sink(type = "output", split = FALSE)
[10:32:23.381]             base::close(...future.stdout)
[10:32:23.381]         }, add = TRUE)
[10:32:23.381]     }
[10:32:23.381]     ...future.frame <- base::sys.nframe()
[10:32:23.381]     ...future.conditions <- base::list()
[10:32:23.381]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:23.381]     if (FALSE) {
[10:32:23.381]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:23.381]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:23.381]     }
[10:32:23.381]     ...future.result <- base::tryCatch({
[10:32:23.381]         base::withCallingHandlers({
[10:32:23.381]             ...future.value <- base::withVisible(base::local({
[10:32:23.381]                 x[[i - 2]] + x[[i - 1]]
[10:32:23.381]             }))
[10:32:23.381]             future::FutureResult(value = ...future.value$value, 
[10:32:23.381]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:23.381]                   ...future.rng), globalenv = if (FALSE) 
[10:32:23.381]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:23.381]                     ...future.globalenv.names))
[10:32:23.381]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:23.381]         }, condition = base::local({
[10:32:23.381]             c <- base::c
[10:32:23.381]             inherits <- base::inherits
[10:32:23.381]             invokeRestart <- base::invokeRestart
[10:32:23.381]             length <- base::length
[10:32:23.381]             list <- base::list
[10:32:23.381]             seq.int <- base::seq.int
[10:32:23.381]             signalCondition <- base::signalCondition
[10:32:23.381]             sys.calls <- base::sys.calls
[10:32:23.381]             `[[` <- base::`[[`
[10:32:23.381]             `+` <- base::`+`
[10:32:23.381]             `<<-` <- base::`<<-`
[10:32:23.381]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:23.381]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:23.381]                   3L)]
[10:32:23.381]             }
[10:32:23.381]             function(cond) {
[10:32:23.381]                 is_error <- inherits(cond, "error")
[10:32:23.381]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:23.381]                   NULL)
[10:32:23.381]                 if (is_error) {
[10:32:23.381]                   sessionInformation <- function() {
[10:32:23.381]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:23.381]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:23.381]                       search = base::search(), system = base::Sys.info())
[10:32:23.381]                   }
[10:32:23.381]                   ...future.conditions[[length(...future.conditions) + 
[10:32:23.381]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:23.381]                     cond$call), session = sessionInformation(), 
[10:32:23.381]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:23.381]                   signalCondition(cond)
[10:32:23.381]                 }
[10:32:23.381]                 else if (!ignore && TRUE && inherits(cond, c("error", 
[10:32:23.381]                 "immediateCondition"))) {
[10:32:23.381]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:23.381]                   ...future.conditions[[length(...future.conditions) + 
[10:32:23.381]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:23.381]                   if (TRUE && !signal) {
[10:32:23.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:23.381]                     {
[10:32:23.381]                       inherits <- base::inherits
[10:32:23.381]                       invokeRestart <- base::invokeRestart
[10:32:23.381]                       is.null <- base::is.null
[10:32:23.381]                       muffled <- FALSE
[10:32:23.381]                       if (inherits(cond, "message")) {
[10:32:23.381]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:23.381]                         if (muffled) 
[10:32:23.381]                           invokeRestart("muffleMessage")
[10:32:23.381]                       }
[10:32:23.381]                       else if (inherits(cond, "warning")) {
[10:32:23.381]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:23.381]                         if (muffled) 
[10:32:23.381]                           invokeRestart("muffleWarning")
[10:32:23.381]                       }
[10:32:23.381]                       else if (inherits(cond, "condition")) {
[10:32:23.381]                         if (!is.null(pattern)) {
[10:32:23.381]                           computeRestarts <- base::computeRestarts
[10:32:23.381]                           grepl <- base::grepl
[10:32:23.381]                           restarts <- computeRestarts(cond)
[10:32:23.381]                           for (restart in restarts) {
[10:32:23.381]                             name <- restart$name
[10:32:23.381]                             if (is.null(name)) 
[10:32:23.381]                               next
[10:32:23.381]                             if (!grepl(pattern, name)) 
[10:32:23.381]                               next
[10:32:23.381]                             invokeRestart(restart)
[10:32:23.381]                             muffled <- TRUE
[10:32:23.381]                             break
[10:32:23.381]                           }
[10:32:23.381]                         }
[10:32:23.381]                       }
[10:32:23.381]                       invisible(muffled)
[10:32:23.381]                     }
[10:32:23.381]                     muffleCondition(cond, pattern = "^muffle")
[10:32:23.381]                   }
[10:32:23.381]                 }
[10:32:23.381]                 else {
[10:32:23.381]                   if (TRUE) {
[10:32:23.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:23.381]                     {
[10:32:23.381]                       inherits <- base::inherits
[10:32:23.381]                       invokeRestart <- base::invokeRestart
[10:32:23.381]                       is.null <- base::is.null
[10:32:23.381]                       muffled <- FALSE
[10:32:23.381]                       if (inherits(cond, "message")) {
[10:32:23.381]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:23.381]                         if (muffled) 
[10:32:23.381]                           invokeRestart("muffleMessage")
[10:32:23.381]                       }
[10:32:23.381]                       else if (inherits(cond, "warning")) {
[10:32:23.381]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:23.381]                         if (muffled) 
[10:32:23.381]                           invokeRestart("muffleWarning")
[10:32:23.381]                       }
[10:32:23.381]                       else if (inherits(cond, "condition")) {
[10:32:23.381]                         if (!is.null(pattern)) {
[10:32:23.381]                           computeRestarts <- base::computeRestarts
[10:32:23.381]                           grepl <- base::grepl
[10:32:23.381]                           restarts <- computeRestarts(cond)
[10:32:23.381]                           for (restart in restarts) {
[10:32:23.381]                             name <- restart$name
[10:32:23.381]                             if (is.null(name)) 
[10:32:23.381]                               next
[10:32:23.381]                             if (!grepl(pattern, name)) 
[10:32:23.381]                               next
[10:32:23.381]                             invokeRestart(restart)
[10:32:23.381]                             muffled <- TRUE
[10:32:23.381]                             break
[10:32:23.381]                           }
[10:32:23.381]                         }
[10:32:23.381]                       }
[10:32:23.381]                       invisible(muffled)
[10:32:23.381]                     }
[10:32:23.381]                     muffleCondition(cond, pattern = "^muffle")
[10:32:23.381]                   }
[10:32:23.381]                 }
[10:32:23.381]             }
[10:32:23.381]         }))
[10:32:23.381]     }, error = function(ex) {
[10:32:23.381]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:23.381]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:23.381]                 ...future.rng), started = ...future.startTime, 
[10:32:23.381]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:23.381]             version = "1.8"), class = "FutureResult")
[10:32:23.381]     }, finally = {
[10:32:23.381]         if (!identical(...future.workdir, getwd())) 
[10:32:23.381]             setwd(...future.workdir)
[10:32:23.381]         {
[10:32:23.381]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:23.381]                 ...future.oldOptions$nwarnings <- NULL
[10:32:23.381]             }
[10:32:23.381]             base::options(...future.oldOptions)
[10:32:23.381]             if (.Platform$OS.type == "windows") {
[10:32:23.381]                 old_names <- names(...future.oldEnvVars)
[10:32:23.381]                 envs <- base::Sys.getenv()
[10:32:23.381]                 names <- names(envs)
[10:32:23.381]                 common <- intersect(names, old_names)
[10:32:23.381]                 added <- setdiff(names, old_names)
[10:32:23.381]                 removed <- setdiff(old_names, names)
[10:32:23.381]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:23.381]                   envs[common]]
[10:32:23.381]                 NAMES <- toupper(changed)
[10:32:23.381]                 args <- list()
[10:32:23.381]                 for (kk in seq_along(NAMES)) {
[10:32:23.381]                   name <- changed[[kk]]
[10:32:23.381]                   NAME <- NAMES[[kk]]
[10:32:23.381]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:23.381]                     next
[10:32:23.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:23.381]                 }
[10:32:23.381]                 NAMES <- toupper(added)
[10:32:23.381]                 for (kk in seq_along(NAMES)) {
[10:32:23.381]                   name <- added[[kk]]
[10:32:23.381]                   NAME <- NAMES[[kk]]
[10:32:23.381]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:23.381]                     next
[10:32:23.381]                   args[[name]] <- ""
[10:32:23.381]                 }
[10:32:23.381]                 NAMES <- toupper(removed)
[10:32:23.381]                 for (kk in seq_along(NAMES)) {
[10:32:23.381]                   name <- removed[[kk]]
[10:32:23.381]                   NAME <- NAMES[[kk]]
[10:32:23.381]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:23.381]                     next
[10:32:23.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:23.381]                 }
[10:32:23.381]                 if (length(args) > 0) 
[10:32:23.381]                   base::do.call(base::Sys.setenv, args = args)
[10:32:23.381]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:23.381]             }
[10:32:23.381]             else {
[10:32:23.381]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:23.381]             }
[10:32:23.381]             {
[10:32:23.381]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:23.381]                   0L) {
[10:32:23.381]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:23.381]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:23.381]                   base::options(opts)
[10:32:23.381]                 }
[10:32:23.381]                 {
[10:32:23.381]                   {
[10:32:23.381]                     NULL
[10:32:23.381]                     RNGkind("Mersenne-Twister")
[10:32:23.381]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:23.381]                       inherits = FALSE)
[10:32:23.381]                   }
[10:32:23.381]                   options(future.plan = NULL)
[10:32:23.381]                   if (is.na(NA_character_)) 
[10:32:23.381]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:23.381]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:23.381]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:23.381]                     .init = FALSE)
[10:32:23.381]                 }
[10:32:23.381]             }
[10:32:23.381]         }
[10:32:23.381]     })
[10:32:23.381]     if (FALSE) {
[10:32:23.381]         base::sink(type = "output", split = FALSE)
[10:32:23.381]         if (NA) {
[10:32:23.381]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:23.381]         }
[10:32:23.381]         else {
[10:32:23.381]             ...future.result["stdout"] <- base::list(NULL)
[10:32:23.381]         }
[10:32:23.381]         base::close(...future.stdout)
[10:32:23.381]         ...future.stdout <- NULL
[10:32:23.381]     }
[10:32:23.381]     ...future.result$conditions <- ...future.conditions
[10:32:23.381]     ...future.result$finished <- base::Sys.time()
[10:32:23.381]     ...future.result
[10:32:23.381] }
[10:32:23.383] assign_globals() ...
[10:32:23.383] List of 2
[10:32:23.383]  $ x:Classes 'listenv', 'environment' <environment: 0x5583e21b4b98> 
[10:32:23.383]  $ i: int 50
[10:32:23.383]  - attr(*, "where")=List of 2
[10:32:23.383]   ..$ x:<environment: R_EmptyEnv> 
[10:32:23.383]   ..$ i:<environment: R_EmptyEnv> 
[10:32:23.383]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:23.383]  - attr(*, "resolved")= logi FALSE
[10:32:23.383]  - attr(*, "total_size")= num 402000
[10:32:23.383]  - attr(*, "already-done")= logi TRUE
[10:32:23.388] - copied ‘x’ to environment
[10:32:23.388] - copied ‘i’ to environment
[10:32:23.388] assign_globals() ... done
[10:32:23.388] plan(): Setting new future strategy stack:
[10:32:23.388] List of future strategies:
[10:32:23.388] 1. sequential:
[10:32:23.388]    - args: function (..., envir = parent.frame())
[10:32:23.388]    - tweaked: FALSE
[10:32:23.388]    - call: NULL
[10:32:23.389] plan(): nbrOfWorkers() = 1
[10:32:24.243] plan(): Setting new future strategy stack:
[10:32:24.243] List of future strategies:
[10:32:24.243] 1. sequential:
[10:32:24.243]    - args: function (..., envir = parent.frame())
[10:32:24.243]    - tweaked: FALSE
[10:32:24.243]    - call: plan(sequential)
[10:32:24.243] plan(): nbrOfWorkers() = 1
[10:32:24.244] SequentialFuture started (and completed)
[10:32:24.244] - Launch lazy future ... done
[10:32:24.244] run() for ‘SequentialFuture’ ... done
[1] 7778742049

> ## Reset plan
> plan(oplan)
[10:32:24.244] plan(): Setting new future strategy stack:
[10:32:24.244] List of future strategies:
[10:32:24.244] 1. sequential:
[10:32:24.244]    - args: function (..., envir = parent.frame())
[10:32:24.244]    - tweaked: FALSE
[10:32:24.244]    - call: future::plan("sequential")
[10:32:24.245] plan(): nbrOfWorkers() = 1
> message("*** Fibonacci demo of the 'future' package ... DONE")
*** Fibonacci demo of the 'future' package ... DONE
> 
> 
> message("*** Mandelbrot demo of the 'future' package ...")
*** Mandelbrot demo of the 'future' package ...
> if (getRversion() >= "3.2.0" && !isWin32) {
+   options(future.demo.mandelbrot.nrow = 2L)
+   options(future.demo.mandelbrot.resolution = 50L)
+   options(future.demo.mandelbrot.delay = FALSE)
+   
+   for (cores in 1:availCores) {
+     message(sprintf("Testing with %d cores ...", cores))
+     options(mc.cores = cores)
+   
+     for (strategy in supportedStrategies(cores)) {
+       message(sprintf("- plan('%s') ...", strategy))
+       plan(strategy)
+       demo("mandelbrot", package = "future", ask = FALSE)
+       message(sprintf("- plan('%s') ... DONE", strategy))
+     }
+   
+     message(sprintf("Testing with %d cores ... DONE", cores))
+   } ## for (cores ...)
+ } else {
+   message(" - This demo requires R (>= 3.2.0). Skipping test. (Skipping also on Win32 i386 for speed)")
+ }
Testing with 1 cores ...
- plan('sequential') ...
[10:32:24.251] plan(): Setting new future strategy stack:
[10:32:24.251] List of future strategies:
[10:32:24.251] 1. sequential:
[10:32:24.251]    - args: function (..., envir = parent.frame())
[10:32:24.251]    - tweaked: FALSE
[10:32:24.251]    - call: plan(strategy)
[10:32:24.252] plan(): nbrOfWorkers() = 1


	demo(mandelbrot)
	---- ~~~~~~~~~~

> library("future")

> library("graphics")

> plot_what_is_done <- function(counts) {
+   for (kk in seq_along(counts)) {
+     f <- counts[[kk]]
+ 
+     ## Already plotted?
+     if (!inherits(f, "Future")) next
+ 
+     ## Not resolved?
+     if (!resolved(f)) next
+ 
+     message(sprintf("Plotting tile #%d of %d ...", kk, n))
+     counts[[kk]] <- value(f)
+     screen(kk)
+     plot(counts[[kk]])
+   }
+ 
+   counts
+ }

> ## Options
> region <- getOption("future.demo.mandelbrot.region", 1L)

> if (!is.list(region)) {
+   if (region == 1L) {
+     region <- list(xmid = -0.75, ymid = 0.0, side = 3.0)
+   } else if (region == 2L) {
+     region <- list(xmid = 0.283, ymid = -0.0095, side = 0.00026)
+   } else if (region == 3L) {
+     region <- list(xmid = 0.282989, ymid = -0.01, side = 3e-8)
+   }
+ }

> nrow <- getOption("future.demo.mandelbrot.nrow", 3L)

> resolution <- getOption("future.demo.mandelbrot.resolution", 400L)

> delay <- getOption("future.demo.mandelbrot.delay", interactive())

> if (isTRUE(delay)) {
+   delay <- function(counts) Sys.sleep(1.0)
+ } else if (!is.function(delay)) {
+   delay <- function(counts) {}
+ }

> ## Generate Mandelbrot tiles to be computed
> Cs <- mandelbrot_tiles(xmid = region$xmid, ymid = region$ymid,
+                        side = region$side, nrow = nrow,
+                        resolution = resolution)

> if (interactive()) {
+   dev.new()
+   plot.new()
+   split.screen(dim(Cs))
+   for (ii in seq_along(Cs)) {
+     screen(ii)
+     par(mar = c(0, 0, 0, 0))
+     text(x = 1 / 2, y = 1 / 2, sprintf("Future #%d\nunresolved", ii), cex = 2)
+   }
+ } else {
+   split.screen(dim(Cs))
+ }
[1] 1 2 3 4

> ## Create all Mandelbrot tiles via lazy futures
> n <- length(Cs)

> message(sprintf("Creating %d Mandelbrot tiles:", n), appendLF = FALSE)
Creating 4 Mandelbrot tiles:
> counts <- lapply(seq_along(Cs), FUN=function(ii) {
+   message(" ", ii, appendLF = FALSE)
+   C <- Cs[[ii]]
+   future({
+     message(sprintf("Calculating tile #%d of %d ...", ii, n), appendLF = FALSE)
+     fit <- mandelbrot(C)
+ 
+     ## Emulate slowness
+     delay(fit)
+ 
+     message(" done")
+     fit
+   }, lazy = TRUE)
+ })
 1[10:32:24.282] getGlobalsAndPackages() ...
[10:32:24.282] Searching for globals...
[10:32:24.288] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[10:32:24.289] Searching for globals ... DONE
[10:32:24.289] Resolving globals: FALSE
[10:32:24.289] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[10:32:24.290] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:32:24.290] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[10:32:24.290] - packages: [1] ‘future’
[10:32:24.290] getGlobalsAndPackages() ... DONE
 2[10:32:24.294] getGlobalsAndPackages() ...
[10:32:24.294] Searching for globals...
[10:32:24.297] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[10:32:24.297] Searching for globals ... DONE
[10:32:24.297] Resolving globals: FALSE
[10:32:24.298] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[10:32:24.298] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:32:24.299] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[10:32:24.299] - packages: [1] ‘future’
[10:32:24.299] getGlobalsAndPackages() ... DONE
 3[10:32:24.299] getGlobalsAndPackages() ...
[10:32:24.299] Searching for globals...
[10:32:24.302] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[10:32:24.303] Searching for globals ... DONE
[10:32:24.303] Resolving globals: FALSE
[10:32:24.303] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[10:32:24.304] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:32:24.304] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[10:32:24.304] - packages: [1] ‘future’
[10:32:24.304] getGlobalsAndPackages() ... DONE
 4[10:32:24.304] getGlobalsAndPackages() ...
[10:32:24.304] Searching for globals...
[10:32:24.308] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[10:32:24.308] Searching for globals ... DONE
[10:32:24.308] Resolving globals: FALSE
[10:32:24.308] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[10:32:24.309] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:32:24.309] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[10:32:24.309] - packages: [1] ‘future’
[10:32:24.309] getGlobalsAndPackages() ... DONE

> message(".")
.

> ## Calculate and plot tiles
> repeat {
+   counts <- plot_what_is_done(counts)
+   if (!any(sapply(counts, FUN = inherits, "Future"))) break
+ }
[10:32:24.318] resolved() for ‘Future’ ...
[10:32:24.318] - state: ‘created’
[10:32:24.319] - run: TRUE
[10:32:24.319] - run() ...
[10:32:24.319] run() for ‘Future’ ...
[10:32:24.319] - state: ‘created’
[10:32:24.319] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:24.319] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:24.319] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:24.319]   - Field: ‘label’
[10:32:24.320]   - Field: ‘local’
[10:32:24.320]   - Field: ‘owner’
[10:32:24.320]   - Field: ‘envir’
[10:32:24.320]   - Field: ‘packages’
[10:32:24.320]   - Field: ‘gc’
[10:32:24.320]   - Field: ‘conditions’
[10:32:24.320]   - Field: ‘expr’
[10:32:24.320]   - Field: ‘uuid’
[10:32:24.320]   - Field: ‘seed’
[10:32:24.320]   - Field: ‘version’
[10:32:24.321]   - Field: ‘result’
[10:32:24.321]   - Field: ‘asynchronous’
[10:32:24.321]   - Field: ‘calls’
[10:32:24.321]   - Field: ‘globals’
[10:32:24.321]   - Field: ‘stdout’
[10:32:24.321]   - Field: ‘earlySignal’
[10:32:24.321]   - Field: ‘lazy’
[10:32:24.321]   - Field: ‘state’
[10:32:24.321] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:24.321] - Launch lazy future ...
[10:32:24.322] Packages needed by the future expression (n = 1): ‘future’
[10:32:24.322] Packages needed by future strategies (n = 0): <none>
[10:32:24.322] {
[10:32:24.322]     {
[10:32:24.322]         {
[10:32:24.322]             ...future.startTime <- base::Sys.time()
[10:32:24.322]             {
[10:32:24.322]                 {
[10:32:24.322]                   {
[10:32:24.322]                     {
[10:32:24.322]                       base::local({
[10:32:24.322]                         has_future <- base::requireNamespace("future", 
[10:32:24.322]                           quietly = TRUE)
[10:32:24.322]                         if (has_future) {
[10:32:24.322]                           ns <- base::getNamespace("future")
[10:32:24.322]                           version <- ns[[".package"]][["version"]]
[10:32:24.322]                           if (is.null(version)) 
[10:32:24.322]                             version <- utils::packageVersion("future")
[10:32:24.322]                         }
[10:32:24.322]                         else {
[10:32:24.322]                           version <- NULL
[10:32:24.322]                         }
[10:32:24.322]                         if (!has_future || version < "1.8.0") {
[10:32:24.322]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:24.322]                             "", base::R.version$version.string), 
[10:32:24.322]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:24.322]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:24.322]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:24.322]                               "release", "version")], collapse = " "), 
[10:32:24.322]                             hostname = base::Sys.info()[["nodename"]])
[10:32:24.322]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:24.322]                             info)
[10:32:24.322]                           info <- base::paste(info, collapse = "; ")
[10:32:24.322]                           if (!has_future) {
[10:32:24.322]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:24.322]                               info)
[10:32:24.322]                           }
[10:32:24.322]                           else {
[10:32:24.322]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:24.322]                               info, version)
[10:32:24.322]                           }
[10:32:24.322]                           base::stop(msg)
[10:32:24.322]                         }
[10:32:24.322]                       })
[10:32:24.322]                     }
[10:32:24.322]                     base::local({
[10:32:24.322]                       for (pkg in "future") {
[10:32:24.322]                         base::loadNamespace(pkg)
[10:32:24.322]                         base::library(pkg, character.only = TRUE)
[10:32:24.322]                       }
[10:32:24.322]                     })
[10:32:24.322]                   }
[10:32:24.322]                   ...future.strategy.old <- future::plan("list")
[10:32:24.322]                   options(future.plan = NULL)
[10:32:24.322]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:24.322]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:24.322]                 }
[10:32:24.322]                 ...future.workdir <- getwd()
[10:32:24.322]             }
[10:32:24.322]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:24.322]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:24.322]         }
[10:32:24.322]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:24.322]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:24.322]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:24.322]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:24.322]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:24.322]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:24.322]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:24.322]             base::names(...future.oldOptions))
[10:32:24.322]     }
[10:32:24.322]     if (FALSE) {
[10:32:24.322]     }
[10:32:24.322]     else {
[10:32:24.322]         if (TRUE) {
[10:32:24.322]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:24.322]                 open = "w")
[10:32:24.322]         }
[10:32:24.322]         else {
[10:32:24.322]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:24.322]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:24.322]         }
[10:32:24.322]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:24.322]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:24.322]             base::sink(type = "output", split = FALSE)
[10:32:24.322]             base::close(...future.stdout)
[10:32:24.322]         }, add = TRUE)
[10:32:24.322]     }
[10:32:24.322]     ...future.frame <- base::sys.nframe()
[10:32:24.322]     ...future.conditions <- base::list()
[10:32:24.322]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:24.322]     if (FALSE) {
[10:32:24.322]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:24.322]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:24.322]     }
[10:32:24.322]     ...future.result <- base::tryCatch({
[10:32:24.322]         base::withCallingHandlers({
[10:32:24.322]             ...future.value <- base::withVisible(base::local({
[10:32:24.322]                 message(sprintf("Calculating tile #%d of %d ...", 
[10:32:24.322]                   ii, n), appendLF = FALSE)
[10:32:24.322]                 fit <- mandelbrot(C)
[10:32:24.322]                 delay(fit)
[10:32:24.322]                 message(" done")
[10:32:24.322]                 fit
[10:32:24.322]             }))
[10:32:24.322]             future::FutureResult(value = ...future.value$value, 
[10:32:24.322]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:24.322]                   ...future.rng), globalenv = if (FALSE) 
[10:32:24.322]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:24.322]                     ...future.globalenv.names))
[10:32:24.322]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:24.322]         }, condition = base::local({
[10:32:24.322]             c <- base::c
[10:32:24.322]             inherits <- base::inherits
[10:32:24.322]             invokeRestart <- base::invokeRestart
[10:32:24.322]             length <- base::length
[10:32:24.322]             list <- base::list
[10:32:24.322]             seq.int <- base::seq.int
[10:32:24.322]             signalCondition <- base::signalCondition
[10:32:24.322]             sys.calls <- base::sys.calls
[10:32:24.322]             `[[` <- base::`[[`
[10:32:24.322]             `+` <- base::`+`
[10:32:24.322]             `<<-` <- base::`<<-`
[10:32:24.322]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:24.322]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:24.322]                   3L)]
[10:32:24.322]             }
[10:32:24.322]             function(cond) {
[10:32:24.322]                 is_error <- inherits(cond, "error")
[10:32:24.322]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:24.322]                   NULL)
[10:32:24.322]                 if (is_error) {
[10:32:24.322]                   sessionInformation <- function() {
[10:32:24.322]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:24.322]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:24.322]                       search = base::search(), system = base::Sys.info())
[10:32:24.322]                   }
[10:32:24.322]                   ...future.conditions[[length(...future.conditions) + 
[10:32:24.322]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:24.322]                     cond$call), session = sessionInformation(), 
[10:32:24.322]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:24.322]                   signalCondition(cond)
[10:32:24.322]                 }
[10:32:24.322]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:24.322]                 "immediateCondition"))) {
[10:32:24.322]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:24.322]                   ...future.conditions[[length(...future.conditions) + 
[10:32:24.322]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:24.322]                   if (TRUE && !signal) {
[10:32:24.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:24.322]                     {
[10:32:24.322]                       inherits <- base::inherits
[10:32:24.322]                       invokeRestart <- base::invokeRestart
[10:32:24.322]                       is.null <- base::is.null
[10:32:24.322]                       muffled <- FALSE
[10:32:24.322]                       if (inherits(cond, "message")) {
[10:32:24.322]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:24.322]                         if (muffled) 
[10:32:24.322]                           invokeRestart("muffleMessage")
[10:32:24.322]                       }
[10:32:24.322]                       else if (inherits(cond, "warning")) {
[10:32:24.322]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:24.322]                         if (muffled) 
[10:32:24.322]                           invokeRestart("muffleWarning")
[10:32:24.322]                       }
[10:32:24.322]                       else if (inherits(cond, "condition")) {
[10:32:24.322]                         if (!is.null(pattern)) {
[10:32:24.322]                           computeRestarts <- base::computeRestarts
[10:32:24.322]                           grepl <- base::grepl
[10:32:24.322]                           restarts <- computeRestarts(cond)
[10:32:24.322]                           for (restart in restarts) {
[10:32:24.322]                             name <- restart$name
[10:32:24.322]                             if (is.null(name)) 
[10:32:24.322]                               next
[10:32:24.322]                             if (!grepl(pattern, name)) 
[10:32:24.322]                               next
[10:32:24.322]                             invokeRestart(restart)
[10:32:24.322]                             muffled <- TRUE
[10:32:24.322]                             break
[10:32:24.322]                           }
[10:32:24.322]                         }
[10:32:24.322]                       }
[10:32:24.322]                       invisible(muffled)
[10:32:24.322]                     }
[10:32:24.322]                     muffleCondition(cond, pattern = "^muffle")
[10:32:24.322]                   }
[10:32:24.322]                 }
[10:32:24.322]                 else {
[10:32:24.322]                   if (TRUE) {
[10:32:24.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:24.322]                     {
[10:32:24.322]                       inherits <- base::inherits
[10:32:24.322]                       invokeRestart <- base::invokeRestart
[10:32:24.322]                       is.null <- base::is.null
[10:32:24.322]                       muffled <- FALSE
[10:32:24.322]                       if (inherits(cond, "message")) {
[10:32:24.322]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:24.322]                         if (muffled) 
[10:32:24.322]                           invokeRestart("muffleMessage")
[10:32:24.322]                       }
[10:32:24.322]                       else if (inherits(cond, "warning")) {
[10:32:24.322]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:24.322]                         if (muffled) 
[10:32:24.322]                           invokeRestart("muffleWarning")
[10:32:24.322]                       }
[10:32:24.322]                       else if (inherits(cond, "condition")) {
[10:32:24.322]                         if (!is.null(pattern)) {
[10:32:24.322]                           computeRestarts <- base::computeRestarts
[10:32:24.322]                           grepl <- base::grepl
[10:32:24.322]                           restarts <- computeRestarts(cond)
[10:32:24.322]                           for (restart in restarts) {
[10:32:24.322]                             name <- restart$name
[10:32:24.322]                             if (is.null(name)) 
[10:32:24.322]                               next
[10:32:24.322]                             if (!grepl(pattern, name)) 
[10:32:24.322]                               next
[10:32:24.322]                             invokeRestart(restart)
[10:32:24.322]                             muffled <- TRUE
[10:32:24.322]                             break
[10:32:24.322]                           }
[10:32:24.322]                         }
[10:32:24.322]                       }
[10:32:24.322]                       invisible(muffled)
[10:32:24.322]                     }
[10:32:24.322]                     muffleCondition(cond, pattern = "^muffle")
[10:32:24.322]                   }
[10:32:24.322]                 }
[10:32:24.322]             }
[10:32:24.322]         }))
[10:32:24.322]     }, error = function(ex) {
[10:32:24.322]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:24.322]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:24.322]                 ...future.rng), started = ...future.startTime, 
[10:32:24.322]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:24.322]             version = "1.8"), class = "FutureResult")
[10:32:24.322]     }, finally = {
[10:32:24.322]         if (!identical(...future.workdir, getwd())) 
[10:32:24.322]             setwd(...future.workdir)
[10:32:24.322]         {
[10:32:24.322]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:24.322]                 ...future.oldOptions$nwarnings <- NULL
[10:32:24.322]             }
[10:32:24.322]             base::options(...future.oldOptions)
[10:32:24.322]             if (.Platform$OS.type == "windows") {
[10:32:24.322]                 old_names <- names(...future.oldEnvVars)
[10:32:24.322]                 envs <- base::Sys.getenv()
[10:32:24.322]                 names <- names(envs)
[10:32:24.322]                 common <- intersect(names, old_names)
[10:32:24.322]                 added <- setdiff(names, old_names)
[10:32:24.322]                 removed <- setdiff(old_names, names)
[10:32:24.322]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:24.322]                   envs[common]]
[10:32:24.322]                 NAMES <- toupper(changed)
[10:32:24.322]                 args <- list()
[10:32:24.322]                 for (kk in seq_along(NAMES)) {
[10:32:24.322]                   name <- changed[[kk]]
[10:32:24.322]                   NAME <- NAMES[[kk]]
[10:32:24.322]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:24.322]                     next
[10:32:24.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:24.322]                 }
[10:32:24.322]                 NAMES <- toupper(added)
[10:32:24.322]                 for (kk in seq_along(NAMES)) {
[10:32:24.322]                   name <- added[[kk]]
[10:32:24.322]                   NAME <- NAMES[[kk]]
[10:32:24.322]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:24.322]                     next
[10:32:24.322]                   args[[name]] <- ""
[10:32:24.322]                 }
[10:32:24.322]                 NAMES <- toupper(removed)
[10:32:24.322]                 for (kk in seq_along(NAMES)) {
[10:32:24.322]                   name <- removed[[kk]]
[10:32:24.322]                   NAME <- NAMES[[kk]]
[10:32:24.322]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:24.322]                     next
[10:32:24.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:24.322]                 }
[10:32:24.322]                 if (length(args) > 0) 
[10:32:24.322]                   base::do.call(base::Sys.setenv, args = args)
[10:32:24.322]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:24.322]             }
[10:32:24.322]             else {
[10:32:24.322]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:24.322]             }
[10:32:24.322]             {
[10:32:24.322]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:24.322]                   0L) {
[10:32:24.322]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:24.322]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:24.322]                   base::options(opts)
[10:32:24.322]                 }
[10:32:24.322]                 {
[10:32:24.322]                   {
[10:32:24.322]                     NULL
[10:32:24.322]                     RNGkind("Mersenne-Twister")
[10:32:24.322]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:24.322]                       inherits = FALSE)
[10:32:24.322]                   }
[10:32:24.322]                   options(future.plan = NULL)
[10:32:24.322]                   if (is.na(NA_character_)) 
[10:32:24.322]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:24.322]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:24.322]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:24.322]                     .init = FALSE)
[10:32:24.322]                 }
[10:32:24.322]             }
[10:32:24.322]         }
[10:32:24.322]     })
[10:32:24.322]     if (TRUE) {
[10:32:24.322]         base::sink(type = "output", split = FALSE)
[10:32:24.322]         if (TRUE) {
[10:32:24.322]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:24.322]         }
[10:32:24.322]         else {
[10:32:24.322]             ...future.result["stdout"] <- base::list(NULL)
[10:32:24.322]         }
[10:32:24.322]         base::close(...future.stdout)
[10:32:24.322]         ...future.stdout <- NULL
[10:32:24.322]     }
[10:32:24.322]     ...future.result$conditions <- ...future.conditions
[10:32:24.322]     ...future.result$finished <- base::Sys.time()
[10:32:24.322]     ...future.result
[10:32:24.322] }
[10:32:24.324] assign_globals() ...
[10:32:24.324] List of 4
[10:32:24.324]  $ ii   : int 1
[10:32:24.324]  $ n    : int 4
[10:32:24.324]  $ C    : cplx [1:25, 1:25] -2.25-1.5i -2.25-1.44i -2.25-1.38i ...
[10:32:24.324]   ..- attr(*, "region")=List of 2
[10:32:24.324]   .. ..$ xrange: num [1:2] -2.25 -0.781
[10:32:24.324]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[10:32:24.324]   ..- attr(*, "tile")= int [1:2] 1 1
[10:32:24.324]  $ delay:function (counts)  
[10:32:24.324]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[10:32:24.324]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x5583e3e3a818> 
[10:32:24.324]  - attr(*, "where")=List of 4
[10:32:24.324]   ..$ ii   :<environment: R_EmptyEnv> 
[10:32:24.324]   ..$ n    :<environment: R_EmptyEnv> 
[10:32:24.324]   ..$ C    :<environment: R_EmptyEnv> 
[10:32:24.324]   ..$ delay:<environment: R_EmptyEnv> 
[10:32:24.324]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:24.324]  - attr(*, "resolved")= logi FALSE
[10:32:24.324]  - attr(*, "total_size")= num 14584
[10:32:24.324]  - attr(*, "already-done")= logi TRUE
[10:32:24.330] - copied ‘ii’ to environment
[10:32:24.330] - copied ‘n’ to environment
[10:32:24.330] - copied ‘C’ to environment
[10:32:24.331] - reassign environment for ‘delay’
[10:32:24.331] - copied ‘delay’ to environment
[10:32:24.331] assign_globals() ... done
[10:32:24.331] plan(): Setting new future strategy stack:
[10:32:24.331] List of future strategies:
[10:32:24.331] 1. sequential:
[10:32:24.331]    - args: function (..., envir = parent.frame())
[10:32:24.331]    - tweaked: FALSE
[10:32:24.331]    - call: NULL
[10:32:24.332] plan(): nbrOfWorkers() = 1
[10:32:24.348] plan(): Setting new future strategy stack:
[10:32:24.348] List of future strategies:
[10:32:24.348] 1. sequential:
[10:32:24.348]    - args: function (..., envir = parent.frame())
[10:32:24.348]    - tweaked: FALSE
[10:32:24.348]    - call: plan(strategy)
[10:32:24.348] plan(): nbrOfWorkers() = 1
[10:32:24.349] SequentialFuture started (and completed)
[10:32:24.349] signalConditions() ...
[10:32:24.349]  - include = ‘immediateCondition’
[10:32:24.349]  - exclude = 
[10:32:24.349]  - resignal = FALSE
[10:32:24.349]  - Number of conditions: 2
[10:32:24.349] signalConditions() ... done
[10:32:24.349] - Launch lazy future ... done
[10:32:24.349] run() for ‘SequentialFuture’ ... done
[10:32:24.350] - run() ... done
[10:32:24.350] - resolved() ...
[10:32:24.350] resolved() for ‘SequentialFuture’ ...
[10:32:24.350] - state: ‘finished’
[10:32:24.350] - run: TRUE
[10:32:24.350] - result: ‘FutureResult’
[10:32:24.350] resolved() for ‘SequentialFuture’ ... done
[10:32:24.350] - resolved: TRUE
[10:32:24.350] - resolved() ... done
[10:32:24.350] resolved() for ‘SequentialFuture’ ... done
Plotting tile #1 of 4 ...
[10:32:24.351] signalConditions() ...
[10:32:24.351]  - include = ‘immediateCondition’
[10:32:24.351]  - exclude = 
[10:32:24.351]  - resignal = FALSE
[10:32:24.351]  - Number of conditions: 2
[10:32:24.351] signalConditions() ... done
[10:32:24.351] Future state: ‘finished’
[10:32:24.351] signalConditions() ...
[10:32:24.351]  - include = ‘condition’
[10:32:24.351]  - exclude = ‘immediateCondition’
[10:32:24.351]  - resignal = TRUE
[10:32:24.352]  - Number of conditions: 2
[10:32:24.352]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #1 of 4 ...[10:32:24.352]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[10:32:24.352] signalConditions() ... done
[10:32:24.353] resolved() for ‘Future’ ...
[10:32:24.354] - state: ‘created’
[10:32:24.354] - run: TRUE
[10:32:24.354] - run() ...
[10:32:24.354] run() for ‘Future’ ...
[10:32:24.354] - state: ‘created’
[10:32:24.354] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:24.354] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:24.354] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:24.355]   - Field: ‘label’
[10:32:24.355]   - Field: ‘local’
[10:32:24.355]   - Field: ‘owner’
[10:32:24.355]   - Field: ‘envir’
[10:32:24.355]   - Field: ‘packages’
[10:32:24.355]   - Field: ‘gc’
[10:32:24.355]   - Field: ‘conditions’
[10:32:24.355]   - Field: ‘expr’
[10:32:24.355]   - Field: ‘uuid’
[10:32:24.355]   - Field: ‘seed’
[10:32:24.356]   - Field: ‘version’
[10:32:24.356]   - Field: ‘result’
[10:32:24.356]   - Field: ‘asynchronous’
[10:32:24.356]   - Field: ‘calls’
[10:32:24.356]   - Field: ‘globals’
[10:32:24.356]   - Field: ‘stdout’
[10:32:24.356]   - Field: ‘earlySignal’
[10:32:24.356]   - Field: ‘lazy’
[10:32:24.356]   - Field: ‘state’
[10:32:24.356] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:24.356] - Launch lazy future ...
[10:32:24.357] Packages needed by the future expression (n = 1): ‘future’
[10:32:24.357] Packages needed by future strategies (n = 0): <none>
[10:32:24.357] {
[10:32:24.357]     {
[10:32:24.357]         {
[10:32:24.357]             ...future.startTime <- base::Sys.time()
[10:32:24.357]             {
[10:32:24.357]                 {
[10:32:24.357]                   {
[10:32:24.357]                     {
[10:32:24.357]                       base::local({
[10:32:24.357]                         has_future <- base::requireNamespace("future", 
[10:32:24.357]                           quietly = TRUE)
[10:32:24.357]                         if (has_future) {
[10:32:24.357]                           ns <- base::getNamespace("future")
[10:32:24.357]                           version <- ns[[".package"]][["version"]]
[10:32:24.357]                           if (is.null(version)) 
[10:32:24.357]                             version <- utils::packageVersion("future")
[10:32:24.357]                         }
[10:32:24.357]                         else {
[10:32:24.357]                           version <- NULL
[10:32:24.357]                         }
[10:32:24.357]                         if (!has_future || version < "1.8.0") {
[10:32:24.357]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:24.357]                             "", base::R.version$version.string), 
[10:32:24.357]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:24.357]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:24.357]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:24.357]                               "release", "version")], collapse = " "), 
[10:32:24.357]                             hostname = base::Sys.info()[["nodename"]])
[10:32:24.357]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:24.357]                             info)
[10:32:24.357]                           info <- base::paste(info, collapse = "; ")
[10:32:24.357]                           if (!has_future) {
[10:32:24.357]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:24.357]                               info)
[10:32:24.357]                           }
[10:32:24.357]                           else {
[10:32:24.357]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:24.357]                               info, version)
[10:32:24.357]                           }
[10:32:24.357]                           base::stop(msg)
[10:32:24.357]                         }
[10:32:24.357]                       })
[10:32:24.357]                     }
[10:32:24.357]                     base::local({
[10:32:24.357]                       for (pkg in "future") {
[10:32:24.357]                         base::loadNamespace(pkg)
[10:32:24.357]                         base::library(pkg, character.only = TRUE)
[10:32:24.357]                       }
[10:32:24.357]                     })
[10:32:24.357]                   }
[10:32:24.357]                   ...future.strategy.old <- future::plan("list")
[10:32:24.357]                   options(future.plan = NULL)
[10:32:24.357]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:24.357]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:24.357]                 }
[10:32:24.357]                 ...future.workdir <- getwd()
[10:32:24.357]             }
[10:32:24.357]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:24.357]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:24.357]         }
[10:32:24.357]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:24.357]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:24.357]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:24.357]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:24.357]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:24.357]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:24.357]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:24.357]             base::names(...future.oldOptions))
[10:32:24.357]     }
[10:32:24.357]     if (FALSE) {
[10:32:24.357]     }
[10:32:24.357]     else {
[10:32:24.357]         if (TRUE) {
[10:32:24.357]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:24.357]                 open = "w")
[10:32:24.357]         }
[10:32:24.357]         else {
[10:32:24.357]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:24.357]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:24.357]         }
[10:32:24.357]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:24.357]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:24.357]             base::sink(type = "output", split = FALSE)
[10:32:24.357]             base::close(...future.stdout)
[10:32:24.357]         }, add = TRUE)
[10:32:24.357]     }
[10:32:24.357]     ...future.frame <- base::sys.nframe()
[10:32:24.357]     ...future.conditions <- base::list()
[10:32:24.357]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:24.357]     if (FALSE) {
[10:32:24.357]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:24.357]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:24.357]     }
[10:32:24.357]     ...future.result <- base::tryCatch({
[10:32:24.357]         base::withCallingHandlers({
[10:32:24.357]             ...future.value <- base::withVisible(base::local({
[10:32:24.357]                 message(sprintf("Calculating tile #%d of %d ...", 
[10:32:24.357]                   ii, n), appendLF = FALSE)
[10:32:24.357]                 fit <- mandelbrot(C)
[10:32:24.357]                 delay(fit)
[10:32:24.357]                 message(" done")
[10:32:24.357]                 fit
[10:32:24.357]             }))
[10:32:24.357]             future::FutureResult(value = ...future.value$value, 
[10:32:24.357]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:24.357]                   ...future.rng), globalenv = if (FALSE) 
[10:32:24.357]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:24.357]                     ...future.globalenv.names))
[10:32:24.357]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:24.357]         }, condition = base::local({
[10:32:24.357]             c <- base::c
[10:32:24.357]             inherits <- base::inherits
[10:32:24.357]             invokeRestart <- base::invokeRestart
[10:32:24.357]             length <- base::length
[10:32:24.357]             list <- base::list
[10:32:24.357]             seq.int <- base::seq.int
[10:32:24.357]             signalCondition <- base::signalCondition
[10:32:24.357]             sys.calls <- base::sys.calls
[10:32:24.357]             `[[` <- base::`[[`
[10:32:24.357]             `+` <- base::`+`
[10:32:24.357]             `<<-` <- base::`<<-`
[10:32:24.357]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:24.357]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:24.357]                   3L)]
[10:32:24.357]             }
[10:32:24.357]             function(cond) {
[10:32:24.357]                 is_error <- inherits(cond, "error")
[10:32:24.357]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:24.357]                   NULL)
[10:32:24.357]                 if (is_error) {
[10:32:24.357]                   sessionInformation <- function() {
[10:32:24.357]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:24.357]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:24.357]                       search = base::search(), system = base::Sys.info())
[10:32:24.357]                   }
[10:32:24.357]                   ...future.conditions[[length(...future.conditions) + 
[10:32:24.357]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:24.357]                     cond$call), session = sessionInformation(), 
[10:32:24.357]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:24.357]                   signalCondition(cond)
[10:32:24.357]                 }
[10:32:24.357]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:24.357]                 "immediateCondition"))) {
[10:32:24.357]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:24.357]                   ...future.conditions[[length(...future.conditions) + 
[10:32:24.357]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:24.357]                   if (TRUE && !signal) {
[10:32:24.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:24.357]                     {
[10:32:24.357]                       inherits <- base::inherits
[10:32:24.357]                       invokeRestart <- base::invokeRestart
[10:32:24.357]                       is.null <- base::is.null
[10:32:24.357]                       muffled <- FALSE
[10:32:24.357]                       if (inherits(cond, "message")) {
[10:32:24.357]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:24.357]                         if (muffled) 
[10:32:24.357]                           invokeRestart("muffleMessage")
[10:32:24.357]                       }
[10:32:24.357]                       else if (inherits(cond, "warning")) {
[10:32:24.357]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:24.357]                         if (muffled) 
[10:32:24.357]                           invokeRestart("muffleWarning")
[10:32:24.357]                       }
[10:32:24.357]                       else if (inherits(cond, "condition")) {
[10:32:24.357]                         if (!is.null(pattern)) {
[10:32:24.357]                           computeRestarts <- base::computeRestarts
[10:32:24.357]                           grepl <- base::grepl
[10:32:24.357]                           restarts <- computeRestarts(cond)
[10:32:24.357]                           for (restart in restarts) {
[10:32:24.357]                             name <- restart$name
[10:32:24.357]                             if (is.null(name)) 
[10:32:24.357]                               next
[10:32:24.357]                             if (!grepl(pattern, name)) 
[10:32:24.357]                               next
[10:32:24.357]                             invokeRestart(restart)
[10:32:24.357]                             muffled <- TRUE
[10:32:24.357]                             break
[10:32:24.357]                           }
[10:32:24.357]                         }
[10:32:24.357]                       }
[10:32:24.357]                       invisible(muffled)
[10:32:24.357]                     }
[10:32:24.357]                     muffleCondition(cond, pattern = "^muffle")
[10:32:24.357]                   }
[10:32:24.357]                 }
[10:32:24.357]                 else {
[10:32:24.357]                   if (TRUE) {
[10:32:24.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:24.357]                     {
[10:32:24.357]                       inherits <- base::inherits
[10:32:24.357]                       invokeRestart <- base::invokeRestart
[10:32:24.357]                       is.null <- base::is.null
[10:32:24.357]                       muffled <- FALSE
[10:32:24.357]                       if (inherits(cond, "message")) {
[10:32:24.357]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:24.357]                         if (muffled) 
[10:32:24.357]                           invokeRestart("muffleMessage")
[10:32:24.357]                       }
[10:32:24.357]                       else if (inherits(cond, "warning")) {
[10:32:24.357]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:24.357]                         if (muffled) 
[10:32:24.357]                           invokeRestart("muffleWarning")
[10:32:24.357]                       }
[10:32:24.357]                       else if (inherits(cond, "condition")) {
[10:32:24.357]                         if (!is.null(pattern)) {
[10:32:24.357]                           computeRestarts <- base::computeRestarts
[10:32:24.357]                           grepl <- base::grepl
[10:32:24.357]                           restarts <- computeRestarts(cond)
[10:32:24.357]                           for (restart in restarts) {
[10:32:24.357]                             name <- restart$name
[10:32:24.357]                             if (is.null(name)) 
[10:32:24.357]                               next
[10:32:24.357]                             if (!grepl(pattern, name)) 
[10:32:24.357]                               next
[10:32:24.357]                             invokeRestart(restart)
[10:32:24.357]                             muffled <- TRUE
[10:32:24.357]                             break
[10:32:24.357]                           }
[10:32:24.357]                         }
[10:32:24.357]                       }
[10:32:24.357]                       invisible(muffled)
[10:32:24.357]                     }
[10:32:24.357]                     muffleCondition(cond, pattern = "^muffle")
[10:32:24.357]                   }
[10:32:24.357]                 }
[10:32:24.357]             }
[10:32:24.357]         }))
[10:32:24.357]     }, error = function(ex) {
[10:32:24.357]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:24.357]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:24.357]                 ...future.rng), started = ...future.startTime, 
[10:32:24.357]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:24.357]             version = "1.8"), class = "FutureResult")
[10:32:24.357]     }, finally = {
[10:32:24.357]         if (!identical(...future.workdir, getwd())) 
[10:32:24.357]             setwd(...future.workdir)
[10:32:24.357]         {
[10:32:24.357]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:24.357]                 ...future.oldOptions$nwarnings <- NULL
[10:32:24.357]             }
[10:32:24.357]             base::options(...future.oldOptions)
[10:32:24.357]             if (.Platform$OS.type == "windows") {
[10:32:24.357]                 old_names <- names(...future.oldEnvVars)
[10:32:24.357]                 envs <- base::Sys.getenv()
[10:32:24.357]                 names <- names(envs)
[10:32:24.357]                 common <- intersect(names, old_names)
[10:32:24.357]                 added <- setdiff(names, old_names)
[10:32:24.357]                 removed <- setdiff(old_names, names)
[10:32:24.357]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:24.357]                   envs[common]]
[10:32:24.357]                 NAMES <- toupper(changed)
[10:32:24.357]                 args <- list()
[10:32:24.357]                 for (kk in seq_along(NAMES)) {
[10:32:24.357]                   name <- changed[[kk]]
[10:32:24.357]                   NAME <- NAMES[[kk]]
[10:32:24.357]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:24.357]                     next
[10:32:24.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:24.357]                 }
[10:32:24.357]                 NAMES <- toupper(added)
[10:32:24.357]                 for (kk in seq_along(NAMES)) {
[10:32:24.357]                   name <- added[[kk]]
[10:32:24.357]                   NAME <- NAMES[[kk]]
[10:32:24.357]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:24.357]                     next
[10:32:24.357]                   args[[name]] <- ""
[10:32:24.357]                 }
[10:32:24.357]                 NAMES <- toupper(removed)
[10:32:24.357]                 for (kk in seq_along(NAMES)) {
[10:32:24.357]                   name <- removed[[kk]]
[10:32:24.357]                   NAME <- NAMES[[kk]]
[10:32:24.357]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:24.357]                     next
[10:32:24.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:24.357]                 }
[10:32:24.357]                 if (length(args) > 0) 
[10:32:24.357]                   base::do.call(base::Sys.setenv, args = args)
[10:32:24.357]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:24.357]             }
[10:32:24.357]             else {
[10:32:24.357]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:24.357]             }
[10:32:24.357]             {
[10:32:24.357]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:24.357]                   0L) {
[10:32:24.357]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:24.357]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:24.357]                   base::options(opts)
[10:32:24.357]                 }
[10:32:24.357]                 {
[10:32:24.357]                   {
[10:32:24.357]                     NULL
[10:32:24.357]                     RNGkind("Mersenne-Twister")
[10:32:24.357]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:24.357]                       inherits = FALSE)
[10:32:24.357]                   }
[10:32:24.357]                   options(future.plan = NULL)
[10:32:24.357]                   if (is.na(NA_character_)) 
[10:32:24.357]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:24.357]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:24.357]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:24.357]                     .init = FALSE)
[10:32:24.357]                 }
[10:32:24.357]             }
[10:32:24.357]         }
[10:32:24.357]     })
[10:32:24.357]     if (TRUE) {
[10:32:24.357]         base::sink(type = "output", split = FALSE)
[10:32:24.357]         if (TRUE) {
[10:32:24.357]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:24.357]         }
[10:32:24.357]         else {
[10:32:24.357]             ...future.result["stdout"] <- base::list(NULL)
[10:32:24.357]         }
[10:32:24.357]         base::close(...future.stdout)
[10:32:24.357]         ...future.stdout <- NULL
[10:32:24.357]     }
[10:32:24.357]     ...future.result$conditions <- ...future.conditions
[10:32:24.357]     ...future.result$finished <- base::Sys.time()
[10:32:24.357]     ...future.result
[10:32:24.357] }
[10:32:24.359] assign_globals() ...
[10:32:24.359] List of 4
[10:32:24.359]  $ ii   : int 2
[10:32:24.359]  $ n    : int 4
[10:32:24.359]  $ C    : cplx [1:25, 1:25] -0.72-1.5i -0.72-1.44i -0.72-1.38i ...
[10:32:24.359]   ..- attr(*, "region")=List of 2
[10:32:24.359]   .. ..$ xrange: num [1:2] -0.719 0.75
[10:32:24.359]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[10:32:24.359]   ..- attr(*, "tile")= int [1:2] 1 2
[10:32:24.359]  $ delay:function (counts)  
[10:32:24.359]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[10:32:24.359]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x5583e3e3a818> 
[10:32:24.359]  - attr(*, "where")=List of 4
[10:32:24.359]   ..$ ii   :<environment: R_EmptyEnv> 
[10:32:24.359]   ..$ n    :<environment: R_EmptyEnv> 
[10:32:24.359]   ..$ C    :<environment: R_EmptyEnv> 
[10:32:24.359]   ..$ delay:<environment: R_EmptyEnv> 
[10:32:24.359]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:24.359]  - attr(*, "resolved")= logi FALSE
[10:32:24.359]  - attr(*, "total_size")= num 14584
[10:32:24.359]  - attr(*, "already-done")= logi TRUE
[10:32:24.365] - copied ‘ii’ to environment
[10:32:24.365] - copied ‘n’ to environment
[10:32:24.365] - copied ‘C’ to environment
[10:32:24.365] - reassign environment for ‘delay’
[10:32:24.365] - copied ‘delay’ to environment
[10:32:24.365] assign_globals() ... done
[10:32:24.366] plan(): Setting new future strategy stack:
[10:32:24.366] List of future strategies:
[10:32:24.366] 1. sequential:
[10:32:24.366]    - args: function (..., envir = parent.frame())
[10:32:24.366]    - tweaked: FALSE
[10:32:24.366]    - call: NULL
[10:32:24.366] plan(): nbrOfWorkers() = 1
[10:32:24.381] plan(): Setting new future strategy stack:
[10:32:24.381] List of future strategies:
[10:32:24.381] 1. sequential:
[10:32:24.381]    - args: function (..., envir = parent.frame())
[10:32:24.381]    - tweaked: FALSE
[10:32:24.381]    - call: plan(strategy)
[10:32:24.381] plan(): nbrOfWorkers() = 1
[10:32:24.381] SequentialFuture started (and completed)
[10:32:24.381] signalConditions() ...
[10:32:24.381]  - include = ‘immediateCondition’
[10:32:24.381]  - exclude = 
[10:32:24.382]  - resignal = FALSE
[10:32:24.382]  - Number of conditions: 2
[10:32:24.382] signalConditions() ... done
[10:32:24.382] - Launch lazy future ... done
[10:32:24.382] run() for ‘SequentialFuture’ ... done
[10:32:24.382] - run() ... done
[10:32:24.382] - resolved() ...
[10:32:24.382] resolved() for ‘SequentialFuture’ ...
[10:32:24.382] - state: ‘finished’
[10:32:24.382] - run: TRUE
[10:32:24.382] - result: ‘FutureResult’
[10:32:24.383] resolved() for ‘SequentialFuture’ ... done
[10:32:24.383] - resolved: TRUE
[10:32:24.383] - resolved() ... done
[10:32:24.383] resolved() for ‘SequentialFuture’ ... done
Plotting tile #2 of 4 ...
[10:32:24.383] signalConditions() ...
[10:32:24.383]  - include = ‘immediateCondition’
[10:32:24.383]  - exclude = 
[10:32:24.383]  - resignal = FALSE
[10:32:24.383]  - Number of conditions: 2
[10:32:24.383] signalConditions() ... done
[10:32:24.384] Future state: ‘finished’
[10:32:24.384] signalConditions() ...
[10:32:24.384]  - include = ‘condition’
[10:32:24.384]  - exclude = ‘immediateCondition’
[10:32:24.384]  - resignal = TRUE
[10:32:24.384]  - Number of conditions: 2
[10:32:24.384]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #2 of 4 ...[10:32:24.384]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[10:32:24.384] signalConditions() ... done
[10:32:24.385] resolved() for ‘Future’ ...
[10:32:24.385] - state: ‘created’
[10:32:24.385] - run: TRUE
[10:32:24.385] - run() ...
[10:32:24.385] run() for ‘Future’ ...
[10:32:24.385] - state: ‘created’
[10:32:24.385] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:24.386] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:24.386] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:24.386]   - Field: ‘label’
[10:32:24.386]   - Field: ‘local’
[10:32:24.386]   - Field: ‘owner’
[10:32:24.386]   - Field: ‘envir’
[10:32:24.386]   - Field: ‘packages’
[10:32:24.386]   - Field: ‘gc’
[10:32:24.387]   - Field: ‘conditions’
[10:32:24.387]   - Field: ‘expr’
[10:32:24.387]   - Field: ‘uuid’
[10:32:24.387]   - Field: ‘seed’
[10:32:24.387]   - Field: ‘version’
[10:32:24.387]   - Field: ‘result’
[10:32:24.387]   - Field: ‘asynchronous’
[10:32:24.387]   - Field: ‘calls’
[10:32:24.387]   - Field: ‘globals’
[10:32:24.387]   - Field: ‘stdout’
[10:32:24.387]   - Field: ‘earlySignal’
[10:32:24.388]   - Field: ‘lazy’
[10:32:24.388]   - Field: ‘state’
[10:32:24.388] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:24.388] - Launch lazy future ...
[10:32:24.388] Packages needed by the future expression (n = 1): ‘future’
[10:32:24.388] Packages needed by future strategies (n = 0): <none>
[10:32:24.389] {
[10:32:24.389]     {
[10:32:24.389]         {
[10:32:24.389]             ...future.startTime <- base::Sys.time()
[10:32:24.389]             {
[10:32:24.389]                 {
[10:32:24.389]                   {
[10:32:24.389]                     {
[10:32:24.389]                       base::local({
[10:32:24.389]                         has_future <- base::requireNamespace("future", 
[10:32:24.389]                           quietly = TRUE)
[10:32:24.389]                         if (has_future) {
[10:32:24.389]                           ns <- base::getNamespace("future")
[10:32:24.389]                           version <- ns[[".package"]][["version"]]
[10:32:24.389]                           if (is.null(version)) 
[10:32:24.389]                             version <- utils::packageVersion("future")
[10:32:24.389]                         }
[10:32:24.389]                         else {
[10:32:24.389]                           version <- NULL
[10:32:24.389]                         }
[10:32:24.389]                         if (!has_future || version < "1.8.0") {
[10:32:24.389]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:24.389]                             "", base::R.version$version.string), 
[10:32:24.389]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:24.389]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:24.389]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:24.389]                               "release", "version")], collapse = " "), 
[10:32:24.389]                             hostname = base::Sys.info()[["nodename"]])
[10:32:24.389]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:24.389]                             info)
[10:32:24.389]                           info <- base::paste(info, collapse = "; ")
[10:32:24.389]                           if (!has_future) {
[10:32:24.389]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:24.389]                               info)
[10:32:24.389]                           }
[10:32:24.389]                           else {
[10:32:24.389]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:24.389]                               info, version)
[10:32:24.389]                           }
[10:32:24.389]                           base::stop(msg)
[10:32:24.389]                         }
[10:32:24.389]                       })
[10:32:24.389]                     }
[10:32:24.389]                     base::local({
[10:32:24.389]                       for (pkg in "future") {
[10:32:24.389]                         base::loadNamespace(pkg)
[10:32:24.389]                         base::library(pkg, character.only = TRUE)
[10:32:24.389]                       }
[10:32:24.389]                     })
[10:32:24.389]                   }
[10:32:24.389]                   ...future.strategy.old <- future::plan("list")
[10:32:24.389]                   options(future.plan = NULL)
[10:32:24.389]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:24.389]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:24.389]                 }
[10:32:24.389]                 ...future.workdir <- getwd()
[10:32:24.389]             }
[10:32:24.389]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:24.389]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:24.389]         }
[10:32:24.389]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:24.389]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:24.389]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:24.389]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:24.389]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:24.389]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:24.389]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:24.389]             base::names(...future.oldOptions))
[10:32:24.389]     }
[10:32:24.389]     if (FALSE) {
[10:32:24.389]     }
[10:32:24.389]     else {
[10:32:24.389]         if (TRUE) {
[10:32:24.389]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:24.389]                 open = "w")
[10:32:24.389]         }
[10:32:24.389]         else {
[10:32:24.389]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:24.389]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:24.389]         }
[10:32:24.389]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:24.389]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:24.389]             base::sink(type = "output", split = FALSE)
[10:32:24.389]             base::close(...future.stdout)
[10:32:24.389]         }, add = TRUE)
[10:32:24.389]     }
[10:32:24.389]     ...future.frame <- base::sys.nframe()
[10:32:24.389]     ...future.conditions <- base::list()
[10:32:24.389]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:24.389]     if (FALSE) {
[10:32:24.389]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:24.389]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:24.389]     }
[10:32:24.389]     ...future.result <- base::tryCatch({
[10:32:24.389]         base::withCallingHandlers({
[10:32:24.389]             ...future.value <- base::withVisible(base::local({
[10:32:24.389]                 message(sprintf("Calculating tile #%d of %d ...", 
[10:32:24.389]                   ii, n), appendLF = FALSE)
[10:32:24.389]                 fit <- mandelbrot(C)
[10:32:24.389]                 delay(fit)
[10:32:24.389]                 message(" done")
[10:32:24.389]                 fit
[10:32:24.389]             }))
[10:32:24.389]             future::FutureResult(value = ...future.value$value, 
[10:32:24.389]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:24.389]                   ...future.rng), globalenv = if (FALSE) 
[10:32:24.389]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:24.389]                     ...future.globalenv.names))
[10:32:24.389]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:24.389]         }, condition = base::local({
[10:32:24.389]             c <- base::c
[10:32:24.389]             inherits <- base::inherits
[10:32:24.389]             invokeRestart <- base::invokeRestart
[10:32:24.389]             length <- base::length
[10:32:24.389]             list <- base::list
[10:32:24.389]             seq.int <- base::seq.int
[10:32:24.389]             signalCondition <- base::signalCondition
[10:32:24.389]             sys.calls <- base::sys.calls
[10:32:24.389]             `[[` <- base::`[[`
[10:32:24.389]             `+` <- base::`+`
[10:32:24.389]             `<<-` <- base::`<<-`
[10:32:24.389]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:24.389]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:24.389]                   3L)]
[10:32:24.389]             }
[10:32:24.389]             function(cond) {
[10:32:24.389]                 is_error <- inherits(cond, "error")
[10:32:24.389]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:24.389]                   NULL)
[10:32:24.389]                 if (is_error) {
[10:32:24.389]                   sessionInformation <- function() {
[10:32:24.389]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:24.389]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:24.389]                       search = base::search(), system = base::Sys.info())
[10:32:24.389]                   }
[10:32:24.389]                   ...future.conditions[[length(...future.conditions) + 
[10:32:24.389]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:24.389]                     cond$call), session = sessionInformation(), 
[10:32:24.389]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:24.389]                   signalCondition(cond)
[10:32:24.389]                 }
[10:32:24.389]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:24.389]                 "immediateCondition"))) {
[10:32:24.389]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:24.389]                   ...future.conditions[[length(...future.conditions) + 
[10:32:24.389]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:24.389]                   if (TRUE && !signal) {
[10:32:24.389]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:24.389]                     {
[10:32:24.389]                       inherits <- base::inherits
[10:32:24.389]                       invokeRestart <- base::invokeRestart
[10:32:24.389]                       is.null <- base::is.null
[10:32:24.389]                       muffled <- FALSE
[10:32:24.389]                       if (inherits(cond, "message")) {
[10:32:24.389]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:24.389]                         if (muffled) 
[10:32:24.389]                           invokeRestart("muffleMessage")
[10:32:24.389]                       }
[10:32:24.389]                       else if (inherits(cond, "warning")) {
[10:32:24.389]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:24.389]                         if (muffled) 
[10:32:24.389]                           invokeRestart("muffleWarning")
[10:32:24.389]                       }
[10:32:24.389]                       else if (inherits(cond, "condition")) {
[10:32:24.389]                         if (!is.null(pattern)) {
[10:32:24.389]                           computeRestarts <- base::computeRestarts
[10:32:24.389]                           grepl <- base::grepl
[10:32:24.389]                           restarts <- computeRestarts(cond)
[10:32:24.389]                           for (restart in restarts) {
[10:32:24.389]                             name <- restart$name
[10:32:24.389]                             if (is.null(name)) 
[10:32:24.389]                               next
[10:32:24.389]                             if (!grepl(pattern, name)) 
[10:32:24.389]                               next
[10:32:24.389]                             invokeRestart(restart)
[10:32:24.389]                             muffled <- TRUE
[10:32:24.389]                             break
[10:32:24.389]                           }
[10:32:24.389]                         }
[10:32:24.389]                       }
[10:32:24.389]                       invisible(muffled)
[10:32:24.389]                     }
[10:32:24.389]                     muffleCondition(cond, pattern = "^muffle")
[10:32:24.389]                   }
[10:32:24.389]                 }
[10:32:24.389]                 else {
[10:32:24.389]                   if (TRUE) {
[10:32:24.389]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:24.389]                     {
[10:32:24.389]                       inherits <- base::inherits
[10:32:24.389]                       invokeRestart <- base::invokeRestart
[10:32:24.389]                       is.null <- base::is.null
[10:32:24.389]                       muffled <- FALSE
[10:32:24.389]                       if (inherits(cond, "message")) {
[10:32:24.389]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:24.389]                         if (muffled) 
[10:32:24.389]                           invokeRestart("muffleMessage")
[10:32:24.389]                       }
[10:32:24.389]                       else if (inherits(cond, "warning")) {
[10:32:24.389]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:24.389]                         if (muffled) 
[10:32:24.389]                           invokeRestart("muffleWarning")
[10:32:24.389]                       }
[10:32:24.389]                       else if (inherits(cond, "condition")) {
[10:32:24.389]                         if (!is.null(pattern)) {
[10:32:24.389]                           computeRestarts <- base::computeRestarts
[10:32:24.389]                           grepl <- base::grepl
[10:32:24.389]                           restarts <- computeRestarts(cond)
[10:32:24.389]                           for (restart in restarts) {
[10:32:24.389]                             name <- restart$name
[10:32:24.389]                             if (is.null(name)) 
[10:32:24.389]                               next
[10:32:24.389]                             if (!grepl(pattern, name)) 
[10:32:24.389]                               next
[10:32:24.389]                             invokeRestart(restart)
[10:32:24.389]                             muffled <- TRUE
[10:32:24.389]                             break
[10:32:24.389]                           }
[10:32:24.389]                         }
[10:32:24.389]                       }
[10:32:24.389]                       invisible(muffled)
[10:32:24.389]                     }
[10:32:24.389]                     muffleCondition(cond, pattern = "^muffle")
[10:32:24.389]                   }
[10:32:24.389]                 }
[10:32:24.389]             }
[10:32:24.389]         }))
[10:32:24.389]     }, error = function(ex) {
[10:32:24.389]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:24.389]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:24.389]                 ...future.rng), started = ...future.startTime, 
[10:32:24.389]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:24.389]             version = "1.8"), class = "FutureResult")
[10:32:24.389]     }, finally = {
[10:32:24.389]         if (!identical(...future.workdir, getwd())) 
[10:32:24.389]             setwd(...future.workdir)
[10:32:24.389]         {
[10:32:24.389]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:24.389]                 ...future.oldOptions$nwarnings <- NULL
[10:32:24.389]             }
[10:32:24.389]             base::options(...future.oldOptions)
[10:32:24.389]             if (.Platform$OS.type == "windows") {
[10:32:24.389]                 old_names <- names(...future.oldEnvVars)
[10:32:24.389]                 envs <- base::Sys.getenv()
[10:32:24.389]                 names <- names(envs)
[10:32:24.389]                 common <- intersect(names, old_names)
[10:32:24.389]                 added <- setdiff(names, old_names)
[10:32:24.389]                 removed <- setdiff(old_names, names)
[10:32:24.389]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:24.389]                   envs[common]]
[10:32:24.389]                 NAMES <- toupper(changed)
[10:32:24.389]                 args <- list()
[10:32:24.389]                 for (kk in seq_along(NAMES)) {
[10:32:24.389]                   name <- changed[[kk]]
[10:32:24.389]                   NAME <- NAMES[[kk]]
[10:32:24.389]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:24.389]                     next
[10:32:24.389]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:24.389]                 }
[10:32:24.389]                 NAMES <- toupper(added)
[10:32:24.389]                 for (kk in seq_along(NAMES)) {
[10:32:24.389]                   name <- added[[kk]]
[10:32:24.389]                   NAME <- NAMES[[kk]]
[10:32:24.389]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:24.389]                     next
[10:32:24.389]                   args[[name]] <- ""
[10:32:24.389]                 }
[10:32:24.389]                 NAMES <- toupper(removed)
[10:32:24.389]                 for (kk in seq_along(NAMES)) {
[10:32:24.389]                   name <- removed[[kk]]
[10:32:24.389]                   NAME <- NAMES[[kk]]
[10:32:24.389]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:24.389]                     next
[10:32:24.389]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:24.389]                 }
[10:32:24.389]                 if (length(args) > 0) 
[10:32:24.389]                   base::do.call(base::Sys.setenv, args = args)
[10:32:24.389]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:24.389]             }
[10:32:24.389]             else {
[10:32:24.389]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:24.389]             }
[10:32:24.389]             {
[10:32:24.389]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:24.389]                   0L) {
[10:32:24.389]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:24.389]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:24.389]                   base::options(opts)
[10:32:24.389]                 }
[10:32:24.389]                 {
[10:32:24.389]                   {
[10:32:24.389]                     NULL
[10:32:24.389]                     RNGkind("Mersenne-Twister")
[10:32:24.389]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:24.389]                       inherits = FALSE)
[10:32:24.389]                   }
[10:32:24.389]                   options(future.plan = NULL)
[10:32:24.389]                   if (is.na(NA_character_)) 
[10:32:24.389]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:24.389]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:24.389]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:24.389]                     .init = FALSE)
[10:32:24.389]                 }
[10:32:24.389]             }
[10:32:24.389]         }
[10:32:24.389]     })
[10:32:24.389]     if (TRUE) {
[10:32:24.389]         base::sink(type = "output", split = FALSE)
[10:32:24.389]         if (TRUE) {
[10:32:24.389]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:24.389]         }
[10:32:24.389]         else {
[10:32:24.389]             ...future.result["stdout"] <- base::list(NULL)
[10:32:24.389]         }
[10:32:24.389]         base::close(...future.stdout)
[10:32:24.389]         ...future.stdout <- NULL
[10:32:24.389]     }
[10:32:24.389]     ...future.result$conditions <- ...future.conditions
[10:32:24.389]     ...future.result$finished <- base::Sys.time()
[10:32:24.389]     ...future.result
[10:32:24.389] }
[10:32:24.390] assign_globals() ...
[10:32:24.390] List of 4
[10:32:24.390]  $ ii   : int 3
[10:32:24.390]  $ n    : int 4
[10:32:24.390]  $ C    : cplx [1:25, 1:25] -2.25+0.03i -2.25+0.09i -2.25+0.15i ...
[10:32:24.390]   ..- attr(*, "region")=List of 2
[10:32:24.390]   .. ..$ xrange: num [1:2] -2.25 -0.781
[10:32:24.390]   .. ..$ yrange: num [1:2] 0.0306 1.5
[10:32:24.390]   ..- attr(*, "tile")= int [1:2] 2 1
[10:32:24.390]  $ delay:function (counts)  
[10:32:24.390]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[10:32:24.390]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x5583e3e3a818> 
[10:32:24.390]  - attr(*, "where")=List of 4
[10:32:24.390]   ..$ ii   :<environment: R_EmptyEnv> 
[10:32:24.390]   ..$ n    :<environment: R_EmptyEnv> 
[10:32:24.390]   ..$ C    :<environment: R_EmptyEnv> 
[10:32:24.390]   ..$ delay:<environment: R_EmptyEnv> 
[10:32:24.390]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:24.390]  - attr(*, "resolved")= logi FALSE
[10:32:24.390]  - attr(*, "total_size")= num 14584
[10:32:24.390]  - attr(*, "already-done")= logi TRUE
[10:32:24.396] - copied ‘ii’ to environment
[10:32:24.396] - copied ‘n’ to environment
[10:32:24.397] - copied ‘C’ to environment
[10:32:24.397] - reassign environment for ‘delay’
[10:32:24.397] - copied ‘delay’ to environment
[10:32:24.397] assign_globals() ... done
[10:32:24.397] plan(): Setting new future strategy stack:
[10:32:24.397] List of future strategies:
[10:32:24.397] 1. sequential:
[10:32:24.397]    - args: function (..., envir = parent.frame())
[10:32:24.397]    - tweaked: FALSE
[10:32:24.397]    - call: NULL
[10:32:24.398] plan(): nbrOfWorkers() = 1
[10:32:24.414] plan(): Setting new future strategy stack:
[10:32:24.414] List of future strategies:
[10:32:24.414] 1. sequential:
[10:32:24.414]    - args: function (..., envir = parent.frame())
[10:32:24.414]    - tweaked: FALSE
[10:32:24.414]    - call: plan(strategy)
[10:32:24.415] plan(): nbrOfWorkers() = 1
[10:32:24.415] SequentialFuture started (and completed)
[10:32:24.415] signalConditions() ...
[10:32:24.415]  - include = ‘immediateCondition’
[10:32:24.415]  - exclude = 
[10:32:24.415]  - resignal = FALSE
[10:32:24.415]  - Number of conditions: 2
[10:32:24.415] signalConditions() ... done
[10:32:24.415] - Launch lazy future ... done
[10:32:24.416] run() for ‘SequentialFuture’ ... done
[10:32:24.416] - run() ... done
[10:32:24.416] - resolved() ...
[10:32:24.416] resolved() for ‘SequentialFuture’ ...
[10:32:24.416] - state: ‘finished’
[10:32:24.416] - run: TRUE
[10:32:24.416] - result: ‘FutureResult’
[10:32:24.416] resolved() for ‘SequentialFuture’ ... done
[10:32:24.416] - resolved: TRUE
[10:32:24.416] - resolved() ... done
[10:32:24.416] resolved() for ‘SequentialFuture’ ... done
Plotting tile #3 of 4 ...
[10:32:24.417] signalConditions() ...
[10:32:24.417]  - include = ‘immediateCondition’
[10:32:24.417]  - exclude = 
[10:32:24.417]  - resignal = FALSE
[10:32:24.417]  - Number of conditions: 2
[10:32:24.417] signalConditions() ... done
[10:32:24.417] Future state: ‘finished’
[10:32:24.417] signalConditions() ...
[10:32:24.417]  - include = ‘condition’
[10:32:24.417]  - exclude = ‘immediateCondition’
[10:32:24.418]  - resignal = TRUE
[10:32:24.418]  - Number of conditions: 2
[10:32:24.418]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #3 of 4 ...[10:32:24.418]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[10:32:24.418] signalConditions() ... done
[10:32:24.419] resolved() for ‘Future’ ...
[10:32:24.419] - state: ‘created’
[10:32:24.419] - run: TRUE
[10:32:24.419] - run() ...
[10:32:24.419] run() for ‘Future’ ...
[10:32:24.419] - state: ‘created’
[10:32:24.419] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:32:24.419] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:32:24.419] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:32:24.420]   - Field: ‘label’
[10:32:24.420]   - Field: ‘local’
[10:32:24.420]   - Field: ‘owner’
[10:32:24.420]   - Field: ‘envir’
[10:32:24.420]   - Field: ‘packages’
[10:32:24.420]   - Field: ‘gc’
[10:32:24.420]   - Field: ‘conditions’
[10:32:24.420]   - Field: ‘expr’
[10:32:24.420]   - Field: ‘uuid’
[10:32:24.420]   - Field: ‘seed’
[10:32:24.421]   - Field: ‘version’
[10:32:24.421]   - Field: ‘result’
[10:32:24.421]   - Field: ‘asynchronous’
[10:32:24.421]   - Field: ‘calls’
[10:32:24.421]   - Field: ‘globals’
[10:32:24.421]   - Field: ‘stdout’
[10:32:24.421]   - Field: ‘earlySignal’
[10:32:24.421]   - Field: ‘lazy’
[10:32:24.421]   - Field: ‘state’
[10:32:24.421] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:32:24.422] - Launch lazy future ...
[10:32:24.422] Packages needed by the future expression (n = 1): ‘future’
[10:32:24.422] Packages needed by future strategies (n = 0): <none>
[10:32:24.422] {
[10:32:24.422]     {
[10:32:24.422]         {
[10:32:24.422]             ...future.startTime <- base::Sys.time()
[10:32:24.422]             {
[10:32:24.422]                 {
[10:32:24.422]                   {
[10:32:24.422]                     {
[10:32:24.422]                       base::local({
[10:32:24.422]                         has_future <- base::requireNamespace("future", 
[10:32:24.422]                           quietly = TRUE)
[10:32:24.422]                         if (has_future) {
[10:32:24.422]                           ns <- base::getNamespace("future")
[10:32:24.422]                           version <- ns[[".package"]][["version"]]
[10:32:24.422]                           if (is.null(version)) 
[10:32:24.422]                             version <- utils::packageVersion("future")
[10:32:24.422]                         }
[10:32:24.422]                         else {
[10:32:24.422]                           version <- NULL
[10:32:24.422]                         }
[10:32:24.422]                         if (!has_future || version < "1.8.0") {
[10:32:24.422]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:24.422]                             "", base::R.version$version.string), 
[10:32:24.422]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:24.422]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:24.422]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:24.422]                               "release", "version")], collapse = " "), 
[10:32:24.422]                             hostname = base::Sys.info()[["nodename"]])
[10:32:24.422]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:24.422]                             info)
[10:32:24.422]                           info <- base::paste(info, collapse = "; ")
[10:32:24.422]                           if (!has_future) {
[10:32:24.422]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:24.422]                               info)
[10:32:24.422]                           }
[10:32:24.422]                           else {
[10:32:24.422]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:24.422]                               info, version)
[10:32:24.422]                           }
[10:32:24.422]                           base::stop(msg)
[10:32:24.422]                         }
[10:32:24.422]                       })
[10:32:24.422]                     }
[10:32:24.422]                     base::local({
[10:32:24.422]                       for (pkg in "future") {
[10:32:24.422]                         base::loadNamespace(pkg)
[10:32:24.422]                         base::library(pkg, character.only = TRUE)
[10:32:24.422]                       }
[10:32:24.422]                     })
[10:32:24.422]                   }
[10:32:24.422]                   ...future.strategy.old <- future::plan("list")
[10:32:24.422]                   options(future.plan = NULL)
[10:32:24.422]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:24.422]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:24.422]                 }
[10:32:24.422]                 ...future.workdir <- getwd()
[10:32:24.422]             }
[10:32:24.422]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:24.422]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:24.422]         }
[10:32:24.422]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:24.422]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:24.422]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:24.422]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:24.422]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:24.422]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:24.422]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:24.422]             base::names(...future.oldOptions))
[10:32:24.422]     }
[10:32:24.422]     if (FALSE) {
[10:32:24.422]     }
[10:32:24.422]     else {
[10:32:24.422]         if (TRUE) {
[10:32:24.422]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:24.422]                 open = "w")
[10:32:24.422]         }
[10:32:24.422]         else {
[10:32:24.422]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:24.422]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:24.422]         }
[10:32:24.422]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:24.422]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:24.422]             base::sink(type = "output", split = FALSE)
[10:32:24.422]             base::close(...future.stdout)
[10:32:24.422]         }, add = TRUE)
[10:32:24.422]     }
[10:32:24.422]     ...future.frame <- base::sys.nframe()
[10:32:24.422]     ...future.conditions <- base::list()
[10:32:24.422]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:24.422]     if (FALSE) {
[10:32:24.422]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:24.422]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:24.422]     }
[10:32:24.422]     ...future.result <- base::tryCatch({
[10:32:24.422]         base::withCallingHandlers({
[10:32:24.422]             ...future.value <- base::withVisible(base::local({
[10:32:24.422]                 message(sprintf("Calculating tile #%d of %d ...", 
[10:32:24.422]                   ii, n), appendLF = FALSE)
[10:32:24.422]                 fit <- mandelbrot(C)
[10:32:24.422]                 delay(fit)
[10:32:24.422]                 message(" done")
[10:32:24.422]                 fit
[10:32:24.422]             }))
[10:32:24.422]             future::FutureResult(value = ...future.value$value, 
[10:32:24.422]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:24.422]                   ...future.rng), globalenv = if (FALSE) 
[10:32:24.422]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:24.422]                     ...future.globalenv.names))
[10:32:24.422]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:24.422]         }, condition = base::local({
[10:32:24.422]             c <- base::c
[10:32:24.422]             inherits <- base::inherits
[10:32:24.422]             invokeRestart <- base::invokeRestart
[10:32:24.422]             length <- base::length
[10:32:24.422]             list <- base::list
[10:32:24.422]             seq.int <- base::seq.int
[10:32:24.422]             signalCondition <- base::signalCondition
[10:32:24.422]             sys.calls <- base::sys.calls
[10:32:24.422]             `[[` <- base::`[[`
[10:32:24.422]             `+` <- base::`+`
[10:32:24.422]             `<<-` <- base::`<<-`
[10:32:24.422]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:24.422]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:24.422]                   3L)]
[10:32:24.422]             }
[10:32:24.422]             function(cond) {
[10:32:24.422]                 is_error <- inherits(cond, "error")
[10:32:24.422]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:24.422]                   NULL)
[10:32:24.422]                 if (is_error) {
[10:32:24.422]                   sessionInformation <- function() {
[10:32:24.422]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:24.422]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:24.422]                       search = base::search(), system = base::Sys.info())
[10:32:24.422]                   }
[10:32:24.422]                   ...future.conditions[[length(...future.conditions) + 
[10:32:24.422]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:24.422]                     cond$call), session = sessionInformation(), 
[10:32:24.422]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:24.422]                   signalCondition(cond)
[10:32:24.422]                 }
[10:32:24.422]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:24.422]                 "immediateCondition"))) {
[10:32:24.422]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:24.422]                   ...future.conditions[[length(...future.conditions) + 
[10:32:24.422]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:24.422]                   if (TRUE && !signal) {
[10:32:24.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:24.422]                     {
[10:32:24.422]                       inherits <- base::inherits
[10:32:24.422]                       invokeRestart <- base::invokeRestart
[10:32:24.422]                       is.null <- base::is.null
[10:32:24.422]                       muffled <- FALSE
[10:32:24.422]                       if (inherits(cond, "message")) {
[10:32:24.422]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:24.422]                         if (muffled) 
[10:32:24.422]                           invokeRestart("muffleMessage")
[10:32:24.422]                       }
[10:32:24.422]                       else if (inherits(cond, "warning")) {
[10:32:24.422]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:24.422]                         if (muffled) 
[10:32:24.422]                           invokeRestart("muffleWarning")
[10:32:24.422]                       }
[10:32:24.422]                       else if (inherits(cond, "condition")) {
[10:32:24.422]                         if (!is.null(pattern)) {
[10:32:24.422]                           computeRestarts <- base::computeRestarts
[10:32:24.422]                           grepl <- base::grepl
[10:32:24.422]                           restarts <- computeRestarts(cond)
[10:32:24.422]                           for (restart in restarts) {
[10:32:24.422]                             name <- restart$name
[10:32:24.422]                             if (is.null(name)) 
[10:32:24.422]                               next
[10:32:24.422]                             if (!grepl(pattern, name)) 
[10:32:24.422]                               next
[10:32:24.422]                             invokeRestart(restart)
[10:32:24.422]                             muffled <- TRUE
[10:32:24.422]                             break
[10:32:24.422]                           }
[10:32:24.422]                         }
[10:32:24.422]                       }
[10:32:24.422]                       invisible(muffled)
[10:32:24.422]                     }
[10:32:24.422]                     muffleCondition(cond, pattern = "^muffle")
[10:32:24.422]                   }
[10:32:24.422]                 }
[10:32:24.422]                 else {
[10:32:24.422]                   if (TRUE) {
[10:32:24.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:24.422]                     {
[10:32:24.422]                       inherits <- base::inherits
[10:32:24.422]                       invokeRestart <- base::invokeRestart
[10:32:24.422]                       is.null <- base::is.null
[10:32:24.422]                       muffled <- FALSE
[10:32:24.422]                       if (inherits(cond, "message")) {
[10:32:24.422]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:24.422]                         if (muffled) 
[10:32:24.422]                           invokeRestart("muffleMessage")
[10:32:24.422]                       }
[10:32:24.422]                       else if (inherits(cond, "warning")) {
[10:32:24.422]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:24.422]                         if (muffled) 
[10:32:24.422]                           invokeRestart("muffleWarning")
[10:32:24.422]                       }
[10:32:24.422]                       else if (inherits(cond, "condition")) {
[10:32:24.422]                         if (!is.null(pattern)) {
[10:32:24.422]                           computeRestarts <- base::computeRestarts
[10:32:24.422]                           grepl <- base::grepl
[10:32:24.422]                           restarts <- computeRestarts(cond)
[10:32:24.422]                           for (restart in restarts) {
[10:32:24.422]                             name <- restart$name
[10:32:24.422]                             if (is.null(name)) 
[10:32:24.422]                               next
[10:32:24.422]                             if (!grepl(pattern, name)) 
[10:32:24.422]                               next
[10:32:24.422]                             invokeRestart(restart)
[10:32:24.422]                             muffled <- TRUE
[10:32:24.422]                             break
[10:32:24.422]                           }
[10:32:24.422]                         }
[10:32:24.422]                       }
[10:32:24.422]                       invisible(muffled)
[10:32:24.422]                     }
[10:32:24.422]                     muffleCondition(cond, pattern = "^muffle")
[10:32:24.422]                   }
[10:32:24.422]                 }
[10:32:24.422]             }
[10:32:24.422]         }))
[10:32:24.422]     }, error = function(ex) {
[10:32:24.422]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:24.422]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:24.422]                 ...future.rng), started = ...future.startTime, 
[10:32:24.422]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:24.422]             version = "1.8"), class = "FutureResult")
[10:32:24.422]     }, finally = {
[10:32:24.422]         if (!identical(...future.workdir, getwd())) 
[10:32:24.422]             setwd(...future.workdir)
[10:32:24.422]         {
[10:32:24.422]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:24.422]                 ...future.oldOptions$nwarnings <- NULL
[10:32:24.422]             }
[10:32:24.422]             base::options(...future.oldOptions)
[10:32:24.422]             if (.Platform$OS.type == "windows") {
[10:32:24.422]                 old_names <- names(...future.oldEnvVars)
[10:32:24.422]                 envs <- base::Sys.getenv()
[10:32:24.422]                 names <- names(envs)
[10:32:24.422]                 common <- intersect(names, old_names)
[10:32:24.422]                 added <- setdiff(names, old_names)
[10:32:24.422]                 removed <- setdiff(old_names, names)
[10:32:24.422]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:24.422]                   envs[common]]
[10:32:24.422]                 NAMES <- toupper(changed)
[10:32:24.422]                 args <- list()
[10:32:24.422]                 for (kk in seq_along(NAMES)) {
[10:32:24.422]                   name <- changed[[kk]]
[10:32:24.422]                   NAME <- NAMES[[kk]]
[10:32:24.422]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:24.422]                     next
[10:32:24.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:24.422]                 }
[10:32:24.422]                 NAMES <- toupper(added)
[10:32:24.422]                 for (kk in seq_along(NAMES)) {
[10:32:24.422]                   name <- added[[kk]]
[10:32:24.422]                   NAME <- NAMES[[kk]]
[10:32:24.422]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:24.422]                     next
[10:32:24.422]                   args[[name]] <- ""
[10:32:24.422]                 }
[10:32:24.422]                 NAMES <- toupper(removed)
[10:32:24.422]                 for (kk in seq_along(NAMES)) {
[10:32:24.422]                   name <- removed[[kk]]
[10:32:24.422]                   NAME <- NAMES[[kk]]
[10:32:24.422]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:24.422]                     next
[10:32:24.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:24.422]                 }
[10:32:24.422]                 if (length(args) > 0) 
[10:32:24.422]                   base::do.call(base::Sys.setenv, args = args)
[10:32:24.422]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:24.422]             }
[10:32:24.422]             else {
[10:32:24.422]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:24.422]             }
[10:32:24.422]             {
[10:32:24.422]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:24.422]                   0L) {
[10:32:24.422]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:24.422]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:24.422]                   base::options(opts)
[10:32:24.422]                 }
[10:32:24.422]                 {
[10:32:24.422]                   {
[10:32:24.422]                     NULL
[10:32:24.422]                     RNGkind("Mersenne-Twister")
[10:32:24.422]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:32:24.422]                       inherits = FALSE)
[10:32:24.422]                   }
[10:32:24.422]                   options(future.plan = NULL)
[10:32:24.422]                   if (is.na(NA_character_)) 
[10:32:24.422]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:24.422]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:24.422]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:24.422]                     .init = FALSE)
[10:32:24.422]                 }
[10:32:24.422]             }
[10:32:24.422]         }
[10:32:24.422]     })
[10:32:24.422]     if (TRUE) {
[10:32:24.422]         base::sink(type = "output", split = FALSE)
[10:32:24.422]         if (TRUE) {
[10:32:24.422]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:24.422]         }
[10:32:24.422]         else {
[10:32:24.422]             ...future.result["stdout"] <- base::list(NULL)
[10:32:24.422]         }
[10:32:24.422]         base::close(...future.stdout)
[10:32:24.422]         ...future.stdout <- NULL
[10:32:24.422]     }
[10:32:24.422]     ...future.result$conditions <- ...future.conditions
[10:32:24.422]     ...future.result$finished <- base::Sys.time()
[10:32:24.422]     ...future.result
[10:32:24.422] }
[10:32:24.424] assign_globals() ...
[10:32:24.424] List of 4
[10:32:24.424]  $ ii   : int 4
[10:32:24.424]  $ n    : int 4
[10:32:24.424]  $ C    : cplx [1:25, 1:25] -0.719+0.031i -0.719+0.092i -0.719+0.153i ...
[10:32:24.424]   ..- attr(*, "region")=List of 2
[10:32:24.424]   .. ..$ xrange: num [1:2] -0.719 0.75
[10:32:24.424]   .. ..$ yrange: num [1:2] 0.0306 1.5
[10:32:24.424]   ..- attr(*, "tile")= int [1:2] 2 2
[10:32:24.424]  $ delay:function (counts)  
[10:32:24.424]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[10:32:24.424]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x5583e3e3a818> 
[10:32:24.424]  - attr(*, "where")=List of 4
[10:32:24.424]   ..$ ii   :<environment: R_EmptyEnv> 
[10:32:24.424]   ..$ n    :<environment: R_EmptyEnv> 
[10:32:24.424]   ..$ C    :<environment: R_EmptyEnv> 
[10:32:24.424]   ..$ delay:<environment: R_EmptyEnv> 
[10:32:24.424]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:24.424]  - attr(*, "resolved")= logi FALSE
[10:32:24.424]  - attr(*, "total_size")= num 14584
[10:32:24.424]  - attr(*, "already-done")= logi TRUE
[10:32:24.430] - copied ‘ii’ to environment
[10:32:24.430] - copied ‘n’ to environment
[10:32:24.430] - copied ‘C’ to environment
[10:32:24.430] - reassign environment for ‘delay’
[10:32:24.430] - copied ‘delay’ to environment
[10:32:24.430] assign_globals() ... done
[10:32:24.431] plan(): Setting new future strategy stack:
[10:32:24.431] List of future strategies:
[10:32:24.431] 1. sequential:
[10:32:24.431]    - args: function (..., envir = parent.frame())
[10:32:24.431]    - tweaked: FALSE
[10:32:24.431]    - call: NULL
[10:32:24.431] plan(): nbrOfWorkers() = 1
[10:32:24.445] plan(): Setting new future strategy stack:
[10:32:24.445] List of future strategies:
[10:32:24.445] 1. sequential:
[10:32:24.445]    - args: function (..., envir = parent.frame())
[10:32:24.445]    - tweaked: FALSE
[10:32:24.445]    - call: plan(strategy)
[10:32:24.446] plan(): nbrOfWorkers() = 1
[10:32:24.446] SequentialFuture started (and completed)
[10:32:24.446] signalConditions() ...
[10:32:24.446]  - include = ‘immediateCondition’
[10:32:24.446]  - exclude = 
[10:32:24.446]  - resignal = FALSE
[10:32:24.446]  - Number of conditions: 2
[10:32:24.446] signalConditions() ... done
[10:32:24.447] - Launch lazy future ... done
[10:32:24.447] run() for ‘SequentialFuture’ ... done
[10:32:24.447] - run() ... done
[10:32:24.447] - resolved() ...
[10:32:24.447] resolved() for ‘SequentialFuture’ ...
[10:32:24.447] - state: ‘finished’
[10:32:24.447] - run: TRUE
[10:32:24.447] - result: ‘FutureResult’
[10:32:24.447] resolved() for ‘SequentialFuture’ ... done
[10:32:24.447] - resolved: TRUE
[10:32:24.447] - resolved() ... done
[10:32:24.448] resolved() for ‘SequentialFuture’ ... done
Plotting tile #4 of 4 ...
[10:32:24.448] signalConditions() ...
[10:32:24.448]  - include = ‘immediateCondition’
[10:32:24.448]  - exclude = 
[10:32:24.448]  - resignal = FALSE
[10:32:24.448]  - Number of conditions: 2
[10:32:24.448] signalConditions() ... done
[10:32:24.448] Future state: ‘finished’
[10:32:24.448] signalConditions() ...
[10:32:24.448]  - include = ‘condition’
[10:32:24.449]  - exclude = ‘immediateCondition’
[10:32:24.449]  - resignal = TRUE
[10:32:24.449]  - Number of conditions: 2
[10:32:24.449]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #4 of 4 ...[10:32:24.449]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[10:32:24.449] signalConditions() ... done

> close.screen()
[1] 1 2 3 4

> message("SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).\n")
SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).

- plan('sequential') ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
- plan('multicore') ...
[10:32:24.455] plan(): Setting new future strategy stack:
[10:32:24.455] List of future strategies:
[10:32:24.455] 1. multicore:
[10:32:24.455]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:24.455]    - tweaked: FALSE
[10:32:24.455]    - call: plan(strategy)
[10:32:24.459] plan(): nbrOfWorkers() = 2


	demo(mandelbrot)
	---- ~~~~~~~~~~

> library("future")

> library("graphics")

> plot_what_is_done <- function(counts) {
+   for (kk in seq_along(counts)) {
+     f <- counts[[kk]]
+ 
+     ## Already plotted?
+     if (!inherits(f, "Future")) next
+ 
+     ## Not resolved?
+     if (!resolved(f)) next
+ 
+     message(sprintf("Plotting tile #%d of %d ...", kk, n))
+     counts[[kk]] <- value(f)
+     screen(kk)
+     plot(counts[[kk]])
+   }
+ 
+   counts
+ }

> ## Options
> region <- getOption("future.demo.mandelbrot.region", 1L)

> if (!is.list(region)) {
+   if (region == 1L) {
+     region <- list(xmid = -0.75, ymid = 0.0, side = 3.0)
+   } else if (region == 2L) {
+     region <- list(xmid = 0.283, ymid = -0.0095, side = 0.00026)
+   } else if (region == 3L) {
+     region <- list(xmid = 0.282989, ymid = -0.01, side = 3e-8)
+   }
+ }

> nrow <- getOption("future.demo.mandelbrot.nrow", 3L)

> resolution <- getOption("future.demo.mandelbrot.resolution", 400L)

> delay <- getOption("future.demo.mandelbrot.delay", interactive())

> if (isTRUE(delay)) {
+   delay <- function(counts) Sys.sleep(1.0)
+ } else if (!is.function(delay)) {
+   delay <- function(counts) {}
+ }

> ## Generate Mandelbrot tiles to be computed
> Cs <- mandelbrot_tiles(xmid = region$xmid, ymid = region$ymid,
+                        side = region$side, nrow = nrow,
+                        resolution = resolution)

> if (interactive()) {
+   dev.new()
+   plot.new()
+   split.screen(dim(Cs))
+   for (ii in seq_along(Cs)) {
+     screen(ii)
+     par(mar = c(0, 0, 0, 0))
+     text(x = 1 / 2, y = 1 / 2, sprintf("Future #%d\nunresolved", ii), cex = 2)
+   }
+ } else {
+   split.screen(dim(Cs))
+ }
[1] 5 6 7 8

> ## Create all Mandelbrot tiles via lazy futures
> n <- length(Cs)

> message(sprintf("Creating %d Mandelbrot tiles:", n), appendLF = FALSE)
Creating 4 Mandelbrot tiles:
> counts <- lapply(seq_along(Cs), FUN=function(ii) {
+   message(" ", ii, appendLF = FALSE)
+   C <- Cs[[ii]]
+   future({
+     message(sprintf("Calculating tile #%d of %d ...", ii, n), appendLF = FALSE)
+     fit <- mandelbrot(C)
+ 
+     ## Emulate slowness
+     delay(fit)
+ 
+     message(" done")
+     fit
+   }, lazy = TRUE)
+ })
 1[10:32:24.463] getGlobalsAndPackages() ...
[10:32:24.463] Searching for globals...
[10:32:24.468] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[10:32:24.468] Searching for globals ... DONE
[10:32:24.469] Resolving globals: FALSE
[10:32:24.469] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[10:32:24.470] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:32:24.470] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[10:32:24.470] - packages: [1] ‘future’
[10:32:24.470] getGlobalsAndPackages() ... DONE
 2[10:32:24.474] getGlobalsAndPackages() ...
[10:32:24.474] Searching for globals...
[10:32:24.477] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[10:32:24.477] Searching for globals ... DONE
[10:32:24.477] Resolving globals: FALSE
[10:32:24.478] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[10:32:24.478] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:32:24.478] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[10:32:24.478] - packages: [1] ‘future’
[10:32:24.479] getGlobalsAndPackages() ... DONE
 3[10:32:24.479] getGlobalsAndPackages() ...
[10:32:24.479] Searching for globals...
[10:32:24.482] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[10:32:24.482] Searching for globals ... DONE
[10:32:24.483] Resolving globals: FALSE
[10:32:24.483] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[10:32:24.483] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:32:24.484] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[10:32:24.484] - packages: [1] ‘future’
[10:32:24.484] getGlobalsAndPackages() ... DONE
 4[10:32:24.484] getGlobalsAndPackages() ...
[10:32:24.484] Searching for globals...
[10:32:24.487] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[10:32:24.488] Searching for globals ... DONE
[10:32:24.488] Resolving globals: FALSE
[10:32:24.488] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[10:32:24.489] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:32:24.489] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[10:32:24.489] - packages: [1] ‘future’
[10:32:24.489] getGlobalsAndPackages() ... DONE

> message(".")
.

> ## Calculate and plot tiles
> repeat {
+   counts <- plot_what_is_done(counts)
+   if (!any(sapply(counts, FUN = inherits, "Future"))) break
+ }
[10:32:24.498] resolved() for ‘Future’ ...
[10:32:24.498] - state: ‘created’
[10:32:24.498] - run: TRUE
[10:32:24.498] - run() ...
[10:32:24.498] run() for ‘Future’ ...
[10:32:24.498] - state: ‘created’
[10:32:24.498] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:24.503] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:24.503] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:24.503]   - Field: ‘label’
[10:32:24.503]   - Field: ‘local’
[10:32:24.503]   - Field: ‘owner’
[10:32:24.504]   - Field: ‘envir’
[10:32:24.504]   - Field: ‘workers’
[10:32:24.504]   - Field: ‘packages’
[10:32:24.504]   - Field: ‘gc’
[10:32:24.504]   - Field: ‘job’
[10:32:24.504]   - Field: ‘conditions’
[10:32:24.504]   - Field: ‘expr’
[10:32:24.505]   - Field: ‘uuid’
[10:32:24.505]   - Field: ‘seed’
[10:32:24.505]   - Field: ‘version’
[10:32:24.505]   - Field: ‘result’
[10:32:24.505]   - Field: ‘asynchronous’
[10:32:24.505]   - Field: ‘calls’
[10:32:24.506]   - Field: ‘globals’
[10:32:24.506]   - Field: ‘stdout’
[10:32:24.506]   - Field: ‘earlySignal’
[10:32:24.506]   - Field: ‘lazy’
[10:32:24.506]   - Field: ‘state’
[10:32:24.506] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:24.507] - Launch lazy future ...
[10:32:24.508] Packages needed by the future expression (n = 1): ‘future’
[10:32:24.508] Packages needed by future strategies (n = 0): <none>
[10:32:24.509] {
[10:32:24.509]     {
[10:32:24.509]         {
[10:32:24.509]             ...future.startTime <- base::Sys.time()
[10:32:24.509]             {
[10:32:24.509]                 {
[10:32:24.509]                   {
[10:32:24.509]                     {
[10:32:24.509]                       {
[10:32:24.509]                         base::local({
[10:32:24.509]                           has_future <- base::requireNamespace("future", 
[10:32:24.509]                             quietly = TRUE)
[10:32:24.509]                           if (has_future) {
[10:32:24.509]                             ns <- base::getNamespace("future")
[10:32:24.509]                             version <- ns[[".package"]][["version"]]
[10:32:24.509]                             if (is.null(version)) 
[10:32:24.509]                               version <- utils::packageVersion("future")
[10:32:24.509]                           }
[10:32:24.509]                           else {
[10:32:24.509]                             version <- NULL
[10:32:24.509]                           }
[10:32:24.509]                           if (!has_future || version < "1.8.0") {
[10:32:24.509]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:24.509]                               "", base::R.version$version.string), 
[10:32:24.509]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:24.509]                                 base::R.version$platform, 8 * 
[10:32:24.509]                                   base::.Machine$sizeof.pointer), 
[10:32:24.509]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:24.509]                                 "release", "version")], collapse = " "), 
[10:32:24.509]                               hostname = base::Sys.info()[["nodename"]])
[10:32:24.509]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:24.509]                               info)
[10:32:24.509]                             info <- base::paste(info, collapse = "; ")
[10:32:24.509]                             if (!has_future) {
[10:32:24.509]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:24.509]                                 info)
[10:32:24.509]                             }
[10:32:24.509]                             else {
[10:32:24.509]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:24.509]                                 info, version)
[10:32:24.509]                             }
[10:32:24.509]                             base::stop(msg)
[10:32:24.509]                           }
[10:32:24.509]                         })
[10:32:24.509]                       }
[10:32:24.509]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:24.509]                       base::options(mc.cores = 1L)
[10:32:24.509]                     }
[10:32:24.509]                     base::local({
[10:32:24.509]                       for (pkg in "future") {
[10:32:24.509]                         base::loadNamespace(pkg)
[10:32:24.509]                         base::library(pkg, character.only = TRUE)
[10:32:24.509]                       }
[10:32:24.509]                     })
[10:32:24.509]                   }
[10:32:24.509]                   ...future.strategy.old <- future::plan("list")
[10:32:24.509]                   options(future.plan = NULL)
[10:32:24.509]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:24.509]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:24.509]                 }
[10:32:24.509]                 ...future.workdir <- getwd()
[10:32:24.509]             }
[10:32:24.509]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:24.509]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:24.509]         }
[10:32:24.509]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:24.509]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:24.509]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:24.509]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:24.509]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:24.509]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:24.509]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:24.509]             base::names(...future.oldOptions))
[10:32:24.509]     }
[10:32:24.509]     if (FALSE) {
[10:32:24.509]     }
[10:32:24.509]     else {
[10:32:24.509]         if (TRUE) {
[10:32:24.509]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:24.509]                 open = "w")
[10:32:24.509]         }
[10:32:24.509]         else {
[10:32:24.509]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:24.509]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:24.509]         }
[10:32:24.509]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:24.509]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:24.509]             base::sink(type = "output", split = FALSE)
[10:32:24.509]             base::close(...future.stdout)
[10:32:24.509]         }, add = TRUE)
[10:32:24.509]     }
[10:32:24.509]     ...future.frame <- base::sys.nframe()
[10:32:24.509]     ...future.conditions <- base::list()
[10:32:24.509]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:24.509]     if (FALSE) {
[10:32:24.509]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:24.509]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:24.509]     }
[10:32:24.509]     ...future.result <- base::tryCatch({
[10:32:24.509]         base::withCallingHandlers({
[10:32:24.509]             ...future.value <- base::withVisible(base::local({
[10:32:24.509]                 withCallingHandlers({
[10:32:24.509]                   {
[10:32:24.509]                     message(sprintf("Calculating tile #%d of %d ...", 
[10:32:24.509]                       ii, n), appendLF = FALSE)
[10:32:24.509]                     fit <- mandelbrot(C)
[10:32:24.509]                     delay(fit)
[10:32:24.509]                     message(" done")
[10:32:24.509]                     fit
[10:32:24.509]                   }
[10:32:24.509]                 }, immediateCondition = function(cond) {
[10:32:24.509]                   save_rds <- function (object, pathname, ...) 
[10:32:24.509]                   {
[10:32:24.509]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:24.509]                     if (file_test("-f", pathname_tmp)) {
[10:32:24.509]                       fi_tmp <- file.info(pathname_tmp)
[10:32:24.509]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:24.509]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:24.509]                         fi_tmp[["mtime"]])
[10:32:24.509]                     }
[10:32:24.509]                     tryCatch({
[10:32:24.509]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:24.509]                     }, error = function(ex) {
[10:32:24.509]                       msg <- conditionMessage(ex)
[10:32:24.509]                       fi_tmp <- file.info(pathname_tmp)
[10:32:24.509]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:24.509]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:24.509]                         fi_tmp[["mtime"]], msg)
[10:32:24.509]                       ex$message <- msg
[10:32:24.509]                       stop(ex)
[10:32:24.509]                     })
[10:32:24.509]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:24.509]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:24.509]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:24.509]                       fi_tmp <- file.info(pathname_tmp)
[10:32:24.509]                       fi <- file.info(pathname)
[10:32:24.509]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:24.509]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:24.509]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:24.509]                         fi[["size"]], fi[["mtime"]])
[10:32:24.509]                       stop(msg)
[10:32:24.509]                     }
[10:32:24.509]                     invisible(pathname)
[10:32:24.509]                   }
[10:32:24.509]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:24.509]                     rootPath = tempdir()) 
[10:32:24.509]                   {
[10:32:24.509]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:24.509]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:24.509]                       tmpdir = path, fileext = ".rds")
[10:32:24.509]                     save_rds(obj, file)
[10:32:24.509]                   }
[10:32:24.509]                   saveImmediateCondition(cond, path = "/tmp/RtmpIGdrVQ/.future/immediateConditions")
[10:32:24.509]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:24.509]                   {
[10:32:24.509]                     inherits <- base::inherits
[10:32:24.509]                     invokeRestart <- base::invokeRestart
[10:32:24.509]                     is.null <- base::is.null
[10:32:24.509]                     muffled <- FALSE
[10:32:24.509]                     if (inherits(cond, "message")) {
[10:32:24.509]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:24.509]                       if (muffled) 
[10:32:24.509]                         invokeRestart("muffleMessage")
[10:32:24.509]                     }
[10:32:24.509]                     else if (inherits(cond, "warning")) {
[10:32:24.509]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:24.509]                       if (muffled) 
[10:32:24.509]                         invokeRestart("muffleWarning")
[10:32:24.509]                     }
[10:32:24.509]                     else if (inherits(cond, "condition")) {
[10:32:24.509]                       if (!is.null(pattern)) {
[10:32:24.509]                         computeRestarts <- base::computeRestarts
[10:32:24.509]                         grepl <- base::grepl
[10:32:24.509]                         restarts <- computeRestarts(cond)
[10:32:24.509]                         for (restart in restarts) {
[10:32:24.509]                           name <- restart$name
[10:32:24.509]                           if (is.null(name)) 
[10:32:24.509]                             next
[10:32:24.509]                           if (!grepl(pattern, name)) 
[10:32:24.509]                             next
[10:32:24.509]                           invokeRestart(restart)
[10:32:24.509]                           muffled <- TRUE
[10:32:24.509]                           break
[10:32:24.509]                         }
[10:32:24.509]                       }
[10:32:24.509]                     }
[10:32:24.509]                     invisible(muffled)
[10:32:24.509]                   }
[10:32:24.509]                   muffleCondition(cond)
[10:32:24.509]                 })
[10:32:24.509]             }))
[10:32:24.509]             future::FutureResult(value = ...future.value$value, 
[10:32:24.509]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:24.509]                   ...future.rng), globalenv = if (FALSE) 
[10:32:24.509]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:24.509]                     ...future.globalenv.names))
[10:32:24.509]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:24.509]         }, condition = base::local({
[10:32:24.509]             c <- base::c
[10:32:24.509]             inherits <- base::inherits
[10:32:24.509]             invokeRestart <- base::invokeRestart
[10:32:24.509]             length <- base::length
[10:32:24.509]             list <- base::list
[10:32:24.509]             seq.int <- base::seq.int
[10:32:24.509]             signalCondition <- base::signalCondition
[10:32:24.509]             sys.calls <- base::sys.calls
[10:32:24.509]             `[[` <- base::`[[`
[10:32:24.509]             `+` <- base::`+`
[10:32:24.509]             `<<-` <- base::`<<-`
[10:32:24.509]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:24.509]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:24.509]                   3L)]
[10:32:24.509]             }
[10:32:24.509]             function(cond) {
[10:32:24.509]                 is_error <- inherits(cond, "error")
[10:32:24.509]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:24.509]                   NULL)
[10:32:24.509]                 if (is_error) {
[10:32:24.509]                   sessionInformation <- function() {
[10:32:24.509]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:24.509]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:24.509]                       search = base::search(), system = base::Sys.info())
[10:32:24.509]                   }
[10:32:24.509]                   ...future.conditions[[length(...future.conditions) + 
[10:32:24.509]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:24.509]                     cond$call), session = sessionInformation(), 
[10:32:24.509]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:24.509]                   signalCondition(cond)
[10:32:24.509]                 }
[10:32:24.509]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:24.509]                 "immediateCondition"))) {
[10:32:24.509]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:24.509]                   ...future.conditions[[length(...future.conditions) + 
[10:32:24.509]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:24.509]                   if (TRUE && !signal) {
[10:32:24.509]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:24.509]                     {
[10:32:24.509]                       inherits <- base::inherits
[10:32:24.509]                       invokeRestart <- base::invokeRestart
[10:32:24.509]                       is.null <- base::is.null
[10:32:24.509]                       muffled <- FALSE
[10:32:24.509]                       if (inherits(cond, "message")) {
[10:32:24.509]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:24.509]                         if (muffled) 
[10:32:24.509]                           invokeRestart("muffleMessage")
[10:32:24.509]                       }
[10:32:24.509]                       else if (inherits(cond, "warning")) {
[10:32:24.509]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:24.509]                         if (muffled) 
[10:32:24.509]                           invokeRestart("muffleWarning")
[10:32:24.509]                       }
[10:32:24.509]                       else if (inherits(cond, "condition")) {
[10:32:24.509]                         if (!is.null(pattern)) {
[10:32:24.509]                           computeRestarts <- base::computeRestarts
[10:32:24.509]                           grepl <- base::grepl
[10:32:24.509]                           restarts <- computeRestarts(cond)
[10:32:24.509]                           for (restart in restarts) {
[10:32:24.509]                             name <- restart$name
[10:32:24.509]                             if (is.null(name)) 
[10:32:24.509]                               next
[10:32:24.509]                             if (!grepl(pattern, name)) 
[10:32:24.509]                               next
[10:32:24.509]                             invokeRestart(restart)
[10:32:24.509]                             muffled <- TRUE
[10:32:24.509]                             break
[10:32:24.509]                           }
[10:32:24.509]                         }
[10:32:24.509]                       }
[10:32:24.509]                       invisible(muffled)
[10:32:24.509]                     }
[10:32:24.509]                     muffleCondition(cond, pattern = "^muffle")
[10:32:24.509]                   }
[10:32:24.509]                 }
[10:32:24.509]                 else {
[10:32:24.509]                   if (TRUE) {
[10:32:24.509]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:24.509]                     {
[10:32:24.509]                       inherits <- base::inherits
[10:32:24.509]                       invokeRestart <- base::invokeRestart
[10:32:24.509]                       is.null <- base::is.null
[10:32:24.509]                       muffled <- FALSE
[10:32:24.509]                       if (inherits(cond, "message")) {
[10:32:24.509]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:24.509]                         if (muffled) 
[10:32:24.509]                           invokeRestart("muffleMessage")
[10:32:24.509]                       }
[10:32:24.509]                       else if (inherits(cond, "warning")) {
[10:32:24.509]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:24.509]                         if (muffled) 
[10:32:24.509]                           invokeRestart("muffleWarning")
[10:32:24.509]                       }
[10:32:24.509]                       else if (inherits(cond, "condition")) {
[10:32:24.509]                         if (!is.null(pattern)) {
[10:32:24.509]                           computeRestarts <- base::computeRestarts
[10:32:24.509]                           grepl <- base::grepl
[10:32:24.509]                           restarts <- computeRestarts(cond)
[10:32:24.509]                           for (restart in restarts) {
[10:32:24.509]                             name <- restart$name
[10:32:24.509]                             if (is.null(name)) 
[10:32:24.509]                               next
[10:32:24.509]                             if (!grepl(pattern, name)) 
[10:32:24.509]                               next
[10:32:24.509]                             invokeRestart(restart)
[10:32:24.509]                             muffled <- TRUE
[10:32:24.509]                             break
[10:32:24.509]                           }
[10:32:24.509]                         }
[10:32:24.509]                       }
[10:32:24.509]                       invisible(muffled)
[10:32:24.509]                     }
[10:32:24.509]                     muffleCondition(cond, pattern = "^muffle")
[10:32:24.509]                   }
[10:32:24.509]                 }
[10:32:24.509]             }
[10:32:24.509]         }))
[10:32:24.509]     }, error = function(ex) {
[10:32:24.509]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:24.509]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:24.509]                 ...future.rng), started = ...future.startTime, 
[10:32:24.509]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:24.509]             version = "1.8"), class = "FutureResult")
[10:32:24.509]     }, finally = {
[10:32:24.509]         if (!identical(...future.workdir, getwd())) 
[10:32:24.509]             setwd(...future.workdir)
[10:32:24.509]         {
[10:32:24.509]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:24.509]                 ...future.oldOptions$nwarnings <- NULL
[10:32:24.509]             }
[10:32:24.509]             base::options(...future.oldOptions)
[10:32:24.509]             if (.Platform$OS.type == "windows") {
[10:32:24.509]                 old_names <- names(...future.oldEnvVars)
[10:32:24.509]                 envs <- base::Sys.getenv()
[10:32:24.509]                 names <- names(envs)
[10:32:24.509]                 common <- intersect(names, old_names)
[10:32:24.509]                 added <- setdiff(names, old_names)
[10:32:24.509]                 removed <- setdiff(old_names, names)
[10:32:24.509]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:24.509]                   envs[common]]
[10:32:24.509]                 NAMES <- toupper(changed)
[10:32:24.509]                 args <- list()
[10:32:24.509]                 for (kk in seq_along(NAMES)) {
[10:32:24.509]                   name <- changed[[kk]]
[10:32:24.509]                   NAME <- NAMES[[kk]]
[10:32:24.509]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:24.509]                     next
[10:32:24.509]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:24.509]                 }
[10:32:24.509]                 NAMES <- toupper(added)
[10:32:24.509]                 for (kk in seq_along(NAMES)) {
[10:32:24.509]                   name <- added[[kk]]
[10:32:24.509]                   NAME <- NAMES[[kk]]
[10:32:24.509]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:24.509]                     next
[10:32:24.509]                   args[[name]] <- ""
[10:32:24.509]                 }
[10:32:24.509]                 NAMES <- toupper(removed)
[10:32:24.509]                 for (kk in seq_along(NAMES)) {
[10:32:24.509]                   name <- removed[[kk]]
[10:32:24.509]                   NAME <- NAMES[[kk]]
[10:32:24.509]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:24.509]                     next
[10:32:24.509]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:24.509]                 }
[10:32:24.509]                 if (length(args) > 0) 
[10:32:24.509]                   base::do.call(base::Sys.setenv, args = args)
[10:32:24.509]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:24.509]             }
[10:32:24.509]             else {
[10:32:24.509]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:24.509]             }
[10:32:24.509]             {
[10:32:24.509]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:24.509]                   0L) {
[10:32:24.509]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:24.509]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:24.509]                   base::options(opts)
[10:32:24.509]                 }
[10:32:24.509]                 {
[10:32:24.509]                   {
[10:32:24.509]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:24.509]                     NULL
[10:32:24.509]                   }
[10:32:24.509]                   options(future.plan = NULL)
[10:32:24.509]                   if (is.na(NA_character_)) 
[10:32:24.509]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:24.509]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:24.509]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:24.509]                     .init = FALSE)
[10:32:24.509]                 }
[10:32:24.509]             }
[10:32:24.509]         }
[10:32:24.509]     })
[10:32:24.509]     if (TRUE) {
[10:32:24.509]         base::sink(type = "output", split = FALSE)
[10:32:24.509]         if (TRUE) {
[10:32:24.509]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:24.509]         }
[10:32:24.509]         else {
[10:32:24.509]             ...future.result["stdout"] <- base::list(NULL)
[10:32:24.509]         }
[10:32:24.509]         base::close(...future.stdout)
[10:32:24.509]         ...future.stdout <- NULL
[10:32:24.509]     }
[10:32:24.509]     ...future.result$conditions <- ...future.conditions
[10:32:24.509]     ...future.result$finished <- base::Sys.time()
[10:32:24.509]     ...future.result
[10:32:24.509] }
[10:32:24.513] assign_globals() ...
[10:32:24.513] List of 4
[10:32:24.513]  $ ii   : int 1
[10:32:24.513]  $ n    : int 4
[10:32:24.513]  $ C    : cplx [1:25, 1:25] -2.25-1.5i -2.25-1.44i -2.25-1.38i ...
[10:32:24.513]   ..- attr(*, "region")=List of 2
[10:32:24.513]   .. ..$ xrange: num [1:2] -2.25 -0.781
[10:32:24.513]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[10:32:24.513]   ..- attr(*, "tile")= int [1:2] 1 1
[10:32:24.513]  $ delay:function (counts)  
[10:32:24.513]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[10:32:24.513]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x5583e3f431c0> 
[10:32:24.513]  - attr(*, "where")=List of 4
[10:32:24.513]   ..$ ii   :<environment: R_EmptyEnv> 
[10:32:24.513]   ..$ n    :<environment: R_EmptyEnv> 
[10:32:24.513]   ..$ C    :<environment: R_EmptyEnv> 
[10:32:24.513]   ..$ delay:<environment: R_EmptyEnv> 
[10:32:24.513]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:24.513]  - attr(*, "resolved")= logi FALSE
[10:32:24.513]  - attr(*, "total_size")= num 14584
[10:32:24.513]  - attr(*, "already-done")= logi TRUE
[10:32:24.523] - copied ‘ii’ to environment
[10:32:24.523] - copied ‘n’ to environment
[10:32:24.523] - copied ‘C’ to environment
[10:32:24.524] - reassign environment for ‘delay’
[10:32:24.524] - copied ‘delay’ to environment
[10:32:24.524] assign_globals() ... done
[10:32:24.524] requestCore(): workers = 2
[10:32:24.528] MulticoreFuture started
[10:32:24.528] - Launch lazy future ... done
[10:32:24.528] run() for ‘MulticoreFuture’ ... done
[10:32:24.529] - run() ... done
[10:32:24.529] - resolved() ...
[10:32:24.529] plan(): Setting new future strategy stack:
[10:32:24.529] List of future strategies:
[10:32:24.529] 1. sequential:
[10:32:24.529]    - args: function (..., envir = parent.frame())
[10:32:24.529]    - tweaked: FALSE
[10:32:24.529]    - call: NULL
[10:32:24.530] plan(): nbrOfWorkers() = 1
[10:32:24.533] plan(): Setting new future strategy stack:
[10:32:24.534] List of future strategies:
[10:32:24.534] 1. multicore:
[10:32:24.534]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:24.534]    - tweaked: FALSE
[10:32:24.534]    - call: plan(strategy)
[10:32:24.539] plan(): nbrOfWorkers() = 2
[10:32:24.540] - resolved: TRUE
[10:32:24.541] - resolved() ... done
[10:32:24.541] resolved() for ‘MulticoreFuture’ ... done
Plotting tile #1 of 4 ...
[10:32:24.542] result() for MulticoreFuture ...
[10:32:24.546] result() for MulticoreFuture ...
[10:32:24.547] result() for MulticoreFuture ... done
[10:32:24.547] signalConditions() ...
[10:32:24.547]  - include = ‘immediateCondition’
[10:32:24.547]  - exclude = 
[10:32:24.547]  - resignal = FALSE
[10:32:24.547]  - Number of conditions: 2
[10:32:24.547] signalConditions() ... done
[10:32:24.547] result() for MulticoreFuture ... done
[10:32:24.548] result() for MulticoreFuture ...
[10:32:24.548] result() for MulticoreFuture ... done
[10:32:24.548] signalConditions() ...
[10:32:24.548]  - include = ‘immediateCondition’
[10:32:24.548]  - exclude = 
[10:32:24.548]  - resignal = FALSE
[10:32:24.548]  - Number of conditions: 2
[10:32:24.548] signalConditions() ... done
[10:32:24.548] Future state: ‘finished’
[10:32:24.549] result() for MulticoreFuture ...
[10:32:24.549] result() for MulticoreFuture ... done
[10:32:24.549] signalConditions() ...
[10:32:24.549]  - include = ‘condition’
[10:32:24.549]  - exclude = ‘immediateCondition’
[10:32:24.549]  - resignal = TRUE
[10:32:24.549]  - Number of conditions: 2
[10:32:24.549]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #1 of 4 ...[10:32:24.549]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[10:32:24.550] signalConditions() ... done
[10:32:24.550] resolved() for ‘Future’ ...
[10:32:24.551] - state: ‘created’
[10:32:24.551] - run: TRUE
[10:32:24.551] - run() ...
[10:32:24.551] run() for ‘Future’ ...
[10:32:24.551] - state: ‘created’
[10:32:24.551] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:24.555] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:24.556] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:24.556]   - Field: ‘label’
[10:32:24.556]   - Field: ‘local’
[10:32:24.556]   - Field: ‘owner’
[10:32:24.559]   - Field: ‘envir’
[10:32:24.560]   - Field: ‘workers’
[10:32:24.560]   - Field: ‘packages’
[10:32:24.560]   - Field: ‘gc’
[10:32:24.560]   - Field: ‘job’
[10:32:24.560]   - Field: ‘conditions’
[10:32:24.560]   - Field: ‘expr’
[10:32:24.560]   - Field: ‘uuid’
[10:32:24.560]   - Field: ‘seed’
[10:32:24.561]   - Field: ‘version’
[10:32:24.561]   - Field: ‘result’
[10:32:24.561]   - Field: ‘asynchronous’
[10:32:24.561]   - Field: ‘calls’
[10:32:24.561]   - Field: ‘globals’
[10:32:24.561]   - Field: ‘stdout’
[10:32:24.561]   - Field: ‘earlySignal’
[10:32:24.561]   - Field: ‘lazy’
[10:32:24.562]   - Field: ‘state’
[10:32:24.562] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:24.562] - Launch lazy future ...
[10:32:24.562] Packages needed by the future expression (n = 1): ‘future’
[10:32:24.562] Packages needed by future strategies (n = 0): <none>
[10:32:24.563] {
[10:32:24.563]     {
[10:32:24.563]         {
[10:32:24.563]             ...future.startTime <- base::Sys.time()
[10:32:24.563]             {
[10:32:24.563]                 {
[10:32:24.563]                   {
[10:32:24.563]                     {
[10:32:24.563]                       {
[10:32:24.563]                         base::local({
[10:32:24.563]                           has_future <- base::requireNamespace("future", 
[10:32:24.563]                             quietly = TRUE)
[10:32:24.563]                           if (has_future) {
[10:32:24.563]                             ns <- base::getNamespace("future")
[10:32:24.563]                             version <- ns[[".package"]][["version"]]
[10:32:24.563]                             if (is.null(version)) 
[10:32:24.563]                               version <- utils::packageVersion("future")
[10:32:24.563]                           }
[10:32:24.563]                           else {
[10:32:24.563]                             version <- NULL
[10:32:24.563]                           }
[10:32:24.563]                           if (!has_future || version < "1.8.0") {
[10:32:24.563]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:24.563]                               "", base::R.version$version.string), 
[10:32:24.563]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:24.563]                                 base::R.version$platform, 8 * 
[10:32:24.563]                                   base::.Machine$sizeof.pointer), 
[10:32:24.563]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:24.563]                                 "release", "version")], collapse = " "), 
[10:32:24.563]                               hostname = base::Sys.info()[["nodename"]])
[10:32:24.563]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:24.563]                               info)
[10:32:24.563]                             info <- base::paste(info, collapse = "; ")
[10:32:24.563]                             if (!has_future) {
[10:32:24.563]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:24.563]                                 info)
[10:32:24.563]                             }
[10:32:24.563]                             else {
[10:32:24.563]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:24.563]                                 info, version)
[10:32:24.563]                             }
[10:32:24.563]                             base::stop(msg)
[10:32:24.563]                           }
[10:32:24.563]                         })
[10:32:24.563]                       }
[10:32:24.563]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:24.563]                       base::options(mc.cores = 1L)
[10:32:24.563]                     }
[10:32:24.563]                     base::local({
[10:32:24.563]                       for (pkg in "future") {
[10:32:24.563]                         base::loadNamespace(pkg)
[10:32:24.563]                         base::library(pkg, character.only = TRUE)
[10:32:24.563]                       }
[10:32:24.563]                     })
[10:32:24.563]                   }
[10:32:24.563]                   ...future.strategy.old <- future::plan("list")
[10:32:24.563]                   options(future.plan = NULL)
[10:32:24.563]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:24.563]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:24.563]                 }
[10:32:24.563]                 ...future.workdir <- getwd()
[10:32:24.563]             }
[10:32:24.563]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:24.563]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:24.563]         }
[10:32:24.563]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:24.563]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:24.563]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:24.563]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:24.563]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:24.563]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:24.563]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:24.563]             base::names(...future.oldOptions))
[10:32:24.563]     }
[10:32:24.563]     if (FALSE) {
[10:32:24.563]     }
[10:32:24.563]     else {
[10:32:24.563]         if (TRUE) {
[10:32:24.563]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:24.563]                 open = "w")
[10:32:24.563]         }
[10:32:24.563]         else {
[10:32:24.563]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:24.563]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:24.563]         }
[10:32:24.563]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:24.563]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:24.563]             base::sink(type = "output", split = FALSE)
[10:32:24.563]             base::close(...future.stdout)
[10:32:24.563]         }, add = TRUE)
[10:32:24.563]     }
[10:32:24.563]     ...future.frame <- base::sys.nframe()
[10:32:24.563]     ...future.conditions <- base::list()
[10:32:24.563]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:24.563]     if (FALSE) {
[10:32:24.563]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:24.563]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:24.563]     }
[10:32:24.563]     ...future.result <- base::tryCatch({
[10:32:24.563]         base::withCallingHandlers({
[10:32:24.563]             ...future.value <- base::withVisible(base::local({
[10:32:24.563]                 withCallingHandlers({
[10:32:24.563]                   {
[10:32:24.563]                     message(sprintf("Calculating tile #%d of %d ...", 
[10:32:24.563]                       ii, n), appendLF = FALSE)
[10:32:24.563]                     fit <- mandelbrot(C)
[10:32:24.563]                     delay(fit)
[10:32:24.563]                     message(" done")
[10:32:24.563]                     fit
[10:32:24.563]                   }
[10:32:24.563]                 }, immediateCondition = function(cond) {
[10:32:24.563]                   save_rds <- function (object, pathname, ...) 
[10:32:24.563]                   {
[10:32:24.563]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:24.563]                     if (file_test("-f", pathname_tmp)) {
[10:32:24.563]                       fi_tmp <- file.info(pathname_tmp)
[10:32:24.563]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:24.563]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:24.563]                         fi_tmp[["mtime"]])
[10:32:24.563]                     }
[10:32:24.563]                     tryCatch({
[10:32:24.563]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:24.563]                     }, error = function(ex) {
[10:32:24.563]                       msg <- conditionMessage(ex)
[10:32:24.563]                       fi_tmp <- file.info(pathname_tmp)
[10:32:24.563]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:24.563]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:24.563]                         fi_tmp[["mtime"]], msg)
[10:32:24.563]                       ex$message <- msg
[10:32:24.563]                       stop(ex)
[10:32:24.563]                     })
[10:32:24.563]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:24.563]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:24.563]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:24.563]                       fi_tmp <- file.info(pathname_tmp)
[10:32:24.563]                       fi <- file.info(pathname)
[10:32:24.563]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:24.563]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:24.563]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:24.563]                         fi[["size"]], fi[["mtime"]])
[10:32:24.563]                       stop(msg)
[10:32:24.563]                     }
[10:32:24.563]                     invisible(pathname)
[10:32:24.563]                   }
[10:32:24.563]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:24.563]                     rootPath = tempdir()) 
[10:32:24.563]                   {
[10:32:24.563]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:24.563]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:24.563]                       tmpdir = path, fileext = ".rds")
[10:32:24.563]                     save_rds(obj, file)
[10:32:24.563]                   }
[10:32:24.563]                   saveImmediateCondition(cond, path = "/tmp/RtmpIGdrVQ/.future/immediateConditions")
[10:32:24.563]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:24.563]                   {
[10:32:24.563]                     inherits <- base::inherits
[10:32:24.563]                     invokeRestart <- base::invokeRestart
[10:32:24.563]                     is.null <- base::is.null
[10:32:24.563]                     muffled <- FALSE
[10:32:24.563]                     if (inherits(cond, "message")) {
[10:32:24.563]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:24.563]                       if (muffled) 
[10:32:24.563]                         invokeRestart("muffleMessage")
[10:32:24.563]                     }
[10:32:24.563]                     else if (inherits(cond, "warning")) {
[10:32:24.563]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:24.563]                       if (muffled) 
[10:32:24.563]                         invokeRestart("muffleWarning")
[10:32:24.563]                     }
[10:32:24.563]                     else if (inherits(cond, "condition")) {
[10:32:24.563]                       if (!is.null(pattern)) {
[10:32:24.563]                         computeRestarts <- base::computeRestarts
[10:32:24.563]                         grepl <- base::grepl
[10:32:24.563]                         restarts <- computeRestarts(cond)
[10:32:24.563]                         for (restart in restarts) {
[10:32:24.563]                           name <- restart$name
[10:32:24.563]                           if (is.null(name)) 
[10:32:24.563]                             next
[10:32:24.563]                           if (!grepl(pattern, name)) 
[10:32:24.563]                             next
[10:32:24.563]                           invokeRestart(restart)
[10:32:24.563]                           muffled <- TRUE
[10:32:24.563]                           break
[10:32:24.563]                         }
[10:32:24.563]                       }
[10:32:24.563]                     }
[10:32:24.563]                     invisible(muffled)
[10:32:24.563]                   }
[10:32:24.563]                   muffleCondition(cond)
[10:32:24.563]                 })
[10:32:24.563]             }))
[10:32:24.563]             future::FutureResult(value = ...future.value$value, 
[10:32:24.563]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:24.563]                   ...future.rng), globalenv = if (FALSE) 
[10:32:24.563]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:24.563]                     ...future.globalenv.names))
[10:32:24.563]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:24.563]         }, condition = base::local({
[10:32:24.563]             c <- base::c
[10:32:24.563]             inherits <- base::inherits
[10:32:24.563]             invokeRestart <- base::invokeRestart
[10:32:24.563]             length <- base::length
[10:32:24.563]             list <- base::list
[10:32:24.563]             seq.int <- base::seq.int
[10:32:24.563]             signalCondition <- base::signalCondition
[10:32:24.563]             sys.calls <- base::sys.calls
[10:32:24.563]             `[[` <- base::`[[`
[10:32:24.563]             `+` <- base::`+`
[10:32:24.563]             `<<-` <- base::`<<-`
[10:32:24.563]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:24.563]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:24.563]                   3L)]
[10:32:24.563]             }
[10:32:24.563]             function(cond) {
[10:32:24.563]                 is_error <- inherits(cond, "error")
[10:32:24.563]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:24.563]                   NULL)
[10:32:24.563]                 if (is_error) {
[10:32:24.563]                   sessionInformation <- function() {
[10:32:24.563]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:24.563]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:24.563]                       search = base::search(), system = base::Sys.info())
[10:32:24.563]                   }
[10:32:24.563]                   ...future.conditions[[length(...future.conditions) + 
[10:32:24.563]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:24.563]                     cond$call), session = sessionInformation(), 
[10:32:24.563]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:24.563]                   signalCondition(cond)
[10:32:24.563]                 }
[10:32:24.563]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:24.563]                 "immediateCondition"))) {
[10:32:24.563]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:24.563]                   ...future.conditions[[length(...future.conditions) + 
[10:32:24.563]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:24.563]                   if (TRUE && !signal) {
[10:32:24.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:24.563]                     {
[10:32:24.563]                       inherits <- base::inherits
[10:32:24.563]                       invokeRestart <- base::invokeRestart
[10:32:24.563]                       is.null <- base::is.null
[10:32:24.563]                       muffled <- FALSE
[10:32:24.563]                       if (inherits(cond, "message")) {
[10:32:24.563]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:24.563]                         if (muffled) 
[10:32:24.563]                           invokeRestart("muffleMessage")
[10:32:24.563]                       }
[10:32:24.563]                       else if (inherits(cond, "warning")) {
[10:32:24.563]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:24.563]                         if (muffled) 
[10:32:24.563]                           invokeRestart("muffleWarning")
[10:32:24.563]                       }
[10:32:24.563]                       else if (inherits(cond, "condition")) {
[10:32:24.563]                         if (!is.null(pattern)) {
[10:32:24.563]                           computeRestarts <- base::computeRestarts
[10:32:24.563]                           grepl <- base::grepl
[10:32:24.563]                           restarts <- computeRestarts(cond)
[10:32:24.563]                           for (restart in restarts) {
[10:32:24.563]                             name <- restart$name
[10:32:24.563]                             if (is.null(name)) 
[10:32:24.563]                               next
[10:32:24.563]                             if (!grepl(pattern, name)) 
[10:32:24.563]                               next
[10:32:24.563]                             invokeRestart(restart)
[10:32:24.563]                             muffled <- TRUE
[10:32:24.563]                             break
[10:32:24.563]                           }
[10:32:24.563]                         }
[10:32:24.563]                       }
[10:32:24.563]                       invisible(muffled)
[10:32:24.563]                     }
[10:32:24.563]                     muffleCondition(cond, pattern = "^muffle")
[10:32:24.563]                   }
[10:32:24.563]                 }
[10:32:24.563]                 else {
[10:32:24.563]                   if (TRUE) {
[10:32:24.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:24.563]                     {
[10:32:24.563]                       inherits <- base::inherits
[10:32:24.563]                       invokeRestart <- base::invokeRestart
[10:32:24.563]                       is.null <- base::is.null
[10:32:24.563]                       muffled <- FALSE
[10:32:24.563]                       if (inherits(cond, "message")) {
[10:32:24.563]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:24.563]                         if (muffled) 
[10:32:24.563]                           invokeRestart("muffleMessage")
[10:32:24.563]                       }
[10:32:24.563]                       else if (inherits(cond, "warning")) {
[10:32:24.563]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:24.563]                         if (muffled) 
[10:32:24.563]                           invokeRestart("muffleWarning")
[10:32:24.563]                       }
[10:32:24.563]                       else if (inherits(cond, "condition")) {
[10:32:24.563]                         if (!is.null(pattern)) {
[10:32:24.563]                           computeRestarts <- base::computeRestarts
[10:32:24.563]                           grepl <- base::grepl
[10:32:24.563]                           restarts <- computeRestarts(cond)
[10:32:24.563]                           for (restart in restarts) {
[10:32:24.563]                             name <- restart$name
[10:32:24.563]                             if (is.null(name)) 
[10:32:24.563]                               next
[10:32:24.563]                             if (!grepl(pattern, name)) 
[10:32:24.563]                               next
[10:32:24.563]                             invokeRestart(restart)
[10:32:24.563]                             muffled <- TRUE
[10:32:24.563]                             break
[10:32:24.563]                           }
[10:32:24.563]                         }
[10:32:24.563]                       }
[10:32:24.563]                       invisible(muffled)
[10:32:24.563]                     }
[10:32:24.563]                     muffleCondition(cond, pattern = "^muffle")
[10:32:24.563]                   }
[10:32:24.563]                 }
[10:32:24.563]             }
[10:32:24.563]         }))
[10:32:24.563]     }, error = function(ex) {
[10:32:24.563]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:24.563]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:24.563]                 ...future.rng), started = ...future.startTime, 
[10:32:24.563]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:24.563]             version = "1.8"), class = "FutureResult")
[10:32:24.563]     }, finally = {
[10:32:24.563]         if (!identical(...future.workdir, getwd())) 
[10:32:24.563]             setwd(...future.workdir)
[10:32:24.563]         {
[10:32:24.563]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:24.563]                 ...future.oldOptions$nwarnings <- NULL
[10:32:24.563]             }
[10:32:24.563]             base::options(...future.oldOptions)
[10:32:24.563]             if (.Platform$OS.type == "windows") {
[10:32:24.563]                 old_names <- names(...future.oldEnvVars)
[10:32:24.563]                 envs <- base::Sys.getenv()
[10:32:24.563]                 names <- names(envs)
[10:32:24.563]                 common <- intersect(names, old_names)
[10:32:24.563]                 added <- setdiff(names, old_names)
[10:32:24.563]                 removed <- setdiff(old_names, names)
[10:32:24.563]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:24.563]                   envs[common]]
[10:32:24.563]                 NAMES <- toupper(changed)
[10:32:24.563]                 args <- list()
[10:32:24.563]                 for (kk in seq_along(NAMES)) {
[10:32:24.563]                   name <- changed[[kk]]
[10:32:24.563]                   NAME <- NAMES[[kk]]
[10:32:24.563]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:24.563]                     next
[10:32:24.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:24.563]                 }
[10:32:24.563]                 NAMES <- toupper(added)
[10:32:24.563]                 for (kk in seq_along(NAMES)) {
[10:32:24.563]                   name <- added[[kk]]
[10:32:24.563]                   NAME <- NAMES[[kk]]
[10:32:24.563]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:24.563]                     next
[10:32:24.563]                   args[[name]] <- ""
[10:32:24.563]                 }
[10:32:24.563]                 NAMES <- toupper(removed)
[10:32:24.563]                 for (kk in seq_along(NAMES)) {
[10:32:24.563]                   name <- removed[[kk]]
[10:32:24.563]                   NAME <- NAMES[[kk]]
[10:32:24.563]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:24.563]                     next
[10:32:24.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:24.563]                 }
[10:32:24.563]                 if (length(args) > 0) 
[10:32:24.563]                   base::do.call(base::Sys.setenv, args = args)
[10:32:24.563]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:24.563]             }
[10:32:24.563]             else {
[10:32:24.563]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:24.563]             }
[10:32:24.563]             {
[10:32:24.563]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:24.563]                   0L) {
[10:32:24.563]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:24.563]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:24.563]                   base::options(opts)
[10:32:24.563]                 }
[10:32:24.563]                 {
[10:32:24.563]                   {
[10:32:24.563]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:24.563]                     NULL
[10:32:24.563]                   }
[10:32:24.563]                   options(future.plan = NULL)
[10:32:24.563]                   if (is.na(NA_character_)) 
[10:32:24.563]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:24.563]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:24.563]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:24.563]                     .init = FALSE)
[10:32:24.563]                 }
[10:32:24.563]             }
[10:32:24.563]         }
[10:32:24.563]     })
[10:32:24.563]     if (TRUE) {
[10:32:24.563]         base::sink(type = "output", split = FALSE)
[10:32:24.563]         if (TRUE) {
[10:32:24.563]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:24.563]         }
[10:32:24.563]         else {
[10:32:24.563]             ...future.result["stdout"] <- base::list(NULL)
[10:32:24.563]         }
[10:32:24.563]         base::close(...future.stdout)
[10:32:24.563]         ...future.stdout <- NULL
[10:32:24.563]     }
[10:32:24.563]     ...future.result$conditions <- ...future.conditions
[10:32:24.563]     ...future.result$finished <- base::Sys.time()
[10:32:24.563]     ...future.result
[10:32:24.563] }
[10:32:24.565] assign_globals() ...
[10:32:24.566] List of 4
[10:32:24.566]  $ ii   : int 2
[10:32:24.566]  $ n    : int 4
[10:32:24.566]  $ C    : cplx [1:25, 1:25] -0.72-1.5i -0.72-1.44i -0.72-1.38i ...
[10:32:24.566]   ..- attr(*, "region")=List of 2
[10:32:24.566]   .. ..$ xrange: num [1:2] -0.719 0.75
[10:32:24.566]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[10:32:24.566]   ..- attr(*, "tile")= int [1:2] 1 2
[10:32:24.566]  $ delay:function (counts)  
[10:32:24.566]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[10:32:24.566]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x5583e3f431c0> 
[10:32:24.566]  - attr(*, "where")=List of 4
[10:32:24.566]   ..$ ii   :<environment: R_EmptyEnv> 
[10:32:24.566]   ..$ n    :<environment: R_EmptyEnv> 
[10:32:24.566]   ..$ C    :<environment: R_EmptyEnv> 
[10:32:24.566]   ..$ delay:<environment: R_EmptyEnv> 
[10:32:24.566]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:24.566]  - attr(*, "resolved")= logi FALSE
[10:32:24.566]  - attr(*, "total_size")= num 14584
[10:32:24.566]  - attr(*, "already-done")= logi TRUE
[10:32:24.573] - copied ‘ii’ to environment
[10:32:24.573] - copied ‘n’ to environment
[10:32:24.573] - copied ‘C’ to environment
[10:32:24.573] - reassign environment for ‘delay’
[10:32:24.573] - copied ‘delay’ to environment
[10:32:24.573] assign_globals() ... done
[10:32:24.573] requestCore(): workers = 2
[10:32:24.576] MulticoreFuture started
[10:32:24.576] - Launch lazy future ... done
[10:32:24.576] run() for ‘MulticoreFuture’ ... done
[10:32:24.576] - run() ... done
[10:32:24.576] - resolved() ...
[10:32:24.577] plan(): Setting new future strategy stack:
[10:32:24.577] List of future strategies:
[10:32:24.577] 1. sequential:
[10:32:24.577]    - args: function (..., envir = parent.frame())
[10:32:24.577]    - tweaked: FALSE
[10:32:24.577]    - call: NULL
[10:32:24.578] plan(): nbrOfWorkers() = 1
[10:32:24.583] plan(): Setting new future strategy stack:
[10:32:24.583] List of future strategies:
[10:32:24.583] 1. multicore:
[10:32:24.583]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:24.583]    - tweaked: FALSE
[10:32:24.583]    - call: plan(strategy)
[10:32:24.587] - resolved: FALSE
[10:32:24.587] - resolved() ... done
[10:32:24.587] resolved() for ‘MulticoreFuture’ ... done
[10:32:24.588] resolved() for ‘Future’ ...
[10:32:24.588] - state: ‘created’
[10:32:24.588] - run: TRUE
[10:32:24.588] - run() ...
[10:32:24.588] run() for ‘Future’ ...
[10:32:24.588] - state: ‘created’
[10:32:24.588] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:24.589] plan(): nbrOfWorkers() = 2
[10:32:24.594] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:24.594] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:24.594]   - Field: ‘label’
[10:32:24.595]   - Field: ‘local’
[10:32:24.595]   - Field: ‘owner’
[10:32:24.595]   - Field: ‘envir’
[10:32:24.595]   - Field: ‘workers’
[10:32:24.596]   - Field: ‘packages’
[10:32:24.596]   - Field: ‘gc’
[10:32:24.596]   - Field: ‘job’
[10:32:24.596]   - Field: ‘conditions’
[10:32:24.597]   - Field: ‘expr’
[10:32:24.597]   - Field: ‘uuid’
[10:32:24.597]   - Field: ‘seed’
[10:32:24.597]   - Field: ‘version’
[10:32:24.598]   - Field: ‘result’
[10:32:24.598]   - Field: ‘asynchronous’
[10:32:24.598]   - Field: ‘calls’
[10:32:24.598]   - Field: ‘globals’
[10:32:24.599]   - Field: ‘stdout’
[10:32:24.599]   - Field: ‘earlySignal’
[10:32:24.599]   - Field: ‘lazy’
[10:32:24.599]   - Field: ‘state’
[10:32:24.600] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:24.600] - Launch lazy future ...
[10:32:24.601] Packages needed by the future expression (n = 1): ‘future’
[10:32:24.601] Packages needed by future strategies (n = 0): <none>
[10:32:24.603] {
[10:32:24.603]     {
[10:32:24.603]         {
[10:32:24.603]             ...future.startTime <- base::Sys.time()
[10:32:24.603]             {
[10:32:24.603]                 {
[10:32:24.603]                   {
[10:32:24.603]                     {
[10:32:24.603]                       {
[10:32:24.603]                         base::local({
[10:32:24.603]                           has_future <- base::requireNamespace("future", 
[10:32:24.603]                             quietly = TRUE)
[10:32:24.603]                           if (has_future) {
[10:32:24.603]                             ns <- base::getNamespace("future")
[10:32:24.603]                             version <- ns[[".package"]][["version"]]
[10:32:24.603]                             if (is.null(version)) 
[10:32:24.603]                               version <- utils::packageVersion("future")
[10:32:24.603]                           }
[10:32:24.603]                           else {
[10:32:24.603]                             version <- NULL
[10:32:24.603]                           }
[10:32:24.603]                           if (!has_future || version < "1.8.0") {
[10:32:24.603]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:24.603]                               "", base::R.version$version.string), 
[10:32:24.603]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:24.603]                                 base::R.version$platform, 8 * 
[10:32:24.603]                                   base::.Machine$sizeof.pointer), 
[10:32:24.603]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:24.603]                                 "release", "version")], collapse = " "), 
[10:32:24.603]                               hostname = base::Sys.info()[["nodename"]])
[10:32:24.603]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:24.603]                               info)
[10:32:24.603]                             info <- base::paste(info, collapse = "; ")
[10:32:24.603]                             if (!has_future) {
[10:32:24.603]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:24.603]                                 info)
[10:32:24.603]                             }
[10:32:24.603]                             else {
[10:32:24.603]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:24.603]                                 info, version)
[10:32:24.603]                             }
[10:32:24.603]                             base::stop(msg)
[10:32:24.603]                           }
[10:32:24.603]                         })
[10:32:24.603]                       }
[10:32:24.603]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:24.603]                       base::options(mc.cores = 1L)
[10:32:24.603]                     }
[10:32:24.603]                     base::local({
[10:32:24.603]                       for (pkg in "future") {
[10:32:24.603]                         base::loadNamespace(pkg)
[10:32:24.603]                         base::library(pkg, character.only = TRUE)
[10:32:24.603]                       }
[10:32:24.603]                     })
[10:32:24.603]                   }
[10:32:24.603]                   ...future.strategy.old <- future::plan("list")
[10:32:24.603]                   options(future.plan = NULL)
[10:32:24.603]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:24.603]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:24.603]                 }
[10:32:24.603]                 ...future.workdir <- getwd()
[10:32:24.603]             }
[10:32:24.603]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:24.603]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:24.603]         }
[10:32:24.603]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:24.603]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:24.603]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:24.603]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:24.603]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:24.603]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:24.603]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:24.603]             base::names(...future.oldOptions))
[10:32:24.603]     }
[10:32:24.603]     if (FALSE) {
[10:32:24.603]     }
[10:32:24.603]     else {
[10:32:24.603]         if (TRUE) {
[10:32:24.603]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:24.603]                 open = "w")
[10:32:24.603]         }
[10:32:24.603]         else {
[10:32:24.603]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:24.603]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:24.603]         }
[10:32:24.603]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:24.603]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:24.603]             base::sink(type = "output", split = FALSE)
[10:32:24.603]             base::close(...future.stdout)
[10:32:24.603]         }, add = TRUE)
[10:32:24.603]     }
[10:32:24.603]     ...future.frame <- base::sys.nframe()
[10:32:24.603]     ...future.conditions <- base::list()
[10:32:24.603]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:24.603]     if (FALSE) {
[10:32:24.603]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:24.603]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:24.603]     }
[10:32:24.603]     ...future.result <- base::tryCatch({
[10:32:24.603]         base::withCallingHandlers({
[10:32:24.603]             ...future.value <- base::withVisible(base::local({
[10:32:24.603]                 withCallingHandlers({
[10:32:24.603]                   {
[10:32:24.603]                     message(sprintf("Calculating tile #%d of %d ...", 
[10:32:24.603]                       ii, n), appendLF = FALSE)
[10:32:24.603]                     fit <- mandelbrot(C)
[10:32:24.603]                     delay(fit)
[10:32:24.603]                     message(" done")
[10:32:24.603]                     fit
[10:32:24.603]                   }
[10:32:24.603]                 }, immediateCondition = function(cond) {
[10:32:24.603]                   save_rds <- function (object, pathname, ...) 
[10:32:24.603]                   {
[10:32:24.603]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:24.603]                     if (file_test("-f", pathname_tmp)) {
[10:32:24.603]                       fi_tmp <- file.info(pathname_tmp)
[10:32:24.603]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:24.603]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:24.603]                         fi_tmp[["mtime"]])
[10:32:24.603]                     }
[10:32:24.603]                     tryCatch({
[10:32:24.603]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:24.603]                     }, error = function(ex) {
[10:32:24.603]                       msg <- conditionMessage(ex)
[10:32:24.603]                       fi_tmp <- file.info(pathname_tmp)
[10:32:24.603]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:24.603]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:24.603]                         fi_tmp[["mtime"]], msg)
[10:32:24.603]                       ex$message <- msg
[10:32:24.603]                       stop(ex)
[10:32:24.603]                     })
[10:32:24.603]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:24.603]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:24.603]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:24.603]                       fi_tmp <- file.info(pathname_tmp)
[10:32:24.603]                       fi <- file.info(pathname)
[10:32:24.603]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:24.603]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:24.603]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:24.603]                         fi[["size"]], fi[["mtime"]])
[10:32:24.603]                       stop(msg)
[10:32:24.603]                     }
[10:32:24.603]                     invisible(pathname)
[10:32:24.603]                   }
[10:32:24.603]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:24.603]                     rootPath = tempdir()) 
[10:32:24.603]                   {
[10:32:24.603]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:24.603]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:24.603]                       tmpdir = path, fileext = ".rds")
[10:32:24.603]                     save_rds(obj, file)
[10:32:24.603]                   }
[10:32:24.603]                   saveImmediateCondition(cond, path = "/tmp/RtmpIGdrVQ/.future/immediateConditions")
[10:32:24.603]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:24.603]                   {
[10:32:24.603]                     inherits <- base::inherits
[10:32:24.603]                     invokeRestart <- base::invokeRestart
[10:32:24.603]                     is.null <- base::is.null
[10:32:24.603]                     muffled <- FALSE
[10:32:24.603]                     if (inherits(cond, "message")) {
[10:32:24.603]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:24.603]                       if (muffled) 
[10:32:24.603]                         invokeRestart("muffleMessage")
[10:32:24.603]                     }
[10:32:24.603]                     else if (inherits(cond, "warning")) {
[10:32:24.603]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:24.603]                       if (muffled) 
[10:32:24.603]                         invokeRestart("muffleWarning")
[10:32:24.603]                     }
[10:32:24.603]                     else if (inherits(cond, "condition")) {
[10:32:24.603]                       if (!is.null(pattern)) {
[10:32:24.603]                         computeRestarts <- base::computeRestarts
[10:32:24.603]                         grepl <- base::grepl
[10:32:24.603]                         restarts <- computeRestarts(cond)
[10:32:24.603]                         for (restart in restarts) {
[10:32:24.603]                           name <- restart$name
[10:32:24.603]                           if (is.null(name)) 
[10:32:24.603]                             next
[10:32:24.603]                           if (!grepl(pattern, name)) 
[10:32:24.603]                             next
[10:32:24.603]                           invokeRestart(restart)
[10:32:24.603]                           muffled <- TRUE
[10:32:24.603]                           break
[10:32:24.603]                         }
[10:32:24.603]                       }
[10:32:24.603]                     }
[10:32:24.603]                     invisible(muffled)
[10:32:24.603]                   }
[10:32:24.603]                   muffleCondition(cond)
[10:32:24.603]                 })
[10:32:24.603]             }))
[10:32:24.603]             future::FutureResult(value = ...future.value$value, 
[10:32:24.603]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:24.603]                   ...future.rng), globalenv = if (FALSE) 
[10:32:24.603]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:24.603]                     ...future.globalenv.names))
[10:32:24.603]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:24.603]         }, condition = base::local({
[10:32:24.603]             c <- base::c
[10:32:24.603]             inherits <- base::inherits
[10:32:24.603]             invokeRestart <- base::invokeRestart
[10:32:24.603]             length <- base::length
[10:32:24.603]             list <- base::list
[10:32:24.603]             seq.int <- base::seq.int
[10:32:24.603]             signalCondition <- base::signalCondition
[10:32:24.603]             sys.calls <- base::sys.calls
[10:32:24.603]             `[[` <- base::`[[`
[10:32:24.603]             `+` <- base::`+`
[10:32:24.603]             `<<-` <- base::`<<-`
[10:32:24.603]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:24.603]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:24.603]                   3L)]
[10:32:24.603]             }
[10:32:24.603]             function(cond) {
[10:32:24.603]                 is_error <- inherits(cond, "error")
[10:32:24.603]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:24.603]                   NULL)
[10:32:24.603]                 if (is_error) {
[10:32:24.603]                   sessionInformation <- function() {
[10:32:24.603]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:24.603]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:24.603]                       search = base::search(), system = base::Sys.info())
[10:32:24.603]                   }
[10:32:24.603]                   ...future.conditions[[length(...future.conditions) + 
[10:32:24.603]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:24.603]                     cond$call), session = sessionInformation(), 
[10:32:24.603]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:24.603]                   signalCondition(cond)
[10:32:24.603]                 }
[10:32:24.603]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:24.603]                 "immediateCondition"))) {
[10:32:24.603]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:24.603]                   ...future.conditions[[length(...future.conditions) + 
[10:32:24.603]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:24.603]                   if (TRUE && !signal) {
[10:32:24.603]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:24.603]                     {
[10:32:24.603]                       inherits <- base::inherits
[10:32:24.603]                       invokeRestart <- base::invokeRestart
[10:32:24.603]                       is.null <- base::is.null
[10:32:24.603]                       muffled <- FALSE
[10:32:24.603]                       if (inherits(cond, "message")) {
[10:32:24.603]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:24.603]                         if (muffled) 
[10:32:24.603]                           invokeRestart("muffleMessage")
[10:32:24.603]                       }
[10:32:24.603]                       else if (inherits(cond, "warning")) {
[10:32:24.603]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:24.603]                         if (muffled) 
[10:32:24.603]                           invokeRestart("muffleWarning")
[10:32:24.603]                       }
[10:32:24.603]                       else if (inherits(cond, "condition")) {
[10:32:24.603]                         if (!is.null(pattern)) {
[10:32:24.603]                           computeRestarts <- base::computeRestarts
[10:32:24.603]                           grepl <- base::grepl
[10:32:24.603]                           restarts <- computeRestarts(cond)
[10:32:24.603]                           for (restart in restarts) {
[10:32:24.603]                             name <- restart$name
[10:32:24.603]                             if (is.null(name)) 
[10:32:24.603]                               next
[10:32:24.603]                             if (!grepl(pattern, name)) 
[10:32:24.603]                               next
[10:32:24.603]                             invokeRestart(restart)
[10:32:24.603]                             muffled <- TRUE
[10:32:24.603]                             break
[10:32:24.603]                           }
[10:32:24.603]                         }
[10:32:24.603]                       }
[10:32:24.603]                       invisible(muffled)
[10:32:24.603]                     }
[10:32:24.603]                     muffleCondition(cond, pattern = "^muffle")
[10:32:24.603]                   }
[10:32:24.603]                 }
[10:32:24.603]                 else {
[10:32:24.603]                   if (TRUE) {
[10:32:24.603]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:24.603]                     {
[10:32:24.603]                       inherits <- base::inherits
[10:32:24.603]                       invokeRestart <- base::invokeRestart
[10:32:24.603]                       is.null <- base::is.null
[10:32:24.603]                       muffled <- FALSE
[10:32:24.603]                       if (inherits(cond, "message")) {
[10:32:24.603]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:24.603]                         if (muffled) 
[10:32:24.603]                           invokeRestart("muffleMessage")
[10:32:24.603]                       }
[10:32:24.603]                       else if (inherits(cond, "warning")) {
[10:32:24.603]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:24.603]                         if (muffled) 
[10:32:24.603]                           invokeRestart("muffleWarning")
[10:32:24.603]                       }
[10:32:24.603]                       else if (inherits(cond, "condition")) {
[10:32:24.603]                         if (!is.null(pattern)) {
[10:32:24.603]                           computeRestarts <- base::computeRestarts
[10:32:24.603]                           grepl <- base::grepl
[10:32:24.603]                           restarts <- computeRestarts(cond)
[10:32:24.603]                           for (restart in restarts) {
[10:32:24.603]                             name <- restart$name
[10:32:24.603]                             if (is.null(name)) 
[10:32:24.603]                               next
[10:32:24.603]                             if (!grepl(pattern, name)) 
[10:32:24.603]                               next
[10:32:24.603]                             invokeRestart(restart)
[10:32:24.603]                             muffled <- TRUE
[10:32:24.603]                             break
[10:32:24.603]                           }
[10:32:24.603]                         }
[10:32:24.603]                       }
[10:32:24.603]                       invisible(muffled)
[10:32:24.603]                     }
[10:32:24.603]                     muffleCondition(cond, pattern = "^muffle")
[10:32:24.603]                   }
[10:32:24.603]                 }
[10:32:24.603]             }
[10:32:24.603]         }))
[10:32:24.603]     }, error = function(ex) {
[10:32:24.603]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:24.603]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:24.603]                 ...future.rng), started = ...future.startTime, 
[10:32:24.603]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:24.603]             version = "1.8"), class = "FutureResult")
[10:32:24.603]     }, finally = {
[10:32:24.603]         if (!identical(...future.workdir, getwd())) 
[10:32:24.603]             setwd(...future.workdir)
[10:32:24.603]         {
[10:32:24.603]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:24.603]                 ...future.oldOptions$nwarnings <- NULL
[10:32:24.603]             }
[10:32:24.603]             base::options(...future.oldOptions)
[10:32:24.603]             if (.Platform$OS.type == "windows") {
[10:32:24.603]                 old_names <- names(...future.oldEnvVars)
[10:32:24.603]                 envs <- base::Sys.getenv()
[10:32:24.603]                 names <- names(envs)
[10:32:24.603]                 common <- intersect(names, old_names)
[10:32:24.603]                 added <- setdiff(names, old_names)
[10:32:24.603]                 removed <- setdiff(old_names, names)
[10:32:24.603]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:24.603]                   envs[common]]
[10:32:24.603]                 NAMES <- toupper(changed)
[10:32:24.603]                 args <- list()
[10:32:24.603]                 for (kk in seq_along(NAMES)) {
[10:32:24.603]                   name <- changed[[kk]]
[10:32:24.603]                   NAME <- NAMES[[kk]]
[10:32:24.603]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:24.603]                     next
[10:32:24.603]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:24.603]                 }
[10:32:24.603]                 NAMES <- toupper(added)
[10:32:24.603]                 for (kk in seq_along(NAMES)) {
[10:32:24.603]                   name <- added[[kk]]
[10:32:24.603]                   NAME <- NAMES[[kk]]
[10:32:24.603]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:24.603]                     next
[10:32:24.603]                   args[[name]] <- ""
[10:32:24.603]                 }
[10:32:24.603]                 NAMES <- toupper(removed)
[10:32:24.603]                 for (kk in seq_along(NAMES)) {
[10:32:24.603]                   name <- removed[[kk]]
[10:32:24.603]                   NAME <- NAMES[[kk]]
[10:32:24.603]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:24.603]                     next
[10:32:24.603]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:24.603]                 }
[10:32:24.603]                 if (length(args) > 0) 
[10:32:24.603]                   base::do.call(base::Sys.setenv, args = args)
[10:32:24.603]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:24.603]             }
[10:32:24.603]             else {
[10:32:24.603]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:24.603]             }
[10:32:24.603]             {
[10:32:24.603]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:24.603]                   0L) {
[10:32:24.603]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:24.603]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:24.603]                   base::options(opts)
[10:32:24.603]                 }
[10:32:24.603]                 {
[10:32:24.603]                   {
[10:32:24.603]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:24.603]                     NULL
[10:32:24.603]                   }
[10:32:24.603]                   options(future.plan = NULL)
[10:32:24.603]                   if (is.na(NA_character_)) 
[10:32:24.603]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:24.603]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:24.603]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:24.603]                     .init = FALSE)
[10:32:24.603]                 }
[10:32:24.603]             }
[10:32:24.603]         }
[10:32:24.603]     })
[10:32:24.603]     if (TRUE) {
[10:32:24.603]         base::sink(type = "output", split = FALSE)
[10:32:24.603]         if (TRUE) {
[10:32:24.603]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:24.603]         }
[10:32:24.603]         else {
[10:32:24.603]             ...future.result["stdout"] <- base::list(NULL)
[10:32:24.603]         }
[10:32:24.603]         base::close(...future.stdout)
[10:32:24.603]         ...future.stdout <- NULL
[10:32:24.603]     }
[10:32:24.603]     ...future.result$conditions <- ...future.conditions
[10:32:24.603]     ...future.result$finished <- base::Sys.time()
[10:32:24.603]     ...future.result
[10:32:24.603] }
[10:32:24.608] assign_globals() ...
[10:32:24.608] List of 4
[10:32:24.608]  $ ii   : int 3
[10:32:24.608]  $ n    : int 4
[10:32:24.608]  $ C    : cplx [1:25, 1:25] -2.25+0.03i -2.25+0.09i -2.25+0.15i ...
[10:32:24.608]   ..- attr(*, "region")=List of 2
[10:32:24.608]   .. ..$ xrange: num [1:2] -2.25 -0.781
[10:32:24.608]   .. ..$ yrange: num [1:2] 0.0306 1.5
[10:32:24.608]   ..- attr(*, "tile")= int [1:2] 2 1
[10:32:24.608]  $ delay:function (counts)  
[10:32:24.608]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[10:32:24.608]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x5583e3f431c0> 
[10:32:24.608]  - attr(*, "where")=List of 4
[10:32:24.608]   ..$ ii   :<environment: R_EmptyEnv> 
[10:32:24.608]   ..$ n    :<environment: R_EmptyEnv> 
[10:32:24.608]   ..$ C    :<environment: R_EmptyEnv> 
[10:32:24.608]   ..$ delay:<environment: R_EmptyEnv> 
[10:32:24.608]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:24.608]  - attr(*, "resolved")= logi FALSE
[10:32:24.608]  - attr(*, "total_size")= num 14584
[10:32:24.608]  - attr(*, "already-done")= logi TRUE
[10:32:24.625] - copied ‘ii’ to environment
[10:32:24.625] - copied ‘n’ to environment
[10:32:24.626] - copied ‘C’ to environment
[10:32:24.626] - reassign environment for ‘delay’
[10:32:24.626] - copied ‘delay’ to environment
[10:32:24.626] assign_globals() ... done
[10:32:24.627] requestCore(): workers = 2
[10:32:24.630] MulticoreFuture started
[10:32:24.631] - Launch lazy future ... done
[10:32:24.631] run() for ‘MulticoreFuture’ ... done
[10:32:24.631] - run() ... done
[10:32:24.631] - resolved() ...
[10:32:24.631] plan(): Setting new future strategy stack:
[10:32:24.632] List of future strategies:
[10:32:24.632] 1. sequential:
[10:32:24.632]    - args: function (..., envir = parent.frame())
[10:32:24.632]    - tweaked: FALSE
[10:32:24.632]    - call: NULL
[10:32:24.633] plan(): nbrOfWorkers() = 1
[10:32:24.636] plan(): Setting new future strategy stack:
[10:32:24.637] List of future strategies:
[10:32:24.637] 1. multicore:
[10:32:24.637]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:24.637]    - tweaked: FALSE
[10:32:24.637]    - call: plan(strategy)
[10:32:24.642] - resolved: FALSE
[10:32:24.642] - resolved() ... done
[10:32:24.643] plan(): nbrOfWorkers() = 2
[10:32:24.643] resolved() for ‘MulticoreFuture’ ... done
[10:32:24.643] resolved() for ‘Future’ ...
[10:32:24.643] - state: ‘created’
[10:32:24.643] - run: TRUE
[10:32:24.643] - run() ...
[10:32:24.644] run() for ‘Future’ ...
[10:32:24.644] - state: ‘created’
[10:32:24.644] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:32:24.649] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:24.649] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:32:24.650]   - Field: ‘label’
[10:32:24.650]   - Field: ‘local’
[10:32:24.650]   - Field: ‘owner’
[10:32:24.650]   - Field: ‘envir’
[10:32:24.650]   - Field: ‘workers’
[10:32:24.650]   - Field: ‘packages’
[10:32:24.651]   - Field: ‘gc’
[10:32:24.651]   - Field: ‘job’
[10:32:24.651]   - Field: ‘conditions’
[10:32:24.651]   - Field: ‘expr’
[10:32:24.651]   - Field: ‘uuid’
[10:32:24.651]   - Field: ‘seed’
[10:32:24.651]   - Field: ‘version’
[10:32:24.652]   - Field: ‘result’
[10:32:24.652]   - Field: ‘asynchronous’
[10:32:24.652]   - Field: ‘calls’
[10:32:24.652]   - Field: ‘globals’
[10:32:24.652]   - Field: ‘stdout’
[10:32:24.652]   - Field: ‘earlySignal’
[10:32:24.652]   - Field: ‘lazy’
[10:32:24.653]   - Field: ‘state’
[10:32:24.653] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:32:24.653] - Launch lazy future ...
[10:32:24.654] Packages needed by the future expression (n = 1): ‘future’
[10:32:24.654] Packages needed by future strategies (n = 0): <none>
[10:32:24.655] {
[10:32:24.655]     {
[10:32:24.655]         {
[10:32:24.655]             ...future.startTime <- base::Sys.time()
[10:32:24.655]             {
[10:32:24.655]                 {
[10:32:24.655]                   {
[10:32:24.655]                     {
[10:32:24.655]                       {
[10:32:24.655]                         base::local({
[10:32:24.655]                           has_future <- base::requireNamespace("future", 
[10:32:24.655]                             quietly = TRUE)
[10:32:24.655]                           if (has_future) {
[10:32:24.655]                             ns <- base::getNamespace("future")
[10:32:24.655]                             version <- ns[[".package"]][["version"]]
[10:32:24.655]                             if (is.null(version)) 
[10:32:24.655]                               version <- utils::packageVersion("future")
[10:32:24.655]                           }
[10:32:24.655]                           else {
[10:32:24.655]                             version <- NULL
[10:32:24.655]                           }
[10:32:24.655]                           if (!has_future || version < "1.8.0") {
[10:32:24.655]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:24.655]                               "", base::R.version$version.string), 
[10:32:24.655]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:24.655]                                 base::R.version$platform, 8 * 
[10:32:24.655]                                   base::.Machine$sizeof.pointer), 
[10:32:24.655]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:24.655]                                 "release", "version")], collapse = " "), 
[10:32:24.655]                               hostname = base::Sys.info()[["nodename"]])
[10:32:24.655]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:24.655]                               info)
[10:32:24.655]                             info <- base::paste(info, collapse = "; ")
[10:32:24.655]                             if (!has_future) {
[10:32:24.655]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:24.655]                                 info)
[10:32:24.655]                             }
[10:32:24.655]                             else {
[10:32:24.655]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:24.655]                                 info, version)
[10:32:24.655]                             }
[10:32:24.655]                             base::stop(msg)
[10:32:24.655]                           }
[10:32:24.655]                         })
[10:32:24.655]                       }
[10:32:24.655]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:24.655]                       base::options(mc.cores = 1L)
[10:32:24.655]                     }
[10:32:24.655]                     base::local({
[10:32:24.655]                       for (pkg in "future") {
[10:32:24.655]                         base::loadNamespace(pkg)
[10:32:24.655]                         base::library(pkg, character.only = TRUE)
[10:32:24.655]                       }
[10:32:24.655]                     })
[10:32:24.655]                   }
[10:32:24.655]                   ...future.strategy.old <- future::plan("list")
[10:32:24.655]                   options(future.plan = NULL)
[10:32:24.655]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:24.655]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:24.655]                 }
[10:32:24.655]                 ...future.workdir <- getwd()
[10:32:24.655]             }
[10:32:24.655]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:24.655]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:24.655]         }
[10:32:24.655]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:24.655]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:24.655]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:24.655]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:24.655]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:24.655]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:24.655]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:24.655]             base::names(...future.oldOptions))
[10:32:24.655]     }
[10:32:24.655]     if (FALSE) {
[10:32:24.655]     }
[10:32:24.655]     else {
[10:32:24.655]         if (TRUE) {
[10:32:24.655]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:24.655]                 open = "w")
[10:32:24.655]         }
[10:32:24.655]         else {
[10:32:24.655]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:24.655]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:24.655]         }
[10:32:24.655]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:24.655]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:24.655]             base::sink(type = "output", split = FALSE)
[10:32:24.655]             base::close(...future.stdout)
[10:32:24.655]         }, add = TRUE)
[10:32:24.655]     }
[10:32:24.655]     ...future.frame <- base::sys.nframe()
[10:32:24.655]     ...future.conditions <- base::list()
[10:32:24.655]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:24.655]     if (FALSE) {
[10:32:24.655]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:24.655]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:24.655]     }
[10:32:24.655]     ...future.result <- base::tryCatch({
[10:32:24.655]         base::withCallingHandlers({
[10:32:24.655]             ...future.value <- base::withVisible(base::local({
[10:32:24.655]                 withCallingHandlers({
[10:32:24.655]                   {
[10:32:24.655]                     message(sprintf("Calculating tile #%d of %d ...", 
[10:32:24.655]                       ii, n), appendLF = FALSE)
[10:32:24.655]                     fit <- mandelbrot(C)
[10:32:24.655]                     delay(fit)
[10:32:24.655]                     message(" done")
[10:32:24.655]                     fit
[10:32:24.655]                   }
[10:32:24.655]                 }, immediateCondition = function(cond) {
[10:32:24.655]                   save_rds <- function (object, pathname, ...) 
[10:32:24.655]                   {
[10:32:24.655]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:32:24.655]                     if (file_test("-f", pathname_tmp)) {
[10:32:24.655]                       fi_tmp <- file.info(pathname_tmp)
[10:32:24.655]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:32:24.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:24.655]                         fi_tmp[["mtime"]])
[10:32:24.655]                     }
[10:32:24.655]                     tryCatch({
[10:32:24.655]                       saveRDS(object, file = pathname_tmp, ...)
[10:32:24.655]                     }, error = function(ex) {
[10:32:24.655]                       msg <- conditionMessage(ex)
[10:32:24.655]                       fi_tmp <- file.info(pathname_tmp)
[10:32:24.655]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:32:24.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:24.655]                         fi_tmp[["mtime"]], msg)
[10:32:24.655]                       ex$message <- msg
[10:32:24.655]                       stop(ex)
[10:32:24.655]                     })
[10:32:24.655]                     stopifnot(file_test("-f", pathname_tmp))
[10:32:24.655]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:32:24.655]                     if (!res || file_test("-f", pathname_tmp)) {
[10:32:24.655]                       fi_tmp <- file.info(pathname_tmp)
[10:32:24.655]                       fi <- file.info(pathname)
[10:32:24.655]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:32:24.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:32:24.655]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:32:24.655]                         fi[["size"]], fi[["mtime"]])
[10:32:24.655]                       stop(msg)
[10:32:24.655]                     }
[10:32:24.655]                     invisible(pathname)
[10:32:24.655]                   }
[10:32:24.655]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:32:24.655]                     rootPath = tempdir()) 
[10:32:24.655]                   {
[10:32:24.655]                     obj <- list(time = Sys.time(), condition = cond)
[10:32:24.655]                     file <- tempfile(pattern = class(cond)[1], 
[10:32:24.655]                       tmpdir = path, fileext = ".rds")
[10:32:24.655]                     save_rds(obj, file)
[10:32:24.655]                   }
[10:32:24.655]                   saveImmediateCondition(cond, path = "/tmp/RtmpIGdrVQ/.future/immediateConditions")
[10:32:24.655]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:24.655]                   {
[10:32:24.655]                     inherits <- base::inherits
[10:32:24.655]                     invokeRestart <- base::invokeRestart
[10:32:24.655]                     is.null <- base::is.null
[10:32:24.655]                     muffled <- FALSE
[10:32:24.655]                     if (inherits(cond, "message")) {
[10:32:24.655]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:24.655]                       if (muffled) 
[10:32:24.655]                         invokeRestart("muffleMessage")
[10:32:24.655]                     }
[10:32:24.655]                     else if (inherits(cond, "warning")) {
[10:32:24.655]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:24.655]                       if (muffled) 
[10:32:24.655]                         invokeRestart("muffleWarning")
[10:32:24.655]                     }
[10:32:24.655]                     else if (inherits(cond, "condition")) {
[10:32:24.655]                       if (!is.null(pattern)) {
[10:32:24.655]                         computeRestarts <- base::computeRestarts
[10:32:24.655]                         grepl <- base::grepl
[10:32:24.655]                         restarts <- computeRestarts(cond)
[10:32:24.655]                         for (restart in restarts) {
[10:32:24.655]                           name <- restart$name
[10:32:24.655]                           if (is.null(name)) 
[10:32:24.655]                             next
[10:32:24.655]                           if (!grepl(pattern, name)) 
[10:32:24.655]                             next
[10:32:24.655]                           invokeRestart(restart)
[10:32:24.655]                           muffled <- TRUE
[10:32:24.655]                           break
[10:32:24.655]                         }
[10:32:24.655]                       }
[10:32:24.655]                     }
[10:32:24.655]                     invisible(muffled)
[10:32:24.655]                   }
[10:32:24.655]                   muffleCondition(cond)
[10:32:24.655]                 })
[10:32:24.655]             }))
[10:32:24.655]             future::FutureResult(value = ...future.value$value, 
[10:32:24.655]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:24.655]                   ...future.rng), globalenv = if (FALSE) 
[10:32:24.655]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:24.655]                     ...future.globalenv.names))
[10:32:24.655]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:24.655]         }, condition = base::local({
[10:32:24.655]             c <- base::c
[10:32:24.655]             inherits <- base::inherits
[10:32:24.655]             invokeRestart <- base::invokeRestart
[10:32:24.655]             length <- base::length
[10:32:24.655]             list <- base::list
[10:32:24.655]             seq.int <- base::seq.int
[10:32:24.655]             signalCondition <- base::signalCondition
[10:32:24.655]             sys.calls <- base::sys.calls
[10:32:24.655]             `[[` <- base::`[[`
[10:32:24.655]             `+` <- base::`+`
[10:32:24.655]             `<<-` <- base::`<<-`
[10:32:24.655]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:24.655]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:24.655]                   3L)]
[10:32:24.655]             }
[10:32:24.655]             function(cond) {
[10:32:24.655]                 is_error <- inherits(cond, "error")
[10:32:24.655]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:24.655]                   NULL)
[10:32:24.655]                 if (is_error) {
[10:32:24.655]                   sessionInformation <- function() {
[10:32:24.655]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:24.655]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:24.655]                       search = base::search(), system = base::Sys.info())
[10:32:24.655]                   }
[10:32:24.655]                   ...future.conditions[[length(...future.conditions) + 
[10:32:24.655]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:24.655]                     cond$call), session = sessionInformation(), 
[10:32:24.655]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:24.655]                   signalCondition(cond)
[10:32:24.655]                 }
[10:32:24.655]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:24.655]                 "immediateCondition"))) {
[10:32:24.655]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:24.655]                   ...future.conditions[[length(...future.conditions) + 
[10:32:24.655]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:24.655]                   if (TRUE && !signal) {
[10:32:24.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:24.655]                     {
[10:32:24.655]                       inherits <- base::inherits
[10:32:24.655]                       invokeRestart <- base::invokeRestart
[10:32:24.655]                       is.null <- base::is.null
[10:32:24.655]                       muffled <- FALSE
[10:32:24.655]                       if (inherits(cond, "message")) {
[10:32:24.655]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:24.655]                         if (muffled) 
[10:32:24.655]                           invokeRestart("muffleMessage")
[10:32:24.655]                       }
[10:32:24.655]                       else if (inherits(cond, "warning")) {
[10:32:24.655]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:24.655]                         if (muffled) 
[10:32:24.655]                           invokeRestart("muffleWarning")
[10:32:24.655]                       }
[10:32:24.655]                       else if (inherits(cond, "condition")) {
[10:32:24.655]                         if (!is.null(pattern)) {
[10:32:24.655]                           computeRestarts <- base::computeRestarts
[10:32:24.655]                           grepl <- base::grepl
[10:32:24.655]                           restarts <- computeRestarts(cond)
[10:32:24.655]                           for (restart in restarts) {
[10:32:24.655]                             name <- restart$name
[10:32:24.655]                             if (is.null(name)) 
[10:32:24.655]                               next
[10:32:24.655]                             if (!grepl(pattern, name)) 
[10:32:24.655]                               next
[10:32:24.655]                             invokeRestart(restart)
[10:32:24.655]                             muffled <- TRUE
[10:32:24.655]                             break
[10:32:24.655]                           }
[10:32:24.655]                         }
[10:32:24.655]                       }
[10:32:24.655]                       invisible(muffled)
[10:32:24.655]                     }
[10:32:24.655]                     muffleCondition(cond, pattern = "^muffle")
[10:32:24.655]                   }
[10:32:24.655]                 }
[10:32:24.655]                 else {
[10:32:24.655]                   if (TRUE) {
[10:32:24.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:24.655]                     {
[10:32:24.655]                       inherits <- base::inherits
[10:32:24.655]                       invokeRestart <- base::invokeRestart
[10:32:24.655]                       is.null <- base::is.null
[10:32:24.655]                       muffled <- FALSE
[10:32:24.655]                       if (inherits(cond, "message")) {
[10:32:24.655]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:24.655]                         if (muffled) 
[10:32:24.655]                           invokeRestart("muffleMessage")
[10:32:24.655]                       }
[10:32:24.655]                       else if (inherits(cond, "warning")) {
[10:32:24.655]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:24.655]                         if (muffled) 
[10:32:24.655]                           invokeRestart("muffleWarning")
[10:32:24.655]                       }
[10:32:24.655]                       else if (inherits(cond, "condition")) {
[10:32:24.655]                         if (!is.null(pattern)) {
[10:32:24.655]                           computeRestarts <- base::computeRestarts
[10:32:24.655]                           grepl <- base::grepl
[10:32:24.655]                           restarts <- computeRestarts(cond)
[10:32:24.655]                           for (restart in restarts) {
[10:32:24.655]                             name <- restart$name
[10:32:24.655]                             if (is.null(name)) 
[10:32:24.655]                               next
[10:32:24.655]                             if (!grepl(pattern, name)) 
[10:32:24.655]                               next
[10:32:24.655]                             invokeRestart(restart)
[10:32:24.655]                             muffled <- TRUE
[10:32:24.655]                             break
[10:32:24.655]                           }
[10:32:24.655]                         }
[10:32:24.655]                       }
[10:32:24.655]                       invisible(muffled)
[10:32:24.655]                     }
[10:32:24.655]                     muffleCondition(cond, pattern = "^muffle")
[10:32:24.655]                   }
[10:32:24.655]                 }
[10:32:24.655]             }
[10:32:24.655]         }))
[10:32:24.655]     }, error = function(ex) {
[10:32:24.655]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:24.655]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:24.655]                 ...future.rng), started = ...future.startTime, 
[10:32:24.655]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:24.655]             version = "1.8"), class = "FutureResult")
[10:32:24.655]     }, finally = {
[10:32:24.655]         if (!identical(...future.workdir, getwd())) 
[10:32:24.655]             setwd(...future.workdir)
[10:32:24.655]         {
[10:32:24.655]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:24.655]                 ...future.oldOptions$nwarnings <- NULL
[10:32:24.655]             }
[10:32:24.655]             base::options(...future.oldOptions)
[10:32:24.655]             if (.Platform$OS.type == "windows") {
[10:32:24.655]                 old_names <- names(...future.oldEnvVars)
[10:32:24.655]                 envs <- base::Sys.getenv()
[10:32:24.655]                 names <- names(envs)
[10:32:24.655]                 common <- intersect(names, old_names)
[10:32:24.655]                 added <- setdiff(names, old_names)
[10:32:24.655]                 removed <- setdiff(old_names, names)
[10:32:24.655]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:24.655]                   envs[common]]
[10:32:24.655]                 NAMES <- toupper(changed)
[10:32:24.655]                 args <- list()
[10:32:24.655]                 for (kk in seq_along(NAMES)) {
[10:32:24.655]                   name <- changed[[kk]]
[10:32:24.655]                   NAME <- NAMES[[kk]]
[10:32:24.655]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:24.655]                     next
[10:32:24.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:24.655]                 }
[10:32:24.655]                 NAMES <- toupper(added)
[10:32:24.655]                 for (kk in seq_along(NAMES)) {
[10:32:24.655]                   name <- added[[kk]]
[10:32:24.655]                   NAME <- NAMES[[kk]]
[10:32:24.655]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:24.655]                     next
[10:32:24.655]                   args[[name]] <- ""
[10:32:24.655]                 }
[10:32:24.655]                 NAMES <- toupper(removed)
[10:32:24.655]                 for (kk in seq_along(NAMES)) {
[10:32:24.655]                   name <- removed[[kk]]
[10:32:24.655]                   NAME <- NAMES[[kk]]
[10:32:24.655]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:24.655]                     next
[10:32:24.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:24.655]                 }
[10:32:24.655]                 if (length(args) > 0) 
[10:32:24.655]                   base::do.call(base::Sys.setenv, args = args)
[10:32:24.655]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:24.655]             }
[10:32:24.655]             else {
[10:32:24.655]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:24.655]             }
[10:32:24.655]             {
[10:32:24.655]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:24.655]                   0L) {
[10:32:24.655]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:24.655]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:24.655]                   base::options(opts)
[10:32:24.655]                 }
[10:32:24.655]                 {
[10:32:24.655]                   {
[10:32:24.655]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:24.655]                     NULL
[10:32:24.655]                   }
[10:32:24.655]                   options(future.plan = NULL)
[10:32:24.655]                   if (is.na(NA_character_)) 
[10:32:24.655]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:24.655]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:24.655]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:24.655]                     .init = FALSE)
[10:32:24.655]                 }
[10:32:24.655]             }
[10:32:24.655]         }
[10:32:24.655]     })
[10:32:24.655]     if (TRUE) {
[10:32:24.655]         base::sink(type = "output", split = FALSE)
[10:32:24.655]         if (TRUE) {
[10:32:24.655]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:24.655]         }
[10:32:24.655]         else {
[10:32:24.655]             ...future.result["stdout"] <- base::list(NULL)
[10:32:24.655]         }
[10:32:24.655]         base::close(...future.stdout)
[10:32:24.655]         ...future.stdout <- NULL
[10:32:24.655]     }
[10:32:24.655]     ...future.result$conditions <- ...future.conditions
[10:32:24.655]     ...future.result$finished <- base::Sys.time()
[10:32:24.655]     ...future.result
[10:32:24.655] }
[10:32:24.658] assign_globals() ...
[10:32:24.658] List of 4
[10:32:24.658]  $ ii   : int 4
[10:32:24.658]  $ n    : int 4
[10:32:24.658]  $ C    : cplx [1:25, 1:25] -0.719+0.031i -0.719+0.092i -0.719+0.153i ...
[10:32:24.658]   ..- attr(*, "region")=List of 2
[10:32:24.658]   .. ..$ xrange: num [1:2] -0.719 0.75
[10:32:24.658]   .. ..$ yrange: num [1:2] 0.0306 1.5
[10:32:24.658]   ..- attr(*, "tile")= int [1:2] 2 2
[10:32:24.658]  $ delay:function (counts)  
[10:32:24.658]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[10:32:24.658]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x5583e3f431c0> 
[10:32:24.658]  - attr(*, "where")=List of 4
[10:32:24.658]   ..$ ii   :<environment: R_EmptyEnv> 
[10:32:24.658]   ..$ n    :<environment: R_EmptyEnv> 
[10:32:24.658]   ..$ C    :<environment: R_EmptyEnv> 
[10:32:24.658]   ..$ delay:<environment: R_EmptyEnv> 
[10:32:24.658]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:32:24.658]  - attr(*, "resolved")= logi FALSE
[10:32:24.658]  - attr(*, "total_size")= num 14584
[10:32:24.658]  - attr(*, "already-done")= logi TRUE
[10:32:24.667] - copied ‘ii’ to environment
[10:32:24.667] - copied ‘n’ to environment
[10:32:24.667] - copied ‘C’ to environment
[10:32:24.667] - reassign environment for ‘delay’
[10:32:24.668] - copied ‘delay’ to environment
[10:32:24.668] assign_globals() ... done
[10:32:24.668] requestCore(): workers = 2
[10:32:24.668] Poll #1 (0): usedCores() = 2, workers = 2
[10:32:24.679] result() for MulticoreFuture ...
[10:32:24.680] result() for MulticoreFuture ...
[10:32:24.680] result() for MulticoreFuture ... done
[10:32:24.680] signalConditions() ...
[10:32:24.680]  - include = ‘immediateCondition’
[10:32:24.681]  - exclude = 
[10:32:24.681]  - resignal = FALSE
[10:32:24.681]  - Number of conditions: 2
[10:32:24.681] signalConditions() ... done
[10:32:24.681] result() for MulticoreFuture ... done
[10:32:24.681] result() for MulticoreFuture ...
[10:32:24.681] result() for MulticoreFuture ... done
[10:32:24.682] signalConditions() ...
[10:32:24.682]  - include = ‘immediateCondition’
[10:32:24.682]  - exclude = 
[10:32:24.682]  - resignal = FALSE
[10:32:24.682]  - Number of conditions: 2
[10:32:24.682] signalConditions() ... done
[10:32:24.685] MulticoreFuture started
[10:32:24.686] - Launch lazy future ... done
[10:32:24.686] run() for ‘MulticoreFuture’ ... done
[10:32:24.686] - run() ... done
[10:32:24.686] - resolved() ...
[10:32:24.687] plan(): Setting new future strategy stack:
[10:32:24.687] List of future strategies:
[10:32:24.687] 1. sequential:
[10:32:24.687]    - args: function (..., envir = parent.frame())
[10:32:24.687]    - tweaked: FALSE
[10:32:24.687]    - call: NULL
[10:32:24.688] plan(): nbrOfWorkers() = 1
[10:32:24.692] plan(): Setting new future strategy stack:
[10:32:24.692] List of future strategies:
[10:32:24.692] 1. multicore:
[10:32:24.692]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:32:24.692]    - tweaked: FALSE
[10:32:24.692]    - call: plan(strategy)
[10:32:24.697] - resolved: FALSE
[10:32:24.697] - resolved() ... done
[10:32:24.697] resolved() for ‘MulticoreFuture’ ... done
Plotting tile #2 of 4 ...
[10:32:24.698] result() for MulticoreFuture ...
[10:32:24.698] plan(): nbrOfWorkers() = 2
[10:32:24.698] result() for MulticoreFuture ... done
[10:32:24.698] result() for MulticoreFuture ...
[10:32:24.698] result() for MulticoreFuture ... done
[10:32:24.698] signalConditions() ...
[10:32:24.699]  - include = ‘immediateCondition’
[10:32:24.699]  - exclude = 
[10:32:24.699]  - resignal = FALSE
[10:32:24.699]  - Number of conditions: 2
[10:32:24.699] signalConditions() ... done
[10:32:24.699] Future state: ‘finished’
[10:32:24.700] result() for MulticoreFuture ...
[10:32:24.700] result() for MulticoreFuture ... done
[10:32:24.700] signalConditions() ...
[10:32:24.700]  - include = ‘condition’
[10:32:24.700]  - exclude = ‘immediateCondition’
[10:32:24.700]  - resignal = TRUE
[10:32:24.700]  - Number of conditions: 2
[10:32:24.701]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #2 of 4 ...[10:32:24.701]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[10:32:24.701] signalConditions() ... done
Plotting tile #3 of 4 ...
[10:32:24.702] result() for MulticoreFuture ...
[10:32:24.704] result() for MulticoreFuture ...
[10:32:24.704] result() for MulticoreFuture ... done
[10:32:24.704] signalConditions() ...
[10:32:24.704]  - include = ‘immediateCondition’
[10:32:24.705]  - exclude = 
[10:32:24.705]  - resignal = FALSE
[10:32:24.705]  - Number of conditions: 2
[10:32:24.705] signalConditions() ... done
[10:32:24.705] result() for MulticoreFuture ... done
[10:32:24.705] result() for MulticoreFuture ...
[10:32:24.706] result() for MulticoreFuture ... done
[10:32:24.706] signalConditions() ...
[10:32:24.706]  - include = ‘immediateCondition’
[10:32:24.706]  - exclude = 
[10:32:24.706]  - resignal = FALSE
[10:32:24.706]  - Number of conditions: 2
[10:32:24.707] signalConditions() ... done
[10:32:24.707] Future state: ‘finished’
[10:32:24.707] result() for MulticoreFuture ...
[10:32:24.707] result() for MulticoreFuture ... done
[10:32:24.707] signalConditions() ...
[10:32:24.707]  - include = ‘condition’
[10:32:24.708]  - exclude = ‘immediateCondition’
[10:32:24.708]  - resignal = TRUE
[10:32:24.708]  - Number of conditions: 2
[10:32:24.708]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #3 of 4 ...[10:32:24.708]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[10:32:24.709] signalConditions() ... done
Plotting tile #4 of 4 ...
[10:32:24.710] result() for MulticoreFuture ...
[10:32:24.711] result() for MulticoreFuture ...
[10:32:24.711] result() for MulticoreFuture ... done
[10:32:24.711] signalConditions() ...
[10:32:24.711]  - include = ‘immediateCondition’
[10:32:24.711]  - exclude = 
[10:32:24.711]  - resignal = FALSE
[10:32:24.711]  - Number of conditions: 2
[10:32:24.712] signalConditions() ... done
[10:32:24.712] result() for MulticoreFuture ... done
[10:32:24.712] result() for MulticoreFuture ...
[10:32:24.712] result() for MulticoreFuture ... done
[10:32:24.712] signalConditions() ...
[10:32:24.712]  - include = ‘immediateCondition’
[10:32:24.712]  - exclude = 
[10:32:24.712]  - resignal = FALSE
[10:32:24.713]  - Number of conditions: 2
[10:32:24.713] signalConditions() ... done
[10:32:24.713] Future state: ‘finished’
[10:32:24.713] result() for MulticoreFuture ...
[10:32:24.713] result() for MulticoreFuture ... done
[10:32:24.713] signalConditions() ...
[10:32:24.713]  - include = ‘condition’
[10:32:24.713]  - exclude = ‘immediateCondition’
[10:32:24.714]  - resignal = TRUE
[10:32:24.714]  - Number of conditions: 2
[10:32:24.714]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #4 of 4 ...[10:32:24.714]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[10:32:24.714] signalConditions() ... done

> close.screen()
[1] 1 2 3 4 5 6 7 8

> message("SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).\n")
SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).

- plan('multicore') ... DONE
- plan('multisession') ...
[10:32:24.716] plan(): Setting new future strategy stack:
[10:32:24.716] List of future strategies:
[10:32:24.716] 1. multisession:
[10:32:24.716]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:32:24.716]    - tweaked: FALSE
[10:32:24.716]    - call: plan(strategy)
[10:32:24.716] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:32:24.717] multisession:
[10:32:24.717] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:32:24.717] - tweaked: FALSE
[10:32:24.717] - call: plan(strategy)
[10:32:24.723] getGlobalsAndPackages() ...
[10:32:24.724] Not searching for globals
[10:32:24.724] - globals: [0] <none>
[10:32:24.724] getGlobalsAndPackages() ... DONE
[10:32:24.725] [local output] makeClusterPSOCK() ...
[10:32:24.782] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:32:24.783] [local output] Base port: 11193
[10:32:24.783] [local output] Getting setup options for 2 cluster nodes ...
[10:32:24.783] [local output]  - Node 1 of 2 ...
[10:32:24.784] [local output] localMachine=TRUE => revtunnel=FALSE

[10:32:24.784] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpIGdrVQ/worker.rank=1.parallelly.parent=79648.1372037836bb0.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpIGdrVQ/worker.rank=1.parallelly.parent=79648.1372037836bb0.pid")'’
[10:32:24.973] - Possible to infer worker's PID: TRUE
[10:32:24.973] [local output] Rscript port: 11193

[10:32:24.974] [local output]  - Node 2 of 2 ...
[10:32:24.974] [local output] localMachine=TRUE => revtunnel=FALSE

[10:32:24.975] [local output] Rscript port: 11193

[10:32:24.975] [local output] Getting setup options for 2 cluster nodes ... done
[10:32:24.975] [local output]  - Parallel setup requested for some PSOCK nodes
[10:32:24.976] [local output] Setting up PSOCK nodes in parallel
[10:32:24.976] List of 36
[10:32:24.976]  $ worker          : chr "localhost"
[10:32:24.976]   ..- attr(*, "localhost")= logi TRUE
[10:32:24.976]  $ master          : chr "localhost"
[10:32:24.976]  $ port            : int 11193
[10:32:24.976]  $ connectTimeout  : num 120
[10:32:24.976]  $ timeout         : num 2592000
[10:32:24.976]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:32:24.976]  $ homogeneous     : logi TRUE
[10:32:24.976]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:32:24.976]  $ rscript_envs    : NULL
[10:32:24.976]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:32:24.976]  $ rscript_startup : NULL
[10:32:24.976]  $ rscript_sh      : chr "sh"
[10:32:24.976]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:32:24.976]  $ methods         : logi TRUE
[10:32:24.976]  $ socketOptions   : chr "no-delay"
[10:32:24.976]  $ useXDR          : logi FALSE
[10:32:24.976]  $ outfile         : chr "/dev/null"
[10:32:24.976]  $ renice          : int NA
[10:32:24.976]  $ rshcmd          : NULL
[10:32:24.976]  $ user            : chr(0) 
[10:32:24.976]  $ revtunnel       : logi FALSE
[10:32:24.976]  $ rshlogfile      : NULL
[10:32:24.976]  $ rshopts         : chr(0) 
[10:32:24.976]  $ rank            : int 1
[10:32:24.976]  $ manual          : logi FALSE
[10:32:24.976]  $ dryrun          : logi FALSE
[10:32:24.976]  $ quiet           : logi FALSE
[10:32:24.976]  $ setup_strategy  : chr "parallel"
[10:32:24.976]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:32:24.976]  $ pidfile         : chr "/tmp/RtmpIGdrVQ/worker.rank=1.parallelly.parent=79648.1372037836bb0.pid"
[10:32:24.976]  $ rshcmd_label    : NULL
[10:32:24.976]  $ rsh_call        : NULL
[10:32:24.976]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:32:24.976]  $ localMachine    : logi TRUE
[10:32:24.976]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:32:24.976]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:32:24.976]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:32:24.976]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:32:24.976]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:32:24.976]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:32:24.976]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:32:24.976]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:32:24.976]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:32:24.976]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:32:24.976]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:32:24.976]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:32:24.976]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:32:24.976]  $ arguments       :List of 28
[10:32:24.976]   ..$ worker          : chr "localhost"
[10:32:24.976]   ..$ master          : NULL
[10:32:24.976]   ..$ port            : int 11193
[10:32:24.976]   ..$ connectTimeout  : num 120
[10:32:24.976]   ..$ timeout         : num 2592000
[10:32:24.976]   ..$ rscript         : NULL
[10:32:24.976]   ..$ homogeneous     : NULL
[10:32:24.976]   ..$ rscript_args    : NULL
[10:32:24.976]   ..$ rscript_envs    : NULL
[10:32:24.976]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:32:24.976]   ..$ rscript_startup : NULL
[10:32:24.976]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:32:24.976]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:32:24.976]   ..$ methods         : logi TRUE
[10:32:24.976]   ..$ socketOptions   : chr "no-delay"
[10:32:24.976]   ..$ useXDR          : logi FALSE
[10:32:24.976]   ..$ outfile         : chr "/dev/null"
[10:32:24.976]   ..$ renice          : int NA
[10:32:24.976]   ..$ rshcmd          : NULL
[10:32:24.976]   ..$ user            : NULL
[10:32:24.976]   ..$ revtunnel       : logi NA
[10:32:24.976]   ..$ rshlogfile      : NULL
[10:32:24.976]   ..$ rshopts         : NULL
[10:32:24.976]   ..$ rank            : int 1
[10:32:24.976]   ..$ manual          : logi FALSE
[10:32:24.976]   ..$ dryrun          : logi FALSE
[10:32:24.976]   ..$ quiet           : logi FALSE
[10:32:24.976]   ..$ setup_strategy  : chr "parallel"
[10:32:24.976]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:32:24.992] [local output] System call to launch all workers:
[10:32:24.992] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpIGdrVQ/worker.rank=1.parallelly.parent=79648.1372037836bb0.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11193 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:32:24.993] [local output] Starting PSOCK main server
[10:32:24.998] [local output] Workers launched
[10:32:24.998] [local output] Waiting for workers to connect back
[10:32:24.999]  - [local output] 0 workers out of 2 ready
[10:32:25.240]  - [local output] 0 workers out of 2 ready
[10:32:25.241]  - [local output] 1 workers out of 2 ready
[10:32:25.246]  - [local output] 1 workers out of 2 ready
[10:32:25.246]  - [local output] 2 workers out of 2 ready
[10:32:25.246] [local output] Launching of workers completed
[10:32:25.247] [local output] Collecting session information from workers
[10:32:25.247] [local output]  - Worker #1 of 2
[10:32:25.248] [local output]  - Worker #2 of 2
[10:32:25.248] [local output] makeClusterPSOCK() ... done
[10:32:25.259] Packages needed by the future expression (n = 0): <none>
[10:32:25.259] Packages needed by future strategies (n = 0): <none>
[10:32:25.260] {
[10:32:25.260]     {
[10:32:25.260]         {
[10:32:25.260]             ...future.startTime <- base::Sys.time()
[10:32:25.260]             {
[10:32:25.260]                 {
[10:32:25.260]                   {
[10:32:25.260]                     {
[10:32:25.260]                       base::local({
[10:32:25.260]                         has_future <- base::requireNamespace("future", 
[10:32:25.260]                           quietly = TRUE)
[10:32:25.260]                         if (has_future) {
[10:32:25.260]                           ns <- base::getNamespace("future")
[10:32:25.260]                           version <- ns[[".package"]][["version"]]
[10:32:25.260]                           if (is.null(version)) 
[10:32:25.260]                             version <- utils::packageVersion("future")
[10:32:25.260]                         }
[10:32:25.260]                         else {
[10:32:25.260]                           version <- NULL
[10:32:25.260]                         }
[10:32:25.260]                         if (!has_future || version < "1.8.0") {
[10:32:25.260]                           info <- base::c(r_version = base::gsub("R version ", 
[10:32:25.260]                             "", base::R.version$version.string), 
[10:32:25.260]                             platform = base::sprintf("%s (%s-bit)", 
[10:32:25.260]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:32:25.260]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:25.260]                               "release", "version")], collapse = " "), 
[10:32:25.260]                             hostname = base::Sys.info()[["nodename"]])
[10:32:25.260]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:32:25.260]                             info)
[10:32:25.260]                           info <- base::paste(info, collapse = "; ")
[10:32:25.260]                           if (!has_future) {
[10:32:25.260]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:25.260]                               info)
[10:32:25.260]                           }
[10:32:25.260]                           else {
[10:32:25.260]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:25.260]                               info, version)
[10:32:25.260]                           }
[10:32:25.260]                           base::stop(msg)
[10:32:25.260]                         }
[10:32:25.260]                       })
[10:32:25.260]                     }
[10:32:25.260]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:25.260]                     base::options(mc.cores = 1L)
[10:32:25.260]                   }
[10:32:25.260]                   ...future.strategy.old <- future::plan("list")
[10:32:25.260]                   options(future.plan = NULL)
[10:32:25.260]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:25.260]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:25.260]                 }
[10:32:25.260]                 ...future.workdir <- getwd()
[10:32:25.260]             }
[10:32:25.260]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:25.260]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:25.260]         }
[10:32:25.260]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:25.260]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:25.260]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:25.260]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:25.260]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:25.260]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:25.260]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:25.260]             base::names(...future.oldOptions))
[10:32:25.260]     }
[10:32:25.260]     if (FALSE) {
[10:32:25.260]     }
[10:32:25.260]     else {
[10:32:25.260]         if (TRUE) {
[10:32:25.260]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:25.260]                 open = "w")
[10:32:25.260]         }
[10:32:25.260]         else {
[10:32:25.260]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:25.260]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:25.260]         }
[10:32:25.260]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:25.260]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:25.260]             base::sink(type = "output", split = FALSE)
[10:32:25.260]             base::close(...future.stdout)
[10:32:25.260]         }, add = TRUE)
[10:32:25.260]     }
[10:32:25.260]     ...future.frame <- base::sys.nframe()
[10:32:25.260]     ...future.conditions <- base::list()
[10:32:25.260]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:25.260]     if (FALSE) {
[10:32:25.260]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:25.260]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:25.260]     }
[10:32:25.260]     ...future.result <- base::tryCatch({
[10:32:25.260]         base::withCallingHandlers({
[10:32:25.260]             ...future.value <- base::withVisible(base::local({
[10:32:25.260]                 ...future.makeSendCondition <- base::local({
[10:32:25.260]                   sendCondition <- NULL
[10:32:25.260]                   function(frame = 1L) {
[10:32:25.260]                     if (is.function(sendCondition)) 
[10:32:25.260]                       return(sendCondition)
[10:32:25.260]                     ns <- getNamespace("parallel")
[10:32:25.260]                     if (exists("sendData", mode = "function", 
[10:32:25.260]                       envir = ns)) {
[10:32:25.260]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:25.260]                         envir = ns)
[10:32:25.260]                       envir <- sys.frame(frame)
[10:32:25.260]                       master <- NULL
[10:32:25.260]                       while (!identical(envir, .GlobalEnv) && 
[10:32:25.260]                         !identical(envir, emptyenv())) {
[10:32:25.260]                         if (exists("master", mode = "list", envir = envir, 
[10:32:25.260]                           inherits = FALSE)) {
[10:32:25.260]                           master <- get("master", mode = "list", 
[10:32:25.260]                             envir = envir, inherits = FALSE)
[10:32:25.260]                           if (inherits(master, c("SOCKnode", 
[10:32:25.260]                             "SOCK0node"))) {
[10:32:25.260]                             sendCondition <<- function(cond) {
[10:32:25.260]                               data <- list(type = "VALUE", value = cond, 
[10:32:25.260]                                 success = TRUE)
[10:32:25.260]                               parallel_sendData(master, data)
[10:32:25.260]                             }
[10:32:25.260]                             return(sendCondition)
[10:32:25.260]                           }
[10:32:25.260]                         }
[10:32:25.260]                         frame <- frame + 1L
[10:32:25.260]                         envir <- sys.frame(frame)
[10:32:25.260]                       }
[10:32:25.260]                     }
[10:32:25.260]                     sendCondition <<- function(cond) NULL
[10:32:25.260]                   }
[10:32:25.260]                 })
[10:32:25.260]                 withCallingHandlers({
[10:32:25.260]                   NA
[10:32:25.260]                 }, immediateCondition = function(cond) {
[10:32:25.260]                   sendCondition <- ...future.makeSendCondition()
[10:32:25.260]                   sendCondition(cond)
[10:32:25.260]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:25.260]                   {
[10:32:25.260]                     inherits <- base::inherits
[10:32:25.260]                     invokeRestart <- base::invokeRestart
[10:32:25.260]                     is.null <- base::is.null
[10:32:25.260]                     muffled <- FALSE
[10:32:25.260]                     if (inherits(cond, "message")) {
[10:32:25.260]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:25.260]                       if (muffled) 
[10:32:25.260]                         invokeRestart("muffleMessage")
[10:32:25.260]                     }
[10:32:25.260]                     else if (inherits(cond, "warning")) {
[10:32:25.260]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:25.260]                       if (muffled) 
[10:32:25.260]                         invokeRestart("muffleWarning")
[10:32:25.260]                     }
[10:32:25.260]                     else if (inherits(cond, "condition")) {
[10:32:25.260]                       if (!is.null(pattern)) {
[10:32:25.260]                         computeRestarts <- base::computeRestarts
[10:32:25.260]                         grepl <- base::grepl
[10:32:25.260]                         restarts <- computeRestarts(cond)
[10:32:25.260]                         for (restart in restarts) {
[10:32:25.260]                           name <- restart$name
[10:32:25.260]                           if (is.null(name)) 
[10:32:25.260]                             next
[10:32:25.260]                           if (!grepl(pattern, name)) 
[10:32:25.260]                             next
[10:32:25.260]                           invokeRestart(restart)
[10:32:25.260]                           muffled <- TRUE
[10:32:25.260]                           break
[10:32:25.260]                         }
[10:32:25.260]                       }
[10:32:25.260]                     }
[10:32:25.260]                     invisible(muffled)
[10:32:25.260]                   }
[10:32:25.260]                   muffleCondition(cond)
[10:32:25.260]                 })
[10:32:25.260]             }))
[10:32:25.260]             future::FutureResult(value = ...future.value$value, 
[10:32:25.260]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:25.260]                   ...future.rng), globalenv = if (FALSE) 
[10:32:25.260]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:25.260]                     ...future.globalenv.names))
[10:32:25.260]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:25.260]         }, condition = base::local({
[10:32:25.260]             c <- base::c
[10:32:25.260]             inherits <- base::inherits
[10:32:25.260]             invokeRestart <- base::invokeRestart
[10:32:25.260]             length <- base::length
[10:32:25.260]             list <- base::list
[10:32:25.260]             seq.int <- base::seq.int
[10:32:25.260]             signalCondition <- base::signalCondition
[10:32:25.260]             sys.calls <- base::sys.calls
[10:32:25.260]             `[[` <- base::`[[`
[10:32:25.260]             `+` <- base::`+`
[10:32:25.260]             `<<-` <- base::`<<-`
[10:32:25.260]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:25.260]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:25.260]                   3L)]
[10:32:25.260]             }
[10:32:25.260]             function(cond) {
[10:32:25.260]                 is_error <- inherits(cond, "error")
[10:32:25.260]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:25.260]                   NULL)
[10:32:25.260]                 if (is_error) {
[10:32:25.260]                   sessionInformation <- function() {
[10:32:25.260]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:25.260]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:25.260]                       search = base::search(), system = base::Sys.info())
[10:32:25.260]                   }
[10:32:25.260]                   ...future.conditions[[length(...future.conditions) + 
[10:32:25.260]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:25.260]                     cond$call), session = sessionInformation(), 
[10:32:25.260]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:25.260]                   signalCondition(cond)
[10:32:25.260]                 }
[10:32:25.260]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:25.260]                 "immediateCondition"))) {
[10:32:25.260]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:25.260]                   ...future.conditions[[length(...future.conditions) + 
[10:32:25.260]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:25.260]                   if (TRUE && !signal) {
[10:32:25.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:25.260]                     {
[10:32:25.260]                       inherits <- base::inherits
[10:32:25.260]                       invokeRestart <- base::invokeRestart
[10:32:25.260]                       is.null <- base::is.null
[10:32:25.260]                       muffled <- FALSE
[10:32:25.260]                       if (inherits(cond, "message")) {
[10:32:25.260]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:25.260]                         if (muffled) 
[10:32:25.260]                           invokeRestart("muffleMessage")
[10:32:25.260]                       }
[10:32:25.260]                       else if (inherits(cond, "warning")) {
[10:32:25.260]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:25.260]                         if (muffled) 
[10:32:25.260]                           invokeRestart("muffleWarning")
[10:32:25.260]                       }
[10:32:25.260]                       else if (inherits(cond, "condition")) {
[10:32:25.260]                         if (!is.null(pattern)) {
[10:32:25.260]                           computeRestarts <- base::computeRestarts
[10:32:25.260]                           grepl <- base::grepl
[10:32:25.260]                           restarts <- computeRestarts(cond)
[10:32:25.260]                           for (restart in restarts) {
[10:32:25.260]                             name <- restart$name
[10:32:25.260]                             if (is.null(name)) 
[10:32:25.260]                               next
[10:32:25.260]                             if (!grepl(pattern, name)) 
[10:32:25.260]                               next
[10:32:25.260]                             invokeRestart(restart)
[10:32:25.260]                             muffled <- TRUE
[10:32:25.260]                             break
[10:32:25.260]                           }
[10:32:25.260]                         }
[10:32:25.260]                       }
[10:32:25.260]                       invisible(muffled)
[10:32:25.260]                     }
[10:32:25.260]                     muffleCondition(cond, pattern = "^muffle")
[10:32:25.260]                   }
[10:32:25.260]                 }
[10:32:25.260]                 else {
[10:32:25.260]                   if (TRUE) {
[10:32:25.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:25.260]                     {
[10:32:25.260]                       inherits <- base::inherits
[10:32:25.260]                       invokeRestart <- base::invokeRestart
[10:32:25.260]                       is.null <- base::is.null
[10:32:25.260]                       muffled <- FALSE
[10:32:25.260]                       if (inherits(cond, "message")) {
[10:32:25.260]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:25.260]                         if (muffled) 
[10:32:25.260]                           invokeRestart("muffleMessage")
[10:32:25.260]                       }
[10:32:25.260]                       else if (inherits(cond, "warning")) {
[10:32:25.260]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:25.260]                         if (muffled) 
[10:32:25.260]                           invokeRestart("muffleWarning")
[10:32:25.260]                       }
[10:32:25.260]                       else if (inherits(cond, "condition")) {
[10:32:25.260]                         if (!is.null(pattern)) {
[10:32:25.260]                           computeRestarts <- base::computeRestarts
[10:32:25.260]                           grepl <- base::grepl
[10:32:25.260]                           restarts <- computeRestarts(cond)
[10:32:25.260]                           for (restart in restarts) {
[10:32:25.260]                             name <- restart$name
[10:32:25.260]                             if (is.null(name)) 
[10:32:25.260]                               next
[10:32:25.260]                             if (!grepl(pattern, name)) 
[10:32:25.260]                               next
[10:32:25.260]                             invokeRestart(restart)
[10:32:25.260]                             muffled <- TRUE
[10:32:25.260]                             break
[10:32:25.260]                           }
[10:32:25.260]                         }
[10:32:25.260]                       }
[10:32:25.260]                       invisible(muffled)
[10:32:25.260]                     }
[10:32:25.260]                     muffleCondition(cond, pattern = "^muffle")
[10:32:25.260]                   }
[10:32:25.260]                 }
[10:32:25.260]             }
[10:32:25.260]         }))
[10:32:25.260]     }, error = function(ex) {
[10:32:25.260]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:25.260]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:25.260]                 ...future.rng), started = ...future.startTime, 
[10:32:25.260]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:25.260]             version = "1.8"), class = "FutureResult")
[10:32:25.260]     }, finally = {
[10:32:25.260]         if (!identical(...future.workdir, getwd())) 
[10:32:25.260]             setwd(...future.workdir)
[10:32:25.260]         {
[10:32:25.260]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:25.260]                 ...future.oldOptions$nwarnings <- NULL
[10:32:25.260]             }
[10:32:25.260]             base::options(...future.oldOptions)
[10:32:25.260]             if (.Platform$OS.type == "windows") {
[10:32:25.260]                 old_names <- names(...future.oldEnvVars)
[10:32:25.260]                 envs <- base::Sys.getenv()
[10:32:25.260]                 names <- names(envs)
[10:32:25.260]                 common <- intersect(names, old_names)
[10:32:25.260]                 added <- setdiff(names, old_names)
[10:32:25.260]                 removed <- setdiff(old_names, names)
[10:32:25.260]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:25.260]                   envs[common]]
[10:32:25.260]                 NAMES <- toupper(changed)
[10:32:25.260]                 args <- list()
[10:32:25.260]                 for (kk in seq_along(NAMES)) {
[10:32:25.260]                   name <- changed[[kk]]
[10:32:25.260]                   NAME <- NAMES[[kk]]
[10:32:25.260]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:25.260]                     next
[10:32:25.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:25.260]                 }
[10:32:25.260]                 NAMES <- toupper(added)
[10:32:25.260]                 for (kk in seq_along(NAMES)) {
[10:32:25.260]                   name <- added[[kk]]
[10:32:25.260]                   NAME <- NAMES[[kk]]
[10:32:25.260]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:25.260]                     next
[10:32:25.260]                   args[[name]] <- ""
[10:32:25.260]                 }
[10:32:25.260]                 NAMES <- toupper(removed)
[10:32:25.260]                 for (kk in seq_along(NAMES)) {
[10:32:25.260]                   name <- removed[[kk]]
[10:32:25.260]                   NAME <- NAMES[[kk]]
[10:32:25.260]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:25.260]                     next
[10:32:25.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:25.260]                 }
[10:32:25.260]                 if (length(args) > 0) 
[10:32:25.260]                   base::do.call(base::Sys.setenv, args = args)
[10:32:25.260]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:25.260]             }
[10:32:25.260]             else {
[10:32:25.260]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:25.260]             }
[10:32:25.260]             {
[10:32:25.260]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:25.260]                   0L) {
[10:32:25.260]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:25.260]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:25.260]                   base::options(opts)
[10:32:25.260]                 }
[10:32:25.260]                 {
[10:32:25.260]                   {
[10:32:25.260]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:25.260]                     NULL
[10:32:25.260]                   }
[10:32:25.260]                   options(future.plan = NULL)
[10:32:25.260]                   if (is.na(NA_character_)) 
[10:32:25.260]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:25.260]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:25.260]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:25.260]                     .init = FALSE)
[10:32:25.260]                 }
[10:32:25.260]             }
[10:32:25.260]         }
[10:32:25.260]     })
[10:32:25.260]     if (TRUE) {
[10:32:25.260]         base::sink(type = "output", split = FALSE)
[10:32:25.260]         if (TRUE) {
[10:32:25.260]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:25.260]         }
[10:32:25.260]         else {
[10:32:25.260]             ...future.result["stdout"] <- base::list(NULL)
[10:32:25.260]         }
[10:32:25.260]         base::close(...future.stdout)
[10:32:25.260]         ...future.stdout <- NULL
[10:32:25.260]     }
[10:32:25.260]     ...future.result$conditions <- ...future.conditions
[10:32:25.260]     ...future.result$finished <- base::Sys.time()
[10:32:25.260]     ...future.result
[10:32:25.260] }
[10:32:25.312] MultisessionFuture started
[10:32:25.312] result() for ClusterFuture ...
[10:32:25.312] receiveMessageFromWorker() for ClusterFuture ...
[10:32:25.313] - Validating connection of MultisessionFuture
[10:32:25.345] - received message: FutureResult
[10:32:25.345] - Received FutureResult
[10:32:25.345] - Erased future from FutureRegistry
[10:32:25.345] result() for ClusterFuture ...
[10:32:25.346] - result already collected: FutureResult
[10:32:25.346] result() for ClusterFuture ... done
[10:32:25.346] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:25.346] result() for ClusterFuture ... done
[10:32:25.346] result() for ClusterFuture ...
[10:32:25.346] - result already collected: FutureResult
[10:32:25.346] result() for ClusterFuture ... done
[10:32:25.346] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:32:25.350] plan(): nbrOfWorkers() = 2


	demo(mandelbrot)
	---- ~~~~~~~~~~

> library("future")

> library("graphics")

> plot_what_is_done <- function(counts) {
+   for (kk in seq_along(counts)) {
+     f <- counts[[kk]]
+ 
+     ## Already plotted?
+     if (!inherits(f, "Future")) next
+ 
+     ## Not resolved?
+     if (!resolved(f)) next
+ 
+     message(sprintf("Plotting tile #%d of %d ...", kk, n))
+     counts[[kk]] <- value(f)
+     screen(kk)
+     plot(counts[[kk]])
+   }
+ 
+   counts
+ }

> ## Options
> region <- getOption("future.demo.mandelbrot.region", 1L)

> if (!is.list(region)) {
+   if (region == 1L) {
+     region <- list(xmid = -0.75, ymid = 0.0, side = 3.0)
+   } else if (region == 2L) {
+     region <- list(xmid = 0.283, ymid = -0.0095, side = 0.00026)
+   } else if (region == 3L) {
+     region <- list(xmid = 0.282989, ymid = -0.01, side = 3e-8)
+   }
+ }

> nrow <- getOption("future.demo.mandelbrot.nrow", 3L)

> resolution <- getOption("future.demo.mandelbrot.resolution", 400L)

> delay <- getOption("future.demo.mandelbrot.delay", interactive())

> if (isTRUE(delay)) {
+   delay <- function(counts) Sys.sleep(1.0)
+ } else if (!is.function(delay)) {
+   delay <- function(counts) {}
+ }

> ## Generate Mandelbrot tiles to be computed
> Cs <- mandelbrot_tiles(xmid = region$xmid, ymid = region$ymid,
+                        side = region$side, nrow = nrow,
+                        resolution = resolution)

> if (interactive()) {
+   dev.new()
+   plot.new()
+   split.screen(dim(Cs))
+   for (ii in seq_along(Cs)) {
+     screen(ii)
+     par(mar = c(0, 0, 0, 0))
+     text(x = 1 / 2, y = 1 / 2, sprintf("Future #%d\nunresolved", ii), cex = 2)
+   }
+ } else {
+   split.screen(dim(Cs))
+ }
[1]  9 10 11 12

> ## Create all Mandelbrot tiles via lazy futures
> n <- length(Cs)

> message(sprintf("Creating %d Mandelbrot tiles:", n), appendLF = FALSE)
Creating 4 Mandelbrot tiles:
> counts <- lapply(seq_along(Cs), FUN=function(ii) {
+   message(" ", ii, appendLF = FALSE)
+   C <- Cs[[ii]]
+   future({
+     message(sprintf("Calculating tile #%d of %d ...", ii, n), appendLF = FALSE)
+     fit <- mandelbrot(C)
+ 
+     ## Emulate slowness
+     delay(fit)
+ 
+     message(" done")
+     fit
+   }, lazy = TRUE)
+ })
 1[10:32:25.354] getGlobalsAndPackages() ...
[10:32:25.354] Searching for globals...
[10:32:25.357] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[10:32:25.357] Searching for globals ... DONE
[10:32:25.357] Resolving globals: FALSE
[10:32:25.358] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[10:32:25.358] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:32:25.358] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[10:32:25.359] - packages: [1] ‘future’
[10:32:25.359] getGlobalsAndPackages() ... DONE
 2[10:32:25.362] getGlobalsAndPackages() ...
[10:32:25.362] Searching for globals...
[10:32:25.366] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[10:32:25.366] Searching for globals ... DONE
[10:32:25.366] Resolving globals: FALSE
[10:32:25.366] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[10:32:25.367] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:32:25.367] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[10:32:25.367] - packages: [1] ‘future’
[10:32:25.367] getGlobalsAndPackages() ... DONE
 3[10:32:25.367] getGlobalsAndPackages() ...
[10:32:25.368] Searching for globals...
[10:32:25.371] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[10:32:25.371] Searching for globals ... DONE
[10:32:25.371] Resolving globals: FALSE
[10:32:25.371] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[10:32:25.372] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:32:25.372] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[10:32:25.372] - packages: [1] ‘future’
[10:32:25.372] getGlobalsAndPackages() ... DONE
 4[10:32:25.373] getGlobalsAndPackages() ...
[10:32:25.373] Searching for globals...
[10:32:25.376] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[10:32:25.376] Searching for globals ... DONE
[10:32:25.376] Resolving globals: FALSE
[10:32:25.377] The total size of the 4 globals is 14.24 KiB (14584 bytes)
[10:32:25.377] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 14.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘C’ (10.72 KiB of class ‘complex’), ‘delay’ (3.41 KiB of class ‘function’) and ‘ii’ (56 bytes of class ‘numeric’)
[10:32:25.377] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[10:32:25.377] - packages: [1] ‘future’
[10:32:25.377] getGlobalsAndPackages() ... DONE

> message(".")
.

> ## Calculate and plot tiles
> repeat {
+   counts <- plot_what_is_done(counts)
+   if (!any(sapply(counts, FUN = inherits, "Future"))) break
+ }
[10:32:25.388] resolved() for ‘Future’ ...
[10:32:25.388] - state: ‘created’
[10:32:25.388] - run: TRUE
[10:32:25.388] - run() ...
[10:32:25.388] run() for ‘Future’ ...
[10:32:25.388] - state: ‘created’
[10:32:25.388] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:25.402] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:25.402] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:25.402]   - Field: ‘node’
[10:32:25.402]   - Field: ‘label’
[10:32:25.402]   - Field: ‘local’
[10:32:25.403]   - Field: ‘owner’
[10:32:25.403]   - Field: ‘envir’
[10:32:25.403]   - Field: ‘workers’
[10:32:25.403]   - Field: ‘packages’
[10:32:25.403]   - Field: ‘gc’
[10:32:25.403]   - Field: ‘conditions’
[10:32:25.403]   - Field: ‘persistent’
[10:32:25.403]   - Field: ‘expr’
[10:32:25.403]   - Field: ‘uuid’
[10:32:25.403]   - Field: ‘seed’
[10:32:25.403]   - Field: ‘version’
[10:32:25.404]   - Field: ‘result’
[10:32:25.404]   - Field: ‘asynchronous’
[10:32:25.404]   - Field: ‘calls’
[10:32:25.404]   - Field: ‘globals’
[10:32:25.404]   - Field: ‘stdout’
[10:32:25.404]   - Field: ‘earlySignal’
[10:32:25.404]   - Field: ‘lazy’
[10:32:25.404]   - Field: ‘state’
[10:32:25.404] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:25.404] - Launch lazy future ...
[10:32:25.405] Packages needed by the future expression (n = 1): ‘future’
[10:32:25.405] Packages needed by future strategies (n = 0): <none>
[10:32:25.405] {
[10:32:25.405]     {
[10:32:25.405]         {
[10:32:25.405]             ...future.startTime <- base::Sys.time()
[10:32:25.405]             {
[10:32:25.405]                 {
[10:32:25.405]                   {
[10:32:25.405]                     {
[10:32:25.405]                       {
[10:32:25.405]                         base::local({
[10:32:25.405]                           has_future <- base::requireNamespace("future", 
[10:32:25.405]                             quietly = TRUE)
[10:32:25.405]                           if (has_future) {
[10:32:25.405]                             ns <- base::getNamespace("future")
[10:32:25.405]                             version <- ns[[".package"]][["version"]]
[10:32:25.405]                             if (is.null(version)) 
[10:32:25.405]                               version <- utils::packageVersion("future")
[10:32:25.405]                           }
[10:32:25.405]                           else {
[10:32:25.405]                             version <- NULL
[10:32:25.405]                           }
[10:32:25.405]                           if (!has_future || version < "1.8.0") {
[10:32:25.405]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:25.405]                               "", base::R.version$version.string), 
[10:32:25.405]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:25.405]                                 base::R.version$platform, 8 * 
[10:32:25.405]                                   base::.Machine$sizeof.pointer), 
[10:32:25.405]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:25.405]                                 "release", "version")], collapse = " "), 
[10:32:25.405]                               hostname = base::Sys.info()[["nodename"]])
[10:32:25.405]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:25.405]                               info)
[10:32:25.405]                             info <- base::paste(info, collapse = "; ")
[10:32:25.405]                             if (!has_future) {
[10:32:25.405]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:25.405]                                 info)
[10:32:25.405]                             }
[10:32:25.405]                             else {
[10:32:25.405]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:25.405]                                 info, version)
[10:32:25.405]                             }
[10:32:25.405]                             base::stop(msg)
[10:32:25.405]                           }
[10:32:25.405]                         })
[10:32:25.405]                       }
[10:32:25.405]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:25.405]                       base::options(mc.cores = 1L)
[10:32:25.405]                     }
[10:32:25.405]                     base::local({
[10:32:25.405]                       for (pkg in "future") {
[10:32:25.405]                         base::loadNamespace(pkg)
[10:32:25.405]                         base::library(pkg, character.only = TRUE)
[10:32:25.405]                       }
[10:32:25.405]                     })
[10:32:25.405]                   }
[10:32:25.405]                   ...future.strategy.old <- future::plan("list")
[10:32:25.405]                   options(future.plan = NULL)
[10:32:25.405]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:25.405]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:25.405]                 }
[10:32:25.405]                 ...future.workdir <- getwd()
[10:32:25.405]             }
[10:32:25.405]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:25.405]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:25.405]         }
[10:32:25.405]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:25.405]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:25.405]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:25.405]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:25.405]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:25.405]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:25.405]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:25.405]             base::names(...future.oldOptions))
[10:32:25.405]     }
[10:32:25.405]     if (FALSE) {
[10:32:25.405]     }
[10:32:25.405]     else {
[10:32:25.405]         if (TRUE) {
[10:32:25.405]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:25.405]                 open = "w")
[10:32:25.405]         }
[10:32:25.405]         else {
[10:32:25.405]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:25.405]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:25.405]         }
[10:32:25.405]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:25.405]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:25.405]             base::sink(type = "output", split = FALSE)
[10:32:25.405]             base::close(...future.stdout)
[10:32:25.405]         }, add = TRUE)
[10:32:25.405]     }
[10:32:25.405]     ...future.frame <- base::sys.nframe()
[10:32:25.405]     ...future.conditions <- base::list()
[10:32:25.405]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:25.405]     if (FALSE) {
[10:32:25.405]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:25.405]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:25.405]     }
[10:32:25.405]     ...future.result <- base::tryCatch({
[10:32:25.405]         base::withCallingHandlers({
[10:32:25.405]             ...future.value <- base::withVisible(base::local({
[10:32:25.405]                 ...future.makeSendCondition <- base::local({
[10:32:25.405]                   sendCondition <- NULL
[10:32:25.405]                   function(frame = 1L) {
[10:32:25.405]                     if (is.function(sendCondition)) 
[10:32:25.405]                       return(sendCondition)
[10:32:25.405]                     ns <- getNamespace("parallel")
[10:32:25.405]                     if (exists("sendData", mode = "function", 
[10:32:25.405]                       envir = ns)) {
[10:32:25.405]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:25.405]                         envir = ns)
[10:32:25.405]                       envir <- sys.frame(frame)
[10:32:25.405]                       master <- NULL
[10:32:25.405]                       while (!identical(envir, .GlobalEnv) && 
[10:32:25.405]                         !identical(envir, emptyenv())) {
[10:32:25.405]                         if (exists("master", mode = "list", envir = envir, 
[10:32:25.405]                           inherits = FALSE)) {
[10:32:25.405]                           master <- get("master", mode = "list", 
[10:32:25.405]                             envir = envir, inherits = FALSE)
[10:32:25.405]                           if (inherits(master, c("SOCKnode", 
[10:32:25.405]                             "SOCK0node"))) {
[10:32:25.405]                             sendCondition <<- function(cond) {
[10:32:25.405]                               data <- list(type = "VALUE", value = cond, 
[10:32:25.405]                                 success = TRUE)
[10:32:25.405]                               parallel_sendData(master, data)
[10:32:25.405]                             }
[10:32:25.405]                             return(sendCondition)
[10:32:25.405]                           }
[10:32:25.405]                         }
[10:32:25.405]                         frame <- frame + 1L
[10:32:25.405]                         envir <- sys.frame(frame)
[10:32:25.405]                       }
[10:32:25.405]                     }
[10:32:25.405]                     sendCondition <<- function(cond) NULL
[10:32:25.405]                   }
[10:32:25.405]                 })
[10:32:25.405]                 withCallingHandlers({
[10:32:25.405]                   {
[10:32:25.405]                     message(sprintf("Calculating tile #%d of %d ...", 
[10:32:25.405]                       ii, n), appendLF = FALSE)
[10:32:25.405]                     fit <- mandelbrot(C)
[10:32:25.405]                     delay(fit)
[10:32:25.405]                     message(" done")
[10:32:25.405]                     fit
[10:32:25.405]                   }
[10:32:25.405]                 }, immediateCondition = function(cond) {
[10:32:25.405]                   sendCondition <- ...future.makeSendCondition()
[10:32:25.405]                   sendCondition(cond)
[10:32:25.405]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:25.405]                   {
[10:32:25.405]                     inherits <- base::inherits
[10:32:25.405]                     invokeRestart <- base::invokeRestart
[10:32:25.405]                     is.null <- base::is.null
[10:32:25.405]                     muffled <- FALSE
[10:32:25.405]                     if (inherits(cond, "message")) {
[10:32:25.405]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:25.405]                       if (muffled) 
[10:32:25.405]                         invokeRestart("muffleMessage")
[10:32:25.405]                     }
[10:32:25.405]                     else if (inherits(cond, "warning")) {
[10:32:25.405]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:25.405]                       if (muffled) 
[10:32:25.405]                         invokeRestart("muffleWarning")
[10:32:25.405]                     }
[10:32:25.405]                     else if (inherits(cond, "condition")) {
[10:32:25.405]                       if (!is.null(pattern)) {
[10:32:25.405]                         computeRestarts <- base::computeRestarts
[10:32:25.405]                         grepl <- base::grepl
[10:32:25.405]                         restarts <- computeRestarts(cond)
[10:32:25.405]                         for (restart in restarts) {
[10:32:25.405]                           name <- restart$name
[10:32:25.405]                           if (is.null(name)) 
[10:32:25.405]                             next
[10:32:25.405]                           if (!grepl(pattern, name)) 
[10:32:25.405]                             next
[10:32:25.405]                           invokeRestart(restart)
[10:32:25.405]                           muffled <- TRUE
[10:32:25.405]                           break
[10:32:25.405]                         }
[10:32:25.405]                       }
[10:32:25.405]                     }
[10:32:25.405]                     invisible(muffled)
[10:32:25.405]                   }
[10:32:25.405]                   muffleCondition(cond)
[10:32:25.405]                 })
[10:32:25.405]             }))
[10:32:25.405]             future::FutureResult(value = ...future.value$value, 
[10:32:25.405]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:25.405]                   ...future.rng), globalenv = if (FALSE) 
[10:32:25.405]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:25.405]                     ...future.globalenv.names))
[10:32:25.405]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:25.405]         }, condition = base::local({
[10:32:25.405]             c <- base::c
[10:32:25.405]             inherits <- base::inherits
[10:32:25.405]             invokeRestart <- base::invokeRestart
[10:32:25.405]             length <- base::length
[10:32:25.405]             list <- base::list
[10:32:25.405]             seq.int <- base::seq.int
[10:32:25.405]             signalCondition <- base::signalCondition
[10:32:25.405]             sys.calls <- base::sys.calls
[10:32:25.405]             `[[` <- base::`[[`
[10:32:25.405]             `+` <- base::`+`
[10:32:25.405]             `<<-` <- base::`<<-`
[10:32:25.405]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:25.405]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:25.405]                   3L)]
[10:32:25.405]             }
[10:32:25.405]             function(cond) {
[10:32:25.405]                 is_error <- inherits(cond, "error")
[10:32:25.405]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:25.405]                   NULL)
[10:32:25.405]                 if (is_error) {
[10:32:25.405]                   sessionInformation <- function() {
[10:32:25.405]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:25.405]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:25.405]                       search = base::search(), system = base::Sys.info())
[10:32:25.405]                   }
[10:32:25.405]                   ...future.conditions[[length(...future.conditions) + 
[10:32:25.405]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:25.405]                     cond$call), session = sessionInformation(), 
[10:32:25.405]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:25.405]                   signalCondition(cond)
[10:32:25.405]                 }
[10:32:25.405]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:25.405]                 "immediateCondition"))) {
[10:32:25.405]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:25.405]                   ...future.conditions[[length(...future.conditions) + 
[10:32:25.405]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:25.405]                   if (TRUE && !signal) {
[10:32:25.405]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:25.405]                     {
[10:32:25.405]                       inherits <- base::inherits
[10:32:25.405]                       invokeRestart <- base::invokeRestart
[10:32:25.405]                       is.null <- base::is.null
[10:32:25.405]                       muffled <- FALSE
[10:32:25.405]                       if (inherits(cond, "message")) {
[10:32:25.405]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:25.405]                         if (muffled) 
[10:32:25.405]                           invokeRestart("muffleMessage")
[10:32:25.405]                       }
[10:32:25.405]                       else if (inherits(cond, "warning")) {
[10:32:25.405]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:25.405]                         if (muffled) 
[10:32:25.405]                           invokeRestart("muffleWarning")
[10:32:25.405]                       }
[10:32:25.405]                       else if (inherits(cond, "condition")) {
[10:32:25.405]                         if (!is.null(pattern)) {
[10:32:25.405]                           computeRestarts <- base::computeRestarts
[10:32:25.405]                           grepl <- base::grepl
[10:32:25.405]                           restarts <- computeRestarts(cond)
[10:32:25.405]                           for (restart in restarts) {
[10:32:25.405]                             name <- restart$name
[10:32:25.405]                             if (is.null(name)) 
[10:32:25.405]                               next
[10:32:25.405]                             if (!grepl(pattern, name)) 
[10:32:25.405]                               next
[10:32:25.405]                             invokeRestart(restart)
[10:32:25.405]                             muffled <- TRUE
[10:32:25.405]                             break
[10:32:25.405]                           }
[10:32:25.405]                         }
[10:32:25.405]                       }
[10:32:25.405]                       invisible(muffled)
[10:32:25.405]                     }
[10:32:25.405]                     muffleCondition(cond, pattern = "^muffle")
[10:32:25.405]                   }
[10:32:25.405]                 }
[10:32:25.405]                 else {
[10:32:25.405]                   if (TRUE) {
[10:32:25.405]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:25.405]                     {
[10:32:25.405]                       inherits <- base::inherits
[10:32:25.405]                       invokeRestart <- base::invokeRestart
[10:32:25.405]                       is.null <- base::is.null
[10:32:25.405]                       muffled <- FALSE
[10:32:25.405]                       if (inherits(cond, "message")) {
[10:32:25.405]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:25.405]                         if (muffled) 
[10:32:25.405]                           invokeRestart("muffleMessage")
[10:32:25.405]                       }
[10:32:25.405]                       else if (inherits(cond, "warning")) {
[10:32:25.405]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:25.405]                         if (muffled) 
[10:32:25.405]                           invokeRestart("muffleWarning")
[10:32:25.405]                       }
[10:32:25.405]                       else if (inherits(cond, "condition")) {
[10:32:25.405]                         if (!is.null(pattern)) {
[10:32:25.405]                           computeRestarts <- base::computeRestarts
[10:32:25.405]                           grepl <- base::grepl
[10:32:25.405]                           restarts <- computeRestarts(cond)
[10:32:25.405]                           for (restart in restarts) {
[10:32:25.405]                             name <- restart$name
[10:32:25.405]                             if (is.null(name)) 
[10:32:25.405]                               next
[10:32:25.405]                             if (!grepl(pattern, name)) 
[10:32:25.405]                               next
[10:32:25.405]                             invokeRestart(restart)
[10:32:25.405]                             muffled <- TRUE
[10:32:25.405]                             break
[10:32:25.405]                           }
[10:32:25.405]                         }
[10:32:25.405]                       }
[10:32:25.405]                       invisible(muffled)
[10:32:25.405]                     }
[10:32:25.405]                     muffleCondition(cond, pattern = "^muffle")
[10:32:25.405]                   }
[10:32:25.405]                 }
[10:32:25.405]             }
[10:32:25.405]         }))
[10:32:25.405]     }, error = function(ex) {
[10:32:25.405]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:25.405]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:25.405]                 ...future.rng), started = ...future.startTime, 
[10:32:25.405]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:25.405]             version = "1.8"), class = "FutureResult")
[10:32:25.405]     }, finally = {
[10:32:25.405]         if (!identical(...future.workdir, getwd())) 
[10:32:25.405]             setwd(...future.workdir)
[10:32:25.405]         {
[10:32:25.405]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:25.405]                 ...future.oldOptions$nwarnings <- NULL
[10:32:25.405]             }
[10:32:25.405]             base::options(...future.oldOptions)
[10:32:25.405]             if (.Platform$OS.type == "windows") {
[10:32:25.405]                 old_names <- names(...future.oldEnvVars)
[10:32:25.405]                 envs <- base::Sys.getenv()
[10:32:25.405]                 names <- names(envs)
[10:32:25.405]                 common <- intersect(names, old_names)
[10:32:25.405]                 added <- setdiff(names, old_names)
[10:32:25.405]                 removed <- setdiff(old_names, names)
[10:32:25.405]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:25.405]                   envs[common]]
[10:32:25.405]                 NAMES <- toupper(changed)
[10:32:25.405]                 args <- list()
[10:32:25.405]                 for (kk in seq_along(NAMES)) {
[10:32:25.405]                   name <- changed[[kk]]
[10:32:25.405]                   NAME <- NAMES[[kk]]
[10:32:25.405]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:25.405]                     next
[10:32:25.405]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:25.405]                 }
[10:32:25.405]                 NAMES <- toupper(added)
[10:32:25.405]                 for (kk in seq_along(NAMES)) {
[10:32:25.405]                   name <- added[[kk]]
[10:32:25.405]                   NAME <- NAMES[[kk]]
[10:32:25.405]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:25.405]                     next
[10:32:25.405]                   args[[name]] <- ""
[10:32:25.405]                 }
[10:32:25.405]                 NAMES <- toupper(removed)
[10:32:25.405]                 for (kk in seq_along(NAMES)) {
[10:32:25.405]                   name <- removed[[kk]]
[10:32:25.405]                   NAME <- NAMES[[kk]]
[10:32:25.405]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:25.405]                     next
[10:32:25.405]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:25.405]                 }
[10:32:25.405]                 if (length(args) > 0) 
[10:32:25.405]                   base::do.call(base::Sys.setenv, args = args)
[10:32:25.405]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:25.405]             }
[10:32:25.405]             else {
[10:32:25.405]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:25.405]             }
[10:32:25.405]             {
[10:32:25.405]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:25.405]                   0L) {
[10:32:25.405]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:25.405]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:25.405]                   base::options(opts)
[10:32:25.405]                 }
[10:32:25.405]                 {
[10:32:25.405]                   {
[10:32:25.405]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:25.405]                     NULL
[10:32:25.405]                   }
[10:32:25.405]                   options(future.plan = NULL)
[10:32:25.405]                   if (is.na(NA_character_)) 
[10:32:25.405]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:25.405]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:25.405]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:25.405]                     .init = FALSE)
[10:32:25.405]                 }
[10:32:25.405]             }
[10:32:25.405]         }
[10:32:25.405]     })
[10:32:25.405]     if (TRUE) {
[10:32:25.405]         base::sink(type = "output", split = FALSE)
[10:32:25.405]         if (TRUE) {
[10:32:25.405]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:25.405]         }
[10:32:25.405]         else {
[10:32:25.405]             ...future.result["stdout"] <- base::list(NULL)
[10:32:25.405]         }
[10:32:25.405]         base::close(...future.stdout)
[10:32:25.405]         ...future.stdout <- NULL
[10:32:25.405]     }
[10:32:25.405]     ...future.result$conditions <- ...future.conditions
[10:32:25.405]     ...future.result$finished <- base::Sys.time()
[10:32:25.405]     ...future.result
[10:32:25.405] }
[10:32:25.408] Exporting 4 global objects (14.24 KiB) to cluster node #1 ...
[10:32:25.408] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[10:32:25.408] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[10:32:25.409] Exporting ‘n’ (56 bytes) to cluster node #1 ...
[10:32:25.409] Exporting ‘n’ (56 bytes) to cluster node #1 ... DONE
[10:32:25.409] Exporting ‘C’ (10.72 KiB) to cluster node #1 ...
[10:32:25.453] Exporting ‘C’ (10.72 KiB) to cluster node #1 ... DONE
[10:32:25.453] Exporting ‘delay’ (3.41 KiB) to cluster node #1 ...
[10:32:25.497] Exporting ‘delay’ (3.41 KiB) to cluster node #1 ... DONE
[10:32:25.497] Exporting 4 global objects (14.24 KiB) to cluster node #1 ... DONE
[10:32:25.498] MultisessionFuture started
[10:32:25.498] - Launch lazy future ... done
[10:32:25.499] run() for ‘MultisessionFuture’ ... done
[10:32:25.499] - run() ... done
[10:32:25.499] - resolved() ...
[10:32:25.510] - resolved: FALSE
[10:32:25.510] - resolved() ... done
[10:32:25.510] resolved() for ‘MultisessionFuture’ ... done
[10:32:25.510] resolved() for ‘Future’ ...
[10:32:25.510] - state: ‘created’
[10:32:25.510] - run: TRUE
[10:32:25.510] - run() ...
[10:32:25.510] run() for ‘Future’ ...
[10:32:25.510] - state: ‘created’
[10:32:25.511] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:25.524] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:25.524] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:25.525]   - Field: ‘node’
[10:32:25.525]   - Field: ‘label’
[10:32:25.525]   - Field: ‘local’
[10:32:25.525]   - Field: ‘owner’
[10:32:25.525]   - Field: ‘envir’
[10:32:25.525]   - Field: ‘workers’
[10:32:25.525]   - Field: ‘packages’
[10:32:25.525]   - Field: ‘gc’
[10:32:25.525]   - Field: ‘conditions’
[10:32:25.525]   - Field: ‘persistent’
[10:32:25.526]   - Field: ‘expr’
[10:32:25.526]   - Field: ‘uuid’
[10:32:25.526]   - Field: ‘seed’
[10:32:25.526]   - Field: ‘version’
[10:32:25.526]   - Field: ‘result’
[10:32:25.526]   - Field: ‘asynchronous’
[10:32:25.526]   - Field: ‘calls’
[10:32:25.526]   - Field: ‘globals’
[10:32:25.526]   - Field: ‘stdout’
[10:32:25.526]   - Field: ‘earlySignal’
[10:32:25.526]   - Field: ‘lazy’
[10:32:25.527]   - Field: ‘state’
[10:32:25.527] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:25.527] - Launch lazy future ...
[10:32:25.527] Packages needed by the future expression (n = 1): ‘future’
[10:32:25.527] Packages needed by future strategies (n = 0): <none>
[10:32:25.528] {
[10:32:25.528]     {
[10:32:25.528]         {
[10:32:25.528]             ...future.startTime <- base::Sys.time()
[10:32:25.528]             {
[10:32:25.528]                 {
[10:32:25.528]                   {
[10:32:25.528]                     {
[10:32:25.528]                       {
[10:32:25.528]                         base::local({
[10:32:25.528]                           has_future <- base::requireNamespace("future", 
[10:32:25.528]                             quietly = TRUE)
[10:32:25.528]                           if (has_future) {
[10:32:25.528]                             ns <- base::getNamespace("future")
[10:32:25.528]                             version <- ns[[".package"]][["version"]]
[10:32:25.528]                             if (is.null(version)) 
[10:32:25.528]                               version <- utils::packageVersion("future")
[10:32:25.528]                           }
[10:32:25.528]                           else {
[10:32:25.528]                             version <- NULL
[10:32:25.528]                           }
[10:32:25.528]                           if (!has_future || version < "1.8.0") {
[10:32:25.528]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:25.528]                               "", base::R.version$version.string), 
[10:32:25.528]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:25.528]                                 base::R.version$platform, 8 * 
[10:32:25.528]                                   base::.Machine$sizeof.pointer), 
[10:32:25.528]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:25.528]                                 "release", "version")], collapse = " "), 
[10:32:25.528]                               hostname = base::Sys.info()[["nodename"]])
[10:32:25.528]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:25.528]                               info)
[10:32:25.528]                             info <- base::paste(info, collapse = "; ")
[10:32:25.528]                             if (!has_future) {
[10:32:25.528]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:25.528]                                 info)
[10:32:25.528]                             }
[10:32:25.528]                             else {
[10:32:25.528]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:25.528]                                 info, version)
[10:32:25.528]                             }
[10:32:25.528]                             base::stop(msg)
[10:32:25.528]                           }
[10:32:25.528]                         })
[10:32:25.528]                       }
[10:32:25.528]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:25.528]                       base::options(mc.cores = 1L)
[10:32:25.528]                     }
[10:32:25.528]                     base::local({
[10:32:25.528]                       for (pkg in "future") {
[10:32:25.528]                         base::loadNamespace(pkg)
[10:32:25.528]                         base::library(pkg, character.only = TRUE)
[10:32:25.528]                       }
[10:32:25.528]                     })
[10:32:25.528]                   }
[10:32:25.528]                   ...future.strategy.old <- future::plan("list")
[10:32:25.528]                   options(future.plan = NULL)
[10:32:25.528]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:25.528]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:25.528]                 }
[10:32:25.528]                 ...future.workdir <- getwd()
[10:32:25.528]             }
[10:32:25.528]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:25.528]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:25.528]         }
[10:32:25.528]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:25.528]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:25.528]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:25.528]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:25.528]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:25.528]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:25.528]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:25.528]             base::names(...future.oldOptions))
[10:32:25.528]     }
[10:32:25.528]     if (FALSE) {
[10:32:25.528]     }
[10:32:25.528]     else {
[10:32:25.528]         if (TRUE) {
[10:32:25.528]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:25.528]                 open = "w")
[10:32:25.528]         }
[10:32:25.528]         else {
[10:32:25.528]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:25.528]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:25.528]         }
[10:32:25.528]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:25.528]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:25.528]             base::sink(type = "output", split = FALSE)
[10:32:25.528]             base::close(...future.stdout)
[10:32:25.528]         }, add = TRUE)
[10:32:25.528]     }
[10:32:25.528]     ...future.frame <- base::sys.nframe()
[10:32:25.528]     ...future.conditions <- base::list()
[10:32:25.528]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:25.528]     if (FALSE) {
[10:32:25.528]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:25.528]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:25.528]     }
[10:32:25.528]     ...future.result <- base::tryCatch({
[10:32:25.528]         base::withCallingHandlers({
[10:32:25.528]             ...future.value <- base::withVisible(base::local({
[10:32:25.528]                 ...future.makeSendCondition <- base::local({
[10:32:25.528]                   sendCondition <- NULL
[10:32:25.528]                   function(frame = 1L) {
[10:32:25.528]                     if (is.function(sendCondition)) 
[10:32:25.528]                       return(sendCondition)
[10:32:25.528]                     ns <- getNamespace("parallel")
[10:32:25.528]                     if (exists("sendData", mode = "function", 
[10:32:25.528]                       envir = ns)) {
[10:32:25.528]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:25.528]                         envir = ns)
[10:32:25.528]                       envir <- sys.frame(frame)
[10:32:25.528]                       master <- NULL
[10:32:25.528]                       while (!identical(envir, .GlobalEnv) && 
[10:32:25.528]                         !identical(envir, emptyenv())) {
[10:32:25.528]                         if (exists("master", mode = "list", envir = envir, 
[10:32:25.528]                           inherits = FALSE)) {
[10:32:25.528]                           master <- get("master", mode = "list", 
[10:32:25.528]                             envir = envir, inherits = FALSE)
[10:32:25.528]                           if (inherits(master, c("SOCKnode", 
[10:32:25.528]                             "SOCK0node"))) {
[10:32:25.528]                             sendCondition <<- function(cond) {
[10:32:25.528]                               data <- list(type = "VALUE", value = cond, 
[10:32:25.528]                                 success = TRUE)
[10:32:25.528]                               parallel_sendData(master, data)
[10:32:25.528]                             }
[10:32:25.528]                             return(sendCondition)
[10:32:25.528]                           }
[10:32:25.528]                         }
[10:32:25.528]                         frame <- frame + 1L
[10:32:25.528]                         envir <- sys.frame(frame)
[10:32:25.528]                       }
[10:32:25.528]                     }
[10:32:25.528]                     sendCondition <<- function(cond) NULL
[10:32:25.528]                   }
[10:32:25.528]                 })
[10:32:25.528]                 withCallingHandlers({
[10:32:25.528]                   {
[10:32:25.528]                     message(sprintf("Calculating tile #%d of %d ...", 
[10:32:25.528]                       ii, n), appendLF = FALSE)
[10:32:25.528]                     fit <- mandelbrot(C)
[10:32:25.528]                     delay(fit)
[10:32:25.528]                     message(" done")
[10:32:25.528]                     fit
[10:32:25.528]                   }
[10:32:25.528]                 }, immediateCondition = function(cond) {
[10:32:25.528]                   sendCondition <- ...future.makeSendCondition()
[10:32:25.528]                   sendCondition(cond)
[10:32:25.528]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:25.528]                   {
[10:32:25.528]                     inherits <- base::inherits
[10:32:25.528]                     invokeRestart <- base::invokeRestart
[10:32:25.528]                     is.null <- base::is.null
[10:32:25.528]                     muffled <- FALSE
[10:32:25.528]                     if (inherits(cond, "message")) {
[10:32:25.528]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:25.528]                       if (muffled) 
[10:32:25.528]                         invokeRestart("muffleMessage")
[10:32:25.528]                     }
[10:32:25.528]                     else if (inherits(cond, "warning")) {
[10:32:25.528]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:25.528]                       if (muffled) 
[10:32:25.528]                         invokeRestart("muffleWarning")
[10:32:25.528]                     }
[10:32:25.528]                     else if (inherits(cond, "condition")) {
[10:32:25.528]                       if (!is.null(pattern)) {
[10:32:25.528]                         computeRestarts <- base::computeRestarts
[10:32:25.528]                         grepl <- base::grepl
[10:32:25.528]                         restarts <- computeRestarts(cond)
[10:32:25.528]                         for (restart in restarts) {
[10:32:25.528]                           name <- restart$name
[10:32:25.528]                           if (is.null(name)) 
[10:32:25.528]                             next
[10:32:25.528]                           if (!grepl(pattern, name)) 
[10:32:25.528]                             next
[10:32:25.528]                           invokeRestart(restart)
[10:32:25.528]                           muffled <- TRUE
[10:32:25.528]                           break
[10:32:25.528]                         }
[10:32:25.528]                       }
[10:32:25.528]                     }
[10:32:25.528]                     invisible(muffled)
[10:32:25.528]                   }
[10:32:25.528]                   muffleCondition(cond)
[10:32:25.528]                 })
[10:32:25.528]             }))
[10:32:25.528]             future::FutureResult(value = ...future.value$value, 
[10:32:25.528]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:25.528]                   ...future.rng), globalenv = if (FALSE) 
[10:32:25.528]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:25.528]                     ...future.globalenv.names))
[10:32:25.528]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:25.528]         }, condition = base::local({
[10:32:25.528]             c <- base::c
[10:32:25.528]             inherits <- base::inherits
[10:32:25.528]             invokeRestart <- base::invokeRestart
[10:32:25.528]             length <- base::length
[10:32:25.528]             list <- base::list
[10:32:25.528]             seq.int <- base::seq.int
[10:32:25.528]             signalCondition <- base::signalCondition
[10:32:25.528]             sys.calls <- base::sys.calls
[10:32:25.528]             `[[` <- base::`[[`
[10:32:25.528]             `+` <- base::`+`
[10:32:25.528]             `<<-` <- base::`<<-`
[10:32:25.528]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:25.528]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:25.528]                   3L)]
[10:32:25.528]             }
[10:32:25.528]             function(cond) {
[10:32:25.528]                 is_error <- inherits(cond, "error")
[10:32:25.528]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:25.528]                   NULL)
[10:32:25.528]                 if (is_error) {
[10:32:25.528]                   sessionInformation <- function() {
[10:32:25.528]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:25.528]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:25.528]                       search = base::search(), system = base::Sys.info())
[10:32:25.528]                   }
[10:32:25.528]                   ...future.conditions[[length(...future.conditions) + 
[10:32:25.528]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:25.528]                     cond$call), session = sessionInformation(), 
[10:32:25.528]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:25.528]                   signalCondition(cond)
[10:32:25.528]                 }
[10:32:25.528]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:25.528]                 "immediateCondition"))) {
[10:32:25.528]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:25.528]                   ...future.conditions[[length(...future.conditions) + 
[10:32:25.528]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:25.528]                   if (TRUE && !signal) {
[10:32:25.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:25.528]                     {
[10:32:25.528]                       inherits <- base::inherits
[10:32:25.528]                       invokeRestart <- base::invokeRestart
[10:32:25.528]                       is.null <- base::is.null
[10:32:25.528]                       muffled <- FALSE
[10:32:25.528]                       if (inherits(cond, "message")) {
[10:32:25.528]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:25.528]                         if (muffled) 
[10:32:25.528]                           invokeRestart("muffleMessage")
[10:32:25.528]                       }
[10:32:25.528]                       else if (inherits(cond, "warning")) {
[10:32:25.528]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:25.528]                         if (muffled) 
[10:32:25.528]                           invokeRestart("muffleWarning")
[10:32:25.528]                       }
[10:32:25.528]                       else if (inherits(cond, "condition")) {
[10:32:25.528]                         if (!is.null(pattern)) {
[10:32:25.528]                           computeRestarts <- base::computeRestarts
[10:32:25.528]                           grepl <- base::grepl
[10:32:25.528]                           restarts <- computeRestarts(cond)
[10:32:25.528]                           for (restart in restarts) {
[10:32:25.528]                             name <- restart$name
[10:32:25.528]                             if (is.null(name)) 
[10:32:25.528]                               next
[10:32:25.528]                             if (!grepl(pattern, name)) 
[10:32:25.528]                               next
[10:32:25.528]                             invokeRestart(restart)
[10:32:25.528]                             muffled <- TRUE
[10:32:25.528]                             break
[10:32:25.528]                           }
[10:32:25.528]                         }
[10:32:25.528]                       }
[10:32:25.528]                       invisible(muffled)
[10:32:25.528]                     }
[10:32:25.528]                     muffleCondition(cond, pattern = "^muffle")
[10:32:25.528]                   }
[10:32:25.528]                 }
[10:32:25.528]                 else {
[10:32:25.528]                   if (TRUE) {
[10:32:25.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:25.528]                     {
[10:32:25.528]                       inherits <- base::inherits
[10:32:25.528]                       invokeRestart <- base::invokeRestart
[10:32:25.528]                       is.null <- base::is.null
[10:32:25.528]                       muffled <- FALSE
[10:32:25.528]                       if (inherits(cond, "message")) {
[10:32:25.528]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:25.528]                         if (muffled) 
[10:32:25.528]                           invokeRestart("muffleMessage")
[10:32:25.528]                       }
[10:32:25.528]                       else if (inherits(cond, "warning")) {
[10:32:25.528]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:25.528]                         if (muffled) 
[10:32:25.528]                           invokeRestart("muffleWarning")
[10:32:25.528]                       }
[10:32:25.528]                       else if (inherits(cond, "condition")) {
[10:32:25.528]                         if (!is.null(pattern)) {
[10:32:25.528]                           computeRestarts <- base::computeRestarts
[10:32:25.528]                           grepl <- base::grepl
[10:32:25.528]                           restarts <- computeRestarts(cond)
[10:32:25.528]                           for (restart in restarts) {
[10:32:25.528]                             name <- restart$name
[10:32:25.528]                             if (is.null(name)) 
[10:32:25.528]                               next
[10:32:25.528]                             if (!grepl(pattern, name)) 
[10:32:25.528]                               next
[10:32:25.528]                             invokeRestart(restart)
[10:32:25.528]                             muffled <- TRUE
[10:32:25.528]                             break
[10:32:25.528]                           }
[10:32:25.528]                         }
[10:32:25.528]                       }
[10:32:25.528]                       invisible(muffled)
[10:32:25.528]                     }
[10:32:25.528]                     muffleCondition(cond, pattern = "^muffle")
[10:32:25.528]                   }
[10:32:25.528]                 }
[10:32:25.528]             }
[10:32:25.528]         }))
[10:32:25.528]     }, error = function(ex) {
[10:32:25.528]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:25.528]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:25.528]                 ...future.rng), started = ...future.startTime, 
[10:32:25.528]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:25.528]             version = "1.8"), class = "FutureResult")
[10:32:25.528]     }, finally = {
[10:32:25.528]         if (!identical(...future.workdir, getwd())) 
[10:32:25.528]             setwd(...future.workdir)
[10:32:25.528]         {
[10:32:25.528]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:25.528]                 ...future.oldOptions$nwarnings <- NULL
[10:32:25.528]             }
[10:32:25.528]             base::options(...future.oldOptions)
[10:32:25.528]             if (.Platform$OS.type == "windows") {
[10:32:25.528]                 old_names <- names(...future.oldEnvVars)
[10:32:25.528]                 envs <- base::Sys.getenv()
[10:32:25.528]                 names <- names(envs)
[10:32:25.528]                 common <- intersect(names, old_names)
[10:32:25.528]                 added <- setdiff(names, old_names)
[10:32:25.528]                 removed <- setdiff(old_names, names)
[10:32:25.528]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:25.528]                   envs[common]]
[10:32:25.528]                 NAMES <- toupper(changed)
[10:32:25.528]                 args <- list()
[10:32:25.528]                 for (kk in seq_along(NAMES)) {
[10:32:25.528]                   name <- changed[[kk]]
[10:32:25.528]                   NAME <- NAMES[[kk]]
[10:32:25.528]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:25.528]                     next
[10:32:25.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:25.528]                 }
[10:32:25.528]                 NAMES <- toupper(added)
[10:32:25.528]                 for (kk in seq_along(NAMES)) {
[10:32:25.528]                   name <- added[[kk]]
[10:32:25.528]                   NAME <- NAMES[[kk]]
[10:32:25.528]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:25.528]                     next
[10:32:25.528]                   args[[name]] <- ""
[10:32:25.528]                 }
[10:32:25.528]                 NAMES <- toupper(removed)
[10:32:25.528]                 for (kk in seq_along(NAMES)) {
[10:32:25.528]                   name <- removed[[kk]]
[10:32:25.528]                   NAME <- NAMES[[kk]]
[10:32:25.528]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:25.528]                     next
[10:32:25.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:25.528]                 }
[10:32:25.528]                 if (length(args) > 0) 
[10:32:25.528]                   base::do.call(base::Sys.setenv, args = args)
[10:32:25.528]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:25.528]             }
[10:32:25.528]             else {
[10:32:25.528]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:25.528]             }
[10:32:25.528]             {
[10:32:25.528]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:25.528]                   0L) {
[10:32:25.528]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:25.528]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:25.528]                   base::options(opts)
[10:32:25.528]                 }
[10:32:25.528]                 {
[10:32:25.528]                   {
[10:32:25.528]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:25.528]                     NULL
[10:32:25.528]                   }
[10:32:25.528]                   options(future.plan = NULL)
[10:32:25.528]                   if (is.na(NA_character_)) 
[10:32:25.528]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:25.528]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:25.528]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:25.528]                     .init = FALSE)
[10:32:25.528]                 }
[10:32:25.528]             }
[10:32:25.528]         }
[10:32:25.528]     })
[10:32:25.528]     if (TRUE) {
[10:32:25.528]         base::sink(type = "output", split = FALSE)
[10:32:25.528]         if (TRUE) {
[10:32:25.528]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:25.528]         }
[10:32:25.528]         else {
[10:32:25.528]             ...future.result["stdout"] <- base::list(NULL)
[10:32:25.528]         }
[10:32:25.528]         base::close(...future.stdout)
[10:32:25.528]         ...future.stdout <- NULL
[10:32:25.528]     }
[10:32:25.528]     ...future.result$conditions <- ...future.conditions
[10:32:25.528]     ...future.result$finished <- base::Sys.time()
[10:32:25.528]     ...future.result
[10:32:25.528] }
[10:32:25.580] Exporting 4 global objects (14.24 KiB) to cluster node #2 ...
[10:32:25.580] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[10:32:25.581] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[10:32:25.581] Exporting ‘n’ (56 bytes) to cluster node #2 ...
[10:32:25.581] Exporting ‘n’ (56 bytes) to cluster node #2 ... DONE
[10:32:25.582] Exporting ‘C’ (10.72 KiB) to cluster node #2 ...
[10:32:25.625] Exporting ‘C’ (10.72 KiB) to cluster node #2 ... DONE
[10:32:25.625] Exporting ‘delay’ (3.41 KiB) to cluster node #2 ...
[10:32:25.669] Exporting ‘delay’ (3.41 KiB) to cluster node #2 ... DONE
[10:32:25.669] Exporting 4 global objects (14.24 KiB) to cluster node #2 ... DONE
[10:32:25.670] MultisessionFuture started
[10:32:25.670] - Launch lazy future ... done
[10:32:25.670] run() for ‘MultisessionFuture’ ... done
[10:32:25.671] - run() ... done
[10:32:25.671] - resolved() ...
[10:32:25.681] - resolved: FALSE
[10:32:25.681] - resolved() ... done
[10:32:25.681] resolved() for ‘MultisessionFuture’ ... done
[10:32:25.682] resolved() for ‘Future’ ...
[10:32:25.682] - state: ‘created’
[10:32:25.682] - run: TRUE
[10:32:25.682] - run() ...
[10:32:25.682] run() for ‘Future’ ...
[10:32:25.682] - state: ‘created’
[10:32:25.682] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:25.696] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:25.696] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:25.696]   - Field: ‘node’
[10:32:25.697]   - Field: ‘label’
[10:32:25.697]   - Field: ‘local’
[10:32:25.697]   - Field: ‘owner’
[10:32:25.697]   - Field: ‘envir’
[10:32:25.697]   - Field: ‘workers’
[10:32:25.697]   - Field: ‘packages’
[10:32:25.697]   - Field: ‘gc’
[10:32:25.697]   - Field: ‘conditions’
[10:32:25.697]   - Field: ‘persistent’
[10:32:25.697]   - Field: ‘expr’
[10:32:25.697]   - Field: ‘uuid’
[10:32:25.698]   - Field: ‘seed’
[10:32:25.698]   - Field: ‘version’
[10:32:25.698]   - Field: ‘result’
[10:32:25.698]   - Field: ‘asynchronous’
[10:32:25.698]   - Field: ‘calls’
[10:32:25.698]   - Field: ‘globals’
[10:32:25.698]   - Field: ‘stdout’
[10:32:25.698]   - Field: ‘earlySignal’
[10:32:25.698]   - Field: ‘lazy’
[10:32:25.698]   - Field: ‘state’
[10:32:25.698] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:25.699] - Launch lazy future ...
[10:32:25.699] Packages needed by the future expression (n = 1): ‘future’
[10:32:25.699] Packages needed by future strategies (n = 0): <none>
[10:32:25.699] {
[10:32:25.699]     {
[10:32:25.699]         {
[10:32:25.699]             ...future.startTime <- base::Sys.time()
[10:32:25.699]             {
[10:32:25.699]                 {
[10:32:25.699]                   {
[10:32:25.699]                     {
[10:32:25.699]                       {
[10:32:25.699]                         base::local({
[10:32:25.699]                           has_future <- base::requireNamespace("future", 
[10:32:25.699]                             quietly = TRUE)
[10:32:25.699]                           if (has_future) {
[10:32:25.699]                             ns <- base::getNamespace("future")
[10:32:25.699]                             version <- ns[[".package"]][["version"]]
[10:32:25.699]                             if (is.null(version)) 
[10:32:25.699]                               version <- utils::packageVersion("future")
[10:32:25.699]                           }
[10:32:25.699]                           else {
[10:32:25.699]                             version <- NULL
[10:32:25.699]                           }
[10:32:25.699]                           if (!has_future || version < "1.8.0") {
[10:32:25.699]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:25.699]                               "", base::R.version$version.string), 
[10:32:25.699]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:25.699]                                 base::R.version$platform, 8 * 
[10:32:25.699]                                   base::.Machine$sizeof.pointer), 
[10:32:25.699]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:25.699]                                 "release", "version")], collapse = " "), 
[10:32:25.699]                               hostname = base::Sys.info()[["nodename"]])
[10:32:25.699]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:25.699]                               info)
[10:32:25.699]                             info <- base::paste(info, collapse = "; ")
[10:32:25.699]                             if (!has_future) {
[10:32:25.699]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:25.699]                                 info)
[10:32:25.699]                             }
[10:32:25.699]                             else {
[10:32:25.699]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:25.699]                                 info, version)
[10:32:25.699]                             }
[10:32:25.699]                             base::stop(msg)
[10:32:25.699]                           }
[10:32:25.699]                         })
[10:32:25.699]                       }
[10:32:25.699]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:25.699]                       base::options(mc.cores = 1L)
[10:32:25.699]                     }
[10:32:25.699]                     base::local({
[10:32:25.699]                       for (pkg in "future") {
[10:32:25.699]                         base::loadNamespace(pkg)
[10:32:25.699]                         base::library(pkg, character.only = TRUE)
[10:32:25.699]                       }
[10:32:25.699]                     })
[10:32:25.699]                   }
[10:32:25.699]                   ...future.strategy.old <- future::plan("list")
[10:32:25.699]                   options(future.plan = NULL)
[10:32:25.699]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:25.699]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:25.699]                 }
[10:32:25.699]                 ...future.workdir <- getwd()
[10:32:25.699]             }
[10:32:25.699]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:25.699]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:25.699]         }
[10:32:25.699]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:25.699]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:25.699]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:25.699]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:25.699]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:25.699]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:25.699]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:25.699]             base::names(...future.oldOptions))
[10:32:25.699]     }
[10:32:25.699]     if (FALSE) {
[10:32:25.699]     }
[10:32:25.699]     else {
[10:32:25.699]         if (TRUE) {
[10:32:25.699]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:25.699]                 open = "w")
[10:32:25.699]         }
[10:32:25.699]         else {
[10:32:25.699]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:25.699]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:25.699]         }
[10:32:25.699]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:25.699]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:25.699]             base::sink(type = "output", split = FALSE)
[10:32:25.699]             base::close(...future.stdout)
[10:32:25.699]         }, add = TRUE)
[10:32:25.699]     }
[10:32:25.699]     ...future.frame <- base::sys.nframe()
[10:32:25.699]     ...future.conditions <- base::list()
[10:32:25.699]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:25.699]     if (FALSE) {
[10:32:25.699]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:25.699]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:25.699]     }
[10:32:25.699]     ...future.result <- base::tryCatch({
[10:32:25.699]         base::withCallingHandlers({
[10:32:25.699]             ...future.value <- base::withVisible(base::local({
[10:32:25.699]                 ...future.makeSendCondition <- base::local({
[10:32:25.699]                   sendCondition <- NULL
[10:32:25.699]                   function(frame = 1L) {
[10:32:25.699]                     if (is.function(sendCondition)) 
[10:32:25.699]                       return(sendCondition)
[10:32:25.699]                     ns <- getNamespace("parallel")
[10:32:25.699]                     if (exists("sendData", mode = "function", 
[10:32:25.699]                       envir = ns)) {
[10:32:25.699]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:25.699]                         envir = ns)
[10:32:25.699]                       envir <- sys.frame(frame)
[10:32:25.699]                       master <- NULL
[10:32:25.699]                       while (!identical(envir, .GlobalEnv) && 
[10:32:25.699]                         !identical(envir, emptyenv())) {
[10:32:25.699]                         if (exists("master", mode = "list", envir = envir, 
[10:32:25.699]                           inherits = FALSE)) {
[10:32:25.699]                           master <- get("master", mode = "list", 
[10:32:25.699]                             envir = envir, inherits = FALSE)
[10:32:25.699]                           if (inherits(master, c("SOCKnode", 
[10:32:25.699]                             "SOCK0node"))) {
[10:32:25.699]                             sendCondition <<- function(cond) {
[10:32:25.699]                               data <- list(type = "VALUE", value = cond, 
[10:32:25.699]                                 success = TRUE)
[10:32:25.699]                               parallel_sendData(master, data)
[10:32:25.699]                             }
[10:32:25.699]                             return(sendCondition)
[10:32:25.699]                           }
[10:32:25.699]                         }
[10:32:25.699]                         frame <- frame + 1L
[10:32:25.699]                         envir <- sys.frame(frame)
[10:32:25.699]                       }
[10:32:25.699]                     }
[10:32:25.699]                     sendCondition <<- function(cond) NULL
[10:32:25.699]                   }
[10:32:25.699]                 })
[10:32:25.699]                 withCallingHandlers({
[10:32:25.699]                   {
[10:32:25.699]                     message(sprintf("Calculating tile #%d of %d ...", 
[10:32:25.699]                       ii, n), appendLF = FALSE)
[10:32:25.699]                     fit <- mandelbrot(C)
[10:32:25.699]                     delay(fit)
[10:32:25.699]                     message(" done")
[10:32:25.699]                     fit
[10:32:25.699]                   }
[10:32:25.699]                 }, immediateCondition = function(cond) {
[10:32:25.699]                   sendCondition <- ...future.makeSendCondition()
[10:32:25.699]                   sendCondition(cond)
[10:32:25.699]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:25.699]                   {
[10:32:25.699]                     inherits <- base::inherits
[10:32:25.699]                     invokeRestart <- base::invokeRestart
[10:32:25.699]                     is.null <- base::is.null
[10:32:25.699]                     muffled <- FALSE
[10:32:25.699]                     if (inherits(cond, "message")) {
[10:32:25.699]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:25.699]                       if (muffled) 
[10:32:25.699]                         invokeRestart("muffleMessage")
[10:32:25.699]                     }
[10:32:25.699]                     else if (inherits(cond, "warning")) {
[10:32:25.699]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:25.699]                       if (muffled) 
[10:32:25.699]                         invokeRestart("muffleWarning")
[10:32:25.699]                     }
[10:32:25.699]                     else if (inherits(cond, "condition")) {
[10:32:25.699]                       if (!is.null(pattern)) {
[10:32:25.699]                         computeRestarts <- base::computeRestarts
[10:32:25.699]                         grepl <- base::grepl
[10:32:25.699]                         restarts <- computeRestarts(cond)
[10:32:25.699]                         for (restart in restarts) {
[10:32:25.699]                           name <- restart$name
[10:32:25.699]                           if (is.null(name)) 
[10:32:25.699]                             next
[10:32:25.699]                           if (!grepl(pattern, name)) 
[10:32:25.699]                             next
[10:32:25.699]                           invokeRestart(restart)
[10:32:25.699]                           muffled <- TRUE
[10:32:25.699]                           break
[10:32:25.699]                         }
[10:32:25.699]                       }
[10:32:25.699]                     }
[10:32:25.699]                     invisible(muffled)
[10:32:25.699]                   }
[10:32:25.699]                   muffleCondition(cond)
[10:32:25.699]                 })
[10:32:25.699]             }))
[10:32:25.699]             future::FutureResult(value = ...future.value$value, 
[10:32:25.699]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:25.699]                   ...future.rng), globalenv = if (FALSE) 
[10:32:25.699]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:25.699]                     ...future.globalenv.names))
[10:32:25.699]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:25.699]         }, condition = base::local({
[10:32:25.699]             c <- base::c
[10:32:25.699]             inherits <- base::inherits
[10:32:25.699]             invokeRestart <- base::invokeRestart
[10:32:25.699]             length <- base::length
[10:32:25.699]             list <- base::list
[10:32:25.699]             seq.int <- base::seq.int
[10:32:25.699]             signalCondition <- base::signalCondition
[10:32:25.699]             sys.calls <- base::sys.calls
[10:32:25.699]             `[[` <- base::`[[`
[10:32:25.699]             `+` <- base::`+`
[10:32:25.699]             `<<-` <- base::`<<-`
[10:32:25.699]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:25.699]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:25.699]                   3L)]
[10:32:25.699]             }
[10:32:25.699]             function(cond) {
[10:32:25.699]                 is_error <- inherits(cond, "error")
[10:32:25.699]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:25.699]                   NULL)
[10:32:25.699]                 if (is_error) {
[10:32:25.699]                   sessionInformation <- function() {
[10:32:25.699]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:25.699]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:25.699]                       search = base::search(), system = base::Sys.info())
[10:32:25.699]                   }
[10:32:25.699]                   ...future.conditions[[length(...future.conditions) + 
[10:32:25.699]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:25.699]                     cond$call), session = sessionInformation(), 
[10:32:25.699]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:25.699]                   signalCondition(cond)
[10:32:25.699]                 }
[10:32:25.699]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:25.699]                 "immediateCondition"))) {
[10:32:25.699]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:25.699]                   ...future.conditions[[length(...future.conditions) + 
[10:32:25.699]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:25.699]                   if (TRUE && !signal) {
[10:32:25.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:25.699]                     {
[10:32:25.699]                       inherits <- base::inherits
[10:32:25.699]                       invokeRestart <- base::invokeRestart
[10:32:25.699]                       is.null <- base::is.null
[10:32:25.699]                       muffled <- FALSE
[10:32:25.699]                       if (inherits(cond, "message")) {
[10:32:25.699]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:25.699]                         if (muffled) 
[10:32:25.699]                           invokeRestart("muffleMessage")
[10:32:25.699]                       }
[10:32:25.699]                       else if (inherits(cond, "warning")) {
[10:32:25.699]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:25.699]                         if (muffled) 
[10:32:25.699]                           invokeRestart("muffleWarning")
[10:32:25.699]                       }
[10:32:25.699]                       else if (inherits(cond, "condition")) {
[10:32:25.699]                         if (!is.null(pattern)) {
[10:32:25.699]                           computeRestarts <- base::computeRestarts
[10:32:25.699]                           grepl <- base::grepl
[10:32:25.699]                           restarts <- computeRestarts(cond)
[10:32:25.699]                           for (restart in restarts) {
[10:32:25.699]                             name <- restart$name
[10:32:25.699]                             if (is.null(name)) 
[10:32:25.699]                               next
[10:32:25.699]                             if (!grepl(pattern, name)) 
[10:32:25.699]                               next
[10:32:25.699]                             invokeRestart(restart)
[10:32:25.699]                             muffled <- TRUE
[10:32:25.699]                             break
[10:32:25.699]                           }
[10:32:25.699]                         }
[10:32:25.699]                       }
[10:32:25.699]                       invisible(muffled)
[10:32:25.699]                     }
[10:32:25.699]                     muffleCondition(cond, pattern = "^muffle")
[10:32:25.699]                   }
[10:32:25.699]                 }
[10:32:25.699]                 else {
[10:32:25.699]                   if (TRUE) {
[10:32:25.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:25.699]                     {
[10:32:25.699]                       inherits <- base::inherits
[10:32:25.699]                       invokeRestart <- base::invokeRestart
[10:32:25.699]                       is.null <- base::is.null
[10:32:25.699]                       muffled <- FALSE
[10:32:25.699]                       if (inherits(cond, "message")) {
[10:32:25.699]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:25.699]                         if (muffled) 
[10:32:25.699]                           invokeRestart("muffleMessage")
[10:32:25.699]                       }
[10:32:25.699]                       else if (inherits(cond, "warning")) {
[10:32:25.699]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:25.699]                         if (muffled) 
[10:32:25.699]                           invokeRestart("muffleWarning")
[10:32:25.699]                       }
[10:32:25.699]                       else if (inherits(cond, "condition")) {
[10:32:25.699]                         if (!is.null(pattern)) {
[10:32:25.699]                           computeRestarts <- base::computeRestarts
[10:32:25.699]                           grepl <- base::grepl
[10:32:25.699]                           restarts <- computeRestarts(cond)
[10:32:25.699]                           for (restart in restarts) {
[10:32:25.699]                             name <- restart$name
[10:32:25.699]                             if (is.null(name)) 
[10:32:25.699]                               next
[10:32:25.699]                             if (!grepl(pattern, name)) 
[10:32:25.699]                               next
[10:32:25.699]                             invokeRestart(restart)
[10:32:25.699]                             muffled <- TRUE
[10:32:25.699]                             break
[10:32:25.699]                           }
[10:32:25.699]                         }
[10:32:25.699]                       }
[10:32:25.699]                       invisible(muffled)
[10:32:25.699]                     }
[10:32:25.699]                     muffleCondition(cond, pattern = "^muffle")
[10:32:25.699]                   }
[10:32:25.699]                 }
[10:32:25.699]             }
[10:32:25.699]         }))
[10:32:25.699]     }, error = function(ex) {
[10:32:25.699]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:25.699]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:25.699]                 ...future.rng), started = ...future.startTime, 
[10:32:25.699]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:25.699]             version = "1.8"), class = "FutureResult")
[10:32:25.699]     }, finally = {
[10:32:25.699]         if (!identical(...future.workdir, getwd())) 
[10:32:25.699]             setwd(...future.workdir)
[10:32:25.699]         {
[10:32:25.699]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:25.699]                 ...future.oldOptions$nwarnings <- NULL
[10:32:25.699]             }
[10:32:25.699]             base::options(...future.oldOptions)
[10:32:25.699]             if (.Platform$OS.type == "windows") {
[10:32:25.699]                 old_names <- names(...future.oldEnvVars)
[10:32:25.699]                 envs <- base::Sys.getenv()
[10:32:25.699]                 names <- names(envs)
[10:32:25.699]                 common <- intersect(names, old_names)
[10:32:25.699]                 added <- setdiff(names, old_names)
[10:32:25.699]                 removed <- setdiff(old_names, names)
[10:32:25.699]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:25.699]                   envs[common]]
[10:32:25.699]                 NAMES <- toupper(changed)
[10:32:25.699]                 args <- list()
[10:32:25.699]                 for (kk in seq_along(NAMES)) {
[10:32:25.699]                   name <- changed[[kk]]
[10:32:25.699]                   NAME <- NAMES[[kk]]
[10:32:25.699]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:25.699]                     next
[10:32:25.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:25.699]                 }
[10:32:25.699]                 NAMES <- toupper(added)
[10:32:25.699]                 for (kk in seq_along(NAMES)) {
[10:32:25.699]                   name <- added[[kk]]
[10:32:25.699]                   NAME <- NAMES[[kk]]
[10:32:25.699]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:25.699]                     next
[10:32:25.699]                   args[[name]] <- ""
[10:32:25.699]                 }
[10:32:25.699]                 NAMES <- toupper(removed)
[10:32:25.699]                 for (kk in seq_along(NAMES)) {
[10:32:25.699]                   name <- removed[[kk]]
[10:32:25.699]                   NAME <- NAMES[[kk]]
[10:32:25.699]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:25.699]                     next
[10:32:25.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:25.699]                 }
[10:32:25.699]                 if (length(args) > 0) 
[10:32:25.699]                   base::do.call(base::Sys.setenv, args = args)
[10:32:25.699]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:25.699]             }
[10:32:25.699]             else {
[10:32:25.699]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:25.699]             }
[10:32:25.699]             {
[10:32:25.699]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:25.699]                   0L) {
[10:32:25.699]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:25.699]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:25.699]                   base::options(opts)
[10:32:25.699]                 }
[10:32:25.699]                 {
[10:32:25.699]                   {
[10:32:25.699]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:25.699]                     NULL
[10:32:25.699]                   }
[10:32:25.699]                   options(future.plan = NULL)
[10:32:25.699]                   if (is.na(NA_character_)) 
[10:32:25.699]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:25.699]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:25.699]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:25.699]                     .init = FALSE)
[10:32:25.699]                 }
[10:32:25.699]             }
[10:32:25.699]         }
[10:32:25.699]     })
[10:32:25.699]     if (TRUE) {
[10:32:25.699]         base::sink(type = "output", split = FALSE)
[10:32:25.699]         if (TRUE) {
[10:32:25.699]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:25.699]         }
[10:32:25.699]         else {
[10:32:25.699]             ...future.result["stdout"] <- base::list(NULL)
[10:32:25.699]         }
[10:32:25.699]         base::close(...future.stdout)
[10:32:25.699]         ...future.stdout <- NULL
[10:32:25.699]     }
[10:32:25.699]     ...future.result$conditions <- ...future.conditions
[10:32:25.699]     ...future.result$finished <- base::Sys.time()
[10:32:25.699]     ...future.result
[10:32:25.699] }
[10:32:25.702] Poll #1 (0): usedNodes() = 2, workers = 2
[10:32:25.721] receiveMessageFromWorker() for ClusterFuture ...
[10:32:25.721] - Validating connection of MultisessionFuture
[10:32:25.721] - received message: FutureResult
[10:32:25.722] - Received FutureResult
[10:32:25.722] - Erased future from FutureRegistry
[10:32:25.722] result() for ClusterFuture ...
[10:32:25.722] - result already collected: FutureResult
[10:32:25.722] result() for ClusterFuture ... done
[10:32:25.722] signalConditions() ...
[10:32:25.722]  - include = ‘immediateCondition’
[10:32:25.722]  - exclude = 
[10:32:25.722]  - resignal = FALSE
[10:32:25.722]  - Number of conditions: 2
[10:32:25.722] signalConditions() ... done
[10:32:25.723] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:25.723] result() for ClusterFuture ...
[10:32:25.723] - result already collected: FutureResult
[10:32:25.723] result() for ClusterFuture ... done
[10:32:25.723] result() for ClusterFuture ...
[10:32:25.723] - result already collected: FutureResult
[10:32:25.723] result() for ClusterFuture ... done
[10:32:25.723] signalConditions() ...
[10:32:25.723]  - include = ‘immediateCondition’
[10:32:25.723]  - exclude = 
[10:32:25.723]  - resignal = FALSE
[10:32:25.723]  - Number of conditions: 2
[10:32:25.724] signalConditions() ... done
[10:32:25.724] Exporting 4 global objects (14.24 KiB) to cluster node #1 ...
[10:32:25.724] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[10:32:25.725] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[10:32:25.725] Exporting ‘n’ (56 bytes) to cluster node #1 ...
[10:32:25.725] Exporting ‘n’ (56 bytes) to cluster node #1 ... DONE
[10:32:25.726] Exporting ‘C’ (10.72 KiB) to cluster node #1 ...
[10:32:25.769] Exporting ‘C’ (10.72 KiB) to cluster node #1 ... DONE
[10:32:25.769] Exporting ‘delay’ (3.41 KiB) to cluster node #1 ...
[10:32:25.813] Exporting ‘delay’ (3.41 KiB) to cluster node #1 ... DONE
[10:32:25.813] Exporting 4 global objects (14.24 KiB) to cluster node #1 ... DONE
[10:32:25.814] MultisessionFuture started
[10:32:25.814] - Launch lazy future ... done
[10:32:25.814] run() for ‘MultisessionFuture’ ... done
[10:32:25.814] - run() ... done
[10:32:25.814] - resolved() ...
[10:32:25.825] - resolved: FALSE
[10:32:25.825] - resolved() ... done
[10:32:25.825] resolved() for ‘MultisessionFuture’ ... done
[10:32:25.825] resolved() for ‘Future’ ...
[10:32:25.826] - state: ‘created’
[10:32:25.826] - run: TRUE
[10:32:25.826] - run() ...
[10:32:25.826] run() for ‘Future’ ...
[10:32:25.826] - state: ‘created’
[10:32:25.826] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:32:25.840] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:32:25.841] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:32:25.841]   - Field: ‘node’
[10:32:25.841]   - Field: ‘label’
[10:32:25.841]   - Field: ‘local’
[10:32:25.841]   - Field: ‘owner’
[10:32:25.841]   - Field: ‘envir’
[10:32:25.841]   - Field: ‘workers’
[10:32:25.841]   - Field: ‘packages’
[10:32:25.841]   - Field: ‘gc’
[10:32:25.842]   - Field: ‘conditions’
[10:32:25.842]   - Field: ‘persistent’
[10:32:25.842]   - Field: ‘expr’
[10:32:25.842]   - Field: ‘uuid’
[10:32:25.842]   - Field: ‘seed’
[10:32:25.842]   - Field: ‘version’
[10:32:25.842]   - Field: ‘result’
[10:32:25.842]   - Field: ‘asynchronous’
[10:32:25.842]   - Field: ‘calls’
[10:32:25.842]   - Field: ‘globals’
[10:32:25.842]   - Field: ‘stdout’
[10:32:25.842]   - Field: ‘earlySignal’
[10:32:25.843]   - Field: ‘lazy’
[10:32:25.843]   - Field: ‘state’
[10:32:25.843] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:32:25.843] - Launch lazy future ...
[10:32:25.843] Packages needed by the future expression (n = 1): ‘future’
[10:32:25.843] Packages needed by future strategies (n = 0): <none>
[10:32:25.844] {
[10:32:25.844]     {
[10:32:25.844]         {
[10:32:25.844]             ...future.startTime <- base::Sys.time()
[10:32:25.844]             {
[10:32:25.844]                 {
[10:32:25.844]                   {
[10:32:25.844]                     {
[10:32:25.844]                       {
[10:32:25.844]                         base::local({
[10:32:25.844]                           has_future <- base::requireNamespace("future", 
[10:32:25.844]                             quietly = TRUE)
[10:32:25.844]                           if (has_future) {
[10:32:25.844]                             ns <- base::getNamespace("future")
[10:32:25.844]                             version <- ns[[".package"]][["version"]]
[10:32:25.844]                             if (is.null(version)) 
[10:32:25.844]                               version <- utils::packageVersion("future")
[10:32:25.844]                           }
[10:32:25.844]                           else {
[10:32:25.844]                             version <- NULL
[10:32:25.844]                           }
[10:32:25.844]                           if (!has_future || version < "1.8.0") {
[10:32:25.844]                             info <- base::c(r_version = base::gsub("R version ", 
[10:32:25.844]                               "", base::R.version$version.string), 
[10:32:25.844]                               platform = base::sprintf("%s (%s-bit)", 
[10:32:25.844]                                 base::R.version$platform, 8 * 
[10:32:25.844]                                   base::.Machine$sizeof.pointer), 
[10:32:25.844]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:32:25.844]                                 "release", "version")], collapse = " "), 
[10:32:25.844]                               hostname = base::Sys.info()[["nodename"]])
[10:32:25.844]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:32:25.844]                               info)
[10:32:25.844]                             info <- base::paste(info, collapse = "; ")
[10:32:25.844]                             if (!has_future) {
[10:32:25.844]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:32:25.844]                                 info)
[10:32:25.844]                             }
[10:32:25.844]                             else {
[10:32:25.844]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:32:25.844]                                 info, version)
[10:32:25.844]                             }
[10:32:25.844]                             base::stop(msg)
[10:32:25.844]                           }
[10:32:25.844]                         })
[10:32:25.844]                       }
[10:32:25.844]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:32:25.844]                       base::options(mc.cores = 1L)
[10:32:25.844]                     }
[10:32:25.844]                     base::local({
[10:32:25.844]                       for (pkg in "future") {
[10:32:25.844]                         base::loadNamespace(pkg)
[10:32:25.844]                         base::library(pkg, character.only = TRUE)
[10:32:25.844]                       }
[10:32:25.844]                     })
[10:32:25.844]                   }
[10:32:25.844]                   ...future.strategy.old <- future::plan("list")
[10:32:25.844]                   options(future.plan = NULL)
[10:32:25.844]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:32:25.844]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:32:25.844]                 }
[10:32:25.844]                 ...future.workdir <- getwd()
[10:32:25.844]             }
[10:32:25.844]             ...future.oldOptions <- base::as.list(base::.Options)
[10:32:25.844]             ...future.oldEnvVars <- base::Sys.getenv()
[10:32:25.844]         }
[10:32:25.844]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:32:25.844]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:32:25.844]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:32:25.844]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:32:25.844]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:32:25.844]             future.stdout.windows.reencode = NULL, width = 80L)
[10:32:25.844]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:32:25.844]             base::names(...future.oldOptions))
[10:32:25.844]     }
[10:32:25.844]     if (FALSE) {
[10:32:25.844]     }
[10:32:25.844]     else {
[10:32:25.844]         if (TRUE) {
[10:32:25.844]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:32:25.844]                 open = "w")
[10:32:25.844]         }
[10:32:25.844]         else {
[10:32:25.844]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:32:25.844]                 windows = "NUL", "/dev/null"), open = "w")
[10:32:25.844]         }
[10:32:25.844]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:32:25.844]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:32:25.844]             base::sink(type = "output", split = FALSE)
[10:32:25.844]             base::close(...future.stdout)
[10:32:25.844]         }, add = TRUE)
[10:32:25.844]     }
[10:32:25.844]     ...future.frame <- base::sys.nframe()
[10:32:25.844]     ...future.conditions <- base::list()
[10:32:25.844]     ...future.rng <- base::globalenv()$.Random.seed
[10:32:25.844]     if (FALSE) {
[10:32:25.844]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:32:25.844]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:32:25.844]     }
[10:32:25.844]     ...future.result <- base::tryCatch({
[10:32:25.844]         base::withCallingHandlers({
[10:32:25.844]             ...future.value <- base::withVisible(base::local({
[10:32:25.844]                 ...future.makeSendCondition <- base::local({
[10:32:25.844]                   sendCondition <- NULL
[10:32:25.844]                   function(frame = 1L) {
[10:32:25.844]                     if (is.function(sendCondition)) 
[10:32:25.844]                       return(sendCondition)
[10:32:25.844]                     ns <- getNamespace("parallel")
[10:32:25.844]                     if (exists("sendData", mode = "function", 
[10:32:25.844]                       envir = ns)) {
[10:32:25.844]                       parallel_sendData <- get("sendData", mode = "function", 
[10:32:25.844]                         envir = ns)
[10:32:25.844]                       envir <- sys.frame(frame)
[10:32:25.844]                       master <- NULL
[10:32:25.844]                       while (!identical(envir, .GlobalEnv) && 
[10:32:25.844]                         !identical(envir, emptyenv())) {
[10:32:25.844]                         if (exists("master", mode = "list", envir = envir, 
[10:32:25.844]                           inherits = FALSE)) {
[10:32:25.844]                           master <- get("master", mode = "list", 
[10:32:25.844]                             envir = envir, inherits = FALSE)
[10:32:25.844]                           if (inherits(master, c("SOCKnode", 
[10:32:25.844]                             "SOCK0node"))) {
[10:32:25.844]                             sendCondition <<- function(cond) {
[10:32:25.844]                               data <- list(type = "VALUE", value = cond, 
[10:32:25.844]                                 success = TRUE)
[10:32:25.844]                               parallel_sendData(master, data)
[10:32:25.844]                             }
[10:32:25.844]                             return(sendCondition)
[10:32:25.844]                           }
[10:32:25.844]                         }
[10:32:25.844]                         frame <- frame + 1L
[10:32:25.844]                         envir <- sys.frame(frame)
[10:32:25.844]                       }
[10:32:25.844]                     }
[10:32:25.844]                     sendCondition <<- function(cond) NULL
[10:32:25.844]                   }
[10:32:25.844]                 })
[10:32:25.844]                 withCallingHandlers({
[10:32:25.844]                   {
[10:32:25.844]                     message(sprintf("Calculating tile #%d of %d ...", 
[10:32:25.844]                       ii, n), appendLF = FALSE)
[10:32:25.844]                     fit <- mandelbrot(C)
[10:32:25.844]                     delay(fit)
[10:32:25.844]                     message(" done")
[10:32:25.844]                     fit
[10:32:25.844]                   }
[10:32:25.844]                 }, immediateCondition = function(cond) {
[10:32:25.844]                   sendCondition <- ...future.makeSendCondition()
[10:32:25.844]                   sendCondition(cond)
[10:32:25.844]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:25.844]                   {
[10:32:25.844]                     inherits <- base::inherits
[10:32:25.844]                     invokeRestart <- base::invokeRestart
[10:32:25.844]                     is.null <- base::is.null
[10:32:25.844]                     muffled <- FALSE
[10:32:25.844]                     if (inherits(cond, "message")) {
[10:32:25.844]                       muffled <- grepl(pattern, "muffleMessage")
[10:32:25.844]                       if (muffled) 
[10:32:25.844]                         invokeRestart("muffleMessage")
[10:32:25.844]                     }
[10:32:25.844]                     else if (inherits(cond, "warning")) {
[10:32:25.844]                       muffled <- grepl(pattern, "muffleWarning")
[10:32:25.844]                       if (muffled) 
[10:32:25.844]                         invokeRestart("muffleWarning")
[10:32:25.844]                     }
[10:32:25.844]                     else if (inherits(cond, "condition")) {
[10:32:25.844]                       if (!is.null(pattern)) {
[10:32:25.844]                         computeRestarts <- base::computeRestarts
[10:32:25.844]                         grepl <- base::grepl
[10:32:25.844]                         restarts <- computeRestarts(cond)
[10:32:25.844]                         for (restart in restarts) {
[10:32:25.844]                           name <- restart$name
[10:32:25.844]                           if (is.null(name)) 
[10:32:25.844]                             next
[10:32:25.844]                           if (!grepl(pattern, name)) 
[10:32:25.844]                             next
[10:32:25.844]                           invokeRestart(restart)
[10:32:25.844]                           muffled <- TRUE
[10:32:25.844]                           break
[10:32:25.844]                         }
[10:32:25.844]                       }
[10:32:25.844]                     }
[10:32:25.844]                     invisible(muffled)
[10:32:25.844]                   }
[10:32:25.844]                   muffleCondition(cond)
[10:32:25.844]                 })
[10:32:25.844]             }))
[10:32:25.844]             future::FutureResult(value = ...future.value$value, 
[10:32:25.844]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:25.844]                   ...future.rng), globalenv = if (FALSE) 
[10:32:25.844]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:32:25.844]                     ...future.globalenv.names))
[10:32:25.844]                 else NULL, started = ...future.startTime, version = "1.8")
[10:32:25.844]         }, condition = base::local({
[10:32:25.844]             c <- base::c
[10:32:25.844]             inherits <- base::inherits
[10:32:25.844]             invokeRestart <- base::invokeRestart
[10:32:25.844]             length <- base::length
[10:32:25.844]             list <- base::list
[10:32:25.844]             seq.int <- base::seq.int
[10:32:25.844]             signalCondition <- base::signalCondition
[10:32:25.844]             sys.calls <- base::sys.calls
[10:32:25.844]             `[[` <- base::`[[`
[10:32:25.844]             `+` <- base::`+`
[10:32:25.844]             `<<-` <- base::`<<-`
[10:32:25.844]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:32:25.844]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:32:25.844]                   3L)]
[10:32:25.844]             }
[10:32:25.844]             function(cond) {
[10:32:25.844]                 is_error <- inherits(cond, "error")
[10:32:25.844]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:32:25.844]                   NULL)
[10:32:25.844]                 if (is_error) {
[10:32:25.844]                   sessionInformation <- function() {
[10:32:25.844]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:32:25.844]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:32:25.844]                       search = base::search(), system = base::Sys.info())
[10:32:25.844]                   }
[10:32:25.844]                   ...future.conditions[[length(...future.conditions) + 
[10:32:25.844]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:32:25.844]                     cond$call), session = sessionInformation(), 
[10:32:25.844]                     timestamp = base::Sys.time(), signaled = 0L)
[10:32:25.844]                   signalCondition(cond)
[10:32:25.844]                 }
[10:32:25.844]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:32:25.844]                 "immediateCondition"))) {
[10:32:25.844]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:32:25.844]                   ...future.conditions[[length(...future.conditions) + 
[10:32:25.844]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:32:25.844]                   if (TRUE && !signal) {
[10:32:25.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:25.844]                     {
[10:32:25.844]                       inherits <- base::inherits
[10:32:25.844]                       invokeRestart <- base::invokeRestart
[10:32:25.844]                       is.null <- base::is.null
[10:32:25.844]                       muffled <- FALSE
[10:32:25.844]                       if (inherits(cond, "message")) {
[10:32:25.844]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:25.844]                         if (muffled) 
[10:32:25.844]                           invokeRestart("muffleMessage")
[10:32:25.844]                       }
[10:32:25.844]                       else if (inherits(cond, "warning")) {
[10:32:25.844]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:25.844]                         if (muffled) 
[10:32:25.844]                           invokeRestart("muffleWarning")
[10:32:25.844]                       }
[10:32:25.844]                       else if (inherits(cond, "condition")) {
[10:32:25.844]                         if (!is.null(pattern)) {
[10:32:25.844]                           computeRestarts <- base::computeRestarts
[10:32:25.844]                           grepl <- base::grepl
[10:32:25.844]                           restarts <- computeRestarts(cond)
[10:32:25.844]                           for (restart in restarts) {
[10:32:25.844]                             name <- restart$name
[10:32:25.844]                             if (is.null(name)) 
[10:32:25.844]                               next
[10:32:25.844]                             if (!grepl(pattern, name)) 
[10:32:25.844]                               next
[10:32:25.844]                             invokeRestart(restart)
[10:32:25.844]                             muffled <- TRUE
[10:32:25.844]                             break
[10:32:25.844]                           }
[10:32:25.844]                         }
[10:32:25.844]                       }
[10:32:25.844]                       invisible(muffled)
[10:32:25.844]                     }
[10:32:25.844]                     muffleCondition(cond, pattern = "^muffle")
[10:32:25.844]                   }
[10:32:25.844]                 }
[10:32:25.844]                 else {
[10:32:25.844]                   if (TRUE) {
[10:32:25.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:32:25.844]                     {
[10:32:25.844]                       inherits <- base::inherits
[10:32:25.844]                       invokeRestart <- base::invokeRestart
[10:32:25.844]                       is.null <- base::is.null
[10:32:25.844]                       muffled <- FALSE
[10:32:25.844]                       if (inherits(cond, "message")) {
[10:32:25.844]                         muffled <- grepl(pattern, "muffleMessage")
[10:32:25.844]                         if (muffled) 
[10:32:25.844]                           invokeRestart("muffleMessage")
[10:32:25.844]                       }
[10:32:25.844]                       else if (inherits(cond, "warning")) {
[10:32:25.844]                         muffled <- grepl(pattern, "muffleWarning")
[10:32:25.844]                         if (muffled) 
[10:32:25.844]                           invokeRestart("muffleWarning")
[10:32:25.844]                       }
[10:32:25.844]                       else if (inherits(cond, "condition")) {
[10:32:25.844]                         if (!is.null(pattern)) {
[10:32:25.844]                           computeRestarts <- base::computeRestarts
[10:32:25.844]                           grepl <- base::grepl
[10:32:25.844]                           restarts <- computeRestarts(cond)
[10:32:25.844]                           for (restart in restarts) {
[10:32:25.844]                             name <- restart$name
[10:32:25.844]                             if (is.null(name)) 
[10:32:25.844]                               next
[10:32:25.844]                             if (!grepl(pattern, name)) 
[10:32:25.844]                               next
[10:32:25.844]                             invokeRestart(restart)
[10:32:25.844]                             muffled <- TRUE
[10:32:25.844]                             break
[10:32:25.844]                           }
[10:32:25.844]                         }
[10:32:25.844]                       }
[10:32:25.844]                       invisible(muffled)
[10:32:25.844]                     }
[10:32:25.844]                     muffleCondition(cond, pattern = "^muffle")
[10:32:25.844]                   }
[10:32:25.844]                 }
[10:32:25.844]             }
[10:32:25.844]         }))
[10:32:25.844]     }, error = function(ex) {
[10:32:25.844]         base::structure(base::list(value = NULL, visible = NULL, 
[10:32:25.844]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:32:25.844]                 ...future.rng), started = ...future.startTime, 
[10:32:25.844]             finished = Sys.time(), session_uuid = NA_character_, 
[10:32:25.844]             version = "1.8"), class = "FutureResult")
[10:32:25.844]     }, finally = {
[10:32:25.844]         if (!identical(...future.workdir, getwd())) 
[10:32:25.844]             setwd(...future.workdir)
[10:32:25.844]         {
[10:32:25.844]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:32:25.844]                 ...future.oldOptions$nwarnings <- NULL
[10:32:25.844]             }
[10:32:25.844]             base::options(...future.oldOptions)
[10:32:25.844]             if (.Platform$OS.type == "windows") {
[10:32:25.844]                 old_names <- names(...future.oldEnvVars)
[10:32:25.844]                 envs <- base::Sys.getenv()
[10:32:25.844]                 names <- names(envs)
[10:32:25.844]                 common <- intersect(names, old_names)
[10:32:25.844]                 added <- setdiff(names, old_names)
[10:32:25.844]                 removed <- setdiff(old_names, names)
[10:32:25.844]                 changed <- common[...future.oldEnvVars[common] != 
[10:32:25.844]                   envs[common]]
[10:32:25.844]                 NAMES <- toupper(changed)
[10:32:25.844]                 args <- list()
[10:32:25.844]                 for (kk in seq_along(NAMES)) {
[10:32:25.844]                   name <- changed[[kk]]
[10:32:25.844]                   NAME <- NAMES[[kk]]
[10:32:25.844]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:25.844]                     next
[10:32:25.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:25.844]                 }
[10:32:25.844]                 NAMES <- toupper(added)
[10:32:25.844]                 for (kk in seq_along(NAMES)) {
[10:32:25.844]                   name <- added[[kk]]
[10:32:25.844]                   NAME <- NAMES[[kk]]
[10:32:25.844]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:25.844]                     next
[10:32:25.844]                   args[[name]] <- ""
[10:32:25.844]                 }
[10:32:25.844]                 NAMES <- toupper(removed)
[10:32:25.844]                 for (kk in seq_along(NAMES)) {
[10:32:25.844]                   name <- removed[[kk]]
[10:32:25.844]                   NAME <- NAMES[[kk]]
[10:32:25.844]                   if (name != NAME && is.element(NAME, old_names)) 
[10:32:25.844]                     next
[10:32:25.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:32:25.844]                 }
[10:32:25.844]                 if (length(args) > 0) 
[10:32:25.844]                   base::do.call(base::Sys.setenv, args = args)
[10:32:25.844]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:32:25.844]             }
[10:32:25.844]             else {
[10:32:25.844]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:32:25.844]             }
[10:32:25.844]             {
[10:32:25.844]                 if (base::length(...future.futureOptionsAdded) > 
[10:32:25.844]                   0L) {
[10:32:25.844]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:32:25.844]                   base::names(opts) <- ...future.futureOptionsAdded
[10:32:25.844]                   base::options(opts)
[10:32:25.844]                 }
[10:32:25.844]                 {
[10:32:25.844]                   {
[10:32:25.844]                     base::options(mc.cores = ...future.mc.cores.old)
[10:32:25.844]                     NULL
[10:32:25.844]                   }
[10:32:25.844]                   options(future.plan = NULL)
[10:32:25.844]                   if (is.na(NA_character_)) 
[10:32:25.844]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:32:25.844]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:32:25.844]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:32:25.844]                     .init = FALSE)
[10:32:25.844]                 }
[10:32:25.844]             }
[10:32:25.844]         }
[10:32:25.844]     })
[10:32:25.844]     if (TRUE) {
[10:32:25.844]         base::sink(type = "output", split = FALSE)
[10:32:25.844]         if (TRUE) {
[10:32:25.844]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:32:25.844]         }
[10:32:25.844]         else {
[10:32:25.844]             ...future.result["stdout"] <- base::list(NULL)
[10:32:25.844]         }
[10:32:25.844]         base::close(...future.stdout)
[10:32:25.844]         ...future.stdout <- NULL
[10:32:25.844]     }
[10:32:25.844]     ...future.result$conditions <- ...future.conditions
[10:32:25.844]     ...future.result$finished <- base::Sys.time()
[10:32:25.844]     ...future.result
[10:32:25.844] }
[10:32:25.846] Poll #1 (0): usedNodes() = 2, workers = 2
[10:32:25.857] receiveMessageFromWorker() for ClusterFuture ...
[10:32:25.857] - Validating connection of MultisessionFuture
[10:32:25.858] - received message: FutureResult
[10:32:25.858] - Received FutureResult
[10:32:25.858] - Erased future from FutureRegistry
[10:32:25.858] result() for ClusterFuture ...
[10:32:25.858] - result already collected: FutureResult
[10:32:25.858] result() for ClusterFuture ... done
[10:32:25.858] signalConditions() ...
[10:32:25.858]  - include = ‘immediateCondition’
[10:32:25.858]  - exclude = 
[10:32:25.858]  - resignal = FALSE
[10:32:25.858]  - Number of conditions: 2
[10:32:25.859] signalConditions() ... done
[10:32:25.859] receiveMessageFromWorker() for ClusterFuture ... done
[10:32:25.859] result() for ClusterFuture ...
[10:32:25.859] - result already collected: FutureResult
[10:32:25.859] result() for ClusterFuture ... done
[10:32:25.859] result() for ClusterFuture ...
[10:32:25.859] - result already collected: FutureResult
[10:32:25.859] result() for ClusterFuture ... done
[10:32:25.859] signalConditions() ...
[10:32:25.859]  - include = ‘immediateCondition’
[10:32:25.859]  - exclude = 
[10:32:25.860]  - resignal = FALSE
[10:32:25.860]  - Number of conditions: 2
[10:32:25.860] signalConditions() ... done
[10:32:25.860] Exporting 4 global objects (14.24 KiB) to cluster node #2 ...
[10:32:25.861] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[10:32:25.861] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[10:32:25.861] Exporting ‘n’ (56 bytes) to cluster node #2 ...
[10:32:25.862] Exporting ‘n’ (56 bytes) to cluster node #2 ... DONE
[10:32:25.862] Exporting ‘C’ (10.72 KiB) to cluster node #2 ...
[10:32:25.905] Exporting ‘C’ (10.72 KiB) to cluster node #2 ... DONE
[10:32:25.905] Exporting ‘delay’ (3.41 KiB) to cluster node #2 ...
[10:32:25.949] Exporting ‘delay’ (3.41 KiB) to cluster node #2 ... DONE
[10:32:25.949] Exporting 4 global objects (14.24 KiB) to cluster node #2 ... DONE
[10:32:25.950] MultisessionFuture started
[10:32:25.950] - Launch lazy future ... done
[10:32:25.950] run() for ‘MultisessionFuture’ ... done
[10:32:25.950] - run() ... done
[10:32:25.950] - resolved() ...
[10:32:25.961] - resolved: FALSE
[10:32:25.961] - resolved() ... done
[10:32:25.961] resolved() for ‘MultisessionFuture’ ... done
Plotting tile #1 of 4 ...
[10:32:25.961] result() for ClusterFuture ...
[10:32:25.962] - result already collected: FutureResult
[10:32:25.962] result() for ClusterFuture ... done
[10:32:25.962] result() for ClusterFuture ...
[10:32:25.962] - result already collected: FutureResult
[10:32:25.962] result() for ClusterFuture ... done
[10:32:25.962] signalConditions() ...
[10:32:25.962]  - include = ‘immediateCondition’
[10:32:25.962]  - exclude = 
[10:32:25.962]  - resignal = FALSE
[10:32:25.962]  - Number of conditions: 2
[10:32:25.962] signalConditions() ... done
[10:32:25.963] Future state: ‘finished’
[10:32:25.963] result() for ClusterFuture ...
[10:32:25.963] - result already collected: FutureResult
[10:32:25.963] result() for ClusterFuture ... done
[10:32:25.963] signalConditions() ...
[10:32:25.963]  - include = ‘condition’
[10:32:25.963]  - exclude = ‘immediateCondition’
[10:32:25.963]  - resignal = TRUE
[10:32:25.963]  - Number of conditions: 2
[10:32:25.963]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #1 of 4 ...[10:32:25.963]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[10:32:25.966] signalConditions() ... done
Plotting tile #2 of 4 ...
[10:32:25.966] result() for ClusterFuture ...
[10:32:25.967] - result already collected: FutureResult
[10:32:25.967] result() for ClusterFuture ... done
[10:32:25.967] result() for ClusterFuture ...
[10:32:25.967] - result already collected: FutureResult
[10:32:25.967] result() for ClusterFuture ... done
[10:32:25.967] signalConditions() ...
[10:32:25.967]  - include = ‘immediateCondition’
[10:32:25.967]  - exclude = 
[10:32:25.967]  - resignal = FALSE
[10:32:25.967]  - Number of conditions: 2
[10:32:25.967] signalConditions() ... done
[10:32:25.968] Future state: ‘finished’
[10:32:25.968] result() for ClusterFuture ...
[10:32:25.968] - result already collected: FutureResult
[10:32:25.968] result() for ClusterFuture ... done
[10:32:25.968] signalConditions() ...
[10:32:25.968]  - include = ‘condition’
[10:32:25.968]  - exclude = ‘immediateCondition’
[10:32:25.968]  - resignal = TRUE
[10:32:25.968]  - Number of conditions: 2
[10:32:25.968]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #2 of 4 ...[10:32:25.968]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[10:32:25.969] signalConditions() ... done
[10:32:25.969] receiveMessageFromWorker() for ClusterFuture ...
[10:32:25.970] - Validating connection of MultisessionFuture
[10:32:25.970] - received message: FutureResult
[10:32:25.970] - Received FutureResult
[10:32:25.970] - Erased future from FutureRegistry
[10:32:25.970] result() for ClusterFuture ...
[10:32:25.970] - result already collected: FutureResult
[10:32:25.970] result() for ClusterFuture ... done
[10:32:25.970] signalConditions() ...
[10:32:25.971]  - include = ‘immediateCondition’
[10:32:25.971]  - exclude = 
[10:32:25.971]  - resignal = FALSE
[10:32:25.971]  - Number of conditions: 2
[10:32:25.971] signalConditions() ... done
[10:32:25.971] receiveMessageFromWorker() for ClusterFuture ... done
Plotting tile #3 of 4 ...
[10:32:25.971] result() for ClusterFuture ...
[10:32:25.971] - result already collected: FutureResult
[10:32:25.971] result() for ClusterFuture ... done
[10:32:25.971] result() for ClusterFuture ...
[10:32:25.971] - result already collected: FutureResult
[10:32:25.972] result() for ClusterFuture ... done
[10:32:25.972] signalConditions() ...
[10:32:25.972]  - include = ‘immediateCondition’
[10:32:25.972]  - exclude = 
[10:32:25.972]  - resignal = FALSE
[10:32:25.972]  - Number of conditions: 2
[10:32:25.972] signalConditions() ... done
[10:32:25.972] Future state: ‘finished’
[10:32:25.972] result() for ClusterFuture ...
[10:32:25.972] - result already collected: FutureResult
[10:32:25.972] result() for ClusterFuture ... done
[10:32:25.972] signalConditions() ...
[10:32:25.973]  - include = ‘condition’
[10:32:25.973]  - exclude = ‘immediateCondition’
[10:32:25.973]  - resignal = TRUE
[10:32:25.973]  - Number of conditions: 2
[10:32:25.973]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #3 of 4 ...[10:32:25.973]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[10:32:25.973] signalConditions() ... done
[10:32:26.010] receiveMessageFromWorker() for ClusterFuture ...
[10:32:26.010] - Validating connection of MultisessionFuture
[10:32:26.010] - received message: FutureResult
[10:32:26.010] - Received FutureResult
[10:32:26.011] - Erased future from FutureRegistry
[10:32:26.011] result() for ClusterFuture ...
[10:32:26.011] - result already collected: FutureResult
[10:32:26.011] result() for ClusterFuture ... done
[10:32:26.011] signalConditions() ...
[10:32:26.011]  - include = ‘immediateCondition’
[10:32:26.011]  - exclude = 
[10:32:26.011]  - resignal = FALSE
[10:32:26.011]  - Number of conditions: 2
[10:32:26.011] signalConditions() ... done
[10:32:26.011] receiveMessageFromWorker() for ClusterFuture ... done
Plotting tile #4 of 4 ...
[10:32:26.012] result() for ClusterFuture ...
[10:32:26.012] - result already collected: FutureResult
[10:32:26.012] result() for ClusterFuture ... done
[10:32:26.012] result() for ClusterFuture ...
[10:32:26.012] - result already collected: FutureResult
[10:32:26.012] result() for ClusterFuture ... done
[10:32:26.012] signalConditions() ...
[10:32:26.012]  - include = ‘immediateCondition’
[10:32:26.012]  - exclude = 
[10:32:26.012]  - resignal = FALSE
[10:32:26.012]  - Number of conditions: 2
[10:32:26.013] signalConditions() ... done
[10:32:26.013] Future state: ‘finished’
[10:32:26.013] result() for ClusterFuture ...
[10:32:26.013] - result already collected: FutureResult
[10:32:26.013] result() for ClusterFuture ... done
[10:32:26.013] signalConditions() ...
[10:32:26.013]  - include = ‘condition’
[10:32:26.013]  - exclude = ‘immediateCondition’
[10:32:26.013]  - resignal = TRUE
[10:32:26.013]  - Number of conditions: 2
[10:32:26.014]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #4 of 4 ...[10:32:26.014]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[10:32:26.014] signalConditions() ... done

> close.screen()
 [1]  1  2  3  4  5  6  7  8  9 10 11 12

> message("SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).\n")
SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).

- plan('multisession') ... DONE
Testing with 2 cores ... DONE
> message("*** Mandelbrot demo of the 'future' package ... DONE")
*** Mandelbrot demo of the 'future' package ... DONE
> 
> message("*** Demos ... DONE")
*** Demos ... DONE
> 
> source("incl/end.R")
[10:32:26.016] plan(): Setting new future strategy stack:
[10:32:26.016] List of future strategies:
[10:32:26.016] 1. sequential:
[10:32:26.016]    - args: function (..., envir = parent.frame())
[10:32:26.016]    - tweaked: FALSE
[10:32:26.016]    - call: future::plan("sequential")
[10:32:26.016] plan(): nbrOfWorkers() = 1
> 
