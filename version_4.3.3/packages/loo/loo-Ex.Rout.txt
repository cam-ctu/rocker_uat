
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "loo"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('loo')
This is loo version 2.7.0
- Online documentation and vignettes at mc-stan.org/loo
- As of v2.0.0 loo defaults to 1 core but we recommend using as many as possible. Use the 'cores' argument or set options(mc.cores = NUM_CORES) for an entire session. 
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("E_loo")
> ### * E_loo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: E_loo
> ### Title: Compute weighted expectations
> ### Aliases: E_loo E_loo.default E_loo.matrix
> 
> ### ** Examples
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("compare")
> ### * compare
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compare
> ### Title: Model comparison (deprecated, old version)
> ### Aliases: compare
> 
> ### ** Examples
> 
> ## Not run: 
> ##D loo1 <- loo(log_lik1)
> ##D loo2 <- loo(log_lik2)
> ##D print(compare(loo1, loo2), digits = 3)
> ##D print(compare(x = list(loo1, loo2)))
> ##D 
> ##D waic1 <- waic(log_lik1)
> ##D waic2 <- waic(log_lik2)
> ##D compare(waic1, waic2)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("crps")
> ### * crps
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: crps
> ### Title: Continuously ranked probability score
> ### Aliases: crps scrps loo_crps loo_scrps crps.matrix crps.numeric
> ###   loo_crps.matrix scrps.matrix scrps.numeric loo_scrps.matrix
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # An example using rstanarm
> ##D library(rstanarm)
> ##D data("kidiq")
> ##D fit <- stan_glm(kid_score ~ mom_hs + mom_iq, data = kidiq)
> ##D ypred1 <- posterior_predict(fit)
> ##D ypred2 <- posterior_predict(fit)
> ##D crps(ypred1, ypred2, y = fit$y)
> ##D loo_crps(ypred1, ypred2, y = fit$y, log_lik = log_lik(fit))
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("elpd")
> ### * elpd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: elpd
> ### Title: Generic (expected) log-predictive density
> ### Aliases: elpd elpd.array elpd.matrix
> 
> ### ** Examples
> 
> # Calculate the lpd of the observed data
> LLarr <- example_loglik_array()
> elpd(LLarr)

Computed from 1000 by 32 log-likelihood matrix using the generic elpd function

     Estimate  SE
elpd    -80.3 3.2
ic      160.5 6.5
> 
> 
> 
> 
> cleanEx()
> nameEx("example_loglik_array")
> ### * example_loglik_array
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: example_loglik_array
> ### Title: Objects to use in examples and tests
> ### Aliases: example_loglik_array example_loglik_matrix
> 
> ### ** Examples
> 
> LLarr <- example_loglik_array()
> (dim_arr <- dim(LLarr))
[1] 500   2  32
> LLmat <- example_loglik_matrix()
> (dim_mat <- dim(LLmat))
[1] 1000   32
> 
> all.equal(dim_mat[1], dim_arr[1] * dim_arr[2])
[1] TRUE
> all.equal(dim_mat[2], dim_arr[3])
[1] TRUE
> 
> all.equal(LLarr[, 1, ], LLmat[1:500, ])
[1] TRUE
> all.equal(LLarr[, 2, ], LLmat[501:1000, ])
[1] TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("kfold-helpers")
> ### * kfold-helpers
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: kfold-helpers
> ### Title: Helper functions for K-fold cross-validation
> ### Aliases: kfold-helpers kfold_split_random kfold_split_stratified
> ###   kfold_split_grouped
> 
> ### ** Examples
> 
> ids <- kfold_split_random(K = 5, N = 20)
> print(ids)
 [1] 1 2 1 1 4 5 3 5 4 1 5 2 3 4 2 4 3 3 5 2
> table(ids)
ids
1 2 3 4 5 
4 4 4 4 4 
> 
> 
> x <- sample(c(0, 1), size = 200, replace = TRUE, prob = c(0.05, 0.95))
> table(x)
x
  0   1 
  8 192 
> ids <- kfold_split_stratified(K = 5, x = x)
> print(ids)
  [1] 1 5 1 3 2 3 4 2 2 4 1 4 2 2 5 4 4 2 2 2 5 3 3 2 3 5 3 3 5 1 1 4 2 2 5 2 2
 [38] 1 1 5 2 2 4 2 2 4 5 4 3 4 4 1 3 4 5 2 5 5 1 3 3 2 2 1 1 2 5 3 4 1 4 5 1 2
 [75] 3 4 3 3 1 3 2 5 1 2 5 3 1 2 5 4 5 1 1 4 4 2 2 3 5 4 3 4 2 4 5 3 5 4 4 4 3
[112] 3 1 4 3 4 1 5 4 2 3 5 1 1 1 1 1 3 2 1 1 5 5 2 1 4 4 1 3 3 3 5 3 5 5 3 3 3
[149] 4 2 4 1 4 1 3 1 3 2 5 2 2 5 3 4 5 1 5 4 4 4 1 5 2 2 5 2 4 2 5 4 1 5 3 4 1
[186] 1 5 1 3 5 3 5 2 3 3 1 5 5 4 1
> table(ids, x)
   x
ids  0  1
  1  2 38
  2  2 38
  3  2 38
  4  1 39
  5  1 39
> 
> grp <- gl(n = 50, k = 15, labels = state.name)
> length(grp)
[1] 750
> head(table(grp))
grp
   Alabama     Alaska    Arizona   Arkansas California   Colorado 
        15         15         15         15         15         15 
> 
> ids_10 <- kfold_split_grouped(K = 10, x = grp)
> (tab_10 <- table(grp, ids_10))
                ids_10
grp               1  2  3  4  5  6  7  8  9 10
  Alabama         0  0  0  0  0  0  0 15  0  0
  Alaska          0  0  0  0 15  0  0  0  0  0
  Arizona         0  0 15  0  0  0  0  0  0  0
  Arkansas        0 15  0  0  0  0  0  0  0  0
  California      0  0  0  0  0 15  0  0  0  0
  Colorado        0  0  0  0  0 15  0  0  0  0
  Connecticut     0  0  0  0  0 15  0  0  0  0
  Delaware        0  0 15  0  0  0  0  0  0  0
  Florida         0 15  0  0  0  0  0  0  0  0
  Georgia         0  0  0  0  0  0 15  0  0  0
  Hawaii          0  0  0  0 15  0  0  0  0  0
  Idaho          15  0  0  0  0  0  0  0  0  0
  Illinois        0  0  0 15  0  0  0  0  0  0
  Indiana         0  0 15  0  0  0  0  0  0  0
  Iowa            0  0  0  0  0  0  0  0 15  0
  Kansas         15  0  0  0  0  0  0  0  0  0
  Kentucky        0 15  0  0  0  0  0  0  0  0
  Louisiana       0  0  0  0 15  0  0  0  0  0
  Maine           0  0  0  0  0  0 15  0  0  0
  Maryland        0  0  0 15  0  0  0  0  0  0
  Massachusetts   0  0  0  0  0  0  0  0  0 15
  Michigan        0  0  0  0  0  0  0 15  0  0
  Minnesota       0  0  0  0  0  0 15  0  0  0
  Mississippi    15  0  0  0  0  0  0  0  0  0
  Missouri        0 15  0  0  0  0  0  0  0  0
  Montana         0  0 15  0  0  0  0  0  0  0
  Nebraska        0  0  0  0  0 15  0  0  0  0
  Nevada          0  0  0  0 15  0  0  0  0  0
  New Hampshire   0  0  0  0  0  0  0  0 15  0
  New Jersey      0  0  0  0  0  0 15  0  0  0
  New Mexico      0  0  0  0  0  0  0 15  0  0
  New York        0  0  0  0  0  0  0  0  0 15
  North Carolina  0  0  0 15  0  0  0  0  0  0
  North Dakota    0  0  0  0  0  0  0  0 15  0
  Ohio            0  0  0  0  0  0  0  0  0 15
  Oklahoma        0 15  0  0  0  0  0  0  0  0
  Oregon         15  0  0  0  0  0  0  0  0  0
  Pennsylvania    0  0  0  0  0 15  0  0  0  0
  Rhode Island    0  0  0  0  0  0  0  0 15  0
  South Carolina  0  0 15  0  0  0  0  0  0  0
  South Dakota    0  0  0  0  0  0  0 15  0  0
  Tennessee       0  0  0 15  0  0  0  0  0  0
  Texas           0  0  0  0  0  0  0  0 15  0
  Utah            0  0  0  0  0  0  0  0  0 15
  Vermont         0  0  0  0  0  0 15  0  0  0
  Virginia        0  0  0  0 15  0  0  0  0  0
  Washington      0  0  0  0  0  0  0 15  0  0
  West Virginia   0  0  0  0  0  0  0  0  0 15
  Wisconsin      15  0  0  0  0  0  0  0  0  0
  Wyoming         0  0  0 15  0  0  0  0  0  0
> colSums(tab_10)
 1  2  3  4  5  6  7  8  9 10 
75 75 75 75 75 75 75 75 75 75 
> 
> ids_9 <- kfold_split_grouped(K = 9, x = grp)
> (tab_9 <- table(grp, ids_9))
                ids_9
grp               1  2  3  4  5  6  7  8  9
  Alabama         0  0  0  0  0  0  0  0 15
  Alaska          0  0  0  0 15  0  0  0  0
  Arizona         0  0  0  0  0  0  0  0 15
  Arkansas        0  0  0  0  0  0  0  0 15
  California      0  0  0  0  0  0 15  0  0
  Colorado        0 15  0  0  0  0  0  0  0
  Connecticut     0 15  0  0  0  0  0  0  0
  Delaware        0  0  0 15  0  0  0  0  0
  Florida         0  0  0 15  0  0  0  0  0
  Georgia        15  0  0  0  0  0  0  0  0
  Hawaii         15  0  0  0  0  0  0  0  0
  Idaho           0  0  0  0  0  0  0 15  0
  Illinois        0 15  0  0  0  0  0  0  0
  Indiana        15  0  0  0  0  0  0  0  0
  Iowa            0  0  0  0 15  0  0  0  0
  Kansas          0  0 15  0  0  0  0  0  0
  Kentucky        0  0 15  0  0  0  0  0  0
  Louisiana       0  0  0  0  0 15  0  0  0
  Maine           0  0  0  0  0  0  0 15  0
  Maryland        0  0 15  0  0  0  0  0  0
  Massachusetts   0  0  0 15  0  0  0  0  0
  Michigan        0  0  0  0  0  0 15  0  0
  Minnesota       0  0  0  0  0  0 15  0  0
  Mississippi     0  0  0  0  0 15  0  0  0
  Missouri        0  0 15  0  0  0  0  0  0
  Montana         0 15  0  0  0  0  0  0  0
  Nebraska        0  0  0  0  0  0  0  0 15
  Nevada          0  0 15  0  0  0  0  0  0
  New Hampshire   0  0  0  0  0  0  0 15  0
  New Jersey      0 15  0  0  0  0  0  0  0
  New Mexico      0  0  0  0  0  0  0 15  0
  New York        0  0  0  0 15  0  0  0  0
  North Carolina 15  0  0  0  0  0  0  0  0
  North Dakota    0  0  0  0 15  0  0  0  0
  Ohio            0  0  0 15  0  0  0  0  0
  Oklahoma        0  0  0  0  0  0  0  0 15
  Oregon          0  0  0  0  0 15  0  0  0
  Pennsylvania    0 15  0  0  0  0  0  0  0
  Rhode Island   15  0  0  0  0  0  0  0  0
  South Carolina  0  0 15  0  0  0  0  0  0
  South Dakota    0  0  0  0  0 15  0  0  0
  Tennessee       0  0  0  0  0 15  0  0  0
  Texas           0  0  0  0 15  0  0  0  0
  Utah            0  0  0  0  0  0  0 15  0
  Vermont        15  0  0  0  0  0  0  0  0
  Virginia        0  0  0 15  0  0  0  0  0
  Washington      0  0  0 15  0  0  0  0  0
  West Virginia   0  0  0  0  0  0 15  0  0
  Wisconsin       0  0  0  0 15  0  0  0  0
  Wyoming         0  0  0  0  0  0 15  0  0
> colSums(tab_9)
 1  2  3  4  5  6  7  8  9 
90 90 90 90 90 75 75 75 75 
> 
> 
> 
> 
> cleanEx()
> nameEx("loo-datasets")
> ### * loo-datasets
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: loo-datasets
> ### Title: Datasets for loo examples and vignettes
> ### Aliases: loo-datasets Kline milk voice voice_loo
> 
> ### ** Examples
> 
> str(Kline)
'data.frame':	10 obs. of  5 variables:
 $ culture    : Factor w/ 10 levels "Chuuk","Hawaii",..: 4 7 6 10 3 9 1 5 8 2
 $ population : int  1100 1500 3600 4791 7400 8000 9200 13000 17500 275000
 $ contact    : Factor w/ 2 levels "high","low": 2 2 2 1 1 1 1 2 1 2
 $ total_tools: int  13 22 24 43 33 19 40 28 55 71
 $ mean_TU    : num  3.2 4.7 4 5 5 4 3.8 6.6 5.4 6.6
> str(milk)
'data.frame':	29 obs. of  8 variables:
 $ clade         : Factor w/ 4 levels "Ape","New World Monkey",..: 4 4 4 4 4 2 2 2 2 2 ...
 $ species       : Factor w/ 29 levels "A palliata","Alouatta seniculus",..: 11 8 9 10 16 2 1 6 28 27 ...
 $ kcal.per.g    : num  0.49 0.51 0.46 0.48 0.6 0.47 0.56 0.89 0.91 0.92 ...
 $ perc.fat      : num  16.6 19.3 14.1 14.9 27.3 ...
 $ perc.protein  : num  15.4 16.9 16.9 13.2 19.5 ...
 $ perc.lactose  : num  68 63.8 69 71.9 53.2 ...
 $ mass          : num  1.95 2.09 2.51 1.62 2.19 5.25 5.37 2.51 0.71 0.68 ...
 $ neocortex.perc: num  55.2 NA NA NA NA ...
> 
> 
> 
> 
> cleanEx()
> nameEx("loo")
> ### * loo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: loo
> ### Title: Efficient approximate leave-one-out cross-validation (LOO)
> ### Aliases: loo loo.array loo.matrix loo.function loo_i is.loo is.psis_loo
> 
> ### ** Examples
> 
> ### Array and matrix methods (using example objects included with loo package)
> # Array method
> LLarr <- example_loglik_array()
> rel_n_eff <- relative_eff(exp(LLarr))
> loo(LLarr, r_eff = rel_n_eff, cores = 2)

Computed from 1000 by 32 log-likelihood matrix.

         Estimate  SE
elpd_loo    -83.6 4.3
p_loo         3.3 1.2
looic       167.2 8.6
------
MCSE of elpd_loo is 0.1.
MCSE and ESS estimates assume MCMC draws (r_eff in [0.6, 1.0]).

All Pareto k estimates are good (k < 0.67).
See help('pareto-k-diagnostic') for details.
> 
> # Matrix method
> LLmat <- example_loglik_matrix()
> rel_n_eff <- relative_eff(exp(LLmat), chain_id = rep(1:2, each = 500))
> loo(LLmat, r_eff = rel_n_eff, cores = 2)

Computed from 1000 by 32 log-likelihood matrix.

         Estimate  SE
elpd_loo    -83.6 4.3
p_loo         3.3 1.2
looic       167.2 8.6
------
MCSE of elpd_loo is 0.1.
MCSE and ESS estimates assume MCMC draws (r_eff in [0.6, 1.0]).

All Pareto k estimates are good (k < 0.67).
See help('pareto-k-diagnostic') for details.
> 
> 
> ### Using log-likelihood function instead of array or matrix
> set.seed(124)
> 
> # Simulate data and draw from posterior
> N <- 50; K <- 10; S <- 100; a0 <- 3; b0 <- 2
> p <- rbeta(1, a0, b0)
> y <- rbinom(N, size = K, prob = p)
> a <- a0 + sum(y); b <- b0 + N * K - sum(y)
> fake_posterior <- as.matrix(rbeta(S, a, b))
> dim(fake_posterior) # S x 1
[1] 100   1
> fake_data <- data.frame(y,K)
> dim(fake_data) # N x 2
[1] 50  2
> 
> llfun <- function(data_i, draws) {
+   # each time called internally within loo the arguments will be equal to:
+   # data_i: ith row of fake_data (fake_data[i,, drop=FALSE])
+   # draws: entire fake_posterior matrix
+   dbinom(data_i$y, size = data_i$K, prob = draws, log = TRUE)
+ }
> 
> # Use the loo_i function to check that llfun works on a single observation
> # before running on all obs. For example, using the 3rd obs in the data:
> loo_3 <- loo_i(i = 3, llfun = llfun, data = fake_data, draws = fake_posterior)
> print(loo_3$pointwise[, "elpd_loo"])
 elpd_loo 
-1.267103 
> 
> # Use loo.function method (default r_eff=1 is used as this posterior not obtained via MCMC)
> loo_with_fn <- loo(llfun, draws = fake_posterior, data = fake_data)
> 
> # If we look at the elpd_loo contribution from the 3rd obs it should be the
> # same as what we got above with the loo_i function and i=3:
> print(loo_with_fn$pointwise[3, "elpd_loo"])
 elpd_loo 
-1.267103 
> print(loo_3$pointwise[, "elpd_loo"])
 elpd_loo 
-1.267103 
> 
> # Check that the loo.matrix method gives same answer as loo.function method
> log_lik_matrix <- sapply(1:N, function(i) {
+   llfun(data_i = fake_data[i,, drop=FALSE], draws = fake_posterior)
+ })
> loo_with_mat <- loo(log_lik_matrix)
> all.equal(loo_with_mat$estimates, loo_with_fn$estimates) # should be TRUE!
[1] TRUE
> 
> 
> ## Not run: 
> ##D ### For package developers: defining loo methods
> ##D 
> ##D # An example of a possible loo method for 'stanfit' objects (rstan package).
> ##D # A similar method is included in the rstan package.
> ##D # In order for users to be able to call loo(stanfit) instead of
> ##D # loo.stanfit(stanfit) the NAMESPACE needs to be handled appropriately
> ##D # (roxygen2 and devtools packages are good for that).
> ##D #
> ##D loo.stanfit <-
> ##D  function(x,
> ##D          pars = "log_lik",
> ##D          ...,
> ##D          save_psis = FALSE,
> ##D          cores = getOption("mc.cores", 1)) {
> ##D   stopifnot(length(pars) == 1L)
> ##D   LLarray <- loo::extract_log_lik(stanfit = x,
> ##D                                   parameter_name = pars,
> ##D                                   merge_chains = FALSE)
> ##D   r_eff <- loo::relative_eff(x = exp(LLarray), cores = cores)
> ##D   loo::loo.array(LLarray,
> ##D                  r_eff = r_eff,
> ##D                  cores = cores,
> ##D                  save_psis = save_psis)
> ##D }
> ## End(Not run)
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("loo_compare")
> ### * loo_compare
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: loo_compare
> ### Title: Model comparison
> ### Aliases: loo_compare loo_compare.default print.compare.loo
> ###   print.compare.loo_ss
> 
> ### ** Examples
> 
> # very artificial example, just for demonstration!
> LL <- example_loglik_array()
> loo1 <- loo(LL)     # should be worst model when compared
> loo2 <- loo(LL + 1) # should be second best model when compared
> loo3 <- loo(LL + 2) # should be best model when compared
> 
> comp <- loo_compare(loo1, loo2, loo3)
> print(comp, digits = 2)
       elpd_diff se_diff
model3   0.00      0.00 
model2 -32.00      0.00 
model1 -64.00      0.00 
> 
> # show more details with simplify=FALSE
> # (will be the same for all models in this artificial example)
> print(comp, simplify = FALSE, digits = 3)
       elpd_diff se_diff elpd_loo se_elpd_loo p_loo   se_p_loo looic   se_looic
model3   0.000     0.000 -19.589    4.284       3.329   1.152   39.178   8.568 
model2 -32.000     0.000 -51.589    4.284       3.329   1.152  103.178   8.568 
model1 -64.000     0.000 -83.589    4.284       3.329   1.152  167.178   8.568 
> 
> # can use a list of objects with custom names
> # will use apple, banana, and cherry, as the names in the output
> loo_compare(list("apple" = loo1, "banana" = loo2, "cherry" = loo3))
       elpd_diff se_diff
cherry   0.0       0.0  
banana -32.0       0.0  
apple  -64.0       0.0  
> 
> ## Not run: 
> ##D # works for waic (and kfold) too
> ##D loo_compare(waic(LL), waic(LL - 10))
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("loo_model_weights")
> ### * loo_model_weights
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: loo_model_weights
> ### Title: Model averaging/weighting via stacking or pseudo-BMA weighting
> ### Aliases: loo_model_weights loo_model_weights.default stacking_weights
> ###   pseudobma_weights
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ### Demonstrating usage after fitting models with RStan
> ##D library(rstan)
> ##D 
> ##D # generate fake data from N(0,1).
> ##D N <- 100
> ##D y <- rnorm(N, 0, 1)
> ##D 
> ##D # Suppose we have three models: N(-1, sigma), N(0.5, sigma) and N(0.6,sigma).
> ##D stan_code <- "
> ##D   data {
> ##D     int N;
> ##D     vector[N] y;
> ##D     real mu_fixed;
> ##D   }
> ##D   parameters {
> ##D     real<lower=0> sigma;
> ##D   }
> ##D   model {
> ##D     sigma ~ exponential(1);
> ##D     y ~ normal(mu_fixed, sigma);
> ##D   }
> ##D   generated quantities {
> ##D     vector[N] log_lik;
> ##D     for (n in 1:N) log_lik[n] = normal_lpdf(y[n]| mu_fixed, sigma);
> ##D   }"
> ##D 
> ##D mod <- stan_model(model_code = stan_code)
> ##D fit1 <- sampling(mod, data=list(N=N, y=y, mu_fixed=-1))
> ##D fit2 <- sampling(mod, data=list(N=N, y=y, mu_fixed=0.5))
> ##D fit3 <- sampling(mod, data=list(N=N, y=y, mu_fixed=0.6))
> ##D model_list <- list(fit1, fit2, fit3)
> ##D log_lik_list <- lapply(model_list, extract_log_lik)
> ##D 
> ##D # optional but recommended
> ##D r_eff_list <- lapply(model_list, function(x) {
> ##D   ll_array <- extract_log_lik(x, merge_chains = FALSE)
> ##D   relative_eff(exp(ll_array))
> ##D })
> ##D 
> ##D # stacking method:
> ##D wts1 <- loo_model_weights(
> ##D   log_lik_list,
> ##D   method = "stacking",
> ##D   r_eff_list = r_eff_list,
> ##D   optim_control = list(reltol=1e-10)
> ##D )
> ##D print(wts1)
> ##D 
> ##D # can also pass a list of psis_loo objects to avoid recomputing loo
> ##D loo_list <- lapply(1:length(log_lik_list), function(j) {
> ##D   loo(log_lik_list[[j]], r_eff = r_eff_list[[j]])
> ##D })
> ##D 
> ##D wts2 <- loo_model_weights(
> ##D   loo_list,
> ##D   method = "stacking",
> ##D   optim_control = list(reltol=1e-10)
> ##D )
> ##D all.equal(wts1, wts2)
> ##D 
> ##D # can provide names to be used in the results
> ##D loo_model_weights(setNames(loo_list, c("A", "B", "C")))
> ##D 
> ##D 
> ##D # pseudo-BMA+ method:
> ##D set.seed(1414)
> ##D loo_model_weights(loo_list, method = "pseudobma")
> ##D 
> ##D # pseudo-BMA method (set BB = FALSE):
> ##D loo_model_weights(loo_list, method = "pseudobma", BB = FALSE)
> ##D 
> ##D # calling stacking_weights or pseudobma_weights directly
> ##D lpd1 <- loo(log_lik_list[[1]], r_eff = r_eff_list[[1]])$pointwise[,1]
> ##D lpd2 <- loo(log_lik_list[[2]], r_eff = r_eff_list[[2]])$pointwise[,1]
> ##D lpd3 <- loo(log_lik_list[[3]], r_eff = r_eff_list[[3]])$pointwise[,1]
> ##D stacking_weights(cbind(lpd1, lpd2, lpd3))
> ##D pseudobma_weights(cbind(lpd1, lpd2, lpd3))
> ##D pseudobma_weights(cbind(lpd1, lpd2, lpd3), BB = FALSE)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("loo_moment_match")
> ### * loo_moment_match
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: loo_moment_match
> ### Title: Moment matching for efficient approximate leave-one-out
> ###   cross-validation (LOO)
> ### Aliases: loo_moment_match loo_moment_match.default
> 
> ### ** Examples
> 
> # See the vignette for loo_moment_match()
> 
> 
> 
> cleanEx()
> nameEx("loo_predictive_metric")
> ### * loo_predictive_metric
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: loo_predictive_metric
> ### Title: Estimate leave-one-out predictive performance..
> ### Aliases: loo_predictive_metric loo_predictive_metric.matrix
> 
> ### ** Examples
> 
> 
> 
> 
> cleanEx()
> nameEx("nlist")
> ### * nlist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nlist
> ### Title: Named lists
> ### Aliases: nlist
> ### Keywords: internal
> 
> ### ** Examples
> 
> 
> # All variables already defined
> a <- rnorm(100)
> b <- mat.or.vec(10, 3)
> nlist(a,b)
$a
  [1] -0.626453811  0.183643324 -0.835628612  1.595280802  0.329507772
  [6] -0.820468384  0.487429052  0.738324705  0.575781352 -0.305388387
 [11]  1.511781168  0.389843236 -0.621240581 -2.214699887  1.124930918
 [16] -0.044933609 -0.016190263  0.943836211  0.821221195  0.593901321
 [21]  0.918977372  0.782136301  0.074564983 -1.989351696  0.619825748
 [26] -0.056128740 -0.155795507 -1.470752384 -0.478150055  0.417941560
 [31]  1.358679552 -0.102787727  0.387671612 -0.053805041 -1.377059557
 [36] -0.414994563 -0.394289954 -0.059313397  1.100025372  0.763175748
 [41] -0.164523596 -0.253361680  0.696963375  0.556663199 -0.688755695
 [46] -0.707495157  0.364581962  0.768532925 -0.112346212  0.881107726
 [51]  0.398105880 -0.612026393  0.341119691 -1.129363096  1.433023702
 [56]  1.980399899 -0.367221476 -1.044134626  0.569719627 -0.135054604
 [61]  2.401617761 -0.039240003  0.689739362  0.028002159 -0.743273209
 [66]  0.188792300 -1.804958629  1.465554862  0.153253338  2.172611670
 [71]  0.475509529 -0.709946431  0.610726353 -0.934097632 -1.253633400
 [76]  0.291446236 -0.443291873  0.001105352  0.074341324 -0.589520946
 [81] -0.568668733 -0.135178615  1.178086997 -1.523566800  0.593946188
 [86]  0.332950371  1.063099837 -0.304183924  0.370018810  0.267098791
 [91] -0.542520031  1.207867806  1.160402616  0.700213650  1.586833455
 [96]  0.558486426 -1.276592208 -0.573265414 -1.224612615 -0.473400636

$b
      [,1] [,2] [,3]
 [1,]    0    0    0
 [2,]    0    0    0
 [3,]    0    0    0
 [4,]    0    0    0
 [5,]    0    0    0
 [6,]    0    0    0
 [7,]    0    0    0
 [8,]    0    0    0
 [9,]    0    0    0
[10,]    0    0    0

> 
> # Define some variables in the call and take the rest from the environment
> nlist(a, b, veggies = c("lettuce", "spinach"), fruits = c("banana", "papaya"))
$a
  [1] -0.626453811  0.183643324 -0.835628612  1.595280802  0.329507772
  [6] -0.820468384  0.487429052  0.738324705  0.575781352 -0.305388387
 [11]  1.511781168  0.389843236 -0.621240581 -2.214699887  1.124930918
 [16] -0.044933609 -0.016190263  0.943836211  0.821221195  0.593901321
 [21]  0.918977372  0.782136301  0.074564983 -1.989351696  0.619825748
 [26] -0.056128740 -0.155795507 -1.470752384 -0.478150055  0.417941560
 [31]  1.358679552 -0.102787727  0.387671612 -0.053805041 -1.377059557
 [36] -0.414994563 -0.394289954 -0.059313397  1.100025372  0.763175748
 [41] -0.164523596 -0.253361680  0.696963375  0.556663199 -0.688755695
 [46] -0.707495157  0.364581962  0.768532925 -0.112346212  0.881107726
 [51]  0.398105880 -0.612026393  0.341119691 -1.129363096  1.433023702
 [56]  1.980399899 -0.367221476 -1.044134626  0.569719627 -0.135054604
 [61]  2.401617761 -0.039240003  0.689739362  0.028002159 -0.743273209
 [66]  0.188792300 -1.804958629  1.465554862  0.153253338  2.172611670
 [71]  0.475509529 -0.709946431  0.610726353 -0.934097632 -1.253633400
 [76]  0.291446236 -0.443291873  0.001105352  0.074341324 -0.589520946
 [81] -0.568668733 -0.135178615  1.178086997 -1.523566800  0.593946188
 [86]  0.332950371  1.063099837 -0.304183924  0.370018810  0.267098791
 [91] -0.542520031  1.207867806  1.160402616  0.700213650  1.586833455
 [96]  0.558486426 -1.276592208 -0.573265414 -1.224612615 -0.473400636

$b
      [,1] [,2] [,3]
 [1,]    0    0    0
 [2,]    0    0    0
 [3,]    0    0    0
 [4,]    0    0    0
 [5,]    0    0    0
 [6,]    0    0    0
 [7,]    0    0    0
 [8,]    0    0    0
 [9,]    0    0    0
[10,]    0    0    0

$veggies
[1] "lettuce" "spinach"

$fruits
[1] "banana" "papaya"

> 
> 
> 
> 
> cleanEx()
> nameEx("pointwise")
> ### * pointwise
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pointwise
> ### Title: Convenience function for extracting pointwise estimates
> ### Aliases: pointwise pointwise.loo
> 
> ### ** Examples
> 
> x <- loo(example_loglik_array())
> pointwise(x, "elpd_loo")
 [1] -2.372054 -2.132756 -2.337100 -2.177556 -2.088849 -2.112027 -2.920085
 [8] -3.038168 -2.385516 -2.091878 -2.150381 -2.138015 -2.090231 -2.281848
[15] -2.241406 -2.448014 -4.517458 -4.989572 -2.330323 -4.711113 -2.466241
[22] -2.562420 -2.840067 -2.749268 -2.420624 -2.129352 -2.112648 -2.240625
[29] -3.220368 -2.505142 -2.642838 -2.145284
> 
> 
> 
> 
> cleanEx()
> nameEx("psis")
> ### * psis
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: psis
> ### Title: Pareto smoothed importance sampling (PSIS)
> ### Aliases: psis psis.array psis.matrix psis.default is.psis is.sis is.tis
> 
> ### ** Examples
> 
> log_ratios <- -1 * example_loglik_array()
> r_eff <- relative_eff(exp(-log_ratios))
> psis_result <- psis(log_ratios, r_eff = r_eff)
> str(psis_result)
List of 2
 $ log_weights: num [1:1000, 1:32] 2.37 2.12 2.24 2.41 2.25 ...
 $ diagnostics:List of 3
  ..$ pareto_k: num [1:32] 0.0447 -0.0593 0.0696 -0.052 -0.1159 ...
  ..$ n_eff   : num [1:32] 901 923 929 896 895 ...
  ..$ r_eff   : num [1:32] 0.933 0.939 0.968 0.913 0.911 ...
 - attr(*, "norm_const_log")= num [1:32] 9.28 9.04 9.25 9.09 9 ...
 - attr(*, "tail_len")= num [1:32] 99 98 97 100 100 102 99 100 103 98 ...
 - attr(*, "r_eff")= num [1:32] 0.933 0.939 0.968 0.913 0.911 ...
 - attr(*, "dims")= int [1:2] 1000 32
 - attr(*, "method")= chr "psis"
 - attr(*, "class")= chr [1:3] "psis" "importance_sampling" "list"
> plot(psis_result)
> 
> # extract smoothed weights
> lw <- weights(psis_result) # default args are log=TRUE, normalize=TRUE
> ulw <- weights(psis_result, normalize=FALSE) # unnormalized log-weights
> 
> w <- weights(psis_result, log=FALSE) # normalized weights (not log-weights)
> uw <- weights(psis_result, log=FALSE, normalize = FALSE) # unnormalized weights
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("relative_eff")
> ### * relative_eff
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: relative_eff
> ### Title: Convenience function for computing relative efficiencies
> ### Aliases: relative_eff relative_eff.default relative_eff.matrix
> ###   relative_eff.array relative_eff.function
> ###   relative_eff.importance_sampling
> 
> ### ** Examples
> 
> LLarr <- example_loglik_array()
> LLmat <- example_loglik_matrix()
> dim(LLarr)
[1] 500   2  32
> dim(LLmat)
[1] 1000   32
> 
> rel_n_eff_1 <- relative_eff(exp(LLarr))
> rel_n_eff_2 <- relative_eff(exp(LLmat), chain_id = rep(1:2, each = 500))
> all.equal(rel_n_eff_1, rel_n_eff_2)
[1] TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("sis")
> ### * sis
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sis
> ### Title: Standard importance sampling (SIS)
> ### Aliases: sis sis.array sis.matrix sis.default
> 
> ### ** Examples
> 
> log_ratios <- -1 * example_loglik_array()
> r_eff <- relative_eff(exp(-log_ratios))
> sis_result <- sis(log_ratios, r_eff = r_eff)
> str(sis_result)
List of 2
 $ log_weights: num [1:1000, 1:32] 2.37 2.12 2.24 2.41 2.25 ...
 $ diagnostics:List of 3
  ..$ pareto_k: num [1:32] 0 0 0 0 0 0 0 0 0 0 ...
  ..$ n_eff   : num [1:32] 901 923 930 896 896 ...
  ..$ r_eff   : num [1:32] 0.933 0.939 0.968 0.913 0.911 ...
 - attr(*, "norm_const_log")= num [1:32] 9.28 9.04 9.24 9.09 9 ...
 - attr(*, "tail_len")= num [1:32] 99 98 97 100 100 102 99 100 103 98 ...
 - attr(*, "r_eff")= num [1:32] 0.933 0.939 0.968 0.913 0.911 ...
 - attr(*, "dims")= int [1:2] 1000 32
 - attr(*, "method")= chr "sis"
 - attr(*, "class")= chr [1:3] "sis" "importance_sampling" "list"
> 
> # extract smoothed weights
> lw <- weights(sis_result) # default args are log=TRUE, normalize=TRUE
> ulw <- weights(sis_result, normalize=FALSE) # unnormalized log-weights
> 
> w <- weights(sis_result, log=FALSE) # normalized weights (not log-weights)
> uw <- weights(sis_result, log=FALSE, normalize = FALSE) # unnormalized weights
> 
> 
> 
> 
> cleanEx()
> nameEx("tis")
> ### * tis
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tis
> ### Title: Truncated importance sampling (TIS)
> ### Aliases: tis tis.array tis.matrix tis.default
> 
> ### ** Examples
> 
> log_ratios <- -1 * example_loglik_array()
> r_eff <- relative_eff(exp(-log_ratios))
> tis_result <- tis(log_ratios, r_eff = r_eff)
> str(tis_result)
List of 2
 $ log_weights: num [1:1000, 1:32] 2.37 2.12 2.24 2.41 2.25 ...
 $ diagnostics:List of 3
  ..$ pareto_k: num [1:32] 0 0 0 0 0 0 0 0 0 0 ...
  ..$ n_eff   : num [1:32] 901 923 930 896 896 ...
  ..$ r_eff   : num [1:32] 0.933 0.939 0.968 0.913 0.911 ...
 - attr(*, "norm_const_log")= num [1:32] 9.28 9.04 9.24 9.09 9 ...
 - attr(*, "tail_len")= num [1:32] 99 98 97 100 100 102 99 100 103 98 ...
 - attr(*, "r_eff")= num [1:32] 0.933 0.939 0.968 0.913 0.911 ...
 - attr(*, "dims")= int [1:2] 1000 32
 - attr(*, "method")= chr "tis"
 - attr(*, "class")= chr [1:3] "tis" "importance_sampling" "list"
> 
> # extract smoothed weights
> lw <- weights(tis_result) # default args are log=TRUE, normalize=TRUE
> ulw <- weights(tis_result, normalize=FALSE) # unnormalized log-weights
> 
> w <- weights(tis_result, log=FALSE) # normalized weights (not log-weights)
> uw <- weights(tis_result, log=FALSE, normalize = FALSE) # unnormalized weights
> 
> 
> 
> 
> cleanEx()
> nameEx("waic")
> ### * waic
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: waic
> ### Title: Widely applicable information criterion (WAIC)
> ### Aliases: waic waic.array waic.matrix waic.function is.waic
> 
> ### ** Examples
> 
> ### Array and matrix methods
> LLarr <- example_loglik_array()
> dim(LLarr)
[1] 500   2  32
> 
> LLmat <- example_loglik_matrix()
> dim(LLmat)
[1] 1000   32
> 
> waic_arr <- waic(LLarr)
Warning: 
3 (9.4%) p_waic estimates greater than 0.4. We recommend trying loo instead.
> waic_mat <- waic(LLmat)
Warning: 
3 (9.4%) p_waic estimates greater than 0.4. We recommend trying loo instead.
> identical(waic_arr, waic_mat)
[1] TRUE
> 
> 
> ## Not run: 
> ##D log_lik1 <- extract_log_lik(stanfit1)
> ##D log_lik2 <- extract_log_lik(stanfit2)
> ##D (waic1 <- waic(log_lik1))
> ##D (waic2 <- waic(log_lik2))
> ##D print(compare(waic1, waic2), digits = 2)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("weights.importance_sampling")
> ### * weights.importance_sampling
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: weights.importance_sampling
> ### Title: Extract importance sampling weights
> ### Aliases: weights.importance_sampling
> 
> ### ** Examples
> 
> # See the examples at help("psis")
> 
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.649 0.084 0.771 0.029 0.067 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
